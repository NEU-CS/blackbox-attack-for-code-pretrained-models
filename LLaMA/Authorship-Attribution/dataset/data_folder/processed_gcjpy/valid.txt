 \n  def is_sym( number ):\n  	num_str = str( number )\n  	num_len = len( num_str )\n  	half_len = int( num_len / 2 )\n  	end = num_str[-half_len:]\n  	rev_end = end[::-1]\n  	start = num_str[:half_len]\n  	equal = rev_end == start \n  	return equal\n  \n  f = open( 'palindromes.out' )\n  \n  numbers = [ int(x) for x in f.read().split() ]\n  \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n  	min, max = [ int(x) for x in raw_input().split() ]\n  	count = 0\n  	for number in numbers:\n  		if min <= number and max >= number:\n  			count += 1\n  \n  	print 'Case #' + str( case ) + ': ' + str( count )\n <CODESPLIT> 0
def build_table():\n  	table = []\n  	for i in range( 0, 31 ):\n  		table.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )\n  \n  	return table\n  \n  \n  def get_max_score( i ):\n  	return max( 0, min( 10, ( i + 2 ) / 3 ) )\n  \n  def get_max_surprise_score( i ):\n  	return min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )\n  \n  def get_max( x, scores, score_needed, num_surprises ):\n  	scores = sorted( scores, reverse=True )\n  	numPass = 0\n  	i = 0;\n  	while ( i < len(scores) ):\n  		if ( x[scores[i]][0] >= score_needed ):\n  			numPass += 1\n  		else:\n  			break\n  		i += 1\n  \n  	while ( i < len(scores) and num_surprises > 0 ):\n  		if ( x[scores[i]][1] >= score_needed ):\n  			numPass += 1\n  			num_surprises -= 1\n  			\n  		i += 1\n  \n  	return numPass\n  \n  x = build_table()\n  \n  num_cases = input()\n  \n  for i in range( 1, num_cases + 1 ):\n  	line = raw_input().split()\n  	num_surprises = int(line[1])\n  	score_needed = int(line[2])\n  	scores_raw = line[3:]\n  \n  	scores = [ int(y) for y in scores_raw ]\n  \n  	print 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )\n <CODESPLIT> 0
 \n  \n  def is_palindrome(num):\n      s = str(num)\n      end_idx = len(s)-1\n      for i in range(len(s)//2):\n          if s[i] != s[end_idx-i]:\n              return False\n      return True\n  \n  def is_valid_base(base):\n      return is_palindrome(base) and is_palindrome(base*base)\n  \n  def process_case(lo, hi):\n      cnt = 0\n      base_lo = math.ceil(math.sqrt(lo))\n      base_hi = math.floor(math.sqrt(hi))\n      for base in range(base_lo, base_hi+1):\n          if is_valid_base(base):\n              cnt += 1\n      return cnt\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          lo,hi = line_of_numbers(next(lines))\n          result = process_case(lo, hi)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('C-small-attempt0')\n <CODESPLIT> 1
 \n  def threshold(p, maxdiff):\n      minval = max(p - maxdiff, 0)\n      return p + minval + minval\n  \n  def process_case(numdata):\n      N,S,p = numdata[0:3]\n      scores = numdata[3:]\n      thre_normal = threshold(p, 1)\n      thre_surprise = threshold(p, 2)\n      result = 0\n      for tot in scores:\n          if tot >= thre_normal:\n              result += 1\n          elif S > 0 and tot >= thre_surprise:\n              result += 1\n              S -= 1\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          result = process_case(line_of_numbers(next(lines)))\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('B-small-attempt0')\n <CODESPLIT> 1
 \n  '''\n  Limits\n  \n  Small dataset       1 <= T <= 100, 1 <= A <= B <= 1000.\n  First large dataset 1 <= T <= 10000. 1 <= A <= B <= 1014.\n  Second large dataset    1 <= T <= 1000. 1 <= A <= B <= 10100.\n  \n  Sample\n  *** Input \n  3\n  1 4\n  10 120\n  100 1000\n   	\n  *** Output \n  Case #1: 2\n  Case #2: 0\n  Case #3: 2\n  \n  \n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  pal_sqr_roots = '''1 \n  2 \n  3 \n  11 \n  22 \n  26 \n  101 \n  111 \n  121 \n  202 \n  212 \n  264 \n  307 \n  836 \n  1001 \n  1111 \n  2002 \n  2285 \n  2636 \n  10001 \n  10101 \n  10201 \n  11011 \n  11111 \n  11211 \n  20002 \n  20102 \n  22865 \n  24846 \n  30693 \n  100001 \n  101101 \n  110011 \n  111111 \n  200002 \n  798644 \n  1000001 \n  1001001 \n  1002001 \n  1010101 \n  1011101 \n  1012101 \n  1042151 \n  1100011 \n  1101011 \n  1102011 \n  1109111 \n  1110111 \n  1111111 \n  1270869 \n  2000002 \n  2001002 \n  2012748 \n  2294675 \n  3069307 \n  10000001 \n  10011001 \n  10100101 \n  10111101 \n  11000011 \n  11011011 \n  11100111 \n  11111111 \n  11129361 \n  12028229 \n  12866669 \n  20000002 \n  30001253 \n  64030648 \n  100000001 \n  100010001 \n  100020001 \n  100101001 \n  100111001 \n  100121001 \n  101000101 \n  101010101 \n  101020101 \n  101101101 \n  101111101 \n  110000011 \n  110010011 \n  110020011 \n  110091011 \n  110101011 \n  110111011 \n  111000111 \n  111010111 \n  111091111 \n  111101111 \n  111111111 \n  200000002 \n  200010002 \n  306930693 \n  1000000001 \n  1000110001 \n  1001001001 \n  1001111001 \n  1010000101 \n  1010110101 \n  1011001101 \n  1011111101 \n  1100000011 \n  1100110011 \n  1101001011 \n  1101111011 \n  1110000111 \n  1110110111 \n  1111001111 \n  2000000002 \n  2062386218 \n  2481623254 \n  10000000001 \n  10000100001 \n  10000200001 \n  10001010001 \n  10001110001 \n  10001210001 \n  10010001001 \n  10010101001 \n  10010201001 \n  10011011001 \n  10011111001 \n  10100000101 \n  10100100101 \n  10100200101 \n  10101010101 \n  10101110101 \n  10106064399 \n  10109901101 \n  10110001101 \n  10110101101 \n  10110911101 \n  10111011101 \n  10111111101 \n  10207355549 \n  11000000011 \n  11000100011 \n  11000200011 \n  11000910011 \n  11001010011 \n  11001110011 \n  11010001011 \n  11010101011 \n  11010911011 \n  11011011011 \n  11011111011 \n  11100000111 \n  11100100111 \n  11100910111 \n  11101010111 \n  11101110111 \n  11110001111 \n  11110101111 \n  13579355059 \n  20000000002 \n  20000100002 \n  22865150135 \n  30101273647 \n  30693069307 \n  83163115486 \n  100000000001 \n  100001100001 \n  100010010001 \n  100011110001 \n  100100001001 \n  100101101001 \n  100110011001 \n  100111111001 \n  101000000101 \n  101001100101 \n  101010010101 \n  101011110101 \n  101100001101 \n  101101101101 \n  101110011101 \n  101116809851 \n  110000000011 \n  110001100011 \n  110010010011 \n  110011110011 \n  110100001011 \n  110101101011 \n  110110011011 \n  111000000111 \n  111001100111 \n  111010010111 \n  111100001111 \n  111283619361 \n  112247658961 \n  128817084669 \n  200000000002 \n  1000000000001 \n  1000001000001 \n  1000002000001 \n  1000010100001 \n  1000011100001 \n  1000012100001 \n  1000100010001 \n  1000101010001 \n  1000102010001 \n  1000110110001 \n  1000111110001 \n  1001000001001 \n  1001001001001 \n  1001002001001 \n  1001010101001 \n  1001011101001 \n  1001100011001 \n  1001101011001 \n  1001110111001 \n  1001111111001 \n  1010000000101 \n  1010001000101 \n  1010002000101 \n  1010010100101 \n  1010011100101 \n  1010099010101 \n  1010100010101 \n  1010101010101 \n  1010109110101 \n  1010110110101 \n  1010111110101 \n  1011000001101 \n  1011001001101 \n  1011010101101 \n  1011011101101 \n  1011099011101 \n  1011100011101 \n  1011101011101 \n  1100000000011 \n  1100001000011 \n  1100002000011 \n  1100009100011 \n  1100010100011 \n  1100011100011 \n  1100100010011 \n  1100101010011 \n  1100110110011 \n  1100111110011 \n  1101000001011 \n  1101001001011 \n  1101009101011 \n  1101010101011 \n  1101011101011 \n  1101100011011 \n  1101101011011 \n  1110000000111 \n  1110001000111 \n  1110009100111 \n  1110010100111 \n  1110011100111 \n  1110100010111 \n  1110101010111 \n  1111000001111 \n  1111001001111 \n  1349465117841 \n  2000000000002 \n  2000001000002 \n  2149099165358 \n  2634812417864 \n  3069306930693 \n  6360832925898 \n  10000000000001 \n  10000011000001 \n  10000100100001 \n  10000111100001 \n  10001000010001 \n  10001011010001 \n  10001100110001 \n  10001111110001 \n  10010000001001 \n  10010011001001 \n  10010100101001 \n  10010111101001 \n  10011000011001 \n  10011011011001 \n  10011100111001 \n  10100000000101 \n  10100011000101 \n  10100100100101 \n  10100111100101 \n  10101000010101 \n  10101011010101 \n  10101100110101 \n  10110000001101 \n  10110011001101 \n  10110100101101 \n  10111000011101 \n  11000000000011 \n  11000011000011 \n  11000100100011 \n  11000111100011 \n  11001000010011 \n  11001011010011 \n  11001100110011 \n  11010000001011 \n  11010011001011 \n  11010100101011 \n  11011000011011 \n  11100000000111 \n  11100011000111 \n  11100100100111 \n  11101000010111 \n  11110000001111 \n  20000000000002 \n  30395080190573 \n  69800670077028 \n  98275825201587 \n  100000000000001 \n  100000010000001 \n  100000020000001 \n  100000101000001 \n  100000111000001 \n  100000121000001 \n  100001000100001 \n  100001010100001 \n  100001020100001 \n  100001101100001 \n  100001111100001 \n  100010000010001 \n  100010010010001 \n  100010020010001 \n  100010101010001 \n  100010111010001 \n  100011000110001 \n  100011010110001 \n  100011101110001 \n  100011111110001 \n  100100000001001 \n  100100010001001 \n  100100020001001 \n  100100101001001 \n  100100111001001 \n  100101000101001 \n  100101010101001 \n  100101101101001 \n  100101111101001 \n  100109990011001 \n  100110000011001 \n  100110010011001 \n  100110091011001 \n  100110101011001 \n  100110111011001 \n  100110990111001 \n  100111000111001 \n  100111010111001 \n  101000000000101 \n  101000010000101 \n  101000020000101 \n  101000101000101 \n  101000111000101 \n  101000990100101 \n  101001000100101 \n  101001010100101 \n  101001091100101 \n  101001101100101 \n  101001111100101 \n  101010000010101 \n  101010010010101 \n  101010101010101 \n  101010111010101 \n  101010990110101 \n  101011000110101 \n  101011010110101 \n  101100000001101 \n  101100010001101 \n  101100101001101 \n  101100111001101 \n  101101000101101 \n  101101010101101 \n  101110000011101 \n  101110010011101 \n  110000000000011 \n  110000010000011 \n  110000020000011 \n  110000091000011 \n  110000101000011 \n  110000111000011 \n  110001000100011 \n  110001010100011 \n  110001101100011 \n  110001111100011 \n  110010000010011 \n  110010010010011 \n  110010091010011 \n  110010101010011 \n  110010111010011 \n  110011000110011 \n  110011010110011 \n  110100000001011 \n  110100010001011 \n  110100101001011 \n  110100111001011 \n  110101000101011 \n  110101010101011 \n  110110000011011 \n  110110010011011 \n  111000000000111 \n  111000010000111 \n  111000091000111 \n  111000101000111 \n  111000111000111 \n  111001000100111 \n  111001010100111 \n  111010000010111 \n  111010010010111 \n  111100000001111 \n  111100010001111 \n  129610990752569 \n  200000000000002 \n  200000010000002 \n  210786628549538 \n  314155324482867 \n  1000000000000000 \n  1000000110000000 \n  1000001001000000 \n  1000001111000000 \n  1000010000100000 \n  1000010110100000 \n  1000011001100000 \n  1000011111100000 \n  1000100000010000 \n  1000100110010000 \n  1000101001010000 \n  1000101111010000 \n  1000110000110000 \n  1000110110110000 \n  1000111001110000 \n  1001000000001000 \n  1001000110001000 \n  1001001001001000 \n  1001001111001000 \n  1001010000101000 \n  1001010110101000 \n  1001011001101000 \n  1001100000011000 \n  1001100110011000 \n  1001101001011000 \n  1001110000111000 \n  1010000000000100 \n  1010000110000100 \n  1010001001000100 \n  1010001111000100 \n  1010010000100100 \n  1010010110100100 \n  1010011001100100 \n  1010100000010100 \n  1010100110010100 \n  1010101001010100 \n  1010110000110100 \n  1011000000001100 \n  1011000110001100 \n  1011001001001100 \n  1011010000101100 \n  1011100000011100 \n  1100000000000010 \n  1100000110000010 \n  1100001001000010 \n  1100001111000010 \n  1100010000100010 \n  1100010110100010 \n  1100011001100010 \n  1100100000010010 \n  1100100110010010 \n  1100101001010010 \n  1100110000110010 \n  1101000000001010 \n  1101000110001010 \n  1101001001001010 \n  1101010000101010 \n  1101100000011010 \n  1110000000000110 \n  1110000110000110 \n  1110001001000110 \n  1110010000100110 \n  1110100000010110 \n  1111000000001110 \n  2000000000000000 \n  2201019508986470 \n  2564053868197730 \n  3066446727654240 \n  3107974295870660 \n  3138199296186060'''\n  pal_sqr_roots = map(int, pal_sqr_roots.split())\n  \n  \n  \n  def is_palindrome(n):\n      return str(n)[::-1] == str(n)\n  \n  palindromic_roots = [x for x in pal_sqr_roots if is_palindrome(x)]\n  \n  fair_and_square = [x*x for x in palindromic_roots]\n  \n  \n  def get_num_fair_and_square(a, b):\n      return len([x for x in fair_and_square if a <= x <= b])\n  \n  for caseNo in range(1, int(input())+1):\n      a,b = map(int, input().split())\n      print 'Case #%d:' % caseNo, get_num_fair_and_square(a, b)\n  \n <CODESPLIT> 2
 \n  '''\n  Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]\n  At least S of the ti values will be between 2 and 28, inclusive.\n  \n  Small dataset 1 = N = 3.\n  Large dataset 1 = N = 100.\n  \n  Sample Input \n  4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \n  Output \n  Case #1: 3\n  Case #2: 2\n  Case #3: 1\n  Case #4: 3\n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  def maxBestDancers(N, S, p, *Ti):\n      cnt = 0\n      for score in Ti:\n          mx = (score + 2) // 3\n          if mx >= p:\n              cnt += 1\n          elif mx >= p-1 > 0 and S>0:\n              S -= 1\n              cnt += 1\n      return cnt\n  \n  for caseNo in range(1, int(input())+1):\n      print 'Case #%d:' % caseNo,\n      lst = map(int, input().split())\n      print maxBestDancers(*lst)\n  \n <CODESPLIT> 2
 \n  def generateTable(N):\n      msq = range(1, 4) + [11, 22] + [101, 111, 121, 202, 212]\n      nums = revnums = [1, 2]\n  \n      digsums = [1, 4]\n  \n      for i in xrange(2, N+1):\n          a, b, d = [], [], []\n          p = 10**(i-1)\n          for j in xrange(len(nums)):\n              for k in xrange(3):\n                  n, rn, ds = 10*nums[j] + k, revnums[j] + k*p, digsums[j] + k*k\n                  if ds < 5:\n                      a.append(n)\n                      b.append(rn)\n                      d.append(ds)\n                      msq.append(10*p*n + rn) # even length\n                      if i == N:\n                          continue\n                      for l in xrange(3): # odd length\n                          if 2*ds + l*l < 10:\n                              msq.append(100*p*n + 10*p*l + rn)\n          nums, revnums, digsums = a, b, d\n  \n      msq.sort()\n      return msq\n  \n  def getNum(A, B):\n      return bisect_right(tab2, B) - bisect_right(tab2, A-1)\n  \n  N = 10\n  tab = generateTable(N)\n  tab2 = map(lambda n: n**2, tab)\n  \n  T = int(raw_input())\n  for z in xrange(T):\n      A, B = map(int, raw_input().split())\n      print "Case #%d: %d" % (z+1, getNum(A, B))\n <CODESPLIT> 3
T = int(raw_input())\n  \n  for z in xrange(1, T+1):\n      a = map(int, raw_input().split())\n      s, p = a[1:3]\n      a = a[3:]\n      A = 0 if p == 0 else 3*p - 2\n      B = 0 if p == 0 else 1 if p == 1 else 3*p-4\n      x = len(filter(lambda x: x >= A, a))\n      y = len(filter(lambda x: x >= B, a)) - x\n      res = x + min(s, y)\n      print "Case #%d:" % z, res\n <CODESPLIT> 3
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def pal(x):\n      l = list(str(x))\n      l2 = copy.copy(l)\n      l2.reverse()\n      return l == l2\n  \n  for i in range(num):\n      count = 0\n      line = f.readline()\n      a,b = line.split()\n      a = int(a)\n      b = int(b)\n      ma = int(math.sqrt(a))\n      mb = int(math.sqrt(b))+1\n      for j in range(ma,mb+1):\n          q = j*j\n          if q < a or q > b:\n              continue\n          if pal(j) and pal(q):\n              count += 1\n      print 'Case #{}:'.format(i+1), count\n <CODESPLIT> 4
 \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      res = [int(x) for x in f.readline().split()]\n      nrg, nrsup, score = res[0:3]\n      del res[0:3]\n      nrpass = 0\n      nrsuppass = 0\n      for x in res:\n          if score > 1:\n              if x >= 3*score-2:\n                  nrpass += 1\n              elif x >= 3*score-4:\n                  nrsuppass += 1\n          elif score == 1:\n              if x > 0:\n                  nrpass += 1\n          else:\n              nrpass +=1\n      print 'Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass)\n <CODESPLIT> 4
 \n  def ss(t, amap, bmap):\n      s = 0\n      for m in amap:\n          if len(m) == 1 and t == m.keys()[0]:\n              s += m[t]\n              for b in bmap:\n                  if t in b:\n                      b[t] -= 1\n                      if b[t] == 0:\n                          b.pop(t)\n              m.clear()\n      return s           \n  \n  \n  def solve(case, in_lines):\n      out = 'Case #%d: '%case\n   \n      rn, cn = [int(x) for x in in_lines[0].split()]\n      mtx = []\n      for i in xrange(rn):\n          mtx.append([int(x) for x in in_lines[i+1].split()])\n      rmap = [{} for x in xrange(rn)]\n      cmap = [{} for x in xrange(cn)]\n      td = {}\n      \n      for i in xrange(rn):\n          for j in range(cn):\n              k = mtx[i][j]\n              if k in rmap[i]:\n                  rmap[i][k] += 1\n              else:\n                  rmap[i][k] = 1\n              if k in cmap[j]:\n                  cmap[j][k] += 1\n              else:\n                  cmap[j][k] = 1\n              if k in td:\n                  td[k] += 1\n              else:\n                  td[k] = 1\n                  \n      while len(td):\n          k = min(td.keys())\n          sb = ss(k, rmap, cmap)\n          sb += ss(k, cmap, rmap)\n          if sb == 0:\n              break;\n          td[k] -= sb\n          if td[k] == 0:\n              td.pop(k)\n  \n      return out + ('YES' if sb else 'NO')\n  \n  \n  def main(raw):\n      lines = raw.split('\n')\n      n = int(lines[0])\n      ln = 1\n      outs = []\n      for case in xrange(1, n+1):\n          buff = []\n          cl = int(lines[ln].split()[0]) + ln + 1\n          while ln < cl and lines[ln]:\n              buff.append(lines[ln])\n              ln += 1\n          s = solve(case, buff)\n          print s\n          outs.append(s)\n      return '\n'.join(outs)\n      pass\n  \n  if __name__ == '__main__':\n      test_input = """4\n  4 3\n  2 5 2\n  1 1 1\n  2 4 2\n  2 3 2\n  3 3\n  2 1 2\n  1 1 1\n  2 1 2\n  5 5\n  2 2 2 2 2\n  2 1 1 1 2\n  2 1 2 1 2\n  2 1 1 1 2\n  2 2 2 2 2\n  1 3\n  1 2 1"""\n      force_no_file = False\n      in_file_name = '' if force_no_file else 'B-large.in'\n      base_path = 'G:/workspace/py/codejam2013/RQ/'\n      if in_file_name:\n          with open(base_path + in_file_name) as f:\n              raw = f.read()\n      else:\n          raw = test_input\n      out = main(raw)\n      if in_file_name:\n          with open(base_path + in_file_name + '.out', 'w') as f:\n              f.write(out)\n      pass\n <CODESPLIT> 5
 \n  def solve(icase, case_input):\n      case_output = 'Case #%i: '%icase\n      \n      result = 0\n      raw = [int(x) for x in case_input[0].split()]\n      ts = raw[3:]\n      ct = raw[1]\n      n = raw[2]\n      cc = 0\n      for i in ts:\n          if i > 3*n-3:\n              result += 1\n          elif i > max(3*n-5, 0):\n              cc += 1\n      result += min(cc, ct)\n  \n      case_output += '%d'%result\n      \n      return case_output\n  \n  \n  def main():\n      global use_test_data\n      global test_data\n      global input_file\n      global output_file\n      \n      if use_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for icase in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(icase, input)\n          print rslt\n          if not use_test_data:\n              print >> output_file, rslt\n      \n      if not use_test_data:\n          input_file.close()\n          output_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = """4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  """\n      use_test_data = False\n      \n      test_file = 'B-small-attempt0.in'\n      if not use_test_data and '' != test_file:\n          input_file = open(test_file)\n          output_file = open(test_file + '.out', 'w')\n      \n      main()\n <CODESPLIT> 5
 \n  T = input()\n  \n  for n in range(1, T+1):\n  \n      A, B = raw_input().split()\n      A, B = int(A), int(B)\n  \n      j = 0\n      for i in range(A, B+1):\n          s = str(i)\n          m = int(i**.5)\n          if s[-1] in ["1", "4", "5", "6", "9"] and \\n                  (s == "".join(reversed(s))) and \\n                  m**2 == i:\n              s = str(m)\n              if s == "".join(reversed(s)):\n                  j += 1\n  \n  \n      print "Case #%d: %d" % (n, j)\n <CODESPLIT> 6
 \n  T=0 #no. of Test cases\n  for line in fileinput.input():\n      if fileinput.isfirstline():\n          T=int(line)\n          print "no. of test cases:", T\n          continue\n      \n      nums=[int(x) for x in line.split()]\n      N=nums[0] #no. of googlers\n      S=nums[1] #no. of surprising triplets\n      p=nums[2] #max value\n      \n      del nums[:3]\n      count=0\n      for num in nums:\n          quo=num//3\n          rem=num%3\n          if quo >= p:\n              count += 1\n              continue\n          elif quo+1 == p and rem > 0:\n              count += 1\n              continue\n          elif quo+1 ==p and rem == 0 and quo > 0 and S > 0:\n              count += 1\n              S -= 1\n              continue\n          elif quo+2 >= p and rem == 2 and S > 0:\n              count += 1\n              S -= 1\n      \n      print "Case #%(k)i: %(count)i" % {"k":fileinput.lineno()-1,"count":count}\n <CODESPLIT> 6
 \n  fin = open('C-small-attempt0.in', 'r')\n  fout = open('ass3.out', 'w')\n  \n  T = int(fin.readline())\n  \n  def perfsq(n):\n      sq = int(math.sqrt(n))\n      if n == sq * sq:\n          return sq\n      return 0\n  \n  def palindrome(n):\n      s = str(n)\n      return (s == s[::-1])\n  \n  def getpal(n):\n      if n == 1:\n          for i in range(10):\n              yield i\n      else:\n          n2 = n / 2\n          for x in xrange(10 ** (n2 - 1), 10 ** n2):\n              s = str(x)\n              if n % 2:\n                  for i in range(10):\n                      ns = s + str(i) + s[::-1]\n                      yield int(ns)\n              else:\n                  ns = s + s[::-1]\n                  yield int(ns)\n  \n  for i in range(T):\n      A, B = map(int, fin.readline().split())\n  \n      ret = 0\n      for j in range(len(str(A)), len(str(B)) + 1):\n          for x in getpal(j):\n              if x < A:\n                  continue\n              if x > B:\n                  break\n              sq = perfsq(x)\n              if sq and palindrome(sq):\n                  ret += 1\n      fout.write('Case #%i: %i\n' % (i + 1, ret))\n <CODESPLIT> 7
input_file = 'B-small-attempt1.in'\n  output_file = 'b.out'\n  \n  \n  def solvecase(inp):\n  	data = [int(n) for n in inp.split()]\n  	N, S, p = data[0:3]\n  	if p == 0:\n  		return N\n  	t = data[3:]\n  	ret = 0\n  	for br in t:\n  		d, r = br / 3, br % 3\n  		if br == 0 or p - d > 2:\n  			continue\n  		if (d >= p) or (r and (d + 1) >= p):\n  			ret += 1\n  		elif S and (d + max(r, 1)) >= p:\n  			ret += 1\n  			S -= 1\n  	return ret\n  \n  lines = open(input_file, 'r').readlines()\n  out = open(output_file, 'w')\n  \n  for i, l in enumerate(lines[1:]):\n  	sout = 'Case #%i: %i' % (i + 1, solvecase(l))\n  	print sout\n  	out.write(sout + '\n')\n  \n  out.close()\n <CODESPLIT> 7
 a = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]\n  A = a[:10]\n  def subdfs(pre, mid, d, t, n):\n      if d == t:\n          k = long(''.join([pre, mid, pre[::-1]]))\n          k = k * k\n          if k > n:\n              return [1, 0]\n          sqk = str(k)\n          if sqk == sqk[::-1]:\n              A.append(k)\n              return [0, 1]\n          else:\n              return [0, 0]\n      res = subdfs(pre + '0', mid, d + 1, t, n)\n      if res[0]: return res\n      if not res[1]: return res\n      res2 = subdfs(pre + '1', mid, d + 1, t, n)\n      if res2[0]: return [1, res[1] + res2[1]]\n      return [0, res[1] + res2[1]]\n  \n  def dfs(d, n):\n      subdfs('1', '', 0, d, n)\n      subdfs('2' + '0' * d, '', d, d, n)\n      subdfs('1', '0', 0, d, n)\n      subdfs('1', '1', 0, d, n)\n      subdfs('1', '2', 0, d, n)\n      subdfs('2' + '0' * d, '0', d, d, n)\n      subdfs('2' + '0' * d, '1', d, d, n)\n  \n  def solve(pre):\n      read_ints = lambda: map(int, raw_input().split())\n      l, r = read_ints()\n      cl = bisect_left(A, l)\n      cr = bisect_right(A, r)\n      cl_ = cr_ = 0\n      for i in xrange(40):\n          if a[i] < l: cl_ += 1\n      for i in xrange(40):\n          if a[i] <= r: cr_ += 1\n      print pre, cr - cl\n  \n  for k in xrange(1, 48):\n      dfs(k, 10 ** 100 + 1)\n  A.sort()\n  N = int(raw_input())\n  for i in xrange(1, N + 1):\n      solve("Case #%d:" % i)\n <CODESPLIT> 8
T = int(raw_input())\n  for t in xrange(T):\n      line = map(int, raw_input().split())\n      N, S, p = line[0:3]\n      a = line[3:]\n      cnt = 0\n      a.sort(reverse=True)\n      for x in a:\n          if (x + 2) / 3 >= p:\n              cnt += 1\n          elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:\n              cnt += 1\n              S -= 1\n          else:\n              break\n      print "Case #%d: %d" % (t + 1, cnt)\n <CODESPLIT> 8
def isPalindrome(number):\n      strNum = str(number)\n      for i in range(len(strNum)/2 + 1):\n          if strNum[i] != strNum[-1*(i+1)]:\n              return False\n      return True\n  \n  '''for i in range(40):\n      if isPalindrome(i) and isPalindrome(i*i):\n          print i*i\n  '''\n  \n  \n  filename = "C-small-attempt0.in"\n  outputname = filename + "out.txt"\n  \n  inFile = open(filename, 'r')\n  outFile = open(outputname, 'w')\n  \n  \n  fairAndSquareNums = [1,4,9,121,484]\n  \n  numTests = int(inFile.readline())\n  \n  for i in range(numTests):\n      line = inFile.readline().split()\n      count = 0\n      for j in range(int(line[0]), int(line[1])+1):\n          if j in fairAndSquareNums:\n              count += 1\n      outFile.write("Case #" + str(i+1) + ": " + str(count) + '\n')\n      print "Case #" + str(i+1) + ": " + str(count)\n  \n  inFile.close()\n  outFile.close()\n <CODESPLIT> 9
inputFile = open("B-small-attempt0 (3).in", 'r')\n  outputFile = open("dancingOutSmall.txt", 'w')\n  numTests = int(inputFile.readline())\n  \n  def countDancers(n,s,p,totals):\n      guaranteed = 0\n      needSurprise = 0\n      if p == 1:\n          for total in totals:\n              if total != 0:\n                  guaranteed += 1\n          return guaranteed\n      for total in totals:\n          if total >= p*3 - 2:\n              guaranteed += 1\n          elif total >= p*3 - 4:\n              needSurprise += 1\n      if needSurprise > s:\n          return guaranteed + s\n      else:\n          return guaranteed + needSurprise\n  \n  for i in range(numTests):\n      line = inputFile.readline().split()\n      n = int(line[0])\n      s = int(line[1])\n      p = int(line[2])\n      totals = []\n      for j in range(n):\n          totals += [int(line[3+j])]\n      outputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '\n')\n  \n  outputFile.close()\n <CODESPLIT> 9
 \n  n_cases = input()\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def is_palindrome(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  for case in xrange(1, n_cases + 1):\n      a, b = to_ints(raw_input())\n  \n      nums = range(int(b ** .5) + 2)\n      palins = filter(is_palindrome, nums)\n      squares = [x**2 for x in palins]\n      palin_squares = filter(is_palindrome, squares)\n      range_squares = [x for x in palin_squares if a <= x <= b]\n  \n      print "Case #%d: %s" % (case, len(range_squares))\n <CODESPLIT> 10
n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      ins = map(int, raw_input().strip().split())\n      n = ins[0]\n      s = ins[1]\n      p = ins[2]\n      t = ins[3:]\n  \n      out = 0\n      for x in t:\n          if (x + 2) / 3 >= p:\n              out += 1\n          elif s and x > p and p - ((x - p) / 2) <= 2:\n              out += 1\n              s -= 1\n              \n      print "Case #%d: %s" % (case, out)\n <CODESPLIT> 10
'''\n  Created on 13 Apr 2013\n  \n  @author: mengda\n  '''\n  \n  ls = []\n  \n  def isP(num):\n      num = str(int(num))\n      for i in range(len(num) / 2):\n          if num[i] <> num[-1 - i]:\n              return False\n      return True\n  \n  def createP(root, half_digits):\n      root = str(root)\n      for i in range(half_digits):\n          ls[i] = root[i]\n          ls[-1 - i] = root[i]\n      return int(''.join(ls))\n  \n  def process(A, B):\n      rlt = 0\n      a = int(math.ceil(math.sqrt(A)))\n      b = int(math.floor(math.sqrt(B)))\n      str_a = str(a)\n      half_digits = int(math.ceil(len(str_a) / 2.0))\n      root = int(str_a[:half_digits])\n      next_root = 10 ** half_digits\n      digits = len(str_a)\n      for _ in range(digits - len(ls)):\n          ls.append('')\n      while True:\n          if root == next_root:\n              if digits % 2 == 0:\n                  next_root *= 10\n                  half_digits += 1\n              else:\n                  root /= 10\n              digits += 1\n              ls.append('')\n          p = createP(root, half_digits)\n          print p,\n          if p > b:\n              print 'too large'\n              break\n          if isP(math.pow(p, 2)):\n              print 'right one!'\n              rlt += 1\n          else:\n              print \n          root += 1\n      return rlt\n  \n  def process1(A, B):\n      rlt = 0\n      a = int(math.ceil(math.sqrt(A)))\n      b = int(math.floor(math.sqrt(B)))\n      for i in range(a, b + 1):\n          if not isP(i):\n              continue\n          power = math.pow(i, 2)\n          if isP(power):\n              rlt += 1\n      return rlt\n  \n  f = open('C-small-attempt1.in', 'r')\n  T = int(f.readline())\n  outLine = []\n  \n  for i in range(1, T + 1):\n      (A, B) = map(int, f.readline().split())\n      outLine.append('Case #%d: %s\n' % (i, process1(A, B)))\n      print outLine[-1],\n  \n  f.close()\n  outFile = open('C-S.out', 'w')\n  outFile.writelines(outLine)\n  outFile.close()\n <CODESPLIT> 11
'''\n  Created on 2012-4-14\n  \n  @author: hemnd\n  '''\n  def cal(args):\n      rslt = 0\n      N = int(args[0])\n      S = int(args[1])\n      p = int(args[2])\n      for i in range(N):\n          s = int(args[i + 3])\n          e = s / 3\n          r = s % 3\n          if e >= p:\n              rslt += 1\n          elif r == 1:\n              if e + 1 >= p:\n                  rslt += 1\n          elif r == 0:\n              if e == 0:\n                  continue\n              if S > 0 and e + 1 >= p:\n                  rslt += 1\n                  S -= 1\n          elif r == 2:\n              if e + 1 >= p:\n                  rslt += 1\n              elif S > 0 and e + 2 >= p:\n                  rslt += 1\n                  S -= 1\n      return rslt\n  \n  inputFile = open('B-small-attempt0.in', 'r')\n  inputLines = inputFile.readlines()\n  inputFile.close()\n  \n  T = int(inputLines[0])\n  outputLines = []\n  \n  for i in range(1, T + 1):\n      args = inputLines[i].strip().split(' ')\n      outputLines.append('Case #%d: %d\n' % (i, cal(args)))\n      print outputLines[i - 1],\n  \n  outputFile = open('B-small.out', 'w')\n  outputFile.writelines(outputLines)\n  outputFile.close()\n <CODESPLIT> 11
 \n  \n  \n  def next_range(stream):\n      line = stream.readline()\n      if not line:\n          return None\n      return [int(x) for x in line.split()]\n  \n  \n  def is_palindrome(n):\n      n = str(n)\n      return all(n[i] == n[len(n)-1-i] for i in range(len(n) // 2))\n  \n  def mysqrt(n):\n      """Return -1 if not an integer"""\n      rt = int(sqrt(n))\n      return rt if rt * rt == n else -1\n  \n  \n  def is_fas(n):\n      rt = mysqrt(n)\n      return rt != -1 and is_palindrome(n) and is_palindrome(rt)\n  \n  \n  def main():\n      with open('C-small-attempt0.in', encoding='utf-8') as f:\n          f.readline()\n  \n          for case in count(1):\n              r = next_range(f)\n              if r is None:\n                  break\n  \n              cnt = 0\n              for n in range(r[0], r[1] + 1):\n                  if is_fas(n):\n                      cnt += 1\n  \n              print('Case #{}: {}'.format(case, cnt))\n  \n  \n  main()\n <CODESPLIT> 12
 \n  \n  def best(total):\n      """Return the best possible score for the given `total`.  Assume\n      the total is computed by summing exactly three scores (each in the\n      interval of 0 to 10 inclusive) and no score can be 2 points apart\n      \n      Arguments:\n      - `total`:\n      """\n      m = total % 3\n      if m == 2:\n          b = total // 3 + 2\n      else:\n          b = total // 3 + 1\n      if b > 10:\n          b = 10\n      return b\n  \n  def best_non_surprising(total):\n      """Return the best possible score for the given `total`, but\n      assume that there should be no more than 1 point difference\n      between the scores.\n  \n      Arguments:\n      - `total`:\n      """\n      if total % 3 == 0:\n          return total // 3\n      else:\n          return total // 3 + 1\n  \n  def max_num_gte_p(totals, S, p):\n      """Return the maximum number of Googlers that could have had a\n      best result of at least p.\n      \n      Arguments:\n      - `totals`:\n      - `S`: number of surprising triplets of scores\n      - `p`:\n      """\n      res = 0\n      for total in totals:\n          if total == 0:\n              if p == 0:\n                  res += 1\n              continue\n  \n          if best_non_surprising(total) >= p:\n              res += 1\n          elif S > 0 and best(total) >= p:\n              res += 1\n              S -= 1\n  \n      return res\n  \n  def main():\n      with open(sys.argv[1], 'r') as f:\n          f.readline()            # skip T\n  \n          n = 0\n          for line in f:\n              n += 1\n  \n              line = [int(s) for s in line.split()]\n              N = line[0]\n              S = line[1]\n              p = line[2]\n              totals = line[3:]\n  \n              print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 12
 \n  def read(f):\n      return list( int(v) for v in f.readline().split() )\n  \n  def answer(f, X, ans):\n      out = "Case #{}: {}".format(X, ans)\n      f.write(out)\n      f.write("\n")\n      print(out)\n  \n  def testcases(f):\n      T = int(f.readline())\n      for X in range(1, T + 1):\n          A, B = read(f)\n          yield X, A, B\n  \n  def ispalindrome(v):\n      s = str(v)\n      for i in range(len(s) // 2):\n          if s[i] != s[-i-1]:\n              return False\n      return True\n  \n  def main(inf, outf):\n      MAX = 1000\n      fslst = []\n      for i in itertools.count():\n          if ispalindrome(i):\n              squere = i * i\n              print(MAX, squere, ispalindrome(squere))\n              if squere > MAX:\n                  break\n              if ispalindrome(squere):\n                  fslst.append(squere)\n      for X, A, B in testcases(inf):\n          cnt = 0\n          for fs in fslst:\n              if A <= fs <= B:\n                  cnt += 1\n          answer(outf, X, cnt)\n  \n  if __name__=="__main__":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + ".out"\n      with open(infname, "r") as inf:\n          with open(outfname, "w") as outf:\n              main(inf, outf)\n <CODESPLIT> 13
 \n  def testcases():\n      with open(sys.argv[1], "r") as f:\n          f.readline()  # skip number of testcases\n          for X, T in enumerate(f, 1):\n              yield X, [int(t) for t in T.split()]\n  \n  def main():\n      for X, T in testcases():\n          N = T[0]   # the number of Googlers\n          S = T[1]   # the number of surprising triplets of scores\n          p = T[2]   # best result of at least\n  \n          y = 0\n  \n          for t in T[3:]:\n              d, m = divmod(t, 3)\n              if m == 0:\n                  if p <= d:\n                      y += 1\n                  elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:\n                      y += 1\n                      S -= 1\n              elif m == 1:\n                  if p <= d + 1:\n                      y += 1\n              else:\n                  if p <= d + 1:\n                      y += 1\n                  elif p <= d + 2 and S:\n                      y += 1\n                      S -= 1\n  \n          print("Case #{:d}: {:d}".format(X, y))\n  \n  if __name__=="__main__":\n      main()\n <CODESPLIT> 13
 \n  def pal(s):\n      for i in xrange(len(s)/2):\n          if s[i] != s[-i-1]:\n              return False\n      return True\n  \n  def pal2(x, s):\n      return pal(s) and pal(str(x*x))\n  \n  def E(k):\n      return 10**k\n  \n  \n  def CREATE_DATABASE(MAX):\n      def init():\n          yield 1\n          yield 2\n          yield 3\n          yield 11\n          yield 22\n          for i in xrange(1, MAX):\n              yield 1*E(2*i) + 1\n              yield 1*E(2*i+1) + 1\n              yield 2*E(2*i) + 2\n              yield 2*E(2*i) + 2 + 1*E(i)\n              yield 2*E(2*i+1) + 2\n              \n              \n      heap = list(sorted(set(init())))\n      for i in heap:\n          print i\n      heapq.heapify(heap)\n      RES = []\n      try:\n          MAX_X = E(MAX)\n          print "MAX_X", MAX_X\n          while True:\n              x = heapq.heappop(heap)\n              RES.append(x)\n              if x == 3:\n                  continue\n              if x > MAX_X:\n                  break\n              s = str(x)\n              j = len(s) / 2\n              shift = 1 if len(s) == 2*j else 0\n              for i in xrange(j+1, MAX):\n                  n = E(2*i-shift) + 1 + E(i-j) * x\n                  if pal2(n,str(n)):\n                      heapq.heappush(heap, n)\n                  \n      except KeyboardInterrupt:\n          print "stopped while x is", x\n      with open("c.database", 'w') as f:\n          for i in sorted(RES + heap):\n              f.write("%i\n"%i)\n  \n  def READ_DATABASE():\n      with open("c.database", 'r') as f:\n          return sorted(map(lambda x: int(x.strip())**2, f))\n  DB = READ_DATABASE()\n  \n  def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def nrints(N): return [rints() for i in xrange(N)]\n      A, B = rints()\n      i = bisect_left(DB, A) \n      j = bisect_right(DB, B)\n      return j-i\n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write("Case #%i: %s\n" % (i, CASE(IN)))\n  \n  if __name__ == "__main__":\n      RUN(sys.stdin, sys.stdout)\n <CODESPLIT> 14
 \n  \n  \n  D1 = {} # no suprize\n  D2 = {} # surprize\n  for i in xrange(0, 31):\n      D1[i] = D2[i] = -1\n  \n  def precompute():\n      for a in xrange(0, 11):\n          for b in xrange(a, min(a+3,11)):\n              for c in xrange(b, min(a+3,11)):\n                  t = a+b+c\n                  assert a <= b <= c <= a+2 and c <= 11\n                  if c < a+2:\n                      D1[t] = max(D1[t], c)\n                  else: # that is, c == a+2, we have a suprize\n                      D2[t] = max(D2[t], c)\n  \n  \n  precompute()\n  \n  def case(S, P, ts):\n      res_n = 0\n      res_s = 0\n      for t in ts:\n          if D1[t] >= P:\n              res_n+=1\n          elif D2[t]>=P:\n              res_s+=1\n      return (res_n + min(res_s, S))\n  \n  \n  def solve(fin, fout):\n      T = int(fin.readline())\n      for t in xrange(T):\n          nums = map(int, fin.readline().strip().split(" "))\n          N, S, P = nums[:3]\n          ts = nums[3:]\n          assert len(ts) == N    \n          fout.write("Case #%i: %i\n" % (t+1, case(S,P,ts)) )\n      return True\n  \n  if __name__ == "__main__":\n      with open(sys.argv[1],'r') as fin:\n          with open(sys.argv[2], 'w') as fout:\n              solve(fin, fout)\n <CODESPLIT> 14
 f   = file(sys.argv[1])\n  out = file(sys.argv[2], 'w')\n  \n  caseCnt = int(f.readline())\n  \n  Num = [\n  	0,\n  	1,\n  	4,\n  	9,\n  	121,\n  	484,\n  	10201,\n  	12321,\n  	14641,\n  	40804,\n  	44944,\n  	1002001,\n  	1234321,\n  	4008004,\n  	100020001,\n  	102030201,\n  	104060401,\n  	121242121,\n  	123454321,\n  	125686521,\n  	400080004,\n  	404090404,\n  	10000200001,\n  	10221412201,\n  	12102420121,\n  	12345654321,\n  	40000800004,\n  	1000002000001,\n  	1002003002001,\n  	1004006004001,\n  	1020304030201,\n  	1022325232201,\n  	1024348434201,\n  	1210024200121,\n  	1212225222121,\n  	1214428244121,\n  	1232346432321,\n  	1234567654321,\n  	4000008000004,\n  	4004009004004,\n  ]\n  \n  for case in range(1, caseCnt+1):\n  	L, H = f.readline().split()\n  	L = int(L); H = int(H)\n  	assert L <= H\n  	\n  	for i in range(len(Num)):\n  		if L <= Num[i]:\n  			break\n  	else:\n  		print>>out, 'Case #%d:'%case, 0\n  		continue\n  \n  	lb = i - 1\n  \n  	for i in range(1, len(Num)+1):\n  		if H >= Num[len(Num)-i]:\n  			break\n  	else:\n  		print>>out, 'Case #%d:'%case, 0\n  		continue\n  	ub = len(Num)-i\n  		\n  	print>>out, 'Case #%d:'%case, ub - lb\n  \n  out.close()\n <CODESPLIT> 15
 \n  f = file("B-small-attempt0.in")\n  w = file("answer.txt", "w")\n  cnt = int(f.readline()[:-1])\n  for no in range(cnt):\n  	l = f.readline()[:-1].split()\n  	T, s, p = map(int, l[:3])\n  	ts = map(int, l[3:])\n  	ns = p*3-2 if p*3-2 > 0 else 0\n  	ss = p*3-4 if p*3-4 > 0 else 31\n  	l = filter(lambda x: x<ns, ts)\n  	c = min([len(filter(lambda x: x>=ss, l)), s])\n  	\n  	print>>w, "Case #%d:"%(no+1), T-len(l)+c\n  \n  \n <CODESPLIT> 15
def check(a,b):\n      c = 0\n      n = 1\n      for i in range(1,4):\n          if i**2 >= a and i**2 <=b:\n              c += 1\n      if 44944 >= a and 44944 <= b:\n          c += 1\n      while n < 10:\n          p1 = int('1'+'1'*n)**2\n          if p1 >= a and p1 <=b:\n              c += 1\n          n += 1\n  \n  \n      if 484 >= a and 484 <= b:\n          c += 1\n  \n      n = 1\n      while True:\n          p2 = int('1'+'0'*n+'1')**2\n          p3 = int('2'+'0'*n+'2')**2\n          if p2 >= a and p2 <= b:\n              c += 1\n          else:\n              break\n          if p3 >= a and p3 <= b:\n              c += 1\n          else:\n              continue\n          n += 1\n  \n      n = 1\n      while True:\n          t = False\n          for m in range(2,5):\n              p4 = int('1'*m+'0'*n+'1'*m)**2\n              if p4 >= a and p4 <= b:\n                  c += 1\n              else:\n                  t = True\n                  break\n          if t:\n              break\n              \n          n += 1\n      return c\n                  \n  dat = raw_input().split()\n  n = int(dat.pop(0))\n  data = [int(e) for e in dat]\n  \n  for i in range(0, n*2, 2):\n      a, b = data[i], data[i+1]\n      print 'Case #%i: '%(i/2+1) + str(check(a,b)) \n  \n      \n <CODESPLIT> 16
f = open('cj2.in','r')\n  out = open('out1.txt','w')\n  inp = [[int(n) for n in s.split()] for s in f.readlines()]\n  \n  def score_partition(score):\n      poss = []\n      if score == 0:\n          return [[0,0,0]]\n      if score == 1:\n          return [[0,0,1]]\n      if score % 3 == 0:\n          poss.append([score/3,score/3,score/3])\n          poss.append([score/3-1,score/3,score/3+1])\n      if score % 3 == 1:\n          poss.append([score/3, score/3,score/3+1])\n          poss.append([score/3-1,score/3+1,score/3+1])\n      if score % 3 == 2:\n          poss.append([score/3,score/3+1,score/3+1])\n          poss.append([score/3,score/3,score/3+2])\n  \n      return poss\n  \n  \n  s = 0\n  c = 1\n  for e in inp[1:len(inp)]:\n      count = 0\n      surprises = e[1]\n      s = 0\n      p = e[2]\n      for i in e[3:len(e)]:\n          scores = score_partition(i)\n          for j in scores: \n              if max(j) >= p:\n                  if max(j)-min(j) == 2:\n                      if s < surprises:\n                          s +=1\n                          count +=1\n                          break\n                  else:\n                      count += 1\n                      break\n                  \n      out.write('Case #'+str(c)+': '+str(count)+'\n')\n      c += 1\n  \n  out.close()\n  f.close()\n                  \n          \n      \n      \n  \n      \n <CODESPLIT> 16
 def ispal(num):\n      num = str(num)\n      if num == num[::-1]:\n          return True\n      else:\n          return False\n  \n  def test(bot, top):\n      count = []\n      for i in range(bot,top+1):\n          if not ((int(i**0.5)**2) == i):\n              continue\n          if ispal(i) and ispal(int(i**0.5)):\n              count.append(i)\n      return len(count)\n  \n  case = 1\n  for line in open('C-small-attempt2.in', 'Ur'):\n      if ' ' in line:\n          a,b = line.split()\n          res = test(int(a),int(b))\n          print("Case #{0}: {1}".format(case, res))\n          case += 1\n  \n  \n <CODESPLIT> 17
 data = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]\n  count = 0\n  for line in data[1:]:\n  	count += 1\n  	supps = line[1]\n  	score = line[2]\n  	maxes = 0\n  	nonsuptot = (score*3)-2\n  	suptot = (score*3)-4\n  	if suptot < 0:\n  		suptot = 1\n  	for i in range(3,(len(line))):\n  		if line[i] >= nonsuptot:\n  			maxes += 1\n  			continue\n  		if (line[i] >= suptot) and (supps > 0):\n  			maxes += 1\n  			supps -= 1\n  	if score == 0:\n  		maxes = line[0]\n  	print ("Case #"+str(count)+":", maxes)\n  		\n  			\n  \n  \n  \n  \n <CODESPLIT> 17
 \n  \n  def is_palindrome(a):\n      return str(a) == ''.join(reversed(str(a)))\n  \n  \n  def solve_problem(min_num, max_num):\n      count = 0\n      for i in xrange(min_num, max_num + 1):\n          if is_palindrome(i):\n              sqrt = math.sqrt(i)\n              if int(sqrt) == sqrt and is_palindrome(int(sqrt)):\n                  count += 1\n      return count\n  \n  \n  if __name__ == '__main__':\n      num_of_cases = int(sys.stdin.readline())\n      for i in xrange(1, num_of_cases + 1):\n          min_num, max_num = map(int, sys.stdin.readline().strip().split(' '))\n          print 'Case #{0}: {1}'.format(i, solve_problem(min_num, max_num))\n <CODESPLIT> 18
"""\n  Google Code Jam 2012 Problem B\n  Usage:\n      python problem_b.py < input.txt > output.txt\n  """\n  \n  \n  def calc_possible(n):\n      combinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores\n      return itertools.ifilter(lambda (x, y, z): x + y + z == n, combinations)\n  \n  \n  def calc_surprising(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def calc_normal(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def solve_problem():\n      number_of_cases = int(sys.stdin.readline())\n  \n      for i in xrange(1, number_of_cases + 1):\n  \n          case = sys.stdin.readline().strip()\n          result = 0\n          num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)\n          num_of_googlers = int(num_of_googlers)\n          num_of_surprising = int(num_of_surprising)\n          desired_score = int(desired_score)\n          scores = map(int, scores.split())\n  \n          possible_scores = []\n  \n          for k in xrange(num_of_googlers):\n  \n              normal = calc_normal(scores[k])\n              surprising = calc_surprising(scores[k])\n  \n              possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))\n  \n          possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))\n          result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))\n  \n          sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n  \n  \n  if __name__ == '__main__':\n      solve_problem()\n <CODESPLIT> 18
 \n  \n  \n  def ispalindrome(n):\n      return str(n) == str(n)[::-1]\n  \n  \n  def solve(A, B):\n      solution = []\n      for n in range(int(math.sqrt(A)), int(math.sqrt(B))+1):\n          if ispalindrome(n):\n              m = n ** 2\n              if ispalindrome(m) and A <= m <= B:\n                  solution.append(n)\n      return len(solution)\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          A, B = map(int, IN.readline().split())\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(A, B)))\n  \n  \n  def makesample(T=100, ABmax=1000):\n      print T\n      for index in range(T):\n          A = random.randint(1, ABmax)\n          B = random.randint(A, ABmax)\n          print A, B\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 19
 \n  \n  \n  \n  \n  def solve(S, p, tlist):\n  	above = 0\n  	consider = 0\n  \n  	for t in tlist:\n  		avg = t / 3\n  		mod = t % 3\n  \n  		if mod == 0:\n  			if avg >= p:\n  				above += 1\n  			elif avg + 1 >= p and t > 0:\n  				consider += 1\n  \n  		elif mod == 1:\n  			if avg + 1 >= p:\n  				above += 1\n  \n  		elif mod == 2:\n  			if avg + 1 >= p:\n  				above += 1\n  			elif avg + 2 >= p:\n  				consider += 1\n  \n  	return above + min(S, consider)\n  \n  \n  def main(IN, OUT):\n  	N = int(IN.readline())\n  	for index in range(N):\n  		data = map(int, IN.readline().strip().split())\n  		(N, S, p), tlist = data[:3], data[3:]\n  		OUT.write('Case #%d: %d\n' % (index + 1, solve(S, p, tlist)))\n  \n  \n  if __name__ == '__main__':\n  	main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> 19
 \n  N_MAX = 10 ** 7  # for First large dataset\n  \n  \n  def is_palindrome(n):\n      s = str(n)\n      for i in xrange(len(s) / 2):\n          if s[i] != s[-1 - i]:\n              return False\n      return True\n  \n  palindromes = [x for x in xrange(N_MAX) if is_palindrome(x)]\n  palindrome_squares = [x ** 2 for x in palindromes]\n  fair_and_square_palindromes = filter(is_palindrome, palindrome_squares)\n  \n  \n  T = int(raw_input())\n  for test_case_id in xrange(1, T + 1):\n      A, B = map(int, raw_input().split())\n      answer = len([x for x in fair_and_square_palindromes if A <= x <= B])\n      print 'Case #{}: {}'.format(test_case_id, answer)\n <CODESPLIT> 20
 \n  \n  poss = dict([(i, {}) for i in xrange(0, 30 + 1)])\n  for a, b, c in itertools.product(range(10 + 1), repeat=3):\n      if a <= b <= c and c - a <= 2:\n          n = a + b + c\n          if c - a == 2:\n              poss[n]['s'] = tuple(sorted((a, b, c)))\n          else:\n              poss[n]['n'] = tuple(sorted((a, b, c)))\n  \n  \n  T = int(raw_input())\n  for case in xrange(1, T + 1):\n      div = map(int, raw_input().split())\n      N, S, p = div[:3]\n      t = div[3:]\n  \n      ans = 0\n      t.sort(reverse=True)\n      for i in xrange(len(t)):\n          na, nb, nc = poss[t[i]]['n']\n          sa, sb, sc = poss[t[i]].get('s', (-1, -1, -1))\n          if p <= nc:\n              ans += 1\n          elif 0 < S and p <= sc:\n              ans += 1\n              S -= 1\n  \n      print 'Case #%d: %d' % (case, ans)\n  \n <CODESPLIT> 20
 \n  \n  \n  INPUT = "tiny"\n  if 1:\n      INPUT = "C-small-attempt0.in"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args\n  \n  def is_palindrome(N):\n      s = str(N)\n      return s == ''.join(reversed(s))\n  \n  def fair_and_square_set(max_N):\n      p = "squareset_%d" % max_N\n      try:\n          s = pickle.load(file(p))\n          return s\n      except:\n          pass\n      s = set()\n      for i in range(1,max_N+1):\n          if is_palindrome(i) and is_palindrome(i*i):\n              s.add(i*i)\n      pickle.dump(s, file(p, "wb"))\n      return s\n  \n  MAX_N = int(1e7)\n  SQUARE_SET = fair_and_square_set(MAX_N)\n  \n  def do_trial(A, B):\n      count = 0\n      for ss in SQUARE_SET:\n          if A <= ss <= B:\n              count += 1\n      return count\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      A, B = [int(x) for x in f.readline().split()]\n      v = do_trial(A, B)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 21
 \n  \n  INPUT = "tiny"\n  \n  INPUT = "B-small-attempt0.in.txt"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  def zdebug(*args):\n      print ''.join(str(s) for s in args)\n  \n  def can_score_p(N, p):\n      low_p = max(p-1, 0)\n      if low_p + low_p + p <= N:\n          return "Y"\n      low_p = max(p-2, 0)\n      if low_p + low_p + p <= N:\n          return "S"\n      return "N"\n  \n  def do_trial(N, S, p, *scores):\n      d = { "Y" : 0, "N" : 0, "S" : 0 }\n      for s in scores:\n          v = can_score_p(s, p)\n          debug("score %s p=%s : %s" % (s, p, v))\n          d[v] = d[v] + 1\n      return d["Y"] + min(d["S"], S)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      l = [int(x) for x in f.readline()[:-1].split()]\n      v = do_trial(*l)\n      print "Case #%d: %s" % (i+1, v)\n <CODESPLIT> 21
 \n  \n  def is_palindromic(i):\n      n = i\n      rev = 0\n      while i > 0:\n          dig = i % 10\n          rev = rev * 10 + dig\n          i = i // 10\n      return n == rev\n  \n  def is_square(i):\n      if i == 1:\n          return True\n      x = i // 2\n      seen = set([x])\n      while x * x != i:\n          x = (x + (i // x)) // 2\n          if x in seen:\n              return False\n          seen.add(x)\n      return True\n  \n  def f(a, b):\n      tot = 0\n  \n      sra = a\n      while not is_square(sra):\n          sra += 1\n      srb = b\n      while not is_square(srb):\n          srb -= 1\n  \n      sra = int(sqrt(sra))\n      srb = int(sqrt(srb))\n  \n      for i in range(sra, srb+1):\n          if is_palindromic(i) and is_palindromic(i ** 2):\n              tot += 1\n  \n      return tot\n  \n  if __name__ == '__main__':\n      T = int(input())\n      for i in range(T):\n          a, b = map(int, input().split())\n          r = f(a, b)\n          print('Case #{}: {}'.format(i+1, r))\n <CODESPLIT> 22
 \n  T = int(raw_input())\n  for i in xrange(T):\n      values = map(int, raw_input().split())\n      [N,s,p] = values[0:3]\n      t = values[3:]\n      answer = 0\n      for note in t:\n          if note < 2:\n              if note >= p:\n                  answer += 1\n          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n              answer += 1\n          elif note % 3 == 0:\n              n = note / 3\n              if n >= p:\n                  answer += 1\n              elif s > 0 and n + 1 >= p:\n                  answer += 1\n                  s -= 1\n          elif note % 3 == 2:\n              n = (note - 2) / 3\n              if n + 1 >= p:\n                  answer += 1\n              elif s > 0 and n + 2 >= p:\n                  answer += 1\n                  s -= 1\n      print 'Case #{0}: {1}'.format(i+1, answer)\n <CODESPLIT> 22
 \n  \n  FILE_NAME_BASE = 'C-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  	a, b = (int(x) for x in inp.readline().split())\n  	return a, b\n  \n  def isFair(x):\n  	l1 = list(str(x))\n  	l2 = list(l1)\n  	l2.reverse()\n  	return l1 == l2\n  \n  def solve(a, b):\n  	c = 0\n  	for i in xrange(a, b + 1):\n  		r = int(sqrt(i))\n  		if r * r == i and isFair(i) and isFair(r):\n  			c += 1\n  \n  	return str(c)\n  \n  def main():\n  	sys.setrecursionlimit(RECURSION_LIMIT)\n  \n  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  	inp = open(FILE_NAME_BASE + '.in', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n  \n  if __name__ == '__main__':\n  	main()\n <CODESPLIT> 23
 \n  FILE_NAME_BASE = 'B-small-attempt0'\n  NUM_PROCESSES = 0\n  \n  def parse(inp):\n  	data = tuple(int(x) for x in inp.readline().split())\n  	dancers, surprises, points = data[ : 3]\n  	totals = data[3 : ]\n  	assert len(totals) == dancers\n  	return totals, surprises, points\n  \n  def totalAtDist():\n  	'''\n  	If a dancer's best result is b, the total can be:\n  	  distance 0: 3b\n  	  distance 1: [3b-2..3b-1]\n  	  distance 2: [3b-4..3b-2]\n  	Note: distance d is only possible if d <= b.\n  \n  	total 15:\n  	b = 0..4:  impossible\n  	b = 5:     dist = 0\n  	b = 6:     dist = 2\n  	b = 7..10: impossible\n  \n  	For every total we have a number of explanations, which are\n  	(b, d) pairs where b is the best result and d is the distance.\n  \n  	The output of this function shows:\n  \n  	Except for 0, 1, 29 and 30, every total t has exactly 2 explanations:\n  	  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)\n  	In other words, always one surprise option and one normal option.\n  	The surprise option can have a result one higher than the normal one or\n  	equal to it.\n  	'''\n  \n  	print '  ',\n  	for b in xrange(0, 11):\n  		print 'b=%d' % b,\n  	print\n  	for total in xrange(0, 31):\n  		print '%2d' % total,\n  		for b in xrange(0, 11):\n  			s = '0' if total == b * 3 else '.'\n  			s += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'\n  			s += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'\n  			print s,\n  		print\n  \n  \n  def solve(totals, surprises, points):\n  	countCertain = 0\n  	countSurprise = 0\n  	for total in totals:\n  		if (total + 2) / 3 >= points:\n  			countCertain += 1\n  		elif 2 <= total <= 28 and (total + 4) / 3 >= points:\n  			countSurprise += 1\n  		else:\n  			pass\n  \n  \n  	return countCertain + min(countSurprise, surprises)\n  \n  if __name__ == '__main__':\n  	inp = open(FILE_NAME_BASE + '.in.txt', 'r')\n  	numCases = int(inp.readline())\n  	if NUM_PROCESSES == 0:\n  		results = [\n  			solve(*parse(inp))\n  			for _ in range(numCases)\n  			]\n  	else:\n  		pool = Pool(NUM_PROCESSES)\n  		results = [\n  			pool.apply_async(solve, parse(inp))\n  			for _ in range(numCases)\n  			]\n  	inp.close()\n  	out = open(FILE_NAME_BASE + '.out.txt', 'w')\n  	for case, result in enumerate(results):\n  		value = result if NUM_PROCESSES == 0 else result.get()\n  		out.write('Case #%d: %s\n' % (case + 1, value))\n  		out.flush()\n  	out.close()\n <CODESPLIT> 23
 \n  def isPalindrome(n):\n      cn=str(n)\n      return (cn==cn[::-1])\n  \n  palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]\n  \n  \n  \n              \n          \n          \n  \n  \n  \n  def Solve(a,b):\n      num=0\n      for p in palinSqrt:\n          if a<= p**2 <=b: num+=1\n      return num\n  \n  \n  \n  def parse(infile):\n      a,b=map(int, infile.readline().split() )\n      return a,b\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  class Categorizer(dict):\n      def __init__(self,thelist,transform,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.AddList(thelist)\n          self.trunc=trunc\n      def AddList(self,thelist):\n          for item in thelist: self.Add( item )\n      def Add(self,object):\n          cat=self.transform( object )\n          if type(cat) is float:\n              cat=round(cat,trunc)\n          if self.has_key(cat):\n              self[cat].append( object )\n          else:\n              self[cat]=[object]\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-len(x[1]))\n          total=0\n          for i in items: total+=len(i[1])\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(len(val))) for val in self.itervalues() )\n          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n          for key,count in items[0:n]:\n              print formatter.format(key,len(count),\n                                     ("%.2f"%(len(count)*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=[]\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=len(self[key])\n              avg+=len(self[key])*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=len(self[key])\n              stddev += len(self[key]) * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n          tot=0\n          for value in self.itervalues(): tot+=len(value)\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += len(self[key])\n             if nCount>tot/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n  \n  \n  \n  \n  class Counter(dict):\n      def __init__(self,thelist,transform=None,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.trunc=trunc\n          self.AddList(thelist)\n      def AddList(self,thelist):\n          if self.transform is not None:\n              for item in thelist: self.Add( self.transform(item) )\n          else:\n              for item in thelist: self.Add( item )            \n      def Add(self,object):\n          if type(object) is float:\n              object=round(object,self.trunc)\n          if self.has_key(object):\n              self[object]+=1\n          else:\n              self[object]=1\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-x[1])\n          total=0\n          for i in items: total+=i[1]\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(val)) for val in self.itervalues() )\n          formatter="{0:<"+str(maxkey)+"} {1:>"+str(maxval)+"}    {2}"\n          for key,count in items[0:n]:\n              print formatter.format(key,count, ("%.2f"%(count*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=0\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=self[key]\n              avg+=self[key]*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=self[key]\n              stddev += self[key] * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n   	total=sum(self.values())\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += self[key]\n             if nCount>total/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: x[1])[0]\n  \n  \n  def gen_primes():\n      """ Generate an infinite sequence of prime numbers.\n      """\n      D = {}  \n      q = 2  \n  \n      while True:\n          if q not in D:\n              yield q        \n              D[q * q] = [q]\n          else:\n              for p in D[q]:\n                  D.setdefault(p + q, []).append(p)\n              del D[q]\n  \n          q += 1\n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n <CODESPLIT> 24
 \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  for iCase in xrange(NumCases):\n      line=[ int(i) for i in infile.readline().split() ]\n  \n      n=line.pop(0)\n      s=line.pop(0)\n      p=line.pop(0)\n  \n      scores=line\n      assert(len(scores))==n\n  \n      imax=0\n      isurprise=0\n  \n      for score in scores:\n          if score<p: continue\n          if score<3*p-4:\n              pass\n          elif 3*p-2>score>=3*p-4:\n              isurprise+=1\n          else:\n              imax+=1\n  \n      print 'Case #'+str(iCase+1)+':',imax+min(isurprise,s)\n  \n <CODESPLIT> 24
 \n  lines = sys.stdin.readlines()\n  def parseCase(lines):\n      dims = map(int,lines[0].split(" "))\n      return 1, dims\n  \n  def getCases(lines):\n      i =0\n      while i < len(lines):\n          lines_used, case = parseCase(lines[i:])\n          i += lines_used\n          yield case\n  \n  \n  fands = []\n  phash = {1:True}\n  def isPalindrome(p):\n      return p in phash\n  \n  def test(p):\n      square = p**.5\n      return square == int(square) and isPalindrome(int(square))\n  \n  for i in range(1,10**5):\n      if i > 9:\n          small_p = int(i * 10 ** int(math.log(i,10)) + int("".join(reversed(str(i)[:-1]))))\n      else: small_p = i\n      phash[small_p]= test(small_p)\n      if phash[small_p]: fands.append(small_p)\n      big_p = int(i * 10 ** int(math.log(i,10)+1) + int("".join(reversed(str(i)))))\n      phash[big_p] = test(big_p)\n      if phash[big_p]: fands.append(big_p)\n  cNum =0\n  \n  for c in getCases(lines[1:]):\n      cNum += 1\n      answer = []\n      for i in fands:\n          if i < c[0]: continue\n          if i > c[1]: break\n          if phash[i]: answer.append(i)\n      answer = str(len(answer))\n      print "Case #%d: %s" % ( cNum, answer)\n  \n  \n      \n  \n  \n <CODESPLIT> 25
 """\n  GCJ framework (gcj.fw.framework)\n   - Command Line and Package interface\n   - output redirection\n   - parsing case input\n   - executing problem code against cases\n   - testing framework\n  """\n  \n  class Framework(object):\n      class Case(object):\n          def __init__(self, caseNumber, caseData=None):\n              self.number = caseNumber\n              self.data = caseData\n              self.result = None\n      \n          @classmethod\n          def parser(cls, f_in):\n              pass\n      \n          def run(self):\n              pass\n      \n          def execute(self, f_in=None):\n              if self.data is None:\n                  self.data = self.parser(f_in)\n              self.result = self.run(**self.data)\n      \n          def __str__(self):\n              return "Case #%d: %s" % (self.number, self.result)\n      \n      \n      class Result(object):\n          def __init__(self, resultData):\n              self.data = resultData\n      \n          def __str__(self):\n              return str(self.ata)\n  \n      def __init__(self, f_in, f_out):\n          sys.stdout = f_out\n          self.f_in = f_in if f_in is not None else sys.stdin\n  \n      def run(self):\n          nCases = int(self.f_in.readline().strip())\n          for num in xrange(nCases):\n              case = type(self).Case(num+1)\n              case.execute( f_in=self.f_in)\n              print case\n  \n  \n      @classmethod\n      def __main__(cls):\n          f_in = sys.stdin\n          if len(sys.argv) > 1:\n              if sys.argv[1] == "-t":\n                  unittest.main()\n                  sys.exit()\n              f_in = open(sys.argv[1])\n          framework = cls(f_in, sys.stdout)\n          framework.run()\n      \n  class Test(unittest.TestCase):\n      cases = []\n      case = None\n      c=[]\n      \n      def setUp(self):\n          self.c = []\n          self.defineCases()\n          counter = 1\n          self.cases = []\n          for c in self.c:\n              case = self.case(counter)\n              case.data = case.parser(StringIO.StringIO(c[0]))\n              self.cases.append( [case, c[1]])\n      \n      def defineCases(self):\n          pass\n      \n      def tearDown(self):\n          pass \n  \n      def test_Name(self):\n          self.setUp()\n          for case in self.cases:\n              print case[0].data, case[1]\n              case[0].execute()\n              self.assertEqual(case[0].result, case[1])\n  '''\n  Created on Apr 8, 2012\n  \n  @author: Joe\n  '''\n  \n  \n  class B(Framework):\n      class Case(Framework.Case):\n          def parser(self, fh):\n              args = map(int, fh.readline().strip().split(" "))\n              N,S,p = args[:3]\n              scores = args[3:] \n              return {"N":N,"S":S,"p":p,"scores":scores}\n          \n          def run(self, N=None,S=None,p=None,scores=None):\n              ret = 0\n              surps = 0\n              for score in scores:\n                  if p > 0 and score == 0: continue\n                  if 3*p-2 <= score:\n                      ret += 1\n                  else:\n                      if 3*p - 4 <= score:\n                          surps += 1\n              return str(ret + min(surps,S))\n              \n  class Test(Test):\n      def defineCases(self):\n          self.case = B.Case\n          self.c = [\n                    ["3 1 5 15 13 11","3"],\n                    ["3 0 8 23 22 21","2"],\n                    ["2 1 1 8 0","1"],\n                    ["6 2 8 29 20 8 18 18 21","3"],\n                    ["1 1 1 1", "1"]\n                    ]\n  \n  if __name__ == "__main__":\n      B.__main__()\n      \n <CODESPLIT> 25
def is_palindrome(s):\n  	if s == '':\n  		return True\n  	else:\n  		if (ord(s[0]) - ord(s[len(s)-1])) == 0:\n  			return is_palindrome(s[1 : len(s) - 1])\n  		else:\n  			return False\n  \n  all_fair_and_square = set()\n  for i in range(10000):\n  	orig = str(i)\n  	rev = orig[::-1]\n  \n  	palin = orig + rev\n  	intpalin = int(palin)\n  	if is_palindrome(str(intpalin * intpalin)):\n  		all_fair_and_square.add(intpalin * intpalin)\n  \n  	palin = orig[:-1] + rev\n  	intpalin = int(palin)\n  	if is_palindrome(str(intpalin * intpalin)):\n  		all_fair_and_square.add(intpalin * intpalin)\n  	\n  \n  \n  t = int(sys.stdin.readline().strip())\n  for ii in range(t):\n  	line = sys.stdin.readline().strip().split()\n  	a = int(line[0])\n  	b = int(line[1])\n  	count = 0\n  	for num in all_fair_and_square:\n  		if (num >= a) and (num <= b):\n  			count += 1\n  	print "Case #" + str(ii + 1) + ": " + str(count)\n  \n <CODESPLIT> 26
 \n  t = int(sys.stdin.readline())\n  for i in range(t):\n  	inputline = sys.stdin.readline().strip()\n  	inputparams = inputline.split()\n  \n  	n = int(inputparams[0])\n  	s = int(inputparams[1])\n  	p = int(inputparams[2])\n  	validcount = 0\n  	surprisingcount = 0\n  	for j in range(n):\n  		score = int(inputparams[3 + j])\n  		if (p + (p - 1) * 2) <= score:\n  			validcount += 1\n  		elif ((p + (p - 2) * 2) <= score) and (p <= score):\n  			surprisingcount += 1\n  \n  	print "Case #%d: %d" % (i + 1, validcount + min(surprisingcount, s))\n <CODESPLIT> 26
 \n  \n  fairsquares = []\n  \n  \n  def read_fairsquares():\n      global fairsquares\n      f = open('fairsquares.txt')\n      for x in f:\n          fairsquares.append(int(x.strip()))\n  \n  \n  def count_less_than(A):\n      left = 0\n      right = len(fairsquares)\n      while left < right:\n          middle = (left + right) // 2\n          if fairsquares[middle] < A:\n              left = middle + 1\n          else:\n              right = middle\n      return left\n  \n  \n  def compute(A, B):\n      count_b = count_less_than(B + 1)\n      count_a = count_less_than(A)\n      return count_b - count_a\n  \n  \n  def parse():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  \n  if __name__ == "__main__":\n      read_fairsquares()\n      T = int(sys.stdin.readline().strip())\n      count = 1\n      part = 0\n      if len(sys.argv) == 3:\n          part = int(sys.argv[1])\n          count = int(sys.argv[2])\n      for i in xrange(T):\n          data = parse()\n          if i * count >= part * T and i * count < (part + 1) * T:\n              result = compute(*data)\n              print "Case #%d: %s" % (i + 1, result)\n <CODESPLIT> 27
 \n  \n  if __name__ == "__main__":\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          values = map(int, sys.stdin.readline().strip().split(' '))\n          _N, S, p = values[0:3]\n          t = values[3:]\n          min_normal = p + 2 * max(0, p - 1)\n          min_surprising = p + 2 * max(0, p - 2)\n          cnt_normal = len(filter(lambda x : x >= min_normal, t))\n          cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal\n          print "Case #%d: %s" % (i + 1, cnt_normal + min(cnt_surprising, S))\n <CODESPLIT> 27
 \n  def get_generators_up_to_length_n(n):\n      generators = []\n      for ii in range(1, n + 1):\n          generators += get_generators_length_n(ii)\n      return generators        \n  \n  def get_generators_length_n(length):\n      if length % 2 == 0: return get_even_generators_length_n(length)\n      else: return get_odd_generators_length_n(length)\n  \n  def get_odd_generators_length_n(length):\n      if length == 1: return [1, 2, 3]\n      else: \n          n = length / 2\n          generators = []\n          for ii in range(min(n, 4)):\n              for comb in itertools.combinations(range(1, n), ii):\n                  first_half = ["1"] + ["0"] * (n-1)\n                  for jj in comb:\n                      first_half[jj] = "1"\n                  second_half = list(first_half)\n                  second_half.reverse()\n                  palin = first_half + ["0"] + second_half\n                  generators.append(int("".join([elem for elem in palin])))\n                  palin[n] = "1"\n                  generators.append(int("".join([elem for elem in palin])))\n                  if ii <= 1:\n                      palin[n] = "2"\n                      generators.append(int("".join([elem for elem in palin])))\n          generators.append(int("".join([elem for elem in (["2"] + ["0"] * (n - 1) + ["0"] + ["0"] * (n - 1) + ["2"])])))\n          generators.append(int("".join([elem for elem in (["2"] + ["0"] * (n - 1) + ["1"] + ["0"] * (n - 1) + ["2"])])))\n          generators.sort()\n          return generators\n  \n  def get_even_generators_length_n(length):\n      if length == 2: return [11, 22]\n      n = length / 2\n      generators = []\n      for ii in range(min(n, 4)):\n          for comb in itertools.combinations(range(1, n), ii):\n              first_half = ["1"] + ["0"] * (n-1)\n              for jj in comb:\n                  first_half[jj] = "1"\n              second_half = list(first_half)\n              second_half.reverse()\n              palin = first_half + second_half\n              generators.append(int("".join([elem for elem in palin])))\n      generators.append(int("".join([elem for elem in (["2"] + ["0"] * (length - 2) + ["2"])])))\n      generators.sort()\n      return generators\n  \n  def is_palin(num):\n      string = str(num)\n      length = len(string)\n      ii = 0\n      while ii < length/2:\n          if string[ii] != string[-(1+ii)]:\n              return False\n          ii += 1\n      return True\n  \n  def gen_fair_and_squares(upper_limit):\n      fair_and_squares = []\n      for ii in range(1, upper_limit + 1):\n          if (is_palin(ii) and is_palin(ii*ii)):\n              fair_and_squares.append(ii)\n      return fair_and_squares\n  \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  gens = get_generators_up_to_length_n(60)\n  squares = map(lambda x: x*x, gens)\n  \n  for t in range(T):\n      A, B = map(int, f.readline().strip().split())\n      total = 0\n      for elem in squares:\n          assert(is_palin(elem))\n          if elem >= A and elem <= B: total += 1\n          if elem > B:\n              break\n  \n      print "Case #%d:" % (t + 1), total\n <CODESPLIT> 28
 \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      temp = map(int, f.readline().split())\n      N = temp[0]\n      S = temp[1]\n      p = temp[2]\n      scores = temp[3:]\n      non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))\n      if (p<=1):\n          surprising_scores = 0\n      else:\n          surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))\n      num_scores = non_surprising_scores + min(surprising_scores, S)   \n      print "Case #%d:" % (t + 1), num_scores\n <CODESPLIT> 28
 \n  \n  		\n  	\n  def isPalindrome(S):\n  	s = str(S) #so I dont need to make sure its a string\n  	for i in range(len(s)//2):\n  		if not s[i] == s[-1 - i]:\n  			return False\n  	return True\n  \n  def FairAndSquare(infile="C-small-attempt0.in", outfile="C-small-attempt0.out"):\n  	inF = open(infile, 'r')\n  	outF = open(outfile, 'w')\n  	\n  	for t in range(1, int(inF.readline().strip()) + 1):\n  		temp = inF.readline().strip().split()\n  		A = long(temp[0])\n  		B = long(temp[1])\n  		count = long(0)\n  		\n  		i = long(math.ceil(math.sqrt(A)))\n  		m = long(math.floor(math.sqrt(B)))\n  		while i <= m:\n  			if isPalindrome(i):\n  				if isPalindrome(i**2):\n  					count += 1\n  			i += 1\n  					\n  		outF.write("Case #" + str(t) + ": " + str(count) + "\n")\n  	\n  	inF.close()\n  	outF.close()\n  	\n  	f = open(outfile, 'r')\n  	print f.read()\n  	f.close()\n  	\n  	\n  if __name__ == "__main__":\n      FairAndSquare()\n <CODESPLIT> 29
data_dict = {}\n  init = False\n  \n  \n  def partB(infile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt",\\n                outfile="C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt"):\n      \n      linesA = []\n      for line in open(infile, 'r'):\n          linesA.append(line.strip())\n  \n      outA = []\n          \n      T = int(linesA[0])\n      for i in range(1, 1 + T):\n          caseA = linesA[i].split()\n          N = int(caseA[0])\n          S = int(caseA[1])\n          P = int(caseA[2])\n          \n          over_norm = 0\n          over_supr = 0\n          \n          for t in [int(conv) for conv in caseA[3:3+N]]:\n              if data_dict[t][0] >= P:\n                  over_norm += 1\n              elif data_dict[t][1] >= P:\n                  over_supr += 1\n          \n          outA.append(over_norm + min(over_supr, S))\n              \n              \n          \n      \n      out = open(outfile, 'w')\n      print "\nOUTPUT"\n      for i in range(1, 1 + T):\n          if i != 1:\n              out.write("\n")\n          print "Case #" + str(i) + ": " +str(outA[i-1])\n          out.write("Case #" + str(i) + ": " +str(outA[i-1]))\n      out.close()\n  \n  def dict_helper(total, depth=0, lowest=10):\n      pass\n  \n  def build_dict():\n      for i in range(31):\n          fullA = []\n          maxN = 0\n          maxS = 0\n          print str(i) + ": "\n          for a1 in range(0,11):\n              for a2 in range(0,11):\n                  for a3 in range(0,11):\n                      if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):\n                          fullA.append((a1,a2,a3))\n                          \n                          print "\t", fullA[-1],\n                          if max(a1,a2,a3)-min(a1,a2,a3) == 2:\n                              print "*"\n                              maxS = max(maxN, max(a1,a2,a3))\n                          else:\n                              print\n                              maxN = max(maxN, max(a1,a2,a3))\n          data_dict[i]=[maxN, maxS]\n      init = True\n      \n  if __name__ == "__main__":\n      build_dict()\n      partB()\n <CODESPLIT> 29
"""Usage:\n      X.py < X.in > X.out\n  """\n  \n  def isqrt(x):\n      "returns int(floor(sqrt(x))) using only integer math"\n      assert x >= 0, 'Undefined %r' % locals()\n      n = int(x)\n      if n == 0:\n          return 0\n      a, b = divmod(n.bit_length(), 2)\n      x = 2**(a+b)\n      while True:\n          y = (x + n//x)//2\n          if y >= x:\n              return x\n          x = y\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, **ignore):\n      P = map(int, infile.next().split())\n      return locals()\n  \n  def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      low = isqrt(P[0])\n      high = isqrt(P[1])+1\n  \n      def is_pal(n):\n          n = str(n)\n          for i in range(len(n)/2+1):\n              if n[i]!=n[len(n)-1-i]:\n                  return False\n          return True\n  \n      res = 0\n      for i in range(low, high+1):\n          if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):\n              res += 1\n  \n      return 'Case #%s: %s\n' % (testcase, res)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n <CODESPLIT> 30
"""Usage:\n      X.py < X.in > X.out\n  """\n  \n  \n  \n  class Solver(object):\n      cache = {}\n  \n      def __init__(self, infile, testcase):\n          self.testcase = testcase\n          self.P = P = map(int, infile.next().split())\n  \n      def init_cache(self):\n          if 'main' in self.cache:\n              return\n  \n      def solve(self):\n  \n          N, S, p = self.P[:3]\n          G = sorted(self.P[3:], reverse=True)\n  \n          r = 0\n          s = 0\n          for g in G:\n              if g >= 3 * p - 2 and g >= p:\n                  r += 1\n              elif g >= 3 * p - 4 and g >= p:\n                  if s == S:\n                      break\n                  r += 1\n                  s += 1\n  \n          return r\n  \n  \n  def main():\n      T = int(sys.stdin.next())\n      for t in xrange(T):\n          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 30
 \n  def is_fair(n):\n      n = str(n)\n      for i in range(long(len(n) / 2)):\n          if n[i] != n[len(n) - i - 1]:\n              return False\n      return True\n  \n  def is_square_and_fair(n):\n      if not is_fair(n): return False\n      root = math.sqrt(n)\n      if root != math.floor(root): return False\n      if not is_fair(long(root)): return False\n      return True\n  \n  def process():\n      a, b = sys.stdin.readline().split()\n      a = long(a)\n      b = long(b)\n      \n      count = 0\n      for i in range(a, b + 1):\n          if is_square_and_fair(i): count = count + 1\n  \n      return count\n  \n  def main():\n  \n      count = int(sys.stdin.readline())\n      for index in range(count):\n          result = process()\n          print "Case #%d: %s" % (index + 1, result)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 31
 \n  \n  def calculate_max_score(scores_sum):\n      if scores_sum % 3 == 1:\n          max_score = (scores_sum + 2) / 3\n          return (max_score, max_score)\n      if scores_sum % 3 == 2:\n          max_score = (scores_sum + 1) / 3\n          return (max_score, max_score + 1)\n      max_score = scores_sum / 3\n      if max_score == 0:\n          return (0, 0)\n      return (max_score, max_score + 1)\n  \n  def find_max_dancers(s, p, *scores_sums):\n      dancers_count = 0\n      for scores_sum in scores_sums:\n          (normal_max, surprise_max) = calculate_max_score(scores_sum)\n          if normal_max >= p:\n              dancers_count = dancers_count + 1\n              continue\n          if surprise_max >= p and s > 0:\n              s = s - 1\n              dancers_count = dancers_count + 1\n              continue\n      return dancers_count\n  \n  def main():\n  \n      case_count = int(sys.stdin.readline())\n  \n      for case_index in range(1, case_count + 1):\n          line = sys.stdin.readline().strip().split(' ')\n          s = int(line[1])\n          p = int(line[2])\n          scores_sums = [int(scores_sum) for scores_sum in line[3:]]\n          print 'Case #%i: %s' % (case_index, find_max_dancers(s, p, *scores_sums))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 31
'''\n  Created on Apr 12, 2013\n  \n  @author: Moatasem\n  '''\n  \n  \n  \n  def isPalindrome(word):\n      isPalin=False\n      if(len(word)%2==0):\n          f_half=word[0:len(word)/2];\n          s_half=word[len(word)/2:len(word)][::-1]\n          if( f_half==s_half):\n              isPalin= True\n      else:\n          f_half=word[0:len(word)/2]\n          s_half=word[(len(word)/2)+1:len(word)][::-1]\n          if( f_half==s_half):\n              isPalin= True\n      return isPalin\n      \n  def getNumberOfFairAndSquare(range_):\n      start=range_[0]\n      end=range_[1]\n      count_=0\n      for i in range(start,end+1):\n          root=math.sqrt(i);\n          if(root.is_integer() and isPalindrome(str(int(root))) and isPalindrome(str(i))):\n              count_+=1\n      return count_\n          \n          \n      \n  \n  f_r = open('C.in',"r")\n  n_test=int(f_r.readline().strip()) \n  f_w = open("C.out", "w")\n  for i in range(n_test):\n      range_ =map(int,f_r.readline().split())\n      result=getNumberOfFairAndSquare(range_)\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n  f_r.close()\n  f_w.close()\n <CODESPLIT> 32
'''\n  Created on Apr 14, 2012\n  \n  @author: moatasem\n  '''\n  \n  \n  def isSurprising(t):\n      if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):\n          return True\n      else:\n          return False\n  \n  \n  def getAllTriplets(n):\n      h=[]\n      for i in xrange(11):\n          for j in xrange(i,11):\n              for  k in xrange(j,11):\n                  if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):\n                      h.append((i,j,k))\n              \n      return  h\n  \n  def getInfo(p,total,S):\n      g= getAllTriplets(total)\n      if(S):\n          s_=len(g)\n          indcies=[]\n          for i in xrange (s_):\n              if(isSurprising(g[i])):\n                  indcies.append(i)\n          for i in xrange (len(indcies)):  \n              g.remove(g[indcies[i]])\n      equ=False\n      sur=False\n      sur_equ=False\n      for i in xrange(len(g)):\n          if(max(g[i])>=p):\n              if(isSurprising(g[i])):\n                  sur_equ=True\n              else:\n                  equ=True\n          elif(isSurprising(g[i])):\n                  sur=True\n      return sur_equ,equ,sur\n             \n  f = open("b_.in", "r")\n  n=int(f.readline().strip())\n  for k  in xrange(n):\n      d=f.readline().strip()\n      googlers=[]\n      g=[int(i) for i in d.split(" ")]\n      N=g[0]\n      S=g[1]\n      noSu=False\n      if(S==0):\n          noSu=True\n      p=g[2]\n      count=0\n      equ_count=0;\n      both_count=0;\n      sur_count=0;\n      first_count=0;\n      googlers=g[3:len(g)]\n      for o in xrange(N):\n          info=getInfo(p,googlers[o],noSu)\n          if(info[0]==True and info[1]==False and S<>0): #101 /100\n              count+=1\n              S-=1\n          elif(info[0]==True and info[1]==True):#110 / 111\n              first_count+=1\n          elif(info[1]==True and info[2]==True):#011\n              both_count+=1\n          elif(info[1]==True):#010\n              count+=1\n          elif(info[2]==True):#001\n              sur_count+=1\n      count+=first_count\n      if(S>0):\n          if(first_count>S):\n              S=0\n          elif(first_count <=S) :\n              S-=first_count\n              if(S>0):\n                   if(both_count>S):\n                      both_count-=S\n                      S=0\n                   else:\n                      both_count=0\n      count+=both_count\n      \n      print 'Case #'+str((k+1))+": "+str(count)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n      \n  \n <CODESPLIT> 32
 \n  def isqrt(num):\n      return int(sqrt(num))\n  \n  def is_square(num):\n      return isqrt(num)**2 == num\n  \n  def is_palindrome(num):\n      return str(num) == "".join(reversed(str(num)))\n  \n  def is_fair_and_square(num):\n      return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))\n  \n  def solve(A,B):\n      count = 0\n      for i in range(A,B+1):\n          if is_fair_and_square(i):\n              count += 1\n      return count\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          A,B = [int(x) for x in raw_input().split()]\n          print "Case #%d: %d" % (i, solve(A,B))\n          \n <CODESPLIT> 33
def max_of_triplets(n):\n      a = n//3\n      if (n % 3) == 0:\n          if a == 0 : return (0,0)\n          return (a, a+1)\n      if (n % 3) == 1:\n          return (a+1, a+1)\n      if a == 9: return (10, 10)\n      return (a+1, a+2)\n  \n  def solve(scores, S, p):\n      t = 0\n      for s in scores:\n          a,b = max_of_triplets(s)\n          if a >= p:\n              t += 1\n          elif b >= p and S > 0:\n              t += 1\n              S -= 1\n      return t\n  \n  if __name__ == "__main__":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          nums = map(int, raw_input().strip().split())\n          N = nums[0]\n          S = nums[1]\n          p = nums[2]\n          scores = nums[3:]\n          if len(scores) != N:\n              print "WTF", i\n          print "Case #%d: %d" % (i, solve(scores, S, p))\n      \n <CODESPLIT> 33
 \n  def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      A, B = read_integers()\n      A_root = int( ceil( sqrt( A ) ) )\n      B_root = int( floor( sqrt( B ) ) )\n      count = 0\n      for root in range( A_root, B_root + 1 ):\n          word = str( root )\n          if word == word[ : : -1 ]:\n              word = str( root*root )\n              if word == word[ : : -1 ]:\n                  count += 1\n      print 'Case #%i:' % ( t + 1 ), count\n <CODESPLIT> 34
def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 ),\n      line = iter( read_integers() )\n      N = line.next()\n      S = line.next()\n      p = line.next()\n      t = sorted( line )\n      count = 0\n      while t and ( t[ -1 ] + 2 )/3 >= p:\n          t.pop()\n          count += 1\n      if p > 1:\n          while S and t and ( t[ -1 ] + 4 )/3 >= p:\n              t.pop()\n              S -= 1\n              count += 1\n      print count\n <CODESPLIT> 34
 \n  def isPalindrome(x):\n      x = str(x)\n      if x[0] != x[-1]:\n          return 0\n      y = x[::-1]\n      if x == y:\n          return 1\n      return 0\n  \n  def generate():\n      digits = [str(x) for x in range(0,10)]\n      dplus = digits + [""]\n  \n      for x in range(1,10):\n          y = x**2\n          if isPalindrome(y):\n              print y\n  \n      for x in range(1,10**4):\n          x = str(x)\n          y = x[::-1]\n          pals = [ int(x+z+y)**2 for z in dplus ]\n          for p in pals:\n              if isPalindrome(p):\n                  print p\n  \n  if __name__ == "__main__":\n      f = open( sys.argv[1] )\n      sqpals = np.array([int(l) for l in f])\n      sqpals.sort()\n      f.close()\n  \n      f = open( sys.argv[2] )\n      t = int(f.readline())\n      t = 1\n      for l in f:\n          a,b = [int(x) for x in l.split()]\n          mt = sqpals >= a\n          lt = sqpals <= b\n          output = sum( mt&lt )\n          print "Case #%s: %s"%(t,output)\n          t += 1\n      \n <CODESPLIT> 35
 \n  \n  if __name__ == "__main__":\n  \n      f = open( "B-small-attempt1.in.txt" )\n      g = open( "output_small.txt", "w" )\n  \n      f.readline()\n      line = f.readline()\n      caseI = 1\n      while line != "":\n          line = [ int(x) for x in line.split() ]\n          N = line[0]\n          surprise = line[1]\n          p = line[2]\n          points = line[3:]\n          points.sort()\n          points.reverse()\n  \n          maxp = 0\n          either = 0\n          make_surprise = 0\n          for x in points:\n              this_p = (x+2)/3\n              if x in [0,1,29,30]:\n                  if this_p >= p:\n                      maxp += 1\n              elif this_p >= p:\n                  either += 1\n                  maxp += 1\n              elif this_p == p-1 and (x+2)%3 > 0:\n                  make_surprise += 1\n              else:\n                  either += 1\n  \n          if make_surprise >= surprise:\n              make_surprise -= surprise\n              maxp += surprise\n              make_surprise = 0\n          else:\n              maxp += make_surprise\n  \n          g.write( "Case #%s: %s\n"%(caseI,maxp) )\n  \n          line = f.readline()\n          caseI += 1\n  \n      f.close()\n      g.close()\n      \n <CODESPLIT> 35
 \n  possibles = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]\n  \n  for case in xrange(codejam.readint()):\n      A, B = map(int, codejam.readstring().split())\n      count = 0\n      for possible in possibles:\n          if A > possible:\n              continue\n  \n          if B < possible:\n              break\n  \n          count += 1\n  \n      print "Case #%d: %d" % (case + 1, count)\n <CODESPLIT> 36
 \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> 36
 \n  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case\n  	with file(filepath, 'rb') as f_in:\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			yield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 1\n  		case = []\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			case.append(line.strip().split(' '))\n  			if not line_index % n:\n  				yield case_counter, case\n  				case_counter += 1\n  				case = []\n  \n  def iterate_cases_glpc(filepath):		#glpc - given lines per case\n  	with file(filepath, 'rb') as f_in:\n  		case_counter = 0\n  		new_case = True\n  		for line_index, line in enumerate(f_in):\n  			if line_index == 0: #T\n  				continue\n  			if new_case:\n  				new_case = False\n  				case_counter += 1\n  				case = []\n  				assert len(line.strip().split(' ')) == 1\n  				lines_left = int(line.strip())\n  				if not lines_left:\n  					new_case = True\n  					yield case_counter, case\n  				continue\n  			if lines_left:\n  				lines_left -= 1\n  				case.append(line.strip().split(' '))\n  			if not lines_left:\n  				new_case = True\n  				yield case_counter, case\n  			\n  def part_of_list_to_int(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(int(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_int(array):\n  	return part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  	assert len(array) == len(flags)\n  	output = []\n  	for index, elem in enumerate(array):\n  		if flags[index]:\n  			output.append(float(elem))\n  		else:\n  			output.append(elem)\n  	return output\n  \n  def list_to_float(array):\n  	return part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  	elem_len = len(array[0])\n  	assert index < elem_len\n  	for elem in array:\n  		assert elem_len == len(elem)\n  	max_sub = array[0][index]\n  	max_elem = array[0]\n  	for elem in array:\n  		if elem[index] > max_sub:\n  			max_sub = elem[index]\n  			max_elem = elem\n  	return max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  	list_len = len(a_list)\n  	if list_len == 1:\n  		if a_list[0] == value:\n  			return pos\n  		return -1\n  	if a_list[list_len/2] > value:\n  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  	else:\n  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  	\n  def list_index_in_sorted_list(a_list, value):\n  	return list_index_in_sorted_with_position(a_list, value, 0)\n  	\n  def check_palindrome(value):\n  	val_str = str(value)\n  	length = len(val_str)\n  	for i in xrange(length):\n  		if val_str[i] != val_str[length - 1 - i]:\n  			return False\n  	return True\n  \n  def calc_result(case):\n  	A = int(case[0])\n  	B = int(case[1])\n  	\n  	A_sqrt = int(math.ceil(math.sqrt(A)))\n  	B_sqrt = int(math.floor(math.sqrt(B)))\n  	\n  	print "\tinterval: %s" % [A, B]\n  	print "\tsqrt_int: %s" % [A_sqrt, B_sqrt]\n  	\n  	count = 0\n  	for i in xrange(A_sqrt, B_sqrt + 1):\n  		if check_palindrome(i):\n  			if check_palindrome(i * i):\n  				count += 1\n  				print "\tfound: %d, %d" % (i, i * i)\n  	\n  	print "\ttot: %d" % count\n  	print \n  	result = "%s" % count\n  	return result\n  \n  def main(filepath):\n  	start_time = time.time()\n  	with file('output.txt', 'wb') as f_out:\n  		\n  		for case_index, case in iterate_cases_1lpc(filepath):\n  			\n  			print "case #%d: time:%.02f" % (case_index, time.time() - start_time)\n  			result = calc_result(case)\n  			\n  			f_out.write("Case #%d: %s\n" % (case_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 37
 \n  class Triplet(object):\n  	def __init__(self, i, j, k):\n  		self.i = i\n  		self.j = j\n  		self.k = k\n  		self.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))\n  		self.valid = self.max_diff <= 2\n  		self.surprise = self.max_diff == 2\n  	\n  	def get_tuple(self):\n  		return (self.i, self.j, self.k)\n  	\n  	def get_redundancies(self):\n  		return [(self.i, self.j, self.k),\n  				(self.i, self.k, self.j),\n  				(self.j, self.i, self.k),\n  				(self.j, self.k, self.i),\n  				(self.k, self.i, self.j),\n  				(self.k, self.j, self.i)]\n  \n  class Googler(object):\n  	def __init__(self, total_points):\n  		self.total_points = total_points\n  		self.regular_triplets = []\n  		self.surprise_triplets = []\n  		\n  		for i in xrange(0, 11):\n  			if i > total_points:\n  				break\n  			for j in xrange(i, 11):\n  				if i + j > total_points:\n  					break\n  				k = total_points - i - j\n  				if k > 10:\n  					break\n  				triplet = Triplet(i, j, k)\n  				self.add(triplet)\n  		\n  		self.can_surprise = len(self.surprise_triplets) > 0\n  		self.actual_triplet = None\n  		self.best_result = -1\n  		\n  	def add(self, triplet):\n  		if not triplet.valid:\n  			return\n  		if triplet.surprise:\n  			self.add_uniquely(triplet, is_surprise=True)\n  		else:\n  			self.add_uniquely(triplet, is_surprise=False)\n  			\n  	def add_uniquely(self, triplet, is_surprise):\n  		if is_surprise:\n  			input_list = self.surprise_triplets\n  		else:\n  			input_list = self.regular_triplets\n  		for triplet_redundancy in triplet.get_redundancies():\n  			if triplet_redundancy in input_list:\n  				return\n  		input_list.append(triplet.get_tuple())\n  	\n  	def __str__(self):\n  		return "regular: %s\nsurprise: %s" % (self.regular_triplets,\n  											  self.surprise_triplets)\n  	\n  	def set_googler(self, is_surprise=False):\n  		if not is_surprise:\n  			self.actual_triplet = self.regular_triplets[0]\n  		else:\n  			self.actual_triplet = self.surprise_triplets[0]\n  		self.calc_best_result()\n  	\n  	def calc_best_result(self):\n  		self.best_result = max(self.actual_triplet)\n  \n  		\n  class Contest(object):\n  	def __init__(self, num_of_googlers, results):\n  		self.num = num_of_googlers\n  		self.googlers = []\n  		for i in xrange(self.num):\n  			self.googlers.append(Googler(results[i]))\n  	\n  	def calc(self, num_of_surprises, p):\n  		max_googlers_over_p = 0\n  		for surprise_perm in self.get_permutations(num_of_surprises):\n  			if not self.validate_permutation(surprise_perm):\n  				continue\n  			count = 0\n  			for index, googler in enumerate(self.googlers):\n  				googler.set_googler(index in surprise_perm)\n  				if googler.best_result >= p:\n  					count += 1\n  			if count >= max_googlers_over_p:\n  				max_googlers_over_p = count\n  		return max_googlers_over_p\n  	\n  	def get_permutations(self, num_of_surprises):\n  		results = get_perms(0, self.num, num_of_surprises)\n  		if not results:\n  			return [[]]\n  		return results\n  	\n  	def validate_permutation(self, perm):\n  		for googler_index in perm:\n  			if not self.googlers[googler_index].can_surprise:\n  				return False\n  		return True\n  \n  def get_perms(start_index, finish_index, amount):\n  	if amount == 0:\n  		return []\n  	result_list = []\n  	for i in xrange(start_index, finish_index):\n  		if amount == 1:\n  			result_list.append([i])\n  			continue\n  		for result in get_perms(i + 1, finish_index, amount - 1):\n  			new_result = [i]\n  			new_result.extend(result)\n  			result_list.append(new_result)\n  	return result_list\n  		\n  def main(filepath):\n  	with file('dancing_output.txt', 'wb') as f_out:\n  		with file(filepath, 'rb') as f_in:\n  			for line_index, line in enumerate(f_in):\n  				if line_index == 0: #T\n  					continue\n  				input_list = line.strip().split(' ')\n  				num_of_googlers = int(input_list[0])\n  				num_of_surprises = int(input_list[1])\n  				p = int(input_list[2])\n  				results = []\n  				for res in input_list[3:]:\n  					results.append(int(res))\n  				contest = Contest(num_of_googlers, results)\n  				result = contest.calc(num_of_surprises, p)\n  				\n  				print\n  				print line.strip()\n  				print result\n  				\n  				f_out.write("Case #%d: %d\n" % (line_index, result))\n  				\n  if __name__ == '__main__':\n  	main(sys.argv[1])\n <CODESPLIT> 37
def IsPal(n):\n      S = str(n);\n      return S == S[::-1];\n  \n  \n  def Gen():\n      LIM = 10**14;\n      N = 10**7;\n      LIST = [];\n      for i in range(1, N):\n          if IsPal(i):\n              if IsPal(i*i):\n                  LIST.append(i);\n      return LIST\n  \n  PP = Gen();\n  \n  T = int(raw_input());\n  for q in range(1,T+1):\n      [A,B] = map(int, raw_input().split());    \n      ANS = 0;\n      for i in range(len(PP)):\n          if B >= PP[i]**2 >= A:\n              ANS += 1;\n      \n      print "Case #%d: %d" %(q, ANS);\n <CODESPLIT> 38
T = int(raw_input());\n  for i in range(T):\n     Data = map(int, raw_input().split());\n     N = Data.pop(0);\n     S = Data.pop(0);\n     p = Data.pop(0);\n     \n     Good = 0;\n     for score in Data:\n        if score >= 3*p-2:\n           Good += 1;\n        else:\n           if (S > 0) and (score >= 3*p-4) and (score >= p):\n              S -= 1;\n              Good += 1;\n  \n     print "Case #%d:" % (i+1),;\n     print Good;\n     \n  \n <CODESPLIT> 38
 \n  def isPalindrome(s):\n    length = len(s)\n    for i in xrange(length / 2):\n      if s[i] != s[length - 1 - i]: \n        return False\n    return True\n  \n  n = int(raw_input())\n  for i in range(n):\n    a, b = map(int, raw_input().strip().split(' '))\n    count = 0\n    for j in range(a, b+1):\n      if isPalindrome(str(j)):\n        s = math.sqrt(j)\n        if s == int(s) and isPalindrome(str(int(s))):\n          count += 1\n    print 'Case #%i: %i' % (i+1, count)\n <CODESPLIT> 39
 \n  T = int(sys.stdin.readline())\n  for i in range(T):\n      line = sys.stdin.readline().strip()\n      values = map(int, line.split(' '))\n      N = values[0]\n      S = values[1]\n      p = values[2]\n      totals = values[3:]\n      ans = 0\n      for total in totals:\n          base = total / 3\n          remainder = total - (base * 3)\n          scores = [base, base, base]\n          j = 0\n          while remainder > 0:\n              scores[j] += 1\n              remainder -= 1\n              j = (j + 1) % 3\n          if max(scores) >= p:\n              ans += 1\n          else:\n              if S > 0:\n                  remainder = total - (base * 3)\n                  if remainder == 0 and base > 0:\n                      if base + 2 >= p:\n                          ans += 1\n                          S -= 1\n                  elif base + min(remainder, 2) >= p:\n                      ans += 1\n                      S -= 1\n      print 'Case #%s: %s' % (i+1, ans)\n <CODESPLIT> 39
 \n  \n  LIMIT = 10\n  \n  def check_palindrome(number):\n      rev = 0\n      runner = number\n      while runner > 0:\n          rev = rev * 10 + (runner % 10)\n          runner /= 10\n      if rev == number:\n          return True\n      else:\n          return False\n  \n  def list_to_number(number_list):\n      l = len(number_list)\n      res = 0; rres = 0\n      multi = 1\n      for i in xrange(1, l + 1):\n          res += number_list[l - i] * multi\n          rres += number_list[i - 1] * multi\n          multi *= 10\n      return (res, rres)\n  \n  def gen_one_side(side_length):\n      state = [0 for _ in xrange(side_length)]\n      done = False\n  \n      while not done:\n          if state[-1] != 0:\n              yield state\n          state[-1] += 1\n          curr = side_length - 1\n          while state[curr] == LIMIT:\n              if curr == 0:\n                  done = True\n                  break\n              state[curr] = 0\n              curr -= 1\n              state[curr] += 1\n  \n  def gen_odd_palindrome(side_length):\n      if side_length == 0:\n          for i in xrange(1, 10):\n              yield i\n      else:\n          multi = 10**side_length\n          for one_side in gen_one_side(side_length):\n              number, rnumber = list_to_number(one_side)\n              for i in xrange(LIMIT):\n                  yield number + i * multi + rnumber * multi * 10\n  \n  def gen_even_palindrome(side_length):\n      multi = 10**side_length\n      for one_side in gen_one_side(side_length):\n          number, rnumber = list_to_number(one_side)\n          yield number + rnumber * multi\n  \n  \n  def gen_palindrome():\n      l = 1\n  \n      while True:\n          if l % 2 == 1:\n              for odd_pal in gen_odd_palindrome((l - 1) / 2):\n                  yield odd_pal\n          else:\n              for even_pal in gen_even_palindrome(l / 2):\n                  yield even_pal\n          l += 1\n  \n  \n  cache = []\n  upper = 10**14\n  for pal in gen_palindrome():\n      pal2 = pal**2\n      if pal2 > upper:\n          break\n      if check_palindrome(pal2):\n          cache.append(pal2)\n  \n  cl = len(cache)\n  T = int(raw_input().strip())\n  for i in xrange(T):\n      low_ind = 0\n      high_ind = cl - 1\n      A, B = map(int, raw_input().strip().split(' '))\n  \n      while cache[low_ind] < A:\n          low_ind += 1\n      while cache[high_ind] > B:\n          high_ind -= 1\n  \n  \n      if low_ind <= high_ind:\n          print "Case #%s: %s" % (i + 1, high_ind - low_ind + 1)\n      else:\n          print "Case #%s: 0" % (i + 1)\n <CODESPLIT> 40
 \n  surprising = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]\n  regular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]\n  \n  f = open(argv[1], 'r')\n  T = int(f.readline().strip('\n'))\n  for i in range(T):\n  	both = 0\n  	surp_only = 0\n  	line = f.readline().strip('\n').split(' ')\n  	N = int(line[0]) # What for?\n  	S = int(line[1])\n  	p = int(line[2])\n  	ts = map(int, line[3:])\n  	for t in ts:\n  		if reduce(max, map(max, regular[t])) >= p:\n  			both += 1\n  		elif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:\n  			surp_only += 1\n  \n  	print "Case #%s: %s" % (i + 1, both + min(surp_only, S))\n <CODESPLIT> 40
 \n  main = do\n      interact (unlines . map showCase . zip [1..] . map (solve . interval) . tail . lines)\n  \n    where\n      interval :: String -> (Int64, Int64)\n      interval l =\n          let [a, b] = map read $ splitOn " " l\n          in (a, b)\n  \n      showCase :: (Int64, Int) -> String\n      showCase (i, r) = printf "Case #%d: %d" i r\n  \n  solve :: (Int64, Int64) -> Int\n  solve (a, b) =\n      length $ takeWhile (<= b) $ dropWhile (< a) [ sq\n          | x <- [0..], palindrome x, let sq = x * x, palindrome sq\n          ]\n    where\n      square x = x * x\n      start = truncate $ sqrt $ double a\n  \n  -- | Returns True if s is a palindrome.\n  palindrome s =\n      let s' = show s\n      in s' == reverse s'\n  \n  double :: Int64 -> Double\n  double = fromIntegral\n <CODESPLIT> 41
 \n  main = interact (unlines . map showCase . zip [1..] . tail . lines)\n    where\n      showCase (i, t) = "Case #" ++ show i ++ ": " ++ solve t\n  \n  solve = show . solve' . map read . words\n    where\n      solve' (n:s:p:ts) = \n          let pts = map maxPoints ts\n              directs = filter ((>= p) . fst) pts\n              surps = filter (\(pd, ps) -> pd < p && ps >= p) pts\n          in length directs + min (length surps) s\n          \n  maxPoints :: Int -> (Int, Int)\n  maxPoints tot = \n      (maxScore $ scores normal, maxScore $ scores surprising)\n    where\n      scores cond = [ (x, y, z) |\n          x <- [0..10], y <- [0..10], z <- [0..10]\n          , x + y + z == tot, cond (x, y, z)\n          ]\n      normal t = bestScore t - badScore t <= 1\n      surprising t = bestScore t - badScore t <= 2\n      maxScore = maximum . map bestScore \n  \n  bestScore (x, y, z) = maximum [x, y, z]\n  badScore (x, y, z) = minimum [x, y, z]\n <CODESPLIT> 41
def checkpalin(s):\n      k = len(s)//2\n      for i in range(k):\n          if s[i]!= s[-1-i]:\n              return False\n      return True\n  \n  goods = [1,2,3]\n  \n  for i in range(1000):\n      for j in ['']+list(range(10)):\n          test = str(i)+str(j)+(str(i)[::-1])\n          if checkpalin(str(int(test)**2)):\n              goods.append(int(test))\n  goods = list(set(goods))\n  goods.sort()\n  \n  T = int(input())\n  \n  for case in range(1,T+1):\n      A,B = [int(x) for x in input().split()]\n      ans = 0\n      for n in goods:\n          if A <= n*n <= B:\n              ans += 1\n      print("Case #",case,": ",ans,sep='')\n <CODESPLIT> 42
T=int(input())\n  for t in range(T):\n    l = [int(x) for x in input().split()]\n    n,huh,p = l[:3]\n    ss = l[3:]\n    nice, maybe = 0,0\n    for s in ss:\n      if s>= p+2*max(p-1,0):\n        nice += 1\n      elif s>= p+2*max(p-2,0):\n        maybe += 1\n    y = nice + min(maybe,huh)\n    print('Case #',t+1,': ',y,sep = '')\n  \n  \n <CODESPLIT> 42
 \n  \n  \n  \n  problem = "C"\n  tag = "small" #commonly sample, small, or large\n  suffix = "-attempt0" #used sometimes for indexing later input files\n  table_of_fairs = np.array([0, 1, 4, 9, 121, 484, 676, 10201, 12321, 14641, \n  40804, 44944, 69696, 94249, 698896, 1002001, 1234321, 4008004, 5221225, 6948496, \n  100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, \n  404090404, 522808225, 617323716, 942060249, 10000200001, 10221412201, 12102420121, \n  12345654321, 40000800004, 637832238736, 1000002000001, 1002003002001, 1004006004001, \n  1020304030201, 1022325232201, 1024348434201, 1086078706801, 1210024200121, \n  1212225222121, 1214428244121, 1230127210321, 1232346432321, 1234567654321, \n  1615108015161, 4000008000004, 4004009004004, 4051154511504, 5265533355625, \n  9420645460249, 100000020000001, 100220141022001, 102012040210201, 102234363432201, \n  121000242000121, 121242363242121, 123212464212321, 123456787654321, \n  123862676268321, 144678292876441, 165551171155561, 400000080000004, \n  900075181570009, 4099923883299904, 10000000200000001, 10002000300020001, \n  10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, \n  10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, \n  10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, \n  12120030703002121, 12122232623222121, 12124434743442121, 12321024642012321, \n  12323244744232321, 12341234943214321, 12343456865434321, 12345678987654321, \n  40000000800000004, 40004000900040004, 94206450305460249, 1000000002000000001, \n  1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, \n  1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, \n  1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, \n  1232344458544432321, 1234323468643234321, 4000000008000000004, 4253436912196343524, \n  6158453974793548516, 100000000020000000001, 100002000030000200001, 100004000060000400001, \n  100020201040102020001, 100022201252102220001, 100024201484102420001, \n  100200120040021002001, 100202122050221202001, 100204124080421402001, \n  100220341262143022001, 100222343474343222001, 102010002040200010201, \n  102012022050220210201, 102014042080240410201, 102030405060504030201, \n  102032425272524230201, 102132537636735231201, 102210100272001012201, 102212122262221212201, \n  102214144272441412201, 102230523292325032201, 102232545484545232201, 102234567696765432201, \n  104190107303701091401, 121000000242000000121, 121002200252002200121, 121004400282004400121, \n  121020021070120020121, 121022221262122220121, 121024421474124420121, 121220122262221022121, \n  121222324272423222121, 121240161292161042121, 121242363484363242121, 121244565696565442121, \n  123210002464200012321, 123212222474222212321, 123230205292502032321, 123232425484524232321, \n  123234645696546432321, 123432124686421234321, 123434346696643434321, 184398883818388893481, \n  400000000080000000004, 400004000090000400004, 522815090696090518225, 906086675171576680609, \n  942064503484305460249, 6916103777337773016196, 10000000000200000000001, 10000220001410002200001, \n  10002002100400120020001, 10002222123632122220001, 10020010200400201002001, 10020230421612403202001, \n  10022014302620341022001, 10022234545854543222001, 10201000020402000010201, 10201222221612222210201, \n  10203022140604122030201, 10203244363836344230201, 10221210222622201212201, 10221432643834623412201, \n  10223234344844343232201, 10224609234443290642201, 12100000002420000000121, 12100242003630024200121,\n  12102202302620320220121, 12102444325852344420121, 12122010222622201022121, 12122252443834425222121, \n  12124214524842541242121, 12321000024642000012321, 12321244225852244212321, 12323222344844322232321, \n  12343210246864201234321, 12384043938083934048321, 12599536942224963599521, 16593841302620314839561, \n  40000000000800000000004, 1000000000002000000000001, 1000002000003000002000001, \n  1000004000006000004000001, 1000020200104010020200001, 1000022200125210022200001, 1000024200148410024200001, 1000200030004000300020001, 1000202030205020302020001, 1000204030408040304020001, 1000220232126212320220001, 1000222232347432322220001, 1002001002004002001002001, 1002003004005004003002001, 1002005006008006005002001, 1002021222306032221202001, 1002023224327234223202001, 1002201232026202321022001, 1002203234227224323022001, 1002221454348434541222001, 1002223456569656543222001, 1020100000204020000010201, 1020102020205020202010201, 1020104040208020404010201, 1020120402306032040210201, 1020122422327232242210201, 1020300010207020100030201, 1020302030406040302030201, 1020304050607060504030201, 1020320414309034140230201, 1020322434528254342230201, 1020324454749474544230201, 1022121002226222001212201, 1022123024227224203212201, 1022141424528254241412201, 1022143446549456443412201, 1022321210249420121232201, 1022323232448442323232201, 1022325254649464525232201, 1210000000024200000000121, 1210002200025200022000121, 1210004400028200044000121, 1210020020107010200200121, 1210022220126210222200121, 1210024420147410244200121, 1210220032026202300220121, 1210222232227222322220121, 1210242254148414522420121, 1210244454369634544420121, 1212201002226222001022121, 1212203204227224023022121, 1212221040509050401222121, 1212223242528252423222121, 1212225444549454445222121, 1212421234248424321242121, 1212423436449446343242121, 1232100000246420000012321, 1232102220247420222012321, 1232120202329232020212321, 1232122422348432242212321, 1232124642369632464212321, 1232322032448442302232321, 1232324252649462524232321, 1234321002468642001234321, 1234323224469644223234321, 1821056104269624016501281, 4000000000008000000000004, 4000004000009000004000004, 4618627222542452227268164, 6942236477330337746322496, 9420645034800084305460249, 40460195511188111559106404, 100000000000020000000000001, 100000220000141000022000001, 100002002010040010200200001, 100002222012363210222200001, 100020001200040002100020001, 100020221222161222122020001, 100022003410262014300220001, 100022223434585434322220001, 100200100020040020001002001, 100200320240161042023002001, 100202104032060230401202001, 100202324254383452423202001, 100220121220262022121022001, 100220341462383264143022001, 100222125432484234521222001, 102010000002040200000010201, 102010222202161202222010201, 102012022032060230220210201, 102012244234383432442210201, 102030201204060402102030201, 102030423426181624324030201, 102032223434282434322230201, 102212100022262220001212201, 102212322442383244223212201, 102214124054282450421412201, 102232321224484422123232201, 121000000000242000000000121, 121000242000363000242000121, 121002202210262012202200121, 121002444212585212444200121, 121022001220262022100220121, 121022243242383242342220121, 121024203630484036302420121, 121220100022262220001022121, 121220342242383242243022121, 121222304234282432403222121, 121242121242484242121242121, 123210000002464200000012321, 123210244202585202442012321, 123212222232484232222212321, 123232201224484422102232321, 123432100024686420001234321, 400000000000080000000000004, 923860899791363197998068329, 4872133543202112023453312784, 9658137819052882509187318569, 10000000000000200000000000001, 10000002000000300000020000001, 10000004000000600000040000001, 10000020200010401000202000001, 10000022200012521000222000001, 10000024200014841000242000001, 10000200021000400012000200001, 10000202021020502012020200001, 10000204021040804012040200001, 10000220221212621212202200001, 10000222221234743212222200001, 10002000102000400020100020001, 10002002102200500220120020001, 10002004102400800420140020001, 10002020304030603040302020001, 10002022304232723240322020001, 10002200143002620034100220001, 10002202143222722234120220001, 10002220345234843254302220001, 10002222345456965454322220001, 10020010000200400200001002001, 10020012002200500220021002001, 10020014004200800240041002001, 10020030220410601402203002001, 10020032222412721422223002001, 10020210221220602212201202001, 10020212223240704232221202001, 10020230441632823614403202001, 10020232443654945634423202001, 10022010100002720000101022001, 10022012102202620220121022001, 10022014104402720440141022001, 10022030322230903222303022001, 10022032324432823442323022001, 10022034326634943662343022001, 10022210341004940014301222001, 10022212343224842234321222001, 10022214345444944454341222001, 10201000000020402000000010201, 10201002020020502002020010201, 10201004040020802004040010201, 10201020402030603020402010201, 10201022422032723022422010201, 10201200001200700210000210201, 10201202021220602212020210201, 10201204041240704214040210201, 10201220403410901430402210201, 10201222423432823432422210201, 10201224443454945434442210201, 10203020102040604020102030201, 10203022122240704222122030201, 10203040506070807060504030201, 10203042526272927262524030201, 10203220123022922032102230201, 10203222143242824234122230201, 10203224163462926436142230201, 10221210000222622200001212201, 10221212022222722222021212201, 10221230422432823422403212201, 10221232444434943444423212201, 10221412221442824412221412201, 10221414243462926434241412201, 10223232102244844220123232201, 10223234124444944442143232201, 12100000000002420000000000121, 12100002200002520000220000121, 12100004400002820000440000121, 12100020020010701002002000121, 12100022220012621002222000121, 12100024420014741002442000121, 12100220023002620032002200121, 12100222223022722032222200121, 12100242243214841234224200121, 12100244443236963234444200121, 12102200102202620220100220121, 12102202302402720420320220121, 12102220124030903042102220121, 12102222324232823242322220121, 12102224524434943442542220121, 12102420145204840254102420121, 12102422345424942454322420121, 12122010000222622200001022121, 12122012202222722220221022121, 12122032240432823404223022121, 12122034442434943424443022121, 12122230223242824232203222121, 12122232425262926252423222121, 12124212102424842420121242121, 12124214304624942640341242121, 12321000000024642000000012321, 12321002220024742002220012321, 12321020202032923020202012321, 12321022422034843022422012321, 12321024642036963024642012321, 12321222023224842232022212321, 12321224243244944234242212321, 12323220102244844220102232321, 12323222322444944422322232321, 12343210000246864200001234321, 12343212222246964222221234321, 16799008923862526832980099761, 40000000000000800000000000004, 40000004000000900000040000004, 44431002775280908257720013444, 98693567900935453900976539689, 1000000000000002000000000000001, 1000000220000014100000220000001, 1000002002001004001002002000001, 1000002222001236321002222000001, 1000020000300004000030000200001, 1000020220302216122030220200001, 1000022002321026201232002200001, 1000022222323458543232222200001, 1000200010020004000200100020001, 1000200230042016102400320020001, 1000202012221206021222102020001, 1000202232243438343422322020001, 1000220012320026200232100220001, 1000220232344238324432320220001, 1000222014541248421454102220001, 1002001000002004002000001002001, 1002001220222016102220221002001, 1002003004005006005004003002001, 1002003224225238325224223002001, 1002021020302206022030201202001, 1002021240524418144250421202001, 1002023024325228225234203202001, 1002201210022026202200121022001, 1002201430264038304620341022001, 1002203214225228225224123022001, 1002221232322248422232321222001, 1020100000000204020000000010201, 1020100222200216120022220010201, 1020102022021206021202202010201, 1020102244221438341224422010201, 1020120200302206022030020210201, 1020120422504418144052240210201, 1020122222343228223432222210201, 1020302010020406040200102030201, 1020302232242418142422322030201, 1020304032241608061422304030201, 1020322212322428242232122230201, 1022121000002226222000001212201, 1022121222422238322242221212201, 1022123024025228225204203212201, 1022141220304428244030221412201, 1022323210022448442200123232201, 1210000000000024200000000000121, 1210000242000036300002420000121, 1210002202201026201022022000121, 1210002444201258521024442000121, 1210022000320026200230002200121, 1210022242322238322232422200121, 1210024202541048401452024200121, 1210220010022026202200100220121, 1210220252044038304402520220121, 1210222212423228223242122220121, 1210242012342048402432102420121, 1212201000002226222000001022121, 1212201242222238322222421022121, 1212203204205228225024023022121, 1212223020322428242230203222121, 1212421210024248424200121242121, 1232100000000246420000000012321, 1232100244200258520024420012321, 1232102222221248421222222012321, 1232122200322248422230022212321, 1232322010022448442200102232321, 1234321000002468642000001234321, 4000000000000008000000000000004, 4844486878939076709398786844484, 6574372239019762679109322734756, 9403095533541415141453355903049, 9659504223792743472973224059569, 9848294822582726272852284928489\n  ])\n  \n  filtered_table = np.array([0, 1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001,\n         1234321, 4008004, 100020001, 102030201, 104060401, 121242121,\n         123454321, 125686521, 400080004, 404090404, 10000200001,\n         10221412201, 12102420121, 12345654321, 40000800004, 1000002000001,\n         1002003002001, 1004006004001, 1020304030201, 1022325232201,\n         1024348434201, 1210024200121, 1212225222121, 1214428244121,\n         1232346432321, 1234567654321, 4000008000004, 4004009004004,\n         100000020000001, 100220141022001, 102012040210201, 102234363432201,\n         121000242000121, 121242363242121, 123212464212321, 123456787654321,\n         400000080000004, 10000000200000001, 10002000300020001,\n         10004000600040001, 10020210401202001, 10022212521222001,\n         10024214841242001, 10201020402010201, 10203040504030201,\n         10205060806050201, 10221432623412201, 10223454745432201,\n         12100002420000121, 12102202520220121, 12104402820440121,\n         12122232623222121, 12124434743442121, 12321024642012321,\n         12323244744232321, 12343456865434321, 12345678987654321,\n         40000000800000004, 40004000900040004, 1000000002000000001,\n         1000220014100220001, 1002003004003002001, 1002223236323222001,\n         1020100204020010201, 1020322416142230201, 1022123226223212201,\n         1022345658565432201, 1210000024200000121, 1210242036302420121,\n         1212203226223022121, 1212445458545442121, 1232100246420012321,\n         1232344458544432321, 1234323468643234321, 4000000008000000004,\n         100000000020000000001, 100002000030000200001, 100004000060000400001,\n         100020201040102020001, 100022201252102220001, 100024201484102420001,\n         100200120040021002001, 100202122050221202001, 100204124080421402001,\n         100220341262143022001, 100222343474343222001, 102010002040200010201,\n         102012022050220210201, 102014042080240410201, 102030405060504030201,\n         102032425272524230201, 102212122262221212201, 102214144272441412201,\n         102232545484545232201, 102234567696765432201, 121000000242000000121,\n         121002200252002200121, 121004400282004400121, 121022221262122220121,\n         121024421474124420121, 121220122262221022121, 121222324272423222121,\n         121242363484363242121, 121244565696565442121, 123210002464200012321,\n         123212222474222212321, 123232425484524232321, 123234645696546432321,\n         123432124686421234321, 123434346696643434321, 400000000080000000004,\n         400004000090000400004, 10000000000200000000001,\n         10000220001410002200001, 10002002100400120020001,\n         10002222123632122220001, 10020010200400201002001,\n         10020230421612403202001, 10022014302620341022001,\n         10022234545854543222001, 10201000020402000010201,\n         10201222221612222210201, 10203022140604122030201,\n         10203244363836344230201, 10221210222622201212201,\n         10221432643834623412201, 10223234344844343232201,\n         12100000002420000000121, 12100242003630024200121,\n         12102202302620320220121, 12102444325852344420121,\n         12122010222622201022121, 12122252443834425222121,\n         12124214524842541242121, 12321000024642000012321,\n         12321244225852244212321, 12323222344844322232321,\n         12343210246864201234321, 40000000000800000000004,\n         1000000000002000000000001, 1000002000003000002000001,\n         1000004000006000004000001, 1000020200104010020200001,\n         1000022200125210022200001, 1000024200148410024200001,\n         1000200030004000300020001, 1000202030205020302020001,\n         1000204030408040304020001, 1000220232126212320220001,\n         1000222232347432322220001, 1002001002004002001002001,\n         1002003004005004003002001, 1002005006008006005002001,\n         1002021222306032221202001, 1002023224327234223202001,\n         1002201232026202321022001, 1002203234227224323022001,\n         1002221454348434541222001, 1002223456569656543222001,\n         1020100000204020000010201, 1020102020205020202010201,\n         1020104040208020404010201, 1020120402306032040210201,\n         1020122422327232242210201, 1020302030406040302030201,\n         1020304050607060504030201, 1020322434528254342230201,\n         1020324454749474544230201, 1022121002226222001212201,\n         1022123024227224203212201, 1022141424528254241412201,\n         1022143446549456443412201, 1022323232448442323232201,\n         1022325254649464525232201, 1210000000024200000000121,\n         1210002200025200022000121, 1210004400028200044000121,\n         1210022220126210222200121, 1210024420147410244200121,\n         1210220032026202300220121, 1210222232227222322220121,\n         1210242254148414522420121, 1210244454369634544420121,\n         1212201002226222001022121, 1212203204227224023022121,\n         1212223242528252423222121, 1212225444549454445222121,\n         1212421234248424321242121, 1212423436449446343242121,\n         1232100000246420000012321, 1232102220247420222012321,\n         1232122422348432242212321, 1232124642369632464212321,\n         1232322032448442302232321, 1232324252649462524232321,\n         1234321002468642001234321, 1234323224469644223234321,\n         4000000000008000000000004, 4000004000009000004000004,\n         100000000000020000000000001, 100000220000141000022000001,\n         100002002010040010200200001, 100002222012363210222200001,\n         100020001200040002100020001, 100020221222161222122020001,\n         100022003410262014300220001, 100022223434585434322220001,\n         100200100020040020001002001, 100200320240161042023002001,\n         100202104032060230401202001, 100202324254383452423202001,\n         100220121220262022121022001, 100220341462383264143022001,\n         100222125432484234521222001, 102010000002040200000010201,\n         102010222202161202222010201, 102012022032060230220210201,\n         102012244234383432442210201, 102030201204060402102030201,\n         102030423426181624324030201, 102032223434282434322230201,\n         102212100022262220001212201, 102212322442383244223212201,\n         102214124054282450421412201, 102232321224484422123232201,\n         121000000000242000000000121, 121000242000363000242000121,\n         121002202210262012202200121, 121002444212585212444200121,\n         121022001220262022100220121, 121022243242383242342220121,\n         121024203630484036302420121, 121220100022262220001022121,\n         121220342242383242243022121, 121222304234282432403222121,\n         121242121242484242121242121, 123210000002464200000012321,\n         123210244202585202442012321, 123212222232484232222212321,\n         123232201224484422102232321, 123432100024686420001234321,\n         400000000000080000000000004, 10000000000000200000000000001,\n         10000002000000300000020000001, 10000004000000600000040000001,\n         10000020200010401000202000001, 10000022200012521000222000001,\n         10000024200014841000242000001, 10000200021000400012000200001,\n         10000202021020502012020200001, 10000204021040804012040200001,\n         10000220221212621212202200001, 10000222221234743212222200001,\n         10002000102000400020100020001, 10002002102200500220120020001,\n         10002004102400800420140020001, 10002020304030603040302020001,\n         10002022304232723240322020001, 10002200143002620034100220001,\n         10002202143222722234120220001, 10002220345234843254302220001,\n         10002222345456965454322220001, 10020010000200400200001002001,\n         10020012002200500220021002001, 10020014004200800240041002001,\n         10020030220410601402203002001, 10020032222412721422223002001,\n         10020210221220602212201202001, 10020212223240704232221202001,\n         10020230441632823614403202001, 10020232443654945634423202001,\n         10022012102202620220121022001, 10022014104402720440141022001,\n         10022032324432823442323022001, 10022034326634943662343022001,\n         10022212343224842234321222001, 10022214345444944454341222001,\n         10201000000020402000000010201, 10201002020020502002020010201,\n         10201004040020802004040010201, 10201020402030603020402010201,\n         10201022422032723022422010201, 10201202021220602212020210201,\n         10201204041240704214040210201, 10201222423432823432422210201,\n         10201224443454945434442210201, 10203020102040604020102030201,\n         10203022122240704222122030201, 10203040506070807060504030201,\n         10203042526272927262524030201, 10203222143242824234122230201,\n         10203224163462926436142230201, 10221210000222622200001212201,\n         10221212022222722222021212201, 10221230422432823422403212201,\n         10221232444434943444423212201, 10221412221442824412221412201,\n         10221414243462926434241412201, 10223232102244844220123232201,\n         10223234124444944442143232201, 12100000000002420000000000121,\n         12100002200002520000220000121, 12100004400002820000440000121,\n         12100022220012621002222000121, 12100024420014741002442000121,\n         12100220023002620032002200121, 12100222223022722032222200121,\n         12100242243214841234224200121, 12100244443236963234444200121,\n         12102200102202620220100220121, 12102202302402720420320220121,\n         12102222324232823242322220121, 12102224524434943442542220121,\n         12102420145204840254102420121, 12102422345424942454322420121,\n         12122010000222622200001022121, 12122012202222722220221022121,\n         12122032240432823404223022121, 12122034442434943424443022121,\n         12122230223242824232203222121, 12122232425262926252423222121,\n         12124212102424842420121242121, 12124214304624942640341242121,\n         12321000000024642000000012321, 12321002220024742002220012321,\n         12321022422034843022422012321, 12321024642036963024642012321,\n         12321222023224842232022212321, 12321224243244944234242212321,\n         12323220102244844220102232321, 12323222322444944422322232321,\n         12343210000246864200001234321, 12343212222246964222221234321,\n         40000000000000800000000000004, 40000004000000900000040000004,\n         1000000000000002000000000000001, 1000000220000014100000220000001,\n         1000002002001004001002002000001, 1000002222001236321002222000001,\n         1000020000300004000030000200001, 1000020220302216122030220200001,\n         1000022002321026201232002200001, 1000022222323458543232222200001,\n         1000200010020004000200100020001, 1000200230042016102400320020001,\n         1000202012221206021222102020001, 1000202232243438343422322020001,\n         1000220012320026200232100220001, 1000220232344238324432320220001,\n         1000222014541248421454102220001, 1002001000002004002000001002001,\n         1002001220222016102220221002001, 1002003004005006005004003002001,\n         1002003224225238325224223002001, 1002021020302206022030201202001,\n         1002021240524418144250421202001, 1002023024325228225234203202001,\n         1002201210022026202200121022001, 1002201430264038304620341022001,\n         1002203214225228225224123022001, 1002221232322248422232321222001,\n         1020100000000204020000000010201, 1020100222200216120022220010201,\n         1020102022021206021202202010201, 1020102244221438341224422010201,\n         1020120200302206022030020210201, 1020120422504418144052240210201,\n         1020122222343228223432222210201, 1020302010020406040200102030201,\n         1020302232242418142422322030201, 1020304032241608061422304030201,\n         1020322212322428242232122230201, 1022121000002226222000001212201,\n         1022121222422238322242221212201, 1022123024025228225204203212201,\n         1022141220304428244030221412201, 1022323210022448442200123232201,\n         1210000000000024200000000000121, 1210000242000036300002420000121,\n         1210002202201026201022022000121, 1210002444201258521024442000121,\n         1210022000320026200230002200121, 1210022242322238322232422200121,\n         1210024202541048401452024200121, 1210220010022026202200100220121,\n         1210220252044038304402520220121, 1210222212423228223242122220121,\n         1210242012342048402432102420121, 1212201000002226222000001022121,\n         1212201242222238322222421022121, 1212203204205228225024023022121,\n         1212223020322428242230203222121, 1212421210024248424200121242121,\n         1232100000000246420000000012321, 1232100244200258520024420012321,\n         1232102222221248421222222012321, 1232122200322248422230022212321,\n         1232322010022448442200102232321, 1234321000002468642000001234321,\n         4000000000000008000000000000004], dtype=object)\n  \n  \n  def read_input(infile):\n      """This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      """\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints():\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #change the dtype?\n      \n      A, B = read_bigints()\n      \n      return (A, B)\n  \n  def is_palindrome(num):\n      digits = []\n      num = int(num)\n      while num > 0:\n          digits.append(num % 10)\n          num = num / 10 #n.b. int division (discard remainder)\n  \n      return digits == digits[::-1]\n  \n      for i in range(len(digits) / 2): #n.b. int division (skips center)\n          if digits[i] != digits[-i+1]:\n              return False\n      return True\n  \n  def solve_case_simple(case):\n      A, B = case\n      \n      if B > table_of_fairs[-1]:\n          raise ValueError, "Ranges too big for lookup table!"\n      \n      valid = (A <= filtered_table) * (filtered_table <= B)\n      return valid.sum()\n  \n  def solve_case(case):\n      """Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      """\n      \n      output = solve_case_simple(case)\n      return output\n  \n  \n  if __name__ == "__main__":\n      infile = open("%s-%s%s.in" % (problem, tag, suffix), 'r')\n      outfile = open("%s-%s%s.out" % (problem, tag, suffix), 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n <CODESPLIT> 43
 \n  \n  case = 1\n  problem = "B"\n  practice = False\n  \n  if practice:\n      practice = "-practice"\n  else:\n      practice = "-attempt0"\n  if case == 0:\n      infile = open("%s-%s%s.in" % (problem, "sample", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "sample", practice), 'w')        \n  elif case == 1:\n      infile = open("%s-%s%s.in" % (problem, "small", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "small", practice), 'w')    \n  elif case == 2:\n      infile = open("%s-%s%s.in" % (problem, "large", practice), 'r')\n      outfile = open("%s-%s%s.out" % (problem, "large", practice), 'w')   \n  else:\n      raise ValueError, 'Invalid case'\n      \n  lookup = {}\n  \n  def check_total(total, p):\n      assert type(total) == int\n      resid = total % 3\n  \n      min_nosurprise = (total / 3)    \n      max_nosurprise = (total / 3) + min(1, resid)\n      \n      \n      if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):\n          if max_nosurprise >= p:\n              return 1\n          else:\n              return -1\n  \n      if max_nosurprise >= p:\n          return 1\n      elif max_nosurprise == p-1:\n          return 0\n      else:\n          return -1\n      \n  cases = int(infile.readline().strip('\n'))\n  for i in range(cases):\n      print 'case %i of %i' % (i+1, cases)\n      line = infile.readline().split()\n      N = int(line[0])\n      S = int(line[1])\n      p = int(line[2])\n      points = []\n      for item in line[3:]:\n          points.append(int(item))\n      assert N == len(points)\n      assert p <= 10\n      assert p >= 0\n      assert S >= 0\n      assert S <= N\n      \n      always = 0\n      possible = 0\n      \n      for total in points:\n          if (total, p) in lookup:\n              depends = lookup[total, p]\n          else:\n              depends = check_total(total, p)\n          \n          if depends == 1:\n              always += 1\n          elif depends == 0:\n              possible += 1\n      \n      output = '%i' % (always + min(possible, S))\n      \n      outfile.write('Case #%i: %s\n' % (i+1, output))\n      \n  infile.close()\n  outfile.close()\n <CODESPLIT> 43
 \n  \n  def is_palindrome(num):\n      s1 = str(num)\n      s2 = s1[::-1]\n      return s1 == s2\n  \n  fair_numbers = []\n  for i in range(pow(10, 7)+1):\n      if is_palindrome(i):\n          num = i*i\n          if is_palindrome(num):\n              fair_numbers.append(num)\n  \n  N = int(sys.stdin.readline())\n  for T in range(1, N+1):\n      min_val, max_val = map(int, sys.stdin.readline().strip().split())\n  \n      ans = 0\n      for num in fair_numbers:\n          if num < min_val:\n              continue\n          if num > max_val:\n              break\n          ans += 1\n      print 'Case #%(T)s: %(ans)s' % locals()\n <CODESPLIT> 44
 \n  \n  for i, line in enumerate(sys.stdin):\n      if i == 0:\n          continue\n  \n      params = [int(n) for n in line.split(' ')]\n      (N, S, p) = params[:3]\n      scores = params[3:]\n  \n      (clear, possible) = (0, 0)\n      normal_min = max(p * 3 - 2, 0)\n      suprising_min = max(p * 3 - 4, 0)\n      for score in scores:\n          if p > score:\n              continue\n          elif score >= normal_min:\n              clear += 1\n          elif score >= suprising_min:\n              possible += 1\n  \n      ans = clear + min(possible, S)\n      print 'Case #%(i)s: %(ans)s' % locals()\n <CODESPLIT> 44
 \n  \n  \n  def calculatepalindromes(ndigits):\n      if ndigits == 1:\n          return 3\n  \n      result = 0\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)/2)\n  \n      if isEven:\n          result += 1\n      else:\n          result += 3\n  \n      for numones in range(0, min(6, fillingdigits) + 1):\n          combinations = int(math.factorial(fillingdigits) / (math.factorial(fillingdigits-numones) * math.factorial(numones)))\n          result += combinations\n          if not isEven:\n              result += combinations\n  \n      return result\n  \n  \n  def findpalindromes(ndigits):\n      if ndigits == 1:\n          return [1, 2, 3]\n  \n      result = []\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)/2)\n  \n      if isEven:\n          result.append(int("2" + "0"*(fillingdigits*2) + "2"))\n      else:\n          result.append(int("2" + "0"*fillingdigits + "0" + "0"*fillingdigits + "2"))\n          result.append(int("2" + "0"*fillingdigits + "1" + "0"*fillingdigits + "2"))\n          result.append(int("1" + "0"*fillingdigits + "2" + "0"*fillingdigits + "1"))\n  \n      for numones in range(0, min(6, fillingdigits)+1):\n          ones = fillOnes([], fillingdigits, numones)\n          for o in ones:\n              if isEven:\n                  result.append(int("1" + "".join(o) + "".join(list(reversed(o))) + "1"))\n              else:\n                  result.append(int("1" + "".join(o) + "0" + "".join(list(reversed(o))) + "1"))\n                  result.append(int("1" + "".join(o) + "1" + "".join(list(reversed(o))) + "1"))\n  \n      return result\n  \n  def fillOnes(combination, size, remainingOnes):\n      if len(combination) == size:\n          return [combination]\n      result = []\n      if remainingOnes > 0:\n          c = combination + ["1"]\n          result += fillOnes(c, size, remainingOnes - 1)\n      if remainingOnes < size - len(combination):\n          c = combination + ["0"]\n          result += fillOnes(c, size, remainingOnes)\n      return result\n  \n  \n  \n  ncases = int(sys.stdin.readline())\n  \n  for t in range(1, ncases+1):\n      fairsquare = 0\n      (a, b) = sys.stdin.readline().strip().split(" ")\n      intA = int(a)\n      intB = int(b)\n      ndigitsA = len(a)\n      ndigitsB = len(b)\n      ndigitsARooted = math.ceil(ndigitsA/2)\n      ndigitsBRooted = math.ceil(ndigitsB/2)\n  \n      if ndigitsBRooted == ndigitsARooted:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA and p ** 2 <= intB:\n                  fairsquare +=1\n      else:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA:\n                  fairsquare +=1\n  \n          for i in range(ndigitsARooted + 1, ndigitsBRooted):\n              fairsquare += calculatepalindromes(i)\n  \n          palindromes = findpalindromes(ndigitsBRooted)\n          for p in palindromes:\n              if p ** 2 <= intB:\n                  fairsquare +=1\n  \n      print("Case #%d: %d" % (t, fairsquare))\n <CODESPLIT> 45
 \n  \n  def findbest(score):\n  	if score == 0: return (0, 0)\n  \n  	best = math.ceil(score / 3)\n  	bestsurp = round(score / 3) + 1\n  \n  	return (best, bestsurp)\n  	\n  sys.stdin.readline()\n  \n  casenum = 0\n  for line in sys.stdin:\n  	casenum += 1\n  \n  	data = line.strip().split(' ')\n  	maxsurprising = int(data[1])\n  	p = int(data[2])\n  	scores = data[3:]\n  	maxgooglers = 0\n  \n  	for s in scores:\n  		(best, bestsurp) = findbest(int(s))\n  		if best >= p:\n  			maxgooglers += 1\n  		else:\n  			if bestsurp >= p and maxsurprising > 0:\n  				maxgooglers += 1\n  				maxsurprising -= 1\n  \n  	print("Case #%d: %d" % (casenum, maxgooglers))\n <CODESPLIT> 45
 \n  def is_square(n):\n      if n in square:\n          return True\n      if is_fair(n):\n          root = int(math.sqrt(n))\n          if root**2 != n:\n              return False\n          ss = is_fair(root)\n          if ss: square.add(n)\n          return ss\n      return False\n  \n  def is_fair(n):\n      if n in fair:\n          return True\n      if n in unfair:\n          return False\n      sn = str(n)\n      l = len(sn)\n      mid = math.ceil(n/2)\n      if sn[0:mid] == sn[mid::-1]:\n          fair.add(n)\n          return True\n      else:\n          unfair.add(n)\n          return False\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n              \n      fair = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11])\n      unfair = set([12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n      square = set([1, 4])\n  \n      t = int(f.readline())\n      for _t in range(t):\n          s = f.readline()\n          if s:\n              x, y = s.split()\n              Total = sum([is_square(n) for n in range(int(x), int(y)+1)])             \n              print ("Case #" + str(_t+1) + ": " + str(Total))\n      \n  \n <CODESPLIT> 46
 \n  def decode_data(input):\n      output = ""\n      for letter in input:\n          if letter in library:\n              output += library[letter]\n      return output\n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())    \n      for _t in range(t):\n          s = f.readline()\n          s = s.split()\n          N = int(s[0])\n          S = int(s[1])\n          p = int(s[2])\n          low_scores = (p - 1) * 2\n          ti = s[3:]\n          ti.sort()\n          r = 0\n          ti = [int(x) for x in ti]\n          for i in ti:\n              score = i - low_scores\n              if p <= i:\n                  if score >= p:\n                      r += 1\n                  elif score >= p - 2 and S > 0:\n                      S -= 1\n                      r +=1\n          print ("Case #" + str(_t+1) + ": " + str(r))\n      \n  \n <CODESPLIT> 46
 \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      """ Returns True iff y is within relative or absolute 'epsilon' of x.\n          By default, 'epsilon' is 1e-6.\n      """\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      return [c for c in fd.readline().strip()]\n  \n  def read_ints(fd):\n      return [int(p) for p in fd.readline().strip().split()]\n  \n  def read_floats(fd):\n      return [float(p) for p in fd.readline().strip().split()]\n  \n  class Mtrx(object):\n      \n      def __init__(self, readfunc):\n          self.readfunc = readfunc\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in range(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in range(self.rows)]\n      \n      def readfromfile(self, fd):\n          self.data = []\n          self.rows, self.cols = read_ints(fd)\n          for _ in range(self.rows):\n              line = self.readfunc(fd)\n              assert len(line) == self.cols\n              self.data.extend(line)\n              \n      def __str__(self):\n          res = ""\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + "\n"\n          return res\n               \n  class IntMatrix(Mtrx):\n      def __init__(self):\n          super(IntMatrix, self).__init__(read_ints)\n  \n  class SymMatrix(Mtrx):\n      def __init__(self):\n          super(IntMatrix, self).__init__(read_syms)\n  \n  class memoizeit(object):\n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          try:\n              return self.cache[args]\n          except KeyError:\n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  class timeit(object):\n      def __init__(self, func):\n          self.func = func\n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          print self.func.__name__, "{:7.3f}s, (res: {})".format(delta, value)\n          return value\n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n <CODESPLIT> 47
 \n  OEXT = ".out"\n  IN_S = "small.in"\n  IN_L = "large.in"\n  CASE_PRFX = "Case #%s: "\n  \n  \n  def avg(L):\n      return 1.0*sum(L)/len(L)\n  \n  triplets = [[0,0,0], [0,0,1], [0,1,1], \n              [0,0,2], [0,2,2], [0,1,2],\n              [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],\n              ]\n  \n  def analyze_sum(sm, tgt):\n      av = 1.0 * sm / 3\n      av_cls = av % 1\n  \n      if av_cls > 0.1:\n          ns_max_val = math.ceil(av)\n      else:\n          ns_max_val = av \n      \n      s_max_val = 0 \n      if sm >= 2 and sm <= 28:\n          if av_cls > 0.5:\n              s_max_val = math.ceil(av) + 1\n          elif av_cls > 0.1:\n              s_max_val = math.ceil(av) \n          else:\n              s_max_val = av + 1\n      \n      if ns_max_val >= tgt:\n          res = [ns_max_val, None]\n          kind = 1\n      elif s_max_val < tgt:\n          res = [None, None]\n          kind = 0\n      else:\n          res = [None, s_max_val]\n          kind = 2\n          \n      print sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind\n      return res, kind\n  \n  def analyze_triplet(trip, tgt):\n      sm = sum(trip)\n      analyze_triplet(sm, tgt)\n      \n  \n  def read_input(filename):\n      data = []\n      with open(filename, "r") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              case = f.readline().strip().split()\n              case = [int(c) for c in case]\n              data.append({"ngoog": case[0], "ssurp": case[1], "ptgt": case[2],\n                           "trips": case[3:]})\n      return data\n  \n  def make_output(fname, output):\n      fname = fname + OEXT\n      with open(fname, "w") as f:\n          restext = []\n          for i, v in enumerate(output):\n              restext.append(CASE_PRFX % (i+1,) + str(v) + "\n")\n          f.writelines(restext)\n      \n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          ansys = [analyze_sum(c, case["ptgt"]) for c in case["trips"]]\n          non_surp_is_enough = len([k for _, k in ansys if k == 1])\n          surp_needed = len([k for _, k in ansys if k == 2])\n          if surp_needed >= case["ssurp"]:\n              res = non_surp_is_enough + case["ssurp"]\n          else:\n              res = non_surp_is_enough + surp_needed\n          output.append(res)\n      print "output:", output\n      make_output(fname, output)\n       \n  \n  main("examples.in")\n  main("small.in")\n <CODESPLIT> 47
directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'\n  \n  \n  def is_palindrome (n):\n      l = list(str(n))\n      return list(reversed(l)) == l\n  \n  def prepare ():\n      global fair_and_squares\n      fair_and_squares = []\n      \n      for i in range(1,10**7):\n          if is_palindrome(i):\n              sqr = i**2\n              if is_palindrome(sqr):\n                  fair_and_squares.append(sqr)\n      return\n  \n          \n  def solve (f_in, f_out):\n      prepare()\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          A,B = [int(x) for x in f_in.readline().split()]\n          count = len([x for x in fair_and_squares if (x>=A and x<=B)])\n          f_out.write('Case #' + str(testcase) + ': ' + str(count) + '\n')\n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n <CODESPLIT> 48
directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'\n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      print ('Test cases : ',T)\n      for i in range(1,T+1):\n          line = f_in.readline()\n          nnn = [int(x) for x in line.split()]\n          S = nnn[1]\n          p = nnn[2]\n          t = nnn[3:]\n          if p > 1:\n              A = 0\n              B = 0\n              for t_i in t:\n                  if t_i >=3*p-2:\n                      A += 1\n                  elif t_i >= 3*p-4:\n                      B += 1\n              result = A + min(B,S)\n          if p == 1:\n              result = len([x for x in t if x>=1])\n          if p == 0:\n              result=  len(t)\n          f_out.write('Case #' + str(i) + ': ' + str(result) + '\n')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n  \n  \n  \n  main_run()\n <CODESPLIT> 48
 \n  def isPalindrome(n) :\n      return str(n) == str(n)[::-1]\n  \n  def findPalindrome(n) :\n      if n % 2 == 0 : return [start*(10**(n/2)) + int(str(start)[::-1]) for start in range(10**(n/2-1),10**(n/2))]\n      if n == 1 : return range(1,10)\n      return [start*(10**(n/2)) + int(str(start)[:-1][::-1]) for start in range(10**(n/2),10**((n+1)/2))]\n  \n  def findPalindromeInRange(a, b) :\n      num = range(len(str(a)), len(str(b)) + 1)\n      allPalindrome = []\n      for n in num : allPalindrome += findPalindrome(n)\n      return filter(lambda x : a <= x <= b, allPalindrome)\n  \n  f = open('C-small-attempt0.in', 'r')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in range(T) :\n      A, B = map(int, f.readline()[:-1].split())\n      a = int(math.ceil(A**0.5))\n      b = int(B**0.5)\n      res = len(filter(lambda x : isPalindrome(x**2), findPalindromeInRange(a, b)))\n      outString = 'Case #' + str(case+1) + ': ' + str(res) + '\n'\n      print outString[:-1]\n      g.write(outString)\n  \n  f.close()\n  g.close()\n <CODESPLIT> 49
fin = open('B-small-attempt0.in', 'r')\n  fout = open('B-output.txt', 'w')\n  \n  cases = int(fin.readline()[:-1])\n  \n  for case in range(cases) :\n      line = map(int, fin.readline()[:-1].split(' '))\n      N, S, p = line[:3]\n      T = line[3:]\n      okLimit = p + 2*max(p-1,0)\n      okIfSLimit = p + 2*max(p-2,0)\n      ok = len(filter(lambda x : x >= okLimit, T))\n      okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))\n      res = ok + min(okIfS, S)\n      fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')\n      \n  fin.close()\n  fout.close()\n <CODESPLIT> 49
 \n  \n  def palindromes():\n      for digits in count(1):\n          for n in xrange(10**(digits-1), 10**digits):\n              n = str(n)\n              yield int(n + n[-2::-1])\n          for n in xrange(10**(digits-1), 10**digits):\n              n = str(n)\n              yield int(n + n[::-1])\n  \n  def is_palindrome(n):\n      n = str(n)\n      return n == n[::-1]\n  \n  def solve(A, B):\n      count = 0\n      for n in palindromes():\n          square = n**2\n          if square > B:\n              break\n          if square >= A and is_palindrome(square):\n              count += 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n  \n              A, B = map(int,fin.readline().split())\n              soln = solve(A, B)\n  \n              print >> fout, "Case #{0}: {1}".format(case, soln)\n <CODESPLIT> 50
 \n  def solve(n, s, p, scores):\n      count = 0\n      for t in scores:\n          if ceil(t/3) >= p:\n              count += 1\n          elif 2 <= t <= 28 and ceil((t+2)/3) >= p and s > 0:\n              count += 1\n              s -= 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in range(1, T+1):\n              line = map(int, fin.readline().split())\n              n, s, p, *scores = line\n              result = solve(n, s, p, scores)\n              print("Case #{0}: {1}".format(case, result), file=fout)\n <CODESPLIT> 50
 \n  def solve(lower, upper, cache):\n      counter = 0\n      for item in cache:\n          if item > upper:\n              break\n          if item < lower:\n              continue\n          counter += 1\n      return counter\n  \n  def is_palindrome(test_int):\n      str_arg = str(test_int)\n      return str_arg == str_arg[::-1]\n  \n  def generate_cache():\n      """ Generates a list of 'fair and square' numbers between 1 and 10^100\n  \n      By observation of generating the first few of these numbers it became\n      obvious that the 'roots' fitted a very specific pattern, they are either\n      single digits and 1,2 or 3; multiple digits consisting of only 1s and 0s;\n      multiple digits with a 2 at the beginning and end and 1s and 0s in the\n      middle or an odd number of digits with a single 2 in the centre and 1s and\n      0s elsewhere.\n  \n      This function therefore only looks at these numbers to build a list of all\n      valid results. """\n      cache = [9,]\n      counter = 1\n      if upper_bound is None:\n          upper_bound = pow(2,25)\n      while counter < upper_bound:\n          binary_part = "{0:b}".format(counter)\n          half_int = binary_part\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = "%s%s" % (binary_part, 2)\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = "2%s" % binary_part[1:]\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          counter += 1\n      return sorted(cache)\n  \n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file", dest="filename",\n                        help="read input from FILE", metavar="FILE")\n      parser.add_option("-c", "--cache", dest="cache_filename",\n                        help="read/write cache from/to CACHE_FILE", metavar="CACHE_FILE")\n      parser.add_option("-g", "--generate-cache", dest="generate_cache",\n                        help="generate the cache file", action="store_true")\n      cache = None\n      (options, args) = parser.parse_args()\n      if options.generate_cache:\n          cache = generate_cache()\n          if not options.cache_filename:\n              output_file = open(options.cache_filename, "w")\n              pickle.dump(cache, output_file)\n              output_file.close()\n      else:\n          cache_file = open(options.cache_filename, "r")\n          cache = pickle.load(cache_file)\n          cache_file.close()\n      if not options.filename:\n          parser.error("Must provide a filename.")\n      input_file = open(options.filename, "r")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n          case_number += 1\n          lower,upper = input_file.readline().split()\n          lower = int(lower)\n          upper = int(upper)\n          data_args = (lower, upper, cache)\n          print "Case #%d: %s" % (case_number, solve(*data_args))\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 51
 \n  def solve(N,S,p,t):\n      if p == 0:\n          return N\n      outright_wins = 0\n      potential_surprises = 0\n      win_cutoff = (p * 3) - 3\n      surprise_cutoff = win_cutoff - 2\n      for score in t:\n          if score == 0:\n              continue\n          elif score > win_cutoff:\n              outright_wins += 1\n          elif score > surprise_cutoff:\n              potential_surprises += 1\n      if potential_surprises < S:\n          return outright_wins + potential_surprises\n      else:\n          return outright_wins + S\n  \n  def parse_case(data_line):\n      bits = data_line.split()\n      N = int(bits[0])\n      S = int(bits[1])\n      p = int(bits[2])\n      t = [int(x) for x in bits[3:]]\n      return N,S,p,t\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option("-f", "--file", dest="filename",\n                        help="read input from FILE", metavar="FILE")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error("Must provide a filename.")\n      input_file = open(options.filename, "r")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n      	case_number += 1\n      	data_args = parse_case(input_file.readline())\n      	print "Case #%d: %d" % (case_number, solve(*data_args))\n  \n  if __name__ == "__main__":\n  	main()\n <CODESPLIT> 51
 \n  \n  def is_palindrome(x):\n      candidate = list(str(x))\n      while len(candidate) > 1:\n          if candidate.pop(0) != candidate.pop():\n              return False\n      return True\n  \n  \n  def square(x):\n      return x * x\n  \n  \n  def solve_case(ab, case_number):\n      fs = 0\n      root = int(math.sqrt(ab[0]))\n      sq = square(root)\n      if sq < ab[0]:\n          root += 1\n          sq = square(root)\n  \n      while sq <= ab[1]:\n          if is_palindrome(root) and is_palindrome(sq):\n              fs += 1\n  \n          root += 1\n          sq = square(root)\n  \n      print "Case #%d: %d" % (case_number, fs)\n  \n  \n  def main():\n      r = sys.stdin\n      if len(sys.argv) > 1:\n          r = open(sys.argv[1], 'r')\n  \n      total_cases = r.readline()\n      for case_number in range(1, int(total_cases) + 1):\n          ab = map(int, r.readline().strip().split(' '))\n          solve_case(ab, case_number)\n  \n  if __name__ == "__main__":\n      main()\n <CODESPLIT> 52
 \n  mod_plus_conv_with_s = {0:1, 1:1, 2:2}\n  mod_plus_conv_without_s = {0:0, 1:1, 2:1}\n  \n  def solve_case(s, p, scores,case_number):\n  	ans = 0\n  	for score in scores:\n  		if p <= (score / 3) + mod_plus_conv_without_s[score % 3]:\n  			ans = ans + 1\n  		elif s > 0 and (score / 3) > 0: \n  			if p <= (score / 3) + mod_plus_conv_with_s[score % 3]:\n  				ans = ans + 1\n  				s = s - 1\n  	print "Case #%d: %d" % (case_number, ans)\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n  	r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n  	case_line = map(int, r.readline().rstrip().split(' '))\n  	solve_case(case_line[1], case_line[2], case_line[3:], case_number)\n  \n <CODESPLIT> 52
 \n  def isPalindrome(n):\n  	n = str(n)	\n  	for i in xrange(len(n)/2):\n  		if n[i] != n[(-i-1)]:\n  			return False\n  	return True\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file("output.txt", "w")\n  \n  T = eval(f.readline())\n  \n  for case in xrange(T):\n  	data = f.readline().split()\n  	A = eval(data[0])\n  	B = eval(data[1])\n  \n  	i = A\n  	found = []\n  	while i <= B:\n  		if isPalindrome(i):\n  			sqrtI = math.sqrt(i)\n  			if sqrtI == int(sqrtI):\n  				if isPalindrome(int(sqrtI)):\n  					found.append(i)\n  		i += 1\n  \n  	fout.write("Case #%d: %d\n" %(case + 1, len(found)))\n <CODESPLIT> 53
arq = file("input.in")\n  n_cases = eval(arq.readline())\n  out = file("output.txt", "w")\n  \n  for case in xrange(n_cases):\n  \n  	data = arq.readline()\n  	data = data.strip()\n  	data = data.split(" ")\n  \n  	n = eval(data[0])\n  	s = eval(data[1])\n  	p = eval(data[2])\n  \n  	scores = []\n  	n_googlers_with_best_result = 0\n  	candidates = 0\n  \n  	for j in data[3:]:\n  		i = eval(j)\n  		if i%3 == 0:\n  			score = i/3\n  			scores.append([score, score, score])\n  		elif (i+1)%3 == 0:\n  			score = (i+1)/3\n  			scores.append([score-1, score, score])\n  		else: #(i+2)%3 == 0\n  			score = (i+2)/3\n  			scores.append([score-1, score-1, score])\n  \n  	for score in scores:\n  		if score[2] >= p:\n  			n_googlers_with_best_result +=1\n  		elif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:\n  			candidates += 1\n  \n  	n_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)\n  \n  	out.write("Case #%d: %d\n" % (case+1, n_googlers_with_best_result))\n <CODESPLIT> 53
 \n  \n  def isPal(n):\n      l = str(n)\n      return l == l[::-1]\n  \n  def solve(a, b):\n      l = int(math.ceil(math.sqrt(a)))\n      u = int(math.floor(math.sqrt(b)))\n  \n      count = 0\n      for x in range(l, u + 1):\n          if isPal(x):\n              if isPal(x*x):\n                  count += 1\n      return str(count)\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n          result = solve(a, b)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 54
 \n  \n  \n  def solve(num_surprises, p, ts):\n      s = 0\n      u = 0\n      for t in ts:\n          a = int(t/3)\n          r = t % 3\n          if a+1 >= p and not r == 0:\n              u += 1\n          elif a >= p and r == 0:\n              u += 1\n          elif a > 0 and a+1 >= p and r == 0:\n              s += 1\n          elif a+2 >= p and r == 2:\n              s += 1\n  \n      return min(num_surprises, s) + u\n          \n          \n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          line = [int(x) for x in sys.stdin.readline().split()]\n          num_surprises = line[1]\n          p = line[2]\n          ts = line[3:]\n          result = solve(num_surprises, p, ts)\n          print ("Case #%s: %s" % (i+1, result))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> 54
 \n  def ispal(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  def ispalsq(n):\n      sqrt = int(math.sqrt(n) + .01)\n      if sqrt ** 2 != n:\n          return False\n      return ispal(n) and ispal(sqrt)\n  \n  def search(s, l, idx):\n      if l % 2 == 0:\n          m = s + s[::-1]\n      else:\n          m = s[:-1] + s[::-1]\n      assert ispal(m)\n      n = int(m) ** 2\n      if not ispal(n):\n          return 0\n  \n      r = 1 if (a <= n <= b) else 0\n      for i in xrange(idx, len(s)):\n          s2 = list(s)\n          s2[i] = str(int(s2[i])+1)\n          s2 = ''.join(s2)\n          r += search(s2, l, i)\n      return r\n  \n  \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          a, b = map(int, f.readline().split())\n  \n          total = 0\n          for l in xrange(1, 150):\n              if 10 ** (l-1) > b:\n                  break\n              total += search("1" + "0" * ((l-1)/2), l, 0)\n          print "Case #%d: %d" % (_t+1, total)\n  \n <CODESPLIT> 55
 \n  if __name__ == "__main__":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          ns = map(int, f.readline().split())\n          n = ns[0]\n          s = ns[1]\n          p = ns[2]\n          assert len(ns) == n + 3\n          scores = ns[3:3+n]\n  \n          sure = 0\n          if_surprising = 0\n          for x in scores:\n              not_surprising = (x + 2) / 3\n              is_surprising = (x + 4) / 3\n              if not_surprising >= p:\n                  sure += 1\n              elif (2 <= x <= 28) and is_surprising >= p:\n                  if_surprising += 1\n          print "Case #%d: %d" % (_t+1, sure + min(if_surprising, s))\n <CODESPLIT> 55
 \n  \n  def readfile(file):\n    """\n      input:\n  \n  		T (number of test cases)\n  \n  		A B\n  \n    """\n  \n    tests = []\n  \n    T = int(file.readline().strip())\n  \n    for i in xrange(T):\n  		test = {}\n  \n  		line = file.readline().strip()\n  		parts = line.split(" ")\n  \n  		if len(parts) != 2:\n  			print "HORRIBLE ERROR IN TEST CASE %d" % (i+1,)\n  			return None\n  \n  		test['A'] = int(parts[0])\n  		test['B'] = int(parts[1])\n      \n  		tests.append(test)\n  \n    return tests\n  \n  def isPalindrome(s):\n  	"""\n  		Is s a palindrome.\n  \n  		S must be a string.\n  	"""\n  \n  	l = len(s)\n  \n  	if (l % 2) == 0:\n  		frontHalf = s[0:l/2]\n  		backHalf = s[l/2:]\n  	else:\n  		frontHalf = s[0:(l-1)/2]\n  		backHalf = s[(l+1)/2:]\n  \n  	backHalf = backHalf[::-1]\n  \n  	if frontHalf == backHalf:\n  		return True\n  	else:\n  		return False\n  \n  def isFairAndSquare(n):\n  \n  	sqrtN = int(math.sqrt(n))\n  \n  	if (sqrtN * sqrtN) != n:\n  		return False\n  \n  	if not isPalindrome(str(n)):\n  		return False\n  \n  	if not isPalindrome(str(sqrtN)):\n  		return False\n  \n  	return True\n  \n  def run(test):\n  	"""\n  		Run a test and return output.\n  	"""\n  \n  	count = 0\n  \n  	for i in xrange(test['A'], test['B'] + 1):\n  		if isFairAndSquare(i):\n  			count = count + 1\n  \n  	return count\n  \n  	i = int(math.sqrt(test['A']))\n  \n  	if (i * i) < test['A']:\n  		i = i + 1\n  \n  	while i < test['B']:\n  		if not isPalindrome(str(i)):\n  			i = i + 1\n  			continue\n  \n  		s = i * i\n  \n  		if s <= test['B']:\n  			if isPalindrome(str(s)):\n  				count = count + 1\n  		else:\n  			break\n  \n  		i = i + 1\n  \n  	return "%s" % (count, )\n  \n  file = open(sys.argv[1], "rt")\n  \n  tests = readfile(file)\n  \n  file.close()\n  \n  case = 1\n  \n  for test in tests:\n    result = run(test)\n    print "Case #%d: %s" % (case, result)\n    case = case + 1\n <CODESPLIT> 56
 \n  def readfile(filename):\n  	"""\n  		The first line of the input gives the number of test\n  		cases, T. T test cases follow. Each test case consists of\n  		a single line containing integers separated by single\n  		spaces. The first integer will be N, the number of\n  		Googlers, and the second integer will be S, the number\n  		of surprising triplets of scores. The third integer will\n  		be p, as described above. Next will be N integers ti:\n  		the total points of the Googlers.\n  	"""\n  \n  	file = open(filename, "rt")\n  \n  	retval = {}\n  \n  	T = int(file.readline().strip())\n  	retval['T'] = T\n  \n  	tests = []\n  \n  	for i in xrange(T):\n  		line = file.readline().strip()\n  \n  		parts = line.split(" ")\n  \n  		N = int(parts[0])\n  		S = int(parts[1])\n  		p = int(parts[2])\n  		t = []\n  \n  		for j in xrange(N):\n  			t = t + [int(parts[3 + j]), ]\n  \n  		test = { 'N' : N, 'S': S, 'p' : p, 't' : t }\n  		tests = tests + [test, ]\n  \n  	retval['tests'] = tests\n  	return retval\n  \n  def spread(triplet):\n  	return max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))\n  \n  def bestresult(triplet):\n  	if triplet:\n  		return max(triplet)\n  	return 0\n  \n  def getcombos(points):\n  	"""\n  		Returns ([unsurprising possibilities, ], [surprising possibilities])\n  	"""\n  \n  	unsurps = []\n  	surps = []\n  \n  	avg = points / 3.0\n  \n  	avg = int(avg)\n  \n  	tested = []\n  \n  	for i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  		for j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  			for k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  				if (i + j + k) != points:\n  					continue\n  \n  				scores = (i,j,k)\n  				scores = sorted(scores)\n  \n  				if scores in tested:\n  					continue\n  				tested.append(scores)\n  \n  				s = spread((i,j,k))\n  \n  				if (s < 2):\n  					unsurps.append(scores)\n  				elif (s == 2):\n  					surps.append(scores)\n  				else:\n  					continue\n  \n  	return (unsurps, surps)\n  \n  def getbesttriplet(triplets):\n  	best = None\n  \n  	for i in triplets:\n  		if best:\n  			if (bestresult(i) > bestresult(best)):\n  				best = i\n  		else:\n  			best = i\n  \n  	return best\n  	\n  \n  def getmulticombos(peeps):\n  	"""\n  		Return the best surprising and non-surprising possibility for\n  		each person.\n  	"""\n  \n  	ret = []\n  \n  	for p in peeps:\n  		u,s = getcombos(p)\n  \n  		bestu = getbesttriplet(u)\n  		bests = getbesttriplet(s)\n  \n  		ret.append((bestu, bests))\n  \n  	return ret\n  \n  def getbestresults(scores, best, numsur):\n  	"""\n  		Figure out the maximum number of people that could have gotten\n  		a single score >= best.  Limited to choosing only numsur surprising\n  		triplets.\n  	"""\n  \n  	peeps = getmulticombos(scores)\n  \n  	count = 0\n  	surcount = 0\n  \n  	for p in peeps:\n  		if (bestresult(p[0]) >= best):\n  			count = count + 1\n  		elif ((bestresult(p[1]) >= best) and (surcount < numsur)):\n  			count = count + 1\n  			surcount = surcount + 1\n  \n  	return count\n  \n  def process(test):\n  	N = test['N']\n  	S = test['S']\n  	p = test['p']\n  	t = test['t']\n  \n  	return getbestresults(t, p, S)\n  \n  data = readfile("B-small-attempt0.in")\n  \n  for i in xrange(data['T']):\n  	test = data['tests'][i]\n  \n  	result = process(test)\n  \n  	print "Case #%d: %d" % (i+1, result)\n <CODESPLIT> 56
 \n  class Test(unittest.TestCase):\n  	def test_1(self):\n  		self.assertEqual(main(1, 4), 2)\n  	def test_2(self):\n  		self.assertEqual(main(10, 120), 0)\n  	def test_3(self):\n  		self.assertEqual(main(100, 100000000000000), 2)\n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def main(M, N):\n  	fns = 0\n  	num = M\n  	maior = math.sqrt(N)\n  	int_maior = 0\n  	\n  	if maior.is_integer():\n  		int_maior = int(maior) - 1\n  		if fair(N):\n  			if fair(int(maior)):\n  				fns += 1\n  	else:\n  		int_maior = int(maior)\n  		\n  	while int_maior >= 1:\n  		if fair(int_maior):\n  			quadrado = int_maior * int_maior\n  			if quadrado >= M:\n  				if fair(quadrado):\n  					fns += 1\n  		int_maior -= 1\n  	return fns\n  \n  def main2(M, N):\n  	fns = 0\n  	num = M\n  	while num <= N:\n  		result = raiz(num)\n  		if result:\n  			if fair(num):\n  			\n  				if fair(result):\n  					fns += 1\n  		num += 1\n  	return fns\n  	\n  def fair(num):\n  	return str(num) == str(num)[::-1]\n  	\n  def raiz(num):\n  	result = math.sqrt(num)\n  	if result.is_integer():\n  		return int(result)\n  	else:\n  		return False\n  	\n  if __name__ == '__main__':\n  	for i in xrange(tCase):	\n  		\n  		N,M = [int(x) for x in sys.stdin.readline().split(' ')]	\n  		print "Case #%d: %d" % (i + 1, main(N,M))\n <CODESPLIT> 57
 \n  tCase = int(sys.stdin.readline())\n  \n  def alien(frases,case):\n  	\n  	case = case.replace('(','[')\n  	case = case.replace(')',']')\n  	\n  	ER1 = re.compile(case, re.I)\n  	count = 0\n  	for frase in frases:\n  		if ER1.search(frase):\n  			count += 1\n  	return count\n  \n  \n  for i in xrange(tCase):	\n  	linha = sys.stdin.readline().split()\n  	P = int(linha[1])\n  	T = int(linha[2])\n  	list = []\n  	for j in range (3,len(linha)):\n  		list.append(int(linha[j]))\n  	list.sort(reverse=True)\n  	realT = T*3 - 2\n  	supT = realT - 2\n  	\n  	count = 0\n  	for item in list:\n  		if item >= realT:\n  			count += 1\n  		elif P > 0 and item >= supT and T >= 2:\n  			count += 1\n  			P -= 1\n  		elif P > 0 and item >= realT and T == 1:\n  			count += 1\n  			P -= 1\n  		elif T == 0:\n  			count += 1\n  		else:\n  			break\n  		\n  	print "Case #%d: %d" % (i+1, count)\n  	\n  	\n  \n <CODESPLIT> 57
def sqrt(x, ge):\n      if x == 1:\n          return 1\n      sx = x >> 1\n      step = sx >> 1\n  \n      while step:\n          if sx ** 2 >= x:\n              sx = sx - step\n          else:\n              sx = sx + step\n          step = step >> 1\n  \n      if ge:\n          while not sx ** 2 < x:\n              sx = sx - 1\n          while not sx ** 2 >= x:\n              sx = sx + 1\n      else:\n          while not sx ** 2 > x:\n              sx = sx + 1\n          while not sx ** 2 <= x:\n              sx = sx - 1\n  \n      return sx\n  \n  \n  def get_start_pali(a):\n      s = str(a)\n      ls = len(s)\n      if ls == 1:\n          return s, True\n      elif ls & 1:\n          return s[:ls >> 1 + 1], True\n      else:\n          return s[:ls >> 1], False\n  \n  \n  def get_next_pali(p, m):\n      if len(p) == p.count("9"):\n          if m:\n              return "1" + "0" * (len(p) - 1), False\n          else:\n              return "1" + "0" * len(p), True\n      else:\n          return str(int(p) + 1), m\n  \n  \n  def pali_to_num(p, m):\n      if m:\n          return int(p + p[-2::-1])\n      else:\n          return int(p + p[::-1])\n  \n  \n  def is_pali(a):\n      s = str(a)\n      hls = len(s) >> 1\n      return s[:hls] == s[:-hls - 1:-1]\n  \n  for i in range(int(input())):\n      a, b = tuple(map(int, input().split()))\n      sqa, sqb = sqrt(a, True), sqrt(b, False)\n  \n      p, m = get_start_pali(sqa)\n      while pali_to_num(p, m) < sqa:\n          p, m = get_next_pali(p, m)\n  \n      count = 0\n  \n      while True:\n          curr = pali_to_num(p, m)\n          if curr > sqb:\n              break\n          if is_pali(curr ** 2):\n              count = count + 1\n          p, m = get_next_pali(p, m)\n  \n      print("Case #{}: {}".format(i + 1, count))\n <CODESPLIT> 58
def passes(p, t): #normal, surprising\n      q, r = divmod(t, 3)\n      if r == 0:\n          return q >= p, q + 1 >= p and q\n      elif r == 1:\n          return q + 1 >= p, q + 1 >= p and q\n      elif r == 2:\n          return q + 1 >= p, q + 2 >= p\n  \n  for case in range(int(input())):\n      st = input().strip().split()\n      n, s, p, t = int(st[0]), int(st[1]), int(st[2]), list(map(int, st[3:]))\n      result = 0\n      for i in t:\n          normal, surprising = passes(p, i)\n          if normal:\n              result += 1\n          elif surprising and s != 0:\n              result += 1\n              s -= 1\n      print("Case #{}: {}".format(case + 1, result))\n <CODESPLIT> 58
lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,\n      100020001,102030201,104060401,121242121,123454321,125686521,400080004,\n      404090404,10000200001,10221412201,12102420121,12345654321,40000800004,\n      1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,\n      1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,\n      1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,\n      102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,\n      123456787654321,400000080000004]\n  \n  \n  def solve(lo,hi):\n      global lst\n      count = 0\n      for i in range(len(lst)):\n          if (lst[i] >= lo and lst[i] <= hi ):\n              count += 1\n      return count\n  \n  fname = raw_input("name of file: ")\n  oname = raw_input("output file name:")\n  f = open(fname,"r")\n  out = open(oname,"w")\n  n = int(f.readline()[:-1])\n  case_num = 1\n  for line in f:\n      args = line[:-1].split()\n      lo = int(args[0])\n      hi = int(args[1])\n      out.write("Case #%d: %d\n" %(case_num,solve(lo,hi)))\n      case_num += 1\n      \n  out.close()\n  f.close()\n      \n <CODESPLIT> 59
fileName = raw_input("File name: ")\n  \n  f = open(fileName,"r")\n  \n  t = int(f.readline()[:-1])\n  \n  tests = []\n  \n  for i in range (t):\n      tests += [f.readline()[:-1]]\n  \n  f.close()\n  \n  \n  def compute(raw):\n      dataN = [] # keeps the max mark for not surprising\n      dataS = [] # keeps the max marks for surprisings\n      \n      items = raw.split() \n      \n      for i in range (int(items[0])):\n          ti = int(items[3+i])\n          if ti < 1:\n              dataS += [0]\n              dataN += [0]\n          elif ti > 28:\n              dataS += [10]\n              dataN += [10]\n          else:\n              dataN += [int((ti+2)/3)] # put the values for all participants\n              dataS += [int((ti+4)/3)]\n          \n          \n  \n      \n      p = int(items[2])\n      s = int(items[1])\n      \n      n_vals = dataN\n      n_vals.sort()\n      \n  \n      i=0\n      minimum = 0 # how many numbers greater than p are there in "not surprising"\n      if n_vals[0] < p:\n          while n_vals[-1-i] >= p:\n              minimum += 1\n              i += 1\n      else:\n          minimum = len(n_vals)\n          \n  \n      s_vals = dataS\n      s_vals.sort()\n      i=0\n      maximum = 0 # how many numbers greater than p are there in "surprising"\n      if s_vals[0] < p:\n          while s_vals[-1-i] >= p:\n              maximum += 1\n              i += 1\n      else:\n          maximum = len(n_vals)\n      \n      return min(maximum, minimum+s) \n      \n  \n  for i in range (t):\n      print "Case #%d: %d" %(i+1,compute(tests[i]))\n  \n  \n      \n <CODESPLIT> 59
 \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(reader(f, *args, **kwargs))\n      return res\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      return read_ints(f)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%d'%res)\n      f.write('\n')\n  \n  \n  def aux(A, B, x, s):\n      res = 0\n      n = int(''.join(x[::-1]+x))\n      nn = n*n\n      if nn > B:\n          return res\n      if nn >= A:\n          res += 1\n      for c in [0, 1, 2]:\n          if s + c*c < 10:\n              n = int(''.join(x[::-1]+[str(c)]+x))\n              nn = n*n\n              if nn >= A and nn <= B:\n                  res += 1\n          if s + 2*c*c < 10:\n              res += aux(A, B, [str(c)]+x, s + 2*c*c)\n      return res\n  \n  def solve_small(case):\n      [A, B] = case\n      res = 0\n      for n in [1, 4, 9]:\n          if n >= A and n <= B:\n              res += 1\n      for c in [1, 2]:\n          res += aux(A, B, [str(c)], 2*c*c)\n      return res\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n <CODESPLIT> 60
 \n  __file__ = sys.argv[0]\n  __path__ = os.path.dirname(__file__)\n  __prob__ = os.path.basename(__path__)\n  \n  def pout(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n  \n  def perr(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n  \n  def argmin(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best > y:\n              best = y\n              res = x\n      return res\n  \n  def argmax(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best < y:\n              best = y\n              res = x\n      return res\n  \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_word_arr(f, R):\n      res = []\n      for i in range(R):\n          res.append(read_word(f))\n      return res\n  \n  def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(read_ints(f, *args, **kwargs))\n      return numpy.array(res, dtype)\n  \n  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n      global ERR_FILE\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      err_fn = fn + '.err'\n      if start_case == 0:\n          append = True\n          if os.path.exists(out_fn):\n              with open(out_fn, 'r') as f:\n                  for l in f:\n                      if l[:6] == 'Case #':\n                          start_case = int(l[6:l.index(':')])+1\n      else:\n          append = False\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'a' if append else 'w') as fo:\n              with open(err_fn, 'w') as ERR_FILE:\n                  T = read_int(fi)\n                  for i in range(T):\n                      case = read_case(fi)\n                      if i+1 < start_case:\n                          continue\n                      print('Case #%d of %d'%(i+1, T))\n                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                      perr('case')\n                      res = solver(case)\n                      perr('res')\n                      write_case(fo, i, res)\n                      fo.flush()\n                      if end_case is not None and i+1 == end_case:\n                          break\n  \n  def test(start_case=1, end_case=None):\n      fn = os.path.join(__path__, 'test')\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small2(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case, fn + '2.out')\n  \n  def large(start_case=0, end_case=None):\n      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case)\n  \n  \n  def read_case(f):\n      Z = read_ints(f)\n      (N, S, p) = Z[:3]\n      t = Z[3:]\n      return (N, S, p, t)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%(i+1))\n      f.write('%s'%res)\n      f.write('\n')\n  \n  FAIL = 'NO SOLUTION'\n  \n  def solve_small(case):\n      (N, S, p, t) = case\n      res = 0\n      for i in range(N):\n          if p >= 2:\n              if t[i] >= 3*p-2:\n                  res += 1\n              elif S > 0 and t[i] >= 3*p-4:\n                  res += 1\n                  S -= 1\n          elif p == 1:\n              if t[i] >= 3*p-2:\n                  res += 1\n          elif p == 0:\n              res += 1\n      return res\n  \n  solve_large = solve_small\n  \n  pout = perr\n <CODESPLIT> 60
def esPal(x):\n  	return str(x) == str(x)[::-1]\n  \n  t = int(raw_input())\n  \n  for case in range(t):\n  	line = raw_input().split(' ')\n  	a = int(line[0])\n  	b = int(line[1])\n  \n  	i = int(a**.5)\n  	if i*i != a:\n  		i += 1\n  	max = int(b**.5)\n  	cantidad = 0\n  	while i <= max:\n  		if esPal(i) and esPal(i*i):\n  			cantidad += 1\n  		i += 1\n  \n  	print 'Case #'+str(case+1)+':', cantidad\n <CODESPLIT> 61
t = int(raw_input())\n  \n  max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]\n  \n  for i in range(t):\n  	line = raw_input().split(' ')\n  	n = int(line[0])\n  	s = int(line[1])\n  	p = int(line[2])\n  \n  	total = 0\n  \n  	for j in range(3, len(line)):\n  		t = int(line[j])\n  		if t == 0:\n  			if p == 0:\n  				total += 1\n  		elif t%3 == 0:\n  			if t/3 >= p:\n  				total +=1\n  			elif t/3 + 1 >= p and s>0:\n  				total +=1\n  				s -=1\n  		elif t%3 == 1:\n  			if (t+2)/3 >= p:\n  				total +=1\n  		else:\n  			if (t+1)/3 >= p:\n  				total +=1\n  			elif (t+1)/3 + 1 >= p and s>0:\n  				total +=1\n  				s -=1\n  \n  \n  \n  	print 'Case #'+str(i+1)+':', total\n  \n  \n <CODESPLIT> 61
 \n  def is_palindrome(n):\n      s = str(n)\n      return s == s[::-1] \n  \n  palindromes = [[], [1,2,3,4,5,6,7,8,9], [11,22,33,44,55,66,77,88,99]]\n  all_palindromes = palindromes[1] + palindromes[2]\n  limit = [100]\n  \n  palindromic_squares = []\n  psqtop = 0\n  psqix = 0\n  \n  stdin = sys.stdin\n  for c in xrange(int(stdin.readline())):\n      a,b = map(int, stdin.readline().split())\n  \n      while psqtop < b:\n          while psqix >= len(all_palindromes):\n              ps = []\n              pp = 10 ** (len(palindromes)-1) + 1\n              for i in range(1,10):\n                  for p in palindromes[-2]:\n                      ps.append(i * pp + 10 * p) \n              palindromes.append(ps)\n              all_palindromes.extend(ps)\n  \n          sq = all_palindromes[psqix] * all_palindromes[psqix]\n          if is_palindrome(sq):\n              palindromic_squares.append(sq)\n          psqix  += 1\n          psqtop = sq\n  \n      aix = bisect.bisect_left(palindromic_squares, a)\n      bix = bisect.bisect_right(palindromic_squares, b)\n  \n      print "Case #%i: %i" % (c+1, bix-aix) \n <CODESPLIT> 62
 \n  T = int(stdin.readline())\n  for i in xrange(1,T+1):\n  	ns = map(int, stdin.readline().split())\n  	N,S,p = ns[0:3]\n  	\n  	h = 0\n  	z = 0\n  \n  	for n in ns[3:]:\n  		if n <= 1:\n  			if n >= p: h += 1	\n  		elif (n+2) // 3 >= p:\n  			h += 1\n  		elif (n+4) // 3 >= p:\n  			z += 1\n  \n  	print "Case #%d: %d" % (i, h + min(S,z))\n  \n  \n <CODESPLIT> 62
 \n  N = 10**4\n  \n  def isp(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  fs = []\n  for i in range(N):\n      s = str(i)\n      n1 = int(s + s[::-1])**2\n      n2 = int(s[:-1] + s[::-1])**2\n  \n      if isp(n1):\n          fs.append(n1)\n      if isp(n2):\n          fs.append(n2)\n  \n  fs.sort()\n  \n  print(fs, file=sys.stderr)\n  \n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      board = []\n      A, B = map(int, fin.readline().split())\n  \n      i = bisect.bisect_left(fs, A)\n      j = bisect.bisect_right(fs, B)\n  \n      print("Case #%d: %s" % (case, j-i))\n  \n  \n <CODESPLIT> 63
 fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      numbers = map(int, fin.readline().split())\n      N, S, p = numbers[:3]\n      T = numbers[3:]\n      normal_limit = p + 2*max(0, (p-1))\n      surpising_limit = p + 2*max(0, (p-2))\n  \n      normal_count = 0\n      surprising_count = 0\n  \n      for t in T:\n          if t >= normal_limit:\n              normal_count += 1\n          elif t >= surpising_limit:\n              surprising_count += 1\n  \n      result = normal_count + min(surprising_count, S)\n  \n      print "Case #%d: %s" % (case, result)\n  \n <CODESPLIT> 63
 \n  def read_ints():\n      return map(int, stdin.readline().rstrip().split(' '))\n  \n  def is_palin(n):\n      s = str(n)\n      return s == s[::-1]\n      \n  def find(n, fas):\n      for i in xrange(len(fas)):\n          if fas[i] >= n:\n              return i\n      return len(fas)\n      \n  def gen_fas(max):\n      fas = []\n      fasappend = fas.append\n      square, base, d = 1, 1, 3\n      while square < max:\n          if is_palin(square) and is_palin(base):\n              fasappend(square)\n          square += d\n          d += 2\n          base += 1\n      return fas\n      \n  def main():\n      MAX = 1000\n      fas = gen_fas(MAX)\n      \n      T = int(stdin.readline())\n      for Ti in xrange(T):\n          A, B = read_ints()\n          answer = find(B + 1, fas) - find(A, fas)\n          print 'Case #{}: {}'.format(Ti + 1, answer)\n          \n  main()\n <CODESPLIT> 64
 \n  def program():\n  	T = int(stdin.readline())\n  	for Ti in xrange(T):\n  		numbers = a = map(int, stdin.readline().rstrip().split(' '))\n  		N, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]\n  		\n  		m = 0\n  		curr_S = S\n  		for i in xrange(N):\n  			t = totals[i]\n  			\n  			if t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):\n  				m += 1\n  			elif curr_S > 0 and t > 0:\n  				if (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):\n  					m += 1\n  					curr_S -= 1\n  		\n  		print 'Case #%d: %d' % (Ti + 1, m)	\n  	\n  if __name__ == '__main__':\n  	program()\n <CODESPLIT> 64
 \n  def get_number_of_test_case():\n      return int(raw_input().strip())\n  \n  def solve_case(t):\n      A, B = [int(x) for x in raw_input().strip().split()]\n  \n      print 'Case #%d: %d' % (t, get_number_of_palindrome(B) - get_number_of_palindrome(A - 1),)\n  \n  def get_number_of_palindrome(n):\n      ret = 0\n  \n      nt = int(math.floor(math.sqrt(n)))\n      total_column = int(math.ceil(math.ceil(math.log10(nt + 1)) / 2.0))\n      upper_limit = 10 ** total_column\n  \n      counter = 0\n      while counter < upper_limit:\n          c_str = [c for c in str(counter)]\n          c_str.reverse()\n  \n          number = str(counter)\n          for c in c_str:\n              number += c\n          number = int(number)\n          number = number ** 2\n          if number <= n and is_palindrome(number):\n              ret += 1\n  \n          number = str(counter)\n          for c in c_str[1:]:\n              number += c\n          number = int(number)\n          number = number ** 2\n          if number <= n and is_palindrome(number):\n              ret += 1\n          \n          counter += 1\n  \n      return ret\n  \n  def is_palindrome(n):\n      if n == 0:\n          return False\n      num = str(n)\n      check_len = len(num) / 2\n      ret = True\n      for i in range(check_len):\n          ret &= num[i] == num[-i - 1]\n      return ret\n  \n  T = get_number_of_test_case()\n  t = 1\n  while t <= T:\n      solve_case(t)\n      t += 1\n  \n <CODESPLIT> 65
t = int(raw_input().strip())\n  t_count = 1\n  while t_count <= t:\n  	line = raw_input().strip().split()\n  	n = int(line[0])\n  	s = int(line[1])\n  	p = int(line[2])\n  	ti_list = line[3:]\n  	p_min = max(p * 3 - 2, p)\n  	p_min_surprise = max(p * 3 - 4, p)\n  	result = 0\n  	for ti in ti_list:\n  		ti = int(ti)\n  		if ti >= p_min:\n  			result += 1\n  		elif p_min > p_min_surprise and ti >= p_min_surprise and s > 0:\n  			result += 1\n  			s -= 1\n  	print 'Case #%d: %d' % (t_count, result,)\n  	t_count += 1\n <CODESPLIT> 65
