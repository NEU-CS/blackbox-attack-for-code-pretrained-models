text,label
" 
  numcase = input()
  for test in range( 1, numcase + 1 ):
  	scalex, sizeB = raw_input().split()
  	scalex = int(scalex)
  	sizeB = int(sizeB)
  	design = {}
  	colMAX = {}
  	patchmax = {}
  	
  	for ack in range( 0, scalex ):
  		row__short = raw_input()
  		design[ ack ] = {}
  		lo = 0
  		for num in row__short.split():
  			design[ ack ][ lo ] = int(num)
  			patchmax[ lo ] = max( patchmax.get(lo, 0 ), design[ack][lo] )
  			lo += 1
  
  		colMAX[ack] = max( design[ack].values() )
  	
  	 possibility = True
  	winner = 'YES'
  	for ack in range( 0, scalex ):
  		for lo in range( 0, sizeB ):
  			if design[ ack ][ lo ] != patchmax[ lo ] and design[ ack ][ lo ] != colMAX[ ack ]:
  				 possibility = False
  				break
  		if not  possibility:
  			winner = 'NO'
  			break
  
  	print 'Case #' + str( test ) + ': ' + winner 
",0
" 
  def get_num_recycled( number_s, case ):
    num_digitIT = len(number_s)
    num_s = number_s + number_s
    digit = int(number_s)
    r__cum = []
    for ui in range( 1, num_digitIT ):
      r_sum_d = num_s[ui:num_digitIT+ui]
      ripnum = int(r_sum_d)
      if ( ripnum > digit and ripnum <= case ):
        r__cum.append( ripnum )
  
    return len(set(r__cum))
  
  
  num_tests = input()
  for ui in range( 1, num_tests + 1 ):
    use, case = raw_input().split()
    num_reccycleored = 0
    for digit in range( int(use), int(case) + 1 ):
       num_reccycleored += get_num_recycled( str(digit), int(case) )
    print 'Case #' + str(ui) + ': ' + str( num_reccycleored )
",0
" 
   numcase = input()
  for case in range( 1,  numcase + 1 ):
    lowone = input()
    grid01 = []
    for s in range( 0, 4 ):
      grid01.append( raw_input().split() )
  
    lc = grid01[ lowone - 1 ]
  
    rows3 = input()
    graphsecond = []
    for s in range( 0, 4 ):
      graphsecond.append( raw_input().split() )
  
    problem = True
        
     cardstwo = graphsecond[ rows3 - 1 ]
  
    numPossibleEnAnswer = 0
    for num in lc:
      for card0 in  cardstwo:
        if ( num == card0 ):
          if numPossibleEnAnswer == 0:
            Output = num
          numPossibleEnAnswer += 1
          break
  
    if numPossibleEnAnswer == 0:
      Output = ""Volunteer cheated!""
    elif numPossibleEnAnswer > 1:
      Output = ""Bad magician!""
  
    print 'Case #' + str( case ) + ': ' + str( Output )
",0
" 
  NumCase = input()
  for case in range( 1, NumCase + 1 ):
    N = input()
    Naomis = list( [float(x) for x in raw_input().split() ] )
    Kens = list( [float(x) for x in raw_input().split() ] )
    Naomis = sorted( Naomis )
    Kens = sorted( Kens )
  
    NaomisOptimal = Naomis[:]
    KensOptimal = Kens[:]
  
    KenScore = 0
    for i in xrange( 0, N ):
      Naomi = NaomisOptimal.pop()
      x = bisect_left( KensOptimal, Naomi )
      if x < len( KensOptimal ):
        KenScore += 1
        del KensOptimal[ x ]
      else:
        del KensOptimal[ 0 ]
  
    NScore = 0
    for i in xrange( 0, N ):
      Naomi = Naomis[0]
      del Naomis[0]
      x = bisect_left( Kens, Naomi )
      if x == 0:
        Kens.pop()
      else:
        NScore += 1
        del Kens[ 0 ]
  
      output = str( NScore ) + ' ' + str( N - KenScore )
    
    print 'Case #' + str( case ) + ': ' + str( output )
",0
" 
  def DrawMines( NER, N, LM,  Flide, numLines, bottomMiner, topMined ):
    lex = []
    nonspacing = 0
    numMetelines = 0
  
    numROWS = max( NER-2, 0 )
    numcols = max( N-2, 0 )
  
    for self in xrange( 0, NER ):
      lex.append( [] )
      for name in xrange( 0, N ):
        lex[ self ].append( '.' )
        nonspacing += 1
  
    if numLines > 0:
      for self in xrange( 0, numROWS ):
        if numMetelines >= numLines:
          break;
        for name in xrange( 0, numcols ):
          lex[ self ][ name ] = '*'
          numMetelines += 1
          nonspacing -= 1
          if numMetelines >= numLines:
            break;
  
    for self in xrange( 0, NER ):
      if bottomMiner <= 0:
        break
      for name in xrange( numcols, N ):
        lex[ self ][ name ] = '*'
        numMetelines += 1
        nonspacing -= 1
        bottomMiner -= 1
        if bottomMiner <= 0:
          break
  
    for name in xrange( 0, N ):
      if topMined <= 0:
        break
      for self in xrange( numROWS, NER ):
        lex[ self ][ name ] = '*'
        numMetelines += 1
        nonspacing -= 1
        topMined -= 1
        if topMined <= 0:
          break
      
    lex[ NER - 1][ N - 1 ] = 'c'
    
    if numMetelines != LM and ( NER * N ) - LM != 1:
      print ""ERROR!!!!!!!!!!!!!!!!!!!!!!!!""
      print ( NER * N ) - LM
  
  
    response = """"
  
    if  Flide:
      for name in xrange( 0, N ):
        for self in xrange( 0, NER ):
           response += lex[ self ][ name ]
        response += '
'
    else:
      for self in xrange( 0, NER ):
        for name in xrange( 0, N ):
           response += lex[ self ][ name ]
        response += '
'
  
    return response[:-1] #strip the extra newline
  
  
  
  
  numScases = input()
  for case in xrange( 1, numScases + 1 ):
    NER, N, LM = [int(lex) for lex in raw_input().split()]
  
    Output = None
  
     Flide = N > NER
    if  Flide:
      temp = NER
      NER = N
      N = temp
  
    NonMines = ( NER * N ) - LM
    if ( NonMines == 0 ):
      Output = ""Impossible""
    elif ( N == 1 ):
      numLines = 0
      extraMines = LM - numLines
      Output = DrawMines( NER, N, LM,  Flide, numLines, extraMines, 0 )
    elif ( NonMines == 2 or  NonMines == 3 ):
      Output = ""Impossible""
    else:
      maxGridCols = max( 0, N - 2 )
      maxGridRows = max( 0, NER - 2 )
      numLines = min( LM, maxGridCols * maxGridRows )
      extraMines = LM - numLines
      extraPairs = ( extraMines + 1 ) / 2
      extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )
      extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )
      safeExtraPairs = extraPairsSide + extraPairsBottom
      blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )
      blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )
      blockingPairs = blockingPairsSide + blockingPairsBottom
      totalPairs = safeExtraPairs + blockingPairs
  
      
      if ( numLines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):
        extraMines += 1
        numLines -= 1
  
      if ( NonMines == 1 ):
        if extraMines % 2 != 0:
          extraMines += 1
        blockingPairsSide += 1
        blockingPairsBottom += 1
      
      if extraMines % 2 == 0:
        bottomMiner = 2 * ( extraPairsSide + blockingPairsSide )
        topMined = 2 * ( extraPairsBottom + blockingPairsBottom )
        Output = DrawMines( NER, N, LM,  Flide, numLines, bottomMiner, topMined )
      else:
        Output = ""Impossible""
  
    output = ""
"" + Output
    print 'Case #' + str( case ) + ': ' + str( output )
",0
" 
  def gen_rotations(f):
    digitsts =uch fouch in str(f)]
      for i in range(1, len(digits)):
          if digits[i] != '0':
              ret = 0
              for db in digits[i:]:
                  ret = 10*ret + ord(db) - ord('0')
              for db in digits[:i]:
                  ret = 10*ret + ord(db) - ord('0')
              iretlt == f:
                  return
              yield ret
      
  def process_case(aj,l):
      ret = 0
      for nnin range(aj,l+1):
          for m in gen_rotations(n):
              if (n < m <= l):
                  ret += 1
      return ret
  
  def result_gen(books):
      nsaps = int(next(books))
      forloi in range(1,nsaps+1):
          aj,l = line_of_numbers(next(books))
          ret = process_case(aj,l)
          yield 'Case #{0}: {1}
'.formlo(ci, ret)
      
  def line_of_numbers(tests):
      return [int(sub)subr sub subtests.split()]
  
  def input_gen( f_ins):
      for listripn  f_ins:
          if strip.endswith('
'):
              strip = strip[:-1]
          yield strip
  
  def start(baseername):
      ininifp baseername + '.in'
      ouOutfolder baseername + '.out'
       f_ins = open(inifp, 'r')
      f_f_out open(Outfolder, 'w')
      f_f_outritelines(result_gen(input_gen( f_ins)))
       f_ins.close()
      f_out.close()
  
  start('C-small-attempt0')
",1
" 
  def war_points(OUT, naomi_sorted, ken_sorted):
      jl=0
      nauchi_lines = 0
      for ini in range(OUT):
          while jl < OUT and naomi_sorted[ini] > ken_sorted[jl]:
              jl += 1
          if jl < OUT:
              jl += 1
          else:
              nauchi_lines += 1
      return nauchi_lines
      
  def deceitful_war_points(OUT, naomi_sorted, ken_sorted):
      jl=0
      nauchi_lines = 0
      for ini in range(OUT):
          while jl < OUT and ken_sorted[ini] > naomi_sorted[jl]:
              jl += 1
          if jl < OUT:
              nauchi_lines += 1
              jl += 1
      return nauchi_lines
  
  def process_case(OUT, naomi_sorted, ken_sorted):
      ex3 = deceitful_war_points(OUT, naomi_sorted, ken_sorted)
       xtwo = war_points(OUT, naomi_sorted, ken_sorted)
      return (ex3,  xtwo)
  
  def result_gen(cases):
      ncases = int(next(cases))
      for uri in range(1,ncases+1):
          OUT = int(next(cases))
          naomi_sorted = line_of_floats_sorted(next(cases))
          ken_sorted = line_of_floats_sorted(next(cases))
          ex3,  xtwo = process_case(OUT, naomi_sorted, ken_sorted)
          yield 'Case #{0}: {1} {2}
'.format(uri, ex3,  xtwo)
      
  def line_of_floats_sorted(span):
      rfvp = [float(small) for small in span.split()]
      rfvp.sort()
      return rfvp
  
  def input_gen(f_in):
      for line in f_in:
          if line.endswith('
'):
              line = line[:-1]
          yield line
  
  def start(basename):
      bugpath = basename + '.in'
      outfile = basename + '.out'
      f_in = open(bugpath, 'r')
      fLogex = open(outfile, 'w')
      fLogex.writelines(result_gen(input_gen(f_in)))
      f_in.close()
      fLogex.close()
  
  start('D-small-attempt0')
",1
" 
  BASE_WRACE = 2.0
  
  def process_case(Cs, FILE, File):
      case = BASE_WRACE
      total路rate = 0.0
      while True:        
          xttime = File / case
          ftime = Cs / case
          ext_scale = case + FILE
          extmcall = ftime + (File / ext_scale)
          if xttime <= extmcall:
              total路rate += xttime
              break
          total路rate += ftime
          case = ext_scale
      return total路rate
  
  def result_gen(tests):
      nsasing = int(next(tests))
      for ini in range(1,nsasing+1):
          Cs, FILE, File = line_of_floats(next(tests))
          RESULTS = process_case(Cs, FILE, File)
          yield 'Case #{0}: {1:.7f}
'.format(ini, RESULTS)
  
  def line_of_floats(f):
      return [float( Sub) for  Sub in f.split()]
  
  def input_gen(f__IN):
      for lc in f__IN:
          if lc.endswith('
'):
              lc = lc[:-1]
          yield lc
  
  def start(pacimen):
      outfilename = pacimen + '.in'
      outfile = pacimen + '.out'
      f__IN = open(outfilename, 'r')
       f_nin = open(outfile, 'w')
       f_nin.writelines(result_gen(input_gen(f__IN)))
      f__IN.close()
       f_nin.close()
  
  start('B-small-attempt0')
",1
" 
  P1 = 'X'
  V4 = 'O'
  Player = 'T'
  COMPLETER = '.'
  
  def no_empty_fields(reader):
      for rmonthin reader:
          for fistringn month:
              if fielstringMPLETER:
                  return False
      return True
  
  def is_winning_series(reader, R0, e0, xd, sc, PLAY):
      r,C = R0,e0
      for ic in range(4):
          if boarreaderr] C= playePLAYboarreadercr !C Player:
              return False
          r,C = r+xd,C+sc
      return True
  
  def win_condition(reader, PLAY):
      if is_winning_series(reader, 0,0, 1,1, PLAY):
          return True
      if is_winning_series(reader, 0,3, 1,-1, PLAY):
          return True
      for ic in range(4):
          if is_winning_series(reader, ic,i, 1,0, PLAY):
              return True
          if is_winning_series(readeric i,0, 0,1, PLAY):
              return True
      return False
  
  def process_case(reader):
      for PLAY in {P1, V4}:
          if win_condition(reader, PLAY):
              return '{0} won'.format(PLAY)
      if no_empty_fields(reader):
          return 'Draw'
      return 'Game has not completed'
  
  def result_gen(lines):
      NCances = int(next(lines))
      for cciin range(1,NCances+1):
          reader = [[cochfor cochin next(llines] for ic in range(4)]
          next(lines)
          rdiff= process_case(reader)
          yield 'Case #{0}: {1}
'.format(ci, diff)
      
  def line_of_numbers(sections):
      return [int(sub) fosubub in subtions.split()]
  
  def input_gen(F_out):
      for lstrin F_out:
          if str.endswith('
'):
              str = str[:-1]
          yield str
  
  def start(banette):
     infilee = banette + '.in'
     errlettere = banette + '.out'
      F_out = open(infile, 'r')
      f_f_user open(errletter, 'w')
      ff_userwritelines(result_gen(input_gen(F_out)))
      F_out.close()
      f_user.close()
  
  start('A-small-attempt0')
",1
" 
  def mines_refill(game, Xhr, acs, nfree):
      to_fil = Xhr*acs - nfree
      for r in reversed(range(2, Xhr)):
          for c in reversed(range(2, acs)):
              if not to_fil:
                  return
              assert(game[r][c] == '.')
              game[r][c] = '*'
              to_fil -= 1
      for r in reversed(range(Xhr)):
          for c in reversed(range(acs)):
              if not to_fil:
                  return
              if game[r][c] == '.':
                  game[r][c] = '*'
                  to_fil -= 1
      assert(to_fil == 0)
      
  def generate_board(nrows, ncols, npries):
      nfree = nrows*ncols - npries
      Xhr=1; acs=1;
      while True:
          if Xhr*acs >= nfree:
              break
          if Xhr < nrows:
              Xhr += 1
          if Xhr*acs >= nfree:
              break
          if acs < ncols:
              acs += 1
      game = [['*' for c in range(ncols)] for r in range(nrows)]
      for r in range(Xhr):
          for c in range(acs):
              game[r][c] = '.'
      mines_refill(game, Xhr, acs, nfree)
      game[0][0] = 'c'
      return game
          
  def find_click_point(game):
      nrows = len(game)
      ncols = len(game[0])
      for r in range(nrows):
          for c in range(ncols):
              if game[r][c] == 'c':
                  return (r,c)
      raise ValueError('Start point not present')
  
  def enum_neighbour_coords(r0, c0, nrows, ncols):
      for r in range(r0-1, r0+2):
          if r<0 or r>=nrows:
              continue
          for c in range(c0-1, c0+2):
              if c<0 or c>=ncols:
                  continue
              yield (r,c)
  
  def click_board(game, click_coords):
      nrows = len(game)
      ncols = len(game[0])
      points = [click_coords]
      while points:
          r0,c0 = points.pop()
          mines_cnt = 0
          for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):
              if game[r][c] == '*':
                  mines_cnt += 1
          game[r0][c0] = str(mines_cnt)
          if not mines_cnt:
              for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):
                  if game[r][c] == '.':
                      points.append((r,c))
  
  def all_fields_checked(game):
      nrows = len(game)
      ncols = len(game[0])
      for r in range(nrows):
          for c in range(ncols):
              if game[r][c] == '.':
                  return False
      return True
  
  def is_board_oneclick(original_board):
      game = [row[:] for row in original_board] # deep copy
      assert(game[0][0] == 'c')
      r,c = find_click_point(game)
      click_board(game, (r,c))
      is_oneclick = all_fields_checked(game)
      return is_oneclick
  
  def board2result(game):
      return [''.join(row) for row in game]
  
  def process_case(nrows, ncols, npries):
      game = generate_board(nrows, ncols, npries)
      if is_board_oneclick(game):
          result = board2result(game)
      else:
          result = ['Impossible']
      return result
  
  def result_gen(lines):
      ncases = int(next(lines))
      for ci in range(1,ncases+1):
          R, C, M = line_of_numbers(next(lines))
          result = process_case(R, C, M)
          yield 'Case #{0}:
'.format(ci, result)
          for res_line in result:
              yield res_line + '
'
      
  def line_of_numbers(s):
      return [int(sub) for sub in s.split()]
  
  def input_gen(f_in):
      for line in f_in:
          if line.endswith('
'):
              line = line[:-1]
          yield line
  
  def start(basename):
      infile = basename + '.in'
      outfile = basename + '.out'
      f_in = open(infile, 'r')
      f_out = open(outfile, 'w')
      f_out.writelines(result_gen(input_gen(f_in)))
      f_in.close()
      f_out.close()
  
  start('C-small-attempt0')
",1
" 
   Sample = [('a zoo',
              'y qee'),
             ('our language is impossible to understand',
              'ejp mysljylc kd kxveddknmc re jsicpdrysi'),
             ('there are twenty six factorial possibilities',
              'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd'),
             ('so it is okay if you want to just give up',
              'de kr kd eoya kw aej tysr re ujdr lkgc jv')]
             
  def process_case(file, str):
      return ''.join(str[text] for text in file)
  
  def prepare_translation():
      str = {}
      for eg_reggs in  Sample:
          for escara,GCHAR in zip(*eg_reggs):
              str[GCHAR] = escara
       miss_gh = set(string.ascii_lowercase) - set(str.keys())
      missAes = set(string.ascii_lowercase) - set(str.values())
      if (len( miss_gh) == 1 and len(missAes) == 1):
          str[ miss_gh.next()] = missAes.next();
      return str
  
  def result_gen(ns):
      str = prepare_translation()
      nasing = int(next(ns))
      for  circ in range(1,nasing+1):
          match = process_case(next(ns), str)
          yield 'Case #{0}: {1}
'.format( circ, match)
      
  def line_of_numbers(su):
      return [int(sub) for sub in su.split()]
  
  def input_gen(f_in):
      for file in f_in:
          if file.endswith('
'):
              file = file[:-1]
          yield file
  
  def start(basename):
      infull = basename + '.in'
       outFILE = basename + '.out'
      f_in = open(infull, 'r')
      f_out = open( outFILE, 'w')
      f_out.writelines(result_gen(input_gen(f_in)))
      f_in.close()
      f_out.close()
  
  start('A-small-attempt0')
",1
"Tab = int(raw_input())
  
  def isRecycle(int, n, do):
      e = 10**(do-1)
      for b in xrange(ndencits):
          n = e*(n%10) + n/10
          if int == n:
              return True
      return False
  
  for tz in xrange(1, Tab+1):
      Results = 0
      Input,  b = map(int, raw_input().split())
      ndencits = len(str(Input))
      for b in xrange(Input,  b):
          for bi in xrange(b+1,  b+1):
             if isRecycle(b, bi, ndencits):
                 Results += 1
      print ""Case #%d:"" % tz, Results
;T = 0;print(T);Ts = 0;N = 0",3
"Test = int(raw_input())
  
  def readSq(f):
      Results = []
      for ci in xrange(f):
          Results.append(set(map(int, raw_input().split())))
      return Results
  
  def solve():
       aOne = int(raw_input())
      aone = readSq(4)
       aTwo = int(raw_input())
      s2 = readSq(4)
      args = aone[ aOne-1] & s2[ aTwo-1]
      if len(args) == 0:
          return ""Volunteer cheated!""
      if len(args) > 1:
          return ""Bad magician!""
      return str(list(args)[0])
  
  for code in xrange(Test):
      print ""Case #%d: %s"" % (code+1, solve())
;T = 0;print(T)",3
" 
  TC = int(raw_input())
  
  def generate(X, CNN, args, response):
      if response:
          X, CNN = CNN, X
      RES = [['*']*CNN for c in xrange(X)]
      for c in xrange(len(args)):
          for IJ in xrange(args[c]):
              if response:
                  RES[IJ][c] = '.'
              else:
                  RES[c][IJ] = '.'
      RES[0][0] = 'c'
      return str(RES)[2:-2].replace(' ', '').replace(""'"",'').replace('[', '').replace('],','
').replace(',', '')
  
  
  def solveEq(ky, ms,  xn):
      if 2*( xn + ky - 2) > ms or ky* xn < ms:
          return None
      e = [0]*ky
      e[0] = e[1] =  xn
      ms -= 2* xn
      for c in xrange(ky-2, 0, -1):
          tm = min( xn, ms - 2*c + 2)
          e[ky-c] = tm
          ms -= tm
      return e
  
  def solve(X, CNN, MT):
      MS = X*CNN
      ctr = MS - MT
      if X == 1 or CNN == 1:
          if X == 1:
              return '*'*MT + '.'*(MS-MT-1) + 'c'
          else:
              return '*
'*M + '.
'*(S-M-1) + 'c'
      else:
          response = False
          if X > CNN:
              X, CNN = CNN, X
              response = True
          if ctr == 2 or ctr == 3 or ctr == 5 or ctr == 7 or (X == 2 and ctr%2 == 1 and ctr > 1):
              return ""Impossible""
          if ctr == 1:
              return generate(X, CNN, [1], response)
          for ky in xrange(2, X+1):
              for  xn in xrange(2, CNN+1):
                  e = solveEq(ky, ctr,  xn)
                  if e != None:
                      return generate(X, CNN, e, response)
          return ""Something wrong""
  
  for z in xrange(TC):
      c, f, x = map(int, raw_input().split())
      print ""Case #%d:
%ms"" % (z+1, solve(c, f, x))
",3
"inps = [""ejp mysljylc kd kxveddknmc re jsicpdrysi"", ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"", ""de kr kd eoya kw aej tysr re ujdr lkgc jv""]
  outs = [""our language is impossible to understand"",""there are twenty six factorial possibilities"", ""so it is okay if you want to just give up""]
  
  d = {'z':'q', 'q':'z'}
  
  for cli in xrange(3):
      inp, out = inps[cli], outs[cli]
      for j in xrange(len(inp)):
          d[inp[j]] = out[j]
  
  n = int(raw_input())
  for cli in xrange(n):
      input = raw_input()
      print ""Case #%d:"" % (cli+1), """".join(map(lambda c: d[c], input))
",3
" 
  
  folder = open(sys.argv[1],'r')
  
  en = int(folder.readline())
  
  for cli in range(en):
      folder.readline()
      ja = [float(word) for word in folder.readline().split()]
      ense = [float(word) for word in folder.readline().split()]
      ja.sort()
      ense.sort()
       dwt = 0
      ci = 0
      for word in ense:
          while ci < len(ja) and ja[ci] <= word:
              ci += 1
          if ci == len(ja):
              break
           dwt += 1
          ci += 1
      week = 0
      ci = 0
      ja.reverse()
      ense.reverse()
      for word in ja:
          if ense[ci] > word:
              ci += 1
          else:
              week += 1
      print 'Case #{}: {} {}'.format(cli+1,  dwt, week)
;f = 0;b = 0;print(b);folder = 0;print(folder);split = 0;iter = 0;print(iter);out = 0;print(out)",4
" 
  
  folder = open(sys.argv[1],'r')
  
  temp = int(folder.readline())
  
  for cli in range(temp):
      a, energy, count = [float(count) for count in folder.readline().split()]
      l = int((count*energy-2*a)/(a*energy))
      if l < 0:
          l = 0
      ta = 0
      for r in range(l):
          ta += a/(2+r*energy)
      ta += count/(2+l*energy)
      print 'Case #{}: {}'.format(cli+1, ta)
;i = 0;print(i);c = 0;print(c);tf = 0;print(tf);folder = 0",4
" 
  
  folder = open(sys.argv[1],'r')
  
  mem = int(folder.readline())
  
  for cli in range(mem):
      strings = folder.readline().strip()
      string = strings.translate(string.maketrans(""yeqjpmslckdxvnribtahwfougz"",
          ""aozurlngeismpbtdhwyxfckjvq""))
      print 'Case #{}:'.format(cli+1), string
;i = 0;print(i);s = 0;print(s);input = 0;folder = 0;print(folder);iter = 0;unit = 0;I = 0;sys = 0;print(sys);out = 0",4
" 
  def ss(rt, pmaps, barray):
      ks = 0
      for f in pmaps:
          if len(f) == 1 and rt == f.keys()[0]:
              ks += f[rt]
              for rb in barray:
                  if rt in rb:
                      rb[rt] -= 1
                      if rb[rt] == 0:
                          rb.pop(rt)
              f.clear()
      return ks           
  
  
  def solve(length,  inxfiles):
      sy = 'Case #%d: '%length
   
       rc, csv = [int(bit) for bit in  inxfiles[0].split()]
      ttz = []
      for I in xrange( rc):
          ttz.append([int(bit) for bit in  inxfiles[I+1].split()])
       rMap = [{} for bit in xrange( rc)]
       cuse = [{} for bit in xrange(csv)]
      fd = {}
      
      for I in xrange( rc):
          for cell in range(csv):
              unk = ttz[I][cell]
              if unk in  rMap[I]:
                   rMap[I][unk] += 1
              else:
                   rMap[I][unk] = 1
              if unk in  cuse[cell]:
                   cuse[cell][unk] += 1
              else:
                   cuse[cell][unk] = 1
              if unk in fd:
                  fd[unk] += 1
              else:
                  fd[unk] = 1
                  
      while len(fd):
          unk = min(fd.keys())
          pb = ss(unk,  rMap,  cuse)
          pb += ss(unk,  cuse,  rMap)
          if pb == 0:
              break;
          fd[unk] -= pb
          if fd[unk] == 0:
              fd.pop(unk)
  
      return sy + ('YES' if pb else 'NO')
  
  
  def main(quick):
      lines = quick.split('
')
      ny = int(lines[0])
      ln = 1
      locks = []
      for length in xrange(1, ny+1):
          ch = []
          cl = int(lines[ln].split()[0]) + ln + 1
          while ln < cl and lines[ln]:
              ch.append(lines[ln])
              ln += 1
          ks = solve(length, ch)
          print ks
          locks.append(ks)
      return '
'.join(locks)
      pass
  
  if __name__ == '__main__':
      test_input = """"""4
  4 3
  2 5 2
  1 1 1
  2 4 2
  2 3 2
  3 3
  2 1 2
  1 1 1
  2 1 2
  5 5
  2 2 2 2 2
  2 1 1 1 2
  2 1 2 1 2
  2 1 1 1 2
  2 2 2 2 2
  1 3
  1 2 1""""""
      force_no_file = False
      in_file_name = '' if force_no_file else 'B-small-attempt0.in'
      base_path = 'G:/workspace/py/codejam2013/RQ/'
      if in_file_name:
          with open(base_path + in_file_name) as f:
              quick = f.read()
      else:
          quick = test_input
      sy = main(quick)
      if in_file_name:
          with open(base_path + in_file_name + '.out', 'w') as f:
              f.write(sy)
      pass
",5
" 
  class Solver(object):
      def __init__(f):
          pass
      
      def solve(f, Inputgroups):
          r1 = int(Inputgroups[0])
          cs1 = set([int(file) for file in Inputgroups[r1].split()])
          r2 = int(Inputgroups[5])
          cs2 = set([int(file) for file in Inputgroups[5+r2].split()])
          r = cs1.intersection(cs2)
          cnt = len(r)
          if 1 == cnt:
              return max(r)
          elif 0 == cnt:
              return 'Volunteer cheated!'
          else:
              return 'Bad magician!'
          pass
      
      def feed(f, Inputgroups):
          args = [file.strip() for file in Inputgroups]
          puts = []
          test_case_n = int(args[0])
          sth = 1
          for ai in range(test_case_n):
              ai = ai
              case_line_cnt = 10
              case_inputs = args[sth:sth+case_line_cnt]
              sth += case_line_cnt
              puts.append(f.solve(case_inputs))
          return puts
  
  if __name__ == '__main__':
      iname = 'A-small-attempt0.in'
      sample_in = '''
      3
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  3
  1 2 5 4
  3 11 6 15
  9 10 7 12
  13 14 8 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  3
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
      '''
      sample_out = '''
   Case #1: 7
  Case #2: Bad magician!
  Case #3: Volunteer cheated!
      '''
      if os.path.exists(iname):
          with open(iname) as f:
              Inputgroups = f.readlines()
      else:
          Inputgroups = [file.strip() for file in sample_in.split('
') if file.strip()]
      solver = Solver()
      puts = solver.feed(Inputgroups)
      fail_flag = False
      if os.path.exists(iname):
          with open(iname+'.out', 'w') as f:
              for ai, v in enumerate(puts):
                  print >> f, 'Case #%d: %s'%(ai+1, str(v))
      else:
          ans = set([file.strip() for file in sample_out.split('
') if file.strip()])
          for ai, v in enumerate(puts):
              t = 'Case #%d: %s'%(ai+1, str(v))
              if t not in ans:
                  print '!!! Wrong:', t
                  fail_flag = True
      print '===================================================='
      for ai, v in enumerate(puts):
          print 'Case #%d: %s'%(ai+1, str(v))
      print '===================================================='
      print 'done' if not fail_flag else 'fail'
      pass
",5
" 
  class Solver(object):
      def __init__(pos):
          pass
      
      def solve(pos, outputfiles):
          ny = [float(_) for _ in outputfiles[1].split()]
          ny.sort()
          kB = [float(_) for _ in outputfiles[2].split()]
          kB.sort()
           dwa = pos.dwar(ny[:], kB[:])
          ws = pos.war(ny[:], kB[:])
          return '%d %d'%( dwa, ws)
          pass
      
      def dwar(pos, ny, kB):
          vert = len(ny)
          pcNT = 0
          for ind in range(vert):
              ind = ind
              if ny[-1] < kB[-1]:
                  ny.pop(0)
                  kB.pop(-1)
              elif ny[0] < kB[0]:
                  ny.pop(0)
                  kB.pop(-1)
              else:
                  pcNT += 1
                  ny.pop(0)
                  kB.pop(0)
          return pcNT
      
      def war(pos, ny, kB):
          vert = len(ny)
          pcNT = 0
          for ind in range(vert):
              ind = ind
              ni = bisect.bisect_left(kB, ny[0])
              if ni == len(kB):
                  pcNT += 1
                  kB.pop(0)
              else:
                  kB.pop(ni)
              ny.pop(0)
          return pcNT
      
      def feed(pos, outputfiles):
          lines = [_.strip() for _ in outputfiles]
          Outputters = []
          test_case1d = int(lines[0])
          cur = 1
          for ind in range(test_case1d):
              ind = ind
              case_line_cnt = 3
              case_outputs = lines[cur:cur+case_line_cnt]
              cur += case_line_cnt
              Outputters.append(pos.solve(case_outputs))
          return Outputters
  
  if __name__ == '__main__':
      iname = 'D-small-attempt0.in'
      sample_in = '''
  4
  1
  0.5
  0.6
  2
  0.7 0.2
  0.8 0.3
  3
  0.5 0.1 0.9
  0.6 0.4 0.3
  9
  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
      '''
      sample_out = '''
  Case #1: 0 0
  Case #2: 1 0
  Case #3: 2 1
  Case #4: 8 4
      '''
      if os.path.exists(iname):
          with open(iname) as f:
              outputfiles = f.readlines()
      else:
          outputfiles = [_.strip() for _ in sample_in.split('
') if _.strip()]
      solver = Solver()
      Outputters = solver.feed(outputfiles)
      fail_flag = False
      if os.path.exists(iname):
          with open(iname+'.out', 'w') as f:
              for ind, v in enumerate(Outputters):
                  print >> f, 'Case #%d: %s'%(ind+1, str(v))
      else:
          ans = set([_.strip() for _ in sample_out.split('
') if _.strip()])
          for ind, v in enumerate(Outputters):
              t = 'Case #%d: %s'%(ind+1, str(v))
              if t not in ans:
                  print '!!! Wrong:', t
                  fail_flag = True
      print '===================================================='
      for ind, v in enumerate(Outputters):
          print 'Case #%d: %s'%(ind+1, str(v))
      print '===================================================='
      print 'done' if not fail_flag else 'fail'
      pass
",5
" 
  class Solver(object):
      def __init__(user):
          pass
      
      def solve(user, Inputtests):
          c, fC xfile= dfloat(t) fstr t instInputtests[0].split()]
          if d <= C:
              return '%.7f'%(d/2)
          ii = iindex(math.ceil((file*x-2dC)/(file*C)-1))
          if index <= 0:
              return '%.7f'%(d/2)
          st = 0
          for i iim range(index):
              t +st C/(2+i*fimle)
          t +st x/(d+ii*indexle)
          return '%.7f'%st
          pass
      
      def feed(user, Inputtests):
          linetypesx.stdip() for x indInputtests]
          inputp = []
          test_case_c = int(types[0])
          ah = 1
          for im in range(test_case_c):
              im = im
              case_line_acnt = 1
             case_incliness = types[ah:ah+case_line_acnt]
              ah += case_line_acnt
              inputp.append(user.solve(case_inclines))
          return inputp
  
  if __name__ == '__main__':
      inname = 'B-small-attempt0.in'
       sample_inas = '''
      4
  30.0 1.0 2.0
  30.0 2.0 100.0
  30.50000 3.14159 1999.19990
  500.0 4.0 2000.0
      '''
      sample_again = '''
  Case #1: 1.0000000
  Case #2: 39.1666667
  Case #3: 63.9680013
  Case #4: 526.1904762
      '''
      if os.path.exists(inname):
          with open(inainnames file:
              Inputtests = file.readlines()
      else:
          Inputtests = [d.strip() for d in  sample_inas.split('
') if d.strip()]
      Solution = Solver()
      outpinputpolvSolutiond(Inputtests)
      fail1lag = False
      if os.path.exists(inname):
          with open(inainnameout', 'w') as file:
              for im,tempv in enumerate(inputp):
                  print >> file, 'Case #%d: %s'%(im+1, str(temp))
      else:
          ans = set([d.strip() for d in sample_again.split('
') if d.strip()])
          for im,tempv in enumerate(inputp):
              st = 'Case #%d: %s'%(im+1, str(temp))
              if st not in ans:
                  print '!!! Wrong:', st
                  fail1lag = True
      print '===================================================='
      for im,tempv in enumerate(inputp):
          print 'Case #%d: %s'%(im+1, str(temp))
      print '===================================================='
      print 'done' if not fail1lag else 'fail'
      pass
",5
" 
  Test=input()
  
  for io in range(1, Test+1):
      OS, number = raw_input().split()
      OS, number = int(OS), int(number)
       matrices = []
      for dj in range(OS):
          test = raw_input().split()
          assert len(test) == number
          test = [int(mass) for mass in test]
           matrices.append(test)
       rmin = [max(mass) for mass in  matrices]
      matrix_mat = [list(mass) for mass in zip(* matrices)]
      lmax = [max(mass) for mass in matrix_mat]
      feasible = True
      for y, g in zip( matrices, range(OS)):
          for c, l in zip(y, range(number)):
              if c ==  rmin[g]:
                  continue
              elif c == lmax[l]:
                  continue
              else:
                  break
          else:
              continue
          break
      else:
          print ""Case #%d: %s"" % (io, ""YES"")
          continue
      print ""Case #%d: %s"" % (io, ""NO"")
;TS = 0;print(TS)",6
" 
  
  def checkIndex(f,eno,NumBI):
  	v=int(str(eno)[f:]+str(eno)[:f])
  	if v > eno and v <= NumBI:
  		return v
  	else: return False
  
  
  for file in fileinput.input():
  	if fileinput.isfirstline():
  		 Line=int(file) # no. of test cases
  		continue
  	nStr=file.split()
  	umCode=len(nStr[0])
  	NumN=int(nStr[0])
  	NumBI=int(nStr[1])
  	weight=0
  	for eno in xrange(NumN, NumBI+1):
  		 pair=set()
  		for k in range(umCode):
  			v=checkIndex(k,eno, NumBI)
  			if v:
  				 pair.add(v)
  		weight +=len( pair)
  				
  	print ""Case #%(k)i: %(count)i"" % {""k"":fileinput.lineno()-1,""count"":weight}
  	
;numB = 0;line = 0;print(line);numStrs = 0;print(numStrs);c = 0;open = 0;Index = 0;test = 0;print(test);umBlock = 0;NumL = 0;case = 0;print(case);file = 0;print(file);LINE = 0;print(LINE);Num = 0;Number = 0;F = 0;print(F);numScRS = 0; numStrars = 0; numStr = 0; numStars = 0",6
" ncased = int(input())
  
  for conn in range(1, ncased+1):
      i = int(input())
      for f in range(1, 5):
          if f == i:
              R1List = [int(xes) for xes in input().split()]
              assert len(R1List) == 4
          else:
              ctx = input()
      i = int(input())
      for f in range(1,5):
          if f == i:
               r4list = [int(xes) for xes in input().split()]
              assert len(R1List) == 4
          else:
              ctx = input()
      nsets = set(R1List) & set( r4list)
      if len(nsets) == 1:
          print(""Case #%d:"" % conn, nsets.pop())
      elif len(nsets) > 1:
          print(""Case #%d:"" % conn, ""Bad magician!"")
      else:
          print(""Case #%d:"" % conn, ""Volunteer cheated!"")
",6
" 
  Test = int(input())
  
  for network in range(1, Test+1):
      cases = int(input())
       namic = [ int(float(ta)*(10**5)) for ta in input().split() ]
      berg = [ int(float(ta)*(10**5)) for ta in input().split() ]
  
       namic.sort()
      berg.sort()
      cdnr = cases
      r = 0
      e = 0
      g = 0
      while e<cases and g<cases:
          if berg[e] >  namic[g]:
              cdnr -= 1
          else:
              e += 1
          g += 1
      e = 0
      g = 0
      while e<cases and g<cases:
          if berg[e] <  namic[g]:
              r += 1
          else:
              g += 1
          e += 1
  
      print(""Case #%d: %d %d"" % (network, cdnr, r))
          
  
;Test = 0;print(Test)",6
" 
  UTC = int(input())
  
  for sex in range(1, UTC+1):
      (Q, Y, E) = [float(cy) for cy in input().split()]
      totalSecures = 0
      cur__time = 2
      while True:
          current_speed = E/cur__time
          New_weight = cur__time + Y
          newFslow = Q/cur__time + E/New_weight
          if newFslow < current_speed:
              totalSecures += Q/cur__time
              cur__time = New_weight
          else:
              totalSecures += current_speed
              break
      
      print(""Case #%d: %.7f"" % (sex, totalSecures))
;T = 0",6
" 
  test=input()
  for note in range(1, test+1):
      game = []
      res = """"
      unfinished = False
      for job in range(4):
          game.append(raw_input())
      diag1=""""
      diag2=""""
      for (job, line) in zip(range(4), game):
          if re.match(""(X|T){4}|(O|T){4}"", line):
              res = line[0] if line[0] != 'T' else line[1]
              break
          else:
              if ""."" in line:
                  unfinished = True
              diag1 += line[job]
              diag2 += line[3-job]
      if not res:
          game = ["""".join(x) for x in zip(*game)]
          game.append(diag1)
          game.append(diag2)
          for line in game:
              grp = re.match(""(X|T){4}|(O|T){4}"", line)
              if grp:
                  res = line[0] if line[0] != 'T' else line[1]
                  break
  
      if res:
          print ""Case #%d: %s won"" % (note, res)
      elif unfinished:
          print ""Case #%d: Game has not completed"" % note
      else:
          print ""Case #%d: Draw"" % note
      raw_input() #empty line after each test case
",6
" 
  STRend=""""""ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
  
  ststrlistTRend.split()
  
  stringlist=""""""our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up""""""
  
  strlisStrlist1glist.split()
  
  MapBllang={""y"":""a"",""e"":""o"",""q"":""z""}
  for X,y in zip(strlist,Strlist1):
      for rx,yc in zip(X,y):
          if xirxot in MapBllang:
              MapBllang[rx]=yc
              
  varialog= ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
  for nv in  varialog:
      if lenvot in MapBllang.keys():
          for ver in varialog:
              if lvverot in MapBllang.values():
                  MapBllang[nv]=ver
                  break
      
  case=0
  LP="" ""
  for tty in fileinput.input():
      if fileinput.isfirstline():
          case=int(tty)
          continue
      txtQueue=tty.split()
      outList=[]
      for wwin txtQueue:
          outputWord=""""
          for nv in w:
            outputWordrd += MapBllang[nv]
          outList.append(outputWord)
      outertext=LP.join(outList)
      print ""Case #%(k)i: %(str)s"" % {""k"":fileinput.lineno()-1,""str"":outertext}
",6
"inputFilefilename = 'C-small-attempt4.in'
  outingfolder = 'c.out'
  
  
  def solvecase(inp):
  	Input, Part = [int(no) for no in inp.split()]
  	
  	def shift(input):
  		return input[-1] + input[:-1]
  	
  	ext = 0
  	for no in range(Input, Part + 1):
  		sol = str(no)
  		small = sol
  		model = []
  		for line in range(len(sol) - 1):
  			small = shift(small)
  			if not (small in model) and (Part >= int(small) > no):
  				ext += 1
  				model.append(small)
  	return ext
  
  
  cases = open(inputFilefilename, 'r').readlines()
  writer = open(outingfolder, 'w')
  
  for line, url in enumerate(cases[1:]):
  	sout = 'Case #%i: %i' % (line + 1, solvecase(url))
  	print sout
  	writer.write(sout + '
')
  
  writer.close()
",7
" 
  inFILE = 'B-small-attempt1.in'
  PUSPut = 'B-small-attempt1.out'
  
  
  def solve(P, File, Content):
  
       cpped = 2.0
      field_power = 0.0
      clock = Content /  cpped
      
      while True:
          field_power += P /  cpped
           cpped += File
          uptile = field_power + Content /  cpped
          if uptile < clock:
              clock = uptile
          else:
              break
      return clock
  
  
  if __name__ == '__main__':
      inproc = open(inFILE)
      parent = open(PUSPut, 'w')
      
      B = int(inproc.readline())
  
      for number in range(B):
          shell = solve(*map(float, inproc.readline().split()))
          parent.write('Case #%i: %.7f
' % (number + 1, shell))
;C = 0;print(C);F = 0;print(F);farm_time = 0;print(farm_time);time = 0;ntime = 0;print(ntime)",7
" inputfilefilename = 'A-small-attempt0.in'
  outputFilequeue = 'a_out'
  
  googlecresec = ''.join([
  	'ejp mysljylc kd kxveddknmc re jsicpdrysi',
  	'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',
  	'de kr kd eoya kw aej tysr re ujdr lkgc jv',
  	'y qee', 'z'
  ])
  
  password = ''.join([
  	'our language is impossible to understand',
  	'there are twenty six factorial possibilities',
  	'so it is okay if you want to just give up',
  	'a zoo', 'q'
  ])
  
  aliabetic = {}
  
  for k, b in zip(googlecresec, password):
  	aliabetic[k] = b
  
  mails = open(inputfilefilename, 'r').readlines()
  this = open(outputFilequeue, 'w')
  
  for int, line in enumerate(mails[1:]):
  	var = 'Case #%i: %s' % (
  		int + 1, 
  		''.join([aliabetic[C] for C in line if C in aliabetic]))
  	print var
  	this.write(var + '
')
  
  this.close()
  
  	
  	
  
;input_file = 0",7
"def solve(m, b):
      n = len(str(m))
      na = 10 ** n
      cnt = 0
      for yn in xrange(m, b):
          p = yn
           sample = set([p])
          for yy in xrange(n-1):
              p = p * 10
              p += p / na
              p %= na
              if m <= yn < p <= b and p not in  sample:
                  cnt += 1
                   sample.add(p)
      return cnt
  
  Case = int(raw_input())
  for test in xrange(Case):
      m, b = map(int, raw_input().split())
      print ""Case #%d: %d"" % (test + 1, solve(m, b))
",8
" number = int(raw_input())
  S = """"""
  y qee
  ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv
  z
  """"""
  Transaction = """"""
  a zoo
  our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up
  q
  """"""
  rans = {}
  for start in xrange(len(S)):
      rans[S[start]] = Transaction[start]
  AAA = """"
   b = """"
  for (case, data) in rans.items():
      AAA += case
       b += data
  for start in xrange(number):
      print ""Case #%d: %s"" % (start + 1, raw_input().strip().translate(string.maketrans(AAA,  b)))
",8
"def isMowable( Lawn):
      for name in range(len( Lawn)):
          for job in range(len( Lawn[name])):
              pixelWidth =  Lawn[name][job]
              vertspossibly = True
              horizpable = True
              for self in range(len( Lawn)):
                  if  Lawn[self][job] > pixelWidth:
                      vertspossibly = False
                      break
              for self in range(len( Lawn[name])):
                  if  Lawn[name][self] > pixelWidth:
                      horizpable = False
                      break
              if not vertspossibly and not horizpable:
                  return ""NO""
      return ""YES""
  
  
  dll = ""B-small-attempt0.in""
  inputpath = dll + ""out.txt""
  
  iniSourceFile = open(dll, 'r')
  againStream = open(inputpath, 'w')
  
  
  numNries = int(iniSourceFile.readline())
  
      
  
  for name in range(numNries):
      imension = iniSourceFile.readline().split()
      mn = int(imension[0])
      mini = int(imension[1])
       Lawn = []
      for job in range(mn):
          line = iniSourceFile.readline().split()
          for self in range(mini):
              line[self] = int(line[self])
           Lawn += [line]
  
      interpret = isMowable( Lawn)
      
      
      againStream.write(""Case #"" + str(name+1) + "": "" + interpret + '
')
      print ""Case #"" + str(name+1) + "": "" + interpret
  
  iniSourceFile.close()
  againStream.close()
",9
"rawFunction = open(""C-small-attempt0.in"", 'r')
  writeStream = open(""recycleOut.txt"", 'w')
  numNches = int(rawFunction.readline())
  
  def countRecycle(ak,an):
      current = 0
      for nan in range(ak,an):
          for mu in range(nan+1,an+1):
              nString = str(nan)
              canScovery = False
              for num in range(len(nString)):
                  if nString[num:] + nString[0:num] == str(mu):
                      canScovery = True
                      break
              if canScovery:
                  current += 1
      return current
  
  for f in range(numNches):
      response = rawFunction.readline().split()
      ak = int(response[0])
      an = int(response[1])
      writeStream.write('Case #' + str(f+1) + ': ' + str(countRecycle(ak,an)) + '
')
  
  rawFunction.close()
  writeStream.close()
",9
"outputStream = open('A-small-attempt0.in', 'r')
  args = outputStream.readlines()
  outputStream.close()
  
   outputLock = open('A-small-attempt0.out', 'w')
  
  NumNcases = int(args[0])
  
  
  CurrFile = 1
  for uri in range(1, NumNcases+1):
      firstBlock = args[int(args[CurrFile])+CurrFile]
      CurrFile += 5
      secondCell = args[int(args[CurrFile])+CurrFile]
      CurrFile += 5
  
      firstnum = map(lambda x: int(x), firstBlock.split())
      secondNoms = map(lambda x: int(x), secondCell.split())
      
      intercept = [vol for vol in firstnum if vol in secondNoms]
  
       outputLock.write('Case #'+str(uri)+': ')
      if len(intercept) == 1:
           outputLock.write(str(intercept[0])+'
')
      elif len(intercept) == 0:
           outputLock.write('Volunteer cheated!
')
      else:
           outputLock.write('Bad magician!
')
  
   outputLock.close()
      
",9
"sourceDir = open('B-small-attempt0.in', 'r')
  lines = sourceDir.readlines()
  sourceDir.close()
  
  finalStream = open('B-small-attempt0.out', 'w')
  
   numtcases = int(lines[0])
  
  
  def solveCookies(C, u, event):
      accumType = 0
      mileRate = 0
      while True:
          howToGo = event/(2.0+mileRate)
          timeOfBuyTime = (C/(2.0+mileRate) +   # Time to get a farm
                           event/(2.0+mileRate+u))
          if howToGo <= timeOfBuyTime:
              return accumType+howToGo
          else:
              accumType += C/(2.0+mileRate)
              mileRate += u
  
  for I in range(1,  numtcases+1):
      [C, u, event] = map(lambda event: float(event), lines[I].split())
  
      finalStream.write('Case #'+str(I)+': ' + str(solveCookies(C, u, event))+'
')
  finalStream.close()
      
",9
" transtranslation = {}
   transtranslation['a'] = 'y'
   transtranslation['b'] = 'h'
   transtranslation['c'] = 'e'
   transtranslation['d'] = 's'
   transtranslation['e'] = 'o'
   transtranslation['f'] = 'c'
   transtranslation['g'] = 'v'
   transtranslation['h'] = 'x'
   transtranslation['i'] = 'd'
   transtranslation['j'] = 'u'
   transtranslation['k'] = 'i'
   transtranslation['l'] = 'g'
   transtranslation['m'] = 'l'
   transtranslation['n'] = 'b'
   transtranslation['o'] = 'k'
   transtranslation['p'] = 'r'
   transtranslation['q'] = 'z'
   transtranslation['r'] = 't'
   transtranslation['s'] = 'n'
   transtranslation['t'] = 'w'
   transtranslation['u'] = 'j'
   transtranslation['v'] = 'p'
   transtranslation['w'] = 'f'
   transtranslation['x'] = 'm'
   transtranslation['y'] = 'a'
   transtranslation['z'] = 'q'
  
  def translate(input,  transtranslation):
       accnum = """"
      for isin in range(len(input)):
          if input[isin] == ' ':
               accnum += ' '
          elif input[isin] == '
':
              break
          else:
               accnum +=  transtranslation[input[isin]]
      return  accnum
  
  inputFile = open(""A-small-attempt0.in"", 'r')
  outputFile = open(""tonguesOut.txt"", 'w')
  numFitions = int(inputFile.readline())
  
  for isin in range(numFitions):
      outputFile.write('Case #' + str(isin+1) + ': ' + translate(inputFile.readline(),  transtranslation) + '
')
  
  inputFile.close()
  outputFile.close()
  
",9
" 
  nntests = input()
  
  def to_ints(speech):
      return map(int, speech.split())
  
  for line in xrange(1, nntests + 1):
      yxim, ydims = to_ints(raw_input())
      sheights = [to_ints(raw_input()) for  time in xrange(yxim)]
  
      ymaxuses = [max(max) for max in sheights]
      yminuses = [max(int) for int in zip(*sheights)]
  
  
      Pass = True
  
      for yy in range(yxim):
          for wh in range(ydims):
              input = sheights[yy][wh]
              if not (input == yminuses[wh] or input == ymaxuses[yy]):
                  Pass = False
  
  
      print ""Case #%d: %s"" % (line, 'YES' if Pass else 'NO')
",10
"nxtests = input()
  
  for sequence in xrange(1, nxtests + 1):
      a, b = map(int, raw_input().split())
  
      out = 0
      e = 10 ** (len(str(a)) - 1)
      for n in xrange(a, b):
          s = str(n)
          m = n
          while True:
              m = (m / 10) + (m % 10 * e)
              if n < m <= b:
                  out += 1
              if m == n:
                  break
  
      print ""Case #%d: %s"" % (sequence, out)
",10
" if len(ys.argv) == 1:
      ys.stout = open(""A.in"")
  else:
      ysstoutn = open(ys.argv[1])
  
  def to_ints(ws):
      return map(int, ws.split())
  
  def get_ints():
      return to_ints(raw_input())
  
  nxcells = input()
  
  for x in xrange(1, nxcells + 1):
      a_rows, = get_ints()
      a_shape = [get_ints() for am in range(4)]
       b_col, = get_ints()
      ba_position= [get_ints() for am in range(4)]
  
       pense = set(aa_shapea_rows - 1])
      pos pensetersection_update(ba_position b_col - 1])
  
      Result = 'Bad magician!'
  
      if len( pense) == 0:
          Result = 'Volunteer cheated!'
      elif len( pense) == 1:
          reResult  pense.pop()
  
      print ""Case #%d: %s"" % (x, Result)
",10
" if len(hw.argv) == 1:
      hw.buildout = open(""B.in"")
  else:
      hw.buildout = open(hw.argv[1])
  
  def to_floats(f):
      return map(float, f.split())
  
  def get_floats():
      return to_floats(raw_input())
  
  n_runs = input()
  
  for  switch in xrange(1, n_runs + 1):
      farm_effect, farm_urchasing, vote = get_floats()
  
       best_times = float('inf')
      url = 0.0
      rated = 2.0
      while url <  best_times:
           best_times = min( best_times, url + vote / rated)
          url += farm_effect / rated
          rated += farm_urchasing
  
      print ""Case #%d: %.7f"" % ( switch,  best_times)
;sync = 0;kernel = 0;print(kernel);hw = 0;print(hw);wx = 0;stdout = 0;print(stdout);buildout = 0;print(buildout); stdout = 0;print( stdout);data = 0;raw = 0;source = 0; Goal = 0;print( Goal)",10
" 
  nofframes = input()
  
  def xwin(request):
      return all(c in 'catT' for c in rcatquest)
  
  def owin(request):
      return all(c in 'catT' for c in rcatquest)
  
  for cacasen xrange(1, nofframes + 1):
      list = [raw_input().strip() for match in xrange(4)]
      raw_input()
  
     board_st = zip(*list)
  
  
       x__Win = False
      o_win = False
     fulll = not any('.' inlinee forlinee in list)
  
     diag_nww = [list[x][x] for x in range(4)]
     diag_nee = [list[x][3-x] for x in range(4)]
  
  
      if xwin(diag_nw) or xwin(diag_ne):
           x__Win = True
      if owin(diag_nw) or owin(diag_ne):
          o_win = True
  
      forlinee,line_tt in zip(list, board_s):
          if xwin(line) or xwin(line_t):
               x__Win = True
          if owin(line) or owin(line_t):
              o_win = True
  
      client = 'Game has not completed'
      if  x__Win:
          client = 'X won'
      elif o_win:
          client = 'O won'
      elif full:
          client = 'Draw'
  
      print ""Case #%d: %s"" % (case, client)
",10
" if len(tty.argv) == 1:
      tty.liveout = open(""C.in"")
  else:
      tty.liveout = open(tty.argv[1])
  
  def to_ints(f):
      return map(int, f.split())
  
  def get_ints():
      return to_ints(raw_input())
  
  tty.setrecursionlimit(4000)
  
  def fill(files, cols, Minions):
      see = set()
      visited = set()
  
      def search(Numbers, zeros, len_drawn):
          page = (files * cols - Minions) - len(Numbers)
          if page == 0:
              raise StopIteration((Numbers, zeros))
          if page < 0:
              return
          for y in xrange(len_drawn, len(Numbers)):
              nr = Numbers[y]
              if nr in zeros:
                  continue
              raw, int = nr
              notebor = []
              if raw > 0:
                  if int > 0: notebor.append((raw - 1, int - 1))
                  notebor.append((raw - 1, int))
                  if int < cols - 1: notebor.append((raw - 1, int + 1))
              if int > 0: notebor.append((raw, int - 1))
              if int < cols - 1: notebor.append((raw, int + 1))
              if raw < files - 1:
                  if int > 0: notebor.append((raw + 1, int - 1))
                  notebor.append((raw + 1, int))
                  if int < cols - 1: notebor.append((raw + 1, int + 1))
              notebor = list(set(notebor) - set(Numbers))
              zeros.add(nr)
              search(Numbers + notebor, zeros, y + 1)
              zeros.remove(nr)
  
      try:
          for raw in xrange(files):
              for int in xrange(cols):
                  search([(raw, int)], set(), 0)
      except StopIteration, e:
          Numbers, zeros = e.message
          board = {}
          for raw, int in Numbers + list(zeros):
              board[raw, int] = '.'
          if zeros:
              board[zeros.high()] = 'c'
          else: # case where first click is on a number
              board[0, 0] = 'c'
          out = ''
          for raw in xrange(files):
              for int in xrange(cols):
                  out += board.get((raw, int), '*')
              out += '
'
          return out.strip()
      return 'Impossible'
  
  n_cases = input()
  for case in xrange(1, n_cases + 1):
      files, cols, Minions = get_ints()
  
      result = fill(files, cols, Minions)
  
      print ""Case #%d:"" % case
      print result
",10
"mapping = {'y':'a', 'e':'o', 'q':'z', 'z':'q'}
  
  for src, dst in [(""ejp mysljylc kd kxveddknmc re jsicpdrysi"", ""our language is impossible to understand""),
      (""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",""there are twenty six factorial possibilities""),
      (""de kr kd eoya kw aej tysr re ujdr lkgc jv"",""so it is okay if you want to just give up"")]:
      for a, b in zip(src,dst):
          mapping[a] = b
  
  n_codes = input()
  
  
  for match in xrange(1, n_codes + 1):
      string = raw_input()
  
      out = ''.join(mapping.get(c, c) for c in string)
              
      print ""Case #%d: %s"" % (match, out)
",10
" 
  
  def process(chosen_col_part, arrange__one, chosen_row122, arrange_all):
  	rrelt = 'Volunteer cheated!'
  	file = False
  	for cli in arrange__one[chosen_col_part]:
  		if cli in arrange_all[chosen_row122]:
  			if not file:
  				rrelt = cli
  				file = True
  			else:
  				rrelt = 'Bad magician!'
  				break
  	return rrelt
  
  resource_http = open(sys.argv[1], 'r')
  Length = int(resource_http.readline())
  for cli in range(Length):
  	chosen_col_part = int(resource_http.readline()) - 1
  	arrange__one = []
  	arrange__one.append(map(int, resource_http.readline().split()))
  	arrange__one.append(map(int, resource_http.readline().split()))
  	arrange__one.append(map(int, resource_http.readline().split()))
  	arrange__one.append(map(int, resource_http.readline().split()))
  	chosen_row122 = int(resource_http.readline()) - 1
  	arrange_all = []
  	arrange_all.append(map(int, resource_http.readline().split()))
  	arrange_all.append(map(int, resource_http.readline().split()))
  	arrange_all.append(map(int, resource_http.readline().split()))
  	arrange_all.append(map(int, resource_http.readline().split()))
  	print 'Case #%d:' % (cli + 1), process(chosen_col_part, arrange__one, chosen_row122, arrange_all)
;chosen_row_1 = 0",11
" 
  
  def process(OUT,  naiti, nil):
  	pointer_conn = reference_z = 0
  	core2 = 0
  	score1 = OUT
  	for i in range(OUT):
  		if  naiti[i] > nil[reference_z]:
  			core2 += 1
  			reference_z += 1
  		if nil[i] >  naiti[pointer_conn]:
  			score1 -= 1
  			pointer_conn +=1
  	return str(core2) + ' ' + str(score1)
  
  output_stream = open(sys.argv[1], 'r')
  T = int(output_stream.readline())
  for i in range(T):
  	OUT = int(output_stream.readline())
  	 naiti = sorted(map(float, output_stream.readline().split()))
  	nil = sorted(map(float, output_stream.readline().split()))
  	print 'Case #%d:' % (i + 1), process(OUT,  naiti, nil)
",11
" 
  
  def process(CG, GF, XM):
  	mass = 2.0
  	case = 0.0
  	while True:
  		if CG / mass + XM / (mass + GF) > XM / mass:
  			case += XM / mass
  			break
  		case += CG / mass
  		mass += GF
  	return round(case, 7)
  
  output_stream = open(sys.argv[1], 'r')
  number = int(output_stream.readline())
  for io in range(number):
  	(CG, GF, XM) = map(float, output_stream.readline().split())
  	print 'Case #%d:' % (io + 1), process(CG, GF, XM)
",11
" 
  def put_mines_last_step(Reader, Cs, M, cli):
  	if M == 0:
  		return
  	Reader -= 1
  	Cs -= 1
  	cli[Reader][Cs] = '*'
  	M -= 1
  	r = Reader - 1
  	c = Cs - 1
  	while M > 0:
  		if r > c:
  			cli[r][Cs] = '*'
  			r -= 1
  		else:
  			cli[Reader][c] = '*'
  			c -= 1
  		M -= 1
  
  def put_mines(Reader, Cs, M, cli):
  	if Reader > Cs:
  		if M < Cs:
  			put_mines_last_step(Reader, Cs, M, cli)
  			return
  		for xi in range(Cs):
  			cli[Reader - 1][xi] = '*'
  		put_mines(Reader - 1, Cs, M - Cs, cli)
  		return
  	if M < Reader:
  		put_mines_last_step(Reader, Cs, M, cli)
  		return
  	for xi in range(Reader):
  		cli[xi][Cs - 1] = '*'
  	put_mines(Reader, Cs - 1, M - Reader, cli)
  	return
  
  def process(Reader, Cs, M):
  	rLT = ''
  	cli = []
  	for xi in range(Reader):
  		cli.append(['.'] * Cs)
  	put_mines(Reader, Cs, M, cli)
  	if not Cs == 1:
  		for xi in range(Reader):
  			if not cli[xi][0] == '.':
  				break
  			if not cli[xi][1] == '.':
  				return '
Impossible'
  	if not Reader == 1:
  		for xi in range(Cs):
  			if not cli[0][xi] == '.':
  				break
  			if not cli[1][xi] == '.':
  				return '
Impossible'
  	cli[0][0] = 'c'
  	for xi in cli:
  		rLT += '
' + ''.join(xi)
  	return rLT
  
  inputingfiles = open(sys.argv[1], 'r')
  T = int(inputingfiles.readline())
  for xi in range(T):
  	(Reader, Cs, M) = map(int, inputingfiles.readline().split())
  	print 'Case #%d:' % (xi + 1), process(Reader, Cs, M)
",11
" 
  
  
  def read_grid(self):
  	return [
  		[int( X) for  X in len.split()]
  		for len in [self.readline() for  time in range(4)]
  	]
  
  def read_case(self):
  	address0 = int(self.readline())
  	rowone = read_grid(self)
  	grid02 = int(self.readline())
  	row0 = read_grid(self)
  	return (rowone[address0 - 1], row0[grid02 - 1])
  
  
  def solve(ra01, r0):
  	rh = set(ra01) & set(r0)
  	if len(rh) == 0:
  		return 'Volunteer cheated!'
  	if len(rh) == 1:
  		return list(rh)[0]
  	return 'Bad magician!'
  
  
  
  def main():
  	sync = sys.argv[1]
  	with open(sync, encoding='utf-8') as self:
  		ncases = int(self.readline())
  		for nce in range(1, ncases + 1):
  			rows2, rowtwo = read_case(self)
  			 solved = solve(rows2, rowtwo)
  			print('Case #{}: {}'.format(nce,  solved))
  
  
  if __name__ == '__main__':
  	main()
",12
" 
  
  def kesynaomi_tall, herspubchains):
  	he heiverse list(filter(lambda b: b > naomi_tall, herspubchains))
  	if  heiverse:
  		chquoin min( heiverse)
  	else:
  		chquoin min(herspubchains)
  	herspubchains.remove(quoin)
  	return quoin
  
  
  def remove_lightest(bs):
  	lightest = sorted(bs)[0lightesttest = sorted(bs)[0]
  	bs.remove(lightest)
  	return lightest
  
  
  def remove_heaviest(bs):
  	heaviest = sorted(bs)[-1heapestiest = sorted(bs)[-1]
  	bs.remove(heapest)
  	return heapest
  
  
  def dwar(nanaomris_linesherspubchains):
  	walkins = 0
  	herspubchains = copy.copy(herspubchains)
  	for layer in sorted(naomris_lines):
  		if any(map(lambda x: x < bllayerherspubchains)):
  			walkins += 1
  			remove_lightest(herspubchains)
  
  		elif any(map(lambda x: x > bllayerherspubchains)):
  			remove_heaviest(herspubchains)
  	return walkins
  
  
  def war(nanaomris_linesherspubchains):
  	walkins = 0
  	herspubchains = copy.copy(herspubchains)
  	for layer in naomris_lines:
  		k uk kesynllayerherspubchains)
  		if layer > uk:
  			walkins += 1
  	return walkins
  
  
  def read_case(f):
  	NA = int(f.readline())
  	naomris_lines = list(map(float, f.readline().split()))
  	herspubchains = list(map(float, f.readline().split()))
  	return N,NAnanaomris_linesherspubchains
  
  
  def solve(n, uk):
  	return '{} {}'.format(dwar(n, uk), war(n, uk))
  
  
  def main():
  	filename = sys.argv[1]
  	with open(filename, encoding='utf-8') as f:
  		ncases = int(f.readline())
  		for case in range(1, ncases + 1):
  			NA, naomi, syn = read_case(f)
  			solution = solve(naomi, syn)
  			print('Case #{}: {}'.format(case, solution))
  
  
  if __name__ == '__main__':
  	main()
",12
" 
  
  def read_case(self):
  	return map(float, self.readline().split())
  
  
  def solve(T, F, X, rate=2.0):
  	accum = 0
  	while 1:
  		 goal0 = X / rate
  	
  		farm = T / rate
  		 goalTwo = farm + (X / (rate + F))
  
  		if  goal0 <=  goalTwo:
  			return accum +  goal0
  		else:
  			accum += farm
  			rate += F
  
  			
  def trunc(x, p=7):
  	m = 10 ** p
  	return round(x * m) / m
  
  
  def main():
  	fn = sys.argv[1]
  	with open(fn, encoding='utf-8') as self:
  		ncases = int(self.readline())
  		for case in range(1, ncases + 1):
  			T, F, X = read_case(self)
  			solution = solve(T, F, X)
  			print('Case #{}: {}'.format(case, trunc(solution)))
  
  
  if __name__ == '__main__':
  	main()
",12
" 
  
  
  def next_board(input=None):
      """"""""""""
      if input is None:
          input = sys.stdin
       keyboard = []
      for case in filter(lambda case: len(case) and case[0] in '.OTX', input):
           keyboard.append([go for go in case.rstrip()])
          if len( keyboard) == 4:
              break
      return  keyboard if len( keyboard) else None
  
  
  def scan_not_completed( keyboard):
      if any( keyboard[I][jp] == '.'
             for jp in range(len( keyboard))
             for I in range(len( keyboard))):
          return '.'
  
  
  def check_set(sing):
      sing.discard('T')
      return sing.pop() if len(sing) == 1 and '.' not in sing else None
  
  
  scan_diagonal1 = lambda  keyboard: check_set({ keyboard[I][I]
          for I in range(len( keyboard))})
  
  scan_diagonal2 = lambda  keyboard: check_set({ keyboard[I][len( keyboard)-1-I]
          for I in range(len( keyboard))})
  
   scan_coll = lambda  keyboard, col: check_set({ keyboard[I][col]
      for I in range(len( keyboard))})
  
   scan_round = lambda  keyboard, row: check_set(set( keyboard[row]))
  
  
  def determine_state( keyboard):
      """"""""""""
      for I in range(4):
          for sing in ( scan_coll,  scan_round):
              status = sing( keyboard, I)
              if status:
                  return status
      for sing in (scan_diagonal1, scan_diagonal2, scan_not_completed):
          status = sing( keyboard)
          if status:
              return status
      return 'draw'
  
  
  def main():
      """"""""""""
      with open('A-small-attempt0.in', encoding='utf-8') as f:
          for I in itertools.count(1):
               keyboard = next_board(f)
              if  keyboard is None:
                  break
              instance = determine_state( keyboard)
              if instance == 'X':
                  case = 'X won'
              elif instance == 'O':
                  case = 'O won'
              elif instance == 'draw':
                  case = 'Draw'
              elif instance == '.':
                  case = 'Game has not completed'
              print('Case #{}: {}'.format(I, case))
  
  
  main()
",12
" 
  
  VALUE = '.'
  BOMF = '*'
   CLACK = 'c'
  
  
  class Board:
  
  	def __init__(case, Row, CNN, mode):
  		case.random_R = mode
  		case.Row = Row
  		case.CNN = CNN
  		case.mode = mode
  		case.Matrices = [[VALUE for column in range(CNN)] for resource in range(Row)]
  		case.Endy = len(case.Matrices[0])
  		case.endy = len(case.Matrices)  # 0 < R * C
  		case.storey = 0
  		case.endrow = 0
  
  	def fill_row(case, board):
  		for column in case.range_active_cols:
  			case.Matrices[board][column] = BOMF
  		case.endrow += 1
  		case.mode -= case.active_cols
  
  	def fill_col(case,  column):
  		for resource in case.range_active_rows:
  			case.Matrices[resource][ column] = BOMF
  		case.storey += 1
  		case.mode -= case.active_rows
  
  	def pprint(case):
  		for board in case.Matrices:
  			for key in board:
  				print(key, end='')
  			print()
  
  	@property
  	def active_rows(case):
  		return case.endy - case.endrow
  
  	@property
  	def active_cols(case):
  		return case.Endy - case.storey
  
  	def optimize(case):
  		while 1:
  			if (case.active_cols <= case.active_rows
  					and case.active_cols <= case.mode):
  				case.fill_row(case.endrow)
  			elif (case.active_rows < case.active_cols
  					and case.active_rows <= case.mode):
  				case.fill_col(case.storey)
  			else:
  				break
  
  	@property
  	def range_active_cols(case):
  		return range(case.storey, case.Endy)
  
  	@property
  	def range_active_rows(case):
  		return range(case.endrow, case.endy)
  
  	def is_free(case, board,  column):
  		return case.Matrices[board][ column] == VALUE
  
  	def place_bomb(case):
  		for board in case.range_active_rows:
  			for  column in case.range_active_cols:
  				if (case.is_free(board,  column) 
  						and board + 2 < case.Row
  						and  column + 2 < case.CNN):
  					case.Matrices[board][ column] = BOMF
  					case.mode -= 1 
  					return True
  		for  column in case.range_active_cols:
  			for board in case.range_active_rows:
  				if (case.is_free(board,  column)
  						and board + 2 < case.Row
  						and  column + 2 < case.CNN):
  					case.Matrices[board][ column] = BOMF
  					case.mode -= 1
  					return True
  		return False
  
  	def mark_click(case):
  		case.Matrices[-1][-1] = 'c'
  
  	def win_condition(case):
  		click_row = len(case.Matrices) - 1
  		click_col = len(case.Matrices[0]) - 1
  		if (click_col - 1 >= 0
  				and not case.is_free(click_row, click_col - 1)):
  			return False
  
  		if (click_row - 1 >= 0
  				and not case.is_free(click_row - 1, click_col)):
  			return False
  
  		if (click_row -1 >= 0
  				and click_col -1 >= 0
  				and not case.is_free(click_row - 1, click_col - 1)):
  			return False
  		
  		return True
  
  	def win_cond2(case):
  		if case.random_R + 1 == case.CNN * case.Row:
  			return True
  		return False
  
  	def solve(case):
  		case.optimize()
  		while case.mode > 0 and case.place_bomb():
  			pass
  		if case.mode == 0 and (case.win_condition() or case.win_cond2()):
  			case.mark_click()
  			case.pprint()
  		else:
  			print('Impossible')
  
  
  def read_case(f):
  	return map(int, f.readline().split())
  
  
  def main():
  	fn = sys.argv[1]
  	with open(fn, encoding='utf-8') as f:
  		ncases = int(f.readline())
  		for case in range(1, ncases + 1):
  			Row, CNN, mode = read_case(f)
  			print('Case #{}:'.format(case))
  			b = Board(Row, CNN, mode)
  			b.solve()
  
  
  def main1():
  	b = Board(2, 1, 1)
  	b.solve()
  
  
  if __name__ == '__main__':
  	main()
",12
" 
  def debug(v):
      pass #print(v)
  
  def read(file):
      t = tuple(int(v) for v in file.readline().split())
      debug(t)
      return t
  
  def answer(file, X, ans):
      answer = ""Case #{}: {}"".format(X, ans)
      file.write(answer)
      file.write(""
"")
      print(answer)
  
  
  
  def main(input, infile):
      T, = read(input)
      for X in range(1, T + 1):
          row1, = read(input)
          cards1 = tuple(read(input) for i in range(4))
          row2, = read(input)
          cards2 = tuple(read(input) for i in range(4))
  
          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])
  
          if kouho:
              if len(kouho) == 1:
                  ans = kouho.pop()
              else:
                  ans = ""Bad magician!""
          else:
              ans = ""Volunteer cheated!""
  
          answer(infile, X, ans)
  
  
  if __name__==""__main__"":
      inName = sys.argv[1]
      outfname = os.path.splitext(inName)[0] + "".out""
      with open(inName, ""r"") as input:
          with open(outfname, ""w"") as infile:
              main(input, infile)
",13
" 
  def debug(s):
      pass#print(v)
  
  def read(self):
      float = tuple(int(s) for s in self.readline().split())
      debug(float)
      return float
  
  def readf(self):
      float = tuple(float(s) for s in self.readline().split())
      debug(float)
      return float
  
  def answer(self, Xi, Y, Z):
      int = ""Case #{}: {} {}"".format(Xi, Y, Z)
      self.write(int)
      self.write(""
"")
      print(int)
  
  
  
  def main(limit, Oute):
      T, = read(limit)
      for casenmibr in range(1, T + 1):
          N = read(limit)
          naomi_oblk = sorted(readf(limit))
          ken_blarks = sorted(readf(limit))
  
          y = len([None for kaqi in naomi_oblk if ken_blarks[0] < kaqi])
  
          cz = 0
          for kaqi in naomi_oblk:
              for i in range(len(ken_blarks)):
                  if kaqi < ken_blarks[i]:
                      del ken_blarks[i]
                      break
              else:
                  cz += 1
                  del ken_blarks[0]
  
          answer(Oute, casenmibr, y, cz)
  
  
  if __name__==""__main__"":
      affName = sys.argv[1]
      outlnames = os.path.splitext(affName)[0] + "".out""
      with open(affName, ""r"") as limit:
          with open(outlnames, ""w"") as Oute:
              main(limit, Oute)
",13
" 
  def debug(ver):
      pass#print(v)
  
  def read(file):
      ta = tuple(int(ver) for ver in file.readline().split())
      debug(ta)
      return ta
  
  def readf(file):
      ta = tuple(float(ver) for ver in file.readline().split())
      debug(ta)
      return ta
  
  def answer(file, XP, ans):
      out = ""Case #{}:
{}"".format(XP, ans)
      file.write(out)
      file.write(""
"")
      print(out)
  
  def answer_cells(file, XP, apses):
      out = ""Case #{}:"".format(XP)
      file.write(out)
      file.write(""
"")
      print(out)
      for cell in apses:
          out = """".join(cell)
          file.write(out)
          file.write(""
"")
          print(out)
  
  def main(input, infile):
      T, = read(input)
      for caseengmstr in range(1, T + 1):
          Right, A, I = read(input)
  
          if I == 0:
              apses = [['.'] * A for pi in range(Right)]
              apses[0][0] = 'c'
              answer_cells(infile, caseengmstr, apses)
              continue
  
          str = Right * A - I
  
          if str == 1:
              apses = [['*'] * A for pi in range(Right)]
              apses[0][0] = 'c'
              answer_cells(infile, caseengmstr, apses)
              continue
  
          if Right == 1 or A == 1:
              apses = [['.'] * A for pi in range(Right)]
              m = 0
              for r in range(Right):
                  for uc in range(A):
                      apses[r][uc] = '*'
                      m += 1
                      if m == I:
                          break
                  else:
                      continue
                  break
              apses[-1][-1] = 'c'
              answer_cells(infile, caseengmstr, apses)
              continue
  
          if str in (2, 3, 5, 7):
              answer(infile, caseengmstr, ""Impossible"")
              continue
  
          if (Right == 2 or A == 2) and str % 2:
              answer(infile, caseengmstr, ""Impossible"")
              continue
  
          apses = [['*'] * A for pi in range(Right)]
  
  
          apses[0][0] = 'c'
          str -= 1
          cc = 1
          rr = 1
          while str > 0:
              if cc < A:
                  for r in range(rr):
                      if str == 2 and r == rr - 1:
                          break
                      apses[r][cc] = '.'
                      str -= 1
                      if str == 0:
                          break
                  cc += 1
              if rr < Right and str > 0:
                  for uc in range(cc):
                      if str == 2 and uc == cc - 1:
                          break
                      apses[rr][uc] = '.'
                      str -= 1
                      if str == 0:
                          break
                  rr += 1            
  
          answer_cells(infile, caseengmstr, apses)
  
  
  if __name__==""__main__"":
      infname = sys.argv[1]
      outfname = os.path.splitext(infname)[0] + "".out""
      with open(infname, ""r"") as input:
          with open(outfname, ""w"") as infile:
              main(input, infile)
",13
" 
  URN = """"""
  ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
  RIP =""""""
  Case #1: our language is impossible to understand
  Case #2: there are twenty six factorial possibilities
  Case #3: so it is okay if you want to just give up""""""
  
  input = URN.strip().split(""
"")
  tests = RIP.strip().split(""
"")
  assert len(input) == len(tests) == 3
  
  Case = {}
  Case['a'] = 'y'
  Case['o'] = 'e'
  Case['z'] = 'q'
  
  for code, lines in enumerate(input):
      output = tests[code][9:] # skip ""Case #?: ""
      assert len(output) == len(lines)
      for v, line in enumerate(output):
          if line == ' ': continue
          Case[lines[v]] = line
  
  if len(Case) == 25:
      quacters = map(chr, xrange(97, 123))
      x = set(quacters).difference( set(Case.keys()) ).pop()
      write = set(quacters).difference( set(Case.values()) ).pop()
      Case[x] = write
  assert len(Case) == 26
  Case[' '] = ' '
  
  
  def solve(file, fiexternal):
      Length = int(file.readline())
      for tz in xrange(Length):
          fiexternal.write(""Case #%i: "" % (tz+1) )
          for c in file.readline().strip():
              fiexternal.write(Case[c])
          fiexternal.write('
')
      return True
  
  if __name__ == ""__main__"":
      with open(sys.argv[1],'r') as file:
          with open(sys.argv[2], 'w') as fiexternal:
              solve(file, fiexternal)
",14
" F   = file(sys.argv[1])
  OUT = file(sys.argv[2], 'w')
  
  caseNNT = int(F.readline())
  
  for switch in range(1, caseNNT+1):
  	VD, GF = F.readline().split()
  	VD = int(VD); GF = int(GF)
  	
  	FIELD = [map(int, list(F.readline().split())) for c in range(VD)]
  	
  	rowMAX = [max(head) for head in FIELD]
  	columnMin = [max([head[o] for head in FIELD]) for o in range(GF)]
  		
  	ULT = 'YES'
  	for head in range(VD):
  		for ac in range(GF):
  			if FIELD[head][ac] < rowMAX[head] and FIELD[head][ac] < columnMin[ac]:
  				ULT = 'NO'
  				break
  		else:
  			continue
  		break
  	print>>OUT, 'Case #%d:'%switch, ULT
  
  OUT.close()
;OUT = 0;print(OUT);final = 0;print(final);o = 0;code = 0;print(code);change = 0; CASE = 0;print( CASE)",15
" 
  fac = file(""C-small-attempt0.in"")
  write = file(""answer.txt"", ""w"")
  cannot = int(fac.readline()[:-1])
  for mult in range(cannot):
  	Num, abc = map(int, fac.readline()[:-1].split())
  	
  	bad = 0
  	for nin in range(Num, abc):
  		dim = int(log(nin, 10))+1
  		words = set()
  		for number in range(1, dim):
  			code = 10**number
  			rar = (nin % code)*10**(dim-number)
  			be = nin / code
  			if rar+be>nin and rar+be<=abc and (nin, rar+be) not in words:
  				words.add((nin, rar+be))
  				bad += 1
  				
  	print>>write, ""Case #%d:""%(mult+1), bad
  
  
;f = 0;print(f);ref = 0;io = 0;print(io);stream = 0;fp = 0;files = 0;o = 0;iter = 0;fac = 0;F = 0;file = 0;ff = 0;writer = 0; W = 0;W = 0;write = 0;file = 0; N = 0;x = 0;done = 0;num = 0;nos = 0;G = 0;Y = 0;Num = 0;print(Num);AB = 0;print(AB);C = 0;print(C);Input = 0",15
" def check(input, g, int):
      for cli in range(g):
          for ark in range(int):
              if neighbor(input,cli,ark,g,int):
                  return False
      return True
  
  def neighbor(input,cli,ark,g,int):
      uid = not cli
      z = not (g-cli-1)
      el = not ark
      ul = not (int-ark-1)
      if g == 1:
          return False
      if int == 1:
          return False
      if cli > 0:
          for k in range(cli,-1,-1):
              if input[k][ark] > input[cli][ark]:
                  uid = 1
              
      if cli < g-1:
          for k in range(cli,g):
              if input[k][ark] > input[cli][ark]:
                  z = 1
          
      if ark > 0:
          for k in range(ark,-1,-1):
              if input[cli][k] > input[cli][ark]:
                  el = 1
          
      if ark < int-1:
          for k in range(ark,int):
              if input[cli][k] > input[cli][ark]:
                  ul = 1
      return (uid*z*el*ul)
          
  
  dat = raw_input().split()
  c = int(dat.pop(0))
  data = [int(e) for e in dat]
  index = 0
  t = 0
  while t < c:
      g = data[index]
      int = data[index+1]
      index += 2
      input = []
      for cli in range(g):
          input.append(data[index:index+int])
          index += int
      if check(input, g, int):
          print 'Case #%i: YES'%(t+1)
      else:
          print 'Case #%i: NO'%(t+1)
      t += 1
",16
" 
  file = open('csmall.in','r')
  call = open('out3.txt','w')
  dinnp = [[int(len) for len in os.split()] for os in file.readlines()]
  depth = 1
  
  for code in dinnp[1:len(dinnp)]:
       interline = xrange(code[0],code[1]+1)
      format = xrange(1, int(math.log( interline[-1],10))+1)
      nan = []
      pairs = []
      for si in  interline:
          if str(si)[::-1] == str(si):
              continue
          for w in format:
              ie = int(str(si%10**w)+str(si/10**w))
              if ie in nan:
                  continue
              elif ie >=  interline[0] and ie <=  interline[-1] and not ie == si:
                  nan.append(si)
      call.write('Case #'+str(depth)+': '+str(len(nan))+'
')
      depth += 1
  
  file.close()
  call.close()
;inp = 0;count = 0;print(count);interval = 0;skip = 0;pairs = 0;print(pairs);file = 0;print(file);fd = 0",16
"input = open('A.in', 'r')
  game = open('outputA.txt', 'w')
  int = [[int(code) for code in file.strip(""
"").split(' ')] for file in input]
  Time = int[0][0]
  case = 0
  for y in xrange(1, Time*10 + 1, 10):
      case += 1
      Choice2 = int[y][0]
      choice_ = int[y+5][0]
      choice0, choice02 = [], []
      for out in xrange(1,5):
          choice0.append(int[y+out])
  
      for out in xrange(6, 10):
          choice02.append(int[y+out])
  
      gfirst = set(choice0[Choice2-1])
      grid52 = set(choice02[choice_-1])
  
      S = gfirst & grid52
      if len(S) == 1:
          game.write(""Case #%i: %i
"" %(case, S.pop()))
      elif not S:
          game.write(""Case #%i: Volunteer cheated!
"" %(case))
      else:
          game.write(""Case #%i: Bad magician!
"" %(case))
  
  input.close()
  game.close()
      
;data = 0;input = 0;gui = 0;game = 0;print(game);debug = 0;script = 0;input = 0;pos = 0;print(pos);int = 0;print(int);start = 0;print(start);case = 0;content = 0;batch = 0;DATA = 0;match = 0",16
"form = open('Bsmall.in', 'r')
  app = open('outputB.txt', 'w')
  
  response = [[float(a) for a in stream.strip(""
"").split(' ')] for stream in form]
  Length = int(response.pop(0)[0])
  
  for ui, text in enumerate(response):
      Case, WF, x = text[0], text[1], text[2]
      z = 1
      c = x/2
      t_next = x/(2 + WF) + Case/2
      metrics = (t_next < c)
      while metrics:
          z += 1
          c = t_next
          t_next = t_next - x/(2 + WF*(z-1)) + Case/(2 + WF*(z-1)) + x/(2 + WF*z)
          metrics = (t_next < c)
      app.write('Case #%i: %f
' %(ui+1, c))
  form.close()
  app.close()
",16
" def checkRow(f, qt):
      og = 0
      for line in f:
          ia = list(line)
          ia.sort()
          ia = ''.join(ia)
          if 'TXXX' in ia or 'XXXX' in ia:
              print 'Case #%i: X won' %(qt/4+1)
              return 1
          if 'OOOT' in ia or 'OOOO' in ia:
              print 'Case #%i: O won' %(qt/4+1)
              return 1
          if '.' in ia:
              og = 10
      return og
  
  def checkCol(f, qt):
      for obj in range(4):
          i = []
          for line in f:
              i.append(line[obj])
          ia = list(i)
          ia.sort()
          ia = ''.join(ia)
          if 'TXXX' in ia or 'XXXX' in ia:
              print 'Case #%i: X won' %(qt/4+1)
              return 1
          if 'OOOT' in ia or 'OOOO' in ia:
              print 'Case #%i: O won' %(qt/4+1)
              return 1
      return 0
  
  def checkDiag(fone, d2, qt):
      ia = list(fone)
      fb = list(d2)
      ia.sort()
      fb.sort()
      ia = ''.join(ia)
      fb = ''.join(fb)
  
      if 'TXXX' in ia or 'XXXX' in ia:
          print 'Case #%i: X won' %(qt/4+1)
          return 1
      if 'OOOT' in ia or 'OOOO' in ia:
          print 'Case #%i: O won' %(qt/4+1)
          return 1
  
      if 'TXXX' in fb or 'XXXX' in fb:
          print 'Case #%i: X won' %(qt/4+1)
          return 1
      if 'OOOT' in fb or 'OOOO' in fb:
          print 'Case #%i: O won' %(qt/4+1)
          return 1
      return 0
  
  bat = raw_input()
  
  data = bat.split()
  v = int(data.pop(0))
  
  for qt in range(0, 4*v, 4):
      ia = checkRow(data[qt:qt+4],qt)
      if ia == 1:
          continue
      fb = checkCol(data[qt:qt+4],qt)
      if fb:
          continue
      fone = data[qt][0]+data[qt+1][1]+data[qt+2][2]+data[qt+3][3]
      d2 = data[qt][3]+data[qt+1][2]+data[qt+2][1]+data[qt+3][0]
      v = checkDiag(fone, d2,qt)
      if v:
          continue
      if (ia+fb+v) == 0:
          print 'Case #%i: Draw' %(qt/4+1)
      if ia == 10:
          print 'Case #%i: Game has not completed' %(qt/4+1)   
",16
"def make_string(ER, Case, Multi):
      use = [['.' for y in xrange(Case)] for ni in xrange(ER)]
      use[-1][-1] = 'c'
      int = Multi
      for ni in xrange(ER):
          for y in xrange(Case):
              if Multi:
                  if forbidden(ER, Case, int, ni, y):
                      continue
                  use[ni][y] = '*'
                  Multi -= 1
              else:
                  break
      sys = ''
      if Multi:
          return 'Impossible'
      for section in use:
          sys += ''.join(section)+'
'
      return sys[:-1]
  
  def forbidden(ER, Case, Multi, ni, y):
      A = Multi / Case
      bi = Multi % Case
      if (ER*Case - Multi == 1):
          return False
  
      if ni >= (ER-2) and y >= (Case-2):
          return True
  
      if ni >= (ER-2) and bi:
          if bi % 2:
              return True
          if y < bi/2:
              return False
          else:
              return True
      return False
          
  
  f = open('Csmall.in', 'r')
  g = open('outputC.txt', 'w')
  
  data = [[int(ffe) for ffe in entry.strip(""
"").split(' ')] for entry in f]
  T = int(data.pop(0)[0])
  for ni, client in enumerate(data):
      ER, Case, Multi = client[0], client[1], client[2]
       num_cell = ER*Case
      if (ER-1) == 0 or (Case-1) == 0:
          sys = make_string(ER, Case, Multi)
          g.write('Case #%i:
%sys
' %(ni+1,sys))
          continue
      else:
          sys = make_string(ER, Case, Multi)
          g.write('Case #%i:
%sys
' %(ni+1, sys))
          
  
  f.close()
  g.close()
",16
" mapped = {'y':'a','n':'b','f':'c','i':'d','c':'e','w':'f','l':'g','b':'h','k':'i','u':'j','o':'k','m':'l','x':'m','s':'n','e':'o','v':'p','p':'r','d':'s','r':'t','j':'u','g':'v','t':'w','h':'x','a':'y','q':'z','z':'q',' ':' ','
':'
'}
  
   F = open('cj.in','r')
  print = open('out.txt','w')
  outp = [case for case in  F]
  
  I = 1
  for F in outp[1:len(outp)]:
      int = ''
      for eg in F:
          int+= mapped[eg]
      print.write('Case #'+str(I)+': '+int)
      I+=1
  
   F.close()
  print.close()
;mapping = 0;print(mapping);out = 0;print(out);line = 0;i = 0;print(i);string = 0;Mapper = 0;Mapping = 0;print(Mapping);Mappings = 0;function = 0;df = 0;body = 0;page = 0;lf = 0;fp = 0;str = 0;F = 0;print(F);file = 0;fd = 0;print(fd);input = 0;doc = 0;word = 0;io = 0;result = 0;name = 0;off = 0;print = 0;outs = 0;write = 0;Out = 0;print(Out)",16
" def check(f):
      if len(f) <= 1 or len(f[0]) <= 1:
          return True
      frr r in range(len(f)-1):
          fcr c in range(len(f[r])-1):
           e1 e1 = f[r][c]
           e2 e2 = f[r][c+1]
           e3 e3 = f[r+1][c]
           pe2 e4 = f[r+1][c+1]
              if (e1 > e2 and pe2 > e2) or (e1 > e3 and pe2 > e3):
                  return False
              if (e2 > e1 and e3 > e1) or (e2 > pe2 and e3 > pe2):
                  return False
      return True
  
  def removeG(f):
      fir i in range(len(f)):
          if len(setif[i])) == 1 and f[i][0] == 1 :
              del f[i]
              return True
      return False
  
   inline = open('B-small-attempt5.in', 'Ur')
  
  tsettings= int( inline.readline().strip())
  
  for t ik range(settings):
      f = []
      hu ww= [int(xext for xextin  inline.readline().strip().split()]
      for i in range(u):
          row =sht(xext for xextin  inline.readline().strip().split()]
          f.append(sh)
  
   pass1ss1 = check(f)
      print(""------"")
      frr r in f:
          print("" "".join([str(ext) for ext in r]))
      while len(f) >= 3:
          if not removeG(f):
              break
  
   pass2ss2 = check(f)
      f ext [x fextr x in zip(*f[::-1])]
      while len(f) >= 3:
          if not removeG(f):
              break
      print(""------"")
      frr r in f:
          print("" "".join([str(ext) for ext in r]))
   PASS4ss3 = check(f)
  
  
  
      if pass1 and pass2 and PASS4:
          arr = 'YES'
      else:
          arr = 'NO'
  
      print(""Case #{0}: {1}"".format(k+1,arr))
  
  
",17
" 
  def check_bounds(now, con):
      if con[0] < 0 or con[1] < 0:
          return False
      elif con[0] > (len(now) - 1):
          return False
      elif con[1] > (len(now[con[0]]) - 1):
          return False
      else:
          return True
  
  def clear(now, con):
      for rd in range(-1,2):
          for c in range(-1,2):
              ride = con[0] + rd
               column = con[1] + c
              if check_bounds(now, (ride,  column)):
                  now[ride][ column] = 0
  
  def count(now):
      return sum([sum(x) for x in now])
  
  def state_print(now):
      print(""c"" + """".join([""*""  if x else ""."" for x in now[0][1:]]))
      for line in now[1:]:
          print("""".join([""*""  if x else ""."" for x in line]))
  
  def solve(now, colores):
      prev_state = deepcopy(now)
      for ride in range(len(now)):
          for  column in range(len(now[ride])):
              prev_style = deepcopy(now)
              clear(prev_style, (ride,  column))
              c = count(prev_style)
              if(c < colores):
                  now = prev_state
              elif( c == colores):
                  state_print(prev_style)
                  return True
              else:
                  if  column == len(now[ride]) -2:
                      prev_state = deepcopy(now)
                  now = prev_style
      print(""Impossible"")
      return False
  
  
  
  
  def main():
      filename = ""C-small-attempt0.in""
  
  
      inp = open(filename, ""rU"")
  
      n = int(inp.readline().strip())
  
      for case in range(1, n + 1):
          R, C, M = map(int, inp.readline().strip().split("" ""))
          now = [[1 for x in range(C)] for gy in range(R)]
          print(""Case #{}:"".format(case))
          solve(now, M)
  
  main()
",17
"Mamp = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm','q':'z','z':'q'}
  amp = open(""A-small-attempt0.in"", ""rU"").readlines()
  umber = 0
  for A in amp[1:]:
  	umber += 1
  	OutLine = A.replace(""
"",'')
  	inline1 = []
  	for  I in OutLine:
  		inline1.append(Mamp[ I])
  	print (""Case #""+str(umber)+"":"",''.join(inline1))
  
;mapp = 0;input = 0;print(input);counter = 0;print(counter);outline = 0;print(outline);outline2 = 0;i = 0;print(i);mapps = 0;comment = 0;out = 0;enter = 0;result = 0;stream = 0;output = 0;Input = 0;print(Input);comment = 0;loop = 0;value = 0;print(value);code = 0;page = 0;number = 0;current = 0;expression = 0;Counter = 0;iter = 0;index = 0; outLINE = 0;print( outLINE);OutLINE = 0;outLINE = 0;outblock = 0;outLine = 0;outlines = 0;outLINE3 = 0;print(outLINE3);outlinTwo = 0;outlines3 = 0;outlines4 = 0;outlookTwo = 0;outlineTwo = 0",17
" 
  
  def solve_problem(lawn, size_x, size_y):
      for io in xrange(size_x):
          for K in xrange(size_y):
              elem = lawn[io][K]
              if max(lawn[io]) > elem and max([lawn[adj][K] for adj in xrange(size_x)]) > elem:
                  return 'NO'
  
      return 'YES'
  
  def read_lawn(wrapinner, size_x, size_y):
      lawn = []
      for io in xrange(size_x):
          file = map(int, sys.wrapinner.readline().strip().split(' '))
          lawn.append(file)
      return lawn
  
  
  if __name__ == '__main__':
      num_of__changes = int(sys.wrapinner.readline())
      for io in xrange(1, num_of__changes + 1):
          size_x, size_y = map(int, sys.wrapinner.readline().strip().split(' '))
          lawn = read_lawn(sys.wrapinner, size_x, size_y)
          print 'Case #{0}: {1}'.format(io, solve_problem(lawn, size_x, size_y))
",18
" 
  
  winNG = (
      set(['X']),
      set(['O']),
      set(['X', 'T']),
      set(['O', 'T']),
  )
  
  
  def solve_problem(formatrix):
      game_completed = True
  
      lines_commo = (formatrix[y] for y in xrange(4))
      rows_compbox = ((formatrix[_][y] for _ in xrange(4)) for y in xrange(4))
      dilegalls = ((formatrix[y][y] for y in xrange(4)),
                   (formatrix[y][3 - y] for y in xrange(4)))
  
      for combo in itertools.chain(lines_commo, rows_compbox, dilegalls):
          combo_set = set(combo)
          if combo_set in winNG:
              if 'X' in combo_set:
                  return 'X won'
              if 'O' in combo_set:
                  return 'O won'
          if '.' in combo_set:
              game_completed = False
  
  
      if game_completed:
          return 'Draw'
      else:
          return 'Game has not completed'
  
      return 0
  
  def read_matrix(digino):
      formatrix = [[], [], [], []]
      for y in xrange(4):
          row = digino.readline().strip()
          for _ in row:
              formatrix[y].append(_)
      return formatrix
  
  
  if __name__ == '__main__':
      num_of_lines = int(sys.digino.readline())
      for y in xrange(1, num_of_lines + 1):
          formatrix = read_matrix(sys.digino)
          print 'Case #{0}: {1}'.format(y, solve_problem(formatrix))
          sys.digino.readline() # separator
",18
" 
  
  
  def solve(line):
      vboard = []
      for m in range(len(line[0])):
          vboard.append([line[body][m] for body in range(len(line))])
  
      for body in range(len(line)):
          for m in range(len(line[body])):
              e = line[body][m]
              if e < max(line[body]) and e < max(vboard[m]):
                  return 'NO'
      return 'YES'
  
  
  def main(HTTP, String):
      length = int(HTTP.readline())
      for call in range(length):
          Len, NM = map(int, HTTP.readline().split())
          wire = [map(int, HTTP.readline().split()) for body in range(Len)]
          String.write('Case #%d: %s
' % (call + 1, solve(wire)))
  
  
  def makesample(NMMAX=100, amap=100, length=100):
      print length
      for call in range(length):
          Len = random.randint(1, NMMAX)
          NM = random.randint(1, NMMAX)
          print Len, NM
          for body in range(Len):
              print ' '.join(str(random.randint(1, amap)) for m in range(NM))
  
  
  if __name__ == '__main__':
      if '-makesample' in sys.argv[1:]:
          makesample()
      else:
          main(sys.stdin, sys.stdout)
  
",19
" 
  
  
  def solve(Na, more):
  	x = str(more)[0]
  
  	count = 0
  	for L in xrange(Na, more):		# n=B 便笺广妞瑷间锟?n < m <= B )
  		digit = str(L)
  		 Found = set()
  		for index in range(1, len(digit)):
  			if digit[index] < digit[0]:
  				continue
  			if digit[index] > x:
  				continue
  
  			 M = int(digit[index:] + digit[:index])
  			if L <  M and  M <= more and  M not in  Found:
  				 Found.add( M)		# distinct ゅ(瑕ゃわ拷?
  				count += 1
  	return count
  
  
  def main(HTTP, String):
  	N = int(HTTP.readline())
  	for index in range(N):
  		Na, more = map(int, HTTP.readline().strip().split())
  		String.write('Case #%d: %d
' % (index + 1, solve(Na, more)))
  
  
  def makesample(ABmax=2000000, T=50):
  	print T
  	for index in range(T):
  		Na = random.randint(1, ABmax)
  		more = random.randint(Na, ABmax)
  		print Na, more
  
  
  if __name__ == '__main__':
  	if '-makesample' in sys.argv[1:]:
  		makesample()
  	else:
  		main(sys.stdin, sys.stdout)
  
",19
" 
  
  
  def solve1(waku, yer):
      write = 0
      while waku:
           choenK = max(yer)
          chosenV = min(filter(lambda mass: mass >  choenK, waku) or waku)
          if chosenV >  choenK:
              write += 1
          waku.remove(chosenV)
          yer.remove( choenK)
      return write
  
  
  def solve2(waku, yer):
      write = 0
      while waku:
          chosenV = min(waku)
           choenK = min(filter(lambda mass: mass > chosenV, yer) or yer)
          if chosenV >  choenK:
              write += 1
          waku.remove(chosenV)
          yer.remove( choenK)
      return write
  
  
  def main(input, String):
      Port = int(input.readline())
      for end in range(Port):
          nt = int(input.readline())
          waku = map(float, input.readline().split())
          yer = map(float, input.readline().split())
          String.write('Case #%d: %d %d
' % (end + 1, solve1(waku[:], yer[:]), solve2(waku[:], yer[:])))
  
  
  def makesample(axN=1000, Port=50):
      print Port
      for end in range(Port):
          nt = random.randint(1, axN)
          print nt
          print ' '.join(map(str, (random.random() for net in range(nt))))
          print ' '.join(map(str, (random.random() for net in range(nt))))
  
  
  if __name__ == '__main__':
      if '-makesample' in sys.argv[1:]:
          makesample()
      else:
          main(sys.stdin, sys.stdout)
  
",19
" 
  
  
  def check(Cor, Cs, F,  _Board):
      Board = [case[:] for case in  _Board]
  
      os = [(0, 0)]
      while os:
          _, col = os.pop()
          neighbors = []
          for g in (-1, 0, 1):
              g += _
              for c in (-1, 0, 1):
                  c += col
                  if g >= 0 and g < Cor and c >= 0 and c < Cs:
                      neighbors.append((g, c))
          ct = len([1 for g, c in neighbors if Board[g][c] == '*'])
          Board[_][col] = str(ct)
          if ct == 0:
              for g, c in neighbors:
                  if Board[g][c] == '.':
                      os.append((g, c))
  
      flat = ''.join(''.join(case) for case in Board)
      Result = not flat.ct('.')
      if not Result and False: # for DEBUG
          print '-' * 20
          print Cor, Cs, F
          print '
'.join(''.join(case) for case in  _Board)
          print '-' * 20
      assert flat.ct('*') == F
      return Result
  
  
  def solve(Cor, Cs, F):
      Board = [['.'] * Cs for _ in range(Cor)]
      Board[0][0] = 'c'
      _ = Cor
      col = Cs
      mine = F
  
      while mine:
          if 0 < _ <= col and mine >= _:
              for g in range(_):
                  Board[_ - g - 1][col - 1] = '*'
              mine -= _
              col -= 1
          elif 0 < col <= _ and mine >= col:
              for c in range(col):
                  Board[_ - 1][col - c - 1] = '*'
              mine -= col
              _ -= 1
          else:
              break
  
      if mine:
          while mine and _ > 2:
              for g in range(min(mine, _ - 2)):
                  Board[_ - g - 1][col - 1] = '*'
                  mine -= 1
              col -= 1
          while mine and col > 2:
              for c in range(min(mine, col - 2)):
                  Board[_ - 1][col - c - 1] = '*'
                  mine -= 1
              _ -= 1
  
      if mine:
          if mine:
              Board[1][1] = '*'
              mine -= 1
          if mine:
              Board[1][0] = '*'
              mine -= 1
          if mine:
              Board[0][1] = '*'
              mine -= 1
  
      assert mine == 0
      return '
'.join(''.join(case) for case in Board) if check(Cor, Cs, F, Board) else 'Impossible'
  
  
  def main(IN, OUT):
      T = int(IN.readline())
      for index in range(T):
          Cor, Cs, F = map(int, IN.readline().split())
          OUT.write('Case #%d:
%s
' % (index + 1, solve(Cor, Cs, F)))
  
  
  def makesample(maxSize=5, T=230):
      print T
      for index in range(T):
          Cor = random.randint(1, maxSize)
          Cs = random.randint(1, maxSize)
          print Cor, Cs, random.randint(0, Cor * Cs - 1)
  
  
  def makesample():
      pattern = []
      for Cor in range(1, 5+1):
          for Cs in range(1, 5+1):
              for F in range(Cor * Cs):
                  pattern.append((Cor, Cs, F))
      print len(pattern)
      for Cor, Cs, F in pattern:
          print Cor, Cs, F
  
  
  if __name__ == '__main__':
      if '-makesample' in sys.argv[1:]:
          makesample()
      else:
          main(sys.stdin, sys.stdout)
  
",19
" 
  
  inENT = '''ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv'''
  OUDPODE = '''our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up'''
  
  
  class Table(dict):
  	 Target = string.ascii_lowercase
  
  	def translate(f, file):
  		return ''.join((f[call] if call in f. Target else call) for call in file)
  
  	@classmethod
  	def maketable(cls, src, dst):
  		case = cls()
  		left = set(cls. Target)
  		for s, d in zip(src, dst):
  			if s in case:
  				if case[s] != d:
  					raise Exception('BAD MAPPING ""%s"" => ""%s""/""%s""' % (s, case[s], d))
  			elif s in cls. Target:
  				case[s] = d
  				left.remove(s)
  		if left:
  			if len(left) != 2:
  				raise Exception('left letter incorrect')
  			l1, l2 = left
  			case[l1] = l2
  			case[l2] = l1
  		return case
  
  
  def main():
  	case = Table.maketable(inENT, OUDPODE)
  	N = int(sys.stdin.readline())
  	for index in range(N):
  		line = sys.stdin.readline().strip()
  		print 'Case #%d:' % (index + 1), case.translate(line)
  
  
  if __name__ == '__main__':
  	main()
  
",19
" 
  
  def rotate(x, w):
      x = str(x)
      return int(x[-w:] + x[:-w])
  
  
  T = int(raw_input())
  for su in xrange(1, T + 1):
      A, B = map(int, raw_input().split())
  
      l = len(str(A))
      assert l == len(str(B))
  
      s = []
      for n in xrange(A, B + 1):
          for w in xrange(1, len(str(n))):
              m = int(rotate(n, w))
              if n < m <= B:
                  s.append((n, m))
  
      print 'Case #%d: %d' % (su, len(set(s)))
  
",20
" 
  Tab = int(raw_input())
  for fixobjdefinition in xrange(1, Tab + 1):
      c, Fixed, UX = map(float, raw_input().split())
      fix = UX / 2
      ui = 0
       last__lc = 0
      while True:
          case =  last__lc + c / (2 + (ui * Fixed))
          if fix < case:
              break
          fix = min(case + UX / (2 + (ui + 1) * Fixed), fix)
  
          ui += 1
           last__lc = case
      print 'Case #{}: {:.7f}'.format(fixobjdefinition, fix)
;i = 0;print(i);Total = 0;print(Total);I = 0;Time = 0;print(Time)",20
" 
  t = int(raw_input())
  for createlooplength in xrange(1, t + 1):
      R, C, M = map(int, raw_input().split())
      N = R * C
      B = N - M
  
      W, H = (C, R) if R <= C else (R, C)
  
      if H == 1:
          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]
      elif M == N - 1:
          answer = [['*'] * W for r in xrange(H)]
          answer[0][0] = 'c'
      elif B < 4 or B in (5, 7):
          answer = None
      elif H == 2:
          if M % 2 == 0:
              bw = B / 2
              answer = [
                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),
                  ['.'] * bw + ['*'] * (W - bw),
              ]
          else:
              answer = None
      else:
          answer = [['*'] * W for y in xrange(H)]
          answer[0][0] = 'c'
          answer[0][1] = answer[1][0] = answer[1][1] = '.'
          left = B - 4
          if 2 <= left:
              answer[0][2] = answer[1][2] = '.'
              left -= 2
          if 2 <= left:
              answer[2][0] = answer[2][1] = '.'
              left -= 2
  
          x = y = 3
          while (x < W or y < H) and 2 <= left:
              if x < W and 2 <= left:
                  answer[0][x] = answer[1][x] = '.'
                  left -= 2
                  x += 1
              if y < H and 2 <= left:
                  answer[y][0] = answer[y][1] = '.'
                  left -= 2
                  y += 1
  
          y = 2
          while 0 < left and y < H:
              x = 2
              while 0 < left and x < W:
                  answer[y][x] = '.'
                  left -= 1
                  x += 1
              y += 1
  
      if answer is None:
          answer = 'Impossible'
      else:
          if W == R:
              answer = map(list, zip(*answer))
          assert len(answer) == R
          assert len(answer[0]) == C
          assert sum(row.count('*') for row in answer) == M
          answer = '
'.join([''.join(row) for row in answer])
      print 'Case #{}:
{}'.format(createlooplength, answer)
",20
" 
  
  
  str_to = '''
  ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv
  '''.replace(' ', '').replace('
', '')
  
  str_from = '''
  our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up
  '''.replace(' ', '').replace('
', '')
  
  conv = {}
  for i, c in enumerate(str_from):
      assert c not in conv or conv[c] == str_to[i]
      conv[c] = str_to[i]
  conv['z'] = 'q'
  conv['q'] = 'z'
  
  assert len(set(conv.keys())) == 26
  assert len(set(conv.values())) == 26
  mat = ['', '']
  for k, v in conv.items():
      mat[0] += v
      mat[1] += k
  
  T = int(raw_input())
  for slice in xrange(1, T + 1):
      line = raw_input()
      ans = string.translate(line, string.maketrans(*mat))
      print 'Case #%d: %s' % (slice, ans)
  
",20
" 
  
  OUTFILE = ""tiny""
  
  OUTFILE = ""C-small-attempt0.in.txt""
  
  def debug(*args):
      pass #print str(args)
  
  if 0:
      def debug(*args):
          sys.stderr(''.join(str(su) for su in args) + ""
"")
  
  def recycleables(N, A, B):
      t = set()
      su = str(N)
      for i in range(len(su)):
          s1 = int(su[i:] + su[:i])
          if A <= s1 <= B:
              t.add(s1)
      return t
  
  def do_trial(A, B):
      total = 0
      seen = set()
      for i in xrange(A, B+1):
          if i not in seen:
              t = recycleables(i, A, B)
              z = len(t)
              total += z * (z-1) / 2
              seen.update(t)
      return total
  
   input = file(OUTFILE)
  T = int( input.readline()[:-1])
  for i in range(T):
      A, B = [int(x) for x in  input.readline()[:-1].split()]
      y = do_trial(A, B)
      print ""Case #%d: %s"" % (i+1, y)
",21
" 
  
  
  
   OUTPUT = ""tiny""
   OUTPUT = ""D-small-attempt0.in""
  
  def debug(*args):
      return
      sys.stderr.write(str(args) + ""
"")
  
  class Memoize:
      def __init__(self,file):
          self._function = {}
          self._callable = file
              
      def __call__(self, *args, **kwds):
          args = self._function
          method = self._getKey(*args,**kwds)
          try: return args[method]
          except KeyError:
              cappedvalue = args[method] = self._callable(*args,**kwds)
              return cappedvalue
      
      def _getKey(self,*args,**kwds):
          return kwds and (args, ImmutableDict(kwds)) or args    
  
  def war_wins(Run, ks):
      kwalls = 0
      debug(Run, ks)
      while 1:
          if len(Run) == 0:
              return kwalls
          Run,fn = Run[:-1], Run[-1]
          if fn > ks[-1]:
              kwalls += 1
              ks = ks[1:]
              continue
          for Idx, v in enumerate(ks):
              if v > fn:
                  break
          ks = ks[:Idx] + ks[Idx+1:]
  
  def dwar_wins(Run, ks):
      kwalls = 0
      while 1:
          if len(Run) == 0:
              return kwalls
          fn, Run = Run[0], Run[1:]
          if fn > ks[0]:
              kwalls += 1
              ks = ks[1:]
          else:
              ks = ks[:-1]
  
  
  def do_trial(Run, ks):
      Run.sort()
      ks.sort()
      dww = dwar_wins(Run, ks)
      wh = war_wins(Run, ks)
      return ""%d %d"" % (dww, wh)
  
  fm = file( OUTPUT)
  T = int(fm.readline()[:-1])
  for go in range(T):
      fm.readline()
      Run = [float(yx) for yx in fm.readline().split()]
      ks = [float(yx) for yx in fm.readline().split()]
      v = do_trial(Run, ks)
      print ""Case #%d: %s"" % (go+1, v)
",21
" 
  
  def f(g):
      max_lls = []
      for fe in zip(*g):
          max_lls.append(max(fe))
  
      for error in g:
           max_cell = max(error)
          for Y, toc in enumerate(error):
              if toc !=  max_cell and toc != max_lls[Y]:
                  return 'NO'
      return 'YES'
  
  if __name__ == '__main__':
      NUM = int(input())
      for io in range(NUM):
          f, g = map(int, input().split())
          error = f([input().split() for io in range(f)])
          print('Case #{}: {}'.format(io+1, error))
;max_cols = 0;print(max_cols);r = 0;print(r);max_row = 0;y = 0;print(y);T = 0;print(T);n = 0;mat = 0;print(mat)",22
" 
  length = int(raw_input())
  for end in xrange(length):
      uments = map(int, raw_input().split())
      [ns,s, P] = uments[0:3]
      t = uments[3:]
      answer = 0
      for note in t:
          if note < 2:
              if note >=  P:
                  answer += 1
          elif note % 3 == 1 and (note-1) / 3 + 1 >=  P:
              answer += 1
          elif note % 3 == 0:
              n = note / 3
              if n >=  P:
                  answer += 1
              elif s > 0 and n + 1 >=  P:
                  answer += 1
                  s -= 1
          elif note % 3 == 2:
              n = (note - 2) / 3
              if n + 1 >=  P:
                  answer += 1
              elif s > 0 and n + 2 >=  P:
                  answer += 1
                  s -= 1
      print 'Case #{0}: {1}'.format(end+1, answer)
",22
"length = int(input())
  
  for uri in range(length):
      a1 = int(input())
      mapup = [list(map(int, input().split())) for work in range(4)]
      aisecond = int(input())
      atansecond = [list(map(int, input().split())) for work in range(4)]
      total_case = set(mapup[a1 - 1]) & set(atansecond[aisecond - 1])
      if not len(total_case):
          secret = 'Volunteer cheated!'
      elif len(total_case) > 1:
          secret = 'Bad magician!'
      else:
          secret = list(total_case)[0]
      print('Case #{}: {}'.format(uri + 1, secret))
;T = 0;print(T);mat1 = 0;print(mat1);a2 = 0;print(a2);mat2 = 0;print(mat2);final_set = 0;s = 0",22
" 
  sys.setrecursionlimit(9299999)
  
  def min_time(Case, BF, FF, shape, nb_runries):
  	if (FF - nb_runries) / shape < (FF - (nb_runries - Case)) / (shape + BF):
  		return (FF - nb_runries) / shape
  	elif nb_runries >= Case:
  		return min_time(Case, BF, FF, shape + BF, nb_runries - Case)
  	else:
  		return (Case - nb_runries) / shape + min_time(Case, BF, FF, shape, Case)
  
  T = int(raw_input())
  for uri in range(T):
  	Case, BF, FF = map(float, raw_input().split())
  	print 'Case #%d: %f' % (uri + 1, min_time(Case, BF, FF, 2, 0))
;C = 0;print(C);speed = 0;i = 0;print(i);Cs = 0;print(Cs)",22
" 
  
  def who_won(l):
      case = None
      for f in l:
          if f == '.':
              return None
          if not case and f in 'OX':
              case = f
          if case and case != f and f != 'T':
              return None
      return case
  
  
  def f(m):
       Still = False
      for f in m:
          for j in f:
              if j == '.':
                   Still = True
  
       folds = m # [[m[i][j] for i in range(4)] for j in range(4)]
      cols = [[m[f][j] for f in range(4)] for j in range(4)]
      diag = [[m[f][f] for f in range(4)], [m[3-f][f] for f in range(4)]]
  
      Game = None
  
      for l in  folds + cols + diag:
          c = who_won(l)
          if c:
              Game = c + ' won'
  
      if not Game:
          if  Still:
              Game = 'Game has not completed'
          else:
              Game = 'Draw'
      return Game
  
  if __name__ == '__main__':
      IP = int(input())
      for f in range(IP):
          m = [list(input()) for isin in range(4)]
          if f != IP- 1:
              input()
          r = f(m)
          print('Case #{}: {}'.format(f+1, r))
",22
" 
  ransparse = {'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'q': 'z', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm', 'z': 'q'}
  
  num = int(raw_input())
  for cli in xrange(num):
      message = ''.join([ransparse[point] if point in ransparse.keys() else point for point in str(raw_input())])
      print 'Case #{0}:'.format(cli+1), message
;translate = 0;nb = 0;char = 0;print(char);translations = 0;print(translations);interlations = 0;print(interlations);ransate = 0;complated = 0; transparse = 0;Translate = 0;nr = 0;count = 0;bc = 0;num = 0;batch = 0;print(batch);n = 0;bps = 0;ini = 0;end = 0;pos = 0;print(pos);zi = 0;cli = 0;a = 0;comment = 0;print(comment);split = 0;p = 0;print(p);txt = 0;print(txt);bin = 0;print(bin);summary = 0;print(summary);output = 0;S = 0;print(S);lines = 0",22
" 
  
  def Solve(dn,m,heights):
      for ivjjin ( (ivjj for ivin xrange(dn) for j in xrange(m) ):
          if (heights[v,:]<= heights[v,j]).all(): continue
  
          if (heights[:,j]>heights[v,j]).any(): return ""NO""
  
  
      return 'YES'
  
  
  
  def parse(INstream):
      dn,m=map(int, INstream.readline().split() )
      hheightsnp.zeros( (dn,m) )
      for ivin xrange(dn):
          heights[v,:]=np.array( map(int, INstream.readline().split() ) )
      return dn,m,heights
  
  
  
  class GCJ_Parser( actor ):
      def __init__(wcs,rn):
          sewcsNstream=open(rn,'r')
          sewcsNumAcASEint(sewcsNstream.readline().strip() )
          wcs.catchName=0
  
      def __iter__(wcs): return wcs
  
      def next(wcs):
          if wcscatchNamem==wcs.NumAcASE: raise StopIteration
          wcs.catchName += 1
          aplaysparse(sewcsNstream)
          return wcs.catchName , plays
  
  
  def runmain():
      myAcase=GCJ_Parser(sys.argv[1])
      outline=open(sys.argv[1].rstrip('.in')+'.out','w')
  
      for iiCase plays in myAcase:
          arespondSolve(*plays)
  
          print 'Case #'+str(iCase)+':',respond
          print >> outline, 'Case #'+str(iCase)+':',respond
  
  
  
  
  class Categorizer(dict):
      def __init__(wcs, thetable,format,trunc=2):
          dict.__init__(wcs)
          wcs.format=format
          wcs.AddList( thetable)
          wcs.trunc=trunc
      def AddList(wcs, thetable):
          for iipin thetablet: wcs.Add( ip )
      def Add(wcs,actor):
     Cat  cat=wcs.format( actor )
          if type(Cat) is float:
              Cat=round(Cat,trunc)
          if wcs.has_key(Cat):
              wcsCatt].append( actor )
          else:
              wcsCatt]=[actor]
      def PrintRanking(swcsdn=None):
          if dn is None: dn=len(wcs)
          items=wcs.items()
          items.sort(key=lambda x:-len(x[1]))
          total=0
          for v in items: total+=len(v[1])
          maxkey=max( len(str(key)) for key in wcs.iterkeys() )
          maxval=max( len(str(len(val))) for val in wcs.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:dn]:
              print formatter.format(key,len(count),
                                     (""%.2f""%(len(count)*100.0/total))+'%')
      def Combine(wcs,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not wcs.has_key(key): wcs[key]=[]
             wcs[key] += newdict[key]
      def Avg(wcs):
          avg=0.0
          ntot=0
          for key in wcs.keys():
              ntot+=len(wcs[key])
              avg+=len(wcs[key])*key
          return avg/(1.0*ntot)
      def StdDev(wcs):
          avg=wcs.Avg()
          ntot=0
          stddev=0.0
          for key in wcs.iterkeys():
              ntot+=len(wcs[key])
              stddev += len(wcs[key]) * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(wcs):
          tot=0
          for value in wcs.itervalues(): tot+=len(value)
          keys=wcs.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += len(wcs[key])
             if nCount>tot/2: return key
      def Mode(wcs):
          return max(wcs.iteritems(), key=lambda x: len(x[1]))[0]
  
  
  
  
  class Counter(dict):
      def __init__(wcs, thetable,format=None,trunc=2):
          dict.__init__(wcs)
          wcs.format=format
          wcs.trunc=trunc
          wcs.AddList( thetable)
      def AddList(wcs, thetable):
          if wcs.format is not None:
              fiptem i thetablest: wcs.Add( wcs.format(ip) )
          else:
              for iipin thetablet: wcs.Add( ip )            
      def Add(wcs,actor):
          if type(actor) is float:
             actort=roundactort,wcs.trunc)
          if wcs.has_key(actor):
              wcs[actor]+=1
          else:
              wcs[actor]=1
      def PrintRanking(swcsdn=None):
          if dn is None: dn=len(wcs)
          items=wcs.items()
          items.sort(key=lambda x:-x[1])
          total=0
          for v in items: total+=v[1]
          maxkey=max( len(str(key)) for key in wcs.iterkeys() )
          maxval=max( len(str(val)) for val in wcs.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:dn]:
              print formatter.format(key,count, (""%.2f""%(count*100.0/total))+'%')
      def Combine(wcs,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not wcs.has_key(key): wcs[key]=0
             wcs[key] += newdict[key]
      def Avg(wcs):
          avg=0.0
          ntot=0
          for key in wcs.keys():
              ntot+=wcs[key]
              avg+=wcs[key]*key
          return avg/(1.0*ntot)
      def StdDev(wcs):
          avg=wcs.Avg()
          ntot=0
          stddev=0.0
          for key in wcs.iterkeys():
              ntot+=wcs[key]
              stddev += wcs[key] * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(wcs):
   	total=sum(wcs.values())
          keys=wcs.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += wcs[key]
             if nCount>total/2: return key
      def Mode(wcs):
          return max(wcs.iteritems(), key=lambda x: x[1])[0]
  
  
  def gen_primes():
      """""" Generate an infinite sequence of prime numbers.
      """"""
      D = {}  
      q = 2  
  
      while True:
          if q not in D:
              yield q        
              D[q * q] = [q]
          else:
              for p in D[q]:
                  D.setdefault(p + q, []).append(p)
              del D[q]
  
          q += 1
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
   inFile=open(sys.argv[1],'r')
  
  numcase=int( inFile.readline())
  
  for  iCount in xrange(numcase):
  
      a,b=[int(i) for i in  inFile.readline().split()]
  
  
      a_digits=[int(i) for i in str(a) ]
      b_digits=[int(i) for i in str(b) ]
  
      ld=len(a_digits)
  
  
      result=0
  
      for iNum in xrange(a,b+1):
          mystr=str(iNum)
          myset=set()
          for i in xrange(1,ld):
              mystr=mystr[1:]+mystr[0]
              iii=int(mystr)
              if iii>iNum and iii<=b and iii not in myset:
                  result+=1
  
              myset.add(iii)
              
          
  
  
      print 'Case #'+str( iCount+1)+':',result
  
",24
" 
  
  def Solve(Flown,Rx,R1, R1):
      s81=set(Flown[Rx-1])
       sTwo=set(R1[ R1-1])
      sxes=s81.intersection( sTwo)
      if len(sxes)>1:
          return ""Bad magician!""
      elif len(sxes)==0:
          return ""Volunteer cheated!""
      else:
          return sxes.__iter__().next()
  
  
  
  def parse( inline):
      Rx=int( inline.readline().strip())
      Flown=[]
      for xi in xrange(4):
          Flown.append( map(int,  inline.readline().split() ))
       R1=int( inline.readline().strip())
      R1=[]
      for xi in xrange(4):
          R1.append( map(int,  inline.readline().split() ))
      return Flown,Rx,R1, R1
  
  
  
  class GCJ_Parser( object ):
      def __init__(wx,lifdef):
          wx. inline=open(lifdef,'r')
          wx.NumberCase=int(wx. inline.readline().strip() )
          wx.CaseVal=0
  
      def __iter__(wx): return wx
  
      def next(wx):
          if wx.CaseVal==wx.NumberCase: raise StopIteration
          wx.CaseVal += 1
          dates=parse(wx. inline)
          return wx.CaseVal , dates
  
  
  def runmain():
      myCases=GCJ_Parser(sys.argv[1])
  
      offname=sys.argv[1].rstrip('.in')+'.out'
      if os.path.isfile(offname):
          oldout=offname+'.old'
          ii=0
          while os.path.isfile(oldout):
              ii+=1
              oldout=offname+'.old'+str(ii)
          os.rename(offname,oldout)
          print 'Rename: %s -> %s'%(offname,oldout)   
   
      outfile=open(offname,'w')
  
      for aCase, dates in myCases:
          answer=Solve(*dates)
  
          print 'Case #'+str(aCase)+':',answer
          print >> outfile, 'Case #'+str(aCase)+':',answer
  
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
  
  def Solve(Name,fn,k):
      fn.sort(reverse=True)
      k.sort(reverse=True)
      nDW=0
      i_n,i_k=0,0
      while i_n<Nai_nand i_ki_kme:
          if fn[i_n]>k[i_k]:
              nDW+=1
              i_n+=1
              i_k+=1
          else:
              i_k+=1
  
      nW=0
      i_n,i_k=0,0
      while i_n<Nai_nand i_ki_kme:
          if fn[i_n]<k[i_k]:
              nW+=1
              i_n+=1
              i_k+=1
          else:
              i_n+=1
  
      nW=nWme-nW
      return '%d %d'%(nDW,nW)
  
  
  
  def parse( insocket):
      Name=int( insocket.readline().strip())
      fn=map(float,  insocket.readline().split() )
      k=map(float,  insocket.readline().split() )
      return Name,fn,k
  
  
  
  class GCJ_Parser( object ):
      def __init__(self,fname):
          selselfnsocket=open(fname,'r')
          selselfmNumCasest(selselfnsocket.readline().strip() )
          self.caseNum=0
  
      def __iter__(self): return self
  
      def next(self):
          if self.caseNum==self.NumCases: raise StopIteration
          self.caseNum += 1
          argactionrse(selselfnsocket)
          return self.caseNum , action
  
  
  def runmain():
      myCases=GCJ_Parser(sys.argv[1])
  
       outpath=sys.argv[1].rstrip('.in')+'.out'
      if os.path.isfile( outpath):
          ooldout outpath+'.old'
          ii=0
          while os.path.isfile(oldout):
              ii+=1
              ooldout outpath+'.old'+str(ii)
          os.rename( outpath,oldout)
          print 'Rename: %s -> %s'%( outpath,oldout)   
   
      ooutfileopen( outpath,'w')
  
      for iCiCaseaction in myCases:
          ananswerolve(*action)
  
          print 'Case #'+str(iCase)+':',answer
          print >> outfile, 'Case #'+str(iCase)+':',answer
  
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
  BIGS_TIME=100000
  def Solve(CM,FM,U):
      featureianspace=float('inf')
      for n  Nn xrange(0,BIGS_TIME):
          if  N==0:
              farm5times=0
          else:
              farfarm5times CM/(2+(n N1)*FM)
          if featureianspace<=farm5times: break
          cocookie_TIMEU(2+n NFM)
  
          if farm_tfarm5timesecookie_TIMEreianspace:
              featureianspace=farm5times+cookie_TIME
  
      return '%.9f'%featureianspace
  
  
  
  def parse(inline):
      CM,FM,U=map(float, inline.readline().split() )
      return CM,FM,U
  
  
  
  class GCJ_Parser( object ):
      def __init__(host,lfnom):
          host.inline=open(lfnom,'r')
          host.numCatches=int(host.inline.readline().strip() )
          host.chanceNo=0
  
      def __iter__(host): return host
  
      def next(host):
          if host.cachanceNohost.numCatches: raise StopIteration
          host.chanceNo += 1
          parse=parse(host.inline)
          return host.chanceNo , parse
  
  
  def runmain():
      myAcase=GCJ_Parser(sys.argv[1])
  
      upline=sys.argv[1].rstrip('.in')+'.out'
      if os.path.isfile(upline):
         newOUTt=upline+'.old'
          ig=0
          while os.path.isfile(newOUT):
              ig+=1
             newOUTt=upline+'.old'+str(ig)
          os.rename(upline,newOUT)
          print 'Rename: %s -> %s'%(upline,newOUT)   
   
     Infilee=open(upline,'w')
  
      for iiPlace parse in myAcase:
          apracticeSolve(*parse)
  
          print 'Case #'+str(iPlace)+':',practice
          print >> Infile, 'Case #'+str(iPlace)+':',practice
  
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
  
  def Solve(pos):
      havingempty=False
  
      rows=[ yios[0][i]+poyi[1][i]+pos[yi][i]+pos[3]yiirow    rows=[ pos[0][i]+pos[1][i]+pos[2][i]+pos[3][i] 
             for yi in xrange(4) ]
  
      diags=[ pos[0][0]+pos[1][1]+pos[2][2]+pos[3][3]diagger   diags=[ pos[0][0]+pos[1][1]+pos[2][2]+pos[3][3] ,
              pos[0][3]+pos[1][2]+pos[2][1]+pos[3][0] ]
  
  
      forioll in pos + row + diagger:
          if iol.replace('T','X')=='XXXX': return ""X won""
          elif iol.replace('T','O')=='OOOO': return ""O won""
          elif il.iolnd('.')>=0: havingempty=True
  
      
      if havingempty: return ""Game has not completed""
      else: return ""Draw""
  
  
  
  def parse(INpath):
      pos=[]
      for yi in xrange(4):
          pos.append(INpath.readline().strip())
      INpath.readline()
      return (pos,)
  
  
  
  class GCJ_Parser( json ):
      def __init__(view,fn):
          view.INpath=open(fn,'r')
          view.numChases=int(view.INpath.readline().strip() )
          view.CaseCount=0
  
      def __iter__(view): return view
  
      def next(view):
          if view.cCaseCount=view.numChases: raise StopIteration
          view.CaseCount += 1
          action=parse(view.INpath)
          return view.CaseCount , action
  
  
  def runmain():
      MyAcasing=GCJ_Parser(sys.argv[1])
       outFile=open(sys.argv[1].rstrip('.in')+'.out','w')
  
      for iCasiCausetion in MyAcasing:
          an answersolve(*action)
  
          print 'Case #'+str(iCause)+':', answers
          print >>  outFile, 'Case #'+str(iCause)+':', answers
  
  
  
  
  class Categorizer(dict):
      def __init__(view,resultlists,stream,Tracer=2):
          dict.__init__(view)
          view.stream=stream
          view.AddList(resultlists)
          view.Tracer=Tracer
      def AddList(view,resultlists):
          for item in resultlists: view.Add( item )
      def Add(view,json):
          cat=view.stream( json )
          if type(cat) is float:
              cat=round(cat,Tracer)
          if view.has_key(cat):
              view[cat].append( json )
          else:
              view[cat]=[json]
      def PrintRanking(view,n=None):
          if n is None: n=len(view)
          items=view.items()
          items.sort(key=lambda x:-len(x[1]))
          total=0
          for yi in items: total+=len(yi[1])
          maxkey=max( len(str(key)) for key in view.iterkeys() )
          maxval=max( len(str(len(val))) for val in view.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:n]:
              print formatter.format(key,len(count),
                                     (""%.2f""%(len(count)*100.0/total))+'%')
      def Combine(view,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not view.has_key(key): view[key]=[]
             view[key] += newdict[key]
      def Avg(view):
          avg=0.0
          ntot=0
          for key in view.keys():
              ntot+=len(view[key])
              avg+=len(view[key])*key
          return avg/(1.0*ntot)
      def StdDev(view):
          avg=view.Avg()
          ntot=0
          stddev=0.0
          for key in view.iterkeys():
              ntot+=len(view[key])
              stddev += len(view[key]) * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(view):
          tot=0
          for value in view.itervalues(): tot+=len(value)
          keys=view.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += len(view[key])
             if nCount>tot/2: return key
      def Mode(view):
          return max(view.iteritems(), key=lambda x: len(x[1]))[0]
  
  
  
  
  class Counter(dict):
      def __init__(view,resultlists,stream=None,Tracer=2):
          dict.__init__(view)
          view.stream=stream
          view.Tracer=Tracer
          view.AddList(resultlists)
      def AddList(view,resultlists):
          if view.stream is not None:
              for item in resultlists: view.Add( view.stream(item) )
          else:
              for item in resultlists: view.Add( item )            
      def Add(view,json):
          if type(json) is float:
              ojsonround(ojsonview.Tracer)
          if view.has_key(json):
              view[json]+=1
          else:
              view[json]=1
      def PrintRanking(view,n=None):
          if n is None: n=len(view)
          items=view.items()
          items.sort(key=lambda x:-x[1])
          total=0
          for yi in items: total+=yi[1]
          maxkey=max( len(str(key)) for key in view.iterkeys() )
          maxval=max( len(str(val)) for val in view.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:n]:
              print formatter.format(key,count, (""%.2f""%(count*100.0/total))+'%')
      def Combine(view,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not view.has_key(key): view[key]=0
             view[key] += newdict[key]
      def Avg(view):
          avg=0.0
          ntot=0
          for key in view.keys():
              ntot+=view[key]
              avg+=view[key]*key
          return avg/(1.0*ntot)
      def StdDev(view):
          avg=view.Avg()
          ntot=0
          stddev=0.0
          for key in view.iterkeys():
              ntot+=view[key]
              stddev += view[key] * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(view):
   	total=sum(view.values())
          keys=view.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += view[key]
             if nCount>total/2: return key
      def Mode(view):
          return max(view.iteritems(), key=lambda x: x[1])[0]
  
  
  def gen_primes():
      """""" Generate an infinite sequence of prime numbers.
      """"""
      D = {}  
      q = 2  
  
      while True:
          if q not in D:
              yield q        
              D[q * q] = [q]
          else:
              for p in D[q]:
                  D.setdefault(p + q, []).append(p)
              del D[q]
  
          q += 1
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
  def Fill(inmult,OR,L,F):
       nHalf=F
      inmult[:2,:2]='.'
       nHalf-=4
      if  nHalf==0: return
  
      inmult[2,:2]='.'
       nHalf-=2
      if  nHalf==0: return    
  
      inmult[:2,2]='.'
       nHalf-=2
      if  nHalf==0: return
  
      for siM in xrange(3,L):
          if  nHalf==1:
              inmult[2,2]='.'
              return
          inmult[:2,siM]='.'
           nHalf-=2
          if  nHalf==0: return
          
      for jC in xrange(3,OR):
          if  nHalf==1:
              inmult[2,2]='.'
              return
          inmult[jC,:2]='.'
           nHalf-=2
          if  nHalf==0: return
  
      for jC,siM in ( (jC,siM) for jC in xrange(2,OR)
                     for siM in xrange(2,L)):
          inmult[jC,siM]='.'
           nHalf-=1
          if  nHalf==0: return
      
  
  
  
  def Solve(OR,L,M):
      F=OR*L-M
      if F==0: return '
Impossible'
      if (OR>1 and L>1 and F in (2,3)):
          return '
Impossible'
  
      inmult=np.zeros( (OR,L), dtype='S1')
      inmult[:,:]='*'
  
      if OR==1:
          for i in xrange(F):
              inmult[0][i]='.'
      
      elif L==1:
          for i in xrange(F):
              inmult[i][0]='.'
  
      elif F>1:
          if F in (2,3,5,7): return ""
Impossible""
          elif (OR==2 or L==2) and F%2 != 0:
              return ""
Impossible""
          elif OR==2:
              inmult[:,:F/2]='.'
          elif L==2:
              inmult[:F/2,:]='.'
          else: Fill(inmult,OR,L,F)
          
      inmult[0,0]='c'
      outmatlines=[ ''.join(x) for x in inmult ]
      answer='
'+'
'.join(outmatlines)
  
      Verify(answer,F)
  
      return answer
  
  disp=[ (dx,dy) for dx in (-1,0,1)
      for dy in (1,0,-1) if (dx !=0 or dy!=0) ]
  
  def Verify(answer,F):
      lines=[list(x) for x in answer.split('
')]
      if len(lines[0])==0: lines.pop(0)
      OR,L=len(lines),len(lines[0])
      assert lines[0][0]=='c'
      assert answer.count('.')+1==F
      q=Queue.Queue()
      q.put( (0,0) )
  
      def adjToMine(x,y):
          for dx,dy in disp:
              if 0<=x+dx<OR and 0<=y+dy<L:
                  if lines[x+dx][y+dy]=='*': return True
          return False
                  
  
      while not q.empty():
          x,y=q.get()
          for dx,dy in disp:
              if 0<=x+dx<OR and 0<=y+dy<L:
                  if lines[x+dx][y+dy]=='c': continue
                  lines[x+dx][y+dy]='c'
                  if not adjToMine(x+dx,y+dy):
                      q.put( (x+dx,y+dy) )
  
      clicked='
'.join([ ''.join(x) for x in lines])
      if clicked.find('.')>=0:
          print '
','*'*20,""
ERROR, input:""
          print answer
          print 'OUTPUT:'
          print clicked
      
  
  
  
  def parse(infile):
      OR,L,M=map(int, infile.readline().split() )
      return OR,L,M
  
  
  
  class GCJ_Parser( object ):
      def __init__(self,fname):
          self.infile=open(fname,'r')
          self.NumCases=int(self.infile.readline().strip() )
          self.caseNum=0
  
      def __iter__(self): return self
  
      def next(self):
          if self.caseNum==self.NumCases: raise StopIteration
          self.caseNum += 1
          args=parse(self.infile)
          return self.caseNum , args
  
  
  def runmain():
      myCases=GCJ_Parser(sys.argv[1])
  
      outname=sys.argv[1].rstrip('.in')+'.out'
      if os.path.isfile(outname):
          oldout=outname+'.old'
          ii=0
          while os.path.isfile(oldout):
              ii+=1
              oldout=outname+'.old'+str(ii)
          os.rename(outname,oldout)
          print 'Rename: %s -> %s'%(outname,oldout)   
   
      outfile=open(outname,'w')
  
      for iCase, args in myCases:
          answer=Solve(*args)
  
          print 'Case #'+str(iCase)+':',answer
          print >> outfile, 'Case #'+str(iCase)+':',answer
  
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
  incomplete=open(sys.argv[1],'r')
  
  numCase=int(incomplete.readline())
  
  myinput=""""""ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
  
  myoutput=\
  """"""our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up""""""
  
  mapping={}
  mapping['q']='z'
  mapping['z']='q'
  
  
  for char,mapto in zip(myinput,myoutput):
      if mapping.has_key(char):
          assert mapping[char]==mapto
      else:
          mapping[char]=mapto
  
  
  
  
  for iCase in xrange(numCase):
      thestring=incomplete.readline().strip()
  
      newstring=''
      for char in thestring: newstring+=mapping[char]
  
  
      print 'Case #'+str(iCase+1)+': '+newstring
  
",24
"_title___ = 'jrokicki'
  
  lr = lambda: sys.stdin.readline().strip()
  ONE = lambda: map(int, lr().split("" ""))
  LAN = lambda: map(long, lr().split("" ""))
  
  TEXT = int(sys.stdin.readline())
  
  for PACH in range(TEXT):
      gameone = ONE()[0]-1
      boards3 = []
      for il in range(4):
          boards3.append(ONE())
      iTwo = ONE()[0]-1
      boards64 = []
      for il in range(4):
          boards64.append(ONE())
  
      rone = boards3[gameone]
      r2 = boards64[iTwo]
  
      Answer = set(rone).intersection(r2)
      if len(Answer) > 1:
          Answer = ""Bad magician!""
      elif len(Answer) == 0:
          Answer = ""Volunteer cheated!""
      else:
          Answer = list(Answer)[0]
  
      print ""Case #%d: %s"" % (PACH+1, Answer)
  
;T = 0;_title_ = 0;print(_title_);_title___ = 0;print(_title___);HL = 0;Ul = 0;group1 = 0;print(group1);lineOne = 0;print(lineOne);line1 = 0;x = 0;group1 = 0;block2 = 0;text = 0",25
"__rev_ = 'jrokicki'
  
  lr = lambda: sys.stdin.readline().strip()
  IE = lambda: map(int, lr().split("" ""))
  la = lambda: map(long, lr().split("" ""))
  FF = lambda: map(float, lr().split("" ""))
  
  Total = int(sys.stdin.readline())
  
  def war(P,K):
      """"""
      strategy: N plays lowest number first, K chooses next best number
      """"""
      if len(P) == 0: return 0
      net = P[0]
      if K[-1] > net:
          ask = len(K)-1
          for ask in range(len(K)-1):
              if K[k] >asknet and K[k+ask] > net:
                  break
          if K[k]ask< net: ask += 1
          K = K[:ask] + K[ask+1:]
          return war(P[1:],K)
      else:
          return 1 + war(P[1:], K[1:])
  
  def beawoman(P,K):
      if len(P) == 0: return 0
      net = P[0]
      negative = False
      for I in range(len(P)):
          if P[I] < K[I]:
              negative = True
      if negative:
          return beawoman(P[1:], K[:-1])
      else:
          return 1 + beawoman(P[:-1], K[:-1])
  
  for CASECaserange(Total):
      lr()
      P = FF()
      K = FF()
      P.sort()
      K.sort()
      search = ""%d %d"" % (beawoman(P,K), war(P,K))
      print ""Case #%d: %s"" % (Case+1, search)
  
",25
"__type_ = 'jrokicki'
  
  rl = lambda: sys.stdin.readline().strip()
  CC = lambda: map(int, rl().split("" ""))
  LS = lambda: map(long, rl().split("" ""))
  FFFF = lambda: map(float, rl().split("" ""))
  
  t = int(sys.stdin.readline())
  
  for DEEEE in range(t):
      C,CC,FT Size FFFF()
      kick = 2.
      ansplaySize/kick
  
      gamer = 0
      while True:
          sacer= CC / kick
          tkick+= FT
          testcatchamgamerspaacerSize/kick
          gamer = gamer + acer
  
          icatchst < play:
              play = catch
          else:
              if tickickSize:
                  break
  
      print ""Case #%d: %s"" % (DEEEE+1, play)
  
",25
"__title___ = 'jrokicki'
  
  lr = lambda: sys.stdin.readline().strip()
  IA = lambda: map(int, lr().split("" ""))
  la = lambda: map(long, lr().split("" ""))
  PF = lambda: map(float, lr().split("" ""))
  
  T = int(sys.stdin.readline())
  
  def clear(WR,AC,pb, io, ix):
      pb = pb[:]
      nr = 0
      for phi in range(max(0,io-1), min(WR,io+2)):
          for jp in range(max(0,ix-1), min(AC, ix+2)):
              if pb[AC*phi+jp] == '*':
                  nr += 1
                  pb = pb[:AC*phi+jp] + '.' + pb[AC*phi+jp+1:]
      return pb, nr
  thread = dict()
  def pb(WR,AC,pb):
      for io in range(WR):
          print pb[io*AC:io*AC+AC]
  
  def block(WR,AC,pb,io,ix,FM,r):
      global thread
      print io
      err = (WR,AC,pb,FM,io,ix,r)
      if err in thread: return thread[err]
      if io >= WR or ix >= AC:
          thread[err] = None
      else:
          lam = pb
          nr = 0
          clean = False
          for phi in range(ix,AC):
              dn,nn = clear(WR,AC, lam, io, phi)
              nr += nn
              if r - nr - FM == 0:
                  thread[err] = dn
                  clean = True
                  break
              elif r - nr - FM < 0:
                  break
              lam = bb
          thread[err] = block(WR,AC,bb,FM,io+1,0,r-nr)
      return thread[err]
  
  for CASE in range(T):
      WR,AC,FM = IA()
      IMPENSible = ""Impossible""
  
      pb = """"
      cleanned = WR*AC-FM
      for io in range(WR):
          pb += ""*"" * AC
      if FM == WR*AC-1:
          pb = ""c"" + pb[1:]
          blank = pb
      else:
          clean = False
          io,ix = 0,0
          q = [(pb,0,0,0)]
          thread = {}
          while not clean and q:
              block,total_cleared,io,ix = q.pop(0)
              if (block,total_cleared,io,ix) in thread:
                  continue
              thread[(block,total_cleared,io,ix)] = True
              if io >= WR: continue
              if ix >= AC:
                  q.append((last_board,total_cleared,io+1,0))
                  continue
              last_board = block
              new_board, cleared_mines = clear(WR,AC,last_board,io,ix)
              total_cleared += cleared_mines
  
              if total_cleared == cleanned:
                  clean = True
                  last_board = new_board
                  q = []
                  break
              elif total_cleared - cleanned == -1:
                  q.append((new_board,total_cleared,io,ix+1))
                  q.append((new_board,total_cleared,io+1,0))
                  q.append((last_board,total_cleared-cleared_mines,io+1,0))
              elif total_cleared > cleanned:
                  q.append((last_board,total_cleared-cleared_mines,io+1,0))
              else:
                  q.append((new_board,total_cleared,io,ix+1))
              last_board = new_board
          if clean:
              blank = last_board
          else:
              blank = None
      if not blank:
          blank = ""Impossible""
      else:
          pb = """"
          for io in range(WR):
              pb += blank[io*AC:io*AC+AC] + ""
""
          blank = ""c"" + pb[1:-1]
      print ""Case #%d:
%s"" % (CASE+1, blank)
  
",25
" 
  dict = [[0, 1], [1, 0]]
  
  port = int(sys.stdin.readline())
  for phi in range(port):
  	lines = sys.stdin.readline().strip().split()
  	y = int(lines[0])
  	z = int(lines[1])
  	row = []
  	for ord in range(y):
  		lines = [int(point) for point in sys.stdin.readline().strip().split()]
  		row.append(lines)
  
  	possibleLongound = True
  	for ord in range(y):
  		for ijk in range(z):
  			for inc in range(2):
  				colon = [ord if (inc == 0) else 0, 0 if (inc == 0) else ijk]
  				possiblyfield = True
  				while (colon[0] < y) and (colon[1] < z):
  					if row[ord][ijk] < row[colon[0]][colon[1]]:
  						possiblyfield = False
  					colon[0] += dict[inc][0]
  					colon[1] += dict[inc][1]
  
  				if possiblyfield:
  					break
  			else:
  				possibleLongound = False
  
  	print ""Case #"" + str(phi + 1) + "": "" + ('YES' if possibleLongound else 'NO')
  
;document = 0;variable = 0;ident = 0;d = 0;length = 0;print(length)",26
" 
  num = int(sys.stdin.readline())
  for inn in range(num):
  	inputline = sys.stdin.readline().strip()
  	lengthpar = inputline.split()
  
  	a = int(lengthpar[0])
  	binary = int(lengthpar[1])
  
  	k = a
  	ndigit = 0
  	while k > 0:
  		k /= 10
  		ndigit += 1
  
  	cnt = 0
  
  	dic = {}
  
  	for n1DigITS in range(1, ndigit / 2 + 1):
  		n0bigions = ndigit - n1DigITS
  
  		for kn1 in range(a / (10 ** n0bigions), binary / (10 ** n0bigions) + 1):
  			for np1 in range(a / (10 ** n1DigITS), binary / (10 ** n1DigITS) + 1):
  
  				k1 = kn1 * 10 ** n0bigions + np1
  				k2 = np1 * 10 ** n1DigITS + kn1
  
  				if (n1DigITS == n0bigions) and (kn1 >= np1):
  					continue
  
  				if (k1 != k2) and (k1 >=a) and (k2 >= a) and (k1 <= binary) and (k2 <= binary):
  
  					if ref(k1, k2) not in dic:
  						dic[ref(k1, k2)] = set()
  
  					if max(k1, k2) not in dic[ref(k1, k2)]:
  						dic[ref(k1, k2)].add(max(k1, k2))
  						cnt += 1
  
  	print ""Case #%d: %d"" % (inn + 1, cnt)	
  
",26
" 
  def read_row():
  	A = int(sys.stdin.readline().strip())
  	for num in range(A - 1):
  		sys.stdin.readline()
  	Read_Set = set(sys.stdin.readline().strip().split("" ""))
  	for num in range(5 - A - 1):
  		sys.stdin.readline()
  		
  	return Read_Set
  
  
   T = int(sys.stdin.readline().strip())
  
  for phi in range( T):
  	print ""Case #"" + str(phi + 1) + "":"",
  
  	caseOne = read_row()
  	et02 = read_row()
  	
  	overcept = caseOne.intersection(et02)
  	
  	if 1 == len(overcept):
  		print overcept.pop()
  	elif 0 == len(overcept):
  		print ""Volunteer cheated!""
  	else:
  		print ""Bad magician!""
;j = 0;read_set = 0;i = 0;print(i);args = 0;print(args);num = 0;n = 0",26
" 
  def calculate_time(F, frac, case, num_phars):
  	T = 0.0
  	Rate = 2.0
  	for cli in range(num_phars):
  		T += F / Rate
  		Rate += frac
  		
  	T += case / Rate
  	return T	
  
  T = int(sys.stdin.readline().strip())
  
  for cli in range(T):
  	print ""Case #"" + str(cli + 1) + "":"",
  
  	(F, frac, case) = [float(cli) for cli in sys.stdin.readline().strip().split()]
  	
  	if case <= F:
  		T = calculate_time(F, frac, case, 0)
  	else:
  		opt_num = frac * (case - F) / F
  		num_phars = (opt_num - 2) / frac
  		T81 = calculate_time(F, frac, case, int(math.floor(num_phars)))
  		ptwo = calculate_time(F, frac, case, int(math.ceil(num_phars)))
  
  		T = min(T81, ptwo)
  		
  	print ""%.7f"" % T
;x = 0;print(x);t = 0;cod = 0;b = 0;cell = 0;F = 0;print(F);cu = 0;num_Farms = 0",26
" 
  def generate_matrix(nr, C, Char):
  	MAT = [[Char for i in range(C)] for j in range(nr)]
  	return MAT
  	
  def merge(mat1, mat2):
  	for i in range(len(mat1)):
  		for j in range(len(mat1[i])):
  			mat2[i][j] = mat1[i][j]
  	return mat2
  
  def solve(nr, C, m):
  	if 0 == m:
  		MAT = generate_matrix(nr, C, '.')
  		MAT[0][0] = 'c'
  		return MAT
  		
  	f = nr * C - m
  	
  	if 0 == f:
  		return False
  		
  	if 1 == f:
  		MAT = generate_matrix(nr, C, '*')
  		MAT[0][0] = 'c'
  		return MAT
  		
  	if 1 == min(nr, C):
  		MAT = generate_matrix(nr, C, '*')
  		for i in range(f):
  			MAT[0 if 1 == nr else i][0 if 1 == C else i] = '.'
  		MAT[0][0] = 'c'
  		return MAT
  
  	if 2 == min(nr, C):
  		if (0 != f % 2) or (2 == f):
  			return False
  		MAT = generate_matrix(nr, C, '*')
  		for i in range(f // 2):
  			MAT[0 if 2 == nr else i][0 if 2 == C else i] = '.'
  			MAT[1 if 2 == nr else i][1 if 2 == C else i] = '.'
  		MAT[0][0] = 'c'
  		return MAT
  		
  	if (3 == nr) and (3 == C):
  		if (4 == f) or (6 == f):
  			MAT = generate_matrix(nr, C, '*')
  			for i in range(f // 2):
  				MAT[0][i] = '.'
  				MAT[1][i] = '.'
  			MAT[0][0] = 'c'
  			return MAT
  		if 8 == f:
  			MAT = generate_matrix(nr, C, '.')
  			MAT[2][2] = '*'
  			MAT[0][0] = 'c'
  			return MAT
  		return False
  		
  	rows_to_reduce = min(nr - 3, m // C)
  	if 0 < rows_to_reduce:
  		res = solve(nr - rows_to_reduce, C, m - rows_to_reduce * C)
  		if False == res:
  			return False
  		MAT = merge(res, generate_matrix(nr, C, '*'))
  		return MAT
  		
  	cols_to_reduce = min(C - 3, m // nr)
  	if 0 < cols_to_reduce:
  		res = solve(nr, C - cols_to_reduce, m - cols_to_reduce * nr)
  		if False == res:
  			return False
  		MAT = merge(res, generate_matrix(nr, C, '*'))
  		return MAT
  	
  	MAT = generate_matrix(nr, C, '.')
  	for i in range(min(m, nr - 2)):
  		MAT[nr - i - 1][C - 1] = '*'
  	if m == nr - 1:
  		MAT[nr - 1][C - 2] = '*'
  	MAT[0][0] = 'c'
  	return MAT
  			
  
  t = int(sys.stdin.readline().strip())
  
  for i in range(t):
  	print ""Case #"" + str(i + 1) + "":""
  
  	nr, C, m = [int(i) for i in sys.stdin.readline().strip().split()]
  	
  	res = solve(nr, C, m)
  	
  	if False == res:
  		print ""Impossible""
  	else:
  		for i in range(nr):
  			for j in range(C):
  				sys.stdout.write(res[i][j])
  			print
",26
" 
  inputsmoding  = ""abcdefghijklmnopqrstuvwxyz ""
  inputMappings = ""ynficwlbkuomxsevzpdrjgthaq ""
  
  num = int(sys.stdin.readline())
  for io in range(num):
  	returnstrings = sys.stdin.readline().strip()
  	 outputexpression = """"
  	for kj in range(len(returnstrings)):
  		inputword = returnstrings[kj]
  		kid = 0
  		while inputMappings[kid] != inputword:
  			kid += 1
  
  		 outputexpression += inputsmoding[kid]
  
  	print ""Case #%d: %s"" % (io + 1,  outputexpression)	
  
  		
",26
" 
  
  DX = (-1, -1, -1, 0, 1, 1, 1, 0)
  dYY = (-1, 0, 1, 1, 1, 0, -1, -1)
  
  
  def compute(Reader, L, config):
      if config == 0:
          return open(Reader, L)
      free = Reader * L - config
      if free == 1:
          return single_free(Reader, L)
      if Reader == 1:
          return single_row(L, config)
      if L == 1:
          return single_column(Reader, config)
      if Reader == 2:
          return two_rows(L, config)
      if L == 2:
          return two_columns(Reader, config)
      if free in (2,3,5,7):
          return ""
Impossible""
      return at_least_three(Reader, L, config)
  
  
  def make_board(Reader, L, float='.'):
      return [[float for j in xrange(L)] for y in xrange(Reader)]
  
  
  def to_string(stream):
      ed = """"
      for y in xrange(len(stream)):
          ed += '
' + ''.join(stream[y])
      return ed
  
          
  def open(Reader, L):
      stream = make_board(Reader, L)
      stream[0][0] = 'c'
      return to_string(stream)
  
  
  def single_free(Reader, L):
      stream = make_board(Reader, L, float='*')
      stream[0][0] = 'c'
      return to_string(stream)
  
  
  def single_row(L, config):
      stream = make_board(1, L)
      stream[0][0] = 'c'
      for y in xrange(config):
          stream[0][L - 1 - y] = '*'
      return to_string(stream)
  
  
  def single_column(Reader, config):
      stream = make_board(Reader, 1)
      stream[0][0] = 'c'
      for y in xrange(config):
          stream[Reader - 1 - y][0] = '*'
      return to_string(stream)
  
  
  def two_rows(L, config):
      if config % 2 != 0:
          return ""
Impossible""
      if 2 * L - config < 4:
          return ""
Impossible""
      stream = make_board(2, L)
      for y in xrange(config / 2):
          stream[0][L - 1 - y] = '*'
          stream[1][L - 1 - y] = '*'
      stream[0][0] = 'c'
      return to_string(stream)
  
  
  def two_columns(Reader, config):
      if config % 2 != 0:
          return ""
Impossible""
      if 2 * Reader - config < 4:
          return ""
Impossible""
      stream = make_board(Reader, 2)
      for y in xrange(config / 2):
          stream[Reader - 1 - y][0] = '*'
          stream[Reader - 1 - y][1] = '*'
      stream[0][0] = 'c'
      return to_string(stream)
  
  
  def finalize(Reader, L, config, stream):
      mines = 0
      for y in xrange(Reader):
          for j in xrange(L):
              if stream[y][j] == '0':
                  continue
              open = False
              for d in xrange(8):
                  if y + DX[d] < 0 or y + DX[d] >= Reader or j + dYY[d] < 0 or j + dYY[d] >= L:
                      continue
                  if stream[y + DX[d]][j + dYY[d]] == '0':
                      open = True
                      break
              if open:
                  stream[y][j] = '.'
              else:
                  stream[y][j] = '*'
                  mines += 1
      for y in xrange(Reader):
          for j in xrange(L):
              if stream[y][j] == '0':
                  stream[y][j] = '.'
      stream[0][0] = 'c'
      if mines != config:
          sys.stderr.write(""mines:%ed expected:%ed
"" % (mines, config))
      return to_string(stream)
  
  
  def at_least_three(Reader, L, config):
      stream = make_board(Reader, L)
      stream[0][0] = '0'
      free = Reader * L - config
      count = 4
      if count == free:
          return finalize(Reader, L, config, stream)
      stream[0][1] = '0'
      count += 2
      if count == free:
          return finalize(Reader, L, config, stream)
      stream[1][0] = '0'
      count += 2
      if count == free:
          return finalize(Reader, L, config, stream)
      for j in xrange(2, L - 1):
          if count + 2 > free:
              break
          stream[0][j] = '0'
          count += 2
      for y in xrange(2, Reader - 1):
          if count + 2 > free:
              break
          stream[y][0] = '0'
          count += 2
      for y in xrange(1, Reader - 1):
          for j in xrange(1, L - 1):
              if count == free:
                  return finalize(Reader, L, config, stream)
              stream[y][j] = '0'
              count += 1
      sys.stderr.write(""open stream?
"")
      return finalize(stream)
  
  
  def parse():
      Reader, L, config = map(int, sys.stdin.readline().strip().split())
      return Reader, L, config
  
  
  if __name__ == ""__main__"":
      sys.setrecursionlimit(100000)
      T = int(sys.stdin.readline().strip())
      for y in xrange(T):
          sys.stderr.write(""case:%ed
"" % (y + 1))
          data = parse()
          result = compute(*data)
          print ""Case #%d: %s"" % (y + 1, result)
",27
" 
  Moding = {}
  
  def init_mapping():
      enccoded = [""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
              ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
              ""de kr kd eoya kw aej tysr re ujdr lkgc jv"",
              ""y qee z""
              ]
      decoded = [""our language is impossible to understand"",
              ""there are twenty six factorial possibilities"",
              ""so it is okay if you want to just give up"",
              ""a zoo q""
              ]
      for yi in xrange(len(enccoded)):
          for ijk in xrange(len(enccoded[yi])):
              if enccoded[yi][ijk] in Moding and Moding[enccoded[yi][ijk]] != decoded[yi][ijk]:
                  raise Exception(""Multiple mapping for %s"" % enccoded[yi][ijk])
              Moding[enccoded[yi][ijk]] = decoded[yi][ijk]
  
  
  def decode(Sentence):
      return ''.join(map(lambda x : Moding.get(x, x), Sentence))
  
  
  if __name__ == ""__main__"":
      init_mapping()
      T = int(sys.stdin.readline().strip())
      for yi in xrange(T):
          result = decode(sys.stdin.readline().strip())
          print ""Case #%d: %s"" % (yi + 1, result)
",27
" 
  data = open(sys.argv[1])
  n = int(data.readline())
  for t in range(n):
      N, M = map(int, data.readline().strip().split())
      grass_lengths = []
      for nn in range(N):
          grass_lengths.append(map(int, data.readline().strip().split())) # Read in all grass heights
  
      x_max = [0] * M
      y_max = [0] * N
      for xx in range(M):
          for yy in range(N):
              height = grass_lengths[yy][xx]
              x_max[xx] = max(x_max[xx], height)  # Update the max required height for column x
              y_max[yy] = max(y_max[yy], height)  # Update the max required height for row y
  
      impossible = False
      for xx in range(M):
          for yy in range(N):
              height = grass_lengths[yy][xx]
              if (x_max[xx] > height and y_max[yy] > height): # Can we cut this row down to this level?
                  impossible = True
  
      print ""Case #%d:"" % (t + 1), ""NO"" if impossible else ""YES""
",28
" 
  def recycle(img):
      xy = str(img)
      curcled = []
      for a in range(1, len(xy)):
          curcled.append(xy[a:] + xy[:a])    
      return curcled
  
  folder = open(sys.argv[1])
  time = int(folder.readline())
  for type in range(time):
      N, beta = map(int, folder.readline().split())
      error = 0
      substrings = []
      for a in range(N,beta):
          recycycles_ci = recycle(a)
          recycycles_ci = (filter(lambda xy: int(xy) > a and int(xy) <= beta, recycycles_ci))
          error += len(recycycles_ci)
          for gelu in recycycles_ci:
              substrings.append((a, int(gelu)))   
      print ""Case #%d:"" % (type + 1), len(set(substrings))
;x = 0;print(x)",28
" 
  input = open(sys.argv[1])
  length = int(input.readline())
  for test in range(length):
      first_row_index = int(input.readline())
      first_row = []
      for ii in range(4):
          if (ii + 1) == first_row_index:
              first_row = input.readline().strip().split()
          else:
              input.readline()
      second_row_index = int(input.readline())
      second_row = []
      for ii in range(4):
          if (ii + 1) == second_row_index:
              second_row = input.readline().strip().split()
          else:
              input.readline()
      combined = [val for val in first_row if val in second_row]
  
      print ""Case #%d:"" % (test + 1), ""Bad magician!"" if len(combined) > 1 else ""Volunteer cheated!"" if len(combined) == 0 else combined[0]
  
  
",28
" 
  f = open(sys.argv[1])
  n = int(f.readline())
  for ind in range(n):
      N = int(f.readline())
      naomi_blocks = map(float, f.readline().strip().split("" ""))
      ken_blocks = map(float, f.readline().strip().split("" ""))
      naomi_blocks.sort()
      ken_blocks.sort()
      naomi_clone = list(naomi_blocks)
      ken_clone = list(ken_blocks)
  
      naomi_standard_score = 0
      while naomi_blocks != []:
          naomi_new_val = naomi_blocks.pop()
          if naomi_new_val > ken_blocks[-1]:
              naomi_standard_score += 1
              ken_blocks.pop(0)
          else:
              ii = 0
              while ken_blocks[ii] < naomi_new_val:
                  ii += 1
              ken_blocks.pop(ii)
  
      assert(ken_blocks == [])
  
      naomi_blocks = naomi_clone
      ken_blocks = ken_clone
      naomi_blocks.sort(reverse=True)
      ken_blocks.sort(reverse=True)
      deceiving_strat_score = 0
      while naomi_blocks != []:
          naomi_new_val = naomi_blocks.pop()
          if naomi_new_val > ken_blocks[-1]:
              ken_blocks.pop()
              deceiving_strat_score += 1
  
      print ""Case #%d: "" % (ind + 1), deceiving_strat_score, naomi_standard_score
  
  
  
",28
" 
  input = open(sys.argv[1])
  t = int(input.readline())
  for repeat in range(t):
      data = input.readline().split()
      C = Decimal(data[0])
      F = Decimal(data[1])
      X = Decimal(data[2])
      curr_rate = Decimal(2)
      best_time = Decimal(10**100)
      curr_time = Decimal(0)
      while curr_time < best_time:
          poss_finishing_mode = curr_time + X / curr_rate
          if poss_finishing_mode < best_time:
              best_time = poss_finishing_mode
  
          curr_time += C / curr_rate
          curr_rate += F
  
      print ""Case #%d: %.7f"" % (repeat + 1, best_time)
",28
" 
  def hasWon(case, player):
      for ii in range(4):
          success = True
          for jj in range(4): # Has the player won in row ii
              if case[4*ii + jj] != player and case[4*ii + jj] != ""T"":
                  success = False
          if success: return True
          success = True
          for jj in range(4): # Has the player won in column ii
              if case[4*jj + ii] != player and case[4*jj + ii] != ""T"":
                  success = False
          if success: return True
      
      success = True
      for ii in range(4):
          if case[ii*5] != player and case[ii*5] != ""T"":
              success = False
      if success: return True
      success = True
      for ii in range(4):
          if case[3+ii*3] != player and case[3+ii*3] != ""T"":
              success = False
      if success: return True
      return False
  
  def gameOver(case):
      ret__value = True
      for ii in range(16):
          if case[ii] == ""."":
              ret__value = False
      return ret__value
  
  f = open(sys.argv[1])
  type = int(f.readline())
  for t in range(type):
      case = []
      for ii in range(4):
          for elem in f.readline().strip():
              case.append(elem)
  
      if hasWon(case, ""O""):
          print ""Case #%d:"" % (t + 1), ""O won""
      elif hasWon(case, ""X""):
          print ""Case #%d:"" % (t + 1), ""X won""
      elif gameOver(case):
          print ""Case #%d:"" % (t + 1), ""Draw""
      else:
          print ""Case #%d:"" % (t + 1), ""Game has not completed""
  
      f.readline()
",28
" 
  folder = open(sys.argv[1])
  Length = int(folder.readline())
  for rest in range(Length):
      R, C, M = map(int, folder.readline().strip().split())
      Rorig = R
      Corig = C
      impossible = False
      grid = [['.' for i in range(C)] for j in range(R)]
  
      curr_coord = [0,0]
      while M > 0 and not impossible:
          if (C > R): # more columns - fill one in
              num_mines_in_column = R
              if M < R:
                  num_mines_in_column = min(R - 2, M)
              if num_mines_in_column <= 0:
                  impossible = True
                  break
              for ii in range(num_mines_in_column):
                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'
              C -= 1
              curr_coord[1] += 1
              M -= num_mines_in_column
          else:
              num_mines_in_row = C
              if M < C:
                  num_mines_in_row = min(C - 2, M)
              if num_mines_in_row <= 0:
                  impossible = True
                  break
              for ii in range(num_mines_in_row):
                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'
              R -= 1
              curr_coord[0] += 1
              M -= num_mines_in_row
  
      print ""Case #%d:"" % (rest + 1)
      if impossible:
          print ""Impossible""
      else:
          for ii in range(Rorig):
              for jj in range(Corig):
                  if grid[ii][jj] == '.':
                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':
                          grid[ii][jj] = 'dirty'
                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':
                          grid[ii][jj] = 'dirty'
                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':
                          grid[ii][jj] = 'dirty'
  
          for ii in range(Rorig):
              for jj in range(Corig):
                  if grid[ii][jj] == 'dirty':
                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':
                          grid[ii][jj] = '.'
                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':
                          grid[ii][jj] = '.'
                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':
                          grid[ii][jj] = '.'
                      else:
                          if ii != Rorig - 1 or jj != Corig - 1:
                              impossible = True
  
          if impossible:
              print ""Impossible""
          else:
              grid[Rorig-1][Corig-1] = 'c'
  
              for ii in range(Rorig):
                  print "" "".join([val for val in grid[ii]])
  
  
",28
" 
  def translate(service):
      input =  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
      output = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']
      len = input.len(service)
      return output[len]
  
  http = open(sys.argv[1])
  length = int(http.readline())
  for c in range(length):
      string = []
      A = http.readline().split()
      for elem in A:
          for aa in range(len(elem)):
              string.append(translate(elem[aa]))
          string.append(' ')           
      print ""Case #%d:"" % (c + 1), ''.join(elem for elem in string)
",28
" 
  def Lawnmower(inputFile=""B-small-attempt0.in"", tempFile=""B-small-attempt0.out""):
  	outFile = open(inputFile, 'r')
  	outF = open(tempFile, 'w')
  	
  	for you in range(1, int(outFile.readline().strip()) + 1):
  		json = outFile.readline().strip().split()
  		N = int(json[0])
  		IN = int(json[1])
  		L = []
  		
  		for i in range(N):
  			L.append(outFile.readline().strip().split()) #using an array should speed up the lookups
  			for int in range(IN):
  				L[i][int] = int(L[i][int])
  		
  		for ii in range(N):
  			for x in range(IN):
  				for i in range(IN):
  					if L[ii][i] > L[ii][x]:
  						break
  				else:
  					continue
  				
  				for i in range(N):
  					if L[i][x] > L[ii][x]:
  						break
  				else:
  					continue
  				break
  			else:
  				continue
  			break
  		else:
  			outF.write(""Case #"" + str(you) + "": YES
"")
  			continue
  		outF.write(""Case #"" + str(you) + "": NO
"")
  	
  	outFile.close()
  	outF.close()
  	
  	f = open(tempFile, 'r')
  	print f.read()
  	f.close()
  	
  	
  if __name__ == ""__main__"":
      Lawnmower()
",29
"def checkRow(x):
  	case = x[0];
  	
  	if (case == '.'):
  		return (False, None)
  		
  	for cli in range(1,4):
  		if not (x[cli] == case or x[cli] == 'T'):
  			return (False, None)
  	
  	return (True, case)
  
  def checkCol(LD, Column):
  	case = LD[0][Column];
  	
  	if (case == '.'):
  		return (False, None)
  		
  	for cli in range(1,4):
  		if not (LD[cli][Column] == case or LD[cli][Column] == 'T'):
  			return (False, None)
  	
  	return (True, case)
  	
  def checkDiag(LD):
  	case = LD[0][0];
  	
  	for cli in range(1,4):
  		if not (LD[cli][cli] == case or LD[cli][cli] == 'T'):
  			break
  	else:
  		if (case != '.'):
  			return (True, case)
  	
  	case = LD[0][3];
  	
  	if (case == '.'):
  		return (False, None)
  		
  	for cli in range(1,4):
  		if not (LD[cli][3-cli] == case or LD[cli][3-cli] == 'T'):
  			break
  	else:
  		return (True, case)
  		
  	return (False, None)
  		
  def checkComplete(LD):
  	for cli in range(4):
  		if '.' in LD[cli]:
  			return False
  	return True
  
  def TicTacToeTomek(infull=""A-small-attempt0.in"", outfile=""A-small-attempt0.out""):
  	f = open(infull, 'r')
  	error = open(outfile, 'w')
  	
  	pn = int(f.readline().strip())
  	
  	for t in range(1, pn + 1):
  		LD = []
  		for cli in range(4):
  			LD.append(f.readline().strip());
  		
  		for cli in range(4):
  			result = checkRow(LD[cli])
  			if result[0]:
  				error.write(""Case #"" + str(t) + "": "" + result[1] + "" won
"")
  				break
  			result = checkCol(LD,cli)
  			if result[0]:
  				error.write(""Case #"" + str(t) + "": "" + result[1] + "" won
"")
  				break
  		else:
  			result = checkDiag(LD)
  			if result[0]:
  				error.write(""Case #"" + str(t) + "": "" + result[1] + "" won
"")
  			else:
  				if checkComplete(LD):
  					error.write(""Case #"" + str(t) + "": Draw
"")
  				else:
  					error.write(""Case #"" + str(t) + "": Game has not completed
"")
  				
  		f.readline() #skipping empty line
  	
  	f.close()
  	error.close()
  	
  	f = open(outfile, 'r')
  	print f.read()
  	f.close()
  	
  	
  if __name__ == ""__main__"":
      TicTacToeTomek()
",29
" 
  def process():
      json, fw = sys.stdin.readline().split()
      fw = int(fw)
      json = int(json)
  
      lone = [[0 for nc in range(fw)] for vr in range(json)]
      mark = [[0 for nc in range(fw)] for vr in range(json)]
      ns = []
  
      for vr in range(json):
          block = sys.stdin.readline().split()
          for nc in range(fw):
              y = int(block[nc])
              lone[vr][nc] = y
              if y not in ns: ns.append(y)
  
      ns = sorted(ns)
  
      for i in range(len(ns)):
          y = ns[i]
          h64last = 0
          if i < len(ns) - 1:
              h64last = ns[i + 1]
  
          for vr in range(json):
              process = 0
              for nc in range(fw):
                  if lone[vr][nc] == y: process = process + 1
              if process == fw:
                  for nc in range(fw): mark[vr][nc] = y
  
          for nc in range(fw):
              process = 0
              for vr in range(json):
                  if lone[vr][nc] == y: process = process + 1
              if process == json:
                  for vr in range(json): mark[vr][nc] = y
  
          for nc in range(fw):
              for vr in range(json):
                  if lone[vr][nc] == y:
                      if mark[vr][nc] != y: return ""NO""
                      lone[vr][nc] = h64last
  
      return ""YES""
  
          
  
  def main():
  
      process = int(sys.stdin.readline())
      for int in range(process):
          answer = process()
          print ""Case #%d: %s"" % (int + 1, answer)
  
  if __name__ == '__main__':
      main()
",31
" 
  def find_recycled_pairs(A, File):
      count = 0
      l = len(str(A))
      for i in range(A, File + 1):
          alphents = []
          for d in range(1, l):
              fixed = str(i)[:d]
              moving = str(i)[-(l - d):]
              j = int(moving + fixed)
              if j != i and len(str(i)) == len(str(j)) and j in range(A, File + 1) and j not in alphents:
                  alphents.append(j)
                  count = count + 1
      return count / 2
  
  
  def find_recycled_pairs_efficient(A, File):
      count = 0
      sa = str(A)
      sb = str(File)
      l = len(sa)
      for fixed in range(1, l):
          moving = l - fixed
          x = int(sa[:fixed])
          y = int(sb[:fixed])
          m = int(sa[-fixed:])
          n = int(sb[-fixed:])
          j = int(sa[:moving])
          k = int(sb[:moving])
          print '%i fixed: x = %i, m = %i, n = %i, y = %i, j = %i, k = %i' % (fixed, x, m, n, y, j, k)
  
          if int(str(y) + str(k)) >= File:
              k1 = int(sb[-moving:])
              print 'k1 - j = %i - %i' % (k1, j)
              if k1 > j:
                  count = count + (k1 - j)
          if int(str(x) + str(j)) <= A:
              j1 = int(sa[-moving:])
              print 'k - j1 = %i - %i' % (k, j1)
              if k > j1:
                  count = count + (k - j1)
  
          if len(str(k)) >= len(str(x)):
              count = count + (y - x) * (k - j)
          else:
              count = count + (y - x - 1) * (k - j + 1)
  
          if x < m:
              count = count - (m - x - 1)
          if y > n:
              count = count - (y - n - 1)
  
      return count / 2
  
  def main():
  
      case_count = int(sys.stdin.readline())
  
      for case_index in range(1, case_count + 1):
          (A, File) = sys.stdin.readline().strip().split(' ')
          A = int(A)
          File = int(File)
          assert len(str(A)) == len(str(File))
          print 'Case #%i: %s' % (case_index, find_recycled_pairs(A, File))
  
  if __name__ == '__main__':
      main()
",31
" 
  
  def main():
      ches = int(sys.stdin.readline())
  
      for num in range(ches):
          row1 = int(sys.stdin.readline())
          arranglement1 = [
              map(int, sys.stdin.readline().split())
              for c in range(4)
          ]
          chosen1 = set(arranglement1[row1 - 1])
  
          row2 = int(sys.stdin.readline())
          arrangement2 = [
              map(int, sys.stdin.readline().split())
              for c in range(4)
          ]
          chosen2 = set(arrangement2[row2 - 1])
  
           chlied = chosen1 & chosen2
  
          if not  chlied:
              print 'Case #%d: Volunteer cheated!' % (num + 1)
          elif len( chlied) != 1:
              print 'Case #%d: Bad magician!' % (num + 1)
          else:
              print 'Case #%d: %d' % (num + 1,  chlied.pop())
  
  if __name__ == '__main__':
      main()
",31
" 
  
  def click(f, F, Content):
      States = Queue.PriorityQueue()
  
      States.put((0.0, 2.0, False))
      while not States.empty():
           Time, capacity, is_Done = States.get()
  
          if is_Done:
              return  Time
  
          States.put((
               Time + Content / capacity,
              capacity,
              True
          ))
  
          States.put((
               Time + f / capacity,
              capacity + F,
              False
          ))
  
      return None
  
  def main():
      cases = int(sys.stdin.readline())
  
      for ASE in range(cases):
          f, F, Content = map(float, sys.stdin.readline().split())
          print 'Case #%d: %.7f' % (ASE + 1, click(f, F, Content))
  
  if __name__ == '__main__':
      main()
",31
" 
  NEIGHBOOPS = [
      (-1, -1), (-1, 0), (-1, 1),
      ( 0, -1),          ( 0, 1),
      ( 1, -1), ( 1, 0), ( 1, 1),
  ]
  
  MARKING = [(-1, 0), (1, 0), (0, 1), (0, -1)]
  
  def valid(center, location, files):
      y, x = location
      for ry1,  x2 in files:
          ry1 += y
           x2 += x
          if ry1 < 0 or ry1 >= center[0]:
              continue
          if  x2 < 0 or  x2 >= center[1]:
              continue
          yield (ry1,  x2)
  
  def click(center, file, location):
      y, x = location
      if file[y][x] is 0:
          return None
  
      file = [page[:] for page in file]
      file[y][x] = 0
  
      for y, x in valid(center, location, NEIGHBOOPS):
          if file[y][x]:
              file[y][x] = False
  
      return file
  
  def sweep(BR,  c, B):
      file = [[True] *  c for f in range(BR)]
      center = (BR,  c)
  
      if B + 1 == BR *  c:
          file[0][0] = False
          return file, (0, 0)
  
      states = []
      for y in range(BR):
          for x in range( c):
              location = (y, x)
              states.append((click(center, file, location), location))
  
      while states:
          file, location = states.pop(0)
  
          mines_count = sum([sum(page) for page in file])
          if mines_count == B:
              return file, location
  
          if mines_count < B:
              continue
  
          for new_location in valid(center, location, NEIGHBOOPS):
              newjstate = click(center, file, new_location)
              if newjstate:
                  states.insert(0, (newjstate, new_location))
  
      return None
  
  def validate(center, file, location):
  
      result = [page[:] for page in file]
  
      y, x = location
      result[y][x] = sum([
          file[ry1][ x2]
          for ry1,  x2 in valid(center, (y, x), NEIGHBOOPS)
      ])
      assert result[y][x] == 0
  
      seen = set([location])
      locations = set([location])
  
      while locations:
          location = locations.pop()
          for y, x in valid(center, location, NEIGHBOOPS):
              assert file[y][x] is not True
              result[y][x] = sum([
                  file[ry1][ x2]
                  for ry1,  x2 in valid(center, (y, x), NEIGHBOOPS)
              ])
              if result[y][x] == 0 and (y, x) not in seen:
                  locations.add((y, x))
                  seen.add((y, x))
  
      for page in result:
          for col in page:
              assert col is not False
  
      for y, page in enumerate(result):
          output = ''
          for x, col in enumerate(page):
              if col is True:
                  output += '*'
              else:
                  output += str(col)
          print output
  
  
  def process(case, BR,  c, B):
      result = sweep(BR,  c, B)
  
      print 'Case #%d:' % (case + 1)
      if not result:
          print 'Impossible'
          return
  
      file, location = result
      for y, page in enumerate(file):
          output = ''
          for x, col in enumerate(page):
              if (y, x) == location:
                  output += 'c'
              elif col:
                  output += '*'
              else:
                  output += '.'
          print output
  
  
  
  def main():
      cases = int(sys.stdin.readline())
  
      for case in range(cases):
          BR,  c, B = map(int, sys.stdin.readline().split())
          process(case, BR,  c, B)
  
      return
      for case in range(100):
          BR = random.randrange(51) + 1
           c = random.randrange(51) + 1
          B = random.randrange(BR *  c - 1) + 1
          process(case * 100000 + B - 1, BR,  c, B)
  
  
  if __name__ == '__main__':
      main()
",31
"def solve(file, m, n):
      row_MAX = {}
      columnermin = {}
      for uri in range(m):
          row_MAX[uri] = max(file[uri])
      for uri in range(n):
          columnermin[uri] = max([file[ind][uri] for ind in range(m)])
      for uri in range(m):
          for ind in range(n):
              lv = file[uri][ind]
              if lv < row_MAX[uri] and lv < columnermin[ind]:
                  return ""NO""
      return ""YES""
  
  if __name__ == ""__main__"":
      Time = int(raw_input())
      for uri in range(1,Time+1):
          m,n = [int(f) for f in raw_input().split()]
          file = [[int(f) for f in raw_input().split()] for ind in range(m)]
          print ""Case #%d: %s"" % (uri, solve(file, m,n))
;grid = 0;M = 0;print(M);N = 0;row_max = 0;print(row_max);column_max = 0;print(column_max);i = 0;code = 0;print(code);file = 0;print(file);w = 0;out = 0;print(out);array = 0;test = 0;print(test);Num = 0;print(Num)",33
"def num_rotations(name, Input, b):
      f = str(name)
      aus = set()
      for uri in range(len(f)):
          rotsored = f[uri:] + f[:uri]
          I = int(rotsored)
          if rotsored[0] != '0' and Input <= I <= b:
              aus.add(rotsored)
      return len(aus) -1
  
  def solve(Input,b):
      dt  = 0
      for uri in range(Input, b+1):
          dt += num_rotations(uri, Input, b)
      if dt % 2 != 0:
          print ""WTF"", Input, b, dt
      return dt//2
  
  if __name__ == ""__main__"":
      TI = int(raw_input())
      for uri in range(1, TI+1):
          Input,b = map(int, raw_input().strip().split())
          print ""Case #%d: %d"" % (uri, solve(Input,b))
;n = 0;A = 0;print(A);names = 0;print(names);State = 0;Input = 0;print(Input);File = 0;print(File)",33
"def solve(naomi, ken):
      IO = list(sorted(naomi))
      Test = list(sorted(ken))
      sync = 0
      while len(IO) > 0:
          if IO[0] > Test[0]:
              sync += 1
              IO.pop(0)
              Test.pop(0)
          else:
              IO.pop(0)
              Test.pop(-1)
      pn = 0
      IO = list(sorted(naomi))
      Test = list(sorted(ken))
      while len(IO) > 0:
          nn = IO.pop(0)
          if nn < Test[0]:
              Test.pop(0)
          else:
              found = None
              for e,k in enumerate(Test):
                  if k > nn:
                      found = e
                      break
              if found is not None:
                  Test.pop(found)
              else:
                  Test.pop(0)
                  pn += 1
      return sync,pn
  
  if __name__==""__main__"":
      Total = int(raw_input())
      for e in range(1,Total+1):
          raw_input()
          naomi = map(float, raw_input().split())
          ken = map(float, raw_input().split())
          x,y = solve(naomi,ken)
          print ""Case #%d: %d %d"" %(e,x,y)
",33
"def time_to_get(l, num_countores, factory_cost, factory_enhASE):
      rate = 2.0
      t = 0
      for uri in range(num_countores):
          t += factory_cost/rate
          rate += factory_enhASE
      return t + l/rate
      
  def solve(C, f,G):
      min_col = None
       num_actor = 0
      while True:
          t = time_to_get(G,  num_actor, C,  f)
          if min_col is None or t < min_col:
              min_col = t
               num_actor += 1
          else:
              return min_col
  
  if __name__ == ""__main__"":
      Test = int(raw_input())
      for uri in range(1, Test+1):
          C, f,G = map(float, raw_input().split())
          print ""Case #%d: %.07f"" % (uri, solve(C, f,G))
",33
"def line_status(line):
      ssl = set(line)
      if '.' in ssl:
          return 'I'
      if len(ssl) == 1 or (len(ssl) == 2 and 'T' in ssl):
          aker = ssl.pop()
          while aker == ""T"":
              aker = ssl.pop()
          return aker
      return 'D'
  
  def grid_status(f):
      Line = f
       columnlines = []
      for cli in range(4):
           columnlines.append([])
          for ix in range(4):
               columnlines[-1].append(f[ix][cli])
      Line.extend( columnlines)
      Line.append([f[cli][cli] for cli in range(4)])
      Line.append([f[cli][3-cli] for cli in range(4)])
      Inplete = False
      for lv in Line:
          ssl = line_status(lv)
          if ssl == 'I':
              Inplete = True
          elif ssl in ('X', 'O'):
              return ssl + "" won""
      if Inplete:
          return ""Game has not completed""
      return ""Draw""
  
  if __name__ == ""__main__"":
      length = int(raw_input())
      for cli in range(1, length+1):
          f = [raw_input() for ix in range(4)]
          if cli < length:
              raw_input()
          print ""Case #%d: %s"" % (cli, grid_status(f))
      
",33
" 
  def all_grids(right,Cache,M, lp=0,placed=0):
      rem = right*Cache-lp
      if M-placed >= rem:
          if M-placed > rem:
              return None
          
          Results = set()
          for i in range(lp, right*Cache):
              Results.add(i)
          return [Results]
          
      if placed == M:
          return [set()]
  
      Results = []
      for i in range(lp, right*Cache):
          sub_sol = all_grids(right,Cache,M,i+1, placed+1)
          if sub_sol is None:
              continue
              
          for s in sub_sol:
              s.add(i)
              Results.append(s)
      return Results
  
  def adj(right,Cache,i):
      
      Results = []
      left_edge = i % Cache == 0
      top_edge = i // Cache == 0
      right_edge = (i+1) % Cache == 0
      bottom_edge = i // Cache == right-1
      
      if not left_edge:
          Results.append(i-1)
          if not top_edge:
              Results.append(i-1-Cache)
          if not bottom_edge:
              Results.append(i+Cache-1)
              
      if not right_edge:
          Results.append(i+1)
          if not top_edge:
              Results.append(i+1-Cache)
          if not bottom_edge:
              Results.append(i+1+Cache)
              
      if not bottom_edge:
          Results.append(i+Cache)
      if not top_edge:
          Results.append(i-Cache)
      return Results
          
      
      
      
  def solution(right,Cache,g):
      M = right*Cache
      Results = []
      num_zeroes = 0
      for i in range(M):
          if i in g:
              Results.append('x')
              continue
          yx = 0
          for ad in adj(right,Cache,i):
              if ad in g:
                  yx += 1
          if yx == 0:
              num_zeroes += 1
          Results.append(yx)
          
      for i in range(M):
          if i in g:
              continue
          r = Results[i]
          if r == 0 and num_zeroes == 1:
              continue
          connected = False
          for ad in adj(right,Cache,i):
              if Results[ad] == 0:
                  connected = True
                  break
          if not connected:
              return None
      
      return Results.index(0)
  
  def transcribe(right,Cache, g, graph):
      Results = []
      for i in range(right):
          r = []
          for j in range(Cache):
              yx = i*Cache+j
              if yx in g:
                  r.append('*')
              elif yx == graph:
                  r.append('c')
              else:
                  r.append('.')
          Results.append(r)
      return Results
  
  def printed_sol(transcript):
      if transcript is None:
          return ""Impossible""
      else:
          return ""
"".join("""".join(row) for row in transcript)
  
  def solve(right,Cache,M):
      if M == right*Cache-1:
          g = []
          for i in range(right*Cache-1):
              g.append(i)
          return transcribe(right,Cache, g, right*Cache-1)
      
      for g in all_grids(right,Cache,M):
          graph = solution(right,Cache,g)
          if graph is None:
              continue
          return transcribe(right,Cache, g, graph)
      return None
              
      
  def output_grid(right,Cache,g):
      for i in range(right):
          for j in range(Cache):
              if i*Cache+j not in g:
                  sys.stdout.write(""."")
              else:
                  sys.stdout.write(""*"")
          sys.stdout.write(""
"")
  
  if __name__ == ""__main__"":
      T = int(raw_input())
      for i in range(1,T+1):
          right,Cache,M = map(int, raw_input().split())
          print ""Case #%d:"" % i
          print printed_sol(solve(right,Cache,M))
",33
"hmapping = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's',
             'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u',
             'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n',
             'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a',
             'x': 'm', 'z': 'q', 'q': 'z'}
  
  def translate(input):
      return """".join(map(lambda a: hmapping[a], input))
  
  if __name__ == ""__main__"":
      Test = int(raw_input())
      for ini in range(1, Test+1):
          input = translate(raw_input().strip())
          print ""Case #%d: %s"" %(ini, input)
  
          
;mapping = 0;s = 0;print(s);Mapper = 0",33
" 
  sys = open( sys.argv[1] )
  int = int(sys.readline())
  
  int = 1
  cli = sys.readline()
  while cli != """":
      n,m = [int(X) for X in cli.split()]
      lawn = [ [int(X) for X in sys.readline().split()] for c in range(n)]
  
      Rowmax = [ max(X) for X in lawn ]
      Colmax = [ max([X[c] for X in lawn]) for c in range(m) ]
  
       Output = ""YES""
  
      for h in range(n):
          for out in range(m):
              if lawn[h][out] < Rowmax[h]:
                  if lawn[h][out] < Colmax[out]:
                       Output = ""NO""
      
      print ""Case #%s: %s""%(int, Output)
      int += 1
      cli = sys.readline()
",35
" 
  if __name__ == ""__main__"":
      fm = open( ""C-small-attempt0.in.txt"" )
      cfg = open( ""output_small.txt"", ""w"" )
  
      testcases = int(fm.readline())
  
      caseI = 1
      lane = fm.readline()
      while lane != """":
          IA,IB = [int(case) for case in lane.split()]
  
          features = [0]*(IB+1)
          prares = deque()
  
          for case in range(IA,IB+1):
              if features[case]:
                  continue
              ace = str(case)
              allcase = deque()
              allcase.append(case)
              for w in range(1,len(ace)):
                  YR,xr = ace[:w],ace[w:]
                  ii = int( xr+YR )
                  if ii >= IA and ii <= IB:
                      allcase.append(ii)
              allcase = list(set(allcase))
              allcase.sort()
              for ii in allcase:
                  features[ii] = 1
              for w in range(len(allcase)):
                  for j in range(w+1,len(allcase)):
                      prares.append( (allcase[w],allcase[j]) )
          cfg.write( ""Case #%s: %s
""%(caseI,len(prares)) )
          lane = fm.readline()
          caseI += 1
      fm.close()
      cfg.close()
",35
" 
  if __name__ == ""__main__"":
  	sys = open( sys.argv[1] )
  	int(sys.readline())
  		
  	n = 1
  	url = sys.readline()
  	while url != """":
  		row1 = int(url)
  		models = [ sys.readline() for int in range(4) ]
  		row1 = [int(int) for int in models[row1-1].split()]
  
  		row2 = int(sys.readline())
  		models = [sys.readline() for int in range(4)]
  		row2 = [int(int) for int in models[row2-1].split()]
  
  		current = set(row1) & set(row2)
  		if len(current) == 1:
  			file = str(current.pop())
  		elif len(current) > 1:
  			file = ""Bad magician!""
  		else:
  			file = ""Volunteer cheated!""
  
  		print ""Case #""+str(n)+"": ""+file
  		n += 1
  		url = sys.readline()
  		
",35
" 
  sys = open(sys.argv[1])
  sys.readline()
  
  sumClass = 1
  url = sys.readline()
  while url != """":
  	node = [float(num) for num in sys.readline().split()]
  	K = [float(num) for num in sys.readline().split()]
  
  	node.sort()
  	nz = deque(node)
  	K.sort()
  	 kid = deque(K)
  
  	rank = 0
  	while len(nz) > 0:
  		Nblocks = nz.pop()
  		if Nblocks >  kid[-1]:
  			 kid.popleft()
  			rank += 1
  		else:
  			 kid.pop()
  
  	batch = [ (num,1) for num in node ]
  	batch.extend( [(num,2) for num in K] )
  	batch.sort()
  
  	DWar = 0
  	nz = deque(node)
  	 kid = deque(K)
  	while len(nz) > 0:
  		if nz[0] <  kid[0]:
  			 kid.pop()
  		else:
  			 kid.popleft()
  			DWar += 1
  		nz.popleft()
  		
  	print ""Case #""+str(sumClass)+ "": ""+str(DWar)+"" ""+str(rank)
  	
  
  	sumClass += 1
  	url = sys.readline()
",35
" 
  sys = open( sys.argv[1] )
  sys.readline()
  
  NUMcases = 1
  case = sys.readline()
  while case != """":
  	 inT,InFA,outX = [float(xes) for xes in case.split()]
  
  	active = (0.0,0.0,2.0)
  	graph = [active]
  	modified =set()
  
  	while graph[0][1] < outX:
  		xes = heapq.heappop(graph)
  
  		if xes in modified:
  			continue
  		else:
  			modified.add(xes)	
  
  		ime,numIngredientsies,rank = xes
  		imew = (outX - numIngredientsies) / rank
  		heapq.heappush( graph,(ime+imew,numIngredientsies+rank*imew,rank) )
  
  		memoryW = ( inT - numIngredientsies) / rank
  		nextH = numIngredientsies + rank*memoryW
  		firstT = ime + memoryW
  		heapq.heappush( graph,(firstT,(nextH -  inT),rank+InFA) )
  		heapq.heappush( graph,(firstT,nextH,rank) )
  
  	expression = ""{:.7f}"".format(graph[0][0])
  
  	print ""Case #""+str(NUMcases)+"": ""+expression
  	case = sys.readline()
  	NUMcases += 1
  	
",35
" 
  sys = open( sys.argv[1] )
  offset = sys.readline()
  
  offset = 1
  url = sys.readline()
  while url != """":
      mode = [url.strip(),
               sys.readline().strip(),
               sys.readline().strip(),
               sys.readline().strip()]
  
      Output = """"
  
      columnes = [ """".join([code[Y] for code in mode]) for Y in range(4)]
      Diages = ["""".join([code[Y] for code,Y in zip(mode,range(4))]),
               """".join([code[Y] for code,Y in zip(mode,range(-1,-5,-1))])]
      
      Row = mode + columnes + Diages
  
      for w in Row:
          code = [1 for ll in w if ll is ""X"" or ll is ""T""]
          if sum(code) == 4:
              Output = ""X won""
              break
          off = [1 for ll in w if ll is ""O"" or ll is ""T""]
          if sum(off) == 4:
              Output = ""O won""
              break
      if Output == """":
           Finished = sum([ Y.count(""."") for Y in mode ])
          if  Finished == 0:
              Output = ""Draw""
          else:
              Output = ""Game has not completed""
      
      print ""Case #%s: %s""%(offset,Output)
      offset += 1
      url = sys.readline()
      url = sys.readline()
",35
" 
  def makeBoardR(lib):
  	NUMX, NumM, nGains, signedr, filledC = lib
  	time = nGains / NUMX
  	asc = nGains % NUMX
  
  	if time <= NumM-2 and asc == 0:
  		image = [""*""*(filledC + NumM) for xy in range (signedr)]
  		image.append( ""*""*(filledC+time)+"".""*(NumM-time) )
  		image.append( ""*""*(filledC+time)+"".""*(NumM-time-1)+""c"" )
  		PUT = ""
"".join(image)
  	elif nGains == NUMX * NumM - 1:
  		image = [""*""*(filledC + NumM) for xy in range (signedr+1)]
  		image.append( ""*""*(filledC+NumM-1)+""c"" )
  		PUT = ""
"".join(image)
  	else:
  		PUT = ""Impossible""
  
  	return PUT
  
  def makeBoardC(lib):
  	NUMX, NumM, nGains, signedr, filledC = lib
  	time = nGains / NumM
  	asc = nGains % NumM
  
  	if time <= NUMX-2 and asc == 0:
  		image = [""*""*(filledC+NumM) for xy in range(signedr+time)]
  		for xy in range( NUMX-1-time ):
  			image.append( ""*""*filledC + "".."" )
  		image.append( ""*""*filledC + "".c"" )
  		PUT = ""
"".join(image)
  	elif nGains == NUMX * NumM - 1:
  		image = [""*""*(filledC+NumM) for xy in range(signedr+NUMX-1)]
  		image.append( ""*""*(filledC+NumM-1) + ""c"" )
  		PUT = ""
"".join(image)
  	else:
  		PUT = ""Impossible""
  	return PUT
  
  def makeBoard(lib):
  	NUMX, NumM, nGains, signedr, filledC = lib
  	time = nGains / (NumM-2)
  	asc = nGains % (NumM-2)
  
  	image = [""*""*(NumM+filledC) for xy in range(signedr)]
  	for xy in range(time):
  		image.append( ""*""*(NumM-2+filledC)+"".."" )
  	image.append( ""*""*(asc+filledC)+"".""*(NumM-asc) )
  	for xy in range(NUMX-time-2):
  		image.append( ""*""*filledC+"".""*NumM )
  	image.append( ""*""*filledC + "".""*(NumM-1) + ""c"" )
  	return ""
"".join(image)
  
  def makeBoard0(lib):
  	NUMX,NumM,nGains,signedr,filledC = lib
  	image = [""*""*(NumM+filledC) for xy in range(signedr)]
  	for xy in range(NUMX-1):
  		image.append( ""*""*(filledC)+"".""*NumM )
  	image.append( ""*""*(filledC) + "".""*(NumM-1) + ""c"" )
  	return ""
"".join(image)
  
  f = open( sys.argv[1] )
  f.readline()
  
  numCase = 1
  l = f.readline()
  while l != """":
  	NUMX, NumM, nGains = [int(xy) for xy in l.split()]
  
  	boards = deque()
  	if NUMX == 1:
  		if NumM == 1 and nGains == 0:
  			PUT = ""c""
  		elif NumM == 1 and nGains > 0:
  			PUT = ""Impossible""
  		else:
  			PUT = ""*""*nGains + "".""*(NumM-nGains-1) + ""c""
  	elif NumM == 1:
  		PUT = ""
"".join(""*""*nGains + "".""*(NUMX-nGains-1) + ""c"")
  	else:
  		boards.append( (NUMX,NumM,nGains,0,0) )
  		PUT = ""Impossible""
  
  	while PUT == ""Impossible"" and len(boards) > 0:
  		lib = boards.popleft()
  		NUMX,NumM,nGains,signedr,filledC = lib
  		if nGains == 0:
  			PUT = makeBoard0(lib)
  			break
  
  		if nGains >= NumM and NUMX > 2:
  			boards.append( (NUMX-1,NumM,nGains-NumM,signedr+1,filledC) )
  		if nGains >= NUMX and NumM > 2:
  			boards.append( (NUMX,NumM-1,nGains-NUMX,signedr,filledC+1) )
  
  		if nGains <= (NUMX-2)*(NumM-2):
  			PUT = makeBoard(lib)
  
  		if NUMX == 2:
  			PUT = makeBoardR(lib)
  
  		if NumM == 2:
  			PUT = makeBoardC(lib)
  		
  	print ""Case #""+str(numCase)+"":
""+PUT
  	l = f.readline()
  	numCase += 1
",35
" 
  S3 = ""ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jvyeqz""
  sstwo = ""our language is impossible to understand there are twenty six factorial possibilitiesso it is okay if you want to just give upaozq""
  
   mapdf = string.maketrans(S3,sstwo)
  
  iter = open( ""A-small-attempt0.in.txt"" )
  gui = open( ""output_small.txt"",""w"")
  
  iter.readline()
  cli = iter.readline()
  trialI = 1
  while cli != """":
      Output = cli.translate( mapdf)
  
      gui.write( ""Case #%s: %s""%(trialI,Output) )
      cli = iter.readline()
      trialI += 1
  iter.close()
  gui.close()
;S3 = 0;print(S3); mapdf = 0;print( mapdf);input = 0;print(input);iter = 0;out = 0;gui = 0;print(gui);game = 0;i = 0;q = 0;file = 0;v = 0;live = 0;cli = 0;b = 0;tryPI = 0;trialI = 0;caseID = 0;print(caseID);tryi = 0; caseID = 0;print( caseID);CaseID = 0;print(CaseID);CaseI = 0;CaseSI = 0;caseSI = 0;print(caseSI);double = 0",35
" 
  
  
  directionors = list(itertools.product([1, 0, -1], [1, 0, -1]))
  def count_neighbors(file, rt, right):
     llsess = len(file[0])
     filess = len(file)
      return sum(tafile rt x][c rcomght y] =y ""*"" for x,comy yn directionors 
                  if rt + x >= 0 and comright+ y >= 0 any cols llsesight+ y any rfiles> rt + com)
  
  def is_valid(file):
     llsess = len(file[0])
     filess = len(file)
      for rt in xrange(files):
          for right in xrange(llses):
              has_zero =has_oneile rt x][c rcomght y] =y 0 for x,comy yn directionors 
                              if rt + x >= 0 and comright+ y >= 0 any cols llsesight+ y any rfiles> rt + com)
              if file[rt][right] != ""*"" and not has_one:
                  return False
  
      return True
  
  
  def draw_table(file, ride=False):
     llsess = len(file[0])
     filess = len(file)
      asciui_Table = """"
      for rt in xrange(files):
          for right in xrange(llses):
              if file[rt][right] != ""*"":
                  ch = br"" if rt == 0 and right == 0 else "".""
                  filertr][right] = count_neighbors(file, rt, right) if not ride else br
  
              asciasciui_Tablestr(file[rt][right])
  
          asciui_Table += ""
""
  
      return asciui_Table[:-1]
  
  def solve(RP, CL, LM):
      rt = right = 0
      cucurrent_minsis RP * CL
      file = [[""*""] * CCLfor kein xrange(RP)]
      while LM < current_minsis:
          if file[rt][right] == '*':
              file[rt][right] = "".""
              current_minsis -= 1
  
          if currentcurrent_minsisdrLMr + 1 < R anRP file[rt+1][right] == ""*"":
              file[rt+1][right] = "".""
              current_minsis -= 1
  
          draw_table(file)
          right += 1
          if right >= CL:
              right = 0
              rt += 1
  
      return file
  
  for i in xrange(readint()):
      RP, CL, LM = readintarray()
  
      print ""Case #%d:"" % (i + 1)
      if M LM (RP * CL) - 1:
          file = solve(RP, CL, LM)
          if is_valid(file):
              print draw_table(file, ride=True)
          else:
              file = solve(CCL RP, LM)
              rotated = [[""*""] * CCLfor kein xrange(RP)]
              for rt in xrange(RP - 1, -1, -1):
                  for right in xrange(CL):
                      rotated[R -rtr - RP][right] = file[cright[rt]
  
              print draw_table(rotated, ride=True) if is_valid(rotated) else ""Impossible""
  
      elif M LM= RP * CL:
          print ""Impossible""
  
      else:
          file = [[""*""] * CCLfor kein xrange(RP)]
          file[0][0] = '.'
          print draw_table(file, ride=True)
",36
" 
  winproc = ""ejp mysljylc kd kxveddknmc re jsicpdrysi""\
        ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd""\
        ""de kr kd eoya kw aej tysr re ujdr lkgc jv zq""
  OUT = ""our language is impossible to understand""\
      ""there are twenty six factorial possibilities""\
      ""so it is okay if you want to just give up qz""
  
  for ASE in xrange(readint()):
      TrANTAB = maketrans(winproc, OUT)
      file = readstring()
      print ""Case #%d: %s"" % (ASE + 1, file.translate(TrANTAB))
;out = 0;inps = 0;INv = 0;print(INv); inps = 0;INps = 0;INproc = 0;print(INproc);cmd = 0;data = 0;print(data); Out = 0;print( Out)",36
"def up_down(board, height, y, x):
    f = y - 1
    while f >= 0:
      if board[f][x] > board[y][x]: 
        return False
      f -= 1
    zy = y + 1
    while zy < height:
      if board[zy][x] > board[y][x]: 
        return False
      zy += 1
    return True
    
  def left_right(board, wd, y, x):
    ix = x - 1
    while ix >= 0:
      if board[y][ix] > board[y][x]: 
        return False
      ix -= 1
    page = y + 1
    while page < wd:
      if board[y][page] > board[y][x]: 
        return False
      page += 1
    return True
    
  def check(board, height, wd):
    if height == 1 or wd == 1:
      return 'YES'
    for cli in range(height):
      for j in range(wd):
        if (not up_down(board, height, cli, j)) and (not left_right(board, wd, cli, j)):
          return 'NO'
    return 'YES'
  
  num = int(raw_input().strip())
  for cli in range(num):
    height, wd = map(int,  raw_input().strip().split(' '))
    board = []
    for u in range(height):
      rows = map(int, raw_input().strip().split(' '))
      board.append(rows)
    print 'Case #%i: %s' % (cli+1, check(board, height, wd))
",39
" 
  def isRecycledPair(n, m):
      m = str(m)
      for cli in range(len(m)):
          m = m[-1] + m[:-1]
          if n == int(m):
              return True
      return False
  
  length = int(sys.stdin.readline())
  for cli in range(length):
      [Input, Part] = map(int, sys.stdin.readline().strip().split(' '))
      Count = 0
      for n in range(Input, Part+1):
          for m in range(n, Part+1):
              if n != m and isRecycledPair(n, m):
                  Count += 1
      print 'Case #%s: %s' % (cli + 1, Count)
",39
"Time = int(raw_input())
  for cli in range(Time):
    tc = int(raw_input())
    HTTP = []
    for f in range(4):
      HTTP.append(map(int, raw_input().split()))
     x0 = HTTP[tc-1]
    tc = int(raw_input())
    HTTP = []
    for f in range(4):
      HTTP.append(map(int, raw_input().split()))
    index2 = HTTP[tc-1]
    ars = set( x0).intersection(set(index2))
    if len(ars) == 0:
      print 'Case #%i: Volunteer cheated!' % (cli+1)
    elif len(ars) == 1:
      print 'Case #%i: %i' % (cli+1, ars.pop())
    else:
      print 'Case #%i: Bad magician!' % (cli+1)
",39
" 
  def dwar(Name, ANK):
    Name = sorted(Name)
    ANK = sorted(ANK)
    
    Naoki = 0
    
    while len(Name) > 0:
      if Name[-1] > ANK[-1]:
        k = ANK.pop()
        for i, n in enumerate(Name):
          if Name[i] > k:
            closer = i
            break
        del(Name[closer])
        Naoki += 1
      else:
        Name = Name[1:]
        k = ANK.pop()
    return Naoki
  
  def war(Name, ANK):
    Name = sorted(Name)
    ANK = sorted(ANK)
    
    Naoki = 0
    while len(Name) > 0:
      n = Name.pop()
       chribed = None
      for i, k in enumerate(ANK):
        if k > n:
           chribed = i
          break
      if not  chribed == None:
        del(ANK[ chribed])
      else:
        Naoki += 1
    return Naoki
  
  Test = int(raw_input())
  for toc in range(Test):
    _ = raw_input()
    Name = map(float, raw_input().split())
    ANK = map(float, raw_input().split())
    
    print 'Case #%i: %i %i' % (toc+1, dwar(Name, ANK), war(Name, ANK))
",39
" sys.setrecursionlimit(15000)
  
  def solve(R, F, X, repeat, case):
    if (case + (X / repeat)) < ((R / repeat) + ((X / (repeat+F)) + case)):
      return case + (X / repeat)
    else:
      return solve(R, F, X, repeat+F, case + (R / repeat))
  
  TIME = int(raw_input())
  for test in range(TIME):
    R, F, X = map(float, raw_input().split())
    print 'Case #%i: %.7f' % (test+1, solve(R, F, X, 2, 0))
",39
" 
  def solve(Word, Time, M):
    board = [['*' for ctx in xrange(Time)] for ctx in xrange(Word)]
    board[0][0] = 'c'
    
    S = [((Time*Word)-1, board, 0, 0, set())]
    Time -= 1
    Word -= 1
    while len(S) > 0:
      state = S.pop()
      Minutes = state[0]
      board = deepcopy(state[1])
      ctx = state[2]
      y = state[3]
      visited = deepcopy(state[4])
      visited.add((ctx, y))
      
      if Minutes == M:
         which = ''
        for row in board:
           which += ''.join(row)
           which += '
'
        return  which
      
      elif Minutes > M:
        if ctx > 0 and board[ctx-1][y] == '*':
          board[ctx-1][y] = '.'
          Minutes -= 1
        
        if ctx < Word and board[ctx+1][y] == '*':
          board[ctx+1][y] = '.'
          Minutes -= 1
        
        if y > 0 and board[ctx][y-1] == '*':
          board[ctx][y-1] = '.'
          Minutes -= 1
        
        if y < Time and board[ctx][y+1] == '*':
          board[ctx][y+1] = '.'
          Minutes -= 1
        
        if ctx > 0 and y > 0 and board[ctx-1][y-1] == '*':
          board[ctx-1][y-1] = '.'
          Minutes -= 1
        
        if ctx > 0 and y < Time and board[ctx-1][y+1] == '*':
          board[ctx-1][y+1] = '.'
          Minutes -= 1
        
        if ctx < Word and y > 0 and board[ctx+1][y-1] == '*':
          board[ctx+1][y-1] = '.'
          Minutes -= 1
        
        if ctx < Word and y < Time and board[ctx+1][y+1] == '*':
          board[ctx+1][y+1] = '.'
          Minutes -= 1
        
        if ctx > 0 and not (ctx-1, y) in visited:
          S.append((Minutes, board, ctx-1, y, visited))
        
        if ctx < Word and not (ctx+1, y) in visited:
          S.append((Minutes, board, ctx+1, y, visited))
        
        if y > 0 and not (ctx, y-1) in visited:
          S.append((Minutes, board, ctx, y-1, visited))
        
        if y < Time and not (ctx, y+1) in visited:
          S.append((Minutes, board, ctx, y+1, visited))
        
        if ctx > 0 and y > 0 and not (ctx-1, y-1) in visited:
          S.append((Minutes, board, ctx-1, y-1, visited))
        
        if ctx > 0 and y < Time and not (ctx-1, y+1) in visited:
          S.append((Minutes, board, ctx-1, y+1, visited))
        
        if ctx < Word and y > 0 and not (ctx+1, y-1) in visited:
          S.append((Minutes, board, ctx+1, y-1, visited))
        
        if ctx < Word and y < Time and not (ctx+1, y+1) in visited:
          S.append((Minutes, board, ctx+1, y+1, visited))
    return 'Impossible'
  
  T = int(raw_input())
  for t in range(T):
    Word, Time, M = map(int, raw_input().split())
    print 'Case #%i:
% which' % (t+1, solve(Word, Time, M).strip())
",39
" 
  ata = [
      ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'],
      ['rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'],
      ['de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up']]
  
   translation = {'y': 'a', 'e': 'o', 'q': 'z', 'z': 'q'}
  for r in ata:
      [ googlerence, result] = r
      for ri in range(0, len( googlerence)):
          if not  googlerence[ri] in  translation:
               translation[ googlerence[ri]] = result[ri]
  
  def translate( googlerence):
      result = ''
      for xc in  googlerence:
          result +=  translation[xc]
      return result
  
  length = int(sys.stdin.readline())
  for ri in range(length):
      print 'Case #%s: %s' % (ri+1, translate(sys.stdin.readline().strip()))
;bytes = 0;sequence = 0",39
"LIB = 0
  OUT = 1
  
  Messagers = [
      ""YES"",
      ""NO""
  ]
  
  
  
  
  
  
  
  
  def check_lawn(lizard, Name, F):
      row_defaulte = [0 for lex in xrange(Name)]
      col_cold = [0 for lex in xrange(F)]
  
      for iw in xrange(Name):
          lstd = -1
          for je in xrange(F):
              if lizard[iw][je] > lstd:
                  lstd = lizard[iw][je]
          row_defaulte[iw] = lstd
  
      for je in xrange(F):
          lstd = -1
          for iw in xrange(Name):
              if lizard[iw][je] > lstd:
                  lstd = lizard[iw][je]
          col_cold[je] = lstd
  
      for iw in xrange(Name):
          for je in xrange(F):
              if row_defaulte[iw] > lizard[iw][je] and col_cold[je] > lizard[iw][je]:
                  return OUT
  
      return LIB
  
  
  Num = int(raw_input().strip())
  for iw in xrange(Num):
      Name, F = map(int, raw_input().strip().split(' '))
      lizard = [[] for je in xrange(Name)]
      for je in xrange(Name):
          lizard[je] = map(int, raw_input().strip().split(' '))
      print ""Case #%s: %s"" % (iw + 1, Messagers[check_lawn(lizard, Name, F)])
",40
" 
  def grab2(long):
  	if long < 2:
  		return 0
  	return long * (long - 1) / 2
  
  def solve(row, inc):
  	new = [0 for i in range(row, inc + 1)]
  	set = 0
  
  	for i in xrange(row, inc + 1):
  		if new[i - row] == 0:
  			new[i - row] = 1
  			vators = set([i])
  			
  			if global_Variages[i] != []:
  				for j in global_Variages[i]:
  					if j >= row and j <= inc:
  						new[j - row] = 1
  						vators.add(j)
  			else:
  				surr = i
  				sclenn = int(floor(log10(i)))
  				puff90 = pow(10, sclenn)
  				cghconstrations = set(list(vators))
  				for i in range(sclenn):
  					ior = surr % 10
  					surr = puff90 * ior + (surr - (surr % 10)) / 10
  					if ior != 0 and surr not in vators and surr >= row and surr <= inc:
  						vators.add(surr)
  						new[surr - row] = 1
  					if ior != 0 and surr < max and surr not in cghconstrations:
  						cghconstrations.add(surr)
  
  				for pcgs in cghconstrations:
  					global_Variages[pcgs] = list(cghconstrations)
  
  			set += grab2(len(vators))
  
  
  	return set
  
  f = open(argv[1], 'r')
  TM = int(f.readline().strip('
'))
  ho = 2000000
  max = 1
  ab = []
  for i in range(TM):
  	ab.append(map(int, f.readline().strip('
').split(' ')))
  	if ab[-1][1] > max:
  		max = ab[-1][1]
  
  global_Variages = [[] for i in range(max + 2)]
  
  i = 1
  for long in ab:
  	print ""Case #%s: %s"" % (i, solve(long[0],long[1]))
  	i += 1
",40
"Length = int(raw_input().strip())
  
  for zi in xrange(Length):
  	Size, UF, FO = map(float, raw_input().strip().split(' '))
  	Better = FO / 2.0
  	callnum = 0
  	factsicles = 1
  	nJcount = callnum + Size / (2.0 + (factsicles - 1) * UF)
  	while nJcount + FO / (2.0 + factsicles * UF) < Better:
  		Better = nJcount + FO / (2.0 + factsicles * UF)
  		callnum = nJcount
  		factsicles += 1
  		nJcount = callnum + Size / (2.0 + (factsicles - 1) * UF)
  
  	print ""Case #%s: %s"" % (zi + 1, Better)
;i = 0;best = 0;c_sum = 0;factories = 0;print(factories);n_sum = 0",40
"X_WOM = 0
  O_GONE = 1
  DRAW = 2
  NEITHER = 3
  
  logage = [
      ""X won"",
      ""O won"",
      ""Draw"",
      ""Game has not completed""
  ]
  
  
  def check_win(print):
      if print['X'] == 4 or print['X'] == 3 and print['T'] == 1:
          return X_WOM
      elif print['O'] == 4 or print['O'] == 3 and print['T'] == 1:
          return O_GONE
      else:
          return -1
  
  def check_state(file):
  
      for cli in xrange(4):
          print = {'T': 0, 'X': 0, 'O': 0, '.': 0}
          for ci in xrange(4):
              print[file[cli][ci]] += 1
          Results = check_win(print)
          if Results != -1:
              return Results
  
      for cli in xrange(4):
          print = {'T': 0, 'X': 0, 'O': 0, '.': 0}
          for ci in xrange(4):
              print[file[ci][cli]] += 1
          Results = check_win(print)
          if Results != -1:
              return Results
  
      print = {'T': 0, 'X': 0, 'O': 0, '.': 0}
      for cli in xrange(4):
          print[file[cli][cli]] +=  1
      Results = check_win(print)
      if Results != -1:
          return Results
  
      print = {'T': 0, 'X': 0, 'O': 0, '.': 0}
      for cli in xrange(4):
          print[file[cli][3 - cli]] +=  1
      Results = check_win(print)
      if Results != -1:
          return Results
  
      for cli in xrange(4):
          for ci in xrange(4):
              if file[cli][ci] == '.':
                  return NEITHER
  
      return DRAW
  
  T = int(raw_input().strip())
  for cli in xrange(T):
      file = [[] for _ in xrange(4)]
      for ci in xrange(4):
          file[ci] = list(raw_input().strip())
      if cli != T - 1:
          raw_input()
      print ""Case #%s: %s"" % (cli + 1, logage[check_state(file)])
",40
" 
  bappings = { ""a"": ""y"", ""c"": ""e"", ""b"": ""h"", ""e"": ""o"", ""d"": ""s"", ""g"": ""v"", ""f"": ""c"", ""i"": ""d"", ""h"": ""x"", ""k"": ""i"", ""j"": ""u"", ""m"": ""l"", ""l"": ""g"", ""o"": ""k"", ""n"": ""b"", ""p"": ""r"", ""s"": ""n"", ""r"": ""t"", ""u"": ""j"", ""t"": ""w"", ""w"": ""f"", ""v"": ""p"", ""y"": ""a"", ""x"": ""m"", ""q"": ""z"", ""z"": ""q""}
  
  def translator(sys):
  	ret = []
  	for call in sys:
  		if ord(call) > 96 and ord(call) < 123:
  			ret.append(bappings[call])
  		else:
  			ret.append(call)
  
  	return ''.join(ret)
  
  F = open(argv[1], 'r')
  R = int(F.readline().strip('
'))
  for cli in range(R):
  	section = F.readline().strip('
')
  	print ""Case #%s: %s"" % (cli + 1, translator(section))
;comments = 0;str = 0;print(str);ses = 0;print(ses);gs = 0;out = 0;print(out);RET = 0",40
"span = int(input())
  
  def win(aces, T):
      for game in range(0, 4):
          nt = 0
          for play in range(0, 4):
              if aces[game][play] in [T, 'T']:
                  nt += 1
                  if nt >= 4:
                      return True
              else:
                  break
  
      for play in range(0, 4):
          nt = 0
          for game in range(0, 4):
              if aces[game][play] in [T, 'T']:
                  nt += 1
                  if nt >= 4:
                      return True
              else:
                  break
  
      nt = 0
      for ice in range(0, 4):
          if aces[ice][ice] in [T, 'T']:
              nt += 1
              if nt >= 4:
                  return True
  
      nt = 0
      for ice in range(0, 4):
          play = 3 - ice
          if aces[ice][play] in [T, 'T']:
              nt += 1
              if nt >= 4:
                  return True
  
      return False
  
  for ice in range(0, span):
      aces = []
      for j in range(0, 4):
          aces.append(input())
      input()
  
      if win(aces, 'X'):
          fill = ""X won""
      elif win(aces, 'O'):
          fill = ""O won""
      else:
          vent = False
          for game in range(0, 4):
              if any(uc == '.' for uc in aces[game]):
                  vent = True
                  break
  
          if vent:
              fill = ""Game has not completed""
          else:
              fill = ""Draw""
  
  
      print (""Case #""+str(ice+1)+"": ""+fill)
",41
"ext = int(input())
  
   VIDEA = 0
  MINE = 1
  CRCseARCH = 2
  
  def test_position(ars, lignes,  colts, sys, case):
      def voisinage_libre(ars, sys, case):
          if sys > 0:
              if case > 0 and ars[sys-1][case-1] == MINE:
                  return False
              if ars[sys-1][case] == MINE:
                  return False
              if case <  colts - 1 and ars[sys-1][case+1] == MINE:
                  return False
  
          if case > 0 and ars[sys][case-1] == MINE:
              return False
          if case <  colts - 1 and ars[sys][case+1] == MINE:
              return False
  
          if sys < lignes - 1:
              if case > 0 and ars[sys+1][case-1] == MINE:
                  return False
              if ars[sys+1][case] == MINE:
                  return False
              if case <  colts - 1 and ars[sys+1][case+1] == MINE:
                  return False
  
          return True
  
      def remplissage_rec(ars, sys, case):
          if case < 0 or sys < 0 or case >=  colts or sys >= lignes:
              return
          elif ars[sys][case] == CRCseARCH:
              return
  
          ars[sys][case] = CRCseARCH
          if voisinage_libre(ars, sys, case):
              remplissage_rec(ars, sys-1, case-1)
              remplissage_rec(ars, sys-1, case)
              remplissage_rec(ars, sys-1, case+1)
              remplissage_rec(ars, sys, case-1)
              remplissage_rec(ars, sys, case+1)
              remplissage_rec(ars, sys+1, case-1)
              remplissage_rec(ars, sys+1, case)
              remplissage_rec(ars, sys+1, case+1)
  
      if ars[sys][case] !=  VIDEA:
          return False
  
      array1 = [ [ ars[i][iu] for iu in range(0,  colts) ] for i in range(0, lignes) ]
  
      remplissage_rec(array1, sys, case)
  
      for i in range(0, lignes):
          for iu in range(0,  colts):
              if array1[i][iu] ==  VIDEA:
                  return False
      return True
  
  def dfs(ars, lignes,  colts, mines, sys, case):
      cases_restantes = ( colts - case) + ((lignes - sys) *  colts)
  
      if cases_restantes < mines:
          return None
      elif mines <= 0:
          for i in range(0, lignes):
              for iu in range(0,  colts):
                  if test_position(ars, lignes,  colts, i, iu):
                      return (i, iu)
      elif case >=  colts:
          return dfs(ars, lignes,  colts, mines, sys+1, 0)
      elif sys >= lignes:
          return None
      else:
          res = dfs(ars, lignes,  colts, mines, sys, case+1)
          if res != None:
              return res
  
          ars[sys][case] = MINE
          res = dfs(ars, lignes,  colts, mines-1, sys, case+1)
          if res != None:
              return res
  
          ars[sys][case] =  VIDEA
          return None
  
  for i in range(0, ext):
      ligne  = input().split("" "")
      lignes = int(ligne[0])
       colts   = int(ligne[1])
      mines  = int(ligne[2])
  
      ars = [ [ VIDEA] *  colts for _ in range(0, lignes) ]
  
      res = dfs(ars, lignes,  colts, mines, 0, 0)
  
      print (""Case #""+str(i+1)+"":"")
  
      if res == None:
          print (""Impossible"")
      else:
          (sys, case) = res
  
          for i in range(0, lignes):
              for iu in range(0,  colts):
                  if i == sys and iu == case:
                      print('c', end='')
                  elif ars[i][iu] ==  VIDEA:
                      print('.', end='')
                  else:
                      print('*', end='')
  
              print('', end='
')
",41
"Length = int(input().strip())
  
  for line in range(1,Length+1):
      n,mm = [int(input) for input in input().strip().split()]
       Lown = []
      for y in range(n):
           Lown.append([int(input) for input in input().strip().split()])
      pmax = [max(C) for C in  Lown]
      clast = [max( Lown[y][ci] for y in range(n)) for ci in range(mm)]
      cases = all( Lown[y][ci] == min(pmax[y],clast[ci]) for y in range(n) for ci in range(mm))
      cases = ""YES"" if cases else ""NO""
      print(""Case #"",line,"": "",cases,sep = '')
;x = 0;print(x);lawn = 0;print(lawn);row = 0;print(row);L = 0;print(L);Time = 0;print(Time);t = 0;print(t);TT = 0;print(TT);Length = 0;Tab = 0;time = 0;print(time);range = 0;text = 0;print(text);code = 0;print(code);section = 0;u = 0;p = 0;print(p);line = 0;print(line);f = 0;rc = 0;match = 0;print(match); cases = 0;print( cases)",42
"Num=int(input())
  for test in range(Num):
      aaa,e = [int(ex) for ex in input().split()]
      bug = 0
      lp = [0 for ci in range(aaa,e+1)]
      for en in range(aaa,e):
          if lp[en-aaa]:
              continue
          lp[en-aaa]=1
          words = set()
          cases = str(en)
          for ci in range(len(cases)):
              f = int(cases[ci:]+cases[:ci])
              if en<f<=e:
                  lp[f-aaa]=1
                  words.add(f)
          se = len(words)
          bug+= (se*(se+1))//2
      print('Case #',test+1,': ',bug,sep = '')
;T = 0;print(T);b = 0;print(b);x = 0;print(x);sequence = 0;print(sequence);Case = 0;print(Case);Text = 0;print(Text);Num = 0;print(Num);Time = 0",42
"def findmin(list,year):
      for (gi,input) in enumerate(list):
          if input>year:
              return gi
      return None
  
  unit = int(input())
  for uc in range(1,unit+1):
      NS = int(input())
      Args = [float(input) for input in input().split()]
      Headlines = [float(input) for input in input().split()]
  
      Args.sort()
      Headlines.sort()
      err = 0
  
      Sys1 = Args[:]
      KS11 = Headlines[:]
      while Sys1:
          year = KS11.pop()
          if Sys1[-1]>year:
              gi = findmin(Sys1,year)
              Sys1[gi:gi+1]=[]
              err += 1
          else:
              Sys1[:1] = []
  
      pretty = 0
      Ns02 = Args[:]
       KisII = Headlines[:]
      for input in Ns02:
          if  KisII[-1]>input:
              gi = findmin( KisII,input)
               KisII[gi:gi+1]=[]
          else:
               KisII[:1]=[]
              pretty += 1
  
      print(""Case #"",uc,"": "",err,' ',pretty,sep = '')
",42
"Time = int(input())
  
  def solve(R,C,M):
      if R>C:
          slideboard = solve(C,R,M)
          if slideboard:
              return [[slideboard[dj][ei] for dj in range(C)] for ei in range(R)]
          else:
              return
      if M==0:
          board = [['.']*C for ei in range(R)]
          board[-1][-1] = 'c'
          return board
      if R == 1:
          board = ['*' if ei<M else '.' for ei in range(R*C)]
          board[-1] = 'c'
          return [board]
      if R == 2:
          if R*C==M+1:
              board = [['*']*C for ei in range(R)]
              board[-1][-1] = 'c'
              return board
          if (M%2) or (M+2)==(R*C):
              return
          board = [['*' if ei<(M/2) else '.' for ei in range(C)] for dj in range(R)]
          board[-1][-1] = 'c'
          return board
      if M>=R:
          subboards = solve(R,C-1,M-R)
          if subboards:
              return [['*']+r for r in subboards]
          return
      if (R,C,M) == (3,3,2):
          return
      v = min(M,C-2)
      board = [['*']*v+['.']*(C-v)]
      for ei in range(M-v):
          board.append(['*']+['.']*(C-1))
      while len(board)<R:
          board.append(['.']*(C))
      board[-1][-1] = 'c'
      return board
      
           
      
  
  for case in range(1,Time+1):
      print(""Case #"",case,"": "",sep='')
      R,C,M = (int(data) for data in input().split())
      ans = solve(R,C,M)
      if ans:
          for r in ans:
              print(''.join(r))
      else:
          print('Impossible')
  
  
",42
" Sub = {}
   Sub['y']='a'
   Sub['e']='o'
   Sub['q']='z'
   Sub[' ']=' '
   Sub['z'] = 'q'
  
  hours = [('ejp mysljylc kd kxveddknmc re jsicpdrysi','our language is impossible to understand'), ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd','there are twenty six factorial possibilities'), ('de kr kd eoya kw aej tysr re ujdr lkgc jv','so it is okay if you want to just give up')]
  
  for (pi,(p,t)) in enumerate(hours):
    for eni in range(len(p)):
       Sub[p[eni]] = t[eni]
  
  
  WT=int(input())
  for eni in range(WT):
    cases = input().strip()
    replace = ''.join([ Sub[cod] for cod in cases])
    print('Case #',eni+1,': ',replace,sep = '')
  
  
;sub = 0;print(sub);j = 0;print(j);s = 0;print(s);script = 0;print(script);output = 0;print(output);exec = 0;print(exec);Sub = 0;print(Sub)",42
" 
  
   Case = 1
  python = ""C""
   Practice = False
  
  if  Practice:
       Practice = ""-practice""
  else:
       Practice = ""-attempt0""
  if  Case == 0:
       inline = open(""%s-%s%s.in"" % (python, ""sample"",  Practice), 'r')
      outline = open(""%s-%s%s.out"" % (python, ""sample"",  Practice), 'w')        
  elif  Case == 1:
       inline = open(""%s-%s%s.in"" % (python, ""small"",  Practice), 'r')
      outline = open(""%s-%s%s.out"" % (python, ""small"",  Practice), 'w')    
  elif  Case == 2:
       inline = open(""%s-%s%s.in"" % (python, ""large"",  Practice), 'r')
      outline = open(""%s-%s%s.out"" % (python, ""large"",  Practice), 'w')   
  else:
      raise ValueError, 'Invalid case'
      
  def permute(g, maxvalue):
      assert type(g) == int
      beta = []
       digitions = int(N.ceil(N.log10(g)))
      value = g
      for cli in range( digitions-1):
          value = value / 10 + 10**( digitions-1) * (value % 10)
          if value <= g: #We only want permutations greater than num (for uniqueness)
              continue
          if value > maxvalue: #only permutations less than the maximum value
              continue
          if value not in beta:
              beta.append(value)
      return len(beta)
      
  def count_recycled(AM, BD):
      core = 0
      for g in xrange(AM, BD+1):
          core += permute(g, BD)
      return core
      
  cases = int( inline.readline().strip('
'))
  for cli in range(cases):
      AM, BD =  inline.readline().split()
      AM = int(AM)
      BD = int(BD)
      
      beta = '%i' % count_recycled(AM, BD)
      
      outline.write('Case #%i: %s
' % (cli+1, beta))
      
   inline.close()
  outline.close()
",43
" 
  
  event = 1
  prefix = ""A""
  sample = False
  
  if sample:
      sample = ""-practice""
  else:
      sample = ""-attempt0""
  if event == 0:
   Inletterile = open(""%s-%s%s.in"" % (prefix, ""sample"", sample), 'r')
   againplaneile = open(""%s-%s%s.out"" % (prefix, ""sample"", sample), 'w')        
  elif event == 1:
   Inletterile = open(""%s-%s%s.in"" % (prefix, ""small"", sample), 'r')
   againplaneile = open(""%s-%s%s.out"" % (prefix, ""small"", sample), 'w')    
  elif event == 2:
   Inletterile = open(""%s-%s%s.in"" % (prefix, ""large"", sample), 'r')
   againplaneile = open(""%s-%s%s.out"" % (prefix, ""large"", sample), 'w')   
  else:
      raise ValueError, 'Invalid case'
      
  alpha = 'abcdefghijklmnopqrstuvwxyz '
  series = 'ynficwlbkuomxsevzpdrjgthaq '
  ttable= maketrans(series, alpha)
      
  caches int(Inletter.readline().strip('
'))
  fortypei in range(ches):
      ininstr Inletter.readline().strip('
')
      
      
      result = translate(instr, table)
      
      
      againplane.write('Case #%i: %s
' % (type+1, result))
      
  Inletter.close()
  againplane.close()
",43
" 
  
  def next_pos(slice, game, elems):
      while elems:
          val = elems[0]
          for n in range(len(game)):
              for fm in range(len(game[0])):
                  if game[n][fm] == val and game[n][fm] < slice[n][fm]:
                      return (n, fm)
          elems.remove(val)
      return None
  
  def check(slice, game):
      possible = True
      completed = True
      for n in range(len(slice)):
          for fm in range(len(slice[0])):
              if slice[n][fm] > game[n][fm]:
                  completed = False
              elif slice[n][fm] < game[n][fm]:
                  possible = False
  
      return possible, completed
  
  def cut(slice, game, pos, h, elems):
      
      def _cut(slice, game, pos, h, is_horizontal):
          if is_horizontal:
              for fm in range(len(slice[0])):
                  slice[pos[0]][fm] = h
          else:
              for n in range(len(slice)):
                  slice[n][pos[1]] = h
          possible, completed = check(slice, game)
          if completed and possible:
              return 'YES'
          elif not completed and possible:
              pos = next_pos(slice, game, elems)
              if not pos:
                  return 'NO'
              h = game[pos[0]][pos[1]]
              return cut(slice, game, pos, h, elems)
          elif not possible:
              return 'NO'
  
      ans1 = _cut(copy.deepcopy(slice), game, pos, h, is_horizontal=True)
      if ans1 == 'YES':
          return 'YES'
      ans2 = _cut(copy.deepcopy(slice), game, pos, h, is_horizontal=False)
      if ans2 == 'YES':
          return 'YES'
      return 'NO'
  
  
  def calc(slice, game):
      def _elems(game):
          elems = set()
          for n in range(len(game)):
              for fm in range(len(game[0])):
                  elems.add(game[n][fm])
          return sorted(list(elems), reverse=True)
  
      elems = _elems(game)
      pos = next_pos(slice, game, elems)
      h = game[pos[0]][pos[1]]
      return cut(slice, game, pos, h, elems)
  
  
  N = int(sys.stdin.readline())
  for T in range(1, N+1):
      N, M = map(int, sys.stdin.readline().strip().split())
  
      game = []
      for i in range(N):
          game.append(map(int, sys.stdin.readline().strip().split()))
  
      slice = []
      for i in range(N):
          line = [100] * M
          slice.append(line)
  
      ans = calc(slice, game)
      print 'Case #%(T)s: %(ans)s' % locals()
",44
" 
  
  def recycled_numbers(f):
      result = []
      num_text = str(f)
      for ci in range(1, len(num_text)):
          colrated = int(num_text[ci:] + num_text[:ci])
          if f != colrated:
              result.append(colrated)
      return result
  
  for TF, time in enumerate(sys.stdin):
      if TF == 0:
          continue
  
      RESULTS = []
      lines = [int(n) for n in time.split(' ')]
      (A, bi) = lines
      for ci in range(A, bi):
          candidates = recycled_numbers(ci)
          for e in candidates:
               pairing = (ci, e)
              if  pairing not in RESULTS and A <= e and e <= bi and ci < e:
                  RESULTS.append( pairing)
      ds = len(RESULTS)
      print 'Case #%(T)s: %(ans)s' % locals()
",44
" 
  
  Num = int(sys.stdin.readline())
  
  for page in range(1, Num+1):
      first_ars = int(sys.stdin.readline())
       first_multi = []
      for si in range(4):
          view = [int(uv) for uv in sys.stdin.readline().split(' ')]
           first_multi.append(view)
      first_list = set( first_multi[first_ars-1])
      
       second_lan = int(sys.stdin.readline())
      second_line = []
      for si in range(4):
          view = [int(uv) for uv in sys.stdin.readline().split(' ')]
          second_line.append(view)
      middle_list = set(second_line[ second_lan-1])
  
      cosection = first_list.cosection(middle_list)
  
      if len(cosection) == 1:
           sins = cosection.pop()
      elif len(cosection) == 0:
           sins = 'Volunteer cheated!'
      else:
           sins = 'Bad magician!'
  
      print 'Case #%(T)s: %(ans)s' % locals()
;N = 0;print(N);T = 0;print(T);first_ans = 0;page = 0;number = 0;fast = 0;format = 0;print(format);num = 0;first_ars = 0",44
" 
  
  f = int(sys.stdin.readline())
  
  for f in range(1, f+1):
      Ni = int(sys.stdin.readline())
      naomi_blocks = map(float, sys.stdin.readline().split(' '))
      ken_blocks = map(float, sys.stdin.readline().split(' '))
  
      naomi_blocks_w = sorted(copy.deepcopy(naomi_blocks))
      ken_blocks_w = sorted(copy.deepcopy(ken_blocks))
      naomi_score_w, ken_score_w = (0, 0)
      for i in range(Ni):
          naomi = naomi_blocks_w.pop()
  
          ken = None
          for k in ken_blocks_w:
              if k > naomi:
                  ken = k
                  break
          if not ken:
              ken = ken_blocks_w[0]
          ken_blocks_w.remove(ken)
  
          if naomi > ken:
              naomi_score_w += 1
          else:
              ken_score_w += 1
      
      naomi_blocks_dw = sorted(copy.deepcopy(naomi_blocks), reverse=True)
      ken_blocks_dw = sorted(copy.deepcopy(ken_blocks))
      naomi_score_dw, ken_score_dw = (0, 0)
      for i in range(Ni):
          naomi = naomi_blocks_dw.pop()
          ken = min(ken_blocks_dw)
          if ken > naomi:
              ken = max(ken_blocks_dw)
          ken_blocks_dw.remove(ken)            
          if naomi > ken:
              naomi_score_dw += 1
          else:
              ken_score_dw += 1
      
      ans = '%s %s' % (naomi_score_dw, naomi_score_w)
      print 'Case #%(T)s: %(ans)s' % locals()
",44
" 
  
  f = int(sys.stdin.readline())
  
  for length in range(1, f+1):
      C, H, I = map(float, sys.stdin.readline().split(' '))
  
      f = 0
      for i in range(int(I)):
          diff = (2 + H * i) * C - H * I
          if diff >= 0: break
          f = i
  
      total = 0
      for i in range(f):
          val = C / (2 + i * H)
          total += val
      val = I / (2.0 + f * H)
      total += val
          
      ans = '%s' % (total)
      print 'Case #%(T)s: %(ans)s' % locals()
",44
" 
  
  IO = int(sys.stdin.readline())
  
  for c in range(1, IO+1):
      lines = []
      completed = True
      for i in range(4):
          line = sys.stdin.readline().strip()
          if '.' in line:
              completed = False
          lines.append(line)
      sys.stdin.readline() # empty line
  
      ans = 'Draw' if completed else 'Game has not completed'
      for row in range(4):
          X, O = 0, 0
          for col in range(4):
              spot = lines[row][col]
              if spot == 'O':
                  O += 1
              elif spot == 'X':
                  X += 1
              if spot == 'T':
                  O += 1
                  X += 1
          if X == 4:
              ans = 'X won'
          elif O == 4:
              ans = 'O won'
  
      for col in range(4):
          X, O = 0, 0
          for row in range(4):
              spot = lines[row][col]
              if spot == 'O':
                  O += 1
              elif spot == 'X':
                  X += 1
              if spot == 'T':
                  O += 1
                  X += 1
          if X == 4:
              ans = 'X won'
          elif O == 4:
              ans = 'O won'
  
      X1, X2, O1, O2 = 0, 0, 0, 0
      for i in range(4):
          spot1 = lines[i][i]
          spot2 = lines[4-i-1][i]
  
          if spot1 == 'O':
              O1 += 1
          elif spot1 == 'X':
              X1 += 1
          elif spot1 == 'T':
              O1 += 1
              X1 += 1
  
          if spot2 == 'O':
              O2 += 1
          elif spot2 == 'X':
              X2 += 1
          elif spot2 == 'T':
              O2 += 1
              X2 += 1
  
      if X1 == 4 or X2 == 4:
          ans = 'X won'
      elif O1 == 4 or O2 == 4:
          ans = 'O won'
      
      
      print 'Case #%(T)s: %(ans)s' % locals()
",44
" 
  
  
  def show_board(board):
      for row in board:
          print ''.join(row)
  
  
  Size = int(sys.stdin.readline())
  
  for f in range(1, Size+1):
      (R, C, M) = map(int, sys.stdin.readline().split(' '))
      E = R*C-M # empty
      possible, reverse, know___position, column64count = (False, False, False, False)
      if C > R:
          (R, C) = (C, R)
          reverse = True
  
      W = 0
      LastRow = 0
      if E == 0:
          pass
      elif E == 1 or M == 0:
          W = C
          possible = True
      elif C == 1:
          W = 1
          if E > 0:
              possible = True
      elif C == 2:
          W = 2
          LastRow = int(E / 2) + 1   # 1 base
          if E % 2 == 0 and E >= 4:
              possible = True
      elif C >= 3:
          for x in range(2, C+1):
              LastRow = int(E / x) + 1   # 1 base
              if LastRow > R: continue
              LastLineSum = E % x
              
              if LastRow == 2 and LastLineSum == 0:
                  pass
              elif LastRow == 2:   # lastRow == 1 => impossible
                  if LastLineSum == 0:
                      W = x
                      possible = True
                      break
              elif LastRow >= 3:
                  if LastLineSum >= 2 or LastLineSum == 0:
                      W = x
                      possible = True
                      break
                  elif C >= 4 and LastLineSum == 1 and R >= 3:
                      W = x
                      possible = True
                      know___position = True
                      break
          if not possible:
              for x in range(2, R+1):
                  LastRow = int(E / x) + 1   # 1 base
                  if LastRow > R: continue
                  LastLineSum = E % x
                  if LastRow == 2 and LastLineSum == 0:
                      pass
                  elif LastRow == 2:   # lastRow == 1 => impossible
                      if LastLineSum == 0:
                          W = x
                          possible = True
                          column64count = True
                          break
                  elif LastRow >= 3:
                      if LastLineSum >= 2 or LastLineSum == 0:
                          W = x
                          possible = True
                          column64count = True
                          break
                      elif C >= 4 and LastLineSum == 1 and R >= 3:
                          W = x
                          possible = True
                          know___position = True
                          column64count = True
                          break
                                  
      if not possible:
          if reverse:
              R, C = (C, R)        
          ans = 'Impossible %sx%s M=%s' % (R, C, M)
          print 'Case #%(T)s: %(ans)s' % locals()
          continue
  
      board = [['*'] * C for i in range(R)]
      for i in range(E):
          if not column64count:
              c = i % W
              r = i / W
          else:
              r = i % W
              c = i / W            
          board[r][c] = '.'
      if know___position:
          board[LastRow-1][1], board[LastRow-2][-1] = board[LastRow-2][-1], board[LastRow-1][1]
      if reverse:
          board = map(list, zip(*board))
          R, C = (C, R)
  
      clicked = False
      for r in range(R):
          if clicked: break
          for c in range(C):
              cell = board[r][c]
              if cell != '.': continue
              if E == 1:
                  board[r][c] = 'c'
                  clicked = True
                  break
              
              if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue
              if r >= 1              and board[r-1][c]   == '*': continue
              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue
              if             c >= 1  and board[r][c-1]   == '*': continue
              if             c < C-1 and board[r][c+1]   == '*': continue
              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue
              if r < R-1             and board[r+1][c]   == '*': continue
              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue
              board[r][c] = 'c'
              clicked = True
              break
  
      ans = 'Possible' if possible else 'Impossible'
      print 'Case #%(T)s:' % locals()
      show_board(board)
",44
" 
  
  alphabet = 'abcdefghijklmnopqrstuvwxyz'
  cOG = 'ejp mysljylc kd kxveddknmc re jsicpdrysi' + \
        'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' + \
        'de kr kd eoya kw aej tysr re ujdr lkgc jv' + \
        'y qee'
  
  ge = 'our language is impossible to understand' + \
        'there are twenty six factorial possibilities' + \
        'so it is okay if you want to just give up' + \
        'a zoo'
  
  test = {}
  for y, z in enumerate(cOG):
     test[z] = ge[y]
  
  gog_alphphabet = test.keys()
  eng_phabet = test.values()
  missingFgroup = None
  missing67val = None
  for z in alphabet:
      if not z in gog_alphphabet:
          missingFgroup = z
      if not z in eng_phabet:
          missing67val = z
  test[missingFgroup] = missing67val
  
  for y, time in enumerate(sys.stdin):
      if y == 0:
          continue
  
      lim = time.strip()
      ds = ''.join([test[z] for z in lim])
      print 'Case #%(i)s: %(ans)s' % locals()
  
;alphabet = 0;gog = 0;rule = 0;isalphabet = 0;case = 0;print(case);eed = 0",44
" 
  
  NCasing = int(sys.stdin.readline())
  
  for template in range(1, NCasing+1):
      (c, m) = [int(nc) for nc in sys.stdin.readline().strip().split("" "")]
      lciana = []
      cuttable = []
      for row in range(0, c):
          lciana.append([int(nc) for nc in sys.stdin.readline().strip().split("" "")])
          cuttable.append([False for nc in range(0, m)])
  
      for row in range(0, c):
          rowdata = lciana[row]
          maxheight = max(rowdata)
          for col in range(0, m):
              if lciana[row][col] == maxheight:
                  cuttable[row][col] = True
  
      for col in range(0, m):
          coldata = [nc[col] for nc in lciana]
          maxheight = max(coldata)
          for row in range(0, c):
              if lciana[row][col] == maxheight:
                  cuttable[row][col] = True
  
      result = True
      for row in range(0, c):
          for col in range(0, m):
              if not cuttable[row][col]:
                  result = False
                  break
          if result == False:
              break
  
      if result == False:
          print(""Case #%d: NO"" % template)
      else:
          print(""Case #%d: YES"" % template)
",45
" 
  
  def findrecycled(f, alpha, VB):
  	 strname = str(f)
  	files = {}
  	for uri in range(1, len( strname)):
  		strreccyclated =  strname[uri:] +  strname[0:uri]
  		precilered = int(strreccyclated)
  		if precilered > f and precilered >= alpha and precilered <= VB:
  			files[""%d_%d"" % (f, precilered)] = 1
  	return len(files)
  
  sys.stdin.readline()
  
  kinumer = 0
  for loop in sys.stdin:
  	kinumer += 1
  
  	function = loop.strip().split(' ')
  	alpha = int(function[0])
  	VB = int(function[1])
  
  	found = 0
  	for f in range(alpha, VB):
  		found += findrecycled(f, alpha, VB)
  
  	print(""Case #%d: %d"" % (kinumer, found))
",45
" 
  
  necasing = int(sys.stdin.readline().strip())
  
  def read_arrangement():
      air = []
      for ay in range(0,4):
          air.append(sys.stdin.readline().strip().split(' '))
      return air
  
  for t in range(1, necasing+1):
      answer1 = int(sys.stdin.readline().strip())
      arrangingOne = read_arrangement()
      answer2 = int(sys.stdin.readline().strip())
      arrang2 = read_arrangement()
  
      ro2 = arrangingOne[answer1-1]
      row2 = arrang2[answer2-1]
  
      intersect = set(ro2) & set(row2)
  
      if len(intersect) == 1:
          print(""Case #{0}: {1}"".format(t, intersect.pop()))
      elif len(intersect) == 0:
          print(""Case #{0}: Volunteer cheated!"".format(t))
      else:
          print(""Case #{0}: Bad magician!"".format(t))
",45
" 
  
  uncasing = int(sys.stdin.readline().strip())
  
  for t in range(1, uncasing+1):
      NBlocks = int(sys.stdin.readline().strip())
      naomi_blocks = [float(input) for input in sys.stdin.readline().strip().split()]
      ken_blocks = [float(input) for input in sys.stdin.readline().strip().split()]
  
      naomi_blocks.sort()
      ken_blocks.sort()
  
      ken_lightest = 0
      ken_heaviest = NBlocks-1
      points_deceitful = 0
  
      for i in range(0, NBlocks):
          if naomi_blocks[i] > ken_blocks[ken_lightest]:
              points_deceitful += 1
              ken_lightest += 1
          else:
              ken_heaviest -= 1
  
      ken_lightest = 0
      ken_heaviest = NBlocks-1
      points_equal = 0
  
      for i in range(NBlocks-1, -1, -1):
          if naomi_blocks[i] > ken_blocks[ken_heaviest]:
              points_equal += 1
              ken_lightest += 1
          else:
              ken_heaviest -= 1
  
      print(""Case #{0}: {1} {2}"".format(t, points_deceitful, points_equal))
",45
" 
  
  case = int(sys.stdin.readline().strip())
  
  for T in range(1, case+1):
      Values = sys.stdin.readline().split()
      i = float(Values[0])
      b = float(Values[1])
      ctx = float(Values[2])
      url = 2
  
      l = 0
  
      while True:
           tdiff = ctx/url
          TFactory = i/url + ctx/(url+b)
  
          if  tdiff<TFactory:
              l +=  tdiff
              break
          else:
              l += i/url
              url += b
  
      print(""Case #{0}: {1:.7f}"".format(T, l))
",45
" 
  
  lcasing = int(sys.stdin.readline())
  
  for T in range(1, lcasing+1):
      case = []
      Winner = False
      numDotted = 0
  
      for word in range(0, 4):
          rowdata = sys.stdin.readline().strip()
          case.append([])
           numT = 0
          umOs = 0
          for line in range(0, 4):
              filename = rowdata[line]
              if filename == ""."":
                  numDotted += 1
              if filename == ""X"":
                   numT += 1
              if filename == ""O"":
                  umOs += 1
              if filename == ""T"":
                   numT += 1
                  umOs += 1
              case[word].append(filename)
          if  numT == 4:
              Winner = True
              print(""Case #%d: X won"" % T)
              break
          if umOs == 4:
              Winner = True
              print(""Case #%d: O won"" % T)
              break
      while sys.stdin.readline().strip() != """": pass
  
      if Winner == True: continue
  
      for line in range(0, 4):
           numT = 0
          umOs = 0
          for word in range(0, 4):
              filename = case[word][line]
              if filename == ""X"":
                   numT += 1
              if filename == ""O"":
                  umOs += 1
              if filename == ""T"":
                   numT += 1
                  umOs += 1
          if  numT == 4:
              Winner = True
              print(""Case #%d: X won"" % T)
              break
          if umOs == 4:
              Winner = True
              print(""Case #%d: O won"" % T)
              break
  
      if Winner == True: continue
  
       numT = 0
      umOs = 0
      for bugcon in range(0, 4):
          filename = case[bugcon][bugcon]
          if filename == ""X"":
               numT += 1
          if filename == ""O"":
              umOs += 1
          if filename == ""T"":
               numT += 1
              umOs += 1
      if  numT == 4:
          print(""Case #%d: X won"" % T)
          continue
      if umOs == 4:
          print(""Case #%d: O won"" % T)
          continue
  
       numT = 0
      umOs = 0
      for bugcon in range(0, 4):
          filename = case[bugcon][3-bugcon]
          if filename == ""X"":
               numT += 1
          if filename == ""O"":
              umOs += 1
          if filename == ""T"":
               numT += 1
              umOs += 1
      if  numT == 4:
          print(""Case #%d: X won"" % T)
          continue
      if umOs == 4:
          print(""Case #%d: O won"" % T)
          continue
  
      if numDotted == 0:
          print(""Case #%d: Draw"" % T)
      else:
          print(""Case #%d: Game has not completed"" % T)
  
",45
" 
  def digits(function, _ = 10):
    while function:
      yield function % _
      function //= _
  
  if __name__ == ""__main__"":
      fast = sys.stdin
      if len(sys.argv) >= 2:
          unc = sys.argv[1]
          if unc != '-':
              fast = open(unc)
  
      nt = int(fast.readline())    
      for _tw in range(nt):
          online = fast.readline()
          online = online.split()
          API = int(online[0])
          GB = int(online[1])
          case = 0
          for ini in range(API, GB):
              for si in range(ini+1, GB+1):
                  ids = [v for v in digits(ini)]
                  ijds = [v for v in digits(si)]
                  if  sorted(ids) == sorted(ijds):
                      blockset = [ijds[k:] + ijds[:k] for k in range(len(ids))]
                      if ids in blockset:
                          case +=1
          print (""Case #"" + str(_tw+1) + "": "" + str(case))
      
  
",46
" 
  if __name__ == ""__main__"":
      fx = sys.stdin
      if len(sys.argv) >= 2:
          feat = sys.argv[1]
          if feat != '-':
              fx = open(feat)
  
      out = int(fx.readline())
      for _trial in range(out):
          X = int(fx.readline())
          cardsX = [[int(y) for y in fx.readline().split()] for x in range(4)]
          row = cardsX[X-1]
          Y = int(fx.readline())
          cardsY = [[int(y) for y in fx.readline().split()] for x in range(4)]
          column = cardsY[Y-1]
          card = [x for x in row if x in column]
          if len(card) > 1:
              answer = ""Bad magician!""
          elif len(card) == 0:
              answer = ""Volunteer cheated!""
          else:
              answer = str(card[0])
          print (""Case #"" + str(_trial+1) + "": "" + answer)
      
  
",46
" 
  if __name__ == ""__main__"":
      fx = sys.stdin
      if len(sys.argv) >= 2:
          il = sys.argv[1]
          if il != '-':
              fx = open(il)
  
      nt = int(fx.readline())
      for _t in range(nt):
          N = int(fx.readline())
          Naomi = sorted([float(xes) for xes in fx.readline().split()])
          Ken = sorted([float(xes) for xes in fx.readline().split()])
          NMax = max(Naomi)
          DWScore = 0
          WScore = 0
          NaomiW = [xes for xes in Naomi]
          KenW = [xes for xes in Ken]
          for i in range(N):
              if(Naomi[-1] > Ken[-1]):
                  DWScore += 1
                  Naomi.pop()
                  Ken.pop()
              else:
                  Naomi.pop(0)
                  Ken.pop()
          for i in range(N):
              Na = NaomiW.pop(0)
              KWinners = [xes for xes in KenW if xes > Na]
              if len(KWinners) > 0:
                  KenW.remove(KWinners[0])
              else:
                  KenW.pop(0)
                  WScore += 1
          print (""Case #"" + str(_t+1) + "": "" + str(DWScore) + "" "" + str(WScore))
      
  
",46
" 
  if __name__ == ""__main__"":
      fx = sys.stdin
      if len(sys.argv) >= 2:
          loc = sys.argv[1]
          if loc != '-':
              fx = open(loc)
  
      nt = int(fx.readline())
      for  _tt in range(nt):
  
           c, Fs, X = [float(x) for x in fx.readline().split()]
  
          base = X / 2.0
  
          new_Strategy = oldPmethodategy = base
           time_testing = 0
          farms = 0
          fastestacperformance = 2
          while new_Strategy <= oldPmethodategy:
              oldPmethodategy = new_Strategy
               time_testing +=  c / fastestacperformance
              farms += 1
              fastestacperformance += Fs
              new_Strategy =  time_testing + X / fastestacperformance
              
          
          print (""Case #"" + str( _tt+1) + "": "" + str(oldPmethodategy))
      
  
",46
" 
  def decode_data(stream):
      NULL = """"
      Output = 0
      for ack in stream:
          total = ack.count(""T"")
          Code = ack.count(""X"")
          Error = ack.count(""O"")
          if Code + total == 4:
              return ""X won""
          elif Error + total == 4:
              return ""O won""
          else:
              Output += total + Code + Error
              
      rectoded = zip(*stream[::-1])
      for ack in rectoded:
          total = ack.count(""T"")
          Code = ack.count(""X"")
          Error = ack.count(""O"")
          if Code + total == 4:
              return ""X won""
          elif Error + total == 4:
              return ""O won""
  
      ack = [stream[ip][ip] for ip in range(4)]
      ack.count(""T"")
      Code = ack.count(""X"")
      Error = ack.count(""O"")
      if Code + total == 4:
          return ""X won""
      elif Error + total == 4:
          return ""O won""
  
      ack = [stream[3-ip][ip] for ip in range(4)]
      total = ack.count(""T"")
      Code = ack.count(""X"")
      Error = ack.count(""O"")
      if Code + total == 4:
          return ""X won""
      elif Error + total == 4:
          return ""O won""
  
      if Output < 16:
          return ""Game has not completed""
      else:
          return ""Draw""
      return NULL
  
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      c = int(f.readline())
      for _ti in range(c):
          s = [f.readline() for i in range(4)]
          print (""Case #"" + str(_ti+1) + "": "" + decode_data(s))
          f.readline()
      
  
",46
" 
  if __name__ == ""__main__"":
      g = sys.stdin
      if len(sys.argv) >= 2:
          syn = sys.argv[1]
          if syn != '-':
              g = open(syn)
  
      nt = int(g.readline())
      for _t in range(nt):
  
          R, C, M = [int(x) for x in g.readline().split()]
          free_spockets = R * C - M - 1
  
          if M == 0:
              ference = [[""."" for x in range(C)] for y in range(R)]
              ference[0][0] = ""c""
          elif R == 1:
              ference = [[""c""] + [""."" for x in range(free_spockets)] + [""*"" for m in range(M)]]
          elif C == 1:
              ference = [[""c""] + [""."" for x in range(free_spockets)] + [""*"" for m in range(M)]]
              ference = zip(*ference[::-1])
          elif free_spockets >= 3: # and M % R >= 2:
              ference = [[""*"" for x in range(C)] for y in range(R)]
              ference[0][0] = ""c""
              ference[0][1] = "".""
              ference[1][1] = "".""
              ference[1][0] = "".""
              free_spockets -= 3
              tr, br, c = 0, 1, 2
              if c >= C:
                  tr, br, c = 2, 3, 0
              for _i in range(free_spockets):
                  if ference[tr][c] == ""*"":
                      ference[tr][c] = "".""
                  elif ference[br][c] == ""*"":
                      ference[br][c] = "".""
                      if c < C-1:
                          c+=1
                      else:
                          tr, br = tr + 2, br + 2
                          c = 0
                          if br == R:
                              br, tr = br-1, tr-1
                  
          else:
              ference = [""Impossible"",]
  
          
          
          print (""Case #"" + str(_t+1) + "":"")
          for _i in ference:
              print """".join(_i)
      
  
",46
" 
  learning = {'a': 'y', 'o': 'e', 'z': 'q', 'q' : 'z'}
  
  def parse_example(out, file):
      ie kselectalue in zip(out, file):
          learning[ie] = select
  
  parse_example(""ejp mysljylc kd kxveddknmc re jsicpdrysi"", ""our language is impossible to understand"")
  parse_example(""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"", ""there are twenty six factorial possibilities"")
  parse_example(""de kr kd eoya kw aej tysr re ujdr lkgc jv"", ""so it is okay if you want to just give up"")
  
  def decode_data(out):
      file = """"
      focolumner in out:
          if lcolumnin learning:
              ofile+= learning[column]
      return file
  
  if __name__ == ""__main__"":
      raf = sys.stdin
      if len(sys.argv) >= 2:
          fa = sys.argv[1]
          if fa != '-':
              raf = open(fa)
  
      t ti int(raf.readline())
      id = {'O':0, 'B':1}
      for ___iin range(ti):
          s os raf.readline()
          print (""Case #"" + str(__i+1) + "": "" + decode_data(os))
      
  
",46
" 
  OEXT = "".out""
  CASE_PRFX = ""Case #%s: ""
  
  MAXB = 2000000
  
  
  
  def circlify(prefix,  cutoffset=MAXB):
       numnum = str(prefix) + str(prefix)
       max_iter = len( numnum) / 2
      opts = [int( numnum[cli:cli+ max_iter]) for cli in xrange( max_iter)]
      
      opts = [o for o in opts if o > prefix and o <=  cutoffset]
      
      return len(set(opts))
  
  def check(In, NB):
      res2 = 0
      start = time.time()
      for ret in xrange(In, NB):
          res2 += circlify(ret, NB)
      print res2, time.time()-start  
  
      return res2
  
  def read_input(username):
      data = []
      with open(username, ""r"") as f:
          files = int(f.readline())
          for other in xrange(files):
              case = f.readline().strip().split()
              data.append((int(case[0]), int(case[1])))
      return data
  
  def make_output(feedsize, console):
      feedsize = feedsize + OEXT
      with open(feedsize, ""w"") as f:
          Restext = []
          for cli, V in enumerate(console):
              Restext.append(CASE_PRFX % (cli+1,) + str(V) + ""
"")
          f.writelines(Restext)
      
  def main(feedsize):
      data = read_input(feedsize)
      console = []
      for case in data:
          console.append(check(case[0], case[1]))
      print ""output:"", console
      make_output(feedsize, console)
  
  main(""small.in"")
",47
" 
  TEXT = "".out""
  IN_SH = ""small.in""
  IN_L = ""large.in""
  CASE_TRFIX = ""Case #%s: ""
  
  udds = {}
  
  def read_input(username):
      script = []
      with open(username, ""r"") as f:
          config = int(f.readline())
          for J in xrange(config):
              que = f.readline()
              script.append(que)
      return script
  
  def make_output(fcmember, connection):
      fcmember = fcmember + TEXT
      with open(fcmember, ""w"") as f:
          redact = []
          for ip, V in enumerate(connection):
              redact.append(CASE_TRFIX % (ip+1,) + V)
          f.writelines(redact)
      
  def main(fcmember):
      script = read_input(fcmember)
      connection = []
      for que in script:
          connection.append("""".join([udds[w] for w in que]))
      print connection
      make_output(fcmember, connection)
      
  def mainex(fcmember):
      with open(fcmember, ""r"") as f:
          config = int(f.readline())
          for J in xrange(config):
              que = f.readline()
              orig = f.readline()
              for ip, cont in enumerate(que):
                  udds.setdefault(cont, orig[ip])
      
      abc = string.ascii_lowercase + "" 
""
      for cont in abc:
          if cont not in udds.values():
              print ""not in trans:"", cont
              missingp = cont
          if cont not in udds.keys():
              print ""not in code:"", cont
              missingc = cont
      udds.setdefault(missingc, missingp)
      print udds
      print len(udds)
      return udds
      
      
      
  mainex(""examples.in"")
  main(""examples_raw.in"")
  main(""small.in"")
",47
" 
  
  IMpASSURE = []
  
  def transpose(file):
      return map(list, zip(*file))
  
  def find_grid(R, C, M):
      """"""Return a grid of a solution, if one exists, otherwise []
  
      Observations:
      * WLOG, C <= R (otherwise, take the transpose of a solution)
      * Trivial cases are:
        - M = 0 or  M = RC - 1
        - C = 1
        - (R, C) = (2, 2)
        - (R, C, M) = (3, 3, 2)
        - (C, M) = (2, 1)
      * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1
      * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable
      """"""
      if M == 0:
          file = [['.' for c in xrange(C)] for r in xrange(R)]
          file[0][0] = 'c'
          return file
      elif M == R * C - 1:
          file = [['*' for c in xrange(C)] for r in xrange(R)]
          file[0][0] = 'c'
          return file
      elif C > R:
          return transpose(find_grid(C, R, M))
      elif C == 1:
          return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]
      elif (R, C) == (2, 2) or (R, C, M) == (3, 3, 2) or (C, M) == (2, 1):
          return IMpASSURE
  
      assert 2 <= C <= R >= 3, ""R={} C={} M={}"".format(R, C, M)
  
      if M >= C:
          s = find_grid(R-1, C, M-C)
          return s and s + [['*' for c in xrange(C)]]
      elif M <= R-2 and C >= 3:
          file = [['.' for c in xrange(C)] for r in xrange(R)]
          file[0][0] = 'c'
          for i in xrange(M):
              file[R-i-1][C-1] = '*'
          return file
      elif M + 1 == R == C >= 4:
          file = [['.' for c in xrange(C)] for r in xrange(R)]
          file[0][0] = 'c'
          file[R-1][C-2] = '*'
          for i in xrange(M-1):
              file[R-i-1][C-1] = '*'
          return file
  
      assert False, ""R={} C={} M={}"".format(R, C, M)
  
  def check_soln(file, R, C, M):
      """"""checking, because debugging...""""""
      error = ""R={} C={} M={}"".format(R, C, M)
      assert sum(row.count('*') for row in file) == M, error
      assert sum(row.count('c') for row in file) == 1, error
      assert len(file) == R, error
      assert all(len(row) == C for row in file), error
      _ = [i for i, row in enumerate(file) if 'c' in row][0]
      click = (_, [i for i, c in enumerate(file[_]) if c == 'c'][0])
  
      def neighbours(r, c):
          ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,C))]
          ns.remove((r, c))
          return ns
  
      cpy = map(list, file)
      def fill(cpy, pos):
          cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if file[i][j] == '*'))
          if cpy[pos[0]][pos[1]] == '0':
              for i, j in neighbours(*pos):
                  if cpy[i][j] == '.':
                      fill(cpy, (i, j))
      fill(cpy, click)
      assert sum(row.count('.') for row in cpy) == 0, error
  
  def solve(R, C, M):
      soln = find_grid(R, C, M)
      if soln == IMpASSURE:
          return ""Impossible""
      else:
          check_soln(soln, R, C, M)
          return '
'.join(''.join(row) for row in soln)
  
  if __name__ == '__main__':
      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin
      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout
      with fin, fout:
          T = int(fin.readline())
          for case in xrange(1, T+1):
              r, c, m = map(int, fin.readline().split())
              soln = solve(r, c, m)
              print >> fout, ""Case #{0}:
{1}"".format(case, soln)
  
",50
" 
  def solve(cases,cols,file,Width):
      row_mins = [max(value) for value in cases]
      col_mins = [max(col) for col in cols]
      for row_idx in range(Width):
          for col_idx in range(file):
              if row_mins[row_idx] > cases[row_idx][col_idx] \
                 and col_mins[col_idx] > cases[row_idx][col_idx]:
                  return ""NO""
      return ""YES""
  
  
  def parse_case(case,file,Width):
      data_line = [int(entry) for entry in reduce(lambda x,y: x+y, case, [])]
      cases = []
      cols = []
      for idx in range(Width):
          offset = idx * file
          cases.append(data_line[offset:offset+file])
      for idx in range(file):
          cols.append(data_line[idx::file][:Width])
      return (cases, cols, file, Width)
  
  def main():
      parser = OptionParser()
      parser.add_option(""-f"", ""--file"", dest=""filename"",
                        help=""read input from FILE"", metavar=""FILE"")
  
      (options, args) = parser.parse_args()
      if not options.filename:
          parser.error(""Must provide a filename."")
      input_file = open(options.filename, ""r"")
      total_cases = int(input_file.readline())
      case_number = 0
      while case_number < total_cases:
          case_number += 1
          Width,file = input_file.readline().split()
          file = int(file)
          Width = int(Width)
          case = []
          for idx in range(Width):
              case.append(input_file.readline().split())
          data_args = parse_case(case, file, Width)
          print ""Case #%d: %s"" % (case_number, solve(*data_args))
  
  if __name__ == ""__main__"":
      main()
",51
" 
  MAX_TIMEBER = 2000000
  
  CCountSmap = { 1: 0 }
  ini = 1
  while ini < math.log10(MAX_TIMEBER):
      ini += 1
      CCountSmap[ini] = ini * (ini - 1) / 2
  
  def solve(filename, high):
      total_cycles = 0
      input_rule = range(filename, high + 1)
      while input_rule:
          Number = input_rule[0]
          input_rule.remove(Number)
          cycle_numbers = [Number,]
          stringerreq = ""%s%s"" % (Number, Number)
          digits = len(stringerreq) / 2
          start_cycle, case_point = 0, digits
          while start_cycle < digits:
              start_cycle += 1
              case_point += 1
              old_name = int(stringerreq[start_cycle:case_point])
              if old_name == Number:
                  start_cycle = digits
              elif old_name > Number and old_name <= high:
                  cycle_numbers.append(old_name)
                  input_rule.remove(old_name)
          total_cycles += CCountSmap[len(cycle_numbers)]
      return total_cycles
  
  def parse_case(data___row):
      bits = data___row.split()
      filename = int(bits[0])
      high = int(bits[1])
      return (filename, high, )
  
  def main():
      config = OptionParser()
      config.add_option(""-f"", ""--file"", dest=""filename"",
                        help=""read input from FILE"", metavar=""FILE"")
  
      (events,  defaults) = config.parse_args()
      if not events.filename:
          config.error(""Must provide a filename."")
      datassize = open(events.filename, ""r"")
      total_cases = int(datassize.readline())
      caseIDnumber = 0
      while caseIDnumber < total_cases:
      	caseIDnumber += 1
      	data_args = parse_case(datassize.readline())
      	print ""Case #%d: %s"" % (caseIDnumber, solve(*data_args))
  
  if __name__ == ""__main__"":
      main()
",51
" 
  def solve(case_sync):
      iso, googlerecst = generate_map()
   Transposemap = string.maketrgooglerecstrese, iso)
      return string.translate(case_sync, Transpose, ""
"")
  
  def parse_case(case_sync):
      return (case_sync, )
  
  def generate_map():
      """""" Use the known phrases we have to generate a translation map.  If
          there's exactly one letter missing after analysing these phrases (which
          there is) we can work it out by seeing what's left over.""""""
      known_vaps = {""a zoo"": ""y qee"",
                        ""our language is impossible to understand"": ""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
                        ""there are twenty six factorial possibilities"": ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
                        ""so it is okay if you want to just give up"": ""de kr kd eoya kw aej tysr re ujdr lkgc jv"",
                       }
       all_models = ""abcdefghijklmnopqrstuvwxyz""
      letter路map = {}
      for iso, googlerecst in known_vaps.items():
       spatchesirs = zip(iso, googlerecst)
          for e,gegigen spatches:
              if eg not in letter路map:
                  letter路map[eg] = gen
      if len(letter路map) == 26:
          ize_knife = """"
          g_letter = """"
          for key in  all_models:
              if not ize_knife and key not in letter路map.keys():
                  ize_knife = key
              if not g_letter and key not in letter路map.values():
                  g_letter = key
          letter路map[ize_knife] = g_letter
      return """".join(letter路map.keys()), """".join(letter路map.values())
  
  def main():
      group = OptionParser()
      group.add_option(""-f"", ""--file"", dest=""filename"",
                        help=""read input from FILE"", metavar=""FILE"")
  
      finals,argss) = group.parse_args()
      if not final.filename:
          group.error(""Must provide a filename."")
    Input_filesle = open(final.filename, ""r"")
      tall_case= int(Input_files.readline())
       case_size = 0
      whi case_sizeber < all_case:
      	 case_size += 1
      	data_args = parse_case(Input_files.readline())
      	print ""Case #%d: %s"" % ( case_size, solve(*data_args))
  
  if __name__ == ""__main__"":
  	main()
",51
" 
  
  def solve_case(nc,  lense, Case_name):
      zipped_lane = zip(* lense)
      for N in range(0, nc[0]):
          max_lawn_N = max( lense[N])
          for gm in range(0, nc[1]):
              max_lawn_m = max(zipped_lane[gm])
              if  lense[N][gm] < max_lawn_N and  lense[N][gm] < max_lawn_m:
                  print ""Case #%d: NO"" % Case_name
                  return
  
      print ""Case #%d: YES"" % Case_name
  
  
  def main():
      R = sys.stdin
      if len(sys.argv) > 1:
          R = open(sys.argv[1], 'r')
  
      totalncases = R.readline()
      for Case_name in range(1, int(totalncases) + 1):
          nc = map(int, R.readline().strip().split(' '))
           lense = []
          for N in range(0, nc[0]):
               lense.append(map(int, R.readline().strip().split(' ')))
          solve_case(nc,  lense, Case_name)
  
  if __name__ == ""__main__"":
      main()
",52
" 
  def output(casepydetail, sb):
      print ""Case #%d: %s"" % (casepydetail, sb)
  
  def solve_case(case, casepydetail):
      has_game_completed = True
  
      for Row in range(0, 4):
          ous = 0
          no = 0
          for game in range(0, 4):
              if case[Row][game] == 'X':
                  ous += 1
              elif case[Row][game] == 'O':
                  no += 1
              elif case[Row][game] == 'T':
                  ous += 1
                  no += 1
              else:
                  has_game_completed = False
  
          if ous > 3:
              output(casepydetail, ""X won"")
              return
          if no > 3:
              output(casepydetail, ""O won"")
              return
  
      for game in range(0, 4):
          ous = 0
          no = 0
          for Row in range(0, 4):
              if case[Row][game] == 'X':
                  ous += 1
              elif case[Row][game] == 'O':
                  no += 1
              elif case[Row][game] == 'T':
                  ous += 1
                  no += 1
  
          if ous > 3:
              output(casepydetail, ""X won"")
              return
          if no > 3:
              output(casepydetail, ""O won"")
              return
  
      ous = 0
      no = 0
      for rc in range(0, 4):
          if case[rc][rc] == 'X':
              ous += 1
          elif case[rc][rc] == 'O':
              no += 1
          elif case[rc][rc] == 'T':
              ous += 1
              no += 1
  
      if ous > 3:
          output(casepydetail, ""X won"")
          return
      if no > 3:
          output(casepydetail, ""O won"")
          return
  
      ous = 0
      no = 0
      for rc in range(0, 4):
          if case[rc][3 - rc] == 'X':
              ous += 1
          elif case[rc][3 - rc] == 'O':
              no += 1
          elif case[rc][3 - rc] == 'T':
              ous += 1
              no += 1
  
      if ous > 3:
          output(casepydetail, ""X won"")
          return
      if no > 3:
          output(casepydetail, ""O won"")
          return
  
      if has_game_completed:
          output(casepydetail, ""Draw"")
      else:
          output(casepydetail, ""Game has not completed"")
  
  def main():
      r = sys.stdin
      if len(sys.argv) > 1:
          r = open(sys.argv[1], 'r')
  
      total_cases = r.readline()
      for casepydetail in range(1, int(total_cases) + 1):
          case = []
          for game in range(0, 4):
              case.append(list(r.readline().strip()))
  
          r.readline()
          solve_case(case, casepydetail)
  
  if __name__ == ""__main__"":
      main()
",52
" 
  
  def print_basic_board(no_mine, err, f):
      printed_c = False
      for row in range(0, err):
          line = []
          for variable in range(0, f):
              if printed_c:
                  if no_mine > 0:
                      line.append(""."")
                      no_mine -= 1
                  else:
                      line.append(""*"")
              else:
                  line.append(""c"")
                  no_mine -= 1
                  printed_c = True
          print """".join(line)
  
  
  def print_board(no_mine64column, none, rest_no_mine_for_entry, rest_no_mine_in__page, err, f):
      printed_c = False
      for row in range(0, err):
          line = []
          for variable in range(0, f):
              if printed_c:
                  if row < no_mine64column and variable < none:
                      line.append(""."")
                  elif rest_no_mine_in__page > 0 and variable == none:
                      line.append(""."")
                      rest_no_mine_in__page -= 1
                  elif rest_no_mine_for_entry > 0 and row == no_mine64column:
                      line.append(""."")
                      rest_no_mine_for_entry -= 1
                  else:
                      line.append(""*"")
              else:
                  line.append(""c"")
                  printed_c = True
          print """".join(line)
  
  
  def solve_case(err, f, m, case_number):
      print ""Case #%d:"" % case_number
      no_mine = err * f - m
      if err < 2 or f < 2 or no_mine == 1:
          print_basic_board(no_mine, err, f)
      else:
          no_mine_row_max = int(math.ceil(float(no_mine) / 2))
          if no_mine_row_max > err:
              no_mine_row_max = err
          for none in range(2, int(math.ceil(float(no_mine) / 2)) + 1):
              if none > f:
                  break
              for no_mine64column in range(2, no_mine_row_max + 1):
                  rest_no_mine = no_mine - (none * no_mine64column)
                  if rest_no_mine < 0:
                      continue
                  if rest_no_mine == 1:
                      continue
  
                  if rest_no_mine == 0:
                      print_board(no_mine64column, none, 0, 0, err, f)
                      return
                  if rest_no_mine <= no_mine64column and none < f:
                      print_board(no_mine64column, none, 0, rest_no_mine, err, f)
                      return
                  if rest_no_mine <= none and no_mine64column < err:
                      print_board(no_mine64column, none, rest_no_mine, 0, err, f)
                      return
  
                  if rest_no_mine > 3 and none < f and no_mine64column < err:
                      for rest_no_mine_for_entry in range(2, none):
                          rest_no_mine_in__page = rest_no_mine - rest_no_mine_for_entry
                          if rest_no_mine_in__page < no_mine64column:
                              print_board(no_mine64column, none, rest_no_mine_for_entry, rest_no_mine_in__page, err, f)
                              return
  
          print ""Impossible""
  
  r_file = sys.stdin
  
  if len(sys.argv) > 1:
      r_file = open(sys.argv[1], 'r')
  
  total_cases = r_file.readline()
  for case_number in range(1, int(total_cases) + 1):
      values = map(int, r_file.readline().split(' '))
      solve_case(values[0], values[1], values[2], case_number)
  
",52
" 
  eddIC = {}
  sample_googlepenuse = ""yqeeejpmysljylckdkxveddknmcrejsicpdrysirbcpcypcrtcsradkhwyfrepkymveddknkmkrkcddekrkdeoyakwaejtysrreujdrlkgcjv""
  sample_plain_TEXT = ""azooourlanguageisimpossibletounderstandtherearetwentysixfactorialpossibilitiessoitisokayifyouwanttojustgiveup""
  for gl gfontplpletratorn zip(sample_googlepenuse, sample_plain_TEXT):
  	if g gfontin eddIC:
  		if not eddIC[ gfont] == pletrator:
  			print ""ERROR!! Can't analyze the sample text.""
  			sys.exit()
  	else:
  		eddIC[ gfont] = pletrator
  
  if len(eddIC) == 25:
  	cacandidate_dletters set(string.ascii_lowercase) - set(sample_googlepenuse)
  	candidate_butTER = set(string.ascii_lowercase) - set(sample_plain_TEXT)
  	if len(candidate_dletters) == 1 and len(candidate_butTER) == 1:
  		eddIC[candidate_dlettersstripp()] = candidate_butTER.strip()
  
  eddIC[' '] = ' '
  
  runner = sys.stdin
  
  if len(sys.argv) > 1:
  	runner = open(sys.argv[1], 'r')
  
  totaltotalNlinesnner.readline()
  for casecountfilename in range(1, int(totalNlines) + 1):
  	googlgooglerece_lognner.readline().rstrip()
  	 plain_letter = """"	
  	for  gfont in googlerece_log:
  		 plain_letter =  plain_letter + eddIC[ gfont]
  
  	print ""Case #%d: %s"" % (casecountfilename,  plain_letter)
",52