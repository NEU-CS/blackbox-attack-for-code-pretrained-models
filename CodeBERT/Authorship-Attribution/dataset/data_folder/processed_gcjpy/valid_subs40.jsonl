{"code": " \n  def is_sym( number ):\n  \tnum_str = str( number )\n  \tnum_len = len( num_str )\n  \thalf_len = int( num_len / 2 )\n  \tend = num_str[-half_len:]\n  \trev_end = end[::-1]\n  \tstart = num_str[:half_len]\n  \tequal = rev_end == start \n  \treturn equal\n  \n  f = open( 'palindromes.out' )\n  \n  numbers = [ int(x) for x in f.read().split() ]\n  \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n  \tmin, max = [ int(x) for x in raw_input().split() ]\n  \tcount = 0\n  \tfor number in numbers:\n  \t\tif min <= number and max >= number:\n  \t\t\tcount += 1\n  \n  \tprint 'Case #' + str( case ) + ': ' + str( count )\n", "substitutes": {"number": ["address", "key", "character", "function", "name", "integer", "umber", "phone", "digit", "line", "regular", "nc", "counter", "switch", "string", "c", "initial", "note", "multiple", "month", "size", "value", "data", "python", "order", "choice", "even", "no", "two", "code", "X", "hello", "date", "index", "union", "text", "null", "unit", "random", "error"], "num_str": [" num7string", "n_string", " num_string", "num_time", "num1string", "num7string", " num7time", "num1time", "num7str", "numinglen", "numingstring", "orig_char", "orig_len", "n_len", "num7len", "orig_str", "num_obj", "numingstr", "n_str", "numingchar", "n_obj", "num_data", " num_time", "orig_string", "num1str", "num_string", " num_data", "num1len", " num7str", "num7time", " num7len", "num_char"], "num_len": ["num64length", "num_start", "num_size", "num__val", "half__val", "num64lin", "n_len", "n_length", "half_start", "num__len", "num__lin", "num__length", "numwstart", "num__size", "half__start", "numwlen", "half_size", "numwsize", "num_val", "num_lin", "num_length", "numwval", "num__start", "num64end", "num__end", "num64len", "n_end", "n_lin", "num_end", "half__size", "half__len", "half_val"], "half_len": ["half33den", "quarter_len", "quarter_length", "half_start", "half33length", "quarter_val", "half_den", "half_line", " half_Len", "half33len", " half_den", " half_start", "half01len", "half_Len", " half_line", " half_length", "half_length", "half01start", "half01den", "half01length", "half33start", "quarter_Len", "half_val"], "end": ["END", "add", "open", "size", "after", "set", "n", "range", "ord", "append", "order", "next", "all", "int", "tail", "limit", "pos", "id", "ension", "index", "mid", "until", "num", "ended", "length", "est", "offset", "vert", "End", "e", "edge", "ed", "ad", "len", "en", "eng", "stop", "ending", "update", "nd"], "rev_end": ["re_len", "re_end", "rev2end", "rev2start", "rev_len", "revallend", "revalllen", "revallsize", "re_start", "revallstart", " rev_len", "rev_size", "rev2len", "rev_start", "re_size", " rev_start"], "start": ["step", "cur", "middle", "open", "new", "i", "key", "set", "only", "range", "now", "shift", "scale", "next", "begin", "int", "type", "name", "part", "before", "pos", "id", "p", "limit", "index", "mid", "pad", "match", "offset", "skip", "base", "e", "pre", "diff", "len", "stop", "first", "starting", "sort", "st"], "equal": ["neutral", "alpha", "i", "ince", "actual", "scale", "all", "ne", "init", "tex", "int", "sex", "multi", "id", "nin", "ran", "balanced", "io", "between", "inc", "expected", "atin", "inas", "foo", "update", "ite", "inn", "data", "partial", "al", "oin", "edIn", "qual", "en", "ide", "icon", "index", "open", "same", "Out"], "f": ["l", "ff", "fer", "z", "progress", "feed", "i", "path", "fit", "n", "sf", "b", "r", "v", "fd", "inf", "full", "fe", "stream", "xf", "frame", "ch", "fl", "d", "fx", "p", "m", "form", "file", "fr", "fac", "fm", "o", "io", "fold", "info", " F", "e", "conf", "buff"], "numbers": ["cores", "cumbers", "nNumbers", "lNumbers", "colores", "columbers", "colNumbers", "Nums", "neums", "neodes", "Numbers", "pumbers", "neumbers", "pums", "nums", "neases", "Nodes", "lores", "nodes", "Nases", "nores", "lums", "colums", "cNumbers", "pases", "cums", "podes", "lumbers", "nases"], "x": ["ex", "l", "i", "t", "xd", "input", "xx", "int", "sex", "id", "rx", "ct", "tx", " cx", "xs", "nc", "y", "string", "c", "ctx", "ci", "hex", "r", "data", "cross", "nw", "python", "xy", "xi", "xxxx", "ww", "m", "ya", "code", "X", "xa", "w", "xp", "index", "nt"], "numCases": ["numPases", "nbCase", "numRecase", "nbRecase", "nbRecales", "numcatches", "numScalls", "nbCatches", "numCores", "numCales", " numCalls", "numcases", "numCatches", "nbCases", "numRalls", "nbCales", "numScores", "numcales", "nbRecases", "numScales", "numRecales", "numPales", "numRases", "numcase", " numCales", "numRecatches", "numRales", "numPatches", "numCalls", "numCase", " numCores", "numRores", "numScases", "numPase", "numRecases", "nbRecatches"], "case": ["section", "Case", "config", "size", "example", "key", "label", "ce", "rice", "core", "pe", "connection", "pair", "call", "trial", "ase", "order", "choice", "type", "default", "name", "current", "ace", "position", "index", "num", "sequence", "match", "length", "cases", "charge", "test", "base", "ance", "ice", "word", "force", "code", "switch", "string"], "min": ["step", "size", "Min", "key", "mean", "unit", "ref", "core", "n", "range", "value", "one", "span", "next", "int", "type", "default", "name", "part", "current", "limit", "pos", "m", "po", "num", "mid", "length", "between", "mini", "skip", "base", "spec", "weight", "pre", "len", "ain", "code", "first", "ver", "c"], "max": ["step", "can", "size", "final", "rand", "rest", "right", "old", "n", "range", "call", "cycle", "order", "next", "total", "Max", "name", "part", "day", "on", "MAX", "limit", "pos", "id", "rank", "std", "ax", "index", "num", "mid", "mod", "length", "est", "base", "no", "c", "wrap", " Max", "nd", "sum"], "count": ["cur", "cond", "note", "size", "key", "core", "col", "seq", "n", "now", "carry", "call", "group", "cycle", "order", "next", "total", "int", "type", "child", "default", "name", "part", "parent", "current", "id", "allow", "list", "num", "match", "race", "length", "fold", "info", "base", "cache", "conf", "depth", "weight", "coll"]}}
{"code": "def build_table():\n  \ttable = []\n  \tfor i in range( 0, 31 ):\n  \t\ttable.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )\n  \n  \treturn table\n  \n  \n  def get_max_score( i ):\n  \treturn max( 0, min( 10, ( i + 2 ) / 3 ) )\n  \n  def get_max_surprise_score( i ):\n  \treturn min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )\n  \n  def get_max( x, scores, score_needed, num_surprises ):\n  \tscores = sorted( scores, reverse=True )\n  \tnumPass = 0\n  \ti = 0;\n  \twhile ( i < len(scores) ):\n  \t\tif ( x[scores[i]][0] >= score_needed ):\n  \t\t\tnumPass += 1\n  \t\telse:\n  \t\t\tbreak\n  \t\ti += 1\n  \n  \twhile ( i < len(scores) and num_surprises > 0 ):\n  \t\tif ( x[scores[i]][1] >= score_needed ):\n  \t\t\tnumPass += 1\n  \t\t\tnum_surprises -= 1\n  \t\t\t\n  \t\ti += 1\n  \n  \treturn numPass\n  \n  x = build_table()\n  \n  num_cases = input()\n  \n  for i in range( 1, num_cases + 1 ):\n  \tline = raw_input().split()\n  \tnum_surprises = int(line[1])\n  \tscore_needed = int(line[2])\n  \tscores_raw = line[3:]\n  \n  \tscores = [ int(y) for y in scores_raw ]\n  \n  \tprint 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )\n", "substitutes": {"table": ["key", "model", "chain", "all", "td", "buffer", "file", "list", "tree", "c", "root", "note", "section", "bl", "py", "case", "core", "che", "array", "order", "element", "dict", "sequence", "module", "base", "cache", "tab", "code", "transform", "end", "index", "view", "cell", "col", "source", "stable", "db", "style", "batch", "back"], "i": ["l", "key", "ti", "t", "fi", "b", "ih", "qi", "phi", "uri", "int", "init", "name", "multi", "ei", "id", "PI", "o", "io", "request", "dom", "iq", "start", "c", "g", "ini", "ci", "si", "image", "j", "min", "eni", "ri", "im", "isi", "xi", "bi", "m", "site", "ni"], "x": ["co", "ex", "l", "t", "input", "b", "xx", "model", "sex", "by", "list", "rx", "tx", "xs", "c", "g", "px", "j", "case", "cross", "data", "python", "array", "xy", "xi", "sync", "m", "play", "layer", "a", "code", "X", "w", "xp", "index", "best", "es", "example", "u", "dx"], "scores": ["scheores", "scars", "cores", " scourses", "Scores", "scales", "SCore", " Scors", " score", "spources", " Scoring", "ancores", "ancors", "sors", "spores", "scheoring", "chores", " scros", "descanners", "scodes", "sores", "SCors", "SCores", "slores", "sours", "core", "scriptores", "chors", " Scores", "oscore", "chore", "slourses", " scoring", "scors", " scales", "Score", "oscores", "scheales", "scours", "cors"], "score_needed": ["core_allowed", "score_ready", "scorePprovided", "core_important", "scoreenallowed", " score_needs", "scoreenused", "loss_provided", "loss_need", "scorePneed", "scorePneeded", "scoreenneed", "scoreoutneeds", " score_ready", "score_needs", "score_necessary", "loss_needed", "score_forced", " score_forced", "scoreenneeded", "score_expected", "score_need", "core_need", " score_necessary", "core_used", "score_used", "score_important", "core_expected", "core_needed", "score_allowed", "scoreoutneeded", " score_used", "score_provided", "scoreoutforced"], "num_surprises": ["num_suvey", "num_promacters", "num_merprising", "num_survey", "num_serfaces", "num_promasures", "num_urprisingly", "num_simries", "num_curprise", "num_urprises", "num_urprise", "num_merprises", "num_suprises", "num_serprises", "num_suceptions", "num_suries", "num_gufaces", "num_serries", "num_Surceptions", "num_curprising", "num_conacters", "num_curites", "num_confaces", "num_conasures", "num_conprises", "num_surfaces", "num_guasures", "num_curprises", "num_guacters", "num_surceptions", "num_surries", "num_serprise", "num_merprisingly", "num_Surprises", "num_simprises", "num_promprises", "num_merites", "num_urfaces", "num_surprising", "num_Surries"], "numPass": ["sumPass", "numberPass", "sumPASS", "sumFail", "nomPASS", "Numpass", "numRun", " numRun", "NumPass", "numLine", " numPASS", "nomPass", " numpass", "nompass", "multipass", "multiPASS", "nomLine", "sumpass", "numberRun", " numLine", "multiFail", "nPass", "numpass", "npass", "multiPass", "numberpass", "NumRun", " numFail", "sumLine", "numFail", "numPASS"], "num_cases": [" num67sections", "numxruns", " num_runs", " numfcases", " num_sections", " num_rows", "num2cells", "num_rows", " num67rows", " num_changes", "num_runs", "num_cells", "numxcases", "num2changes", " num67tests", "num2cases", "num2runs", "numfcells", "num67rows", "numlcases", "num67sections", "numfcases", " numfcells", "num_sections", " num_tests", " num_cells", "numfruns", "numfchanges", "numlrows", "num_tests", "num67cases", " numfruns", "num67tests", " num67cases", "num_changes", "numlsections", "numxcells", "numxchanges", " numfchanges", "numltests"], "line": ["co", "l", "inline", "feed", "input", "shell", "ne", "frame", "file", "look", "list", "rule", "lf", "cle", "string", "c", "column", "LINE", "log", "section", "lo", "le", "lines", "case", "out", "r", "data", "group", "se", "item", "sync", "entry", "time", "no", "code", "use", "date", "end", "strip", "band"], "scores_raw": ["scorer_Raw", "scores_short", "scales_raw", "scores_RAW", "scores_spec", "scores_row", "scorer_row", "scales_spec", "scales_Raw", "scores_Raw", "scorer_RAW", "scorer_raw", "scales_short"], "y": [" ye", "j", "z", "sys", "yy", "py", "t", " Y", "yo", "col", "n", "b", "s", "v", "xx", "yl", "yi", " you", "xy", "ies", "ie", "ch", " year", "yz", "p", " inst", "vy", "m", "yn", "yth", "cy", "ym", "yr", " equ", "yu", "ye", "yd", "oy", "ya", "si"]}}
{"code": " \n  \n  def is_palindrome(num):\n      s = str(num)\n      end_idx = len(s)-1\n      for i in range(len(s)//2):\n          if s[i] != s[end_idx-i]:\n              return False\n      return True\n  \n  def is_valid_base(base):\n      return is_palindrome(base) and is_palindrome(base*base)\n  \n  def process_case(lo, hi):\n      cnt = 0\n      base_lo = math.ceil(math.sqrt(lo))\n      base_hi = math.floor(math.sqrt(hi))\n      for base in range(base_lo, base_hi+1):\n          if is_valid_base(base):\n              cnt += 1\n      return cnt\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          lo,hi = line_of_numbers(next(lines))\n          result = process_case(lo, hi)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('C-small-attempt0')\n", "substitutes": {"num": ["text", "missing", "min", "size", "unit", "max", "u", "loc", "n", "count", "one", "range", "node", "su", "ui", "common", "span", "dim", "coord", "sex", "name", "multi", "us", "pos", "um", "id", "m", "uni", "form", "na", "home", "x", "length", "umi", "offset", "end", "nb", "temp", "no", "Num"], "s": ["l", "b", "tests", "name", "bis", "o", "cells", "comments", "ans", "xs", "h", "y", "string", "c", "g", "sb", "ends", "strings", "si", "size", "sets", "ses", "r", "sf", "ids", "se", "blocks", "qs", "words", "rules", "site", "ns", "x", "abs", "its", "os", "ops", "sis", "spec", "series"], "end_idx": ["end_idsxd", "end_Idz", "endxidy", "endxindk", "end_partxs", "end_endxc", "endxidxc", "end_partxd", "end_idz", "end_Idy", "end_endk", "endxindxc", "end_partx", "end_idxd", "endxidx", "end_endx", "end_idy", "end_Idxs", "end_indy", "endxindy", "end_indk", "end_partz", "end_indxc", "end_idk", "endxindx", "end_Idxc", "end_idsz", "endxidk", "end_idxs", "end_Idxd", "end_endy", "end_Idk", "end_Idx", "end_idxc", "end_idsx", "end_indx", "end_idsxs"], "i": ["ai", "l", "ip", "j", "z", "eni", "u", "ti", " I", "ri", " ii", "col", "I", "n", "b", "one", "v", "ui", "qi", "yi", "int", "xi", "ie", "bi", "li", "ei", "ace", "id", "d", "p", "iu", "x", "pi", "ni", "mi", "di", "ix", "info", "idi", "end"], "base": ["based", "l", "alpha", "loc", "b", "model", "chain", "scale", "ase", "uri", "int", "name", "area", "id", "file", "kit", "la", "h", "c", "ma", "bas", "basic", "root", "si", "le", "size", "case", "py", "valid", "core", "old", "family", "Base", "se", "bi", "site", "bc", "binary", "x", "local"], "lo": ["small", "l", "LO", "le", "log", "co", "size", "elo", "pl", "loc", "ri", "lim", "old", "so", "b", "loop", "ino", "ui", "lab", "ha", "ko", "phi", "ln", "bi", "low", "li", "ro", "id", "hei", "los", "go", "lie", "po", "sci", "ni", "cl", "o", "length", "zo", "lb"], "hi": ["l", "co", "wa", "chi", "cli", "py", "ili", "loc", "gh", "lim", "HI", "fi", "range", "b", "one", "ih", "inf", "ui", "his", "ha", "phi", "Hi", "ho", "xi", "bi", "low", "li", "hei", "id", "rh", "go", "index", "pi", "mid", "mi", "high", "plus", "ali", "mini", "lin"], "cnt": ["ncnt", "nrt", " counters", "cno", "ncrt", "ucct", "ncnc", "ncno", "ncct", "count", "nct", "Cno", " count", " crt", "encnt", " cct", "ncount", "nnc", "ccount", "ucounters", "ucnt", " cno", "uccount", "cnc", "nnt", " cNT", "counters", "Cnt", "ncNT", "encct", " ccount", "CNT", " cnc", "crt", "enccount", "Count", "encounters", "cNT", "cct"], "base_lo": ["bas_la", "bas_hi", "bas_loc", "bas_lo", " base_low", "base_loc", "base_po", "base_low", " base_po", "base_la", " base_la"], "base_hi": ["root_hy", "base_ha", "base25hi", "root_ha", "base25ha", "base_hu", "base_hel", "root_hi", " base_hu", "root_hel", "base25hy", "base_hy", "base_la", "base25hel", " base_la"], "lines": ["log", "l", "elines", "ines", "zip", "sections", "ins", "lim", "ses", "codes", "books", "ids", "limits", "ln", "frames", "errors", "liners", "blocks", "li", "rules", "lists", "objects", "los", "users", "ns", "lined", "cells", "steps", "cases", "runs", "lin", "rows", "la", "models", "ls", "planes", "items", "zi", "sites", "lins"], "ncases": ["nase", "nsased", "necalls", "ncase", "necases", "nsase", "nased", "yncases", "necased", "nats", "encatures", "encats", "ncatures", "yncats", "nsases", "yncatures", "ncalls", "necats", "encases", "yncalls", "necase", "encalls", "nsats", "ncased", "ncats", "necatures", "nases"], "ci": ["ai", "co", "l", "le", "chi", "cli", "case", "ki", "cin", "character", "loc", "ri", "lim", "cu", "col", "cia", "ic", "chain", "xi", "ln", "bi", "low", "li", "ace", "id", "bc", "sci", "ni", "pi", "di", "cont", "ico", "lin", "la", "oi", "oci", "ice", "nc", "cci", "zi"], "result": ["mate", "text", "summary", "new", "obj", "page", "case", "final", "error", "valid", "comment", "desc", "range", "ge", "value", "r", "su", "data", "item", "default", "master", "function", "name", "dict", "mer", "entry", "runner", "err", "success", "list", "res", "response", "match", "search", "grade", "length", "info", "cache", "coll", "report"], "sub": ["section", "text", "ser", "sec", "desc", "case", "member", "src", "loc", "ss", "sup", " subst", "ses", " Sub", "su", "sam", "job", "slice", "uc", "sa", "se", "child", "type", "sim", "name", "id", "entry", "super", "sed", "sel", "str", "search", "si", "subject", " subs", "second", "suff", "sp", "sing", " su"], "f_in": ["f_again", "f_In", "fayin", "f_init", " f_ini", "f_ini", "f67inc", "fFileint", " f__again", " f_int", "f67out", "c_out", " f__out", " f__in", " f_inner", "f_int", "f67in", " f_init", " f_gen", " f_In", "f__inc", " f_again", "fayIn", " f_ins", "f__again", "f67again", "c_in", "fayinit", "f_gen", " f__inc", "f__out", "fFileout", " f_inc", "f_ins", "c_ins", "f__in", "fFileins", "f_inner", "f__ins", "f_inc"], "line": ["l", "inline", "key", "input", "shell", "all", "ln", "frame", "name", "id", "file", "list", "cl", " inline", "rule", "lf", "h", "string", "c", "LINE", "log", "section", "obj", "case", "out", "label", "value", "data", "profile", "next", "item", "limit", "entry", "site", "layer", "en", "code", "number", "liner", "end"], "basename": ["baseette", " basname", "Baseless", "baseename", "biname", "binename", "baseeless", "Basame", "bateme", "basisite", "baseme", "batename", "bineless", "basame", "baseeme", "Basername", "buername", "buename", " basisite", "basername", "Basisite", "batame", "buame", " basame", "batname", "Basename", "basname", "baseless", "buisite", "binette", " baseme", "Basette", "basette", " basername", "baseame"], "infile": ["uppath", " inpath", "insfile", " infilename", "outfilename", "inpath", " inbase", "inbase", "upfilename", " inname", "insbase", "insfilename", "outFILE", "inFILE", "outname", "outpath", "upFILE", "inname", " inFILE", "infilename", "outbase", "insname", "upfile"], "outfile": [" outfilename", "upformat", "outfolder", "infolder", "outfilename", "outfiles", "upfilename", "Outfilename", " outfiles", "Outfiles", " outformat", "Outfile", " outfolder", "outname", " outname", "informat", "inname", "Outname", "infilename", "outformat", "infiles", "upfolder", "upfile"], "f_out": ["f2Out", " f2again", "f2again", "f_again", " f__in", " f2Out", "f_outer", " f__outer", "f2in", "f8in", " f_nin", "f__in", " f_again", "f_Out", " f_line", "flexin", "f_nin", "f_line", " f_OUT", "f2out", "flexouter", "flexnin", " f_outer", "flexout", "f8out", "f8outer", "f__nin", " f2out", " f2in", " f_Out", "f8nin", " f__out", "f__outer", "f_OUT", "f__out", " f__nin"]}}
{"code": " \n  def threshold(p, maxdiff):\n      minval = max(p - maxdiff, 0)\n      return p + minval + minval\n  \n  def process_case(numdata):\n      N,S,p = numdata[0:3]\n      scores = numdata[3:]\n      thre_normal = threshold(p, 1)\n      thre_surprise = threshold(p, 2)\n      result = 0\n      for tot in scores:\n          if tot >= thre_normal:\n              result += 1\n          elif S > 0 and tot >= thre_surprise:\n              result += 1\n              S -= 1\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          result = process_case(line_of_numbers(next(lines)))\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('B-small-attempt0')\n", "substitutes": {"p": ["l", "pp", "pl", "t", "i", "b", "phi", "int", "pixel", "pot", "val", "tp", "point", "PI", "o", "ap", "h", "y", "start", "c", "g", "fp", "T", "j", "min", "per", "case", "py", "r", "lp", "pressure", "value", "data", "np", "item", "par", "m", "x", "bp", "base"], "maxdiff": ["maxchange", " maxchange", "lastDiff", "Maxdiff", "lastchange", "maxDiff", "Maxref", " maxref", "axdiff", "axDiff", "maxref", "mindiff", "lastdiff", "minDiff", "axchange", " maxDiff", "minref", "MaxDiff"], "minval": [" minVal", "minVal", "minvalue", " minmin", "maxmin", " minvalue", "Minvals", "maxval", "maxVal", "Minvalue", "Minmin", "Minval", "maxvalue", "minvals", " minvals", "minmin", "MinVal", "maxvals"], "numdata": ["sumpos", "tempdata", "sumdat", "npos", "nresults", "numseries", "alldata", "alllines", "testdata", "ndat", "smallfiles", "numpos", "smalldata", "alldat", "multiresults", "tempdat", "allresults", "multipos", "sumlines", "multilines", "multidat", "multidata", "tempseries", "numfiles", "testseries", "ndata", "sumresults", "testfiles", "numlines", "testdat", "smallseries", "sumdata", "numdat", "smalldat", "tempfiles", "numresults"], "N": ["Q", "P", "Z", "D", "Sc", "H", "I", "n", "NC", "RN", "M", "A", "NT", "Test", "NP", "NN", "G", "U", "PI", "Ni", "Ns", "O", "Num", "C", "V", "L", "X", "K", "Y", "T", "B", "network", "F", "NS", "R"], "S": ["P", "Q", "section", "Case", "size", "Z", "D", "Size", "case", "i", "ss", "H", "I", "n", "Su", "M", "SU", "A", "SN", "SR", "SA", "ns", "G", "U", "num", "SD", "SE", "CS", "Ns", "W", "Results", "sp", "O", "sample", "SL", "SC", "SP", "OS", "C", "V"], "scores": ["quatters", "cores", " scorer", "Scores", "Scales", "scales", "descorer", "quorer", " score", "cales", " scales", "Score", "corer", "quales", "scorer", "catters", "descore", "quores", "descales", "Scorer", "descores", "scatters", "Scatters", "score"], "thre_normal": ["thre_random", "thore_Normal", "thore_common", "thre_general", "thre_norm", "thre2common", "thore_norm", "thbre_normal", "thre2norm", "thore_normal", "thbre_general", "thre2normal", "thre2Normal", "thre_common", "thbre_random", "thbre_norm", "thre_Normal"], "thre_surprise": ["thre_surce", "thre_purprising", "thre_purprises", "thre_purvey", "thre_Survey", "thre_surmetic", "thre_urprising", "thre_Surmetic", "thre_purce", "thre_purprise", "thre_urprise", "thre_surprising", "thre_purception", "thre_curprises", "thre_surprises", "thre_purmetic", "thre_curception", "thre_survey", "thre_surception", "thre_urvey", "thre_Surprise", "thre_curprise", "thre_urmetic", "thre_urception", "thre_curprising", "thre_urce", "thre_Surce", "thre_urprises"], "result": ["progress", "desc", "i", "scale", "function", "name", "runner", "grade", "Results", "counter", "c", "feature", "root", "size", "case", "out", "df", "valid", "core", "rate", "r", "value", "term", "data", "duration", "order", "compl", "dict", "ret", "err", "goal", "spec", "output", "code", "number", "use", "done", "cash", "ULT", "gi"], "tot": ["ertoted", "hetots", " tOT", "ttoto", "tots", "ltots", "ptoted", " tota", "ptocl", "tomots", "ltot", " tots", "tomOT", "ttocl", "ttoted", "ptot", "Tox", "ttower", "ttot", "tOT", "hetot", "ptoto", "toto", "tox", "tomot", "Tower", "Tots", "ltOT", "Tot", "toted", "ltota", "ertot", "tocl", "ertocl", "ttots", "tower", "tota", "hetower", "ttox", "hetox"], "lines": ["log", "l", "text", "es", "ines", "zip", "sections", "ins", "ses", "codes", "slice", "ids", "tests", "limits", "ln", "frames", "errors", "breaks", "blocks", "ds", "rules", "lists", "objects", "users", "los", "ns", "lined", "flows", "times", "cells", "steps", "cases", "runs", "lin", "rows", "models", "xs", "ls", "items", "lins"], "ncases": ["nase", "nvades", "nvats", "nales", "ncase", "necales", "necases", "necakes", "necades", "nvaps", "NCakes", "ncades", "ncales", "nvases", "nsades", "necaps", "NCales", "nsases", "necats", "necase", "nsats", "ncats", "nsaps", "nakes", "NCases", "ncaps", "NCase", "nases", "ncakes"], "ci": ["ai", "cell", "dc", "chi", "case", "i", "cc", "cin", "ce", "loc", " ii", "cu", "col", "cia", "inf", "uc", "su", "slice", "ic", "cs", "init", "xi", "cod", "li", "cm", "id", "cr", "bc", "sci", "ni", "num", "pi", "di", " i", " c", "cont", "oci", "ice", "nc", "ca"], "s": ["l", "sq", "sec", "services", "sections", "sets", "states", "ss", "path", " samples", "n", "sf", "ses", "r", "su", "slice", "se", "tests", "scan", "sim", "words", "site", "sym", "search", "cells", "steps", "comments", "space", "runs", "types", "rows", "spec", "e", "second", "ws", "series", "ls", "sing", "items", "sites"], "sub": ["section", "division", "cell", "sq", "sec", "desc", "case", "loc", "src", "ss", "sup", " subst", "ses", " Sub", "su", "uc", "sam", "slice", "SU", "se", "child", "struct", "sim", "type", "name", "li", "id", "super", "seed", "site", "bc", "sci", "num", "search", " subs", "subject", "spec", "second", "suff", "sp"], "f_in": ["f_again", "f_id", "fAMout", " f_gin", "fockout", " f_inn", "fockin", "f_input", " f_sin", "cf_input", "cf_ins", "fAMin", "fAMsin", "cf_in", "fockid", "f__inc", "cf_id", "fockagain", "f_inn", " f_ins", "cf_again", "cf_out", "fAMinn", "f__out", " f_inc", "f_gin", "f_ins", "f_sin", "f__in", " f_input", "f__ins", "f_inc"], "line": ["l", "inline", "key", "input", "stroke", "model", "chain", "int", "frame", "function", "name", "buffer", "file", "rule", "lf", "string", "c", "LINE", "lo", "log", "section", "reader", "case", "out", "value", "data", "next", "item", "phrase", "limit", "entry", "site", "base", "no", "record", "en", "output", "code", "liner", "end"], "basename": ["biname", "binename", "offette", "pacername", "Basame", "baseme", "pacelist", "basame", "offername", "offename", "Basername", "bineme", "baselist", "pacename", "pacette", "basername", " basame", "missette", "misselist", "missername", "Basename", "offelist", "binername", " baseme", "basette", " basername", "Baseme", "missename"], "infile": ["outzip", "inputzip", " infp", "insfile", " infilename", "outfilename", "inputfilename", "outile", " inile", "outfp", " inname", "insfilename", "insfp", "outname", "inile", "inputile", "inputfile", "inname", "infp", "infilename", " inzip", "insname", "inzip"], "outfile": [" outfilename", "inline", "outfolder", "exline", "againfilename", "outfilename", "inputfilename", "inbase", "outline", "exfilename", "outmodel", "againmodel", " outmodel", " outfolder", "exfile", "exbase", "inputfile", " outline", "againfile", "infilename", "inputfolder", "outbase", " outbase", "againfolder", "inputmodel"], "f_out": [" f_err", "f___write", "f_again", "f___outer", "f_outer", "f_err", " f_again", " f_write", " f_OUT", "f_OUT", " f_sum", "f___in", " f_outer", "f___out", "f_write", "f_sum"]}}
{"code": " \n  '''\n  Limits\n  \n  Small dataset       1 <= T <= 100, 1 <= A <= B <= 1000.\n  First large dataset 1 <= T <= 10000. 1 <= A <= B <= 1014.\n  Second large dataset    1 <= T <= 1000. 1 <= A <= B <= 10100.\n  \n  Sample\n  *** Input \n  3\n  1 4\n  10 120\n  100 1000\n   \t\n  *** Output \n  Case #1: 2\n  Case #2: 0\n  Case #3: 2\n  \n  \n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  pal_sqr_roots = '''1 \n  2 \n  3 \n  11 \n  22 \n  26 \n  101 \n  111 \n  121 \n  202 \n  212 \n  264 \n  307 \n  836 \n  1001 \n  1111 \n  2002 \n  2285 \n  2636 \n  10001 \n  10101 \n  10201 \n  11011 \n  11111 \n  11211 \n  20002 \n  20102 \n  22865 \n  24846 \n  30693 \n  100001 \n  101101 \n  110011 \n  111111 \n  200002 \n  798644 \n  1000001 \n  1001001 \n  1002001 \n  1010101 \n  1011101 \n  1012101 \n  1042151 \n  1100011 \n  1101011 \n  1102011 \n  1109111 \n  1110111 \n  1111111 \n  1270869 \n  2000002 \n  2001002 \n  2012748 \n  2294675 \n  3069307 \n  10000001 \n  10011001 \n  10100101 \n  10111101 \n  11000011 \n  11011011 \n  11100111 \n  11111111 \n  11129361 \n  12028229 \n  12866669 \n  20000002 \n  30001253 \n  64030648 \n  100000001 \n  100010001 \n  100020001 \n  100101001 \n  100111001 \n  100121001 \n  101000101 \n  101010101 \n  101020101 \n  101101101 \n  101111101 \n  110000011 \n  110010011 \n  110020011 \n  110091011 \n  110101011 \n  110111011 \n  111000111 \n  111010111 \n  111091111 \n  111101111 \n  111111111 \n  200000002 \n  200010002 \n  306930693 \n  1000000001 \n  1000110001 \n  1001001001 \n  1001111001 \n  1010000101 \n  1010110101 \n  1011001101 \n  1011111101 \n  1100000011 \n  1100110011 \n  1101001011 \n  1101111011 \n  1110000111 \n  1110110111 \n  1111001111 \n  2000000002 \n  2062386218 \n  2481623254 \n  10000000001 \n  10000100001 \n  10000200001 \n  10001010001 \n  10001110001 \n  10001210001 \n  10010001001 \n  10010101001 \n  10010201001 \n  10011011001 \n  10011111001 \n  10100000101 \n  10100100101 \n  10100200101 \n  10101010101 \n  10101110101 \n  10106064399 \n  10109901101 \n  10110001101 \n  10110101101 \n  10110911101 \n  10111011101 \n  10111111101 \n  10207355549 \n  11000000011 \n  11000100011 \n  11000200011 \n  11000910011 \n  11001010011 \n  11001110011 \n  11010001011 \n  11010101011 \n  11010911011 \n  11011011011 \n  11011111011 \n  11100000111 \n  11100100111 \n  11100910111 \n  11101010111 \n  11101110111 \n  11110001111 \n  11110101111 \n  13579355059 \n  20000000002 \n  20000100002 \n  22865150135 \n  30101273647 \n  30693069307 \n  83163115486 \n  100000000001 \n  100001100001 \n  100010010001 \n  100011110001 \n  100100001001 \n  100101101001 \n  100110011001 \n  100111111001 \n  101000000101 \n  101001100101 \n  101010010101 \n  101011110101 \n  101100001101 \n  101101101101 \n  101110011101 \n  101116809851 \n  110000000011 \n  110001100011 \n  110010010011 \n  110011110011 \n  110100001011 \n  110101101011 \n  110110011011 \n  111000000111 \n  111001100111 \n  111010010111 \n  111100001111 \n  111283619361 \n  112247658961 \n  128817084669 \n  200000000002 \n  1000000000001 \n  1000001000001 \n  1000002000001 \n  1000010100001 \n  1000011100001 \n  1000012100001 \n  1000100010001 \n  1000101010001 \n  1000102010001 \n  1000110110001 \n  1000111110001 \n  1001000001001 \n  1001001001001 \n  1001002001001 \n  1001010101001 \n  1001011101001 \n  1001100011001 \n  1001101011001 \n  1001110111001 \n  1001111111001 \n  1010000000101 \n  1010001000101 \n  1010002000101 \n  1010010100101 \n  1010011100101 \n  1010099010101 \n  1010100010101 \n  1010101010101 \n  1010109110101 \n  1010110110101 \n  1010111110101 \n  1011000001101 \n  1011001001101 \n  1011010101101 \n  1011011101101 \n  1011099011101 \n  1011100011101 \n  1011101011101 \n  1100000000011 \n  1100001000011 \n  1100002000011 \n  1100009100011 \n  1100010100011 \n  1100011100011 \n  1100100010011 \n  1100101010011 \n  1100110110011 \n  1100111110011 \n  1101000001011 \n  1101001001011 \n  1101009101011 \n  1101010101011 \n  1101011101011 \n  1101100011011 \n  1101101011011 \n  1110000000111 \n  1110001000111 \n  1110009100111 \n  1110010100111 \n  1110011100111 \n  1110100010111 \n  1110101010111 \n  1111000001111 \n  1111001001111 \n  1349465117841 \n  2000000000002 \n  2000001000002 \n  2149099165358 \n  2634812417864 \n  3069306930693 \n  6360832925898 \n  10000000000001 \n  10000011000001 \n  10000100100001 \n  10000111100001 \n  10001000010001 \n  10001011010001 \n  10001100110001 \n  10001111110001 \n  10010000001001 \n  10010011001001 \n  10010100101001 \n  10010111101001 \n  10011000011001 \n  10011011011001 \n  10011100111001 \n  10100000000101 \n  10100011000101 \n  10100100100101 \n  10100111100101 \n  10101000010101 \n  10101011010101 \n  10101100110101 \n  10110000001101 \n  10110011001101 \n  10110100101101 \n  10111000011101 \n  11000000000011 \n  11000011000011 \n  11000100100011 \n  11000111100011 \n  11001000010011 \n  11001011010011 \n  11001100110011 \n  11010000001011 \n  11010011001011 \n  11010100101011 \n  11011000011011 \n  11100000000111 \n  11100011000111 \n  11100100100111 \n  11101000010111 \n  11110000001111 \n  20000000000002 \n  30395080190573 \n  69800670077028 \n  98275825201587 \n  100000000000001 \n  100000010000001 \n  100000020000001 \n  100000101000001 \n  100000111000001 \n  100000121000001 \n  100001000100001 \n  100001010100001 \n  100001020100001 \n  100001101100001 \n  100001111100001 \n  100010000010001 \n  100010010010001 \n  100010020010001 \n  100010101010001 \n  100010111010001 \n  100011000110001 \n  100011010110001 \n  100011101110001 \n  100011111110001 \n  100100000001001 \n  100100010001001 \n  100100020001001 \n  100100101001001 \n  100100111001001 \n  100101000101001 \n  100101010101001 \n  100101101101001 \n  100101111101001 \n  100109990011001 \n  100110000011001 \n  100110010011001 \n  100110091011001 \n  100110101011001 \n  100110111011001 \n  100110990111001 \n  100111000111001 \n  100111010111001 \n  101000000000101 \n  101000010000101 \n  101000020000101 \n  101000101000101 \n  101000111000101 \n  101000990100101 \n  101001000100101 \n  101001010100101 \n  101001091100101 \n  101001101100101 \n  101001111100101 \n  101010000010101 \n  101010010010101 \n  101010101010101 \n  101010111010101 \n  101010990110101 \n  101011000110101 \n  101011010110101 \n  101100000001101 \n  101100010001101 \n  101100101001101 \n  101100111001101 \n  101101000101101 \n  101101010101101 \n  101110000011101 \n  101110010011101 \n  110000000000011 \n  110000010000011 \n  110000020000011 \n  110000091000011 \n  110000101000011 \n  110000111000011 \n  110001000100011 \n  110001010100011 \n  110001101100011 \n  110001111100011 \n  110010000010011 \n  110010010010011 \n  110010091010011 \n  110010101010011 \n  110010111010011 \n  110011000110011 \n  110011010110011 \n  110100000001011 \n  110100010001011 \n  110100101001011 \n  110100111001011 \n  110101000101011 \n  110101010101011 \n  110110000011011 \n  110110010011011 \n  111000000000111 \n  111000010000111 \n  111000091000111 \n  111000101000111 \n  111000111000111 \n  111001000100111 \n  111001010100111 \n  111010000010111 \n  111010010010111 \n  111100000001111 \n  111100010001111 \n  129610990752569 \n  200000000000002 \n  200000010000002 \n  210786628549538 \n  314155324482867 \n  1000000000000000 \n  1000000110000000 \n  1000001001000000 \n  1000001111000000 \n  1000010000100000 \n  1000010110100000 \n  1000011001100000 \n  1000011111100000 \n  1000100000010000 \n  1000100110010000 \n  1000101001010000 \n  1000101111010000 \n  1000110000110000 \n  1000110110110000 \n  1000111001110000 \n  1001000000001000 \n  1001000110001000 \n  1001001001001000 \n  1001001111001000 \n  1001010000101000 \n  1001010110101000 \n  1001011001101000 \n  1001100000011000 \n  1001100110011000 \n  1001101001011000 \n  1001110000111000 \n  1010000000000100 \n  1010000110000100 \n  1010001001000100 \n  1010001111000100 \n  1010010000100100 \n  1010010110100100 \n  1010011001100100 \n  1010100000010100 \n  1010100110010100 \n  1010101001010100 \n  1010110000110100 \n  1011000000001100 \n  1011000110001100 \n  1011001001001100 \n  1011010000101100 \n  1011100000011100 \n  1100000000000010 \n  1100000110000010 \n  1100001001000010 \n  1100001111000010 \n  1100010000100010 \n  1100010110100010 \n  1100011001100010 \n  1100100000010010 \n  1100100110010010 \n  1100101001010010 \n  1100110000110010 \n  1101000000001010 \n  1101000110001010 \n  1101001001001010 \n  1101010000101010 \n  1101100000011010 \n  1110000000000110 \n  1110000110000110 \n  1110001001000110 \n  1110010000100110 \n  1110100000010110 \n  1111000000001110 \n  2000000000000000 \n  2201019508986470 \n  2564053868197730 \n  3066446727654240 \n  3107974295870660 \n  3138199296186060'''\n  pal_sqr_roots = map(int, pal_sqr_roots.split())\n  \n  \n  \n  def is_palindrome(n):\n      return str(n)[::-1] == str(n)\n  \n  palindromic_roots = [x for x in pal_sqr_roots if is_palindrome(x)]\n  \n  fair_and_square = [x*x for x in palindromic_roots]\n  \n  \n  def get_num_fair_and_square(a, b):\n      return len([x for x in fair_and_square if a <= x <= b])\n  \n  for caseNo in range(1, int(input())+1):\n      a,b = map(int, input().split())\n      print 'Case #%d:' % caseNo, get_num_fair_and_square(a, b)\n  \n", "substitutes": {"inf": ["zin", "exp", "obj", "cli", "Info", "ins", "cin", "iter", "eth", "feed", "ref", "input", "fi", "inn", "qt", "prot", "thin", "txt", "raw", "fen", "init", "ln", "utils", "dict", "alf", "arf", "std", "ipl", "inner", "din", "tif", "cl", "irc", "rec", "elf", "cgi", "pub", "fin", "info", "inc"], "pal_sqr_roots": [" sys_sqr_files", " sys_sqr_roots", " sys_sqrt6roots", " sys_sqr6roots", " sys_sqr_name", " sys_sqrt_name", " sys_sqr6name", " sys_sqr1roots", " sys_sqrt_files", " sys_sqr1name", " sys_sqrt6files", " sys_sqr6root", " sys_sqrt6name", " sys_sqr_root", " sys_sqr6files", " sys_sqrt6root", " sys_sqr1files", " sys_sqrt_roots", " sys_sqrt_root", " sys_sqr1root"]}}
{"code": " \n  '''\n  Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]\n  At least S of the ti values will be between 2 and 28, inclusive.\n  \n  Small dataset 1 = N = 3.\n  Large dataset 1 = N = 100.\n  \n  Sample Input \n  4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \n  Output \n  Case #1: 3\n  Case #2: 2\n  Case #3: 1\n  Case #4: 3\n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  def maxBestDancers(N, S, p, *Ti):\n      cnt = 0\n      for score in Ti:\n          mx = (score + 2) // 3\n          if mx >= p:\n              cnt += 1\n          elif mx >= p-1 > 0 and S>0:\n              S -= 1\n              cnt += 1\n      return cnt\n  \n  for caseNo in range(1, int(input())+1):\n      print 'Case #%d:' % caseNo,\n      lst = map(int, input().split())\n      print maxBestDancers(*lst)\n  \n", "substitutes": {"inf": ["zin", "lo", "magic", "exp", "zz", "iw", "Info", "ins", "cin", "feed", "api", "iter", "input", "inn", "qt", "prot", "thin", "raw", "fen", "init", "fif", "ln", "utils", "std", "arf", "ipl", "inner", "abs", "pi", "irc", "rec", "elf", "plus", "cgi", "fin", "inc", "info", "lin", "fits", "conf"], "N": ["P", "J", "Q", "z", "Z", "D", "Size", "H", "n", "I", "M", "NA", "A", "np", "SN", "NN", "G", "U", " n", "Ni", "Ns", "W", "O", "E", "Sn", "C", "V", "L", "X", "K", "Y", "T", "B", "F", "NS", "R"], "S": ["P", "Q", "J", "size", "Z", "D", "Size", "Sc", "Ps", "H", "n", "I", "s", "M", "SO", "A", "SN", "SR", "SA", "Sl", "SH", "G", " s", "U", "Sa", "SE", "Ns", "W", "ps", "O", "E", "SC", "SP", "Sn", "C", "V", "Si", "L", "X", "Y"], "p": ["P", "l", "Q", "j", "z", "pp", "t", "i", "u", "Ps", "n", "lp", "b", "s", "r", "IP", "pe", "cp", "M", "v", "jp", "np", "k", "d", "m", "wp", "power", "x", "pi", "tp", "o", "pc", "ap", "e", "ps", " P", "sp", "h", "y", "C"], "cnt": ["cno", " c0", "ucct", "count", "colNT", " count", " crt", "colount", "Cnc", "colnt", " cct", "ecnt", "lcct", "col0", "ucnt", " cno", "C0", "c0", "cnc", " cNT", "ucnc", "acnt", "acct", "Cnt", "acNT", "CNT", " cnc", "ecnc", "lcnt", "ecrt", "crt", "acnc", "lcount", "acount", "ucrt", "lcno", "ecct", "Count", "cNT", "cct"], "score": ["fee", "nice", "min", "size", "z", "chi", "error", "core", "set", "rate", " scores", "count", "distance", "pair", "trial", "np", "scan", "level", " scoring", "rank", "Score", "sci", "cpu", "num", "ni", "match", " penalty", "pi", "grade", "si", "gram", "skip", "result", "poly", "weight", "ranking", "word", "nz", "zi", "y"], "mx": ["exp", "wm", "py", "ti", "core", "mn", "n", "nu", "pm", "me", "cp", "xml", "Mi", "cross", "cycle", "jp", "np", "net", "cm", "yz", "rank", "m", "wp", "mc", "ns", "hop", "x", "rx", "MC", "mu", "prefix", "cpu", "bp", "ni", "pha", "Ni", "MX", "ap", "poly", "weight"], "caseNo": [" caseNO", "CaseNO", " caseNumber", "CaseNum", "trialNo", "matchNo", "trialno", " caseno", "matchNO", "caseno", "Caseno", "caseNumber", "CaseNo", "matchNum", "caseNum", "matchno", "trialNumber", "CaseNumber", "trialNum", " caseNum", "caseNO"], "lst": ["llsts", "lST", "elsts", " lsc", " lbl", "lsc", " lST", "lbl", "llnd", "elst", "plnd", "lnd", "llST", "llbl", "plbl", "lsts", "elbl", "elsc", "plst", "plST", "llsc", "llst", " lsts", " lnd"]}}
{"code": " \n  def generateTable(N):\n      msq = range(1, 4) + [11, 22] + [101, 111, 121, 202, 212]\n      nums = revnums = [1, 2]\n  \n      digsums = [1, 4]\n  \n      for i in xrange(2, N+1):\n          a, b, d = [], [], []\n          p = 10**(i-1)\n          for j in xrange(len(nums)):\n              for k in xrange(3):\n                  n, rn, ds = 10*nums[j] + k, revnums[j] + k*p, digsums[j] + k*k\n                  if ds < 5:\n                      a.append(n)\n                      b.append(rn)\n                      d.append(ds)\n                      msq.append(10*p*n + rn) # even length\n                      if i == N:\n                          continue\n                      for l in xrange(3): # odd length\n                          if 2*ds + l*l < 10:\n                              msq.append(100*p*n + 10*p*l + rn)\n          nums, revnums, digsums = a, b, d\n  \n      msq.sort()\n      return msq\n  \n  def getNum(A, B):\n      return bisect_right(tab2, B) - bisect_right(tab2, A-1)\n  \n  N = 10\n  tab = generateTable(N)\n  tab2 = map(lambda n: n**2, tab)\n  \n  T = int(raw_input())\n  for z in xrange(T):\n      A, B = map(int, raw_input().split())\n      print \"Case #%d: %d\" % (z+1, getNum(A, B))\n", "substitutes": {"N": ["II", "P", "J", "Q", "Z", "D", "Size", "NI", "H", "I", "NC", "RN", "M", "NA", "NT", "Len", "NN", "NB", "NE", "Nat", "NM", "G", "U", "num", "TN", "Ni", "Ns", "W", "O", "Num", "E", "Tab", "NO", "C", "CNN", "S", "V", "Ne", "L", "X"], "msq": ["Msq", "msqs", "psq", "osqu", " msqu", "Msqu", "mmeq", "leseq", "msdq", "sdq", "mmq", "mmql", "mseq", "omsq", "oesq", "mosq", "vsqu", "squ", "ssqs", "msg", "moseq", "psqs", "nsqs", "oeseq", "osq", "mosg", "masql", "msql", "lesql", "ssq", "nseq", "ssqu", "Msc", " msg", "nsq", "vsq", "Msqs", "omsql", "osc", "sql"], "nums": ["cnums", "cumbers", "nummies", "anonumbers", " nummies", " num", "Nums", "cum", "cnummies", "cnum", "Numbers", " numbers", "inubs", " nubs", "Nummies", " nams", "anonum", "anonummies", " noms", "inums", "num", "cnumbers", "noms", "anonums", "cnoms", "inummies", "nams", "numbers", "cnubs", "inams", "Noms", "coms", "nubs", "cnams", "cums", "Num"], "revnums": ["revrnums", "revnoms", "RevNumes", "RevNums", "Revnumbers", "revrnoms", "revNumes", "revnumer", "Revcumbers", "revbynoms", "revznoms", "revcums", "revznumbers", "revunoms", "Revnoms", "revunums", "revrnumer", "revNum", "Revcums", "revunum", "revbynums", " revnoms", "revnum", "revcumbers", "revnames", "revznum", "revcum", " revrnum", "RevNoms", "RevNames", "revrnumes", "revrnames", "revbynames", " revnumer", "Revnumes", "revNumbers", "Revcum", "Revnums", "Revcoms", "Revnum"], "digsums": ["dligumes", "drigmas", "dimensums", "digumes", "digmas", "dimensumes", "dighums", "digsqs", "digsummies", "Digsames", "adigsqs", "digums", "dIGum", "adigqs", "adigsims", "dimensum", "dIGums", "drigqs", "dighum", "diglums", "adigsummies", "dligums", "adigsum", "digummies", "Digums", "dimensames", "Digum", "Digumes", "adigims", "Digsums", "digsmas", "digqs", "adigmas", "adigums", "diglims", "digsumes", "dIGummies", "digames", "Digsum", "dligames"], "i": ["P", "ai", "ip", "ji", "chi", "jl", "ki", "u", "ti", "t", "I", "im", "r", "v", "ih", "ui", "phi", "ik", "int", "xi", "ie", "bi", "li", "id", "limit", "m", "iu", "x", "pi", "ni", "mi", "num", "o", "nb", "e", "h", "zi", "y", "f", "axis"], "a": ["ak", "ai", "aa", "ab", "ama", "alpha", "art", "u", "api", "va", "am", "r", "s", "ba", "au", "sa", "asa", "ao", "aw", "ga", "ae", "m", "na", "x", "o", "ac", "up", "la", "ap", "da", "e", "ea", "an", "h", "ad", "ca", "y", "f", "ar", "af"], "b": ["xb", "aa", "ab", "abb", "bl", "ib", "u", "rb", "bb", "emb", "boot", "r", "s", "v", "ba", "wb", "db", "fb", "be", "bf", "m", "eb", "bs", "ob", "mb", "o", "lb", "bur", "nb", "e", "cb", "h", "ad", "y", "f", "ub", "c", "g", "w", "sb"], "d": ["ld", "deb", "dc", "vd", "D", "t", "u", "mad", "dx", "bd", "r", "s", "v", "md", "data", "dr", "dl", "db", "dat", "do", "rd", "id", "m", "x", "pad", "di", "o", "dom", "dos", "da", "e", "dh", "h", "ad", "du", "y", "diff", "pd", "f", "ud"], "p": ["P", "ip", "per", "pp", "py", "u", "t", "pn", "pl", "r", "s", "v", "lp", "pr", "pe", "cp", "np", "pos", "m", "x", "pi", "tp", "o", "pc", "ap", "e", "ps", " P", "sp", "pre", "h", "y", "f", "ar", "pt", "q", "c", "g", "fp", "w"], "j": ["bj", "note", "J", "uj", "section", "adj", "ji", "ij", "kk", "obj", "jl", "key", "u", "br", "jan", "old", "r", "s", "v", "js", "ijk", "jp", "it", "ik", "kn", "ie", "ch", "part", "li", "ok", "m", "jen", "er", "jo", "je", "jj", "o", "oj", "ix", "jon"], "k": ["ak", "P", "kk", "pp", "key", "t", "u", "ki", "dk", "ke", "ks", "r", "v", "ku", "ijk", "s", "pe", "ko", "uk", "kn", "ik", "kl", "yk", "unk", "ok", "m", "kg", "ek", "ky", "mk", "sh", "x", "pi", "o", "ac", "e", "h", "y", "km", "f"], "n": ["obj", "u", "pn", "t", "nan", "r", "s", "v", "nu", "node", "nw", "conn", "all", "np", "net", "ne", "ln", "name", "on", "nr", "m", "na", "dn", "yn", "ns", "nin", "x", "ni", "num", "o", "nb", "e", "Ns", "an", "nc", "cn", "ny", "y", "len", "nm"], "rn": ["nv", "dc", "rf", "kk", "pn", "core", "mn", "r", "lp", "RN", "inn", "nw", "ign", "np", "kn", "ne", "ron", "ln", "nor", "nr", "rd", "na", "dn", "lr", "din", "ns", "syn", "rx", "nil", "gn", "da", "cb", "nc", "nn", "cn", "nz", "f", "sn", "dy", "rc"], "ds": ["ld", "dc", "lines", "pn", "df", "nos", "dx", "eps", "ks", "cd", "s", "lp", "fd", "els", "js", " dd", "cp", "dim", "dl", "db", "Ds", "cs", "np", "dat", "sync", "dp", "ys", "ded", "dn", "bs", "ists", "ns", "di", "dos", "da", "ops", "vs", "ps", "xs", "ls"], "l": ["u", "t", "r", "s", "v", "lp", "dl", "ln", "li", "fl", "m", "ns", "x", "length", "lin", "e", "ol", "il", "ls", "h", "len", "y", "f", "long", "q", "L", "c", "el", "lc", "ll", "g", "w", "nl", "sl", "un", "kl"], "A": ["Q", "J", "Ac", "API", "D", "alpha", "Data", "Len", "SA", "TA", "One", "Tab", "Wa", "L", "Y", "Count", "Num", "AY", "Na", "Az", "H", "AB", "M", "NA", "Am", "KA", "App", "U", "AW", "AI", "W", "Ar", "O", "CA", "E", "V", "X", "An", "mA", "FA"], "B": ["P", "Q", "WB", "Ub", "QB", "ab", "DB", "Z", "D", "FB", "GB", "BT", "IB", "UB", "AB", "BF", "RB", "LB", "M", "Base", "Ab", "AP", "SB", "PB", "VB", "NB", "BL", "Bs", "G", "U", "BER", "BB", "BC", "CB", "BG", "BE", "BS", "W", "EB", "O"], "tab": ["config", "mm", "cell", "text", "ab", "tri", "abb", "bl", "ib", "atom", "case", "bb", "cart", "loc", "t", "abc", "AB", "col", "count", "loop", "nav", "circ", "flat", "trial", "lab", "array", "db", "txt", " Tab", "acc", "TA", "ob", "table", "abs", "num", "row", "mat", "ct", "cont", "nb"], "tab2": [" tab3", "colB", "tab3", "bb4", "table4", "tableB", "tab4", "Tab1", "abB", "bb3", "Tab2", "col1", " tab4", "table1", "bb2", " tab1", "bb1", "Tab4", "ab2", "tab1", "Tab3", "col2", "ab1", "tabB", "table2"], "T": ["P", "J", "Q", "DT", "TS", "Z", "D", "Ti", "TH", "t", "H", "I", "Trans", "M", "Len", "NT", "TC", "Ts", "TG", "Tw", "TW", "WT", "Time", "TA", "U", "TN", "Tu", "W", "Total", "Tab", "E", "TL", "C", "Length", "S", "V", "L", "X", "TB", "TT"], "z": ["step", "ZZ", "Z", "zip", "zz", "t", " Z", "zh", "count", "loop", "v", "slice", "ZI", "phi", "int", "zen", "az", "fl", "pos", "zone", "m", "ez", "seed", "time", "x", "tz", "num", "zo", "zy", "e", "ze", "depth", "ice", "nz", "zi", "div", "iz", "y", "f", "zer"]}}
{"code": "T = int(raw_input())\n  \n  for z in xrange(1, T+1):\n      a = map(int, raw_input().split())\n      s, p = a[1:3]\n      a = a[3:]\n      A = 0 if p == 0 else 3*p - 2\n      B = 0 if p == 0 else 1 if p == 1 else 3*p-4\n      x = len(filter(lambda x: x >= A, a))\n      y = len(filter(lambda x: x >= B, a)) - x\n      res = x + min(s, y)\n      print \"Case #%d:\" % z, res\n", "substitutes": {"T": ["P", "Q", "TS", "Z", "D", "t", "H", "I", "n", "M", "NT", "Max", "Ts", "TW", "m", "WT", "Time", "time", "pot", "G", " t", "ta", "N", "TN", "o", "W", "O", "Total", "E", "C", "f", "S", "V", "L", "X", "c", "TT", "Y", "K", "F"], "z": ["exp", "hz", "j", "Z", "i", "u", " d", "zh", " Z", "max", " ii", " l", "abc", "n", "r", "v", " rand", "red", "int", "k", "d", "id", "zone", "yz", "wx", "tz", "num", "xt", "rec", " c", "o", "zo", "ix", "e", "series", "poly", "nz", "zi", "iz", "ry"], "a": ["ak", "aa", "l", "ai", "wa", "sta", "ab", "alpha", "art", "t", "u", "api", "va", "i", "am", "ast", "n", "ba", "b", "au", "sa", "asa", "array", "ha", "int", "aw", "ga", "area", "ae", "d", "m", "ata", "ax", "ta", "auto", "o", "ac", "ans", "da", "ap"], "s": ["l", "es", "sq", "t", "ins", "u", "ss", "n", "r", "b", "v", "ses", "xx", "sa", "yi", "ays", "ies", "sv", "ows", "ds", "d", "m", "ys", "bs", "ns", "o", "sb", "ix", "ans", "e", "ps", "xs", "ls", "an", "h", "f", "S", "q", "c", "sy"], "p": ["P", "l", "j", "pp", "per", "alpha", "t", "u", "i", "n", "r", "b", "v", "pe", "pr", "cp", "lp", "array", "phi", "np", "k", "d", "m", "pi", "tp", "bp", "point", "o", "pc", "ap", "e", "ps", " P", "sp", "an", "h", "f", "pt", "q", "c"], "A": ["P", "Q", "Ca", "Na", "As", "Z", "D", "alpha", "AA", "LA", "H", "I", "AB", "b", "Ax", "M", "GA", "NA", "Bu", "Ab", "AP", "Am", "Alpha", "HA", "G", "ax", "U", "N", "AD", "ac", "da", "At", "Ar", "CA", "AF", "C", "S", "f", "L", "X"], "B": ["AR", "P", "Q", "J", "WB", "DB", "Z", " b", "D", "AA", "GB", "BT", "Beta", "H", "I", "AB", "b", "BF", "M", "Ab", "SB", "PB", "NB", "Bs", "G", "U", "N", "BB", "BC", "Blue", "CB", "W", "O", "BA", "E", "C", "MB", "S", "V", "L"], "x": ["l", "ex", "alpha", "t", "i", "input", "b", "xx", "int", "id", "rx", "point", "o", "ct", "tx", "xs", "h", "c", "Y", "g", "px", "hex", "XX", "wa", "j", "case", "r", "data", "cross", "xy", "xi", "xxxx", "ww", "m", "ix", "ya", "an", "en", "code", "X"], "y": ["l", "j", "min", "yy", "i", "t", "u", "py", "n", "b", "v", "xx", "yi", "phi", "xy", "int", "ys", "d", "vy", "m", "pi", "cy", "o", "ye", "oy", "ya", "ey", "zy", "e", "ry", "h", "f", "yt", "dy", "c", "Y", "g", "w", "height", "yx"], "res": ["exp", "vec", "es", "sol", "max", "rand", "eps", "ms", "r", "req", "data", "gr", "ids", " Res", "arr", "nr", "grid", "pos", "id", "re", "resp", "RES", "ret", "err", "ns", "ax", "details", "val", "response", "rec", "rev", "win", "row", "rx", "Res", "os", "rows", "our", "result", "poly"]}}
{"code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def pal(x):\n      l = list(str(x))\n      l2 = copy.copy(l)\n      l2.reverse()\n      return l == l2\n  \n  for i in range(num):\n      count = 0\n      line = f.readline()\n      a,b = line.split()\n      a = int(a)\n      b = int(b)\n      ma = int(math.sqrt(a))\n      mb = int(math.sqrt(b))+1\n      for j in range(ma,mb+1):\n          q = j*j\n          if q < a or q > b:\n              continue\n          if pal(j) and pal(q):\n              count += 1\n      print 'Case #{}:'.format(i+1), count\n", "substitutes": {"f": ["z", "folder", "t", "u", "feed", "df", "iter", "ref", "n", "r", "s", "sf", "fd", "v", "inf", "data", "full", "stream", "fen", "fc", "xf", "fb", "tf", "func", "d", "fx", "p", "m", "file", "form", "handler", "fr", "er", "o", "io", "e", "lf", "buff", "h", "fa"], "num": ["mm", "month", "size", "unit", "iter", "u", "loc", "lim", "col", "mn", "n", "zero", "dim", "mon", "NUM", "np", "name", "multi", "om", "cm", "um", "id", "p", "m", "nom", "uni", "pos", "mu", "offset", "dom", "nb", "nam", "temp", "nc", "div", "nm", "du", "len", "norm", "sum"], "x": ["xb", "ex", "text", "es", "z", "u", "xe", "xxx", "n", "input", "s", "v", "xml", "xx", "pe", "r", "data", "cross", "array", "xf", "element", "xy", "xi", "name", "xc", "k", "xes", "p", "m", "val", "rx", "xt", "o", "ix", "e", "xs", "h", "y", "code", "X"], "l": ["le", " L", "z", "pl", "bl", "t", "u", "n", "r", "s", "v", "lp", "dl", "ell", "ln", "k", "li", "fl", "d", "al", "p", "m", "list", "o", "lb", "lin", "la", "e", "ol", "il", "ls", "h", "y", "ul", "len", "L", "c", "el", "split", "lc"], "l2": ["Lball", "L1", "Ltwo", "b2", "L2", "l4", "lball", "l5", " l4", "litwo", "b5", "line1", "L5", " l5", "b4", "li1", "line2", "ltwo", " ltwo", "L4", " l1", "lineball", "li2", "l1", "b1", " lball"], "i": ["ai", "ip", "ir", "ij", "obj", "z", "page", "ib", "ti", "u", " ii", "col", "I", "im", "ih", "n", "qi", "ui", "slice", "it", "uri", "item", "int", "xi", "type", "init", "ie", "name", "k", "part", "li", "ei", "d", "id", "p", "limit", "iu", "pi", "gu", "o"], "count": ["log", "cond", "comp", "size", "z", "case", "key", "cc", "label", "max", "ib", "old", "seq", "n", "loop", "found", "now", "call", "order", "total", "handle", "type", "name", "ch", "low", "li", "id", "p", "err", "list", "ph", "match", "length", "info", "offset", "skip", "find", "cache", "conf", "depth"], "line": ["LINE", "le", "log", "strip", "cell", "lines", "page", "bl", "out", "iter", "u", "comment", "mode", "url", "n", "r", "s", "v", "range", "shell", "header", "data", "source", "raw", " Line", "ln", "sync", "p", "m", "file", "list", "lock", "block", "cl", "str", "row", "lin", "e", "lf", "no"], "a": ["ak", "aa", "ai", "wa", "ab", "ama", "z", "alpha", "za", "art", "u", "va", "am", "oa", "n", "r", "s", "au", "ba", "sa", "A", "asa", "qa", "aw", "ga", "area", "d", "p", "ae", "m", "o", "ac", "la", "da", "ea", "e", "ja", "an", "ad", "ca"], "b": ["bar", "aa", "ab", "z", "bl", "ib", "u", "bb", "rb", "emb", "n", "r", "ba", "v", "s", "wb", "db", "fb", "k", "bi", "d", "be", "p", "bf", "m", "eb", "body", "bc", "bs", "ob", "binary", "o", "lb", "nb", "e", "cb", "base", "h", "y", "c"], "ma": ["aa", "mm", "wa", "ama", "mas", "alpha", "Ma", "u", "bb", "za", "am", "ms", "n", "md", "mp", "au", "sa", "ha", "qa", "area", "ga", "d", "ae", "p", "ra", "m", "aea", "ka", "na", "mc", "ta", "ema", "sha", "ya", "la", "da", "ea", "e", "base", "ca"], "mb": ["xb", "aa", "mm", "ab", "mt", "ib", "mag", "rb", "bb", "emb", "mad", "mn", "ms", "mp", "nob", "md", "kb", "db", "fb", "om", "cm", "bf", "m", "eb", "bc", "amb", "mc", "ob", "mega", "gb", "lb", "la", "nb", "large", "pg", "cb", " mm", "mma", "MB", "amber"], "j": ["bj", "J", "mm", "ji", "z", "ij", "bl", "jl", "u", "br", "bb", " ii", "am", "n", "r", "s", "v", "js", "qi", "jp", "qa", "int", "ie", "jam", "bi", "k", "li", "ch", "d", "p", "m", "iu", "aq", "fr", "sh", "jo", "je", "dj", "jj", "o"], "q": ["Q", "qu", "mm", "z", "u", "bb", "t", "ue", "quality", "n", "one", "v", "r", "qi", "range", "qt", "qq", "eq", "jp", "qa", "dq", "int", "quant", "k", "ch", "d", "id", "qs", "p", "m", "ql", "aq", "sh", "ph", "cl", "arch", "ant", "quest", "ix", "ac"]}}
{"code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      res = [int(x) for x in f.readline().split()]\n      nrg, nrsup, score = res[0:3]\n      del res[0:3]\n      nrpass = 0\n      nrsuppass = 0\n      for x in res:\n          if score > 1:\n              if x >= 3*score-2:\n                  nrpass += 1\n              elif x >= 3*score-4:\n                  nrsuppass += 1\n          elif score == 1:\n              if x > 0:\n                  nrpass += 1\n          else:\n              nrpass +=1\n      print 'Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass)\n", "substitutes": {"f": ["l", "j", "z", "folder", "rf", "feed", "df", "t", "ref", "n", "r", "b", "s", "v", "fd", "sf", "inf", "fe", "stream", "fc", "fb", "tf", "frame", "k", "ch", "d", "fx", "p", "bf", "m", "file", "form", "handler", "fr", "er", "o", "io", "os", "e", "lf"], "num": ["size", "unit", "iter", "max", "loc", "lim", "col", "n", "range", "count", "loop", "dim", "NUM", "np", "init", "name", "gen", "nr", "om", "pos", "id", "um", "nom", "uni", "file", "block", "end", "nb", "nam", "temp", "status", "nc", "no", "div", "len", "en", "norm", "ul", "sum", "mult"], "i": ["ex", "l", "ip", "j", "z", "chi", "cli", "u", "out", "ti", "col", "im", "I", "ih", "n", "v", "bit", "r", "isi", "slice", "yi", "uri", "int", "xi", "ie", "name", "k", "bi", "li", "ei", "d", "id", "pos", "p", "iu", "index", "pi", "o", "io", "ix"], "res": ["progress", "pres", "all", "breaks", "re", "file", "ores", "rx", "val", "Results", "rr", "vals", "reg", "lines", "obj", "out", "ras", "nos", "rate", "r", "data", "rats", "raw", " Res", "gen", "blocks", "qs", "resp", "ret", "err", "os", "rem", "files", "rates", "R", "sol", "ms", "req", "s", "Rs"], "x": ["ex", "t", "b", "xx", "int", "sex", "name", "id", "rx", "ct", "tx", " cx", "xs", "nc", "h", "y", "c", "ctx", "g", "px", "est", "r", "cross", "xy", "xi", "sync", "xxxx", "m", "ix", " exam", "no", "a", " index", "code", "X", "number", "xa", "w", "xp", "index"], "nrg": ["cnperse", "ngin", "pnperse", "pnrw", "nzgin", "pngin", "cnrg", "nperse", "cnrw", "cngin", "nrw", "nzperse", "nzrg", "nzrw", "pnrg"], "nrsup": ["nrssample", "Narsup", " nrsupe", "narsuper", "Nrsuper", "nrsuper", "nricshaw", "nrsshaw", "nricsupe", "nlsup", " ncsample", "nrsups", "nricsup", "ncsup", "nrssup", "ncshaw", "ncsample", "nrsupe", "nrsample", "nrshaw", "nrssupe", "nrsupp", "nRSups", " ncsupe", "nricsample", "nlsuper", "Narsups", "ncsupe", " ncsup", " ncshaw", " nrsample", "Nrsupp", "nRSup", "nRSuper", "Nrsups", "narsup", "narsupp", "nlsupp", "Nrsup", "nlsups"], "score": ["sat", "color", "key", "fit", "scale", "fen", "ne", "name", "rank", "file", "rx", "line", "grade", "team", "y", "feature", "est", "size", "eni", "case", "core", "rate", "value", "rage", "cross", "order", "xy", "level", "sync", "Score", "race", "play", "cache", "winner", "ize", "en", "scoring", "year", "code", "orer"], "nrpass": ["nlwin", "nlskip", "adrpassword", "nrfail", "nrstep", "rnsect", "NRpassword", "nrwin", "rnpassword", "mrPASS", "rxpos", "NRpass", "nrPASS", "rnstrip", "nlstep", "nlpass", "rxpass", "usrcross", "rnskip", "nrpassword", "srstep", "lrfail", "rnPASS", "rnwin", "adrstep", "usrpass", "NRsect", "mrstep", "mrpos", "mrcross", "adrsect", "nrcross", "lrcross", "ncskip", "srpass", "mrfail", "adrpass", "rnstep", "nrsect", "rnpos"], "nrsuppass": ["nruppasses", "rsuppress", "nroppasses", "norcompact", "nrcompress", "rcompass", "norcomposs", "rcompress", "nrSuppass", "nruppress", "nrcompact", "nropposs", "nrcomposs", "nrsuppasses", "norsuppact", "rsuppasses", "nrcompass", "nrcompasses", "nrsupposs", "nrSuppress", "nrsuppress", "norsuppass", "rsuppass", "norsupposs", "nrSuppact", "nruppass", "nrupposs", "norsuppasses", "nroppact", "nrSuppasses", "norcompasses", "norcompass", "nrsuppact", "rcomposs", "nrSupposs", "nroppass", "rsupposs", "rcompasses"]}}
{"code": " \n  def ss(t, amap, bmap):\n      s = 0\n      for m in amap:\n          if len(m) == 1 and t == m.keys()[0]:\n              s += m[t]\n              for b in bmap:\n                  if t in b:\n                      b[t] -= 1\n                      if b[t] == 0:\n                          b.pop(t)\n              m.clear()\n      return s           \n  \n  \n  def solve(case, in_lines):\n      out = 'Case #%d: '%case\n   \n      rn, cn = [int(x) for x in in_lines[0].split()]\n      mtx = []\n      for i in xrange(rn):\n          mtx.append([int(x) for x in in_lines[i+1].split()])\n      rmap = [{} for x in xrange(rn)]\n      cmap = [{} for x in xrange(cn)]\n      td = {}\n      \n      for i in xrange(rn):\n          for j in range(cn):\n              k = mtx[i][j]\n              if k in rmap[i]:\n                  rmap[i][k] += 1\n              else:\n                  rmap[i][k] = 1\n              if k in cmap[j]:\n                  cmap[j][k] += 1\n              else:\n                  cmap[j][k] = 1\n              if k in td:\n                  td[k] += 1\n              else:\n                  td[k] = 1\n                  \n      while len(td):\n          k = min(td.keys())\n          sb = ss(k, rmap, cmap)\n          sb += ss(k, cmap, rmap)\n          if sb == 0:\n              break;\n          td[k] -= sb\n          if td[k] == 0:\n              td.pop(k)\n  \n      return out + ('YES' if sb else 'NO')\n  \n  \n  def main(raw):\n      lines = raw.split('\n')\n      n = int(lines[0])\n      ln = 1\n      outs = []\n      for case in xrange(1, n+1):\n          buff = []\n          cl = int(lines[ln].split()[0]) + ln + 1\n          while ln < cl and lines[ln]:\n              buff.append(lines[ln])\n              ln += 1\n          s = solve(case, buff)\n          print s\n          outs.append(s)\n      return '\n'.join(outs)\n      pass\n  \n  if __name__ == '__main__':\n      test_input = \"\"\"4\n  4 3\n  2 5 2\n  1 1 1\n  2 4 2\n  2 3 2\n  3 3\n  2 1 2\n  1 1 1\n  2 1 2\n  5 5\n  2 2 2 2 2\n  2 1 1 1 2\n  2 1 2 1 2\n  2 1 1 1 2\n  2 2 2 2 2\n  1 3\n  1 2 1\"\"\"\n      force_no_file = False\n      in_file_name = '' if force_no_file else 'B-large.in'\n      base_path = 'G:/workspace/py/codejam2013/RQ/'\n      if in_file_name:\n          with open(base_path + in_file_name) as f:\n              raw = f.read()\n      else:\n          raw = test_input\n      out = main(raw)\n      if in_file_name:\n          with open(base_path + in_file_name + '.out', 'w') as f:\n              f.write(out)\n      pass\n", "substitutes": {"t": ["l", "z", "target", "u", "ti", "r", "v", "qt", "ot", "tt", "port", "te", "int", "type", "tf", "name", "tm", "tom", "rt", "d", "wt", "p", "id", "ret", "table", "ta", "tp", "token", "o", "ant", "ct", "lat", "tn", "e", "tun", "h", "y", " T", "pt", "f"], "amap": [" amaps", "amapper", "ramaps", "pmaps", "acapper", "acaps", "mapper", "ammap", "amaps", "acap", "ramapper", "pmap", "pmapping", "ramap", "maps", "pmapper", "map", " amapper", "acmap", " amapping", "ramapping", "mmap", " ammap", "amapping"], "bmap": ["bcap", " bcap", "wmap", "rblock", " btable", " bblock", "bbapp", "cbmaps", "rcap", "lbblock", "bmaps", "lbtable", "bbmap", "warray", "cbmap", "cbapp", "lbcap", "bbmaps", "wapp", "cbarray", "lbmap", "bapp", "wmaps", "bblock", "bbarray", "rtable", "barray", "btable"], "s": ["l", "shell", "stats", "breaks", "sh", "bis", "o", "ans", "conf", "h", "y", "start", "string", "c", "g", "strings", "si", "size", "ing", "sets", "sf", "ses", "r", "js", "se", "sync", "site", "bs", "ns", "abs", "er", "its", "os", "ops", "spec", "sp", "ls", "ed", "en", "ssl"], "m": ["l", "sm", "mm", "mt", "z", "mun", "ab", "bl", "u", "mr", "am", "mn", "ms", "mp", "r", "pm", "v", "md", "im", "M", "meta", "tm", "d", "cm", "p", "mc", "table", "mu", "ym", "fm", "mi", "mat", "o", "map", "module", "e", "cache", "machine", "hm", "arm"], "b": ["xb", "l", "ab", "z", "bl", "br", "u", "bb", "ib", "rb", "emb", "r", "ba", "v", "wb", "db", "bh", "fb", "bi", "d", "p", "bf", "eb", "bm", "bc", "bs", "ob", "bis", "mb", "o", "gb", "lb", "nb", "base", "cb", "e", "bt", "h", "y", "a"], "case": ["exc", "l", "address", "sea", "feed", "ce", "loc", "path", "ase", "int", "name", "ace", "id", "table", "line", "ct", "conf", "nc", "h", "switch", "c", "instance", "ci", "section", "shape", "core", "r", "fe", "time", "bc", "client", "fold", "base", "ice", "no", "a", "code", "X", "use", "patch"], "in_lines": ["out_planes", " inxcases", "in_line", "in_planes", " in_cells", "in_files", " in_line", " inxfiles", "inxline", " inxlines", "out_cells", " in_cases", " inxbreaks", "in5cycles", " inxcells", " inxline", "inxcases", "out_lines", "inxfiles", " in_breaks", "inxcells", "in_breaks", "in_cycles", "in5planes", " in_files", "inxbreaks", "inxlines", "in5lines", "out_cycles", "in_cases", "in5cells", "in_cells"], "out": ["IN", "summary", "echo", "Out", "external", "new", "obj", "text", "example", "error", "Output", "comment", "statement", "print", "static", "flat", "full", "msg", "it", "bin", "init", "expression", "dot", "name", "again", "inner", "err", "prefix", "str", "o", "io", "short", "conf", "report", "OUT", "copy", "output", "script", "sum", "cfg"], "rn": ["rb", "abc", "dr", "ne", "rar", "ron", "nr", "rt", " ne", "rx", " linen", " cx", "nc", "nir", "unn", "c", "rr", "ci", "roc", "ren", "eni", " r", "core", " ii", "mn", "r", "nw", "bi", "rd", "ni", "gn", "cb", " fn", "dc", "cin", " rc", "oa", "RN", "dn", "ru"], "cn": ["cre", "ren", "eni", "cin", "core", "mn", "oa", "r", "conn", "cs", "net", "kn", "xi", "ron", "vc", "xc", "bi", "nr", "rt", "cm", "cr", "na", "dn", "mc", "ns", "ni", "rx", "gn", "ru", "ct", "csv", "rin", "ctx", "nc", "nn", "ca", "en", "cdn", "sn", "enc"], "x": ["rex", "xb", "ex", "l", "z", "u", "dx", "xe", "xxx", "xd", "r", "xx", "v", "ux", "_", "bit", "cross", "xf", "xy", "int", "xi", "sex", "xc", "sw", "on", "xxxx", "xes", "d", "fx", "p", "id", "work", "wx", "time", "oint", "ax", "rx", "xt", "point", "ct"], "mtx": ["MTxs", "rtax", "mtz", "MTx", "MTX", "mdy", " mtq", "MTz", "tmx", "gtx", "ttx", "gtxs", "mtX", "tmq", "tmwx", "tmX", "rtwx", "mdx", "rtx", "gtX", "mtxs", " mtX", "mty", " mtwx", "ttz", "mdxs", "mdX", "mtwx", "mtq", "gty", "rtX", "ttX", "rtz", "MTy", "mtax", "ttax", "MTax", "rtq"], "i": ["ai", "l", "ip", "ir", "ji", "z", "ij", "eni", "u", "ti", "ri", "ki", "I", "im", "r", "v", "ih", "ui", "qi", "ori", "ic", "yi", "phi", "it", "ik", "int", "xi", "uri", "ie", "bi", "li", "ei", "d", "id", "p", "nr", "iu", "pi", "ni", "di"], "rmap": ["rmaps", "cmaps", "cshare", "rblock", "mmaps", "mMap", "rapper", " rpose", "rgapper", "rlshare", "dmap", "kpose", "fmaps", "rgmap", "hmap", " rmaps", "kmap", "capper", "fpose", "rapp", "mdata", "rdata", " rdata", "fmap", " rapper", "rshare", "rcap", "dpose", "rlapp", "hpose", "rgwise", "rgpose", "rbpose", "rbwise", "dapp", "rbapper", "dblock", "lmap", "rbmap", "rpose"], "cmap": ["lcblock", "lcmap", "rcopen", "cblock", "rconfig", "csm", "rblock", " cblock", "rcapper", "rapper", " csm", "cpose", "rcpose", "duse", "dMap", "dmap", "rcsm", "capper", "bopen", " cMap", " cuse", "cuse", " cpy", "rcmap", "bpy", "bconfig", "copen", "dpose", "rpy", "ruse", "cconfig", "rcMap", "bmp", "ropen", "lcmp", " cconfig", "rsm", "rpose", "cMap", "cmp"], "td": ["ld", "tc", "chart", "tk", "sh", "table", "ta", "tp", "od", "lf", "dh", "pt", "tmp", "elt", "c", "nd", "TD", "ht", "bb", "zh", "data", "dl", "dat", "edd", "rd", "cz", "notes", "metadata", "cb", "ssl", "sd", "st", "nt", "dc", "thin", "tt", "meta", " dd", "db", "tf"], "j": ["bj", "J", "uj", "l", "cell", "ji", "z", "ij", "br", "jl", "u", "key", "ri", "iv", "col", "r", "v", "js", "ijk", "jp", "it", "ik", "xi", "ie", "ch", "bi", "li", "d", "id", "p", "ion", "ni", "jo", "je", "other", "jj", "o", "oj", "ix", "io"], "k": ["l", "key", "right", "kick", "ko", "kn", "name", "tk", "id", "o", "h", "y", "kind", "kid", "c", "g", "kh", "kin", "kr", "king", "kk", "r", "che", "ack", "sync", "unk", "ek", "spec", "w", "ak", "u", "dk", "gh", "ke", "ku", " sk", "cp", "ik", "uk", "d"], "sb": ["abb", "amp", "rb", "shell", "inf", "sa", "sh", "nb", "nn", " SB", "bg", "bm", "si", "ab", "obj", "bl", "bb", "scl", "usb", "sf", "obb", "dB", "sie", "bf", "bc", "bs", "bp", "lb", "cb", " eb", "sp", "ls", "bt", "ssl", "sd", "src", "sw", "sam", "kb", "db"], "raw": ["small", "strip", "RAW", "text", "new", "game", "example", "feed", "then", "rew", "path", "input", "xml", "static", "cooked", "flat", "full", "source", "stream", "content", "buffer", "running", "form", "Raw", "inner", "orig", "clean", "pure", "block", "json", "str", "row", "remote", "line", "normal", "original", "temp", "empty", "ws", "quick"], "lines": ["l", "inline", "tests", "breaks", "liners", "objects", "charges", "line", "cells", "steps", "posts", "plugins", "lf", "xs", "lins", "mails", "vals", "ends", "strings", "books", "log", "elines", "locks", "codes", "js", "les", "lights", "frames", "blocks", "rules", "users", "bs", "ns", "notes", "ls", "items", "points", "files", "groups", "loads"], "n": ["l", "un", "z", "size", "pn", "count", "nu", "inn", "span", "nw", "conn", "net", "ne", "nor", "p", "na", "ns", "num", "N", "o", "nb", "ol", "e", "nc", "nn", "len", "en", "y", "f", "sn", "c", "ll", "fn", "w", "nl", "ng", "nt", "ny"], "ln": ["l", "ld", "loc", "lt", "wl", "fen", "kn", "NL", "nil", "line", "sql", "fin", "nb", "lf", "nn", "lins", "elt", "L", "ini", "nd", "lon", "log", "bl", "lp", "inn", "dl", "ell", "ill", "ns", "ni", "gn", "lb", "dL", "ls", "vl", "en", "bn", "sd", "nu", "cli"], "outs": ["css", "jobs", "tests", "alls", "breaks", "atches", "charges", "atts", "maps", "cells", "steps", "bles", "offs", "fits", " outputs", "xs", "dates", "lins", "inas", "ends", "strings", "sets", "reports", "locks", "js", "codes", "bos", "frames", "blocks", "bs", "ns", "notes", "abs", "its", "comes", "ops", "ls", "output", "modules", " layouts"], "buff": ["config", "bash", "ff", "text", "uff", "cell", "uf", "abb", "zip", "bl", "ab", "feed", "pp", "bb", "roll", "fam", "shell", "thin", "qq", "slice", "lab", "front", "append", "txt", "butt", "hand", "fb", "bin", "batch", "app", "breaks", "ch", "fl", "buffer", "body", "bm", "box", "ob", "tips", "sh"], "cl": ["rl", "lo", "ld", "le", "cel", "ocl", "pl", "bl", "cli", "cc", "max", "scl", "pull", "null", "lim", "loc", "col", "shell", "pe", "vel", "comb", "left", "kl", "fl", " ll", "ill", "sh", "lock", "spl", "hell", "win", "ct", "la", "ol", "lf", "coll", "acl", "vl", "ul", "Cl"]}}
{"code": " \n  def solve(icase, case_input):\n      case_output = 'Case #%i: '%icase\n      \n      result = 0\n      raw = [int(x) for x in case_input[0].split()]\n      ts = raw[3:]\n      ct = raw[1]\n      n = raw[2]\n      cc = 0\n      for i in ts:\n          if i > 3*n-3:\n              result += 1\n          elif i > max(3*n-5, 0):\n              cc += 1\n      result += min(cc, ct)\n  \n      case_output += '%d'%result\n      \n      return case_output\n  \n  \n  def main():\n      global use_test_data\n      global test_data\n      global input_file\n      global output_file\n      \n      if use_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for icase in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(icase, input)\n          print rslt\n          if not use_test_data:\n              print >> output_file, rslt\n      \n      if not use_test_data:\n          input_file.close()\n          output_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = \"\"\"4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \"\"\"\n      use_test_data = False\n      \n      test_file = 'B-small-attempt0.in'\n      if not use_test_data and '' != test_file:\n          input_file = open(test_file)\n          output_file = open(test_file + '.out', 'w')\n      \n      main()\n", "substitutes": {"icase": ["iccace", "ikases", "ikape", "iacace", "ticased", "ICasing", "ticase", "icace", "iacasing", "wicase", "ICast", "unicases", "iccase", "unicase", "aicase", "wicape", "iacape", "icore", "icerased", "icerases", "iacases", "iscast", "aicased", "iacase", "iccasing", "icases", "ticases", "icasing", "iscasing", " icases", "wicases", "iscases", "unicasing", "icast", "aicases", "aicore", "icerase", "ikace", "icerore", "ticore"], "case_input": ["case_data", "Case_output", " case_file", "Case_source", "case_source", " case_data", "Case_data", "Case_input", "case_file"], "case_output": [" case_Output", " case_write", "case2output", " case_file", "case2Output", "case2write", "case_Output", "case_file", "case_final", " case_final", "case_unit", " case_unit", "case_write"], "result": ["character", "function", "runner", "cont", "grade", "inc", "conf", "coll", "counter", "instance", "feature", "case", "out", "df", " r", "r", "true", "array", "compl", "dict", "ret", "sequence", "output", "account", "code", "number", "cash", "ULT", "date", "score", "card", "cell", "dc", "unit", "error", "ult", "found", "uc", "call", "total"], "raw": ["RAW", "exp", "shape", "new", "null", "feed", "complete", "rew", "right", "now", "xml", "uc", "node", "flat", "full", "fast", "stream", " Raw", "array", "all", "batch", "parse", "sync", "events", "aw", "ww", "words", "rss", "form", "oct", "Raw", "event", "track", "clean", "details", "response", "json", "row", "draw", "cont"], "x": ["ex", "l", "t", "xx", "int", "sex", "name", "id", "file", "rx", "cl", "line", "tx", "xs", "h", "y", "string", "c", "ctx", "g", "px", "ci", "image", "case", "r", "python", "array", "xy", "xi", "xxxx", "m", "ix", "output", "code", "X", "w", "xp", "index", "text", "example"], "ts": ["ths", "tc", "TS", "features", "lines", "t", "states", "ms", "s", "tt", "cs", "tests", "stats", "ats", "acc", "tf", "Ts", "events", "tes", "td", " times", " tests", "ctr", "outs", "ns", " cases", "ta", "ches", "times", "steps", "cells", "cases", "tx", "types", "rows", "ops", "test", "ps", "ws", "temp"], "ct": ["config", "tc", "dc", "case", "t", "ce", "ss", "col", "count", "cd", "uc", "ic", "conn", "cs", "fc", "acc", "xc", "ds", "cm", "cr", "std", "ctr", "cat", "ns", "Ct", "cy", "cl", "cont", "th", "pc", "CC", "temp", "nc", "cn", "pt", "sc", "ck", "code", "q", "rc"], "n": ["l", "adj", "j", "min", "z", "t", "u", "pn", "max", "r", "b", "count", "v", "s", "nu", "ne", "k", "nr", "d", "p", "m", "ns", "ni", "num", "pi", "N", "o", "nb", "e", "nc", "no", "cn", "nm", "y", "a", "f", "nit", "q", "c", "g"], "cc": ["co", "tc", "dc", "kk", "case", "ce", "cca", "cas", "cu", "count", "cd", "uc", " CC", "cs", "conn", "fc", "acc", "vc", "ec", "k", "cm", "bc", "sect", "mc", "cv", "cl", "ac", "pc", "inc", "CC", "cb", "ced", "cci", "nc", "ca", "cn", "sc", "ck", "code", "q"], "i": ["ai", "l", "ip", "j", "iac", "z", "chi", "t", "ti", "u", "I", "b", "s", "v", "inf", "count", "r", "span", "ic", "it", "int", "xi", "ie", "k", "li", "ei", "d", "id", "p", "ace", "iu", " ti", "pi", "ni", "ta", "di", "num", " c", "o", "io"], "data": ["step", "config", "image", "reader", "text", "lines", "zip", "database", "case", "api", "feed", "complete", "value", "xml", "Data", "DATA", "slice", "source", "array", "next", "tests", "dat", "function", "content", "ata", "blocks", "pos", "d", "p", "dict", "file", "na", "list", "pad", "response", "line", "info", "media", "la", "rows"], "T": ["P", "Q", "J", "DT", "TS", "Z", "D", "TH", "t", "H", "I", "TR", "M", "A", "NT", "TE", "Test", "TC", "TW", "WT", "Time", "TA", "G", "U", "N", "TN", "length", "Tu", "W", "O", "Total", "Tab", "E", "C", "S", "V", "L", "X", "TB", "TT"], "iLine": ["siBlock", "iiDay", "iiCo", "siCo", "siLine", "liL", "siDay", " iPage", "iL", "IL", "uBlock", "iRange", "uPage", "IBlock", " iL", "iDay", "iiLine", " iDay", "siL", "liBlock", "liLine", "liRange", " iCo", "uLine", "iPage", " iBlock", "iiL", "ILine", " iRange", "IPage", "iBlock", "iCo", "siRange", "uL"], "caseLineNum": ["caseLineLen", "caseEntryNum", "caseRowLen", "choiceLineLen", "caseLineNo", " caselineSum", "caseEntrySum", "choiceNameNo", "caselineNumber", " caselineNumber", "caseNameLen", "caseBlockSum", "caseRowNum", "caseLineNumber", " caselineNUM", "caseBlockNo", "choiceLineNo", "choiceLineNUM", "caselineNum", "caselineNUM", "caseBlockNUM", "caseBlockNum", "caseLineNUM", "caseBlockNumber", "caseEntryNUM", "choiceNameLen", "choiceNameNum", "choiceLineNum", "caseEntryNumber", "caseNameNUM", " caseLineSum", "caselineSum", "caseNameNum", "caseRowNo", "caseNameNo", " caselineNum", " caseLineNumber", " caseLineNUM", "caseBlockLen", "choiceNameNUM"], "input": ["step", "config", "image", "shape", "text", "view", "reader", "new", "submit", "ip", "null", "unit", "feed", "pull", "xml", "uc", "command", "source", "array", "interface", "qa", "expression", "int", "type", "element", "batch", "init", "memory", "document", "current", "buffer", "um", "entry", "file", "form", "event", "list", "table", "session", "field"], "rslt": ["Rsl", "rslet", "rotslett", "rslett", "Rslett", "srgt", "rotslt", "RSlt", "RSlet", "rstail", " rslet", " rstail", "Rslt", "srtail", "RSelt", "Rslet", " rsgt", "rotstail", " rsLT", "rsl", "rselt", "rotsgt", "srlett", "RSLT", " rselt", "RSl", "Rselt", "RSlett", "srlt", " rsl", "rsgt", "rsLT", "RsLT", " rslett"], "test_data": ["test2data", "outputingfile", "case_data", " test_string", "testacdata", "testingwindow", "test_body", "testcasewindow", "output_database", "test2template", "outputingdatabase", "testingdata", "output_window", "outputingwindow", "test_filename", "testacstring", "test_string", "testcasedatabase", "output_data", "testcasefile", "testingfile", " test_template", "outputingdata", "case_body", "test2string", "testactemplate", "case_file", "case_filename", "test_template", "test_window", "testcasedata", "testingdatabase", "test_database"], "use_test_data": ["use_case_Data", "use_case_function", "use_testerData", "use_test2dat", "use_testing_Data", "use_testingData", "use_testing_break", "use_testing_dat", "use_testingresults", "use_test_function", "use_test_Data", "use_testing_class", "use_testing_data", "use_test2file", "use_Test_dat", "use_case_data", "use_test_case", "use_test_class", "use_testing_results", "use_testerdata", "use_Test_case", "use_test2data", "use_test_break", "use_testing_file", "use_testabledata", "use_testingdata", "use_case_format", "use_test_file", "use_test_results", "use_test_format", "use_Test_data", "use_testingbreak", "use_testablecase", "use_test_dat", "use_testabledat", "use_testerclass"], "test_file": ["testingline", " testingfile", " testingdata", "test_type", " testpfolder", "testmemfiles", " test_folder", "testpdir", " test_FILE", "testablefolder", "test_download", "testing_line", "test_files", "test_line", "testingfolder", "testpdata", "testing_file", "testabledata", " test_dir", "testingdata", " testingfiles", "test_folder", " testingline", "testabledir", "testPooltype", "testingfiles", " test_files", "test_dir", " test_download", "testablefiles", "test_function", " testpfile", "testingingfunction", "testingtype", "testabledownload", "testxline", "testpfile", "testxfile", "test_FILE", "testingingtype"], "input_file": ["output_source", "input_table", "input2buffer", "inputPoolfile", "output_data", "input_files", "input2line", " input_data", "input2file", "output_files", " input_log", "input_data", "input_source", "output_table", "inputPoolfiles", "input2source", "output_line", "output_output", "input_buffer", "input_output", " input_files", "input_log", "output_buffer", "input_line", "inputPooloutput"], "output_file": ["case_files", "outputingfile", "outputinglog", "case_data", " output_log", " output_channel", "output_line", "output_channel", "output_directory", "output_log", "output_data", "input_directory", "outputJfil", "outputJlog", "output_fil", " output_data", "output_files", "input_files", "case_file", "input_data", "outputingfil", "outputJfile", "outputJchannel", "outputingchannel", " output_files", "case_log", " output_fil", " output_line"]}}
{"code": " \n  T = input()\n  \n  for n in range(1, T+1):\n  \n      A, B = raw_input().split()\n      A, B = int(A), int(B)\n  \n      j = 0\n      for i in range(A, B+1):\n          s = str(i)\n          m = int(i**.5)\n          if s[-1] in [\"1\", \"4\", \"5\", \"6\", \"9\"] and \\\n                  (s == \"\".join(reversed(s))) and \\\n                  m**2 == i:\n              s = str(m)\n              if s == \"\".join(reversed(s)):\n                  j += 1\n  \n  \n      print \"Case #%d: %d\" % (n, j)\n", "substitutes": {"T": ["P", "J", "Q", "TS", "Z", "D", "Ti", "t", "H", "I", "M", "NT", "Test", " M", "TW", "TF", "WT", "Time", "TA", "G", " N", " t", "N", "TN", "TI", "Tu", "W", "O", "Tab", "E", "C", "Length", "S", "V", "L", "X", "TB", "TT", "Y", "K"], "n": ["l", "adj", "z", "t", "u", "pn", "r", "b", "v", "count", "span", "net", "init", "ne", "ln", "k", "li", "d", "p", "na", "dn", "ns", " N", "x", "ni", "num", "N", "o", "nb", "e", "nt", "nc", "nn", "cn", "nm", "len", "en", "a", "sn", "f"], "A": ["Q", "Ac", "API", "D", "Ma", "Act", "au", "Data", "Len", "SA", "And", "One", "Wa", "L", "Y", "Input", "Num", "Ay", "Na", "Az", "H", "AB", "M", "NA", "Am", "KA", "This", "Ant", "U", "Bar", "W", "Ar", "O", "CA", "an", "E", "Auth", "a", "V", "X"], "B": ["P", "J", "Q", "WB", "QB", "DB", "Z", " b", "D", "GB", "BT", "IB", "UB", "H", "I", "Other", "b", "BF", "AB", "M", "LB", "Base", "NB", "BL", "Bs", "G", "U", "N", "BB", "BR", "BC", "CB", "BE", "End", "BS", "W", "O", "Be", "BA", "E"], "j": ["P", "J", "l", "uj", "adj", "ji", "z", "ij", "size", "jl", "t", "u", "key", "r", "b", "I", "v", "job", "count", "js", "jp", "jam", "k", "part", "li", "d", "id", "p", "x", "pi", "num", "jo", "N", "dj", "jj", "o", "jon", "oj", "offset", "e"], "i": ["ai", "l", "ip", "min", "z", "chi", "alpha", "ib", "ti", "u", " I", "t", "I", "im", "b", "v", "r", "inf", "me", "M", "phi", "ik", "int", "xi", "ie", "bi", "k", "li", "pos", "id", "p", "d", "iu", "x", "pi", "ni", "mi", "di", "mu", "o"], "s": ["l", "t", "b", "sa", "tests", "multi", "id", "sh", "o", "ans", "xs", "h", "y", "string", "c", "params", "g", "sb", "strings", "si", "sets", "ims", "im", "r", "ses", "sf", "js", "sie", "se", "sync", "words", "ns", "x", "os", "ls", "an", "a", "lower", "w", "gs"], "m": ["l", "sm", "mm", "min", "z", "t", "u", "mode", "mr", "mn", "ms", "r", "b", "v", "md", "im", "I", "M", "em", "pm", "me", "k", "tm", "li", "d", "p", "mass", "mc", "x", "pi", "mi", "mu", "o", "module", "e", "machine", "hm", "h", "y", "a"]}}
{"code": " \n  T=0 #no. of Test cases\n  for line in fileinput.input():\n      if fileinput.isfirstline():\n          T=int(line)\n          print \"no. of test cases:\", T\n          continue\n      \n      nums=[int(x) for x in line.split()]\n      N=nums[0] #no. of googlers\n      S=nums[1] #no. of surprising triplets\n      p=nums[2] #max value\n      \n      del nums[:3]\n      count=0\n      for num in nums:\n          quo=num//3\n          rem=num%3\n          if quo >= p:\n              count += 1\n              continue\n          elif quo+1 == p and rem > 0:\n              count += 1\n              continue\n          elif quo+1 ==p and rem == 0 and quo > 0 and S > 0:\n              count += 1\n              S -= 1\n              continue\n          elif quo+2 >= p and rem == 2 and S > 0:\n              count += 1\n              S -= 1\n      \n      print \"Case #%(k)i: %(count)i\" % {\"k\":fileinput.lineno()-1,\"count\":count}\n", "substitutes": {"T": ["LINE", "P", "Q", "DT", "TS", "Z", "D", "t", "H", "I", "n", "TX", "TR", "M", "A", "NT", "TE", "Test", "int", "TC", "TF", "WT", "Time", "TA", "G", " t", "U", "TN", "W", "O", "E", "Line", "C", "Length", "V", "L", "X", "TB", "TT", "K"], "line": ["LINE", "log", "section", "l", "text", "cell", "lines", "page", "byte", "size", "inline", "case", "unit", "example", "error", "comment", "run", "mode", "col", "ino", "de", "header", "object", "trial", "source", "int", "type", "frame", "name", "do", "tail", "li", "limit", "id", "phase", "buffer", "site", "file", "time", "position"], "nums": ["rnumbers", "rnults", " nrams", "cumbers", "crams", "Nums", "cum", "Numbers", "enoms", " numbers", " nubs", "enumbers", "Nrams", "enum", "enrams", " noms", "nrams", " nults", "noms", "nults", "numbers", "enubs", "enums", "Nubs", "rnoms", "Noms", "rnums", "nubs", "cults", "cums", "Nults", "Num"], "x": ["ex", "l", "section", "text", "z", "case", "t", "u", "i", "out", " X", "run", " seq", "xxx", "n", "xx", "v", "data", "int", "xi", "sex", "name", "xc", "pos", "m", "file", "na", "xt", "match", "row", " text", "str", "mat", " c", "e", "xs", "word", "h", "no", "y"], "N": ["P", "Q", "J", "Z", "D", "H", "n", "I", "M", "A", "NT", "NN", "k", "ns", "G", "NL", "U", " n", "Ni", "Ns", "W", "O", "Num", "E", "C", "V", "L", "X", "Y", "K", "B", "CN", "F", "NS", "R"], "S": ["P", "Q", "Case", "Z", "D", "Size", "u", "Ps", "ss", "SEC", "H", "I", "n", "s", "M", "SU", "A", "FS", "SN", "XX", "SR", "Serial", "Sp", "MS", "SH", "ns", "G", " s", "U", "Sa", "SE", "CS", "Ns", "W", "ps", "sp", "O", "US", "INS", "Num"], "p": ["P", "l", "ip", "j", "pm", "z", "pp", "per", "br", "t", "u", "i", "pn", "n", "lp", "r", "b", "v", "cp", "s", "pr", "M", "pe", "op", "post", "jp", "np", "k", "ch", "pa", "dp", "d", "m", "power", "pi", "tp", "point", "o", "rep", "up"], "count": ["cond", "key", "i", "process", "carry", "name", "id", "allow", "list", "read", "ct", "conf", "coll", "h", "start", "c", "Count", "repeat", "add", "size", "case", "group", "order", "limit", "time", "race", "base", "cache", "sum", "code", "number", "index", "nt", "last", "error", "col", "only", "found", "call", "total"], "num": ["opt", "text", "un", "null", "unit", "case", "max", "u", "comment", "t", "col", "n", "zero", "b", "nu", "dim", "common", "node", "comb", "NUM", "param", "mom", "np", "bin", "init", "part", "multi", "om", "um", "nom", "m", "bc", "na", "match", "andom", "mat", "o", "inc", "nb", "result"], "quo": ["quoo", "QuO", "qot", "squo", "qoa", "Quoo", " qui", "sqo", "aquoo", "aquos", "quO", "qoo", "aquot", "qos", "clot", " quoo", "cloa", "aquO", "quos", "sqos", "squi", "equoo", "cloo", "Quo", "aquoa", "sqoo", "qo", "equo", "Quos", " quos", "aquo", "aqui", "quoa", "equot", "clos", "sqot", "equos", " quO", "squos", "clo"], "rem": ["ex", "progress", "ref", "rest", "right", "REM", "em", "dem", "red", "rar", "re", "nom", "prev", "cl", "rip", "when", "remove", "nd", "reg", "min", "roll", "mn", "im", "r", "pm", "rol", "rage", "order", "ern", "rac", "m", "ret", "err", "prom", "rim", "sp", "nz", "reb", "pri", "com"]}}
{"code": " \n  fin = open('C-small-attempt0.in', 'r')\n  fout = open('ass3.out', 'w')\n  \n  T = int(fin.readline())\n  \n  def perfsq(n):\n      sq = int(math.sqrt(n))\n      if n == sq * sq:\n          return sq\n      return 0\n  \n  def palindrome(n):\n      s = str(n)\n      return (s == s[::-1])\n  \n  def getpal(n):\n      if n == 1:\n          for i in range(10):\n              yield i\n      else:\n          n2 = n / 2\n          for x in xrange(10 ** (n2 - 1), 10 ** n2):\n              s = str(x)\n              if n % 2:\n                  for i in range(10):\n                      ns = s + str(i) + s[::-1]\n                      yield int(ns)\n              else:\n                  ns = s + s[::-1]\n                  yield int(ns)\n  \n  for i in range(T):\n      A, B = map(int, fin.readline().split())\n  \n      ret = 0\n      for j in range(len(str(A)), len(str(B)) + 1):\n          for x in getpal(j):\n              if x < A:\n                  continue\n              if x > B:\n                  break\n              sq = perfsq(x)\n              if sq and palindrome(sq):\n                  ret += 1\n      fout.write('Case #%i: %i\n' % (i + 1, ret))\n", "substitutes": {"fin": ["lo", "fun", "cook", "fer", "final", "loader", "cin", "iter", "han", "prem", "trans", "fit", "fi", "inn", "pin", "fd", "su", "thin", "pen", "lib", "jin", "conn", "fen", "bin", "init", "fb", "ln", "zen", "do", "fat", "pos", "close", "serv", "die", "fr", "din", "syn", "util", "win", "send"], "fout": ["FOut", "Finner", "fmwrite", "faout", " fint", "fwOut", "fwinner", "fawrite", "fOut", "faint", "fwin", "fmOut", " finner", "Fout", " fwrite", "finner", "Fin", "fint", "fwrite", "fmint", "faOut", "fwout", "fmout", " fOut"], "T": ["P", "J", "Q", "TS", "Z", "D", "t", "out", "H", "I", "M", "Len", "NT", "Test", "type", "Ts", "TW", "p", "WT", "Time", "G", " N", "N", "TN", "W", "O", "E", "C", "Length", "S", "V", "L", "X", "number", "TT", "Y", "K", "CT", "F", "IT"], "n": ["l", "t", "b", "ot", "ne", "int", "ln", "name", "o", "nb", "Ns", "nc", "nn", "y", "c", "g", "size", "r", "np", "m", "ni", "gn", "an", "no", "cn", "nm", "en", "a", "number", "network", "w", "nu", "nan", "nt", "pn", "u", "k", "d", "dn", "yn"], "sq": ["Q", "seq", "inf", "qi", "qq", "shift", "scale", "rt", "ace", "sh", "rx", "tp", "ct", "sql", "iq", "nn", "Sn", "supp", "tmp", " np", "foo", " squared", " square", "sb", "quant", "si", "qu", "shape", "Na", "size", "scl", "sf", " squares", "array", "se", "np", " ss", "xi", " SQ", "ql"], "s": ["l", "t", "b", "stats", "sh", "o", "sql", "ans", "Ns", "xs", "h", "y", "string", "c", "g", "sb", "strings", "si", "sets", "ims", "r", "ses", "se", "ies", "sync", "m", "bs", "ens", "signed", "os", "spec", "sp", "ls", "ssl", "a", "w", "ips", "gs", "es", "ins"], "i": ["l", "ti", "t", "b", "inf", "qi", "phi", "uri", "int", "init", "multi", "ei", "id", "o", "io", "jit", "counter", "y", "start", "c", "g", "ini", "ci", "si", "ij", "ri", "r", "xi", "bi", "m", "ni", "ix", "mini", "a", "gi", "index", "iv", "u", "I", "ui"], "n2": ["n82", "c4", "N2", "gTwo", "nb3", "Ntwo", "nb2", " n02", "n02", "N82", "NTwo", "d02", " n4", "n3", "n4", "N3", "ntwo", "g2", " nTwo", "nTwo", "d2", "d4", "gtwo", "c02", " n82", "nb82", " n3", " ntwo", "c2"], "x": ["ex", "l", "pl", "rax", "t", "b", "xx", "int", "sex", "id", "re", " xp", "rx", "cl", "o", "ct", "tx", " cx", "xs", "nc", "h", "y", "c", "ctx", "px", "r", "cross", "xy", "xi", "xxxx", "ww", "m", "ix", "Tx", "an", "act", "a", "code", "X", "network"], "ns": ["es", "lines", "z", "ins", "nos", "states", "eps", "ss", "ms", "ks", "ses", "strings", "nu", "nw", "cs", "ids", "tests", "np", "net", "ne", "ats", "int", "aps", "ips", "nis", "nets", "ains", "ds", "p", "works", "na", "bs", "als", "ens", "outs", "ios", "notes", "ni", "N", "nin"], "A": ["AR", "P", "Q", "Ac", "Case", "Ca", "Na", "As", "JA", "D", "alpha", "AA", "Ma", "LA", "AU", "H", "I", "AB", "Ax", "au", "M", "NA", "GA", "Ab", "AP", "Am", "HA", "SA", "IA", "The", "PA", "TA", "G", "U", "N", "AD", "And", "At", "Ar", "O"], "B": ["P", "Q", "J", "WB", "QB", "Z", " b", "D", "FB", "BT", "UB", "H", "I", "AB", "b", "BF", "BO", "RB", "M", "LB", "BM", "VB", "SB", "PB", "AP", "NB", "BL", "Bs", "G", "U", "N", "BER", "BB", "BC", "BE", "BS", "W", "EB", "O", "BA"], "ret": ["best", "Ret", "reg", "det", "fun", "mt", "sec", "py", "t", "ref", "iter", "final", "fit", "count", "lt", "trial", "txt", "it", "int", "lit", "default", "rot", "back", "part", "rt", "id", "re", "resp", "round", "success", "val", "num", "res", "xt", "match", "rev", "rets", "rep", "flag", "alt"], "j": ["bj", "J", "ai", "l", "ip", "adj", "ji", "ij", "obj", "z", "br", "jl", "key", " d", "ib", "py", "uj", "section", "b", "xx", "v", "js", "job", "num", "jp", "it", "xy", "xi", "ie", "k", "li", "d", "id", "m", "jo", "je", "xt", "dj", "jj", "o"]}}
{"code": "input_file = 'B-small-attempt1.in'\n  output_file = 'b.out'\n  \n  \n  def solvecase(inp):\n  \tdata = [int(n) for n in inp.split()]\n  \tN, S, p = data[0:3]\n  \tif p == 0:\n  \t\treturn N\n  \tt = data[3:]\n  \tret = 0\n  \tfor br in t:\n  \t\td, r = br / 3, br % 3\n  \t\tif br == 0 or p - d > 2:\n  \t\t\tcontinue\n  \t\tif (d >= p) or (r and (d + 1) >= p):\n  \t\t\tret += 1\n  \t\telif S and (d + max(r, 1)) >= p:\n  \t\t\tret += 1\n  \t\t\tS -= 1\n  \treturn ret\n  \n  lines = open(input_file, 'r').readlines()\n  out = open(output_file, 'w')\n  \n  for i, l in enumerate(lines[1:]):\n  \tsout = 'Case #%i: %i' % (i + 1, solvecase(l))\n  \tprint sout\n  \tout.write(sout + '\n')\n  \n  out.close()\n", "substitutes": {"input_file": ["inputsfile", "inputsresource", "input_resource", "inputingfiles", "inputodefile", "data_files", "input_module", "inputoderesource", "dataodename", "inputodefiles", "inputmingfile", "inputodename", "output_base", "inputingfile", "inputingbase", "dataoderesource", "inputmingmodule", "inputmingfiles", "dataodefile", "input_name", "data_file", "data_name", "dataodefiles", "inputmingbase", "data_resource", "input_base", "output_files", "input_files", "output_module", "inputsname", "inputsfiles", "inputingmodule"], "output_file": ["outputingbase", "outputChanemail", "outputChanfolder", "outputingfile", "outputingfolder", "outputChanfilename", "input_filename", "outputingfilename", " output_filename", "inputingname", "output_filename", "output_base", "inputingfile", "output_name", "inputingbase", "outputChanfile", "outputingname", " output_email", "input_name", "output_email", "inputingfilename", "input_base", "outputingemail", " output_folder", "output_folder"], "inp": ["inping", " infp", "innfile", " INfile", "Infile", "Inp", " INpart", "outping", "innP", " inping", "outfile", " inP", " INp", "outp", "innping", "inP", "Infp", "innp", "inpart", "infile", "infp", " inpart", "Inpart", " infile", "outP", " INfp"], "data": ["config", "text", "alpha", "case", "valid", "after", "input", "s", "v", "Data", "call", "DATA", "post", "array", "next", "raw", "int", "dat", "frame", "batch", "default", "content", "arr", "breaks", "ata", "area", "pos", "file", "na", "list", "x", "block", "response", "rec", "line", "o", "info", "rows", "result", "e"], "n": ["j", "z", "u", "b", "s", "nu", "nw", "all", "np", "net", "int", "ne", "name", "k", "pos", "m", "na", "ns", "x", "num", "ni", "o", " c", "nb", "e", "nc", "nn", "cn", "no", "nm", "y", "a", "f", "sn", "c", "number", "g", "fn", "w", "ind"], "N": ["P", "Q", "J", "Col", "Z", "D", "Id", " R", " Ne", "Ch", "H", "I", "RN", "v", "Data", "M", "A", "Len", "Pro", "Max", " D", "pos", "NR", "ns", "G", "num", "W", "Ar", "O", "E", "C", "f", "V", "L", "X", "Y", "K", "T", "B", "Sub"], "S": ["rl", "P", "Q", "J", "z", "Z", "D", " R", "Sc", "right", "ss", "H", "I", "b", "s", "v", "Rs", "range", "Su", "M", "SU", "A", "left", "se", "sv", "SR", "Si", "Sp", "ro", "NR", "SH", "ns", "G", "x", " s", "U", "res", "str", " sr", "sr"], "p": ["P", "j", "z", "pp", "case", "u", "ref", "pn", "api", "b", "s", "v", "pr", "pe", "span", "lp", "jp", "np", "dp", "pos", "m", "wp", "x", "pi", "tp", "bp", "o", "up", "pc", "ap", "e", "ps", " P", "sp", "pre", "h", "y", "start", "pt", "f"], "t": ["j", "z", "art", "u", "ti", "set", "b", "s", "v", "ot", "array", "int", "type", "ment", "name", "m", "x", "ta", "tp", "xt", "o", "e", "h", "y", " T", "to", "a", "f", "pt", "q", "tr", "ation", "c", "T", "g", "at", "w", "ut", "st", "ts"], "ret": ["fun", "ref", "fit", "b", "all", "red", "int", "rt", "id", "re", "fr", "val", "bis", "pub", "alt", "fin", "Return", "pt", "ut", "Num", "Ret", "reg", "j", "iter", "resp", "err", "sp", "en", "__", "ft", "R", "nt", "last", "trial", " Ret", "part", "arr", "cat", "num", "res"], "br": ["step", "P", " Br", "j", "min", "z", "bl", "ref", "max", "shr", "hr", "ur", "rb", "ov", "b", "Br", "pr", "v", "range", "span", "dr", "gr", "next", "int", "arr", "ch", "nr", "cr", "m", "wr", "lr", "fr", "frac", "adr", "err", "prev", "pi", "bp", "str", "gap"], "d": ["P", "ld", "j", "dc", "z", "min", "D", "u", "b", "s", "v", "fd", "dl", "db", "dat", "dp", "ds", "rd", " D", "id", "m", "dn", "x", "o", "da", "e", "dh", "ad", "h", "du", "y", "f", "a", "dy", "q", "c", "split", "dt", "g", "w"], "r": ["rl", "P", "ir", "j", "min", "z", "rf", " R", "rb", "u", "right", "b", "s", "v", "pr", "range", "dr", "rg", "k", "nr", "rt", "rd", "ro", "m", "re", "ra", "lr", "fr", "er", "x", "ru", "rev", "o", "sr", "row", "e", "h", "a", "f", "radius"], "lines": ["LINE", "log", "lo", "elines", " Lines", "ines", "inline", "args", "ins", "iter", "lp", "locks", "s", "les", "txt", "ids", "ln", "breaks", " codes", "blocks", "pos", "los", "objects", "lined", "line", "cells", " results", "comments", "cases", "runs", "lin", "rows", " breaks", "lf", " rows", "ze", "ls", " line", "items", "lins"], "out": ["log", "image", "engine", "exp", " output", "Out", "new", "page", "size", "cli", "external", "final", "error", "window", "pool", "obj", "server", "url", "connection", "print", "call", "header", "group", "source", "net", "dot", "default", "name", "sync", "part", "parent", "again", "file", "outs", "inner", "list", "err", "lock", "block", "prefix"], "i": ["ai", "ip", "j", "z", "chi", "u", "ti", "ri", "I", "v", "ui", "qi", "phi", "int", "xi", "bi", "k", "li", "part", "id", "pos", "m", "iu", "x", "pi", "ni", "mi", "di", "line", "o", "mini", "end", "e", "h", "zi", "y", "a", "axis", "c", "ii"], "l": ["rl", "le", "j", "z", "pl", "sol", "u", "loc", "lp", "s", "v", "b", "wl", "dl", "kl", "ler", "ln", "k", "li", "m", "lis", "line", "o", "la", "lin", "e", "il", "ls", "lu", "len", "L", "el", "c", "lc", "ll", "w", "nl", "sl", "yl"], "sout": ["sgOut", " supdate", "sprintf", "soutput", "sgouts", " sqa", " sOut", "lsqa", "esout", "Souts", "psint", "psupdate", "sgprintf", "lsoutput", "souts", " sint", "SOut", "lsin", " souts", "esoutput", "toutput", "supdate", "Sprintf", "tout", "lsout", " sprintf", "Sout", "sin", "lsint", "lsupdate", "sint", "psqa", "esin", "tin", "sqa", "sOut", "psout", "sgout"]}}
{"code": " a = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]\n  A = a[:10]\n  def subdfs(pre, mid, d, t, n):\n      if d == t:\n          k = long(''.join([pre, mid, pre[::-1]]))\n          k = k * k\n          if k > n:\n              return [1, 0]\n          sqk = str(k)\n          if sqk == sqk[::-1]:\n              A.append(k)\n              return [0, 1]\n          else:\n              return [0, 0]\n      res = subdfs(pre + '0', mid, d + 1, t, n)\n      if res[0]: return res\n      if not res[1]: return res\n      res2 = subdfs(pre + '1', mid, d + 1, t, n)\n      if res2[0]: return [1, res[1] + res2[1]]\n      return [0, res[1] + res2[1]]\n  \n  def dfs(d, n):\n      subdfs('1', '', 0, d, n)\n      subdfs('2' + '0' * d, '', d, d, n)\n      subdfs('1', '0', 0, d, n)\n      subdfs('1', '1', 0, d, n)\n      subdfs('1', '2', 0, d, n)\n      subdfs('2' + '0' * d, '0', d, d, n)\n      subdfs('2' + '0' * d, '1', d, d, n)\n  \n  def solve(pre):\n      read_ints = lambda: map(int, raw_input().split())\n      l, r = read_ints()\n      cl = bisect_left(A, l)\n      cr = bisect_right(A, r)\n      cl_ = cr_ = 0\n      for i in xrange(40):\n          if a[i] < l: cl_ += 1\n      for i in xrange(40):\n          if a[i] <= r: cr_ += 1\n      print pre, cr - cl\n  \n  for k in xrange(1, 48):\n      dfs(k, 10 ** 100 + 1)\n  A.sort()\n  N = int(raw_input())\n  for i in xrange(1, N + 1):\n      solve(\"Case #%d:\" % i)\n", "substitutes": {"a": ["aa", "ai", "j", "ab", "z", "alpha", "art", "am", "input", "b", "s", "au", "data", "access", "sa", "array", "parts", "app", "aaaa", "ga", "parser", "ae", "p", "ata", "m", "list", "o", "audio", "ac", "result", "e", "ca", "an", "ad", "y", "account", "ar", "f", "c", "params"], "A": ["P", "aa", "ai", "Q", "API", "As", "Z", "D", "alpha", "AA", "args", "am", "H", "I", "Data", "M", "AM", "array", "AP", "Alpha", "KA", "ae", "p", "This", "m", "Array", "G", "U", "AD", "ac", "W", "Ar", "O", "ca", "CA", "ad", "AF", "E", "C", "S"], "pre": ["j", "min", "per", "pl", "py", "key", "ref", "after", "final", "primary", "prem", "process", "pro", "pres", "pm", "pr", "pe", "pin", "pan", "model", "post", "rup", "dat", "master", "name", "part", "on", "before", "pos", "p", "par", "pid", "m", "re", "PRE", "po", "prev", "prom", "pi", "tp"], "mid": ["mm", "middle", "dc", "min", "key", "max", "desc", "rand", "mad", "mr", "ms", "med", "md", "req", "dim", "meta", "dem", "post", "dr", "main", "order", "int", "master", "part", "tm", "multi", "id", "mer", "pos", "m", "pid", "p", "cm", "time", "x", "num", "pad", "mi", "mod", "remote"], "d": ["ld", "D", "xd", "b", "de", "dim", "dr", "name", "td", " D", "id", "o", "dom", "dh", "h", "y", "start", "c", "g", "nd", "j", "min", "data", "dl", "dat", "do", "dp", "dict", "m", "x", "da", "en", "w", "st", "sd", "end", "dc", "u", "dx", "s"], "t": ["tc", "j", "mt", "z", "u", "b", "s", "v", "ot", "tu", "tt", "it", "total", "int", "net", "type", "tm", "p", "m", "time", "table", "ta", "x", "tz", "tp", "num", "o", "ty", "ct", "tw", "tn", "e", "h", "y", "en", "pt", "f", "c", "tim", "T"], "n": ["b", "ot", "ne", "ln", "name", "nor", "don", "nin", "o", "nb", "nc", "nn", "y", "unn", "c", "T", "g", "j", "out", "inn", "np", "m", "ns", "x", "ni", "an", "no", "cn", "nm", "en", "network", "w", "nu", "nt", "nan", "pn", "u", "s", "common", "dn"], "k": ["ak", "j", "kk", "pp", "key", "u", "ki", "dk", "ke", "ks", "s", "v", "ku", "b", "cp", "ijk", "kb", "ko", "uk", "ik", "kn", "tk", "ch", "unk", "id", "p", "ok", "m", "kg", "ek", "ky", "work", "through", "mk", "x", "num", "o", "rek", "kick", "kat"], "sqk": ["isfq", "qks", "iqk", "qkk", "dqK", "dqks", "iqK", "isfk", "isfK", "qqks", "sqK", " sqK", "qqK", "qqkk", "sqks", "sqq", "dqk", " sqq", "dqq", " sqks", "sqkk", "qqk", "qk", "isfks", "iqks", " sqkk"], "res": ["rest", "right", "pres", "all", "re", "ores", "maps", "val", "cells", "rus", "ans", "params", "vals", "ours", "reg", "values", "obj", "out", "ras", "nos", "mr", "js", "data", "true", "relations", "ids", "gen", "blocks", "qs", "par", "resp", "ret", "bs", "err", "ns", "x", "details", "er", "ries", "acts"], "res2": ["rem5", "ares62", "ares2", "rys4", "results72", "rs4", "pr2", "results5", "res4", "res62", "rus1", "resultstwo", "result2", "rys62", "rys2", "results1", "resTwo", "aresTwo", "prestwo", "rysTwo", "ros2", "rusTwo", "res1", "rs2", "rs62", "rsTwo", "results2", "restwo", "pres2", "rem1", "ares4", " res1", "rem2", "pr1", "result62", "rosTwo", "ros1", "res5", "pr62", "remtwo"]}}
{"code": "T = int(raw_input())\n  for t in xrange(T):\n      line = map(int, raw_input().split())\n      N, S, p = line[0:3]\n      a = line[3:]\n      cnt = 0\n      a.sort(reverse=True)\n      for x in a:\n          if (x + 2) / 3 >= p:\n              cnt += 1\n          elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:\n              cnt += 1\n              S -= 1\n          else:\n              break\n      print \"Case #%d: %d\" % (t + 1, cnt)\n", "substitutes": {"T": ["P", "Q", "TS", "z", "Z", "D", "H", "I", "n", "M", "A", "NT", "TC", "TW", "Time", "time", "TA", "G", "TN", "TI", "length", "W", "O", "E", "C", "Length", "V", "L", "X", "number", "TT", "Y", "K", "B", "CT", "F", "TB", "R"], "t": ["l", "section", "text", "j", "z", "u", "i", "ti", "col", "n", "b", "s", "v", "tt", "total", "int", "type", "part", "tail", "d", "id", "m", "template", "time", "num", "tz", "xt", "ty", "o", "ct", " n", "e", "temp", "h", "y", "tick", "f", "pt", "code", "X"], "line": ["LINE", "log", "l", "section", "strip", "text", "cell", "le", "lines", "page", "link", "inline", "case", "out", "comment", "n", "range", "v", "data", "slice", "source", "group", " Line", "se", "int", "frame", "parse", "name", "sync", "part", "pos", "id", "entry", "m", "file", "time", "list", "block", "str", "response"], "N": ["Q", "P", "Z", "D", "H", "n", "I", "M", "NA", "A", "NT", "SN", "na", "ns", "G", "U", "o", " n", "Ni", "Ns", "W", "O", "Num", "E", "Sn", "C", "V", "L", "X", "number", "Y", "K", "B", "F", "NS", "R"], "S": ["P", "Q", "State", "J", "Na", "size", "Z", "D", "Size", "ss", "POS", "H", "n", "I", "s", "M", "SU", "A", "SN", "SA", "AS", "G", " s", "U", "Sa", "SE", "Ns", "W", "ps", "sp", "O", "sample", "SL", "E", "SC", "SP", "C", "V", "Si", "L"], "p": ["P", "l", "j", "z", "pp", "per", "i", "u", "n", "r", "b", "s", "lp", "pe", "cp", "v", "M", "A", "Po", "jp", "np", "NP", "k", "dp", "d", "m", "PA", "pi", "tp", "point", "o", "bp", "pc", "e", "ps", " P", "sp", "y", "f", "C"], "a": ["aa", "ai", "l", "wa", "section", "sta", "ab", "z", "alpha", "i", "va", "am", "ada", "oa", "n", "ba", "s", "b", "au", " A", "span", "data", "A", "sa", "array", "asa", "ha", "int", "part", "area", "ga", "ata", "d", "m", "ae", "na", "Array", "auto", "o", "ac"], "cnt": ["ncnt", "lcnc", "pnd", "pct", "cgt", "lcrt", "count", " count", " crt", "ppt", "fcrt", "incnt", " cct", "incgt", "lcct", " cpt", "ncount", "rcnt", "rcgt", "acpt", "cnc", "lcnd", " cNT", "acnt", "fcct", "ncNT", "acNT", "rcnd", "rcount", "fcnt", "ncpt", " cnc", "lcnt", " cnd", "crt", "incnd", "acount", "cpt", "cnd", "fcnc"], "x": ["step", "xb", "ex", "l", "P", "j", "z", "size", "page", "case", "u", "i", " X", "dx", "insert", "xxx", "n", "xx", "v", "expl", "_", "s", "xy", "int", "xi", "sex", "xc", "k", "xes", "d", "pos", "id", "m", "wx", "time", "ax", "xt", "point", "o", "ix"]}}
{"code": "def isPalindrome(number):\n      strNum = str(number)\n      for i in range(len(strNum)/2 + 1):\n          if strNum[i] != strNum[-1*(i+1)]:\n              return False\n      return True\n  \n  '''for i in range(40):\n      if isPalindrome(i) and isPalindrome(i*i):\n          print i*i\n  '''\n  \n  \n  filename = \"C-small-attempt0.in\"\n  outputname = filename + \"out.txt\"\n  \n  inFile = open(filename, 'r')\n  outFile = open(outputname, 'w')\n  \n  \n  fairAndSquareNums = [1,4,9,121,484]\n  \n  numTests = int(inFile.readline())\n  \n  for i in range(numTests):\n      line = inFile.readline().split()\n      count = 0\n      for j in range(int(line[0]), int(line[1])+1):\n          if j in fairAndSquareNums:\n              count += 1\n      outFile.write(\"Case #\" + str(i+1) + \": \" + str(count) + '\n')\n      print \"Case #\" + str(i+1) + \": \" + str(count)\n  \n  inFile.close()\n  outFile.close()\n", "substitutes": {"number": ["text", "size", "byte", "anything", "unit", "rice", "random", "reference", "n", "b", "value", "input", "zero", "span", "data", "object", "python", "source", "expression", "int", "type", "function", "name", "document", "integer", "p", "m", "umber", "phone", "digit", "x", "num", "o", "length", "mini", "request", "regular", "result", "Number", "version"], "strNum": ["StrNum", "striVal", "strNumber", " strTon", "striNum", "arrVal", "arrNum", "strNUM", "strnum", "frNum", "striNUM", "strVal", "strLen", "StrNumber", " strnum", " strLen", "StrLen", "frTon", "StrNUM", "StrName", "arrName", "arrnum", "frNumber", " strNumber", "strTon", "frLen", "arrNumber", "StrTon", "striNumber", " strNUM", " strVal", "arrLen", " strName", "Strnum", "StrVal", "strName"], "i": ["l", "key", "ti", "t", "b", "connection", "qi", "phi", "uri", "int", "init", "multi", "ei", "id", "o", "io", "iq", "y", "start", "c", "ini", "ci", "si", "image", "ij", "ite", "eni", "ri", "im", "r", "isi", "xi", "bi", "m", "inner", "x", "ni", "jo", "ix", "mini"], "filename": ["maximum", "l", "summary", "ppa", "knife", "database", "journal", "ename", "figure", "management", "url", "path", "File", "stem", "sf", "information", "lace", "Filename", "wl", "dll", "license", "fil", "txt", "kn", "name", "phrase", "document", "tail", "ilk", "location", "file", "binary", "sequence", "nil", "FILE", "prefix", "json", "named", "subject", "sole"], "outputname": ["outputstring", "writefile", "Outputname", "Outputstring", " outputfile", "Outputfile", "outfilename", " outputName", "outputfile", "writename", " outputstring", "outputfilename", "Outputfilename", "outfile", " outputfilename", "outname", "outputName", "writeName", "outName", "OutputName", "writestring"], "inFile": ["ninLine", " inStream", "outLoop", "inLoop", "insfile", "ninfile", "outFilename", "Infile", "insString", "insStream", " inFolder", "insFolder", "insLoop", " inLoop", "dinFile", "inString", "ninFile", "InSourceFile", "inSourceFile", "inFolder", "iniSourceFile", "outString", "iniFile", "inifile", "dinfile", "outfile", "outStream", "isinFile", "InFile", " inSourceFile", "inStream", "isinStream", " inString", "insFile", "infile", "InStream", "isinFilename", "dinFilename", "ninFolder", " inLine"], "outFile": ["OUTFolder", "newStream", "outputFolder", "OutFile", "outputFile", "outputDirectory", " outfile", "offLock", "OUTLog", "outLine", "outputfile", "outLock", "newFile", " outFolder", "OutDirectory", "newFolder", "OutStream", "offFile", "OUTLock", "outFolder", "OUTFile", "outfile", "outStream", "outputLine", " outStream", " outDirectory", "offLog", "OutLine", "outDirectory", "outLog", " outLine", "newfile", "outputStream", "offFolder", " outLog", " outLock"], "fairAndSquareNums": ["fairAndsquarenumeric", "fairAndsquareNumeric", "fairAndsquareNum", "fairAndSquareNumbers", "fairAndSquarenumbers", "fairAndSquareNsumeric", "fairAndSquareNum", "fairAndSquareCums", "fairAndSquareNsumbers", "fairAndsquarenumbers", "fairAndsquareNomes", "fairAndSquareCum", "fairAndSquarenum", "fairAndsquarenum", "fairAndSquarenums", "fairAndSquareNumeric", "fairAndSquareComes", "fairAndSquareNsum", "fairAndSquareCumbers", "fairAndSquareNomes", "fairAndsquarenomes", "fairAndSquarenumeric", "fairAndSquarenomes", "fairAndsquareNums", "fairAndsquareNumbers", "fairAndsquarenums", "fairAndSquareNsums"], "numTests": ["numTenests", "numNcases", "numtesters", "numbertcases", "numbertests", "NumTickets", "numTucases", "numtests", "numberTests", "numberTtests", "numberttests", "numTesttests", "numtcases", "numbertesters", "NumTencases", "NumTenickets", "numTencases", "numTestcases", "numberTesters", "numNests", "numTentests", "numTutests", "NumTtests", "numTesters", "numTiickets", "numTiests", "numTickets", "numTestickets", "numTuests", "NumTcases", "NumTests", "numTestests", "numttests", "numTcases", "NumTenests", "numTuesters", "numberTcases", "numNtests", "numNesters", "numTtests"], "line": ["LINE", "log", "l", "section", "strip", "cell", "text", "link", "le", "page", "lo", "zip", "inline", "case", "out", "iter", "comment", "character", "unit", "col", "range", "b", "ge", "data", "chain", "source", "se", "ne", "frame", "parse", "name", "sync", "part", "day", "entry", "file", "look", "list", "block", "cl"], "count": ["key", "connection", "all", "int", "name", "id", "file", "allow", "list", "other", "fail", "offset", "nb", "coll", "counter", "start", "c", "Count", "log", "add", "size", "case", "data", "true", "group", "level", "limit", "base", "cache", "sum", "code", "use", "more", "index", "zip", "error", "col", "found", "call", "total"], "j": ["note", "J", "l", "ji", "obj", "z", "ij", "size", "jl", "col", "I", "n", "r", "b", "ge", "cor", "_", "jp", "ne", "int", "ie", "ch", "li", "stat", " it", "x", "jo", "je", "num", "match", "jj", "ct", "length", " n", "fail", " c", "e", "you", "h", "no"]}}
{"code": "inputFile = open(\"B-small-attempt0 (3).in\", 'r')\n  outputFile = open(\"dancingOutSmall.txt\", 'w')\n  numTests = int(inputFile.readline())\n  \n  def countDancers(n,s,p,totals):\n      guaranteed = 0\n      needSurprise = 0\n      if p == 1:\n          for total in totals:\n              if total != 0:\n                  guaranteed += 1\n          return guaranteed\n      for total in totals:\n          if total >= p*3 - 2:\n              guaranteed += 1\n          elif total >= p*3 - 4:\n              needSurprise += 1\n      if needSurprise > s:\n          return guaranteed + s\n      else:\n          return guaranteed + needSurprise\n  \n  for i in range(numTests):\n      line = inputFile.readline().split()\n      n = int(line[0])\n      s = int(line[1])\n      p = int(line[2])\n      totals = []\n      for j in range(n):\n          totals += [int(line[3+j])]\n      outputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '\n')\n  \n  outputFile.close()\n", "substitutes": {"inputFile": ["sourceDirectory", "outputFiles", "sourceFile", "inputFiles", "inputLine", " inputDirectory", " inputLine", "argumentFiles", "inputStream", "InputFiles", "InputLine", "InputFILE", "inputFILE", " inputStream", "argumentFILE", "argumentStream", "InputFile", "sourceFiles", "InputDirectory", " inputFiles", "InputStream", "sourceLine", "argumentFile", "outputFILE", "outputStream", "inputDirectory", "outputLine"], "outputFile": ["outputFiles", "inputFiles", "inputFilename", "outputDirectory", " outputfile", "Outputfile", "outputfile", " outputDir", "returnFilename", "inputStream", "outputFilename", "returnStream", " outputStream", " outputFiles", "returnDirectory", "OutputDir", "OutputDirectory", "OutputStream", "returnFile", "returnDir", "OutputFile", "outputStream", "outputDir", "inputDir", "OutputFiles", "inputDirectory", "returnfile", "OutputFilename"], "numTests": [" numTencases", " numTenasks", "numTenests", "numEntester", "numTestasks", " numTrial", "numTenrial", "numTasks", "numTrial", "NumFasks", "numFcases", "numTester", "numPatests", "numTenasks", " numTenrial", "numPatcases", "numTencases", "numFester", "numTestcases", "NumFcases", "NumTasks", "NumTester", " numTenests", "numTestester", "numFests", "numEntcases", "NumFests", "NumFester", " numTasks", "NumTcases", "NumTests", "numTestests", "numTcases", "numFrial", " numTcases", "numEntests", "numEntasks", "numPatasks", "numFasks", "numPatrial"], "n": ["P", "l", "min", "z", "size", "t", "u", "pn", "loc", "r", "b", "v", "nu", "node", "nw", "np", "ne", "net", "init", "name", "k", "on", "d", "pos", "m", "na", "ns", "x", "num", "N", "o", "nb", "e", "sp", "an", "nc", "cn", "h", "no", "y"], "s": ["l", "t", "b", "sa", "stats", "us", "sh", "tp", "o", "steps", "ans", "xs", "h", "y", "start", "c", "g", "sb", "si", "lines", "size", "sets", "sf", "ses", "r", "less", "sie", "se", "m", "site", "ns", "os", "spec", "sp", "ls", "a", "ssl", "w", "ips", "gs"], "p": ["l", "pp", "t", "b", "pr", "press", "scale", "tp", "o", "ap", "h", "y", "pt", "c", "params", "g", "pa", "ep", "size", "per", "py", "lp", "r", "period", "pu", "np", "limit", "m", "pid", "x", "sp", "a", "number", "w", "api", "pn", "u", "cp", "part", "k"], "totals": ["totall", "totiotal", "totsals", "Tottals", "tfatale", "Towalls", "tfatials", "Towal", "tottales", "totsations", "tottes", "tiotals", "totalities", "totes", "Tototal", "Totations", "Tiotalls", "Totals", "pottes", "tottalls", "Tottales", "tiotale", "totsalities", "totsials", "totses", "pottals", "towal", "potials", "totialls", "Totale", "tiotal", "tottals", "Towalities", "Towales", "tottall", "towals", "tfatals", "totsalls", "potalls", "tfatall"], "guaranteed": ["Guantree", "guantedees", "guantedee", " guarentee", "guanteal", "guaureed", "GuarantEED", "Guarantees", "guaureal", "guessal", "guarantEED", "guantees", "guustal", "Guarantee", "guafeed", "guarantly", "guafeal", "guarentee", "guarantees", "guantedeed", "guantededed", "guarental", "guafees", "guarentees", "guantee", "guustee", "guopardEED", "guarantal", "guanteed", "Guantees", "guantal", "guarentree", "guantEED", "Guarantree", "Guanteed", "Guanteal", "Guantal", " guarenteded", "guesseed", " guarantee"], "needSurprise": ["needSurception", " needSurprises", "needsurvey", "needAsprises", "needCurception", "knowsurprise", "knowsurvey", "needSurprising", " needSurvey", "needSurface", "needsurface", "needSuperception", " needCurprising", "needAsprise", "needCurprise", "needSuperprises", "needSuperprise", " needSurprising", "needSurprises", "needMarface", "needsurprising", "knowSurprising", "needAsvey", "needsurprises", "needMarprising", "knowSurprise", " needCurprises", "needCurprises", "needSurvey", "knowsurface", "needSuperprising", "needCurprising", "needsurprise", "knowsurprising", "needMarprise", "knowSurvey", "needCurvey", "needCurface", " needCurprise", " needSurception"], "total": ["otal", "t", "scale", "all", "completely", "seed", "active", "gross", "ta", "tp", "o", "c", "initial", "basic", "pa", "si", "quant", "note", "size", "complete", "valid", "set", "percent", "less", "partial", "market", "average", "m", "tax", "sp", "no", "latest", "a", "number", "specified", "done", "nt", "last", "open", "necessary"], "i": ["ai", "ip", "z", "chi", "page", "cli", "ti", "u", "iter", "t", "ski", "I", "ui", "qi", "slice", "it", "jp", "uri", "int", "xi", "ie", "k", "multi", "li", "ei", "id", "m", "iu", "inner", "x", "pi", "di", "io", "ix", "mini", "e", "iq", "y", "f", "q"], "line": ["l", "inline", "key", "loc", "b", "shell", "ne", "frame", "name", "id", "file", "look", "list", "cl", "rule", "lf", "cle", "string", "c", "column", "LINE", "log", "le", "lo", "lines", "case", "data", "se", "item", "sync", "do", "entry", "no", "du", "number", "use", "date", "liner", "end", "strip"], "j": ["note", "J", "l", "adj", "section", "ji", "z", "obj", "ij", "jl", "key", "t", " dj", "b", "pm", "pr", "v", "job", "jp", "se", "net", "int", "ie", "k", "ch", "li", "m", "ni", "pi", "je", "dj", "point", "jj", "jump", "str", "o", "ps", "ja", "jit", "sp"]}}
{"code": " \n  n_cases = input()\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def is_palindrome(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  for case in xrange(1, n_cases + 1):\n      a, b = to_ints(raw_input())\n  \n      nums = range(int(b ** .5) + 2)\n      palins = filter(is_palindrome, nums)\n      squares = [x**2 for x in palins]\n      palin_squares = filter(is_palindrome, squares)\n      range_squares = [x for x in palin_squares if a <= x <= b]\n  \n      print \"Case #%d: %s\" % (case, len(range_squares))\n", "substitutes": {"n_cases": ["n__tests", " nxtimes", "nxtests", "n__cases", " n_times", " nxcases", "n_chains", "n__sections", "nxtimes", " n_sections", " n_lines", "nxcases", " nxlines", "n_lines", "n_times", "n__times", "n_tests", "n_sections", "nxlines", " n_tests", " n_chains", "n__chains", "n__lines", " nxtests"], "s": ["l", "i", "t", "input", "tests", "o", "ans", "xs", "ments", "h", "y", "string", "c", "g", "sb", "ends", "strings", "si", "speech", "ing", "sets", "ses", "r", "sf", "js", "less", "se", "sync", "qs", "m", "ns", "os", "spec", "ls", "w", "gs", "small", "es", "ins", "u"], "n": ["l", "j", "z", "t", "u", "i", "r", "v", "net", "ne", "name", "k", "d", "p", "m", "na", "nin", "ns", "num", "N", "o", "nb", "e", "names", "Ns", "an", "nn", "nc", "cn", "no", "y", "en", "sn", "f", "S", "q", "c", "number", "network", "w"], "case": ["section", "Case", "address", "config", "ab", "size", "sea", "ce", "loc", "core", "ue", "abc", "one", "count", "me", "trial", "ve", "ase", "chance", "int", "app", "name", "xc", "ie", " _", "ace", "id", "p", "position", "num", "match", "line", " i", " c", "race", "length", "cases", "space", "e", "bug"], "a": ["ai", "aa", "wa", "ab", "alpha", "i", "u", "va", "ada", "am", "ba", "au", " A", "span", "sa", "A", "ga", "area", "ae", "p", "m", "na", "ax", "abs", "pi", "num", "ac", "da", "la", "ea", "base", "e", "an", "ad", "ca", "y", "f", "c", "ma", "xa"], "b": ["bar", "xb", "l", "aa", "j", "ab", "z", "abb", "ib", "i", "u", "bb", "rb", "r", "v", "ba", "wb", "bin", "fb", "k", "bi", "area", "ben", "d", "ae", "p", "bf", "m", "eb", "bs", "ob", "binary", "num", "bis", "mb", "bp", "sb", "o", "lb", "nb"], "nums": ["snums", "nonumbers", "snoms", "enoms", " nules", " numbers", "enumbers", "nules", "nubes", "snumbers", "ennums", " noms", "ennubes", " nubes", "noms", "snules", "enubes", "numbers", "nonules", "enums", "nonoms", "ennoms", "ennumbers", "nonums"], "palins": ["opalouts", "pin", "aliins", "aliin", " palouts", "pis", "PalIns", "paris", " palIns", "palin", "palis", "parans", "palIns", "pins", "alians", "parin", "palouts", "Palins", "pans", "parins", "aliis", "palans", "Palouts", "opalins", "opalIns"], "squares": ["scars", "squared", "quars", "sqakes", "Squars", "squars", "Squares", "sqars", " squakes", "scares", "quares", "quared", "Squakes", "quashes", "scakes", "sqares", "scashes", "sqashes", " squared", "squashes", " squars", "Squared", "quakes", "squakes"], "x": ["co", "ex", "l", "alpha", "rax", "i", "t", "xx", "ross", "int", "sex", "id", "oint", "rx", "cl", "o", "ct", "tx", "xs", "h", "y", "c", "flex", "gal", "px", "ci", "pa", "www", "j", "r", "cross", "xi", "m", "auto", "ix", "no", "code", "com", "X", "number"], "palin_squares": ["palin_squapes", "palin_shares", "palin_quapes", "palin_share", "palin_Squaring", "palin_shared", "palin_quare", "palin_squaring", "palin_sharing", "palin_sqare", "palin_Square", "palin_sqared", "palin_squared", "palin_quaring", "palin_square", "palin_Squared", "palin_quared", "palin_Squares", "palin_Squapes", "palin_quares", "palin_sqapes", "palin_sqares"], "range_squares": ["range_Squared", "range_square", "range_quare", "range_Squeries", "range_varieries", "range_Square", "range_sqeries", "range_squared", "range_qares", "range_Squars", "range_Squares", "range_sqared", "range_quared", "range_squeries", "range_qeries", "range_qare", "range_variars", "range_sqars", "range_sqares", "range_queries", "range_qared", "range_quares", "range_variared", "range_variares", "range_squars"]}}
{"code": "n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      ins = map(int, raw_input().strip().split())\n      n = ins[0]\n      s = ins[1]\n      p = ins[2]\n      t = ins[3:]\n  \n      out = 0\n      for x in t:\n          if (x + 2) / 3 >= p:\n              out += 1\n          elif s and x > p and p - ((x - p) / 2) <= 2:\n              out += 1\n              s -= 1\n              \n      print \"Case #%d: %s\" % (case, out)\n", "substitutes": {"n_cases": ["nxtests", "nalltests", " n_times", "n_rows", "n_points", "nallpoints", " n_rows", " n_cells", "nxpoints", "nxrows", "nxcases", "n_cells", "n_times", "n_tests", " n_points", " n_tests", "nallrows", "nallcases"], "case": ["exc", "section", "Case", "config", "shape", "size", "ce", "loc", "core", "path", "count", "me", "loop", "pe", "pair", "trial", "chain", "ase", "se", "int", "name", "xc", "ace", "id", "d", "pos", "position", "time", "num", "sequence", "match", "line", " i", " c", "cases", "e", "ice", "code", "switch", "number"], "ins": ["includes", "ex", "IN", "ones", "features", "lines", "ines", "bits", "args", "amps", "ss", "eps", "input", "ks", "inn", "strings", "cons", "cs", "ids", "tests", "int", "ats", "init", "ips", "alls", "ains", "breaks", "events", "blocks", "pos", "works", "rules", "bs", "outs", "inner", "ns", "tips", "abs", "bis", "mins"], "n": ["l", "j", "z", "i", "r", "b", "v", "span", "np", "ne", "k", "pos", "m", "na", "ns", "pi", "num", "ni", "N", "o", " c", "nb", "e", "nc", "y", "en", "sn", "f", "c", "number", "g", "w", "ind", "nt"], "s": ["opt", "l", "ex", "es", "sq", "lines", "z", "size", "sec", "features", "submit", "i", "pn", "u", "ss", "states", "ses", "b", "v", "r", "sf", "span", "cs", "left", "se", "sync", "d", "m", "site", "als", "outs", "ns", "sym", "abs", "o", "steps", "space", "os", "ops", "e"], "p": ["P", "l", "j", "z", "per", "pp", "py", "i", "u", "pn", "r", "b", "lp", "pr", "v", "cp", "pe", "op", "ot", "np", "int", "d", "pos", "m", "pi", "num", "tp", "bp", "point", "o", "up", "pc", "e", "ps", "sp", "pre", "h", "y", "a", "f"], "t": ["step", "l", "j", "z", "u", "i", "set", "r", "b", "v", "pe", "tt", "python", "int", "type", "k", "d", "pos", "m", "ns", "ta", "tp", "sequence", "point", "xt", "o", "tw", "e", "sp", "h", "y", " T", "en", "a", "f", "pt", "q", "c", "T", "g"], "out": ["co", "ex", "key", "path", "b", "all", "int", "name", "id", "outs", "list", "line", "o", "y", "string", "c", "g", "In", "obj", "next", "sync", "inner", "err", "token", "no", "output", "a", "number", "w", "at", "off", "index", "exp", "Out", "example", "unit", "error", "it", "part", "pos"], "x": ["step", "ex", "l", "j", "z", "size", "example", "u", "i", " X", "xe", "xxx", "dx", "b", "xx", "v", "pe", "cross", "python", "ic", "xf", "xy", "int", "xi", "xc", "k", "xes", "pos", "d", "id", "m", "wx", "na", " xp", "ax", "rx", "num", "xt", "point", "ct"]}}
{"code": "'''\n  Created on 13 Apr 2013\n  \n  @author: mengda\n  '''\n  \n  ls = []\n  \n  def isP(num):\n      num = str(int(num))\n      for i in range(len(num) / 2):\n          if num[i] <> num[-1 - i]:\n              return False\n      return True\n  \n  def createP(root, half_digits):\n      root = str(root)\n      for i in range(half_digits):\n          ls[i] = root[i]\n          ls[-1 - i] = root[i]\n      return int(''.join(ls))\n  \n  def process(A, B):\n      rlt = 0\n      a = int(math.ceil(math.sqrt(A)))\n      b = int(math.floor(math.sqrt(B)))\n      str_a = str(a)\n      half_digits = int(math.ceil(len(str_a) / 2.0))\n      root = int(str_a[:half_digits])\n      next_root = 10 ** half_digits\n      digits = len(str_a)\n      for _ in range(digits - len(ls)):\n          ls.append('')\n      while True:\n          if root == next_root:\n              if digits % 2 == 0:\n                  next_root *= 10\n                  half_digits += 1\n              else:\n                  root /= 10\n              digits += 1\n              ls.append('')\n          p = createP(root, half_digits)\n          print p,\n          if p > b:\n              print 'too large'\n              break\n          if isP(math.pow(p, 2)):\n              print 'right one!'\n              rlt += 1\n          else:\n              print \n          root += 1\n      return rlt\n  \n  def process1(A, B):\n      rlt = 0\n      a = int(math.ceil(math.sqrt(A)))\n      b = int(math.floor(math.sqrt(B)))\n      for i in range(a, b + 1):\n          if not isP(i):\n              continue\n          power = math.pow(i, 2)\n          if isP(power):\n              rlt += 1\n      return rlt\n  \n  f = open('C-small-attempt1.in', 'r')\n  T = int(f.readline())\n  outLine = []\n  \n  for i in range(1, T + 1):\n      (A, B) = map(int, f.readline().split())\n      outLine.append('Case #%d: %s\n' % (i, process1(A, B)))\n      print outLine[-1],\n  \n  f.close()\n  outFile = open('C-S.out', 'w')\n  outFile.writelines(outLine)\n  outFile.close()\n", "substitutes": {"ls": ["rl", "las", "l", "ld", "es", "lines", "ins", "ss", "lp", "lt", "s", "strings", "els", "wl", "roots", "les", "dl", "cs", "tests", "fts", "ln", "alls", "li", "ds", "lv", "ys", "ils", "lists", "lr", "bs", "los", "als", "ns", "list", "lbs", "ios", "details", "bps", "lis", "tl"], "num": ["loc", "dim", "init", "int", "name", "multi", "id", "nom", "digit", "nil", "inc", "dom", "nb", "nc", "gnu", "c", "Num", "size", "iter", "valid", "mn", "mon", "np", "m", "bc", "ns", "x", "umi", "number", "ng", "end", "index", "nu", "text", "unit", "u", "node", "common", "NUM", "total"], "i": ["l", "ti", "t", "loc", "ih", "qi", "phi", "uri", "int", "multi", "area", "ei", "id", "o", "io", "h", "y", "start", "c", "g", "ini", "ci", "si", "lo", "j", "ij", "eni", "py", "xi", "bi", "m", "x", "ni", "ix", "mini", "hi", "gi", "index", "cli", "api"], "root": ["children", "alpha", "right", "rew", "loc", "path", "abc", "input", "pr", "ot", "op", "uri", "name", "id", "rank", "seed", "box", "round", "nil", "o", "dom", "offset", "h", "bottom", "tree", "af", "string", "c", "g", "ep", "section", "ow", "wire", "valid", "core", "set", "r", "value", "term", "data"], "half_digits": ["half_milists", "half_sequbits", "half_Digbits", "half_digitets", "half_multiplets", "half_logitive", "half_digitive", "half_digITS", "half_digions", "half_Digins", "half_multiplbits", "half_Digiles", "half_minits", "half_digiles", "half_minists", "half_pinsitive", "half_logits", "half_pinsets", "half_pinsITS", "half_dimit", "half_digets", "half_digitins", "half_milions", "half_mililes", "half_Digets", "half_milbits", "half_bigit", "half_milits", "half_digitits", "half_multiplins", "half_pinsits", "half_dimins", "half_logets", "half_sequits", "half_Digities", "half_Digists", "half_DigITS", "half_logITS", "half_digitITS", "half_milit"], "A": ["Ac", "API", "D", "Ma", "au", "Data", "GA", "SA", "Next", "TA", "One", "L", "Y", "Input", "Num", "AY", "Fa", "Ay", "Na", "H", "AB", "Alt", "M", "NA", "AN", "Am", "This", "U", "AW", "W", "Ar", "O", "CA", "E", "Ra", "X", "An", "mA", "Ak", "R"], "B": ["P", "URL", "Q", "WB", "Ub", "QB", "DB", "D", "FB", "GB", "Second", "BT", "IB", "UB", "AB", "Other", "I", "BF", "BW", "RB", "M", "LB", "BM", "Bu", "Ab", "SB", "PB", "VB", "NB", "Bs", "Bah", "U", "N", "BER", "BB", "BC", "Bar", "CB", "BE", "BS"], "rlt": ["rLT", "rrbt", "rrlett", "rglett", "rglt", " rgt", "rrlt", "rritt", "brlt", "Rlett", "roret", "srilt", "rroret", "plt", "Rlt", " rbt", " rilt", "srgt", " rlett", " roret", "pgt", "Rbt", "RLT", "ritt", "rrelt", " ritt", "rgoret", "srLT", "rbt", "Relt", "brelt", "srelt", "rgelt", "Rilt", "srlett", " rLT", "pelt", "rlett", "rilt", "rgt"], "a": ["aa", "ai", "l", "aux", "sta", "ab", "wa", "ama", "alpha", "args", "u", "api", "va", "am", "oa", "n", "ba", "au", "off", "sa", "array", "aw", "area", "aba", "d", "ae", "m", "active", "ata", "na", "x", "o", "aj", "ac", "la", "ap", "ea", "e", "da", "an"], "b": ["l", "abb", "rb", "t", "abc", "bis", "o", "nb", "h", "y", "c", "g", "bas", "sb", "j", "ab", "bb", "r", "bi", "m", "bc", "bs", "binary", "x", "bp", "lb", "bound", "base", "cb", "bt", "number", "beta", "w", "bar", "end", "br", "u", "s", "db", "fb"], "str_a": ["str__a", "raw___fa", "str___ab", "str___aaa", "str___a", "str__A", "str_A", "raw___a", "str128fa", "str_an", "raw___aaa", "raw_a", "str_m", "str128a", "Str_A", "str_am", "Str_a", "str_b", " str_m", "raw_aaa", "str_aaa", "raw_fa", "str___fa", " str_an", "raw_ab", " str_A", "Str_an", "str__an", "raw___ab", "str__m", "Str_b", "Str_fa", "str128b", "str128an", "str_ab", "str_fa", "Str_am"], "next_root": ["next_depth", "next_loc", " next_seed", "next67root", "next54depth", "next67value", "next54grade", "next_value", "next_seed", "next54roots", "next67loc", " next_depth", " next_value", " next_roots", " next_loc", "next54root", " next_grade", "next_roots", "next_grade"], "digits": ["multiplit", "divbits", "multiplits", " digbits", "milbits", "multiplitives", "generities", "divests", "digests", " digitives", "multiplbits", "divits", "Digits", "digit", "digists", "generit", " digit", "Digitives", "divists", "milits", "milit", "Digists", "generits", "digities", "digbits", "generbits", "milities", " digests", "Digbits", "digitives", "Digests", "milists", "Digit", "Digities", "divit"], "_": ["lo", "l", "ow", "s", "x", "o", "of", "len", "__", " x", "g"], "p": ["P", "l", "ip", "j", "pp", "pl", "py", "t", "u", "api", "out", "pn", "n", "r", "s", "v", "lp", "pr", "cp", "pe", "op", "ot", "jp", "np", "pb", "dp", "part", "d", "m", "pid", "pot", "wp", "mp", "po", "x", "pi", "tp", "bp", "point", "o"], "power": ["P", "ip", "j", "size", "chi", "alpha", "pp", "case", "ow", "max", " I", "br", "sup", "I", "count", "energy", "now", "print", "pe", "qi", "data", "shift", "OWER", "element", "ch", "k", "part", " Power", "ion", "pipe", "component", "pi", "o", "length", "age", "state", "ix", "strength", "powers", "depth"], "f": ["l", "ff", "uf", "z", "rf", "folder", "feed", "df", "t", " r", "ref", "iter", "fit", "input", "r", "fi", "n", "v", "inf", "fd", "full", "fe", "stream", "fen", "xf", "fc", "fb", "tf", "function", "fl", "d", "bf", "m", "form", "file", "handler", "fr", "fac", "fm", "o"], "T": ["P", "TS", "Z", "D", "TH", "Size", "t", "Ti", "H", "I", "M", "NT", "TC", "Ts", "TW", "WT", "Time", "time", "TA", "G", " t", "U", "N", "TN", "TI", "Tu", "W", "O", "Total", "E", "C", "Length", "S", "V", "Temp", "L", "X", "TB", "TT", "K"], "outLine": ["OutRow", "OutList", "sumLine", "againRow", "sumRow", "againList", "OutBuffer", "sumBuffer", "outBuffer", "OutLine", "sumList", "againLine", "outList", "againBuffer", "outRow"]}}
{"code": "'''\n  Created on 2012-4-14\n  \n  @author: hemnd\n  '''\n  def cal(args):\n      rslt = 0\n      N = int(args[0])\n      S = int(args[1])\n      p = int(args[2])\n      for i in range(N):\n          s = int(args[i + 3])\n          e = s / 3\n          r = s % 3\n          if e >= p:\n              rslt += 1\n          elif r == 1:\n              if e + 1 >= p:\n                  rslt += 1\n          elif r == 0:\n              if e == 0:\n                  continue\n              if S > 0 and e + 1 >= p:\n                  rslt += 1\n                  S -= 1\n          elif r == 2:\n              if e + 1 >= p:\n                  rslt += 1\n              elif S > 0 and e + 2 >= p:\n                  rslt += 1\n                  S -= 1\n      return rslt\n  \n  inputFile = open('B-small-attempt0.in', 'r')\n  inputLines = inputFile.readlines()\n  inputFile.close()\n  \n  T = int(inputLines[0])\n  outputLines = []\n  \n  for i in range(1, T + 1):\n      args = inputLines[i].strip().split(' ')\n      outputLines.append('Case #%d: %d\n' % (i, cal(args)))\n      print outputLines[i - 1],\n  \n  outputFile = open('B-small.out', 'w')\n  outputFile.writelines(outputLines)\n  outputFile.close()\n", "substitutes": {"args": ["l", "mm", "loc", "input", "init", "grades", "function", "alls", "atts", "GS", "comments", "names", "dates", "cmd", "first", "string", "c", "params", "g", "vals", "strings", "log", "magic", "j", "lines", "obj", "py", "ras", "data", "array", "ids", "np", "ands", "dict", "words", "qs", "m", "ns", "err", "x"], "rslt": ["RSitt", "rsalt", "arsgt", "rsitt", "rsnat", "rslett", " rsitt", "arsrt", "rtlt", "rysgt", "RSlt", "rlt", "rslit", "arslit", "arslett", "ssLT", "RSlit", "srLT", "RSgt", "Rslt", "RSelt", "arsalt", "arslt", " rsgt", "rtitt", "cslt", "srli", "rysalt", "cslit", "rselt", "arselt", "srlett", "rsli", "RSLT", "Rsgt", " rselt", "rtnat", "cselt", "rtelt", "ryslt"], "N": ["P", "Q", "J", "Z", "D", "Size", "H", "I", "n", "RN", "M", "NA", "Len", "NT", "A", "SN", "NM", "G", "NL", "U", "No", " n", "Ni", "Ns", "W", "O", "Num", "E", "OS", "C", "Ne", "V", "MN", "L", "X", "K", "Y", "B", "F", "NS"], "S": ["Q", "State", "Fs", "D", "Ps", "Socket", "SA", "SK", "AS", "SE", "Ns", "SL", "LS", "L", "c", "VS", "Y", "g", "SS", "DS", "si", "RS", "size", "H", "M", "SU", "se", "ns", "U", "os", "W", "sp", "O", "E", "V", "X", "B", "SI", "R", "Case"], "p": ["P", "l", "ip", "j", "z", "pp", "null", "api", "t", "u", "after", "n", "lp", "b", "v", "cp", "M", "pe", "python", "np", "k", "part", "parent", "d", "m", "pot", "wp", "power", "x", "pi", "tp", "point", "vp", "o", "local", "ap", "ps", " P", "sp", "pre"], "i": ["l", "key", "ti", "t", "b", "ih", "qi", "phi", "int", "multi", "ei", "id", "o", "io", "iq", "h", "y", "start", "c", "g", "ini", "ci", "si", "j", "ij", "size", "eni", "iter", "ri", "xi", "bi", "m", "x", "ni", "ix", "mini", "hi", "a", "gi", "index"], "s": ["l", "es", "j", "sq", "size", "z", "t", "u", "sets", "ss", "n", "b", "v", "ses", "sa", "cs", "se", "sv", "ds", "d", "m", "ns", "south", "o", "os", "ps", "sp", "ls", "xs", "y", "f", "a", "c", "g", "w", "rs", "gs", "si"], "e": ["le", "l", "es", "j", "z", "size", "ime", "ise", "east", "t", " E", "u", "ce", "esi", "ss", "n", "energy", "v", "pe", "b", "me", "one", "eq", "ele", "fe", "ev", "se", "oe", "ell", "ne", "ec", "ie", "ae", "d", "id", "m", "x", "er", "ef", "o"], "r": ["rl", "P", "l", "ir", "j", "z", "rf", "br", "ur", "rb", " R", "t", "u", "mr", "n", "b", "Rs", "v", "I", "range", "pr", "dr", "it", "rar", "rt", "d", "re", "cr", "m", "lr", "fr", "err", "er", "x", "o", "sr", "yr", "rn", " Re", "h"], "inputFile": ["sourceDirectory", "outputFiles", "InputBuffer", "sourceFile", "inputFiles", "outputFile", "resultFile", "outputDirectory", "resultDirectory", " inputDirectory", " inputBuffer", "outputfile", "inputStream", "InputFiles", "Inputfile", "inputBuffer", "inputFolder", "resultFiles", "InputFile", "InputDirectory", "inputfile", "InputStream", " inputFiles", "InputFolder", " inputFolder", "outputStream", "sourceFolder", "resultfile", "outputBuffer", "sourceStream", "inputDirectory", " inputStream"], "inputLines": ["inputCLues", "inputBlues", " inputLites", "inputSlined", "inputLine", "inputSlites", " inputSlanes", "inputCLites", "inputPlows", "inputFlines", "inputPllines", "inputLongows", " inputLlines", "inputFlites", "InputBlines", "inputSlues", " inputLanes", " inputSlines", " inputSlites", "InputBlined", "inputCLined", "inputFlows", " inputPlelines", "inputLelines", "InputLues", "inputCLlines", "InputLine", "inputPlines", "InputLines", "inputLites", "inputCLanes", "InputLined", "inputCLines", " inputLows", "inputBlined", "inputCLine", "inputLlines", "InputBlues", "inputBline", " inputPlines"], "T": ["P", "Q", "J", "DT", "TS", "Z", "D", "Size", "Ti", "t", "TH", "H", "I", "n", "IP", "M", "A", "NT", "TG", "WT", "Time", "TA", "G", "U", "TN", "TI", "W", "O", "E", "C", "Length", "V", "L", "X", "TB", "TT", "Y", "K", "B", "CT"], "outputLines": ["outputBine", "responseCLelines", "outputCLine", "outputBines", "outputBlizes", "responseLlines", "writeLines", "outputVine", "OutputLines", "outputRodes", "outputLineines", "responseCLues", "outputRines", "outputBlelines", "outputSlelines", "outputCLelines", "OutputBlines", "OutputLine", "outputBline", "outputCLines", "outputRlines", "outputSine", "outputVlines", "OutputBllines", "OutputLlines", "OutputLizes", "outputLineine", "outputBlues", "writeLine", "outputLlines", "responseLines", "outputTlines", "outputSlines", "responseCLlines", "writeTines", "responseCLines", "outputLizes", "writeTine", "outputRine", "outputLelines"]}}
{"code": " \n  \n  \n  def next_range(stream):\n      line = stream.readline()\n      if not line:\n          return None\n      return [int(x) for x in line.split()]\n  \n  \n  def is_palindrome(n):\n      n = str(n)\n      return all(n[i] == n[len(n)-1-i] for i in range(len(n) // 2))\n  \n  def mysqrt(n):\n      \"\"\"Return -1 if not an integer\"\"\"\n      rt = int(sqrt(n))\n      return rt if rt * rt == n else -1\n  \n  \n  def is_fas(n):\n      rt = mysqrt(n)\n      return rt != -1 and is_palindrome(n) and is_palindrome(rt)\n  \n  \n  def main():\n      with open('C-small-attempt0.in', encoding='utf-8') as f:\n          f.readline()\n  \n          for case in count(1):\n              r = next_range(f)\n              if r is None:\n                  break\n  \n              cnt = 0\n              for n in range(r[0], r[1] + 1):\n                  if is_fas(n):\n                      cnt += 1\n  \n              print('Case #{}: {}'.format(case, cnt))\n  \n  \n  main()\n", "substitutes": {"stream": ["log", "reader", "feed", "iter", "u", "path", "sw", "input", "range", "loop", "draft", "fd", "object", "source", "raw", "frame", "function", "fl", "document", "m", "host", "file", "form", "fr", "until", "row", "cont", "flo", "io", "length", "fold", " f", "e", "filter", "channel", "h", "Stream", "enc", "f", "q"], "line": ["LINE", "log", "lo", "l", "co", "cell", "text", "link", "lines", "page", "obj", "reader", "inline", "feed", "out", "comment", "range", "shell", "header", "data", "object", "source", "live", "ne", "frame", "ln", "name", "sync", "content", "buffer", "id", "entry", "le", "file", "fr", "block", "lined", "cl", "response", "val"], "x": ["xb", "ex", "l", "z", "key", "t", "max", "u", "out", "dx", "xe", "xxx", "xx", "v", "bit", "ux", "cross", "xf", "xy", "int", "xi", "sex", "name", "xc", "k", "xxxx", "d", "id", "p", "na", "rx", "val", "num", "xt", "ix", "e", "xs", "y", "f", "X"], "n": ["l", "t", "b", "all", "ne", "int", "ln", "name", "nor", "nr", "nin", "o", "nb", "nc", "nn", "y", "c", "g", "nd", "j", "out", "nw", "np", "m", "ns", "ni", "an", "no", "cn", "en", "a", "number", "network", "w", "ng", "nu", "nt", "nan", "br", "pn"], "i": ["ai", "l", "ip", "j", "ij", "chi", "z", "eni", "u", "ti", "t", "ri", "loc", "col", "I", "b", "v", "bit", "qi", "ui", "ih", "ori", "phi", "int", "xi", "k", "bi", "li", "d", "pos", "p", "id", "m", "iu", "ni", "pi", "mi", "di", "o", "io"], "rt": ["art", "t", "right", "lt", "pr", "ot", "dr", "NT", "int", "rit", "nr", " ret", "fort", "rx", "val", "ct", "lat", "pt", "T", "rr", "ut", "nd", "vr", "root", "ht", "tri", "mt", "out", "adr", "ri", "rd", "ret", "frac", "err", "apt", "ac", "bt", "no", "ft", "at"], "case": ["exc", "section", "Case", "sea", "error", "rand", "ce", "loc", "key", "rest", "core", "rice", "mode", "range", "b", "count", "trial", "change", "ase", "chance", "se", "type", "name", "ch", "ace", "id", "p", "m", "time", "position", "num", "match", "row", "race", "length", "cases", "rule", "result", "bug", "e"], "r": ["rl", "l", "ir", "j", "rf", "null", "t", "rb", "u", "error", "run", "right", "hr", "adr", "range", "b", "pr", "v", "pair", "chain", "rg", "rar", "nor", "k", "nr", "d", "ro", "p", "re", "m", "cr", "lr", "fr", "iter", "runner", "err", "er", "num", "res", "response"], "cnt": ["ncnt", "uncret", "cno", "lcNT", "ncct", "encant", "Cno", "ecannot", "encnt", " cct", "ecnt", " cnn", "uncnn", "ncannot", " cno", " cret", "cant", " cNT", "encNT", "Cnt", "uncnt", "cret", " cant", "CNT", "lcnt", " cnd", "lcret", "cannot", "cnn", " cannot", "Cant", "cnd", "ncnd", "ecct", "uncNT", "lcnn", "encno", "cNT", "cct", "ecnd"]}}
{"code": " \n  \n  def best(total):\n      \"\"\"Return the best possible score for the given `total`.  Assume\n      the total is computed by summing exactly three scores (each in the\n      interval of 0 to 10 inclusive) and no score can be 2 points apart\n      \n      Arguments:\n      - `total`:\n      \"\"\"\n      m = total % 3\n      if m == 2:\n          b = total // 3 + 2\n      else:\n          b = total // 3 + 1\n      if b > 10:\n          b = 10\n      return b\n  \n  def best_non_surprising(total):\n      \"\"\"Return the best possible score for the given `total`, but\n      assume that there should be no more than 1 point difference\n      between the scores.\n  \n      Arguments:\n      - `total`:\n      \"\"\"\n      if total % 3 == 0:\n          return total // 3\n      else:\n          return total // 3 + 1\n  \n  def max_num_gte_p(totals, S, p):\n      \"\"\"Return the maximum number of Googlers that could have had a\n      best result of at least p.\n      \n      Arguments:\n      - `totals`:\n      - `S`: number of surprising triplets of scores\n      - `p`:\n      \"\"\"\n      res = 0\n      for total in totals:\n          if total == 0:\n              if p == 0:\n                  res += 1\n              continue\n  \n          if best_non_surprising(total) >= p:\n              res += 1\n          elif S > 0 and best(total) >= p:\n              res += 1\n              S -= 1\n  \n      return res\n  \n  def main():\n      with open(sys.argv[1], 'r') as f:\n          f.readline()            # skip T\n  \n          n = 0\n          for line in f:\n              n += 1\n  \n              line = [int(s) for s in line.split()]\n              N = line[0]\n              S = line[1]\n              p = line[2]\n              totals = line[3:]\n  \n              print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"total": ["otal", "t", "i", "largest", "scale", "all", "stats", "master", "multi", "good", "mass", "gross", "table", "ta", "mu", "tp", "o", "h", "start", "first", "c", "T", "successful", "root", "quant", "si", "maximum", "min", "size", "complete", "valid", "r", "percent", "mon", "data", "less", "partial", "average", "ret", "local"], "m": ["l", "mm", "j", "mt", "mas", "t", "i", "mean", "u", "mad", "mr", "am", "ms", "r", "md", "v", "mp", "M", "all", "tm", "om", "cm", "d", "um", "mc", "x", "num", "mi", "mb", "mu", "fm", "o", "ym", "e", "machine", "h", "y", "a", "f", "mult"], "b": ["l", "j", "ab", "z", "bl", "ib", "t", "i", "rb", "u", "bb", "null", "r", "v", "wb", "count", "all", "it", "fb", "k", "part", "bi", "d", "be", "bf", "bc", "bs", "ob", "x", "val", "num", "mb", "o", "sb", "lb", "nb", "e", "base", "ed", "bt"], "totals": ["totsials", "pottales", "tfatials", "totall", "toballs", "tOTalls", "pottalities", "pottalls", "potales", "tottalities", "totsals", "ntotall", "ntotials", "tfatales", "pottals", "tfatalities", "tottALS", "Totsals", "totsall", "tottials", "potals", "tobalities", "ntotals", "ntottals", "tiotales", "Totsalls", "totsales", "tottales", "tottals", "tOTales", "ntotalls", "tobals", "ntotsall", "tiotials", "tottall", "ntotsals", "Totalls", "totalls", "TotsALS", "tiotals"], "S": ["Q", "J", "State", "D", "Sign", "Ps", "o", "GS", "SE", "Ns", "Results", "SL", "Sn", "L", "Y", "T", "g", "ST", "SS", "strings", "RS", "si", "size", "sets", "Sample", "H", "M", "SU", "se", "SN", "U", "local", "os", "W", "sp", "O", "E", "V", "B", "SI"], "p": ["l", "pp", "t", "i", "pr", "op", "press", "all", "tp", "o", "proc", "ap", "h", "y", "start", "pt", "c", "g", "fp", "pa", "j", "per", "py", "lp", "r", "python", "order", "np", "limit", "par", "pid", "x", "sp", "a", "w", "api", "pn", "u", "cp", "pair"], "res": ["exp", "es", "j", "z", "sys", "obj", "sol", "final", "out", "max", "nos", "ms", "pres", "r", "req", "gr", "next", "all", "net", "back", "part", "good", "re", "resp", "rss", "RES", "ret", "err", "ns", "x", "val", "details", "response", "rec", "rev", "sr", "reset", "prev", "runs", "Res"], "n": ["l", "j", "z", "size", "t", "i", "u", "max", "r", "v", "nu", "count", "net", "ne", "ln", "name", "k", "nr", "d", "pos", "ns", "x", "num", "o", "nb", "e", "nc", "nn", "len", "y", "a", "f", "sn", "nit", "c", "number", "g", "w", "nt"], "line": ["co", "l", "inline", "key", "i", "int", "ne", "frame", "ln", "name", "file", "cl", "point", "o", "rule", "lf", "start", "cle", "string", "c", "column", "LINE", "log", "section", "lo", "le", "lines", "obj", "case", "out", "r", "data", "group", "se", "item", "sync", "do", "et", "entry", "time"], "s": ["opt", "l", "sq", "sec", "size", "sys", "lines", "sol", "unit", "t", "u", "i", "ss", "r", "ses", "su", "se", "stats", "ln", "name", "d", "pos", "site", "ns", "num", "str", "o", "sr", "os", "nb", "rows", "spec", "e", "ps", "ws", "sp", "sample", "ls", "h", "y"], "N": ["P", "Q", "Z", "D", " Ne", "I", "M", "ne", "SN", "NR", "ns", "NL", "G", "ni", "num", "Ni", "nb", "Ns", "W", "O", "Num", "Sn", "C", "V", "L", "Y", "K", "T", "B", "F", "NS", "R"]}}
{"code": " \n  def read(f):\n      return list( int(v) for v in f.readline().split() )\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def testcases(f):\n      T = int(f.readline())\n      for X in range(1, T + 1):\n          A, B = read(f)\n          yield X, A, B\n  \n  def ispalindrome(v):\n      s = str(v)\n      for i in range(len(s) // 2):\n          if s[i] != s[-i-1]:\n              return False\n      return True\n  \n  def main(inf, outf):\n      MAX = 1000\n      fslst = []\n      for i in itertools.count():\n          if ispalindrome(i):\n              squere = i * i\n              print(MAX, squere, ispalindrome(squere))\n              if squere > MAX:\n                  break\n              if ispalindrome(squere):\n                  fslst.append(squere)\n      for X, A, B in testcases(inf):\n          cnt = 0\n          for fs in fslst:\n              if A <= fs <= B:\n                  cnt += 1\n          answer(outf, X, cnt)\n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n", "substitutes": {"f": ["l", "fun", "uf", "fore", "t", "feed", "fi", "b", "stream", "fen", "fc", "frame", "function", "file", "handler", "fr", "fac", "o", "io", "lf", "conf", "h", "fw", "af", "fed", "c", "fp", "g", "fo", "log", "df", "r", "sf", "fe", "func", "bf", "m", "x", "buff", "a"], "v": ["l", "nv", "j", "vd", "z", "u", "t", "iv", "va", "ov", "n", "r", "b", "value", "vin", "ve", "ev", "all", "int", "sv", "uv", "k", "lv", "d", "p", "m", "x", "val", "U", "pi", "vp", "o", "vt", "vid", "vs", "vu", "e", "h", "av", "y"], "X": ["Q", "J", "D", "Code", "OX", "XL", "int", "XM", "IX", "xs", "UX", "L", "c", "Y", "XXX", "Index", "In", "XX", "H", "M", "x", "U", "AW", "WR", "Cy", "W", "Tx", "O", "E", "XP", "V", "XT", " x", "CE", "R", "Case", "Col", "Out", "Z", "I"], "ans": ["can", "ANN", "Na", "As", "AU", "aning", " Ans", "cas", "cons", "Ann", "ann", "Anne", "anan", "anon", "aus", "AN", "NA", "annels", "ase", "ays", "Ab", "scan", "ats", "man", "ants", "ana", "ns", "fan", "chan", "ANS", "ani", "Args", "Scan", "ases", "aff", "an", "lan", "ars", "ain", "CNN"], "out": ["log", "IN", "exp", "text", "Out", "external", "obj", "new", "key", "error", "Output", "comment", "written", "n", "flat", "call", "data", "header", "password", "msg", "trial", "array", "conn", "all", "expression", "int", "init", "bin", "default", "write", "sync", "name", "again", "wx", "outs", "err", "block", "plain", "clean", "str"], "T": ["Q", "P", "DT", "TS", "Z", "D", "Ti", "TH", "t", "H", "I", "TX", "TR", "M", "NT", "TC", "Max", "TF", "WT", "Time", "TA", "G", "U", "N", "TN", "W", "O", "Total", "E", "C", "Length", "S", "V", "L", "TB", "TT", "Y", "K", "PT", "F"], "A": ["AR", "P", "Q", "Case", "Ac", "Ca", "Na", "As", "API", "D", "AU", "AA", "Ma", "LA", "Az", "H", "I", "AB", " a", "Data", "M", "NA", "AN", "AM", "GA", "Ab", "AP", "Am", "HA", "RA", "SA", "Ant", "Australia", "Ha", "G", "U", "N", "AW", "AI", "And"], "B": ["P", "Q", "J", "WB", "QB", "DB", "Z", " b", "D", "GB", "Bur", "UB", "AB", "I", "Other", "b", "BF", "H", "BW", "M", "LB", "VB", "Ab", "PB", "SB", "NB", "BL", "Bs", "BBC", "G", "U", "N", "BER", "Blue", "BC", "BB", "CB", "BE", "FF", "BS"], "s": ["l", "es", "lines", "u", "t", "ins", "sets", "ss", "sup", "n", "ses", "b", "r", "su", "ks", "ves", "cs", "se", "hs", "sv", "parts", "k", "ds", "d", "p", "ys", "m", "sg", "ns", "abs", "x", "south", "str", "o", "ances", "os", "vs", "e", "ps", "ws"], "i": ["l", "iw", "t", "ti", "b", "ih", "qi", "phi", "uri", "int", "init", "ei", "id", "line", "o", "io", "h", "y", "start", "c", "g", "ini", "ci", "si", "j", "size", "eni", "iter", "ri", "im", "r", "xi", "limit", "m", "x", "ni", "ix", "sp", "ice", "a"], "inf": ["pl", "pp", "ref", "fit", "fi", "input", "qq", "lab", "fen", "init", "int", "fr", "cl", "cgi", "fin", "inc", "conf", "af", "c", "instance", "ini", "www", "log", "image", "obj", "imag", "iter", "sf", "inn", "inst", "fe", "txt", "ipl", "frac", "inner", "binary", "nz", "gi", "inter", "exp"], "outf": ["outb", "inF", "upF", "offfe", "offc", " outfile", "OUTl", "OUTf", "outputf", "outputfile", "outfe", "Outf", "Outb", "offb", "offf", "Outfs", "infs", "upc", "offl", "Outc", "outputfs", "outl", "outfile", "Outfile", " outl", "offfile", "OUTfile", "inc", "Outfe", "outfs", "outc", "upf", "infile", "OUTfe", "outF", " outF", " outb", " outc", " outfe", "upfile"], "MAX": ["LINE", "P", "Q", "maximum", "IN", "RAW", "ALL", "END", "Size", "NULL", "RE", "max", "HEAD", "I", "SIZE", "EXT", "IP", "FAULT", "NUM", "MIN", "chain", "GEN", "WORK", "NG", "Max", "ID", "INFO", "ION", "Array", "VALUE", "MOD", "U", "FILE", "N", "VERSION", "CR", "INT", "PATH", "WARN", "IX"], "fslst": ["sfslsts", "fSlst", "sfsnst", "sfslst", "sfslist", "vslst", "fslsts", "fsnst", "flst", " fSlsts", "fslest", "fSLsts", " fslest", "vslST", "vSLsts", "flST", "fSLest", "vSLST", "fslST", "fsnist", "sfslST", "vSLst", "flest", "vSLest", "fSlST", "fSlsts", "vslsts", "fSLST", "fflst", " fslST", "flsts", "fsnsts", "sfsnsts", "fSlest", "fsslst", " fslsts", "fsslsts", "fslist", " fSlest", " fSlst"], "squere": ["quere", " queb", "sqiere", " squeb", " squeren", " squiere", "Squire", " querer", "Squier", "iquere", "Squerer", "quire", "squ\u00e8re", " squier", "sufferer", "Squester", "squester", "queret", " quere", "Squiere", " squire", " squerer", "sqeret", "squeb", "squire", " squ\u00e8re", "iquerer", "squeret", " queren", "queb", "suffier", "iqu\u00e8re", "squiere", " quire", "squerer", "quier", "qu\u00e8re", "sq\u00e8re", " squeret", "sqere"], "cnt": ["Cct", "scnt", "scount", "count", " count", " crt", " cct", " cnn", "ccount", "Cnn", "conNT", "connd", "concount", " cNT", "Cnt", " ccount", "connt", "CNT", "scct", " cnd", "crt", "cnn", "conrt", "cnd", "Count", "Cnd", "scNT", "cNT", "cct", "Ccount", "Crt", "connn"], "fs": ["omp", "As", "Fs", "args", "feed", "df", "GB", "AA", "ss", "File", "ms", "AB", "BF", "fd", "FA", "full", "Base", "fe", "free", "cs", "ids", "Va", "fc", "Ab", "fb", "ums", "CF", "alls", "Fa", "Alpha", "This", "bf", "ABC", "bc", "bs", "Array", "ns", "ef", "x", "U"], "infname": ["Infname", "initname", "infame", "infpath", " infnam", "inibase", "Infpath", "InfName", "Infnam", "ifnames", "affName", "Infnames", " infnames", "initame", "ifpath", "infnames", "infName", "Infnamed", "Inffilename", "ininame", "affnam", "infnam", "infnamed", "iniName", "Infame", "ifname", " infame", "infbase", "initfilename", "ifnamed", " infnamed", "affname", "initnam", "affbase", "inffilename", " inffilename", "Infbase", "ininam", " infpath"], "outfname": ["wsfword", "outFnam", "outFName", "outlfsize", "outsfName", "wsfnam", "wfname", "outlword", " outFsize", "outlName", "outfbname", "outfilename", " outfsize", " outFname", "outlfname", "outfword", "outfilesize", "wsfname", "wfName", "outfbword", "outlnam", "outfbnam", "wfnam", "wsfName", "outFname", " outFnam", "outfilenam", "outlname", " outfnam", "wfword", "outfileName", " outfName", "outfnam", "outfbName", " outFName", "outsfnam", "outfsize", "outFsize", "outlfnam", "outsfword"]}}
{"code": " \n  def testcases():\n      with open(sys.argv[1], \"r\") as f:\n          f.readline()  # skip number of testcases\n          for X, T in enumerate(f, 1):\n              yield X, [int(t) for t in T.split()]\n  \n  def main():\n      for X, T in testcases():\n          N = T[0]   # the number of Googlers\n          S = T[1]   # the number of surprising triplets of scores\n          p = T[2]   # best result of at least\n  \n          y = 0\n  \n          for t in T[3:]:\n              d, m = divmod(t, 3)\n              if m == 0:\n                  if p <= d:\n                      y += 1\n                  elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:\n                      y += 1\n                      S -= 1\n              elif m == 1:\n                  if p <= d + 1:\n                      y += 1\n              else:\n                  if p <= d + 1:\n                      y += 1\n                  elif p <= d + 2 and S:\n                      y += 1\n                      S -= 1\n  \n          print(\"Case #{:d}: {:d}\".format(X, y))\n  \n  if __name__==\"__main__\":\n      main()\n", "substitutes": {"X": ["Q", "P", "J", "z", "Z", "D", "Day", "Code", "File", "H", "I", "Work", "Node", "IP", "Data", "Val", "TX", "M", "XL", "A", "XY", "Event", "Test", "RH", "ID", "Xi", "Time", "Do", "Array", "G", "x", "U", "PC", "PE", "Text", "FF", "Path", "Tx", "W", "DD"], "T": ["P", "Q", "Case", "DT", "TS", "As", "Z", "D", "TH", "Not", "Ti", "Tr", "GT", "H", "n", "XT", "I", "MT", "M", "A", "NT", "Test", "Ep", "ET", "Ts", "TG", "Tw", "Unt", "TF", "The", "WT", "Time", "Do", "G", "x", "U", "TN", "Table", "Tu", "Unit"], "t": ["opt", "l", "unt", " mt", "j", "z", "D", "art", "i", "u", "out", "ti", "ont", "n", "r", "b", "s", "v", "gt", "tt", "ot", "python", "M", "all", "put", "it", "int", "type", "tf", "k", "tm", "et", "td", "ret", "x", "tz", "tp", "xt", "ta", "o"], "N": ["P", "Q", "j", "z", "Z", "D", "H", "n", "I", "M", "A", "NT", "np", "pos", "ns", "G", "num", "o", " n", "Ns", "W", " P", "O", "E", "C", "V", "L", "c", "K", "Y", "g", "B", "w", "F", "Num", "R"], "S": ["Q", "D", "Ps", "YY", "Ds", "Socket", "AS", "SD", "o", "SE", "YS", "St", "Ns", "US", "L", "Y", "g", "ST", "SS", "DS", "H", "M", "SU", "x", "U", "WS", "W", "sp", "E", "V", "B", "w", "SI", "R", "TS", "Z", "u", "s", "SO", "A"], "p": ["P", "l", "lp", "ip", "j", "z", "pp", "py", "i", "u", "pn", "n", "r", "b", "s", "v", "pr", "cp", "ot", "op", "pm", "np", "k", "dp", "pos", "power", "x", "pi", "tp", "bp", "o", "pc", "ap", "e", "ps", " P", "sp", "pre", "h", "start"], "y": ["l", "i", "b", "phi", "id", " py", "ym", "o", "h", "c", "Y", " ya", "g", "si", "j", "yy", "py", "yo", "r", "np", "xy", "ies", "xi", "vy", "x", "my", "yr", "ya", "zy", "sp", " yo", "iy", "a", "year", " variable", " x", "iny", "w", " Y", "u"], "d": ["P", "l", "ld", "dc", "j", "z", "D", "u", "i", "dx", "n", "r", "b", "s", "v", "fd", "cd", "did", "dl", "dat", "do", "k", "ds", "td", "id", "dn", "x", "di", "o", "mod", "dom", "da", "e", "depth", "h", "div", "ad", "diff", "pd", "a"], "m": ["l", "sm", "mm", "j", "mt", "z", "i", "u", "mn", "ms", "n", "r", "b", "s", "v", "md", "pm", "alm", "M", "em", "k", "tm", "om", "cm", "mp", "mc", "x", "mi", "ym", "fm", "o", "ap", "e", "hm", "im", "an", "h", "a", "f", "rm"]}}
{"code": " \n  def pal(s):\n      for i in xrange(len(s)/2):\n          if s[i] != s[-i-1]:\n              return False\n      return True\n  \n  def pal2(x, s):\n      return pal(s) and pal(str(x*x))\n  \n  def E(k):\n      return 10**k\n  \n  \n  def CREATE_DATABASE(MAX):\n      def init():\n          yield 1\n          yield 2\n          yield 3\n          yield 11\n          yield 22\n          for i in xrange(1, MAX):\n              yield 1*E(2*i) + 1\n              yield 1*E(2*i+1) + 1\n              yield 2*E(2*i) + 2\n              yield 2*E(2*i) + 2 + 1*E(i)\n              yield 2*E(2*i+1) + 2\n              \n              \n      heap = list(sorted(set(init())))\n      for i in heap:\n          print i\n      heapq.heapify(heap)\n      RES = []\n      try:\n          MAX_X = E(MAX)\n          print \"MAX_X\", MAX_X\n          while True:\n              x = heapq.heappop(heap)\n              RES.append(x)\n              if x == 3:\n                  continue\n              if x > MAX_X:\n                  break\n              s = str(x)\n              j = len(s) / 2\n              shift = 1 if len(s) == 2*j else 0\n              for i in xrange(j+1, MAX):\n                  n = E(2*i-shift) + 1 + E(i-j) * x\n                  if pal2(n,str(n)):\n                      heapq.heappush(heap, n)\n                  \n      except KeyboardInterrupt:\n          print \"stopped while x is\", x\n      with open(\"c.database\", 'w') as f:\n          for i in sorted(RES + heap):\n              f.write(\"%i\n\"%i)\n  \n  def READ_DATABASE():\n      with open(\"c.database\", 'r') as f:\n          return sorted(map(lambda x: int(x.strip())**2, f))\n  DB = READ_DATABASE()\n  \n  def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def nrints(N): return [rints() for i in xrange(N)]\n      A, B = rints()\n      i = bisect_left(DB, A) \n      j = bisect_right(DB, B)\n      return j-i\n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write(\"Case #%i: %s\n\" % (i, CASE(IN)))\n  \n  if __name__ == \"__main__\":\n      RUN(sys.stdin, sys.stdout)\n", "substitutes": {"s": ["l", "aces", "ices", "b", "sh", "o", "ances", " S", "xs", "h", "y", "string", "c", "g", "sb", "resses", "strings", "si", "lines", "sets", "ses", "sf", "r", "js", "less", "hours", "ies", "sync", "qs", "m", "bs", "ns", "details", "its", "os", "ops", "sis", "ls", "a", "ssl"], "i": ["l", "IO", "J", "iw", "ti", " I", "fi", "ih", "b", "qi", "phi", "uri", "int", "init", "multi", "ei", "id", "o", "io", "iq", "h", "y", "string", "c", "g", "ini", "ci", "si", "ij", "eni", "ri", "im", "r", "xi", "bi", "m", "go", "ni", "my", "ix"], "x": ["l", "ex", "key", "xd", "input", "b", "xx", "press", "int", "sex", "function", "re", "file", "rx", "val", "cl", "o", "tx", "test", "you", "xs", "h", "y", "stop", "c", "Y", "g", "px", "size", "out", "r", "value", "print", "data", "cross", "xy", "xi", "xxxx", "ww", "m"], "k": ["Q", "l", "kk", "z", "keys", "key", "u", "ki", "max", "ke", "ks", "r", "b", "v", "ko", "ik", "ch", "d", "p", "m", "sh", "o", "ac", "e", "h", "y", "km", "f", "ck", "q", "sk", "c", "K", "g", "w", "KE", "kw"], "MAX": ["Q", "ALL", "D", "DIR", "MIN", "IL", "NG", "ION", "ER", "HE", "CR", "IX", "FREE", "NAME", "FORM", "EST", "EX", "IM", "Y", "T", "XX", "LINE", "maximum", "size", "DC", "H", "SIZE", "DI", "M", "Max", "limit", "JR", "U", "FILE", "WR", "W", "XP", "V", "X", "NER"], "heap": [" heaper", "seap", "seaps", "seaper", "HEamp", "heapy", "Heape", "sheape", "cheap", "cheamp", " heamp", "seamp", "Heaps", "HEap", "heaps", "cheaper", "sheAP", "Heap", "heamp", "peap", "HeAP", "peAP", "peape", "sheap", "heaper", "weap", "peamp", "Heaper", "sheaper", "cheape", " heapy", " heaps", "weamp", "sheaps", "sheamp", "weaps", "HEaper", "peaper", "cheaps", "weaper"], "RES": ["Q", "RAW", "P", "VAL", "RESULTS", "RE", "URN", "GB", "REM", "Rs", "VER", "DATA", "REC", "OR", "ARS", "GR", "NG", "ES", "FS", "STR", "SR", "Response", "Resources", "RED", "MS", "ER", "REP", "G", "ALS", "GET", "res", "WER", "CR", "FILE", "GS", "BER", "WS", "SE", "PATH", "WR"], "MAX_X": ["MAXNX", " MAX_XP", "MAXNIX", "MAXIDY", "MAX_XP", "RAW_XX", "MAXNXX", "MAXIDX", "MAXADY", "MaxIDEX", " MAX_IX", "RAW_IX", "MAXJX", "RAW_XP", "Max_XX", "MAXJEX", "MAX64Y", "MAX64IX", "MAXJY", "MAXADEX", "RAW_X", "MAX_XX", "MAX64X", "MaxIDXX", "MAX_EX", "Max_X", "Max_EX", " MAX_Y", "MAX_Y", "MaxIDX", "MAX_IX", "MAXNXP", "MAX64XX", "MAXADX", "MaxIDY", "MAXIDEX", "Max_Y", "MAXIDXX", "MAXJXX", "MAX64XP"], "j": ["note", "J", "l", "uj", "adj", "ji", "z", "ij", "size", "jl", "max", "sup", "r", "b", "I", "js", "qi", "v", "left", "jp", "ne", "li", "ch", "d", "part", "p", "m", "sh", "dj", "jj", "o", "ix", "offset", "e", "h", "y", "start", "a", "f", "q"], "shift": ["small", "J", "exp", "ff", "size", "z", "case", "max", "right", "set", "shr", "sup", "I", "count", "sleep", "value", "qi", "pop", "scale", "left", "jp", "init", "Shift", "ch", " shifts", "pos", "p", "mass", "seed", "ctr", "sh", "hift", "power", "index", "field", "gap", "ix", "offset", "cube", "end"], "n": ["l", "adj", "z", "size", "nan", "pn", "max", "mn", "b", "v", "node", "nw", "np", "net", "ne", "int", "init", "name", "nor", "nr", "d", "p", "m", "na", "dn", "nin", "ns", "ni", "num", "o", "rn", "nb", "e", "Ns", "nt", "nc", "nn", "an", "cn", "nm"], "DB": ["LINE", "IO", "RAW", "D", "database", "DF", "DC", "input", "DI", "DIR", "TYPE", "DATA", "db", "STR", "CF", "BL", "DL", "ID", "MODE", "DEBUG", "ER", "table", "FILE", "TABLE", "CR", "FIX", "CB", "DE", "DD", "SQL", "Db", "MI", "ENG", "CI", "DS", "TEXT"], "IN": ["URL", "PIN", "RAW", "IO", "ALL", "D", "NI", "ins", "out", "HEAD", "input", "DI", "DIR", "EN", "DATA", "AN", "IND", "bin", "IL", "NG", "STR", "READ", "SN", "NN", "INE", "OU", "CL", "BL", "DL", "LIB", "inner", "LIN", "CON", "CR", "URI", "BC", "IC", "INS", "IR", "SQL"]}}
{"code": " \n  \n  \n  D1 = {} # no suprize\n  D2 = {} # surprize\n  for i in xrange(0, 31):\n      D1[i] = D2[i] = -1\n  \n  def precompute():\n      for a in xrange(0, 11):\n          for b in xrange(a, min(a+3,11)):\n              for c in xrange(b, min(a+3,11)):\n                  t = a+b+c\n                  assert a <= b <= c <= a+2 and c <= 11\n                  if c < a+2:\n                      D1[t] = max(D1[t], c)\n                  else: # that is, c == a+2, we have a suprize\n                      D2[t] = max(D2[t], c)\n  \n  \n  precompute()\n  \n  def case(S, P, ts):\n      res_n = 0\n      res_s = 0\n      for t in ts:\n          if D1[t] >= P:\n              res_n+=1\n          elif D2[t]>=P:\n              res_s+=1\n      return (res_n + min(res_s, S))\n  \n  \n  def solve(fin, fout):\n      T = int(fin.readline())\n      for t in xrange(T):\n          nums = map(int, fin.readline().strip().split(\" \"))\n          N, S, P = nums[:3]\n          ts = nums[3:]\n          assert len(ts) == N    \n          fout.write(\"Case #%i: %i\n\" % (t+1, case(S,P,ts)) )\n      return True\n  \n  if __name__ == \"__main__\":\n      with open(sys.argv[1],'r') as fin:\n          with open(sys.argv[2], 'w') as fout:\n              solve(fin, fout)\n", "substitutes": {"D1": [" DONE", "D3", "Do11", "DSb", "d0", " D0", "FD2", "Do2", "DS2", " D4", "Do1", "Fb", "d1", "d3", " DOne", "dONE", "db", "D0", "d11", " Db", " D9", " D3", "DS1", "T1", "D9", "F1", "T9", "Cb", "FDb", "DOne", "C1", "dOne", "F0", "T3", "DONE", "C2", "F2", " D11", "C4", "TONE"], "D2": ["d8", "D3", "DB", "d0", "S3", "R1", "DTwo", " D0", "d52", "D8", "d1", "dB", "DD2", "d3", "Dtwo", "R2", "db", "D0", " Db", " DTwo", "MD1", " D3", "MDb", "STwo", "DD1", "LD0", "LD52", "DDB", "D52", " DB", "MDB", "LD2", "RTwo", "Db", "d2", "DD8", " D52", "S2", "S1", "MD2"], "i": ["ai", "l", "ip", "ir", "j", "z", "arc", "ib", "ti", "u", "I", "im", "n", "v", "ui", "qi", "ic", "yi", "phi", "it", "int", "xi", "ie", "aci", "bi", "k", "li", "ei", "d", "id", "p", "multi", "m", "iu", "x", "pi", "ni", "mi", "di", "o"], "a": ["aa", "ai", "l", "sta", "ab", "z", "alpha", "art", "u", "api", "ada", "am", "oa", "n", "r", "ba", "s", "au", "data", "A", "sa", "array", "asa", "k", "area", "aw", "d", "p", "ae", "m", "ga", "pa", "ax", "x", "ta", "o", "ac", "da", "ap", "ah"], "b": ["aa", "l", "ai", "j", "ab", "z", "abb", "u", "bb", "rb", "n", "r", "ba", "v", "s", "A", "fb", "k", "bi", "d", "p", "bf", "m", "be", "ae", "bc", "bs", "cat", "x", "cy", "o", "ac", "ap", "e", "base", "bt", "ca", "h", "ad", "an"], "c": ["l", "dc", "z", "u", "cc", "ce", "max", "cin", "cu", "n", "r", "cd", "cp", "v", "s", "ic", "unc", "cs", "fc", "cent", "ec", "xc", "ch", "k", "cm", "d", "p", "ae", "cr", "m", "bc", "x", "cy", "ta", "o", "ct", "ac", "pc", "e", "cb"], "t": ["l", "unt", "tc", "art", "ti", "lt", "ot", "int", "rt", "id", "ta", "tp", "o", "ct", "h", "y", "start", "pt", "tmp", "g", "ut", "tip", "j", "out", "set", "r", "qt", "m", "time", "x", "token", "ac", "ft", "tim", "at", "w", "st", "off", "nt", "u"], "S": ["Q", "TS", "D", "ss", "H", "I", "n", "Su", "s", "M", "SO", "SU", "A", "Single", "SN", "SA", "SK", "SH", "AS", "G", "U", " s", "Sa", "SE", "CS", "Ns", "W", "US", "O", "SL", "E", "Sn", "SP", "SC", "C", "OS", "V", "Si", "L", "X"], "P": ["Q", "PIN", "WP", "D", "TP", "Ps", " p", "H", "I", "IP", "PO", "M", "PU", "PD", "A", "Po", "AP", "PB", "PR", "NP", "PK", "DP", "p", "PA", "G", "U", "PE", "PI", "FP", "Py", "Pa", "RP", "PF", "JP", "PP", "PN", "YP", "W", "O", "E"], "ts": ["tc", "ations", "TR", "tests", "alls", "Ts", "tes", "td", "uments", "ta", "tp", "steps", "GS", "test", "xs", "ments", "dates", "pt", "vals", "SS", "ents", "lines", "sts", "ims", "Ms", "ids", "frames", " times", "qs", "Time", "time", "tips", "ns", "x", "sequence", "abs", "ls", "points", "Types", "X"], "res_n": ["res_p", "resIds", "resPu", "resPn", "Res_s", "res_i", "res_N", "Res_p", "resESSna", "res__s", "Res_nc", "resIdn", "resIdna", "res__n", "Res_N", "res__u", "resESSnc", "Res_n", "Res_u", "Res_i", "resIdnc", "resPs", "Res_na", "resESSs", "res_u", "res_na", "res_ne", "Res_ne", "res__i", "res_nc", "resESSn", "resPi"], "res_s": ["res_p", "Res_s", "Res_p", "res_ns", " res_c", "res_l", "r_ns", "r_s", " res_p", "Res_ns", "Res_n", "r_c", "r_l", "res_c"], "fin": ["fun", "fit", "fi", "inf", "pen", "fen", "init", "ln", "id", "file", "fr", "fail", "proc", "vert", "rob", "h", "rip", "nir", "inv", "fp", "ini", "kin", "iter", "hr", "r", "inn", "par", "inner", "err", "details", "fish", "os", "spec", "en", "Fin", "done", "fa", "end", "nu", "exp"], "fout": ["cfOut", "fouts", "FOut", "Fpass", " fline", "Foff", "Fline", "fline", " FOut", " Fpass", "cfouts", "flist", "fbout", "fbouts", " fpass", " foff", " flist", "fpout", "fpoff", " Fout", "fOut", "fbin", "fpin", "fpouts", "fblist", "cflist", "fpass", "Fout", "cfout", "Fin", " fouts", "fbline", "fbOut", "Fouts", "foff", " Fin", " fOut"], "T": ["Q", "DT", "TS", "Z", "D", "TH", "Ti", "H", "I", "M", "A", "NT", "Ts", "WT", "TF", "Time", "TA", "G", "U", "TN", "TI", "W", "Times", "O", "C", "Length", "V", "L", "X", "TT", "Y", "K", "B", "CT", "F", "Type", "Num", "R"], "nums": ["uumbers", "cumbers", " num", "Nums", "cum", "Nems", "numeric", "Numer", "nems", "uumeric", "pum", "Numbers", "pumbers", "uums", " numbers", "pums", "numer", "pems", "num", "noms", "uum", " nems", "numbers", "poms", "Numeric", "Noms", "coms", "pumer", "cums", " numer", " numeric", "Num"], "N": ["Q", "J", "Na", "TS", "Z", "D", "null", "max", "H", "n", "I", "M", "NA", "A", "NT", "Len", "NUM", "Nat", "G", "U", "num", "TN", "length", " n", "Ns", "W", "O", "Num", "E", "C", "Length", "V", "L", "X", "number", "Y", "K", "B", "CN", "F"]}}
{"code": " f   = file(sys.argv[1])\n  out = file(sys.argv[2], 'w')\n  \n  caseCnt = int(f.readline())\n  \n  Num = [\n  \t0,\n  \t1,\n  \t4,\n  \t9,\n  \t121,\n  \t484,\n  \t10201,\n  \t12321,\n  \t14641,\n  \t40804,\n  \t44944,\n  \t1002001,\n  \t1234321,\n  \t4008004,\n  \t100020001,\n  \t102030201,\n  \t104060401,\n  \t121242121,\n  \t123454321,\n  \t125686521,\n  \t400080004,\n  \t404090404,\n  \t10000200001,\n  \t10221412201,\n  \t12102420121,\n  \t12345654321,\n  \t40000800004,\n  \t1000002000001,\n  \t1002003002001,\n  \t1004006004001,\n  \t1020304030201,\n  \t1022325232201,\n  \t1024348434201,\n  \t1210024200121,\n  \t1212225222121,\n  \t1214428244121,\n  \t1232346432321,\n  \t1234567654321,\n  \t4000008000004,\n  \t4004009004004,\n  ]\n  \n  for case in range(1, caseCnt+1):\n  \tL, H = f.readline().split()\n  \tL = int(L); H = int(H)\n  \tassert L <= H\n  \t\n  \tfor i in range(len(Num)):\n  \t\tif L <= Num[i]:\n  \t\t\tbreak\n  \telse:\n  \t\tprint>>out, 'Case #%d:'%case, 0\n  \t\tcontinue\n  \n  \tlb = i - 1\n  \n  \tfor i in range(1, len(Num)+1):\n  \t\tif H >= Num[len(Num)-i]:\n  \t\t\tbreak\n  \telse:\n  \t\tprint>>out, 'Case #%d:'%case, 0\n  \t\tcontinue\n  \tub = len(Num)-i\n  \t\t\n  \tprint>>out, 'Case #%d:'%case, ub - lb\n  \n  out.close()\n", "substitutes": {"f": ["log", "l", "rf", "sys", "folder", "z", "obj", "t", "df", "fig", "feed", "u", "n", "fi", "b", "s", "sf", "fd", "r", "v", "input", "inf", "fe", "xf", "fc", "fb", "tf", "d", "p", "m", "file", "form", "fr", "x", "o", "io", "up", "info", "os", "e"], "out": [" output", "ex", "key", "t", "fi", "connection", "static", "int", "dot", "ln", "name", "file", "by", "outs", "point", "option", "o", "action", "io", "line", "fin", "conf", "y", "cmd", "c", "g", "fp", "fo", "log", "obj", "df", "print", "gen", "ret", "err", "x", "base", "cache", "no", "output"], "caseCnt": ["casecst", "CaseCourse", "caseDecNT", "caseCner", " casecNT", "caseNCnt", "caseNCst", "caseNCNT", "caseNCner", "casecner", " casecner", "caseCst", " caseCst", "caseCn", "caseDecnt", "casecNT", "caseCourse", "caseScourse", " casecnt", "caseScNT", " caseCNT", "caseScn", "caseCNT", "CaseCNT", " casecst", " caseCner", "CaseCnt", "caseDecourse", "caseScnt", "caseDecn", "casecnt", "CaseCn"], "Num": ["Code", "Data", "Len", "Int", "Bu", "Fig", "Sim", "Rom", "Tam", "Fun", "Mo", "Dom", "Mu", "Multi", "Math", "Unit", "Dou", "Ul", "Norm", "Db", "Buff", "Tab", "Uh", "Conf", "Pi", "Count", "Index", "Block", "Tan", "Ch", "Na", "Msg", "Info", "Integer", "Tri", "Grid", " num", "M", "Ring", "Time"], "case": ["address", "ce", "path", "b", "ase", "int", "name", "ace", "line", "test", "c", "instance", "section", "shape", "size", "core", "say", "cycle", "chance", "choice", "bi", "time", "x", "sequence", "race", "hyp", "base", "series", "ice", "no", "year", "code", "number", " CASE", "date", "end", "Case", "division", "uc", "slice"], "L": ["TL", "P", "l", "J", " Li", "LC", "LO", "Q", "EL", "Z", "D", "El", "LA", "FL", " l", "I", "M", "LB", "XL", "Len", "IL", "CL", "BL", "DL", "AL", "LL", "NL", "G", "Li", "U", "La", "N", "line", "LU", "LG", "LD", "dL", "W", "LS", "Ul"], "H": ["Q", "P", "HL", "J", "Z", "D", "TH", "CH", "HI", "I", "HS", "HM", " h", "M", "A", "HR", "MH", "Hi", "HB", "IL", "His", "AH", "RH", "HA", "HY", "HH", "DH", "Ha", "SH", "G", "U", "HE", "N", "He", "length", "NH", "GH", "W", "HK", "HP"], "i": ["l", "iw", "ti", "b", "ih", "qi", "phi", "int", "multi", "ei", "id", "list", "o", "io", "iq", "y", "start", "c", "g", "ini", "CI", "ci", "si", "lo", "j", "ri", "r", "xi", "bi", "m", "x", "ni", "idi", "hi", "a", "gi", "index", "cli", "u", "I"], "lb": ["rl", "log", "l", "ai", "Ub", "ld", "abb", "bl", "ib", "rb", "max", "loc", "ctrl", "abc", "hub", "exit", "lp", "b", "lt", "wb", "LB", "lab", "dl", "bh", "HB", "SB", "ln", "li", "lv", "iu", "lr", "lbs", "bp", "abl", "lin", "nb", "Lab", "lf", "cb", "hi"], "ub": ["cur", "ai", "Ub", "ab", "pl", "ib", "ur", "u", "rb", "bb", "ue", "UB", "ubs", "hub", "im", "uy", "b", "uc", "obb", "ug", "LB", "lab", "lam", "HB", "ums", "ch", "uba", "li", "cm", "um", "id", "uper", "eb", "uni", "bc", "ob", "uh", "num", "pub", "up"]}}
{"code": " \n  f = file(\"B-small-attempt0.in\")\n  w = file(\"answer.txt\", \"w\")\n  cnt = int(f.readline()[:-1])\n  for no in range(cnt):\n  \tl = f.readline()[:-1].split()\n  \tT, s, p = map(int, l[:3])\n  \tts = map(int, l[3:])\n  \tns = p*3-2 if p*3-2 > 0 else 0\n  \tss = p*3-4 if p*3-4 > 0 else 31\n  \tl = filter(lambda x: x<ns, ts)\n  \tc = min([len(filter(lambda x: x>=ss, l)), s])\n  \t\n  \tprint>>w, \"Case #%d:\"%(no+1), T-len(l)+c\n  \n  \n", "substitutes": {"f": ["rf", "z", "folder", "t", "df", "feed", "iter", "ref", "i", "n", "sf", "b", "v", "fd", "r", "inf", "found", "full", "fe", "fen", "xf", "fc", "fb", "tf", "d", "body", "m", "file", "arf", "form", "fr", "x", "o", "io", "fold", "e", "lf", "tab", "h", "af"], "w": ["log", "view", "wh", "wa", "hw", "wcs", "wave", "iw", "ow", "t", "window", "wy", "sw", "b", "v", "wb", "wal", "wl", "nw", "wo", "wu", "we", "write", "aw", "wt", "d", "wer", "work", "m", "wx", "kw", "wp", "wan", "wr", "We", "x", "tw", "wi", "ew", "self"], "cnt": ["Cnc", " cnn", "Cnn", "dcnd", "conNT", "cnc", "dcNT", " cNT", "dcnc", "dcnt", "Cnt", "connt", "CNT", " cnc", " cnd", "conannot", "cannot", "cnn", " cannot", "cnd", "Cnd", "cNT", "Cannot", "connn"], "no": ["co", "lo", " ip", "i", "error", "mode", "nos", " nos", "n", "one", " loop", " No", "so", "ino", " NO", "connection", "now", "ko", "toc", "name", "do", "nor", " where", " new", " error", "pos", "part", " ne", "na", "go", "po", " N", "No", "num", "x", "N", " wo", "yes", "o", " z"], "l": ["rl", "log", " L", "lo", "le", "lines", "z", "pl", "t", "i", "u", "iter", "loc", "n", "lp", "b", "v", "r", "lt", "les", "dl", "left", " ls", "ell", "ln", "k", "fl", "li", "d", "al", "m", "file", "list", "x", "lis", "line", "o", "tl", "lin", "la"], "T": ["P", "Q", "TS", "z", "size", "D", "Z", "Size", "t", "H", "I", "v", "M", "A", "Ts", "Time", " C", "G", "No", "U", "pi", "N", "length", "CC", "Ns", "W", " P", "O", "h", "E", "C", "pt", "S", "V", "Length", "L", "X", "TT", "Y", "K"], "s": ["P", "es", "lines", "z", "size", "t", "u", "i", "sets", "n", "r", "b", "v", "ses", "cs", "se", "sv", "ds", "d", "tips", "x", "tp", "its", "o", "os", "e", "spec", "ps", "ws", "sp", "ls", "xs", "sites", "y", "a", "sn", "S", "sc", "q", "g"], "p": ["P", "ip", "j", "z", "per", "pp", "t", "i", "u", "pn", "n", "lp", "b", "v", "r", "pr", "cp", "pe", "np", "int", "k", "pa", "d", "m", "x", "pi", "tp", "bp", "point", "o", "pc", "ap", "e", "ps", " P", "sp", "h", "y", "a", "pt"], "ts": ["es", "TS", "z", "t", "ins", "ms", "ks", "n", "tt", "cs", "ids", "tests", "se", "ats", "aps", "alls", "Ts", "tes", "ds", "qs", "outs", "tips", "als", "x", "tz", "ta", "tp", "times", "steps", "cases", "ets", "types", "posts", "ps", "ws", "xs", "ments", "ls", "sp", "sites"], "ns": ["es", "lines", "z", "ins", "nos", "ims", "eps", "ms", "n", "ks", "cs", "ids", "ne", "ats", "nets", "ds", "ys", "qs", "na", "bs", "ens", "x", "os", "ans", "vs", "Ns", "ps", "ws", "xs", "ls", "names", "sp", "nz", "sites", "y", "sn", "cycles", "points", "ics", "rs"], "ss": ["css", "hess", "es", "z", "t", "ins", "ess", "uss", "n", "r", "ms", "xx", "ses", "sa", " ps", "cs", "sv", "ips", "ds", "ress", "ys", "pos", "tes", "rss", "na", "bs", "x", "tz", "iss", "vs", "ps", "\u00df", "sp", "xs", "ls", "ws", "sd", "nz", "pt", "sc"], "c": ["tc", "dc", "size", "z", "t", "cc", "ce", "i", "u", "max", "cu", "n", "r", "b", "count", "uc", "cs", "unc", "ec", "k", "d", "cz", "cm", "m", "cr", "x", "cy", "o", "ct", "cit", "ac", "pc", "e", "nc", "cn", "y", "len", "Cs", "C", "sc"]}}
{"code": "def check(a,b):\n      c = 0\n      n = 1\n      for i in range(1,4):\n          if i**2 >= a and i**2 <=b:\n              c += 1\n      if 44944 >= a and 44944 <= b:\n          c += 1\n      while n < 10:\n          p1 = int('1'+'1'*n)**2\n          if p1 >= a and p1 <=b:\n              c += 1\n          n += 1\n  \n  \n      if 484 >= a and 484 <= b:\n          c += 1\n  \n      n = 1\n      while True:\n          p2 = int('1'+'0'*n+'1')**2\n          p3 = int('2'+'0'*n+'2')**2\n          if p2 >= a and p2 <= b:\n              c += 1\n          else:\n              break\n          if p3 >= a and p3 <= b:\n              c += 1\n          else:\n              continue\n          n += 1\n  \n      n = 1\n      while True:\n          t = False\n          for m in range(2,5):\n              p4 = int('1'*m+'0'*n+'1'*m)**2\n              if p4 >= a and p4 <= b:\n                  c += 1\n              else:\n                  t = True\n                  break\n          if t:\n              break\n              \n          n += 1\n      return c\n                  \n  dat = raw_input().split()\n  n = int(dat.pop(0))\n  data = [int(e) for e in dat]\n  \n  for i in range(0, n*2, 2):\n      a, b = data[i], data[i+1]\n      print 'Case #%i: '%(i/2+1) + str(check(a,b)) \n  \n      \n", "substitutes": {"a": ["l", "alpha", "art", "am", "au", "access", "sa", "asa", "ha", "all", "aw", "area", "aba", "active", "o", "la", "ap", "ea", "h", "y", "ma", "g", "aa", "wa", "sta", "ab", "j", "valid", "ast", "r", "inst", "array", "ga", "x", "abs", "auto", "ac", "audio", "ya", "da"], "b": ["l", "abb", "rb", "bel", "function", "other", "bis", "o", "nb", "h", "y", "g", "bas", "sb", "root", "j", "ab", "out", "bb", "arb", "r", "orb", "bi", "bf", "bc", "bs", "binary", "x", "abs", "bp", "bu", "hide", "lb", "base", "B", "beta", "w", "http", "bar", "br"], "c": ["co", "l", "tc", "arc", "ce", "loc", "abc", "chain", "all", "ec", "function", "mc", "cl", "line", "o", "cont", "ct", "coll", "nc", "h", "y", "g", "ci", "j", "size", "case", "oc", "core", "r", "cycle", "x", "ac", "cache", "cn", "code", "w", "end", "can", "dc", "u"], "n": ["l", "ot", "all", "ne", "ln", "name", "nor", " N", "o", "nb", "nc", "nn", "y", "ain", "g", "nd", "adj", "j", "size", "out", "iter", "mn", "r", "np", "inner", "ns", "x", "ni", "no", "cn", "nm", "en", "number", "network", "w", "ng", "end", "nt", "nan", "nu"], "i": ["ai", "l", "ip", "j", "adi", "z", "chi", "cli", "eni", "api", "u", "ti", "ri", "key", "I", "im", "v", "count", "qi", "ui", "phi", "it", "int", "xi", "iri", "ie", "bi", "multi", "li", "ei", "d", "id", "p", "k", "iu", "uni", "x", "pi", "ni", "num"], "p1": ["p151", "cpOne", "jpOne", "P151", "jp6", "f3", "cp2", "P2", "api151", "cp1", "p8", " p8", "api1", "cp6", "jp2", "api2", "P3", "api8", "POne", "jp1", "f8", " p151", "P6", "p6", "P8", "P1", "f1", "f2", "pOne"], "p2": ["ip8", "functionsecond", "ipsecond", "P5", "m1", "a2", "ip25", "P2", " psecond", "p8", "P20", " p8", "function25", "ip2", "function2", "p20", "ip20", "a4", "P3", "m3", "p5", "a1", "p25", "ip3", "ip1", "psecond", "function8", " p5", "P4", "P1", "a5", "m20", "m2", " p25"], "p3": [" p123", "ip183", "p03", "fp3", "cp1", "p123", "cp183", "ip03", "P3", " pThree", "fp4", "P123", "pThree", "u3", "P183", "ip3", "cp03", "ip1", "u4", "uThree", "P4", "P1", "cp3", "fp1", "u1", "p183", "P03", "fp123", "PThree"], "t": ["l", "tc", "j", "z", "br", "u", "out", "tan", "r", "s", "v", "never", "ot", "tt", "te", "int", "type", "tf", "wt", "rt", "d", "p", "x", "ta", "tp", "o", "tw", "ant", "tn", "tun", "h", "y", "pt", "f", "tr", "dt", "T", "ut", "g", "at"], "m": ["l", "mm", "month", "j", "z", "u", "am", "mn", "ms", "im", "r", "s", "v", "pm", "M", "k", "multi", "om", "cm", "d", "p", "mc", "x", "pi", "num", "mu", "ym", "mi", "N", "mat", "o", "mod", "nc", "h", "an", "nm", "y", "km", "en", "f"], "p4": ["c4", "password256", "c6", " p256", "password4", "cp4", "p256", "P2", "cp480", "c8", " p6", "P443", "p8", " p8", "tp4", " pfour", "p480", "tp8", "tp443", "np8", " p443", "passwordfour", "tp2", "np5", "cpfour", "c5", "p443", "np6", "password480", " p5", "p6", "P4", "P8", " p480", "np4", "cp256", "pfour", "p5"], "dat": ["sat", "pl", "abc", "input", "Data", "dr", "int", "Dat", "oct", "fr", "list", "lat", "g", "ut", "adj", "obj", "bl", "py", "out", "iter", "valid", "complete", "set", "DATA", "txt", "np", "bi", "ata", "dict", " Dat", "bc", "da", "series", "output", "date", "dc", "db", "batch", "arr", "ds"], "data": ["config", "open", "lines", "z", "new", "database", "zip", "case", "u", "valid", "args", "changes", "xxx", "input", "Data", "DATA", "array", "change", "next", "raw", "days", "frame", "parts", "batch", "content", "arr", "breaks", "ata", "memory", "d", "pos", "p", "dict", "na", "list", "table", "sequence", "x", "pad", "response"], "e": ["l", "een", "es", "j", "ite", "z", "size", "ime", "u", " E", "ue", "r", "me", "de", "pe", "ele", "fe", "ev", "ine", "element", "ne", "oe", "ec", "ie", "ei", "ae", "d", "p", "id", "err", "x", "o", " ie", "ea", "ze", "ed", "ice", "E", "en", "ee"]}}
{"code": "f = open('cj2.in','r')\n  out = open('out1.txt','w')\n  inp = [[int(n) for n in s.split()] for s in f.readlines()]\n  \n  def score_partition(score):\n      poss = []\n      if score == 0:\n          return [[0,0,0]]\n      if score == 1:\n          return [[0,0,1]]\n      if score % 3 == 0:\n          poss.append([score/3,score/3,score/3])\n          poss.append([score/3-1,score/3,score/3+1])\n      if score % 3 == 1:\n          poss.append([score/3, score/3,score/3+1])\n          poss.append([score/3-1,score/3+1,score/3+1])\n      if score % 3 == 2:\n          poss.append([score/3,score/3+1,score/3+1])\n          poss.append([score/3,score/3,score/3+2])\n  \n      return poss\n  \n  \n  s = 0\n  c = 1\n  for e in inp[1:len(inp)]:\n      count = 0\n      surprises = e[1]\n      s = 0\n      p = e[2]\n      for i in e[3:len(e)]:\n          scores = score_partition(i)\n          for j in scores: \n              if max(j) >= p:\n                  if max(j)-min(j) == 2:\n                      if s < surprises:\n                          s +=1\n                          count +=1\n                          break\n                  else:\n                      count += 1\n                      break\n                  \n      out.write('Case #'+str(c)+': '+str(count)+'\n')\n      c += 1\n  \n  out.close()\n  f.close()\n                  \n          \n      \n      \n  \n      \n", "substitutes": {"f": ["l", "fer", "z", "rf", "t", "df", "u", "feed", "ref", "path", "r", "b", "v", "fd", "sf", "fe", "stream", "fen", "fc", "fb", "tf", "fl", "d", "fx", "bf", "m", "file", "form", "fr", "x", "fm", "o", "io", "info", "lf", "h", "a", "q", "ft", "files"], "out": ["log", "ex", "exp", "co", "opt", "l", "Out", "obj", "page", "z", "error", "window", "t", "In", "v", "diff", "op", "object", "raw", "all", "net", "bin", "int", "dot", "ln", "gen", "ch", "part", "parent", "again", "box", "file", "outs", "err", "x", "lock", "point", "line", "o", "io"], "inp": ["Inps", " inv", "InP", "inps", "INe", " inps", "inips", "insh", "inf", "Inp", "INps", "innf", "inne", "incp", "innps", "INf", "innv", " inh", "insi", "iniP", "Incp", " inP", "inh", " ini", "inicp", "inP", "INp", "innp", "insp", " ine", "inv", "innh", " incp", "inip", "insv", "ini", "inni", " inf", "ine"], "n": ["l", "z", "t", "u", "r", "b", "v", "node", "nw", "it", "np", "net", "ne", "all", "name", "k", "nr", "d", "pos", "m", "na", "dn", "ns", "x", "ni", "num", "N", "o", "nb", "nt", "self", "nc", "nn", "no", "h", "nm", "len", "en", "y", "a"], "s": ["l", "t", "b", "all", "stats", "us", "o", "comments", "xs", "ages", "h", "y", "string", "g", "strings", "si", "lines", "sec", "size", "ing", "sets", "core", "ims", "ses", "r", "js", "ids", "se", "np", "ies", "qs", "m", "ns", "x", "abs", "details", "ries", "os", "ops", "sp"], "score": ["color", "key", "mean", "fit", "skill", "scale", "live", "name", "degree", "id", "rank", "seed", "file", "field", "line", "o", "grade", "team", "video", "y", "start", "risk", "feature", "est", "fee", "image", "vec", "size", "case", "complete", "core", "rate", "value", "profile", "order", "chance", "level", "average", "tie", "time"], "poss": ["boss", "toposs", "hosit", "ifower", "apou", "dataoc", " pOSS", "soss", "ploss", "psOSS", "kOSS", "hore", "Pense", "pott", "aposit", "bonse", "pore", "psos", "iour", "hou", "ponse", "fott", "koss", "hoss", "foss", " pore", "bower", "ingenn", "topOSS", "sosit", "pores", " posit", "s6", " pores", "lower", "poc", "lott", "pOSS", "dataores", "Posit"], "c": ["cur", "l", "sec", "z", "size", "dc", "case", "t", "error", "u", "ce", "cc", "col", "cu", "b", "r", "v", "cd", "cor", "call", "chain", "cs", "cycle", "toc", "xc", "k", "ch", "d", "cm", "m", "cr", "time", "mc", "x", "cy", "o", "pc", "cache", "cb", "coll"], "e": ["l", "es", "ite", "z", "case", "t", "ce", "max", "u", "core", "r", "me", "energy", "v", "pe", "de", "b", "ge", "fe", "ele", "ev", "se", "element", "ne", "oe", "ec", "ie", "k", "ei", "d", "ae", "be", "m", "err", "ile", "x", "er", "ef", "je", "line"], "count": ["l", "sec", "z", "size", "case", "t", "error", "max", "cc", "core", "col", "seq", "b", "v", "sleep", "shell", "call", "found", "cs", "total", "child", "k", "ch", "stat", "id", "m", "time", "err", "x", "length", "state", "conf", "cache", "depth", "sp", "coll", "status", "h", "base", "counter"], "surprises": [" surriers", " surprising", "SUriers", " surprise", "surcharges", "surprising", "SUprising", "surprise", "sprises", "SUprise", " surcharges", "Surprising", "Surcharges", "sprising", "Surriers", "Surprises", "SUprises", "scharges", "sprise", "Surprise", "surriers"], "p": ["P", "l", "z", "pp", "py", "t", "u", "pressure", "b", "r", "v", "pr", "cp", "pe", "jp", "np", "ping", "pos", "d", "pid", "m", "x", "pi", "tp", "bp", "point", "o", "up", "pc", "top", "ap", "ps", "sp", "pre", "h", "y", "a", "padding", "q"], "i": ["J", "l", "ip", "z", "chi", "t", "u", "I", "r", "b", "v", "qi", "it", "se", "ne", "int", "xi", "init", "ie", "k", "ch", "li", "ei", "d", "id", "m", "iu", "x", "pi", "o", "io", "iq", "h", "E", "y", "a", "code", "q", "ner", "g"], "scores": ["coates", "coors", "Scores", "scents", "switches", "bcors", "scitches", "sworer", "Scents", "swores", "bcores", "scors", "glors", "scefficients", "studores", "studorer", "glores", "scates", "bcates", "scorer", "glates", "bcefficients", "glefficients", "swents", "students", "coores", "Scorer", "studitches", "Scitches", "coefficients"], "j": ["note", "J", "l", "adj", "ij", "z", "obj", "ji", "size", "jl", "u", "t", "py", "r", "ge", "v", "js", "b", "im", "jp", "ne", "int", "ie", "ch", "k", "li", "pos", "d", "m", "fr", "x", "other", "num", "er", "str", "dj", "row", "o", "aj", "jj"]}}
{"code": " def ispal(num):\n      num = str(num)\n      if num == num[::-1]:\n          return True\n      else:\n          return False\n  \n  def test(bot, top):\n      count = []\n      for i in range(bot,top+1):\n          if not ((int(i**0.5)**2) == i):\n              continue\n          if ispal(i) and ispal(int(i**0.5)):\n              count.append(i)\n      return len(count)\n  \n  case = 1\n  for line in open('C-small-attempt2.in', 'Ur'):\n      if ' ' in line:\n          a,b = line.split()\n          res = test(int(a),int(b))\n          print(\"Case #{0}: {1}\".format(case, res))\n          case += 1\n  \n  \n", "substitutes": {"num": ["loc", "init", "int", "name", "multi", "id", "nom", "digit", "o", "inc", "nb", "test", "nam", "nc", "h", "initial", "Num", "min", "out", "valid", "mon", "mom", "np", "gen", "m", "x", "umi", "ident", "no", "en", "number", "bn", "icon", "index", "nt", "nu", "text", "unit", "random", "u"], "bot": ["log", "tip", "br", "plot", "loc", "core", "mot", "lot", "n", "bit", "pin", "inf", "prot", "ot", "bo", "lib", "ic", "pop", "txt", "net", "init", "bin", "type", "domain", "butt", "dot", "bi", "byn", "pos", "id", "p", "rank", "box", "round", "bc", "err", "prefix", "lb", "Bot", "test"], "top": ["best", "tip", "ip", "min", "size", "page", "max", "loc", "core", "lot", "n", "op", "pop", "txt", "left", "all", "type", "tops", "dot", "part", "limit", "pos", "p", "site", "home", "tips", "success", "high", "kit", "up", "lat", "hyp", "sp", "no", "len", "start", "bottom", "stop", "first", "title"], "count": ["log", "add", "size", "max", "key", "loc", "col", "n", "found", "call", "group", "lab", "order", "all", "int", "type", "part", "ch", "parent", "limit", "id", "p", "cat", "list", "match", "length", "info", "base", "cache", "depth", "weight", "lang", "bug", "counter", "len", "start", "check", "long", "code", "c"], "i": ["l", "ti", "loc", "fi", "input", "inf", "qi", "phi", "int", "multi", "id", "o", "io", "h", "y", "start", "c", "g", "ini", "ci", "si", "j", "eni", "xi", "bi", "limit", "m", "x", "ni", "ix", "mini", "hi", "number", "gi", "index", "cli", "u", "I", "s", "ui"], "case": ["section", "Case", "address", "size", "ASE", "sea", "error", "ce", "key", "max", "core", "cas", "rest", "rice", "rate", "one", "r", "me", "uc", "call", "rage", "chain", "shift", "ase", "chance", "type", "default", "ie", "name", "cer", "choice", "ace", "id", "p", "bc", "success", "match", "length", "client", "charge"], "line": ["LINE", "lo", "l", "log", "strip", "cell", "link", "lines", "page", "inline", "unit", "out", "bl", "comment", "error", "url", "n", "r", "pin", "never", "pe", "header", "object", "profile", "trial", "source", "style", "se", "net", "frame", "name", "phrase", "li", "et", "pos", "buffer", "re", "file", "std", "block"], "a": ["aa", "ai", "l", "sta", "ab", "ama", "alpha", "u", "api", "va", "ada", "am", "n", "r", "s", "ba", "au", "A", "sa", "asa", "ha", "all", "int", "app", "ie", "aw", "area", "ae", "p", "d", "na", "x", "ac", "up", "da", "la", "ea", "e", "an", "ad"], "b": ["l", "ab", "abb", "br", "bl", "rb", "bb", "ib", "u", "n", "r", "ba", "s", "v", "wb", "db", "fb", "both", "bi", "part", "d", "p", "bf", "eb", "m", "bc", "bs", "x", "mb", "lb", "bur", "nb", "e", "base", "y", "f", "c", "B", "beta", "sb"], "res": ["exc", "reg", "progress", "rice", "error", "ras", "rest", "cas", "mr", "rate", "r", "pres", "req", "trial", " Res", "ress", "us", "id", "re", "cr", "resp", "RES", "ret", "err", "success", "details", "rx", "response", "rec", "rev", "win", "rus", "Res", "our", "rel", "base", "rem", "cache", "result", "resolution"]}}
{"code": " data = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]\n  count = 0\n  for line in data[1:]:\n  \tcount += 1\n  \tsupps = line[1]\n  \tscore = line[2]\n  \tmaxes = 0\n  \tnonsuptot = (score*3)-2\n  \tsuptot = (score*3)-4\n  \tif suptot < 0:\n  \t\tsuptot = 1\n  \tfor i in range(3,(len(line))):\n  \t\tif line[i] >= nonsuptot:\n  \t\t\tmaxes += 1\n  \t\t\tcontinue\n  \t\tif (line[i] >= suptot) and (supps > 0):\n  \t\t\tmaxes += 1\n  \t\t\tsupps -= 1\n  \tif score == 0:\n  \t\tmaxes = line[0]\n  \tprint (\"Case #\"+str(count)+\":\", maxes)\n  \t\t\n  \t\t\t\n  \n  \n  \n  \n", "substitutes": {"data": ["image", "format", "config", "shape", "features", "keys", "alpha", "input", "value", "Data", "DATA", "slice", "model", "images", "scale", "raw", "meta", "default", "p", "list", "sequence", "response", "row", "map", "info", "result", "cache", "channel", "series", "temp", "sample", "options", "output", "results", "params", "split", "transform", "index"]}}
{"code": " \n  \n  def is_palindrome(a):\n      return str(a) == ''.join(reversed(str(a)))\n  \n  \n  def solve_problem(min_num, max_num):\n      count = 0\n      for i in xrange(min_num, max_num + 1):\n          if is_palindrome(i):\n              sqrt = math.sqrt(i)\n              if int(sqrt) == sqrt and is_palindrome(int(sqrt)):\n                  count += 1\n      return count\n  \n  \n  if __name__ == '__main__':\n      num_of_cases = int(sys.stdin.readline())\n      for i in xrange(1, num_of_cases + 1):\n          min_num, max_num = map(int, sys.stdin.readline().strip().split(' '))\n          print 'Case #{0}: {1}'.format(i, solve_problem(min_num, max_num))\n", "substitutes": {"a": ["aa", "ai", "sta", "ab", "alpha", "am", "n", "r", "b", "ba", "s", "another", "mac", "sam", "python", "A", "sa", "array", "name", "aaaa", "ga", "area", "ae", "p", "ace", "m", "na", "ana", "x", "abs", "auto", "o", "analysis", "ac", "ya", "da", "la", "e", "an", "ca"], "min_num": ["minDnum", "miningnon", "miningnu", "min_four", "min_min", "start_sum", "minalnum", "minxnu", "minipfour", "minipsum", "startxnon", "start_um", " min_number", "start_num", "max_n", "miningnum", "min_um", "start_nu", "min_number", "start_non", "minOnum", "minDnon", "minaln", "minOn", "minOtext", " min_n", "minxnum", "minOprefix", "min_nu", "start_min", "min_n", "min_prefix", "startxnum", "minDum", "minipnum", "min_non", "miningum", " min_uni", "min_sum", "minDnu"], "max_num": ["maxWmun", "maxjn", "max_n", " max_end", " max_size", "max_size", "maxUn", " max_n", "max__nom", "maxWnum", "next_n", " max_number", "max_nom", " max_sum", "max__n", "max__num", "max_sum", "next_num", "nextjnom", "maxWn", "maxjsize", " max_mun", "next_nom", "nextjnum", "max_number", "maxUnum", "maxUsum", "max_mun", "max_end", " max_nom", "nextjsize", "nextjn", "maxUend", "maxjnum", "maxWsize", "max__number", "maxjnom", "next_size"], "count": ["cond", "add", "size", "case", "key", "max", "col", "seq", "n", "found", "call", "group", "all", "total", "int", "type", "child", "it", "name", "part", "parent", "id", "p", "list", "val", "num", "match", "th", "length", "ac", "info", "base", "find", "conf", "depth", "weight", "result", "force", "self", "div"], "i": ["lo", "ai", "l", "ip", "j", "z", "chi", "cli", "iw", "eni", "ti", "u", "t", "api", "ib", "case", "I", "n", "b", "r", "v", "ui", "qi", "ic", "yi", "phi", "uri", "int", "xi", "type", "ie", "name", "bi", "k", "li", "ei", "d", "id", "p", "m"], "sqrt": ["secrect", "secrf", "shr", "squr", " sqrot", "shrect", "qnorm", "sqrot", "squrot", "qnt", "chr", " sqrect", "secrt", "sqnt", "qrot", "sqrf", "shnt", "chrt", "shRT", "chRT", "shrf", " sqr", "sqrect", "shrot", "chnorm", "qrt", " sqnt", "qRT", "squRT", "sqr", " sqrf", "sqRT", "sqnorm", " sqRT", "shrt", "secRT", "squnt", "qr", "squnorm", "squrt"], "num_of_cases": ["num_ofxcase", "num_ofaccases", "num_ofxblocks", "num_of_times", "num_offsections", "num_of_case", "num_ofxcases", "num_of_blocks", "num_ofxsections", "num_offcases", "num_offcase", "num_ofactimes", "num_ofaccase", "num_offblocks", "num_of_lines", "num_ofaclines", "num_of_sections"]}}
{"code": "\"\"\"\n  Google Code Jam 2012 Problem B\n  Usage:\n      python problem_b.py < input.txt > output.txt\n  \"\"\"\n  \n  \n  def calc_possible(n):\n      combinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores\n      return itertools.ifilter(lambda (x, y, z): x + y + z == n, combinations)\n  \n  \n  def calc_surprising(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def calc_normal(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def solve_problem():\n      number_of_cases = int(sys.stdin.readline())\n  \n      for i in xrange(1, number_of_cases + 1):\n  \n          case = sys.stdin.readline().strip()\n          result = 0\n          num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)\n          num_of_googlers = int(num_of_googlers)\n          num_of_surprising = int(num_of_surprising)\n          desired_score = int(desired_score)\n          scores = map(int, scores.split())\n  \n          possible_scores = []\n  \n          for k in xrange(num_of_googlers):\n  \n              normal = calc_normal(scores[k])\n              surprising = calc_surprising(scores[k])\n  \n              possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))\n  \n          possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))\n          result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))\n  \n          sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n  \n  \n  if __name__ == '__main__':\n      solve_problem()\n", "substitutes": {"n": ["l", "t", "b", "all", "ne", "name", "nor", "o", "nb", "coll", "nc", "nn", "h", "y", "c", "g", "j", "size", "r", "np", "ten", "m", "ns", "x", "local", "an", "no", "cn", "two", "en", "number", "network", "w", "ng", "nt", "nu", "nan", "u", "s", "node"], "combinations": ["domines", "cominations", "combinators", "clination", "comination", "clinations", "combinos", "Combinations", "clines", "clinos", "clinators", "comines", "dominations", "Combination", "Combinators", "combines", "domination", "combination", "cominators", " combinators", " combination", "dominators", "Combinos", " combinos"], "results": ["includes", "jobs", "windows", "tests", "stats", "grades", "multi", "uments", "weights", "objects", "outs", "maps", "cells", "steps", "comments", "plugins", "irements", "Results", "ners", "vals", "successful", "versions", "ents", "values", "lines", "reports", "data", "members", "errors", "blocks", "qs", "rules", "settings", "details", "products", "gets", "holes", "resources", "items", "cludes"], "number_of_cases": ["number_of_fits", "number_ofxcase", "number_ofxsettings", "number_ofxpoints", "number_of_points", "number_of_case", "number_ofxcases", "number_of_settings", "number_of_rows"], "i": ["l", "ip", "j", "z", "u", "t", " ii", "col", "I", "r", "b", "cor", "uc", "ic", "item", "ch", "li", "d", "id", "p", "bc", "cl", "gu", " c", "ct", "ix", " j", "e", "h", "a", "f", "q", "char", "gi", "ind", "ci", "cf"], "case": ["condition", "section", "Case", "address", "config", "shape", "size", "example", "key", "error", "ce", "character", "contract", "core", "sea", "path", "rice", "value", "connection", "pair", "trial", "profile", "stuff", "ase", "chance", "type", "choice", "name", "cer", "part", "time", "match", "ignore", "client", "cases", "charge", "space", "rule", "bug", "base"], "result": ["section", "answer", "page", "target", "final", "random", "error", "r", "value", "found", "distance", "data", "trial", "true", "group", "array", "item", "default", "function", "average", "dict", "rank", "round", "ret", "list", "success", "power", "mask", "res", "response", "match", "search", "row", "grade", "length", "filter", "cache", "weight", "report", "gain"], "num_of_googlers": ["num_of_goongles", "num_of_googsler", "num_of_loogler", "num_of_googglor", "num_of_goongler", "num_of_looggles", "num_of_googlor", "num_of_googsblers", "num_of_googsles", "num_of_googblers", "num_of_googslor", "num_of_loonglers", "num_of_googglers", "num_of_googhlor", "num_of_goongglers", "num_of_loogsler", "num_of_loogglor", "num_of_looglers", "num_of_googgglers", "num_of_looggler", "num_of_goongblers", "num_of_googhler", "num_of_googhlers", "num_of_googsglers", "num_of_googgblers", "num_of_googgedglers", "num_of_googgler", "num_of_loogsblers", "num_of_googgedlers", "num_of_goonglers", "num_of_googslers", "num_of_loongblers", "num_of_loongler", "num_of_googler", "num_of_looggglers", "num_of_loogblers", "num_of_loongles", "num_of_googgedler", "num_of_googles", "num_of_googgedles"], "num_of_surprising": ["num_of_urprise", "num_of_urprising", "num_of_urprises", "num_of_serieving", "num_of_curprise", "num_of_serpiring", "num_of_interprises", "num_of_curprising", "num_of_interieving", "num_of_serprise", "num_of_Surprises", "num_of_Surprisingly", "num_of_serprises", "num_of_surprisingly", "num_of_urpiring", "num_of_curieving", "num_of_surieving", "num_of__serpiring", "num_of_surprises", "num_of__surprisingly", "num_of_serprisingly", "num_of__surprising", "num_of_interprising", "num_of_Surprise", "num_of__surprises", "num_of__surpiring", "num_of__serprisingly", "num_of__serprising", "num_of_urprisingly", "num_of_curprises", "num_of_curprisingly", "num_of_surpiring", "num_of_Surpiring", "num_of__serprises", "num_of_interprisingly", "num_of_serprising", "num_of_Surprising", "num_of_surprise"], "desired_score": ["deserved_match", "desired_match", "desired___match", "desired\u00b7score", "desired_word", "desiredfword", "desiredfscore", "desiredacscore", "desired\u00b7distance", "desired_distance", "desinished_size", "deserved_word", "desiredacmatch", "desiredftime", "desired_white", "deserved_time", "desired_size", "deserved_field", "deserved_score", "desiredacword", "desired_field", "desired___score", "deserved_white", "desired___white", "desired___field", "desired\u00b7size", "desired_time", "desinished_score", "desiredactime", "desiredfmatch", "desinished_distance"], "scores": ["SCorers", "oscopes", "cores", " scourses", "escuries", "accessors", "Scores", "scategories", "swopes", " score", "scorers", "swores", "encourses", "descoring", "encores", "spors", "ascore", "oscoring", "expopes", "spores", "descorers", "spords", "clusaches", "descanners", "SCors", "accessores", "SCores", "core", "spored", "compors", "descatches", "clusores", "oscore", " scategories", "descategories", " scoring", "pors", "scors", "scuries", "Score"], "possible_scores": ["possible_clores", "possible_scours", "possible_scored", "possible_hypore", "possible_descored", "possible_clatters", "possible_scors", "possible_Scores", "possible_locore", "possible_Scored", "possible_Score", "possible_clore", "possible_score", "possible_cORE", "possible_cored", "possible_Scors", "possible_core", "possible_descors", "possible_corer", "possible_cores", "possible_Scorer", "possible_ScORE", "possible_locores", "possible_descore", "possible_hypores", "possible_cours", "possible_scORE", "possible_cors", "possible_scatters", "possible_hypORE", "possible_locours", "possible_hyporer", "possible_locatters", "possible_clours", "possible_scorer", "possible_descores", "possible_catters"], "k": [" work", "key", "kick", "b", "ko", "kn", "tk", " ng", "id", " ch", "h", " che", "kid", "c", "g", "kin", " kn", "kr", "j", "kk", "unk", "m", "x", " eg", "w", "u", "dk", "ke", "ku", " sk", "cp", "ask", " ka", "ik", "uk", "d", "work", "ka", " z", " j"], "normal": ["small", "neutral", "fun", "color", "new", "size", "natural", "random", "error", "mean", "unit", "old", "den", "ean", "standard", "common", "data", "Normal", "front", "raw", "all", "change", "total", "general", "default", "simple", "average", "function", "good", "parent", "day", "pos", "fat", "active", "organ", "special", "position", "form", "other", "clean"], "surprising": ["surprises", "Surprising", "surprisingly", "Surprises", "surprise", "urprisingly", "serprising", "serprisingly", "urprising", "serprise", "serprises", "Surprisingly", "urprises", "urprise", "Surprise"], "possible": ["spores", "paored", "possibility", "Possibility", "spossible", "Pores", "pores", "Pored", "pored", "spored", "paossible", "spossibility", "Possible", "paossibility", "paores"]}}
{"code": " \n  \n  \n  def ispalindrome(n):\n      return str(n) == str(n)[::-1]\n  \n  \n  def solve(A, B):\n      solution = []\n      for n in range(int(math.sqrt(A)), int(math.sqrt(B))+1):\n          if ispalindrome(n):\n              m = n ** 2\n              if ispalindrome(m) and A <= m <= B:\n                  solution.append(n)\n      return len(solution)\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          A, B = map(int, IN.readline().split())\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(A, B)))\n  \n  \n  def makesample(T=100, ABmax=1000):\n      print T\n      for index in range(T):\n          A = random.randint(1, ABmax)\n          B = random.randint(A, ABmax)\n          print A, B\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n", "substitutes": {"n": ["l", "adj", "nv", "un", "j", "min", "z", "size", "null", "t", "u", "i", "max", "mn", "r", "b", "s", "v", "node", "M", "NA", "nw", "np", "net", "ne", "init", "ln", "name", "k", "nr", "d", "p", "na", "dn", "ns", "x", "ni", "num", "N", "o"], "A": ["API", "D", "Ma", "Code", "Data", "GA", "Int", "ACT", "SA", "TA", "AS", "And", "One", "BA", "L", "Y", "Input", "In", "Num", "AY", "Na", "Sample", "AB", "H", "M", "NA", "AN", "Am", "KA", "RA", "This", "ABC", "App", "U", "AW", "AD", "AI", "ANC", "W", "Ar"], "B": ["Q", "J", "D", "UB", "Other", "b", "LB", "Gb", "VB", "Bs", "BER", "BB", "EB", "BA", "Tab", "L", "Y", "Block", "BY", "WB", "QB", "DB", "IB", "Beta", "AB", "H", "M", "Base", "PB", "BL", "U", "BC", "W", "O", "E", "MB", "V", "X", "OB", "R"], "solution": ["absolver", "solver", "absolution", "dolver", "ssolution", "dolutions", "solving", "solutions", "absolved", "Solution", "dolving", "ssolver", "absolutions", "ssolutions", " solve", "solve", "solved", "dolution", "Solved", "Solutions", "ssolving", " solver", "ssolve", " solved", "Solve", " solving", "Solver", " solutions"], "m": ["l", "sm", "mm", "j", "min", "z", "i", "u", "max", "mr", "am", "mn", "ms", "r", "b", "im", "v", "range", "dim", "pm", "M", "model", " M", "k", "om", "cm", "d", "p", "mc", "x", "num", "mu", "ym", "N", "fm", "o", "mi", "e", "an", "h"], "IN": ["II", "LINE", "URL", "PIN", "IO", "PASS", "Out", "TIME", "RAW", "HTTP", "ins", "out", "Client", "input", "EN", "IT", "DATA", "AN", "MIN", "IND", "USER", "String", "ING", "bin", "IL", "NG", "READ", "STR", "OU", "CL", "UPDATE", "DL", "WIN", "UID", "inner", "MC", "LIN", "FILE", "N", "PUT"], "OUT": ["LINE", "Q", "IO", "RAW", "URL", "II", "Out", "ALL", "TH", "out", "Output", "DC", "DERR", "EXT", "OT", "GER", "EN", "DATA", "GEN", "NT", "String", "WORK", "IL", "NG", "STR", "READ", "OU", "NB", "DL", "GROUP", "ER", "Writer", "GET", "FILE", "INT", "PUT", "STDOUT", "UN", "INS", "W"], "T": ["P", "Q", "DT", "TS", "Z", "D", "TH", "t", "TM", "H", "I", "SIZE", "IP", "LT", "TR", "M", "NT", "TE", "Position", "TC", "Ts", "TG", "R", "ID", "TW", "WT", "TF", "Time", "TA", "G", "AT", "U", "N", "TN", "TI", "length", "W", "O", "Total", "Target"], "index": ["END", "j", "obj", "size", "page", "Z", "key", "out", "i", "iter", "alpha", "loc", "example", "t", "path", "insert", "col", "input", "I", "b", "value", "loop", "DI", "data", "slice", "IND", "order", "array", "int", "type", "name", "pos", "id", "site", "ion", "position", "inner", "read", "x", "val"], "ABmax": ["abmax", "ABcache", "AFmax", " ABorig", "AFMax", "ADrest", "AFtotal", "ADcache", " ABMax", "ADorig", "ADMAX", "ADmax", " ABMAX", "abtotal", "ABMax", "ADMax", "ABorig", "ADtotal", "ABMAX", "AForig", "ABtotal", "ABrest", "abMAX", " ABtotal", " ABrest", " ABcache", "abcache", "AFMAX", "AFrest"]}}
{"code": " \n  \n  \n  \n  \n  def solve(S, p, tlist):\n  \tabove = 0\n  \tconsider = 0\n  \n  \tfor t in tlist:\n  \t\tavg = t / 3\n  \t\tmod = t % 3\n  \n  \t\tif mod == 0:\n  \t\t\tif avg >= p:\n  \t\t\t\tabove += 1\n  \t\t\telif avg + 1 >= p and t > 0:\n  \t\t\t\tconsider += 1\n  \n  \t\telif mod == 1:\n  \t\t\tif avg + 1 >= p:\n  \t\t\t\tabove += 1\n  \n  \t\telif mod == 2:\n  \t\t\tif avg + 1 >= p:\n  \t\t\t\tabove += 1\n  \t\t\telif avg + 2 >= p:\n  \t\t\t\tconsider += 1\n  \n  \treturn above + min(S, consider)\n  \n  \n  def main(IN, OUT):\n  \tN = int(IN.readline())\n  \tfor index in range(N):\n  \t\tdata = map(int, IN.readline().strip().split())\n  \t\t(N, S, p), tlist = data[:3], data[3:]\n  \t\tOUT.write('Case #%d: %d\n' % (index + 1, solve(S, p, tlist)))\n  \n  \n  if __name__ == '__main__':\n  \tmain(sys.stdin, sys.stdout)\n  \n", "substitutes": {"S": ["P", "Q", "State", "TS", "SM", "D", "Ps", "POS", "DS", "In", "H", "I", "SEC", "s", "IP", "M", "SO", "SU", "A", "source", "FS", "System", "SN", "SR", "CL", "SK", "SH", "G", "U", "Sa", "GS", "WS", "SE", "St", "spec", "BS", "W", "INS", "sample", "O"], "p": ["l", "pp", "pl", "i", "b", "pr", "Po", "int", "pot", "tp", "point", "option", "o", "ap", "h", "y", "pt", "c", "params", "fp", "T", "g", "root", "j", "per", "py", "TP", "Python", "pro", "lp", "r", "pm", "python", "np", "m", "po", "x", "bp", "sp", "a"], "tlist": ["pcode", "atset", "dtList", "lbase", "vList", "Tlist", " tList", "Tval", "atlist", "pset", " tcode", "TList", "dtbase", "plist", "vcode", "pList", "vval", "Tset", "Tcode", "llist", "vlist", "tset", " tval", "tList", "dtlist", "atList", "tbase", "Tbase", "tval", "tcode", "lList"], "above": ["alpha", "profit", "past", "master", "prev", "between", "inc", "outside", "Above", "bottom", "first", "over", "root", "margin", "conference", "conservative", "per", "present", "python", "origin", "behind", "giving", "frac", "highest", "according", " ahead", "a", "lower", "padding", "fresh", "cover", "author", "enough", "within", "inside", "into", "TOP", "central", "Top", "null"], "consider": ["very", "respect", "require", "integer", "allow", "table", "accept", "option", "grade", "moderate", " avoid", "remove", "c", "over", "feature", "collect", "follow", "minus", "care", "iter", "present", "portion", "txt", "about", "element", "even", "control", "adjust", " proportion", "just", "cover", "com", "number", "use", "into", "design", "transform", " considering", "iterator", "include"], "t": ["l", "tc", "j", "z", "art", "i", "out", "u", "ti", "iot", "n", "r", "s", "v", "ot", "tt", "tu", "off", "python", "all", "put", "total", "int", "te", "type", "tf", "it", "tom", "tm", "d", "m", "time", "ret", "table", "x", "ta", "tp", "xt", "er", "o"], "avg": ["evG", "umgy", "ajp", "avgen", "afgy", "afgar", "evp", "AVge", "afge", "umgs", "avergar", "ajgo", "ovge", "afga", "evge", "ajg", "ajga", "AVg", "avergs", "avi", "svge", "svG", "afgo", "evg", "svp", " avp", "svg", "averg", "aji", "AVG", "avergo", "umg", "AVp", " avgu", "ajG", "umga", "ajgy", " avgo", "avgo", "avgs"], "mod": [" mods", "fun", "tool", "progress", "dim", "ot", "op", "access", "complex", "init", "int", "function", "id", "oct", "round", "allow", "MOD", "od", "option", "grade", "alt", "supp", "pt", " MOD", "update", "section", "reg", "sec", "size", "ow", "set", "im", "pm", "term", "Mod", "m", "track", "edit", "rim", "ac"], "IN": ["LINE", "Q", "URL", "PIN", "IO", "RAW", "Out", "ins", "out", "input", "DIR", "Lin", "EN", "M", "DATA", "MIN", "IND", "String", "bin", "IL", "NG", "READ", "login", "CL", "OU", "UPDATE", "ID", "DL", "WIN", "LIB", "AL", "BL", "Reader", "inner", "din", "MC", "GET", "LIN", "FILE", "Ins"], "OUT": ["LINE", "Q", "P", "END", "RAW", "IO", "Out", "Z", "TH", "HEAD", "out", "Python", "Output", "I", "EXT", "OT", "OF", "DIR", "DATA", "NT", "String", "READ", "IL", "STR", "NG", "OP", "FS", "OU", "CL", "BL", "AL", "TF", "GROUP", "ER", "outs", "inner", "FILE", "INT", "TABLE", "PATH"], "N": ["P", "Na", "Z", "D", "Size", "NI", "n", "I", "NC", "SIZE", "Data", "M", "NA", "Len", "NT", "A", "NUM", "NG", "SN", "NN", "NE", "NR", "New", "NM", "G", "num", "No", "length", "Ni", "Ns", "Number", "O", "Num", "NO", "C", "Ne", "V", "MN", "L", "X"], "index": ["include", "obj", "page", "key", "out", "i", "insert", "input", "n", "value", "object", "slice", "IND", "item", "int", "element", "level", "type", "name", "degree", "pos", "site", "ion", "position", "digit", "inner", "x", "val", "num", "prefix", "point", "line", "row", "match", "action", "length", "ix", "inc", "offset", "end"], "data": ["missing", "size", "zip", "alpha", "update", "key", "xxx", "input", "r", "n", "value", "Data", "DATA", "post", "slice", "source", "array", "style", "raw", "left", "shift", "int", "dat", "next", "default", "batch", "write", "name", "content", "ata", "d", "id", "buffer", "na", "cat", "read", "list", "block", "pad", "response"]}}
{"code": " \n  N_MAX = 10 ** 7  # for First large dataset\n  \n  \n  def is_palindrome(n):\n      s = str(n)\n      for i in xrange(len(s) / 2):\n          if s[i] != s[-1 - i]:\n              return False\n      return True\n  \n  palindromes = [x for x in xrange(N_MAX) if is_palindrome(x)]\n  palindrome_squares = [x ** 2 for x in palindromes]\n  fair_and_square_palindromes = filter(is_palindrome, palindrome_squares)\n  \n  \n  T = int(raw_input())\n  for test_case_id in xrange(1, T + 1):\n      A, B = map(int, raw_input().split())\n      answer = len([x for x in fair_and_square_palindromes if A <= x <= B])\n      print 'Case #{}: {}'.format(test_case_id, answer)\n", "substitutes": {"N_MAX": ["n_max", "n__max", "NAMmax", "RNMax", "NNMAX", "NIPMax", "NNmax", "R_HEAD", "NNMax", "n_MAX", "n__MAX", "NIPMAX", "n_Max", "RNHEAD", "NAMHEAD", "R_Max", "R_MAX", "N_max", "N__Max", "N_HEAD", "R_max", "NAMMAX", "NNHEAD", "n__Max", "NIPmax", "N__max", "N_Max", "RNMAX", "NAMMax", "RNmax", "N__MAX"], "n": ["l", "j", "z", "t", "max", "u", "b", "v", "node", "net", "ne", "name", "k", "d", "p", "m", "nin", "ns", "num", "N", "o", "nb", "e", "nt", "Ns", "nn", "no", "y", "en", "a", "f", "sn", "c", "number", "g", "fn", "w", "network", "nu"], "s": ["l", "ts", "es", "services", "t", "ins", "u", "sets", "ss", "sup", "states", "ses", "r", "v", "sf", "b", "letters", "js", "slice", "sa", "ks", "cs", "source", "se", "tests", "less", "sv", "parts", "ds", "d", "p", "ys", "m", "qs", "sg", "ns", "abs", "south", "str", "bis"], "i": ["ai", "l", "ip", "j", "z", "chi", "alpha", "eni", "u", "ti", " I", "t", "ri", "I", "b", "bit", "v", "r", "inf", "phi", "int", "xi", "k", "bi", "li", "ei", "d", "id", "p", "m", "iu", "pi", "ni", "o", "io", "ix", "e", "il", "h", "y"], "palindromes": ["palindchromites", "palendromises", "palindroyis", "palindrocs", "palintromites", "palintromeues", "palindromees", "palindrose", "palindromee", "palintromues", "palindromites", "palindrosues", "palendroms", "palintromees", "palindchromes", "palindrocis", "palindroms", "palindroyes", "palindromues", "palendromees", "palindrocises", "palindroys", "palintrome", "palindromeues", "palindrome", "palendromes", "palindroyises", "palindromis", "palindromises", "palindromeises", "palindchromues", "palendromeises", "palindroses", "palindroces", "palindromeis", "palindchrome", "palendromis", "palindrosites", "palendromeis", "palintromeites"], "x": ["co", "ex", "l", "rax", "alpha", "t", "rest", "xd", "abc", "input", "Any", "b", "xx", "ross", "int", "sex", "id", "oint", "rx", "ct", "tx", "xs", "h", "y", "c", "Y", "g", "px", "ci", "www", "size", "im", "r", "cross", "xy", "xi", "xxxx", "ww", "m", "go"], "palindrome_squares": ["palindrome_quares", "palindrome_quare", "palindrome_squars", "palindrome_Squeries", "palindrome_quers", "palindrome_scers", "palindrome_Squests", "palindrome_equars", "palindrome_scare", "palindrome_Squars", "palindrome_Square", "palindrome_equares", "palindrome_squers", "palindrome_Squares", "palindrome_Squers", "palindrome_squeries", "palindrome_quared", "palindrome_Squared", "palindrome_scares", "palindrome_scared", "palindrome_squests", "palindrome_equeries", "palindrome_equests", "palindrome_square", "palindrome_squared"], "fair_and_square_palindromes": ["fair_and_square_palndramES", "fair_and_square_palendromee", "fair_and_square_palendromeals", "fair_and_square_palindramed", "fair_and_square_palindrome", "fair_and_square_palndrame", "fair_and_square_palendrome", "fair_and_square_palendromees", "fair_and_square_palindramals", "fair_and_square_palendromed", "fair_and_square_palindrones", "fair_and_square_palindromeES", "fair_and_square_palndrome", "fair_and_square_palendromeed", "fair_and_square_palindrame", "fair_and_square_palindromee", "fair_and_square_palindramES", "fair_and_square_palindromees", "fair_and_square_palndrames", "fair_and_square_palindrone", "fair_and_square_palendromes", "fair_and_square_palindromeals", "fair_and_square_palindrumites", "fair_and_square_palindromals", "fair_and_square_palindromed", "fair_and_square_palndromES", "fair_and_square_palindrumes", "fair_and_square_palindromES", "fair_and_square_palindromeed", "fair_and_square_palindrumES", "fair_and_square_palindronals", "fair_and_square_palindroned", "fair_and_square_palindrames", "fair_and_square_palindramites", "fair_and_square_palindromeites", "fair_and_square_palindromites", "fair_and_square_palindrume", "fair_and_square_palndromes", "fair_and_square_palndramites", "fair_and_square_palendromals"], "T": ["Q", "P", "TS", "Z", "D", "TH", "t", "ti", "H", "I", "TX", "M", "Test", "TC", "type", "ID", "TW", "TF", "WT", "Time", "time", "TA", "G", "N", "TN", "TI", "W", "O", "Total", "Tab", "E", "C", "Length", "S", "V", "L", "X", "TB", "TT", "Y"], "test_case_id": ["test_test_index", "test_sectionblocknum", "test_section_index", "test_section_num", "test_case__index", "test_test_ids", "test_caseblocknum", "test_caseblockid", "test_caseblockids", "test_case__id", "test_sectionblockid", "test_caseblockindex", "test_case__ids", "test_sectionblockids", "test_case_ids", "test_section_id", "test_case_num", "test_case__num", "test_sectionblockindex", "test_case_index", "test_test_id", "test_section_ids"], "A": ["P", "El", "Ca", "Na", "As", "D", "alpha", "AA", "Ma", "LA", "H", "I", "AB", "ba", "Ax", "au", "Val", "M", "Ab", "Alpha", "HA", "IA", "AL", "App", "Array", "G", "U", "Answer", "N", "At", "Ar", "O", "CA", "ca", "BA", "E", "a", "C", "S", "L"], "B": ["Q", "P", "Ub", "WB", "QB", "DB", "Z", "D", "GB", "UB", "AB", "I", "b", "BF", "LB", "M", "BM", "SB", "PB", "NB", "BL", "Bs", "G", "U", "N", "Blue", "CB", "BC", "BE", "BS", "EB", "O", "BA", "Tab", "E", "C", "S", "Bal", "L", "X"], "answer": ["uit", "address", "swers", "size", "issue", " answered", "error", "random", "complete", "say", "exit", "one", "une", "su", "amount", "term", "trial", "SU", "duration", "array", "true", "next", " Answer", "ell", "default", "evidence", "see", "area", "rue", "side", "answered", "ace", "current", "trace", "err", "field", "Answer", "response", "token", "race"]}}
{"code": " \n  \n  poss = dict([(i, {}) for i in xrange(0, 30 + 1)])\n  for a, b, c in itertools.product(range(10 + 1), repeat=3):\n      if a <= b <= c and c - a <= 2:\n          n = a + b + c\n          if c - a == 2:\n              poss[n]['s'] = tuple(sorted((a, b, c)))\n          else:\n              poss[n]['n'] = tuple(sorted((a, b, c)))\n  \n  \n  T = int(raw_input())\n  for case in xrange(1, T + 1):\n      div = map(int, raw_input().split())\n      N, S, p = div[:3]\n      t = div[3:]\n  \n      ans = 0\n      t.sort(reverse=True)\n      for i in xrange(len(t)):\n          na, nb, nc = poss[t[i]]['n']\n          sa, sb, sc = poss[t[i]].get('s', (-1, -1, -1))\n          if p <= nc:\n              ans += 1\n          elif 0 < S and p <= sc:\n              ans += 1\n              S -= 1\n  \n      print 'Case #%d: %d' % (case, ans)\n  \n", "substitutes": {"poss": [" pos", "Pens", " pense", "noss", "npos", "spos", "npasses", "nos", "sposs", "nens", "tense", "Puss", "coss", "pense", "tOSS", "lpuss", " passes", "Passes", "pens", "cOSS", "puss", "Pos", " puss", "pos", "tass", "Powers", " pott", "npens", "Pott", "Pairs", "nowers", "passes", " pOSS", "toss", " pens", "powers", "Pass", "spowers", " pairs", "cairs"], "i": ["ai", "l", "ip", "j", "chi", "z", "eni", "ib", "ti", "u", "ri", "I", "r", "v", "qi", "ui", "yi", "phi", "uri", "it", "int", "xi", "item", "ie", "k", "part", "li", "bi", "d", "id", "ch", "m", "iu", "x", "pi", "ni", "mi", "di", "num", "o"], "a": ["ak", "aa", "ai", "l", "wa", "ab", "z", "alpha", "art", "u", "va", "ada", "am", "ach", "oa", "count", "ba", "au", "s", " A", "v", "A", "array", "asa", "aw", "ata", "pa", "ae", "d", "area", "x", "o", "ac", "inc", "da", "ap", "ah", "e", "ea", "la"], "b": ["l", "aa", "j", "ab", "api", "rb", "bb", "u", "ib", "r", "s", "v", "ba", "wb", "db", "bh", "fb", "k", "area", "d", "be", "bf", "eb", "ae", "bc", "bs", "x", "cy", "o", "ac", "lb", "e", "cb", "ca", "h", "fa", "y", "f", "g", "B"], "c": ["cur", "l", "dc", "z", "arc", "cos", "u", "cc", "max", "loc", "ce", "cin", "col", "cu", "count", "s", "v", "cp", "cd", "r", "call", "cs", "unc", "fc", "ec", "xc", "k", "ch", "cm", "d", "m", "cr", "bc", "mc", "cat", "x", "cy", "rec", "o", "ct"], "n": ["l", "config", "j", "z", "pn", "u", "out", "r", "s", "v", "ann", "node", "conn", "np", "net", "ne", "int", "name", "k", "d", "m", "dn", "ns", "x", "ni", "num", "o", "e", "nt", "names", "self", "coll", "an", "cn", "h", "no", "y", "en", "f", "sn"], "T": ["P", "Q", "TS", "Z", "D", "Size", "GT", "H", "I", "M", "A", "NT", "TC", "TW", "TA", "G", "U", "W", "O", "Total", "E", "C", "Length", "V", "PT", "L", "X", "TT", "Y", "TB", "B", "CT", "F", "R"], "case": ["section", "Case", "shape", "ip", "address", "config", "size", "ce", "mode", "core", "one", "count", "r", "pe", "uc", "slice", "trial", "shift", "fe", "ase", "se", "type", "ie", "name", "day", "ace", "d", "id", "phase", "time", "position", "bc", "num", "match", "line", "race", "cases", "e", "bug", "ice"], "div": ["cur", "division", "tri", "dc", "min", "pp", "br", "window", "u", "DIV", "ow", "max", "ce", "desc", "input", "r", "s", "v", "dim", "span", "data", "rup", "group", "dec", "raw", "int", "app", "part", "ch", "d", "pos", "m", "box", "form", "inner", "table", "prev", "str", "rec", "di"], "N": ["P", "Q", "Na", "Z", "D", "I", "NC", "M", "NA", "AN", "A", "NB", "ns", "G", "U", "Sa", "Ns", "O", "an", "C", "sn", "V", "L", "X", "K", "B", "An", "F", "CN", "NS", "R"], "S": ["Q", " SS", "D", "Sign", "Ps", "SA", "AS", "SE", "St", "Ns", "LS", "Sn", "L", "g", "ST", "SS", "si", "Na", "sec", "M", "se", "SN", "ns", "U", "W", "sp", "O", "an", "V", "X", "B", "SI", "R", "TS", "Z", "I", "s", "A", "cs", "CS"], "p": ["P", "l", "ppa", "pp", "amp", "pn", "u", "r", "s", "cp", "pe", "ot", "op", "pr", "A", "np", "NP", "d", "pos", "m", "PA", "ns", "x", "tp", "bp", "o", "pc", "Pa", "os", "ap", "e", "nt", "ps", " P", "sp", "an", "h", "y", "en", "C"], "t": ["l", "unt", "tc", "new", "ti", "u", "trans", "r", "s", "v", "qt", "ot", "tt", "tu", "flat", "txt", "te", "it", "total", "int", "type", "tf", "part", "tm", "wt", "d", "body", "m", "template", "list", "table", "x", "ta", "tp", "o", "cont", "tw", "ct", "e", "tab"], "ans": ["ai", "Case", "ents", "can", "Na", "args", "ins", "amps", "ras", " Ans", "ss", "eps", "ations", "ms", "ks", "cons", "s", "ann", "span", " ads", "NA", "AN", "aus", "cs", "ids", "anas", "ays", "anes", "leans", "ats", "errors", "ds", "ants", "pos", " spans", "ens", "ns", "ni", "ANS", "san"], "na": ["aa", "wa", "Na", "chi", "nan", "ss", "ann", "NA", "asa", "np", "qa", "ne", "net", "NN", "pos", "cr", "po", "ns", "cat", "ni", "Sa", "Ni", "ac", "nas", "nat", "da", "la", "Ns", "nt", "ca", "nn", "nz", "Ne", "sn", "NS", "pa", "ny"], "nb": ["ai", "adj", "aa", "ab", "abb", "pn", "bb", "abc", "nu", "ann", "cp", "np", "ne", "NN", "bi", "nr", "wp", "dn", "sg", "bc", "ns", "ni", "bp", "ani", "Ni", "nat", "cb", "Ns", "nn", "ad", "nz", "ny", "sn", "bn", "nl", "nd", "nt", "nan", "si"], "nc": ["aa", "nv", "dc", "pn", "cc", "mn", "nu", "NC", "ann", "cp", "nw", "conn", "cs", "np", "ne", "xc", "NN", "nr", "bc", "dn", "mc", "ns", "ni", "gn", "ct", "rn", "Ni", "inc", "pc", "ac", "da", "Ns", "nn", "cn", "nd", "nm", "nz", "sn", "enc", "bn"], "sa": ["aa", "ai", "sta", "ss", "ba", "so", "ann", "sam", " si", "ne", "sv", "bi", "SA", "asi", "sg", "bc", "ns", "ni", "ta", "Sa", "ac", "nas", "da", "sp", "ca", "nn", "cn", "sn", "sd", "pa", "si"], "sb": ["ai", "ib", "rb", "bb", "src", "ss", "stab", "sf", "s", "st", "wb", "np", "SB", "sv", "soc", "bi", "nr", "bc", "sg", "bs", "ni", "bp", "si", "lb", "gb", "cb", "sp", "ls", "nn", "sn", "sd", "pb", "sq"], "sc": ["dc", "esc", "ci", "cc", "Sc", "ss", "sw", "so", "s", "NC", "uc", "cs", "se", "ne", "soc", "sync", "ch", "asc", "bc", "sg", "cv", "ns", "sh", "sci", "cl", "osc", "usc", "si", "ac", "pc", "CS", "pg", "sp", "nz", "cn", "SC", "sn", "rc", "sk", "anc"]}}
{"code": " \n  \n  \n  INPUT = \"tiny\"\n  if 1:\n      INPUT = \"C-small-attempt0.in\"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args\n  \n  def is_palindrome(N):\n      s = str(N)\n      return s == ''.join(reversed(s))\n  \n  def fair_and_square_set(max_N):\n      p = \"squareset_%d\" % max_N\n      try:\n          s = pickle.load(file(p))\n          return s\n      except:\n          pass\n      s = set()\n      for i in range(1,max_N+1):\n          if is_palindrome(i) and is_palindrome(i*i):\n              s.add(i*i)\n      pickle.dump(s, file(p, \"wb\"))\n      return s\n  \n  MAX_N = int(1e7)\n  SQUARE_SET = fair_and_square_set(MAX_N)\n  \n  def do_trial(A, B):\n      count = 0\n      for ss in SQUARE_SET:\n          if A <= ss <= B:\n              count += 1\n      return count\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      A, B = [int(x) for x in f.readline().split()]\n      v = do_trial(A, B)\n      print \"Case #%d: %s\" % (i+1, v)\n", "substitutes": {"INPUT": ["AINLINE", "AINput", "InInput", "InPUT", "INput", "inPU", "input", "INLINE", "inInput", "AINFILE", "inULT", "InULT", " INInput", "InLINE", "InFILE", "INULT", "inPUT", " INULT", "inFILE", "INFILE", "inLINE", " INPU", "AINPUT", "Input", "INPU", " INLINE", "InPU", "INInput"], "self": ["co", "right", "connection", "all", "master", "name", "utils", "host", "other", "cl", "point", "proc", "h", "c", "ctx", "g", "instance", "per", "case", "py", "complete", "public", "me", "r", "plugin", "python", "func", "m", "er", "client", "module", "spec", "base", "layer", "make", "patch", "http", "w", "writer", "view"], "function": ["fun", "library", "closure", "null", " functions", "member", "figure", "unit", "value", "connection", "job", "node", "call", "data", "object", "python", "full", "partial", "unc", "array", "type", " func", "name", "func", "document", "parent", "package", "file", "position", "handler", "functional", "action", "module", "original", "fork", "method", "word", "Function", "wrapper", "operation"], "_cache": ["workingconfig", "_data", "_ache", "_session", "workingfunction", "_call", "logache", " _function", "logdata", "logcall", "workingsession", "workingcache", " _config", "_function", "_config", " _session", "logcache"], "_callable": ["_Callfunction", "___variation", "_callative", "_Caller", "_variable", "_Callable", "_calledable", "_variation", "_Callation", "_calledfunction", "___variables", "_callation", "_functionative", "_codeation", "___callation", "_caller", "_calleder", "___variable", "_codeable", "_functionable", "_variables", "_calledative", "___callable", "_callables", "_functionfunction", "_Callables", "_Callative", "___callables", "_codeables", "_callfunction", "_functioner"], "cache": ["co", "config", "image", "can", "cell", "fake", "keys", "null", "args", "py", "api", "pool", "cu", "public", "hash", "value", "capacity", "call", "data", "object", "model", "proxy", "store", "default", "parse", "storage", "memory", "sync", "parent", "dict", "ae", "Cache", "session", "table", "lock", "ached", "response", "match", "client", "ac"], "key": ["section", "fee", "link", "keys", "size", "page", "py", "error", "label", "core", "KEY", "path", "url", "hash", "value", "connection", "capacity", "mac", "call", "data", "object", "store", "array", "item", "element", "type", "name", "definition", "k", "sync", "id", "entry", "seed", "host", "file", "by", " entry", "str", "service", "property"], "cachedValue": ["cannedValues", "cachedvalue", " cryptedValues", "fachedvalue", "cryptedvalue", "conedValue", "cachedValues", " cryptedVALUE", "cannedVALUE", "fachedValues", "cashedValue", "cashedKey", "cappedValue", "cachedVALUE", "conedvalue", "cryptedValues", "fappedvalue", "cachableValues", "fachedValue", "fappedValues", " cachedValues", "cachableKey", "cannedValue", "cappedValues", "cachablevalue", "cryptedVALUE", " cachedvalue", "fappedValue", "cachedKey", "cappedvalue", "cannedvalue", "conedVALUE", " cachedVALUE", "conedValues", "fappedKey", "cappedKey", " cryptedvalue", "fachedKey", "cryptedValue", " cryptedValue"], "N": ["P", "Q", "J", "Na", "size", "Z", "D", "Size", "NI", "H", "n", "I", "NC", "SIZE", "M", "NA", "NT", "NUM", "NG", "SN", "NN", "NB", "NE", "ns", "G", "NM", "U", "Ni", "Ns", "W", "O", "Num", "E", "C", "MN", "S", "V", "Ne", "L", "X"], "s": ["l", "ssh", "t", "b", "tests", "ows", "tes", "outs", "ores", "o", "ances", "comments", "Ns", "xs", "ments", "h", "y", "string", "c", "params", "g", "sb", "ends", "strings", "si", "ces", "values", "lines", "sec", "ing", "sets", "set", "stores", "ses", "r", "js", "ves", "se", "np", "sync"], "max_N": ["max_C", "max_n", "maxJK", " maxJL", " max_K", "max2C", " max_C", "Max_n", "Max_N", " maxJN", "Max_M", " maxJK", "maxJC", "maxJL", "max_L", "max2L", "maxJM", "maxJN", "max2N", " max_L", "max_K", "Max_K", "max_M", "Max_C", "max2M", " maxJC", "max2K"], "p": ["P", "l", "ip", "j", "page", "pp", "py", "t", "u", "api", "out", "path", "n", "lp", "b", "cp", "pr", "r", "input", "port", "jp", "np", "ping", "pb", "part", "d", "m", "pid", "file", "pot", "wp", "pipe", "po", "pi", "bp", "tp", "point", "o", "pc", "proc"], "i": ["l", "ti", "t", "fi", "ih", "b", "qi", "phi", "uri", "int", "multi", "ei", "id", "val", "mu", "o", "io", "h", "y", "start", "c", "ini", "ci", "si", "j", "eni", "ri", "r", "xi", "bi", "limit", "m", "ni", "ani", "ix", "mini", "hi", "a", "w", "gi"], "MAX_N": [" MAXIDS", "MAXIDS", "MAX_K", " MAX_C", "AND_n", "MAX64n", "MAXIDC", "MAXIDN", "MAX64C", "MAXJC", " MAXIDC", "MAX2C", "AND_C", "MAXJS", "MAX2N", "AND64C", "MAX_C", "MAX2K", "AND64n", " MAX_S", "AND64N", "MAXJN", " MAXIDK", " MAXIDN", "MAX_S", "MAX64N", "MAXJK", "MAX2S", " MAX_K", "AND_N", "MAXIDK", "MAX_n"], "SQUARE_SET": ["SQUAR_Set", "SQUAREALET", "SQUAREALSet", "SQUARALSet", "SQUAREETET", "SQUAR_READ", "SQUAR_SET", "SQUARALET", "SQUAREETSet", "SQUAREETSET", "SQUAR_ET", "SQUARALREAD", "SQUARE_READ", "SQUAREALSET", "SQUAREALREAD", "SQUARALSET", "SQUARE_ET", "SQUAREETREAD", "SQUARE_Set"], "A": ["Ac", "API", "D", "Ma", "Act", "au", "GA", "What", "SA", "TA", "AE", "And", "One", "L", "Y", "Count", "Num", "AY", "DA", "H", "M", "NA", "Am", "This", "ABC", "App", "U", "AD", "W", "Ar", "O", "CA", "E", "a", "V", "X", "An", "mA", "Ak", "R"], "B": ["P", "Q", "WB", "QB", "DB", "Z", "D", " b", "FB", "GB", "IB", "UB", "OA", "AB", "I", "b", "BF", "BW", "RB", "LB", "M", "BM", "BU", "VB", "Ab", "PB", "SB", "HB", "NB", "BL", "Bs", "G", "U", "BER", "BR", "BC", "CB", "BB", "BE", "BS"], "count": ["l", "add", "size", "z", "case", "max", "error", "col", "seq", "n", "b", "value", "found", "call", "span", "all", "stats", "type", "child", "ch", "id", "resp", "list", "val", "num", "match", "race", "length", "skip", "base", "e", "depth", "weight", "counter", "y", "start", "check", "C", "long", "code"], "ss": ["css", "mm", " SS", "DB", "Z", "pl", "pp", "bl", "cc", "ASS", "ess", "sw", "H", "xx", "au", "su", "M", "ross", "NUM", "all", "SB", "acc", "ass", "oss", "SA", "ds", "ress", "pos", "BL", "R", "asp", "MS", "SH", "bs", "str", "ct", "iss", "WS", "BC", "BB"], "f": ["l", "fun", "ff", "fff", "z", "rf", "uf", "api", "feed", "df", "t", "ref", "fit", "fi", "sf", "b", "loop", " df", "fd", "found", "n", "inf", "r", "fast", "fe", "stream", "fen", "fc", "fb", "tf", "k", "forum", "d", "bf", "m", "form", "file", "handler", "fr", "io"], "T": ["P", "Q", "Case", "TS", "Z", "D", "t", "GT", "H", "I", "M", "NT", "TC", "type", "TG", "WT", "TF", "Time", "time", "TA", "G", "U", "TN", "TI", "W", "O", "Total", "E", "TL", "C", "S", "V", "L", "X", "TT", "Y", "Count", "CT", "F", "K"], "x": ["xb", "l", "ex", "qu", "j", "z", "size", "t", "max", "u", " X", "dx", "xxx", "col", "n", "r", "xx", "ux", "xf", "xy", "int", "xi", "xc", "d", "id", "m", "wx", "ax", "val", "rx", "row", "ct", "ix", "e", " xx", "h", "y", " index", "code", "q"], "v": ["l", "qv", "nv", "j", "vd", "z", "values", "t", "u", "iv", "va", "n", "r", "value", "Val", "vm", "ve", "ev", "tv", "sv", "uv", "k", "lv", "d", "Value", "m", "cv", " V", "val", "vert", "vid", "vs", "e", "temp", "version", "h", "var", "y", "V", "q"]}}
{"code": " \n  \n  INPUT = \"tiny\"\n  \n  INPUT = \"B-small-attempt0.in.txt\"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  def zdebug(*args):\n      print ''.join(str(s) for s in args)\n  \n  def can_score_p(N, p):\n      low_p = max(p-1, 0)\n      if low_p + low_p + p <= N:\n          return \"Y\"\n      low_p = max(p-2, 0)\n      if low_p + low_p + p <= N:\n          return \"S\"\n      return \"N\"\n  \n  def do_trial(N, S, p, *scores):\n      d = { \"Y\" : 0, \"N\" : 0, \"S\" : 0 }\n      for s in scores:\n          v = can_score_p(s, p)\n          debug(\"score %s p=%s : %s\" % (s, p, v))\n          d[v] = d[v] + 1\n      return d[\"Y\"] + min(d[\"S\"], S)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      l = [int(x) for x in f.readline()[:-1].split()]\n      v = do_trial(*l)\n      print \"Case #%d: %s\" % (i+1, v)\n", "substitutes": {"INPUT": ["InInput", "SULT", "InPUT", "INLA", "SST", "SPUT", "inInput", "XPUT", "inENT", "INST", "ILFF", "InULT", " INInput", "SInput", "XFF", "ILST", "InFILE", "INENT", "SFILE", "InENT", " INST", "INULT", "inPUT", "XLA", "ILLA", "inFILE", "ILPUT", "XST", " INFF", " INLA", "INFILE", "INFF", "InST", "SENT", " INULT", "INInput"], "s": ["t", "input", "b", "tests", "all", "stats", "function", "us", "tp", "service", "o", "h", "y", "string", "c", "params", "g", "sb", "si", "j", "lines", "out", "r", "ses", "python", "se", "sync", "m", "ns", "os", "spec", "sp", "ls", "ssl", "a", "w", "gs", "es", "ins", "u"], "N": ["P", "Q", "Na", "min", "z", "Z", "D", "Size", "H", "n", "I", "NC", "M", "NA", "AN", "A", "NT", "NG", "Max", "NN", "NE", "ns", "G", "No", "num", "U", "NM", "o", " n", "GN", "Ni", "Ns", "W", "O", "Num", "OUT", "E", "Sn", "C", "Ne"], "p": ["P", "ip", "j", "z", "pp", "pl", "py", "t", "u", "api", "args", "n", "lp", "b", "pe", "cp", "r", "pair", "op", "pr", "python", "jp", "np", "k", "dp", "pa", "m", "wp", "pot", "po", "pi", "tp", "point", "bp", "o", "vp", "up", "pc", "ap", "e"], "low_p": ["old_pi", "old_lp", "low9c", "low25pe", "low64ps", "low9p", " low_s", "low_c", "low64point", "old_point", "low25p", "low50ps", "low_lp", "low64p", "old_c", "low9lp", "lowacpre", " low_pe", "old_P", "low25P", "low50c", "low_n", "low9h", "low50point", "lowacn", "old_n", "lowacp", "low_point", "low_pre", "low25n", " low_n", "old_p", "low50p", "low_ps", "low_P", "old_h", "lowacP", " low_P", "old_pre", "low_pe"], "S": ["P", "Q", "Z", "D", "u", "ss", "H", "n", "I", "M", "A", "SN", "G", "U", "SE", "Ns", "W", "O", "E", "SC", "SP", "OS", "C", "V", "Si", "L", "X", "Y", "K", "B", "F", "IS", "ST", "SI", "PS", "SS", "NS", "R"], "d": ["ld", "dc", "j", "z", "vd", "D", "t", "df", "u", "xd", "bd", "n", "r", "b", "fd", "md", "cd", "de", "data", "did", "st", "dl", "db", "dat", "sync", "do", "k", "ds", "dict", "td", "rd", "m", "ded", "dn", "di", "o", "ct", "dom", "da", "e"], "v": ["P", "qv", "nv", "vd", "j", "z", "t", "u", "va", "iv", "nov", "vari", "ov", "n", "r", "b", "value", "vm", "trial", "ve", "ev", "sv", "uv", "tv", "k", "volt", "li", "lv", "m", "vy", "cv", "val", " V", "vp", "o", "vt", "vert", "ou", "vs", "vid"], "f": ["t", "feed", "rb", "ref", "fit", "input", "fi", "b", "inf", "stream", "fen", "fc", "frame", "file", "handler", "fr", "io", "proc", " F", "lf", "conf", "h", "fw", "af", "c", "fp", "g", "fo", "j", "lines", "df", "r", "sf", "fe", "bf", "m", "tab", "buff", "a", "ft"], "T": ["P", "Q", "DT", "TS", "size", "Z", "D", "Ti", "t", "GT", "H", "I", "n", "M", "A", "type", "VT", "TC", "Ts", "TG", "TF", "WT", "TA", "G", "U", "TN", "TI", "length", "W", "O", "Total", "E", "TL", "C", "V", "L", "X", "number", "TT", "Y"], "i": ["ai", "ip", "j", "z", "u", "t", "n", "I", "b", "r", "ui", "phi", "uri", "int", "xi", "ie", "k", "bi", "li", "id", "pos", "m", "iu", "uni", "pi", "ni", "o", "mini", "end", "e", "h", "zi", "y", "start", "a", "c", "ii", "w", "ini", "ind"], "l": ["le", " L", "j", "z", "t", "u", "n", "lp", "b", "wl", "dl", "left", "ell", "ln", "ly", "k", "li", "fl", "ql", "m", "Li", "line", "o", "ol", "e", "lf", "il", "ls", "vl", "y", "len", "long", "L", "c", "el", "lc", "g", "ll", "nl", "sl"], "x": ["ex", "j", "z", "u", "max", "t", " X", "dx", "xxx", "n", "r", "I", "xx", "b", "_", " y", "trial", "xy", "int", "xi", "xc", "k", "ch", "id", "m", "time", "ax", "xt", "o", " c", "ct", "ix", " z", "e", "xs", "h", "y", "a", "q", "L"]}}
{"code": " \n  \n  def is_palindromic(i):\n      n = i\n      rev = 0\n      while i > 0:\n          dig = i % 10\n          rev = rev * 10 + dig\n          i = i // 10\n      return n == rev\n  \n  def is_square(i):\n      if i == 1:\n          return True\n      x = i // 2\n      seen = set([x])\n      while x * x != i:\n          x = (x + (i // x)) // 2\n          if x in seen:\n              return False\n          seen.add(x)\n      return True\n  \n  def f(a, b):\n      tot = 0\n  \n      sra = a\n      while not is_square(sra):\n          sra += 1\n      srb = b\n      while not is_square(srb):\n          srb -= 1\n  \n      sra = int(sqrt(sra))\n      srb = int(sqrt(srb))\n  \n      for i in range(sra, srb+1):\n          if is_palindromic(i) and is_palindromic(i ** 2):\n              tot += 1\n  \n      return tot\n  \n  if __name__ == '__main__':\n      T = int(input())\n      for i in range(T):\n          a, b = map(int, input().split())\n          r = f(a, b)\n          print('Case #{}: {}'.format(i+1, r))\n", "substitutes": {"i": ["l", "ti", "t", " I", "fi", "ih", "qi", "phi", "uri", "int", "multi", "ei", "id", "o", "io", "ig", "h", "y", "start", "c", "g", "ini", "ci", "si", "lo", "j", "ri", "im", "isi", "xi", "bi", "m", "er", "ni", "ix", "mini", "hi", "ed", "w", "gi"], "n": ["l", "adj", "j", "z", "t", "u", "s", "v", "np", "bin", "ne", "init", "ln", "nor", "k", "bi", "d", "p", "m", "ns", " N", "ni", "N", "rec", "o", "rn", "nb", "e", "nt", "nc", "h", "cn", "len", "sn", "f", "c", "number", "g", "w", "nu"], "rev": ["abc", "vision", "dec", "int", "init", "nr", "id", "re", "rank", "round", "ctr", " prev", "prev", "val", "h", "inv", "c", "Rev", "root", "ren", "tri", "j", "nov", "iter", "order", "gen", "rd", "err", "year", "w", "sub", "R", "index", "iv", "k", "d", "block", "num", "res", "N"], "dig": ["log", "exp", "reg", "tip", "dc", "min", "desc", "ref", "rand", "cd", "md", "circ", "dim", "de", "dem", "ord", "dec", "db", "init", "ment", "ie", "gen", "day", "rd", "d", "pos", "id", "cr", "ded", "round", "digit", "orig", "rib", "num", "rod", "row", "mod", "line", "rep", "ig"], "x": ["ex", "l", "t", "xd", "abc", "xx", "inf", "int", "sex", "id", "rx", "tx", "xs", "h", "y", "c", "g", "px", "ci", "j", "cross", "xy", "xi", "xxxx", "m", "time", "ix", "hi", "act", " index", "code", "X", "xa", "w", "xp", "index", "ox", "u", "dx", "s"], "seen": ["section", "closed", "new", "selected", "connected", "checked", "complete", "saw", "loc", "set", "written", "finished", "seq", "shown", "found", "sa", "lost", "hidden", "left", "existing", "established", "see", "events", "bidden", "id", " unseen", "sect", "sent", "used", "sequence", "registered", " observed", "signed", "confirmed", "matched", "sha", "inc", "served", "given", "original"], "a": ["ak", "aa", "l", "ai", "wa", "sta", "ab", "z", "ama", "alpha", "art", "u", "api", "va", "am", "s", "au", "ba", "sa", "A", "asa", "ao", "int", "ie", "aw", "area", "ata", "d", "p", "ra", "ae", "ga", "na", "ax", "o", "ac", "ya", "la", "da", "ea"], "b": ["bar", "xb", "l", "j", "ab", "z", "abb", "br", "ib", "rb", "u", "bb", "arb", "ba", "v", "s", "range", "wb", "db", "bh", "fb", "bi", "d", "be", "p", "bf", "eb", "bc", "bs", "bis", "mb", "o", "ac", "bot", "lb", "bur", "nb", "e", "base", "cb"], "tot": ["ttOT", "eot", "toti", "totaloto", "tempot", "doti", "totalot", "tots", "totalott", "retots", " tott", "retot", "Toby", "toby", "total", "dot", "ttot", "tOT", "bott", "retotal", "tott", "eotal", "dott", "toto", "totaloti", "ttoby", "bot", "retott", "eots", "Tot", "ttoti", "tempoti", "doto", " toto", "bots", "TOT", "tempoby", "tempOT", "botal", "Toti"], "sra": ["dsara", "zra", "insru", " sla", "zta", "asru", "dsra", "psru", "southras", "psara", "asras", "insra", " sha", "fran", "alsri", "sran", "serum", "seran", "sara", "fra", "alsta", "alstra", "dsran", "psras", "sta", "Srb", "southra", "psra", "ssma", "insara", "sesru", "sma", "Sla", "asra", "dsrum", "sla", "ssha", "fara", "sras", "Sma"], "srb": ["dsrf", "southrt", "dsru", "src", "southru", "dsra", "serb", "isra", "psru", "rsruby", "dsrt", "dsvr", "wsra", " swb", "lsruby", " sru", "wserb", " sreb", " sruby", "gserb", "ansrt", " srf", "gsra", "dsreb", "sru", " sr", "psrc", "southrb", "southvr", "sr", "srob", "ansrob", " src", "wsru", "ansru", " serb", "dsrc", "lsrb", "isrb", "swb"], "T": ["P", "Q", "TS", "Z", "D", "TH", "t", "H", "I", "TR", "M", "A", "NT", "TC", "WT", "TF", "Time", "time", "TA", "G", "U", "N", "TN", "TI", "W", "O", "E", "C", "Length", "S", "V", "L", "X", "TB", "TT", "Y", "PT", "B", "K", "F"], "r": ["rl", "ir", "br", "ur", "rb", " R", "right", "t", "mr", "error", "hr", "Rs", "range", "pr", "v", "rg", "rar", "k", "nr", "rd", "d", "id", "p", "rt", "m", "cr", "ro", "re", "lr", "err", "er", "res", "str", "ru", "row", "rec", "sr", "e", "result", "reb"]}}
{"code": " \n  T = int(raw_input())\n  for i in xrange(T):\n      values = map(int, raw_input().split())\n      [N,s,p] = values[0:3]\n      t = values[3:]\n      answer = 0\n      for note in t:\n          if note < 2:\n              if note >= p:\n                  answer += 1\n          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n              answer += 1\n          elif note % 3 == 0:\n              n = note / 3\n              if n >= p:\n                  answer += 1\n              elif s > 0 and n + 1 >= p:\n                  answer += 1\n                  s -= 1\n          elif note % 3 == 2:\n              n = (note - 2) / 3\n              if n + 1 >= p:\n                  answer += 1\n              elif s > 0 and n + 2 >= p:\n                  answer += 1\n                  s -= 1\n      print 'Case #{0}: {1}'.format(i+1, answer)\n", "substitutes": {"T": ["P", "J", "Q", "TS", "Z", "D", "Size", "ti", "H", "I", "period", "Note", "M", "trial", "A", "NT", "Test", "TW", "Time", "time", "TA", "tips", "G", "sequence", "TN", "TI", "length", "W", "O", "Total", "E", "C", "Length", "S", "V", "L", "X", "number", "TT", "Y"], "i": ["ip", "j", "z", "chi", "u", "ti", "iter", "I", "count", "v", "inf", "ui", "qi", "slice", "uri", "int", "xi", "ie", "bi", "k", "li", "d", "id", "m", "iu", "uni", "position", "x", "pi", "di", "o", "ix", "mini", "info", "end", "e", "zi", "y", "start", "a"], "values": ["versions", "ones", "lines", "keys", "args", "ims", "sets", "forms", "Values", "ms", "verts", "eps", "value", "v", "letters", "strings", "data", "tests", "stats", "ips", "frames", "errors", "events", "uments", "blocks", "lists", "objects", "notes", "settings", "ns", "fields", "flows", "val", "maps", "times", "details", "places", "cases", "terms", "types"], "N": ["P", "J", "Q", "Z", "D", "H", "I", "Note", "M", "A", "NT", "NP", "NN", "ns", "G", "U", "num", "Ni", "Ns", "W", "O", "E", "Sn", "C", "S", "V", "L", "X", "Y", "K", "B", "F", "Me", "NS", "R", "nu"], "s": ["l", "b", "name", "multi", "o", "steps", "comments", "ans", "Ns", "names", "ments", "y", "string", "c", "g", "strings", "si", "speech", "j", "lines", "size", "sets", "ses", "less", "sync", "qs", "m", "site", "ns", "notes", "x", "yes", "its", "os", "ops", "sp", "ls", "a", "w", "groups"], "p": ["P", "l", "exp", "ip", "j", "z", "pp", "py", "u", "api", "after", "primary", "r", "b", "lp", "pr", "v", "pe", "op", "port", "python", "cp", "post", "jp", "np", "app", "part", "k", "parent", "current", "pos", "d", "m", "wp", "er", "pi", "tp", "vp", "point", "o"], "t": ["P", "l", "text", "j", "z", "u", "ti", "b", "v", "value", "ot", "tt", "Note", "int", "type", "tm", "d", "ott", "m", "time", "table", "x", "ta", "tp", "sequence", "o", "comments", "e", "temp", "h", "y", "pt", "f", "a", "q", "tr", "c", "g", "w", "ut"], "answer": ["address", "au", "music", "write", "name", "area", "integer", "round", "nee", "ta", "Answer", "field", "option", "grade", "offset", "approximately", "video", " answers", "string", "question", "update", "support", "image", "appropriate", "size", "issue", "eni", " answered", "bring", "say", "value", "practice", "term", "python", "duration", "array", "order", "next", "element", "ell"], "note": ["study", "key", "ot", "all", "music", "int", "ne", "write", "name", "multi", "phone", "line", "o", "grade", "nb", "y", "c", "question", "g", "si", "speech", "tip", "notice", "j", "size", "voice", "case", "set", "term", "Note", "order", "np", "dat", "sync", "m", "notes", "sequence", "ni", "no", "year"], "n": ["l", "j", "z", "null", "u", "out", "pn", "one", "b", "v", "node", "term", "ot", "left", "all", "np", "net", "ne", "it", "ln", "name", "k", "d", "m", "na", "dn", "ns", "x", "ni", "pi", "num", "o", "nb", "e", "nt", "nc", "no", "cn", "nn", "ny"]}}
{"code": " \n  \n  FILE_NAME_BASE = 'C-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  \ta, b = (int(x) for x in inp.readline().split())\n  \treturn a, b\n  \n  def isFair(x):\n  \tl1 = list(str(x))\n  \tl2 = list(l1)\n  \tl2.reverse()\n  \treturn l1 == l2\n  \n  def solve(a, b):\n  \tc = 0\n  \tfor i in xrange(a, b + 1):\n  \t\tr = int(sqrt(i))\n  \t\tif r * r == i and isFair(i) and isFair(r):\n  \t\t\tc += 1\n  \n  \treturn str(c)\n  \n  def main():\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\n  \n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\n  \tnumCases = int(inp.readline())\n  \tif NUM_PROCESSES == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(NUM_PROCESSES)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n  \n  if __name__ == '__main__':\n  \tmain()\n", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_BEASH", "FILE_NAME_FAME", "FILE_NAME__BASH", "FILE_NAMEPBAME", "FILE_NAME_BUAME", "FILE_NAME_OBAS", "FILE_NAME_BAME", "FILE_NAME__BASE", "FILE_NAME_FASE", "FILE_NAME_ABASE", "FILE_NAME_BEAME", "FILE_NAME_OBASE", "FILE_NAME_FASH", "FILE_NAME_ABAS", "FILE_NAME_BASH", "FILE_NAME_BEAS", "FILE_NAME_BUASE", "FILE_NAMEPBASE", "FILE_NAME_ABAME", "FILE_NAME_BUAS", "FILE_NAME__BEAME", "FILE_NAMEPBAS", "FILE_NAME__BEASH", "FILE_NAME_OBAME", "FILE_NAME_BEASE", "FILE_NAME__BAS", "FILE_NAME_OBASH", "FILE_NAME__BAME", "FILE_NAME_BAS", "FILE_NAME__BEASE"], "NUM_PROCESSES": ["NUM_PROCECes", "NUM_PROCOSSIONS", "NUM_PROCOCS", "NUM_PRECECes", "NUM_PROCESSS", "NUM_PROGRECS", "NUM_PRECESSes", "NUM_PROCESSORS", "NUM_PROCERes", "NUM_PROCOCKS", "NUM_PROCESSKS", "NUM_PROCECES", "NUM_PROGRECURES", "NUM_PROCESSERS", "NUM_PROCITES", "NUM_PROTACTIONS", "NUM_PROCNECTes", "NUM_PROCCEPTES", "NUM_PROTACTes", "NUM_PROCERURES", "NUM_PROCCEPTes", "NUM_PROGRECes", "NUM_PROCOCes", "NUM_PROTACTURES", "NUM_PROTESSes", "NUM_PROCECIONS", "NUM_PROCECKS", "NUM_PROTESSIONS", "NUM_PROCECS", "NUM_PROCERES", "NUM_PROCACTERS", "NUM_PROCNECTERS", "NUM_PROCOCES", "NUM_PROCACTes", "NUM_PRECESSORS", "NUM_PROTACTES", "NUM_PROTESSURES", "NUM_PROCESSes", "NUM_PRECESSES", "NUM_PRECESSERS"], "MEM_LIMIT_GB": ["MEM_LIMITED_GB", "MEM_LIMITE_MB", "MEM_LIMITED_MM", "MEM_LIMIT2GP", "MEM_LIMITED_GP", "MEM_LIMITE_TB", "MEM_LIMIT_MB", "MEM_LIMITE_GW", "MEM_LIMIT_MM", "MEM_LIMIT_GP", "MEM_LIMIT_GW", "MEM_LIMIT2MB", "MEM_LIMIT_TB", "MEM_LIMIT2GB", "MEM_LIMIT2MM", "MEM_LIMITE_GB", "MEM_LIMITED_MB"], "RECURSION_LIMIT": ["RECURSION_LIGER", "RECURSION_LOBITS", "RECURSION_CLimITS", "RECURSION_CLIMER", "RECURSION_LIGIT", "RECURSION_LOBit", "RECURSION_LIGit", "RECURSION_LOBIT", "RECURSION_LONGit", "RECURSION_LOBITION", "RECURSION_LimITED", "RECURSION_LimITS", "RECURSION_LOBITED", "RECURSION_CLimITION", "RECURSION_LimITION", "RECURSION_CLIGER", "RECURSION_LIGITS", "RECURSION_CLIMITED", "RECURSION_LIMITS", "RECURSION_CLIGIT", "RECURSION_LIMITION", "RECURSION_LONGER", "RECURSION_LIGITED", "RECURSION_LONGIT", "RECURSION_CLimIT", "RECURSION_LOBER", "RECURSION_LimIT", "RECURSION_LIMITED", "RECURSION_CLIMITS", "RECURSION_CLIMIT", "RECURSION_CLIGit", "RECURSION_CLIGITED", "RECURSION_LIMER", "RECURSION_CLIMITION", "RECURSION_LONGITED", "RECURSION_LIGITION", "RECURSION_CLimITED", "RECURSION_CLIMit", "RECURSION_LIMit"], "inp": ["zinq", " inv", " infp", "insh", "inlp", "inf", " inh", "binf", "inic", " inpi", " inpc", "binc", "idpi", "INfp", " inP", "inh", "insb", "inc", "inipp", "zinp", "infp", " inpo", "inv", "inpc", "binpp", "inq", "insc", "kinP", " inb", " inlp", "inpp", " inproc", "inP", "Infp", "linpi", "Inq", "INh", "zinh", "inspo", "zinpp"], "a": ["ak", "aa", "l", "ai", "wa", "sta", "ab", "alpha", "za", "art", "u", "api", "va", "ada", "am", "oa", "n", "ba", "s", "au", "data", "A", "sa", "asa", "ao", "int", "aw", "area", "d", "p", "ae", "m", "ra", "o", "ac", "da", "la", "ea", "e", "ah"], "b": ["xb", "l", "aa", "j", "ab", "z", "abb", "boot", "ib", "u", "rb", "bb", "t", "n", "s", "v", "ba", "range", "wb", "db", "bh", "fb", "bi", "k", "d", "body", "p", "bf", "m", "eb", "be", "bc", "bs", "amb", "ob", "bis", "mb", "BB", "lb", "bur"], "x": ["ex", "l", "t", "input", "xx", "int", "list", "rx", "xs", "nc", "h", "y", "L", "string", "g", "px", "hex", "j", "data", "python", "array", "xy", "xi", "ix", "an", "code", "X", "xa", "w", "xp", "index", "es", "anything", "u", "I", "s", "xf", "content", "d", "ax"], "l1": ["ll1", "L1", " lone", "L0", "L13", "ll2", " l13", "llone", "L2", " l0", "li13", "l4", "l0", "ll4", " l4", "li11", "Lone", "l3", "li3", "L11", "li1", "l11", "L4", "L3", " l3", "li0", "li2", " l11", "l13", "lone"], "l2": ["L1", "lione", " lone", "Ltwo", "Li4", "L2", "L02", "l4", " l4", "li02", "Lone", "l3", "li3", "li1", "Li1", " l02", "ltwo", " ltwo", "Litwo", "L4", "Li2", "L3", " l3", "li2", "l02", "lone"], "c": ["co", "l", "roc", "dc", "sec", "z", "arc", "u", "ce", "t", "cc", "right", "cu", "n", "count", "s", "circ", "v", "cor", "uc", "cs", "unc", "fc", "int", "ec", "xc", "k", "ch", "d", "p", "m", "cr", "cy", "o", "ct", "ac", "pc", "e", "h", "cn"], "i": ["l", "ai", "ip", "ir", "j", "ij", "z", "arc", "ib", "u", "t", "ti", "ri", "api", "I", "s", "v", "n", "range", "qi", "ori", "ic", "yi", "phi", "it", "int", "xi", "uri", "iri", "ie", "bi", "li", "d", "id", "p", "re", "m", "iu", "pi", "rec"], "r": ["rl", "l", "ir", "j", "br", "ur", "rb", "u", "right", "ri", "t", "hr", "mr", "n", "range", "pr", "v", "s", "rar", "nr", "rt", "d", "ra", "p", "re", "m", "cr", "ro", "rd", "lr", "fr", "err", "er", "rx", "res", "ru", "o", "sr", "yr", "rev"], "soft": ["very", "mm", "ib", "server", "slow", "bit", "static", "little", "less", "free", "stable", "net", "simple", "protected", "low", "system", "us", "Soft", "micro", "allow", "fr", "gross", "used", "util", "local", "mini", "normal", "large", "force", "nz", "user", "use", "char", "forced", "safe", " Soft", "cost", "fast"], "hard": ["small", "weak", "adv", "middle", "external", "clear", "max", "rest", "windows", "core", "old", "count", "Hard", "dim", "press", "dr", "full", "vm", "live", "raw", "net", "int", "direct", "low", "limit", "dead", "rank", "work", "active", "cr", "allow", "deep", "high", "win", "reset", "remote", "client", "bound", "base", "large"], "numCases": ["numberNakes", "numPases", "numBases", "numConatches", "numConASE", " numTases", "numcakes", "numCakes", "numBats", "numTales", "numPodes", " numCASE", "numNases", "numCales", " numTodes", "numAcatches", " numCalls", "numPASE", "numcases", "numCodes", "numNase", "numCatches", "numCats", "numberCats", "numberCakes", " numTales", " numTASE", " numAcases", "numberNases", "numScales", " numCatches", "numConalls", "numPales", "numBakes", " numCodes", " numCales", "numberNase", "numNakes", "numcase", "numRecatches"], "results": ["versions", "includes", "values", "features", "RESULTS", "args", "complete", "windows", "forms", "changes", "stores", "reports", "locks", "allows", "images", "needs", "tests", "grades", "performance", "games", "memory", "errors", "events", "blocks", "words", "works", "rules", "outs", "ns", "settings", "details", "maps", "res", "response", "times", " Results", "cells", "ries", "cases", "runs"], "_": [" the", "ing", "___", "s", " all", "all", "k", "al", "d", "m", "val", "U", "ac", " block", "self", " v", "non", "__", "f", " non", "g", "ay", "un"], "pool": ["can", "wa", "graph", "rain", "page", "progress", "max", "pull", "server", "sw", "col", "process", "loop", "connection", "op", "call", "container", "port", "chain", "group", "conn", "full", "ha", "np", "net", "child", "ping", "batch", "app", "parent", "p", "box", "round", "host", "lock", "block", "res", "socket", "util", "row"], "out": ["log", "ex", "image", "engine", "exp", "exec", "Out", "new", "size", "unit", "error", "key", "connection", "job", "call", "conn", "group", "net", "bin", "write", "name", "again", "p", "work", "box", "manager", "file", "home", "outs", "err", "session", "lock", "block", "list", "res", "response", "table", "line", "o", "option"], "case": ["step", "section", "Case", "address", "config", "division", "shape", "ASE", "example", "mode", "ce", "stage", "call", "slice", "trial", "change", "chance", "ase", "cycle", "se", "choice", "default", "type", "cer", "ace", "position", "time", "lock", "sequence", "point", "match", "length", "client", "cases", "charge", "space", "rule", "bug", "base", "course"], "result": ["process", "function", "name", "re", "round", "runner", "table", "val", "request", "der", "test", "you", "instance", "root", "section", "ser", "obj", "iter", "df", "rate", "particip", "data", "group", "array", "item", "compl", "dict", "entry", "ret", "err", "output", "number", "date", "end", "error", "pair", "object", "back", "cup", "event"], "value": ["section", "answer", "values", "min", "size", "example", "key", "error", "unit", "valid", "max", "count", "v", "job", "data", "trial", "scale", "expression", "item", "total", "type", "default", "child", "name", "content", "memory", "part", "current", "Value", "id", "position", "VALUE", "index", "val", "num", "response", "search", "grade", "length", "version"]}}
{"code": " \n  FILE_NAME_BASE = 'B-small-attempt0'\n  NUM_PROCESSES = 0\n  \n  def parse(inp):\n  \tdata = tuple(int(x) for x in inp.readline().split())\n  \tdancers, surprises, points = data[ : 3]\n  \ttotals = data[3 : ]\n  \tassert len(totals) == dancers\n  \treturn totals, surprises, points\n  \n  def totalAtDist():\n  \t'''\n  \tIf a dancer's best result is b, the total can be:\n  \t  distance 0: 3b\n  \t  distance 1: [3b-2..3b-1]\n  \t  distance 2: [3b-4..3b-2]\n  \tNote: distance d is only possible if d <= b.\n  \n  \ttotal 15:\n  \tb = 0..4:  impossible\n  \tb = 5:     dist = 0\n  \tb = 6:     dist = 2\n  \tb = 7..10: impossible\n  \n  \tFor every total we have a number of explanations, which are\n  \t(b, d) pairs where b is the best result and d is the distance.\n  \n  \tThe output of this function shows:\n  \n  \tExcept for 0, 1, 29 and 30, every total t has exactly 2 explanations:\n  \t  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)\n  \tIn other words, always one surprise option and one normal option.\n  \tThe surprise option can have a result one higher than the normal one or\n  \tequal to it.\n  \t'''\n  \n  \tprint '  ',\n  \tfor b in xrange(0, 11):\n  \t\tprint 'b=%d' % b,\n  \tprint\n  \tfor total in xrange(0, 31):\n  \t\tprint '%2d' % total,\n  \t\tfor b in xrange(0, 11):\n  \t\t\ts = '0' if total == b * 3 else '.'\n  \t\t\ts += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'\n  \t\t\ts += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'\n  \t\t\tprint s,\n  \t\tprint\n  \n  \n  def solve(totals, surprises, points):\n  \tcountCertain = 0\n  \tcountSurprise = 0\n  \tfor total in totals:\n  \t\tif (total + 2) / 3 >= points:\n  \t\t\tcountCertain += 1\n  \t\telif 2 <= total <= 28 and (total + 4) / 3 >= points:\n  \t\t\tcountSurprise += 1\n  \t\telse:\n  \t\t\tpass\n  \n  \n  \treturn countCertain + min(countSurprise, surprises)\n  \n  if __name__ == '__main__':\n  \tinp = open(FILE_NAME_BASE + '.in.txt', 'r')\n  \tnumCases = int(inp.readline())\n  \tif NUM_PROCESSES == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(NUM_PROCESSES)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(FILE_NAME_BASE + '.out.txt', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_OBRC", "FILE_NAME_TBASE", "FILE_NAME_WBASE", "FILE_NAME_TBETA", "FILE_NAME_WBBS", "FILE_NAME_TBAS", "FILE_NAME_BRC", "FILE_NAME_BERC", "FILE_NAME_OBAS", "FILE_NAME_DBAS", "FILE_NAME_BBS", "FILE_NAME__BASE", "FILE_NAME_WBRC", "FILE_NAME_BEATH", "FILE_NAME_OBASE", "FILE_NAME__BBS", "FILE_NAME_DBASE", "FILE_NAME_BEAS", "FILE_NAME_DBATH", "FILE_NAME_BETA", "FILE_NAME_BEETA", "FILE_NAME_DBETA", "FILE_NAME_OBBS", "FILE_NAME_WBAS", "FILE_NAME_BEASE", "FILE_NAME_BATH", "FILE_NAME__BAS", "FILE_NAME_TBATH", "FILE_NAME_BAS"], "NUM_PROCESSES": ["NUM_PRCCESSes", "NUM_PRCCITERS", "NUM_PROCECes", "NUM_PROCOSSIONS", "NUM_PRECECes", "NUM_PRECESSes", "NUM_PROCProcessERS", "NUM_PROCESSORS", "NUM_PROGRESSGES", "NUM_PROCProcesses", "NUM_PROCITERS", "NUM_PRCCITIONS", "NUM_PROCODUCTERS", "NUM_PROCECES", "NUM_PROCITORS", "NUM_PROCITES", "NUM_PROCESSERS", "NUM_PROCNECTes", "NUM_PROCOSSGES", "NUM_PROCProcessORS", "NUM_PRECOSSES", "NUM_PROGRECGES", "NUM_PROGRECes", "NUM_PRCCESSES", "NUM_PROGRECORS", "NUM_PROCNECTIONS", "NUM_PROCECIONS", "NUM_PRCCESSERS", "NUM_PRCCESSIONS", "NUM_PRECESSURES", "NUM_PRECESSIONS", "NUM_PROCESSGES", "NUM_PROCNECTERS", "NUM_PROCACTes", "NUM_PRCCITES", "NUM_PRECESSORS", "NUM_PROCESSes", "NUM_PRECESSES", "NUM_PRECESSERS", "NUM_PROCOSSES"], "inp": [" inz", "insh", "inf", "inpa", "inpl", "zinpy", " inh", " inpr", "inpy", "inic", "innz", " inpy", " inP", "inh", "insb", "inc", "zinp", "insf", " Inp", "inv", "inps", "nincp", "ninp", " inb", "ninb", "iniproc", " inproc", "inpr", "inP", "innh", "INh", "iniv", "Inpl", "inipl", "arinps", "Inp", "inscp", "innpa", "insz", "inspa"], "data": ["aa", "text", "reader", "features", "lines", "size", "zip", "database", "alpha", "final", "feed", "complete", "api", "update", "ada", "input", "Data", "call", "DATA", "array", "next", "dat", "default", "parts", "batch", "content", "arr", "blocks", "dict", "buffer", "pos", "p", "d", "ata", "bytes", "na", "list", "details", "pad", "response"], "x": ["lo", "ex", "l", "z", "example", "t", "i", "max", "u", " X", "dx", "xxx", "n", "r", "xx", "v", "xf", "xy", "xi", "xc", "name", "content", "k", "ch", "d", "p", "m", "wx", "event", "ax", "rx", "num", "row", " c", "ct", "e", "xs", "nc", "h", "y"], "dancers": ["tances", "Dances", "ad100", "tiders", "Diders", "D100", "dancing", "tancer", "Dancer", "diders", "Dancers", " d100", "adancing", "dancer", "adancer", " diders", "d100", "Dancing", "adancers", " dancer", "dances", "tancers", " dances", " dancing"], "surprises": ["useprising", "typrises", "interplex", "urprising", "transprises", "serprising", "useventures", "transprising", "wraprising", "transplex", "serprises", "serventures", "Surfaces", "typrise", "interprises", "surfaces", "purprise", "wraprise", "urprises", "interprise", "surplex", "wraventures", "surprising", "purprises", "useprises", "transprise", "serfaces", "surprise", "typrising", "useprise", "surventures", "tyfaces", "urfaces", "wraprises", "Surprising", "Surplex", "Surprises", "serprise", "interprising", "purfaces"], "points": ["windows", "tests", "stats", "breaks", "downs", "pot", "objects", "charges", "maps", "point", "steps", "cells", "posts", "offs", "plugins", "pins", "ages", "planes", "dates", "pt", "pointers", "params", " positions", "quant", "ones", "elines", "lines", "amps", "codes", "ids", "blocks", "tips", "notes", "chains", "details", "products", "series", "holes", "items", "pots"], "totals": ["totingals", "tigrals", "totsases", "tigrases", "towes", "Totsality", "tOTalls", "tensality", "totsality", "Totses", "tensals", "Totsases", "totsals", "Tottals", "totality", "tottels", "totses", "totases", "Totels", "towal", "Totsals", "Tottels", "totels", "tOTales", "totingales", "Totsalls", "totsales", "tottales", "tottals", "tOTaled", "totsal", "Totsaled", "Tottalls", "tensases", "Totalls", "totsels", "totalls", "towalls", "towales", "tottal"], "b": ["l", "abb", "t", "i", "rb", "all", "id", "o", "nb", "h", "y", "c", "g", "bas", "sb", "j", "ab", "bl", "bb", "r", "bi", "al", "limit", "bf", "m", "bc", "bs", "bp", "auto", "lb", "bound", "base", "cb", "bt", "a", "number", "B", "w", "beta", "br"], "total": ["mm", "t", "i", "volume", "scale", "all", "stats", "multi", "active", "gross", "ta", "tp", "lat", "posts", "h", "start", "c", "bas", "basic", "doc", "quant", "aa", "bl", "py", "complete", "valid", "percent", "less", "partial", "next", "dat", "average", "bi", "cz", "m", "bc", "ph", "auto", "local", "confirmed"], "s": ["t", "i", "statement", "stats", "us", "outs", "o", "steps", "comments", "conf", "h", "string", "c", "params", "g", "sb", "strings", "si", "lines", "ing", "sets", "ses", "sf", "js", "sync", "words", "qs", "m", "ns", "settings", "notes", "abs", "details", "its", "os", "spec", "ls", "ssl", "w", "gs"], "countCertain": ["countGeneral", "sumEverything", " countcertain", "sumGeneral", "CountCertain", " countSpecial", " countGeneral", "CountGeneral", "sumSpecial", "CountEverything", "sumcertain", "sumCertain", "countcertain", "countEverything", "Countcertain", "countSpecial", "CountSpecial", " countEverything"], "countSurprise": ["countSusception", "countsurprises", " countsurprises", " countSurprises", " countSurvey", " countsurception", "countSusprising", "countCurprise", "countSusvey", "countCurception", "countsurvey", "countSurprising", " countsurvey", "countSurprises", " countSurprising", "countSusprises", "countCurvey", " countsurprise", "countCurprising", " countSurception", "countsurprising", "countSurception", "countSurvey", "countsurprise", "countCurprises", "countSusprise", " countsurprising", "countsurception"], "results": ["versions", "includes", "features", "values", "fires", "RESULTS", "lines", "final", "complete", "forms", "changes", "stores", "shows", "reports", "locks", "views", "roots", "allows", "tests", "stats", "grades", "performance", "tops", "memory", "errors", "events", "blocks", "multi", "words", "works", "rules", "objects", "outs", "settings", "details", "maps", "res", "response", " Results", "waves"], "_": [" the", "Id", "ing", "___", "n", " all", "all", "k", " new", "id", "m", " un", "val", "U", "ac", " block", "self", "of", "non", "__", "a", "f", " an", "g", " non"], "pool": ["graph", "wa", "rain", "pl", "max", "pull", "sw", "process", "col", "loop", "connection", "job", "call", "op", "container", "port", "chain", "group", "full", "np", "child", "batch", "app", "function", "parent", "p", "work", "box", "round", "rig", "list", "lock", "block", "res", "socket", "util", "io", "client", "mix", "cache"], "out": ["log", "ex", "image", "exp", "exec", "Out", "new", "page", "obj", "error", "comment", "connection", "call", "op", "object", "full", "source", "group", "next", "net", "bin", "write", "name", "part", "parent", "again", "work", "outs", "inner", "list", "err", "lock", "prefix", "o", "io", "client", "writer", "up", "ou", "extra"], "case": ["step", "section", "Case", "config", "answer", "page", "example", "error", "ce", "path", "slice", "trial", "change", "ase", "choice", "type", "default", "name", "ace", "success", "match", "line", "cases", "rule", "base", "ance", "ice", "word", "tmp", "code", "catch", "instance", "resource", "sub", "test"], "result": ["section", "summary", "text", "page", "desc", "error", "final", "description", "df", "complete", "r", "particip", "pair", "profile", "group", "array", "item", "function", "compl", "back", "dict", "d", "current", "entry", "round", "ret", "event", "err", "success", "runner", "val", "list", "res", "response", "match", "search", "row", "draw", "request", "test"], "value": ["format", "section", "answer", "values", "example", "key", "unit", "max", "v", "model", "trial", "item", "expression", "type", "default", "function", "name", "content", "memory", "Value", "list", "VALUE", "val", "response", "match", "search", "end", "sample", "number", "index", "score", "test"]}}
{"code": " \n  def isPalindrome(n):\n      cn=str(n)\n      return (cn==cn[::-1])\n  \n  palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]\n  \n  \n  \n              \n          \n          \n  \n  \n  \n  def Solve(a,b):\n      num=0\n      for p in palinSqrt:\n          if a<= p**2 <=b: num+=1\n      return num\n  \n  \n  \n  def parse(infile):\n      a,b=map(int, infile.readline().split() )\n      return a,b\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  class Categorizer(dict):\n      def __init__(self,thelist,transform,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.AddList(thelist)\n          self.trunc=trunc\n      def AddList(self,thelist):\n          for item in thelist: self.Add( item )\n      def Add(self,object):\n          cat=self.transform( object )\n          if type(cat) is float:\n              cat=round(cat,trunc)\n          if self.has_key(cat):\n              self[cat].append( object )\n          else:\n              self[cat]=[object]\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-len(x[1]))\n          total=0\n          for i in items: total+=len(i[1])\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(len(val))) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,len(count),\n                                     (\"%.2f\"%(len(count)*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=[]\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=len(self[key])\n              avg+=len(self[key])*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=len(self[key])\n              stddev += len(self[key]) * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n          tot=0\n          for value in self.itervalues(): tot+=len(value)\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += len(self[key])\n             if nCount>tot/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n  \n  \n  \n  \n  class Counter(dict):\n      def __init__(self,thelist,transform=None,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.trunc=trunc\n          self.AddList(thelist)\n      def AddList(self,thelist):\n          if self.transform is not None:\n              for item in thelist: self.Add( self.transform(item) )\n          else:\n              for item in thelist: self.Add( item )            \n      def Add(self,object):\n          if type(object) is float:\n              object=round(object,self.trunc)\n          if self.has_key(object):\n              self[object]+=1\n          else:\n              self[object]=1\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-x[1])\n          total=0\n          for i in items: total+=i[1]\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(val)) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,count, (\"%.2f\"%(count*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=0\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=self[key]\n              avg+=self[key]*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=self[key]\n              stddev += self[key] * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n   \ttotal=sum(self.values())\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += self[key]\n             if nCount>total/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: x[1])[0]\n  \n  \n  def gen_primes():\n      \"\"\" Generate an infinite sequence of prime numbers.\n      \"\"\"\n      D = {}  \n      q = 2  \n  \n      while True:\n          if q not in D:\n              yield q        \n              D[q * q] = [q]\n          else:\n              for p in D[q]:\n                  D.setdefault(p + q, []).append(p)\n              del D[q]\n  \n          q += 1\n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n", "substitutes": {"n": ["l", "j", "z", "t", "r", "s", "node", "span", "nw", "conn", "np", "ne", "ln", "name", "nor", "k", "d", "m", "na", "dn", "ns", "x", "N", "o", "nat", "nb", "e", "Ns", "names", "nt", "nc", "nn", "ny", "y", "f", "sn", "nit", "c", "bn", "number"], "cn": ["css", "dc", "pn", "cc", "cin", "scl", "core", "abc", "cd", "cp", "conn", "cs", "np", "domain", "vc", "ln", "xc", "name", "ains", "cm", "cr", "na", "dn", "bc", "mc", "ns", "gn", "prefix", "ct", "csv", "rn", "nat", "CC", "cache", "nc", "nn", "ca", "aff", "cdn", "ain"], "palinSqrt": ["palinSQrf", "palinEsQrot", "palinPsQrot", "palinEsqrt", "palinPsqrt", "palinSqRT", "palinPsQrt", "palinSqurot", "palinPsQRT", "palinEsqRT", "palinSqsrot", "palinSQRT", "palinPsqrd", "palinSQrd", "palinSqsrf", "palinSQrt", "palinSsqrf", "palinSqsrt", "palinEsqrf", "palinEsQrf", "palinSQrot", "palinSqrf", "palinEsqrot", "palinSqrot", "palinEsQrt", "palinSqurd", "palinEsQRT", "palinSsqrd", "palinSqsRT", "palinPsqRT", "palinSsqrt", "palinSsqRT", "palinPsQrd", "palinSsqrot", "palinPsqrot", "palinSquRT", "palinSqurt", "palinSqrd"], "a": ["aa", "ai", "l", "wa", "ab", "ama", "alpha", "u", "va", "am", "oa", "r", "ba", "s", "au", " A", "A", "sa", "asa", "ha", "qa", "int", "aw", "ata", "area", "ae", "d", "m", "ga", "na", "x", "ua", "o", "ac", "da", "la", "ea", "e", "an", "ca"], "b": ["bar", "xb", "l", "j", "ab", "abb", "z", "obj", "ib", "rb", "bb", "blue", "emb", "r", "s", "v", "wb", "bel", "ba", "db", "bh", "bin", "fb", "orb", "bi", "ben", "d", "be", "bf", "eb", "m", "body", "bc", "bs", "ob", "x", "other", "bis", "mb", "bu"], "num": ["dim", "all", "lam", "int", "init", "name", "miss", "id", "nom", " N", "proc", "nam", "nb", " np", "c", "instance", "Num", "obj", "mon", "anon", "mom", "np", "gen", "al", "x", "ni", "umi", "no", "nm", "du", "X", "number", "off", "mem", "end", "index", "nu", "col", "node", "sam"], "p": ["P", "opt", "l", "aa", "ip", "j", "z", "pp", "br", "py", "t", "u", "case", "ref", "alpha", "r", "s", "cp", "pr", "v", "op", "A", "jp", "np", "d", "m", "wp", "x", "pi", "bp", "o", "rep", "ac", "pc", "ap", "e", " P", "sp", "img", "h"], "infile": ["INFile", "INfolder", "inline", "incfile", "outfolder", "infolder", "instream", " infilename", "incfilename", "outfilename", "incfolder", "inf", "inputfilename", "INhandle", " instream", "inhandle", "INf", "outline", "outFile", "inputf", "inputline", "outf", "INstream", "outhandle", "incFile", " inline", "INfile", "inputfile", "INfilename", "infilename", "inFile", "INline", "outstream", " inf", " inhandle"], "self": ["exc", "co", "l", "hw", "pp", "ref", "right", "false", "driver", "all", "hand", "function", "master", "name", "utils", "host", "list", "other", "cl", "request", "proc", "github", "conf", "h", "tmp", "c", "ctx", "g", "instance", "www", "j", "obj", "case", "ing", "public", "me", "r", "plugin", "data", "np"], "fname": ["filefile", "FName", "lfName", "filenames", " ffile", "Fpath", "afName", "fileName", "Ffile", " fName", "filename", "Fname", "lffile", "filepath", "fnames", "ffile", "fName", "afname", "lfpath", " fnames", "afnames", "lfname", "fpath", "affile"], "NumCases": ["NumChodes", "numAcodes", "numChase", "NumChAS", "NumAcodes", "NumCodes", "NumChalls", "NumRecalls", "NumConase", "NumChasing", "NumCasing", "numAcase", "NumCalls", "NumRecAS", "numCasing", "NumAcases", "NumACAS", "NumConasing", "NumCase", "NumChase", "numChalls", "NumAcasing", "numCodes", "NumAcase", "numCases", "numCAS", "numAcasing", "numAcases", "numCalls", "numChAS", "NumChases", "NumConases", "numCase", "NumConodes", "NumACase", "NumRecase", "NumRecases", "NumACalls", "NumCAS", "NumACases"], "caseNum": ["aseNum", " casenum", " caseNumber", "CaseNum", "testnum", "testNumber", "testNo", " caseNo", "caseNumber", "asenum", "caseNo", "CaseNo", "aseNo", " caseName", "CaseNumber", "testNum", "caseName", "casenum", "CaseName", "testName", "Casenum", "aseName"], "args": ["loc", "pres", "all", "stats", "int", "aw", "objects", "list", "other", "atts", "action", "GS", "ig", "start", "asm", "params", "g", "doc", "lines", "obj", "size", "py", "ras", "data", "allows", "array", "next", "np", "ass", "dict", "plays", "afi", "ns", "x", "abs", "ani", "ix", "spec", "w", "more"], "myCases": ["MyCases", "myTats", "myTased", "myCats", "MyAcases", "myCased", "MyAcats", "myAcats", "myCase", " myCase", "myCsases", "MyCased", " myCsased", "mycase", "MyAcased", "myCsats", "MyCase", " myCsasing", "myTases", "myAcase", "mycased", "mycasing", "myCsasing", "MyAcase", "myCsased", "myCsase", "myAcased", "myCasing", " myCsase", " myCased", "mycases", " myCsases", " myCasing", "MyCats", "myAcases", "myTase", "myAcasing"], "outfile": [" outFile", "tempfile", " outfilename", "OutFile", "inline", "exline", "tempf", "outfilename", "inf", "Outline", "tempfilename", "outline", "exfilename", "outFile", "Outfilename", "outf", "tempFile", "Outfile", "exFile", "exfile", "infilename", "inFile", " outf"], "iCase": ["iChance", "iCondition", "jiTest", "jiChance", "uProduct", "iProduct", "uCase", "eCondition", "icase", "iuCase", " iRace", "yiProduct", "jiCase", "eProduct", "IChance", "eChild", " iChance", "picase", "iTest", "ITest", "yiCondition", "eCase", " icase", "yiCase", "iChild", "iRace", " iTest", "piCase", "piRace", "iuRace", "piTest", "uChild", "iucase", "iuTest", "yiChild", "uCondition", "ICase"], "answer": ["address", "feed", "abc", "all", "name", "ace", "don", "Answer", "accept", "grade", "asm", " answers", "string", "question", "update", "add", "out", "say", "exit", "r", "rage", "data", "array", "next", "ell", "err", "ac", "output", "respond", "sub", "aj", "example", "null", "offer", "call", " Answer", "acc", "answered", "altern", "response"], "thelist": ["theirl", "thetable", " theline", " Thel", "THEbatch", "theList", " thecollection", "THElist", " Thecollection", "theseline", "thebatch", " Thelist", " thelists", "etheline", "thesetable", " thetable", "theirlists", " Thebatch", "THEl", "theline", "Thelist", "thelists", "etheList", "theirList", " theList", "ethelist", "Thelists", "theirlist", "ethel", "Thel", "theselist", "thecollection", "THEcollection", "TheList", "thel", " thel", " thebatch", "ethetable"], "transform": ["format", "shape", "text", "size", "target", "orient", "move", "help", "trans", "forms", "set", "process", "path", "range", "project", "dim", "feature", "port", "model", "shift", "scale", "init", "type", "function", "rot", "improve", "dict", "translation", "form", "time", "template", "consider", "track", "attribute", "align", "mask", "metadata", "delay", "Transform", "draw"], "trunc": ["Trunc", "Tracer", "traction", "theunc", "theraction", "trunk", "tactor", " tracer", "Trac", " trumb", " tractor", "theactor", " Trunk", " trunk", " trraction", "tunc", "Trunk", "TRunk", "TRac", "trraction", "tractor", "trac", "TRacer", "trumb", " Tracer", " Trumb", " Trunc", "tracer", "Trumb", " trac", "TRunc"], "item": ["link", "new", "anything", "page", "obj", "unit", "atom", "member", "example", "url", "container", "msg", "source", "order", "element", "name", "entry", "time", "hop", "other", "match", "ix", "original", "rule", "result", "method", "channel", "record", "user", "Item", "article", "index", "root"], "object": ["config", "text", "obj", "comment", "server", "Object", "project", "static", "future", "python", "array", "complex", "type", "struct", "function", "system", "parser", "integer", "objects", "er", "any", "json", "o", "module", "proc", "pattern", "result", "problem", "private", "bool", "string", "number", "float", "instance", "thread", "article", "void"]}}
{"code": " \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  for iCase in xrange(NumCases):\n      line=[ int(i) for i in infile.readline().split() ]\n  \n      n=line.pop(0)\n      s=line.pop(0)\n      p=line.pop(0)\n  \n      scores=line\n      assert(len(scores))==n\n  \n      imax=0\n      isurprise=0\n  \n      for score in scores:\n          if score<p: continue\n          if score<3*p-4:\n              pass\n          elif 3*p-2>score>=3*p-4:\n              isurprise+=1\n          else:\n              imax+=1\n  \n      print 'Case #'+str(iCase+1)+':',imax+min(isurprise,s)\n  \n", "substitutes": {"infile": ["innhandle", "inline", "incfile", "outfolder", "infolder", "innfile", "insfile", "Infile", "incfolder", "inf", "winf", "inchandle", "innf", "inhandle", "Inpipe", "inpipe", "outline", "inspipe", "winfile", "incline", "inshandle", "outhandle", "outfile", "insline", "winline", " inline", " infolder", "winfiles", "insf", " infiles", "Inhandle", "insfiles", "Inf", "innpipe", " inf", "infiles", " inhandle"], "NumCases": ["numcased", "NumCasses", "numScase", "NumCased", "numScased", "Numcases", "NumChasing", "numCased", "NumCasing", "numcases", "numcasing", "NumScase", "numCasing", "NumScased", "NumCase", "Numcasing", "NumChase", "NumScasing", "numScasses", "numCasses", "numcase", "numCases", "NumScases", "NumChased", "NumChases", "Numcase", "numCase", "Numcased", "numScases", "Numcasses", "NumScasses"], "iCase": ["iLoop", "iPath", "cCase", " iCourse", "iNumber", "ILoop", "iiNumber", "cCourse", "ICourse", "icase", "liName", "isiName", "liCase", "isiPath", "isiCase", " iLoop", "isiNumber", "iiPath", "iCourse", "liPath", " icase", "iiCase", "liNumber", "ccase", "iiName", "Icase", "cLoop", "iName", "ICase"], "line": ["l", "inline", "chain", "live", "all", "int", "frame", "name", "file", "list", "grade", "rule", "cle", "string", "c", "LINE", "log", "le", "lo", "lines", "case", "out", "iter", "data", "se", "item", "sync", "do", "entry", "time", "base", "code", "number", "liner", "strip", "band", "cell", "zip", "unit", "error"], "i": ["l", "ai", "ip", "j", "z", "chi", "eni", "u", " I", "I", "r", "b", "isi", "fi", "ui", "_", "it", "uri", "int", "xi", "k", "li", "ei", "d", "id", "ace", "m", "iu", " it", "x", "pi", "ni", "o", "io", " c", " j", "oi", "e", "start", "a"], "n": ["l", "un", "j", "size", "z", "pn", "t", "nan", "u", "r", "b", "count", "v", "span", "np", "net", "ne", "name", "k", "nr", "pos", "d", "m", "na", "ns", "x", "ni", "num", "N", "o", "nb", "e", "nc", "nn", "an", "cn", "no", "y", "en", "sn"], "s": ["small", "l", "j", "sec", "size", "z", "sq", "t", "u", "ss", "states", "r", "b", "v", "ses", "su", "span", "cs", "se", "sim", "sync", "sv", "ds", "side", "d", "m", "site", "sg", "ns", "settings", "south", "o", "os", "e", "spec", "ps", "series", "sp", "ls", "sites"], "p": ["P", "l", "ip", "j", "z", "page", "pp", "py", "t", "case", "u", "pn", "after", "r", "lp", "cp", "pr", "v", "b", "op", "span", "post", "python", "pair", "jp", "np", "type", "k", "pa", "pos", "d", "m", "pot", "prev", "x", "pi", "tp", "point", "o", "pc"], "scores": ["expores", "SCores", "SCases", "Scores", "escences", "scases", " Scases", "Scors", "expences", " scors", " Scors", " Scored", " Scores", " scored", "SCore", "scences", "scards", "exporer", "scors", "Score", "lcored", "lcanners", "escors", " Scards", "scored", "Scences", "scorer", "lcors", "escorer", "scanners", "Scards", "escores", "lcores", "Scorer", " Scanners", "expors", " scanners", "SCards", " Score", "Scases"], "imax": ["imAX", "IMagic", "imagic", "imaxy", "iamake", "immaze", "iamax", " imaze", " imaxy", " imAX", "simake", "imaze", " imac", "immax", "IMaze", "imase", "imac", "IMAX", "immac", "simaze", " imake", "IMac", "imake", "simase", "simax", " imase", "immAX", "IMake", "iamaze", "Imax", "IMax", "Imaxy", "Imagic", "Imake", "iamase", "IMaxy", " imagic"], "isurprise": [" isurcise", "issurantine", "isuperprise", "issurprise", "isurergest", "isaurprise", "isurervey", " isaurprising", " isurvey", "issurvey", " isaurprise", "isupercise", "Isaurprising", "iscurvey", "isaurprising", "isaurprises", "Isurprises", " isurgest", "isurcise", "isureantine", " isurprising", "Isurantine", "iscurprise", "iscurprises", "isurprises", " isaurvey", "iscurprising", "isureprises", "Isaurprise", "isureprising", "Isurprise", "isaurvey", " isaurcise", "isurerprise", "isupergest", " isaurprises", "isaurgest", "issurprises", "isaurcise", "isurgest"], "score": [" result", "path", "int", "ne", "name", "id", "rank", "ores", "o", "grade", "y", " test", "c", "size", "case", "core", "pro", "rate", " scoring", "Score", "go", "err", "x", "play", "nz", "ize", "scoring", "code", "pri", "number", "ore", "exp", " scorer", "pn", "error", "une", "cp", "uc", "trial", "k"]}}
{"code": " \n  lines = sys.stdin.readlines()\n  def parseCase(lines):\n      dims = map(int,lines[0].split(\" \"))\n      return 1, dims\n  \n  def getCases(lines):\n      i =0\n      while i < len(lines):\n          lines_used, case = parseCase(lines[i:])\n          i += lines_used\n          yield case\n  \n  \n  fands = []\n  phash = {1:True}\n  def isPalindrome(p):\n      return p in phash\n  \n  def test(p):\n      square = p**.5\n      return square == int(square) and isPalindrome(int(square))\n  \n  for i in range(1,10**5):\n      if i > 9:\n          small_p = int(i * 10 ** int(math.log(i,10)) + int(\"\".join(reversed(str(i)[:-1]))))\n      else: small_p = i\n      phash[small_p]= test(small_p)\n      if phash[small_p]: fands.append(small_p)\n      big_p = int(i * 10 ** int(math.log(i,10)+1) + int(\"\".join(reversed(str(i)))))\n      phash[big_p] = test(big_p)\n      if phash[big_p]: fands.append(big_p)\n  cNum =0\n  \n  for c in getCases(lines[1:]):\n      cNum += 1\n      answer = []\n      for i in fands:\n          if i < c[0]: continue\n          if i > c[1]: break\n          if phash[i]: answer.append(i)\n      answer = str(len(answer))\n      print \"Case #%d: %s\" % ( cNum, answer)\n  \n  \n      \n  \n  \n", "substitutes": {"lines": ["l", "sticks", "inline", "b", "tests", "breaks", "file", "objects", "cl", "line", "cells", "steps", "comments", "posts", "plugins", "pins", "xs", "lins", "strings", "books", "log", "lo", "elines", "sets", "ses", "locks", "codes", "les", "lights", "ids", "frames", "blocks", "qs", "rules", "users", "notes", "headers", "holes", "ls", "items"], "dims": [" dim", "Dim", "drims", "Ddim", " dums", "ddim", "dimims", "dim", "densions", " ddim", "diamond", "dums", "Dums", " densions", "Diamond", "Dims", "dimiamond", "drim", "dimim", " diamond", "drums", "Densions", "drdim", "dimensions"], "i": ["l", "alpha", "iw", "ti", "t", "fi", "input", "b", "qi", "phi", "uri", "int", "init", "multi", "area", "ei", "id", "line", "o", "io", "iq", "h", "y", "start", "g", "ini", "ci", "si", "j", "eni", "ri", "im", "r", "isi", "data", "xi", "bi", "m", "inner", "x"], "lines_used": ["lines_created", "cases_needed", "cases_created", "lines_needed", " lines_use", "cases_used", "cases_use", "lines_use", " lines_needed"], "case": ["mate", "section", "Case", "config", "text", "shape", "able", "page", "example", "key", "max", "mode", "ce", "cas", "feed", "path", "then", "cp", "pe", "call", "slice", "data", "chain", "ase", "se", "it", "type", "default", "function", "name", "ace", "id", "bc", "cl", "match", "line", "length", "cases", "base", "result"], "fands": ["fcanders", "fanded", "panders", "cants", " faps", "pands", " fando", "fances", "fcando", "xfants", "xfands", "xfando", "pants", "xfaps", " fances", "cands", "xfanders", "fanders", "canders", " fanded", " fanders", "cances", "fando", "fand", "landers", "laps", "pances", " fants", "panded", "fcand", "lands", "fcands", "lants", "xfand", "fants", "faps", "canded", " fand"], "phash": ["Phap", "phashed", "Phashes", "ghashes", "phah", " phashed", " phap", "uphashed", " phat", "hashes", "hash", "shash", "Phashed", "ghash", "uphashing", "ophash", "uphay", " phashes", "ghah", "shashes", " phart", "phashing", "shart", "phap", "aphashed", "thash", "shashed", "aphash", "phhash", "shhash", "thap", "thhash", "shashing", "hashing", "Phashing", "phat", "aphay", "ghhash", "Phhash", " phashing"], "p": ["P", "l", "ip", "j", "page", "pp", "alpha", "py", "t", "api", "u", "pl", "n", "lp", "r", "b", "v", "cp", "pr", "s", "op", "pair", "python", "circle", "jp", "np", "type", "ping", "part", "k", "d", "pos", "m", "po", " cp", "power", "x", "pi", "tp", "bp"], "square": ["piece", "alpha", "right", "shift", "scale", "pixel", "round", "sh", "cube", "repeat", "feature", "le", "image", "qu", "shape", "size", " squares", "circle", "se", "np", "angle", "x", "copy", "a", "shadow", "ape", "bar", "small", "same", "stri", "null", "cap", "style", "crop", "power", "pad", "row", "depth", "quad", "sc"], "small_p": ["small_data", "small_ps", "real_p", "smalliandata", "small54s", "small25p", "small33P", "smalliantp", "small_pe", " small_data", "small64p", "small25pe", " small_np", "smallThec", "smallianp", "small68tp", "small_q", "small67c", "small54ps", "real25p", " small_tp", "small68sp", "small_gap", "real25pe", " small_i", "small54p", "small64pe", "small_i", " small_php", "real25sp", "small33np", "small68gap", "small33c", "small68p", "small_n", "small_sp", "big_c", "small67p", "smallThep", "big_s"], "big_p": ["big_wp", "bigPp", "big25c", "significant25op", "big25i", "big_lp", "big_i", "big_op", "bigThep", "big25wp", " big_sp", "bigPsp", " small_pair", "large_n", "bigTheop", "big67pair", " small_part", " big_lp", "large_c", "big_c", "significant_pa", "big67P", "big_pair", "large_p", "significant_i", "big_sp", "big_pa", "big_P", "bigThesp", "bigThelp", "big67p", "bigThepart", "significant25i", "big25pa", "big_pi", " small_pi", "bigThepa", "big67pi", "big25p", "large_wp"], "cNum": ["CNum", "fnum", "pNum", " cNo", " cnum", " cLen", "CNo", "eInfo", "eNumber", "fNum", "CNumber", "cNo", "CNUM", "cInfo", "cnum", "CLen", "eNUM", "pNo", " cVal", "eNum", "cNumber", " cInfo", "cVal", "fLen", "cNUM", "CVal", " cNUM", "Cnum", "CInfo", "pLen", "pNumber", " cNumber", "cLen", "fVal"], "c": ["l", "z", "t", "cc", "u", "cin", "ce", "col", "cu", "n", "count", "b", "cd", "v", "s", "uc", "call", "ic", "unc", "toc", "cycle", "fc", "cs", "int", "content", "ch", "k", "li", "d", "m", "mc", "cv", "x", "cl", "match", "line", "ct", "ac", "cases", "e"], "answer": ["address", " result", "name", " explanation", "area", "ace", "field", "Answer", "option", "grade", "comments", "edge", " answers", "string", "question", "update", "support", "fee", "section", "notice", "size", "issue", " answered", "core", "say", "value", "term", "data", "duration", "array", "next", "order", "ell", "average", "do", "entry", "err", "settings", "sequence", "cache"]}}
{"code": " \"\"\"\n  GCJ framework (gcj.fw.framework)\n   - Command Line and Package interface\n   - output redirection\n   - parsing case input\n   - executing problem code against cases\n   - testing framework\n  \"\"\"\n  \n  class Framework(object):\n      class Case(object):\n          def __init__(self, caseNumber, caseData=None):\n              self.number = caseNumber\n              self.data = caseData\n              self.result = None\n      \n          @classmethod\n          def parser(cls, f_in):\n              pass\n      \n          def run(self):\n              pass\n      \n          def execute(self, f_in=None):\n              if self.data is None:\n                  self.data = self.parser(f_in)\n              self.result = self.run(**self.data)\n      \n          def __str__(self):\n              return \"Case #%d: %s\" % (self.number, self.result)\n      \n      \n      class Result(object):\n          def __init__(self, resultData):\n              self.data = resultData\n      \n          def __str__(self):\n              return str(self.ata)\n  \n      def __init__(self, f_in, f_out):\n          sys.stdout = f_out\n          self.f_in = f_in if f_in is not None else sys.stdin\n  \n      def run(self):\n          nCases = int(self.f_in.readline().strip())\n          for num in xrange(nCases):\n              case = type(self).Case(num+1)\n              case.execute( f_in=self.f_in)\n              print case\n  \n  \n      @classmethod\n      def __main__(cls):\n          f_in = sys.stdin\n          if len(sys.argv) > 1:\n              if sys.argv[1] == \"-t\":\n                  unittest.main()\n                  sys.exit()\n              f_in = open(sys.argv[1])\n          framework = cls(f_in, sys.stdout)\n          framework.run()\n      \n  class Test(unittest.TestCase):\n      cases = []\n      case = None\n      c=[]\n      \n      def setUp(self):\n          self.c = []\n          self.defineCases()\n          counter = 1\n          self.cases = []\n          for c in self.c:\n              case = self.case(counter)\n              case.data = case.parser(StringIO.StringIO(c[0]))\n              self.cases.append( [case, c[1]])\n      \n      def defineCases(self):\n          pass\n      \n      def tearDown(self):\n          pass \n  \n      def test_Name(self):\n          self.setUp()\n          for case in self.cases:\n              print case[0].data, case[1]\n              case[0].execute()\n              self.assertEqual(case[0].result, case[1])\n  '''\n  Created on Apr 8, 2012\n  \n  @author: Joe\n  '''\n  \n  \n  class B(Framework):\n      class Case(Framework.Case):\n          def parser(self, fh):\n              args = map(int, fh.readline().strip().split(\" \"))\n              N,S,p = args[:3]\n              scores = args[3:] \n              return {\"N\":N,\"S\":S,\"p\":p,\"scores\":scores}\n          \n          def run(self, N=None,S=None,p=None,scores=None):\n              ret = 0\n              surps = 0\n              for score in scores:\n                  if p > 0 and score == 0: continue\n                  if 3*p-2 <= score:\n                      ret += 1\n                  else:\n                      if 3*p - 4 <= score:\n                          surps += 1\n              return str(ret + min(surps,S))\n              \n  class Test(Test):\n      def defineCases(self):\n          self.case = B.Case\n          self.c = [\n                    [\"3 1 5 15 13 11\",\"3\"],\n                    [\"3 0 8 23 22 21\",\"2\"],\n                    [\"2 1 1 8 0\",\"1\"],\n                    [\"6 2 8 29 20 8 18 18 21\",\"3\"],\n                    [\"1 1 1 1\", \"1\"]\n                    ]\n  \n  if __name__ == \"__main__\":\n      B.__main__()\n      \n", "substitutes": {"self": ["exc", "co", "l", "hw", "progress", "i", "ref", "eth", "process", "b", "connection", "static", "false", "driver", "all", "hand", "master", "name", "function", "utils", "us", "system", "host", "other", "cl", "request", "proc", "github", "plugins", "lf", "h", "tmp", "first", "ctx", "g", "instance", "support", "sec", "obj", "ing"], "caseNumber": ["aseNum", "CaseNum", "catchNumber", " caseNo", "aseNumbers", " casenumber", "caseNumbers", "catchnumber", "aseNumber", "caseNo", " caseNumbers", "aseUnit", "CaseNo", "caseNum", "CaseNumber", "catchNo", "caseUnit", "CaseNumbers", "CaseUnit", " caseUnit", " caseNum", "casenumber", "Casenumber", "catchNum"], "caseData": [" casedata", " caseInfo", "catchdata", "trialType", " caseType", "casedata", "caseType", "conditionData", "testData", "caseResult", "testdata", "trialResult", "caseInfo", "catchData", "caseNum", " caseName", "conditionType", "catchName", "conditionResult", "caseName", "testName", "trialNum", " caseNum", "trialData", "testInfo", "conditionNum", "catchInfo", " caseResult"], "number": ["note", "address", "division", "size", "database", "unit", "error", "figure", "label", "reference", "n", "count", "pin", "span", "family", "object", "trial", "currency", "duration", "group", "order", "NUM", "expression", "direction", "type", "function", "name", "part", "document", "parent", "creator", "umber", "position", "category", "sequence", "language", "token", "gender", "length", "state"], "data": ["alpha", "key", "input", "Data", "connection", "model", "shift", "init", "name", "definition", "multi", "area", "id", "handler", "list", "json", "action", "analysis", "media", "test", "start", "string", "params", "root", "reader", "values", "size", "loader", "out", "rate", "value", "DATA", "group", "array", "next", "raw", "dat", "dict", "sequence", "client"], "result": ["format", "answer", "obj", "database", "target", "final", "error", "df", "comment", "description", "url", "rate", "r", "value", "model", "profile", "object", "duration", "source", "order", "item", "type", "default", "master", "name", "memory", "dict", "manager", "runner", "success", "res", "response", "match", "json", "metadata", "grade", "length", "test", "cache", "status"], "cls": ["pls", "methods", "CLs", "Clp", "Clses", " clp", "methodS", "Chsi", "clS", "clsi", "Clsi", "clses", "CLses", "plp", "Cls", "CLsb", "clclass", "Clsb", "methodsi", "Chsb", "clsb", "Clclass", "methodsb", "clp", "Chs", " clclass", "plclass", "methodses", "ClS", "CLS"], "f_in": ["f_bin", "fockIN", "f_In", "F_out", "f_IN", " f_ini", "f_ini", "sf_out", "form_ini", "fixout", "fLogins", "flexout", " flexout", "f_cin", "form__in", "c_out", " f__out", "fOCKin", "fockin", " f_instance", "f_input", "fockini", "f_din", " f__in", "c_din", " f_sin", "F_ini", "fixdin", " f_inf", " flexinstance", " flexin", "form__ini", "f__nin", "fileout", "f__bin", "fixin", " f__nin", " f_In", "form_in", "form__bin"], "resultData": ["exampleData", "responseDat", "errorBody", " resultString", "errorInfo", "responseArray", "resultDat", "responseName", "resultBody", " resultDat", "exampleString", "resultName", "exampleDat", "responseString", "responseInfo", "featureName", "responseData", "featureData", "errorName", "errorData", "resultInfo", " resultArray", "responseBody", "resultString", "exampleArray", "resultArray", "featureBody", "featureInfo"], "f_out": ["f2Out", "p_again", "f64again", "f2again", "f_again", "f_ins", "f2in", " f_again", "f_Out", "f64in", "f2out", " f_ins", "f64out", "p_out", "f64ins", "p_Out", "p_in"], "sys": ["exc", "wcs", "hw", "windows", "process", "shell", "struct", "frame", "utils", "system", "us", "re", "sh", "rx", "ystem", "tp", "service", "proc", "tmp", "pty", "ctx", "fp", "instance", "sb", "console", "www", "root", " system", "sec", "py", "misc", "exit", "ses", "python", "phys", "np", "sync", "func", "qs", "site"], "stdout": ["stdouts", "STDOut", "stdOut", "STDIN", "streamout", "streamoutput", "STDin", "standouts", "streamouts", "stdIN", " stdIN", "stdoutput", " STDIN", " stdin", "stdin", "standout", "streamin", " stdOut", "standin", "STDout", " STDout", " stdouts", " STDOut", " stdoutput", " STDin", "standoutput"], "nCases": [" nScased", "ncases", "nChakes", " nCased", "nClaces", " nScases", "nClased", "nCrasing", "ncaces", "nCrased", " nCaces", "nCrakes", "nClases", "nScakes", " nScasing", " nCasing", "nScasing", "nCaces", "nScaces", "nScased", "nChasing", "nCakes", "ncasing", "nCased", " nScakes", "nChased", "nScases", "nCrases", "nClasing", "ncased", "nCasing", " nScaces", "nChases", " nCakes"], "num": ["exp", "tri", "new", "i", "u", "out", "unit", "loc", "max", "lim", "col", "n", "nu", "zero", "node", "su", "uc", "dim", "nw", "NUM", "coord", "ord", "mom", "comb", "begin", "np", "int", "name", "k", "nr", "d", "id", "um", "rank", "m", "nom", "uni", "na", "umber", "x"], "case": ["address", "key", "i", "sea", "ce", "character", "path", "connection", "model", "shift", "chain", "ase", "name", "definition", "ace", "id", "phase", "table", "cl", "point", "line", "rule", "test", "place", "tmp", "switch", "string", "instance", "cast", "ride", "section", "cel", "contract", "set", "core", "me", "value", "project", "true", "cycle"], "framework": ["support", "config", "section", "browser", "example", "loader", "window", "df", "ow", "core", "hub", "loop", "node", "plugin", "model", "family", "forest", "theme", "fe", "element", "ception", "child", "frame", "app", "foundation", "system", "manager", "form", "runner", "web", "gui", "ework", "util", "eer", "client", "module", "ground", "fruit", "fork", "flower"], "cases": ["ceptions", "ces", "config", "Case", "features", "lines", "children", "closure", "sections", "sets", "forms", "changes", "casts", "forces", "uses", "reports", "shows", "codes", "uc", "cs", "tests", "errors", "breaks", "events", "blocks", "rules", "tips", "chains", "settings", "details", "fields", "ches", "charges", "times", "steps", "cells", "comments", "suits", "runs", "projects"], "c": ["exc", "l", "tc", "desc", "i", "t", "ce", "loc", "abc", "b", "chain", "all", "fc", "ec", "name", "mc", "category", "cl", "o", "cont", "ct", "coll", "nc", "h", "y", "g", "ci", "r", "cycle", "m", "bc", "x", "ac", "cache", "cb", "cn", "a", "code", "w", "Case"], "counter": ["step", "cur", "condition", "exp", "card", "page", "key", "ctrl", "comment", "server", "timer", "url", "abc", "sleep", "count", "loop", "static", "shift", "order", "child", "default", "batch", "Counter", "name", "parent", "current", "nr", "seed", "time", "category", "sequence", "field", "match", "race", "length", "cube", "cmp", "coll", "queue", "user"]}}
{"code": "def is_palindrome(s):\n  \tif s == '':\n  \t\treturn True\n  \telse:\n  \t\tif (ord(s[0]) - ord(s[len(s)-1])) == 0:\n  \t\t\treturn is_palindrome(s[1 : len(s) - 1])\n  \t\telse:\n  \t\t\treturn False\n  \n  all_fair_and_square = set()\n  for i in range(10000):\n  \torig = str(i)\n  \trev = orig[::-1]\n  \n  \tpalin = orig + rev\n  \tintpalin = int(palin)\n  \tif is_palindrome(str(intpalin * intpalin)):\n  \t\tall_fair_and_square.add(intpalin * intpalin)\n  \n  \tpalin = orig[:-1] + rev\n  \tintpalin = int(palin)\n  \tif is_palindrome(str(intpalin * intpalin)):\n  \t\tall_fair_and_square.add(intpalin * intpalin)\n  \t\n  \n  \n  t = int(sys.stdin.readline().strip())\n  for ii in range(t):\n  \tline = sys.stdin.readline().strip().split()\n  \ta = int(line[0])\n  \tb = int(line[1])\n  \tcount = 0\n  \tfor num in all_fair_and_square:\n  \t\tif (num >= a) and (num <= b):\n  \t\t\tcount += 1\n  \tprint \"Case #\" + str(ii + 1) + \": \" + str(count)\n  \n", "substitutes": {"s": ["l", "tests", "ows", "bis", "o", "comments", "request", "xs", "ments", "h", "string", "c", "uploads", "g", "sb", "resses", "strings", "si", "speech", "lines", "ships", "sets", "ses", "sf", "r", "js", "ves", "sync", "blocks", "qs", "words", "m", "ns", "sed", "settings", "abs", "x", "its", "ges", "os"], "all_fair_and_square": ["all_fair_with_private", "all_fair_and_private", "all_fair_and_Square", "all_fair_with_square", "all_fair_and_quad", "all_fair_andxfair", "all_fair_and_fair", "all_fair_andxsquare", "all_fair_with_Square", "all_fair_andxSquare"], "i": ["ai", "image", "ip", "ir", "j", "ite", "z", "eni", " ip", "ti", "u", "I", "r", "inn", "ih", "n", "qi", "qq", "ori", "it", "uri", "init", "xi", "ie", "isin", "li", "ei", "id", "p", "d", "m", "iu", "arin", "x", "ni", "pi", "mi", "di", " bi", "io"], "orig": ["exc", "pp", "alpha", "ref", "rb", "rest", "loc", "lim", "abc", "inf", "init", "good", "id", "ctr", "prev", "alt", "coll", "h", "tmp", "inv", "reg", "obj", "iter", "valid", "old", "r", "Orig", "data", "ord", "order", "raw", "origin", "gen", "ret", "x", "mini", "base", "iso", "pred", "history"], "rev": ["cur", "exp", "reg", "inter", "ren", "j", "min", "obj", "iter", "ref", "rest", "loc", "r", "range", "v", "pr", "reverse", "ev", "order", "acc", "ie", "gen", "dep", "nr", "id", "re", "cr", "ret", "err", "prev", "index", "val", "res", "rec", "block", "turn", "info", "inc", "rel", "vs"], "palin": ["spolin", "pelin", " pelin", "spatin", "pillin", "spinar", "cparin", "spillin", "Parin", "cpelin", " pillin", " palli", "spalan", "patin", "Pelin", " patin", "Polin", "lpinar", "polin", "cpolin", "lpalin", "Palan", "Patin", "sparin", "spalli", "palan", " parin", " pinar", "parin", "cpalin", " palan", "lpillin", "palli", "Palin", " polin", "lpalli", "spalin", "Palli", "pinar"], "intpalin": ["intpaban", "intpsinning", "ntpparin", "intfarin", "ntpelin", "intpaabil", "intbindal", "intpaalin", "intppalin", "intbalin", "intpalian", "intwalin", "intepinning", "intpalid", "incpalin", "incnpalin", "intPahn", "intpalli", "inttarin", "intpsarin", "intpolin", "intharin", "motpinning", "interparin", "intralin", "motepaban", "intpparin", "intPalli", "pointwarin", "intpralian", "intpaahn", "intfalian", "ntpalin", "intsparin", "intrali", "ntvarin", "incnpillin", "intpralid", "motparin", "intpaarin"], "t": ["l", "tip", "tc", "z", "size", "ti", "u", "n", "r", "lt", "v", "qt", "ot", "tt", "trial", "duration", "it", "total", "int", "type", "tm", "wt", "rt", "d", "p", "m", "template", "time", "tz", "ta", "tp", "x", "o", "e", "y", "start", "tick", "pt", "f", "q"], "ii": ["II", "note", "ai", "ci", "z", "chi", "py", "ti", "fi", "inf", "dim", "qi", "slice", "fe", "yi", "agi", "qa", "int", "xi", "init", "ne", "ie", "acc", "bi", "li", "ei", "iu", "uni", "sci", "ni", "mi", "di", "ali", "gu", "ix", "mini", "info", "ou", "bug", "img"], "line": ["strip", "log", "l", "section", "le", "cell", "text", "link", "lo", "page", "zip", "LINE", "inline", "out", "feed", "comment", "loc", "col", "r", "ge", "pe", "header", "data", "meta", "object", "chain", "source", "se", "ne", "frame", "parse", "sync", "do", "part", "tail", "side", "phase", "entry", "file", "none"], "a": ["aa", "ai", "l", "wa", "sta", "ab", "ama", "api", "u", "va", "am", "n", "ba", "au", "A", "asa", "sa", "qa", "area", "ata", "d", "ae", "p", "ana", "x", "ac", "la", "da", "ea", "e", "an", "ad", "ca", "aff", "y", "f", "c", "g", "fa", "ia"], "b": ["xb", "l", "aa", "j", "ab", "abb", "bl", "ib", "u", "rb", "bb", "emb", "n", "r", "ba", "v", "wb", "db", "fb", "pb", "k", "d", "be", "p", "eb", "bc", "bs", "ob", "x", "mb", "o", "bot", "lb", "bur", "gb", "nb", "e", "cb", "ad", "y"], "count": ["note", "log", "size", "z", "case", "error", "label", "key", "max", "col", "seq", "n", "found", "call", "group", "order", "total", "int", "type", "part", "id", "p", "die", "list", "match", "th", "length", "info", "offset", "base", "bug", "depth", "weight", "coll", "e", "nn", "no", "div", "counter", "len"], "num": ["text", "tri", "nov", "iter", "u", "loc", "lim", "sup", "col", "seq", "annot", "n", "node", "su", "dim", "mon", "nw", "coord", "NUM", "np", "bin", "int", "acc", "net", "name", "gen", "bi", "multi", "om", "id", "nom", "uni", "m", "bc", "x", "ni", "mid", "di", "prefix", "hom"]}}
{"code": " \n  t = int(sys.stdin.readline())\n  for i in range(t):\n  \tinputline = sys.stdin.readline().strip()\n  \tinputparams = inputline.split()\n  \n  \tn = int(inputparams[0])\n  \ts = int(inputparams[1])\n  \tp = int(inputparams[2])\n  \tvalidcount = 0\n  \tsurprisingcount = 0\n  \tfor j in range(n):\n  \t\tscore = int(inputparams[3 + j])\n  \t\tif (p + (p - 1) * 2) <= score:\n  \t\t\tvalidcount += 1\n  \t\telif ((p + (p - 2) * 2) <= score) and (p <= score):\n  \t\t\tsurprisingcount += 1\n  \n  \tprint \"Case #%d: %d\" % (i + 1, validcount + min(surprisingcount, s))\n", "substitutes": {"t": ["l", "tc", "z", "target", "u", "ti", "r", "b", "qt", "v", "ot", "tt", "python", "int", "type", "tf", "tm", "d", "m", "time", "tz", "ta", "tp", "x", "o", "e", "temp", "h", "y", "start", "tick", "pt", "f", "the", "c", "task", "title", "tim", "T", "dt"], "i": ["lo", "l", "ip", "ij", "z", "chi", "ib", "ti", "u", "col", "I", "im", "v", "ui", "slice", "python", "uri", "int", "xi", "type", "ie", "bi", "k", "li", "d", "id", "pos", "m", "iu", "index", "x", "pi", "o", "io", "ix", "mini", "e", "h", "counter", "y"], "inputline": ["outputline", "inputpage", " inputlin", "inputlin", " inputfile", " inputlines", "inputLine", "outputpage", "inputlines", "Inputlines", " inputLine", " inputpage", "viewLine", "outputfile", "Inputline", "Inputlin", "viewlin", "Inputfile", "InputLine", "outputlines", "viewline", "viewlines", "Inputpage", "inputfile"], "inputparams": ["outputline", "paramparams", "outputshape", "latline", "Inputpar", "inputams", "paramparam", "inputParameters", "intams", "outputparams", "innerpar", "Inputline", "reviewlist", "inputparam", "inputlist", "intparam", "outputParameters", "parambase", "InputParameters", "reviewparam", " inputParameters", " inputparam", "reviewparams", "latams", "intline", "outputbase", " inputbase", "Inputparam", "latparams", "outputlist", " inputshape", "innerparams", "inputpar", "latparam", " inputlist", "Inputparams", "inputphase", "outputphase", "inputbase", "outputparam"], "n": ["l", "size", "z", "u", "count", "b", "v", "r", "nu", "span", "np", "ne", "k", "d", "pos", "m", "ns", "x", "ni", "num", "pi", "N", "o", "nb", "e", "nc", "nn", "y", "en", "f", "sn", "q", "number", "c", "network", "g", "w", "nl", "nt"], "s": ["l", "features", "size", "z", "jobs", "lines", "sq", "u", "states", "ss", "r", "b", "v", "js", "count", "sf", "ses", "cs", "se", "sv", "sync", "k", "ds", "d", "m", "sg", "ns", "south", "seconds", "space", "e", "spec", "ps", "sp", "ls", "sample", "h", "y", "ssl", "f"], "p": ["P", "l", "ip", "z", "per", "pp", "py", "u", "pl", "pn", "count", "lp", "v", "cp", "b", "r", "pe", "pr", "op", "python", "pu", "jp", "np", "k", "d", "m", "x", "pi", "tp", "point", "o", "up", "pc", "ap", "e", "sp", "h", "y", "start", "f"], "validcount": ["validscore", " validsum", "totallength", "validCount", " validscore", "specificlength", "totalCount", "actualCount", "specificscore", "specificcount", "testinglength", "validlength", "activecode", "goodcount", "specificsum", "goodcode", "validcode", "testingcount", " validCount", "validsum", "actuallength", "testingsum", " validcode", "activeCount", "goodCount", "actualweight", "activecount", "totalcount", "totalweight", " validweight", "testingscore", " validlength", "actualcount", "goodsum", "validweight", "activesum"], "surprisingcount": ["syprisingCount", "SurpriseCount", "Surprisec", "surprisecount", "surprisinglysum", "syprisescount", "Surprisingsum", "Surprisesum", "surtainingc", "surprisingc", "SurprisingCount", "surprisec", "surpriseCount", "surprisessum", "Surprisecount", "surprisingsum", "surtainingCount", "Surprisingc", "syprisingsum", "surprisesCount", "syprisessum", "surprisingCount", "surprisesum", "Surprisingcount", "syprisingcount", "surtainingcount", "syprisesCount", "surprisinglycount", "surprisesc", "surprisinglyCount", "surprisescount"], "j": ["bj", "note", "J", "adj", "l", "ip", "uj", "ji", "z", "obj", " b", "ij", " ip", "iv", "jl", " d", " r", "ib", " ii", " l", "u", "r", "b", "v", "job", "jp", "it", "ie", "k", "ch", "li", "d", "m", "x", "pi", "jo", "num", "dj", "jj", " z"], "score": ["exp", "vec", "size", "z", "case", "py", "error", "key", "core", "pro", "rate", "fit", "count", "kick", "v", "confidence", "pe", "cp", "span", "scale", "live", "order", "scan", "ie", "cer", "sync", "k", "price", "rank", "cr", "time", "Score", "strike", "err", "success", "x", "clean", "match", "ignore", "grade"]}}
{"code": " \n  \n  fairsquares = []\n  \n  \n  def read_fairsquares():\n      global fairsquares\n      f = open('fairsquares.txt')\n      for x in f:\n          fairsquares.append(int(x.strip()))\n  \n  \n  def count_less_than(A):\n      left = 0\n      right = len(fairsquares)\n      while left < right:\n          middle = (left + right) // 2\n          if fairsquares[middle] < A:\n              left = middle + 1\n          else:\n              right = middle\n      return left\n  \n  \n  def compute(A, B):\n      count_b = count_less_than(B + 1)\n      count_a = count_less_than(A)\n      return count_b - count_a\n  \n  \n  def parse():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  \n  if __name__ == \"__main__\":\n      read_fairsquares()\n      T = int(sys.stdin.readline().strip())\n      count = 1\n      part = 0\n      if len(sys.argv) == 3:\n          part = int(sys.argv[1])\n          count = int(sys.argv[2])\n      for i in xrange(T):\n          data = parse()\n          if i * count >= part * T and i * count < (part + 1) * T:\n              result = compute(*data)\n              print \"Case #%d: %s\" % (i + 1, result)\n", "substitutes": {"fairsquares": ["fairsquearing", "fairsqueakes", "fairsquores", "farmssquares", "fairsquare", "fairsqars", "fairssquakes", "fairsaquared", "farmssquare", "fairsquerarters", "foursquares", "faresqares", "fourssquare", "farmssquores", "fairsaquares", "fairsquared", "fairsqueared", "faresqars", "fairsqarters", "fairsquaring", "farmsquare", "foursquars", "faresquare", "faresquars", "fairsquars", "faresqare", "fairsqakes", "fairsqare", "faresqakes", "faresaquars", "fourssquars", "fairsqueares", "faresaquares", "fairsquarters", "fairsqares", "farmsquared", "farmsquares", "fairsqaring", "fairssquaring", "fairsqared"], "f": ["l", "config", "ff", "rf", "zip", "t", "df", "ref", "n", "sf", "b", "v", "inf", "fd", "flat", "full", "fe", "array", "fc", "xf", "fb", "tf", "function", "frame", "fl", "d", "body", "p", "bf", "m", "fx", "form", "file", "fr", "elf", "info", "e", "h", "a", "af"], "x": ["xb", "ex", "config", "l", "exp", "exec", "page", "z", "example", "t", "u", "xe", "url", "xxx", "n", "r", "xx", "v", "ux", "xml", "s", "array", "xf", "xy", "xi", "expr", "sex", "xc", "content", "xes", "ww", "d", "p", "work", "host", "wx", "m", "event", "ax", "rx"], "A": ["API", "D", "alpha", "Ma", "b", "GA", "area", "TA", "AS", "offset", "One", "L", "Y", "Count", "AY", "Na", "Az", "H", "AB", "M", "NA", "AN", "array", "Am", "Max", "U", "AW", "auto", "AD", "W", "Ar", "O", "CA", "E", "a", "X", "mA", "R", "AR", "AU"], "left": ["l", "path", "all", "list", "mid", "cl", "line", "offset", "start", "bottom", "first", "L", "column", "le", "lo", "double", "min", "size", "obj", "old", "little", "partial", "next", "ell", "level", "low", "m", "inner", "wrong", "hide", "two", "lower", "w", "index", "end", "last", "small", "col", "Right", "front"], "right": ["rest", "rew", "rank", "round", "through", "mid", "start", "bottom", "first", "column", "rw", "root", "third", "size", "rand", "r", "value", "cross", "partial", "inner", "wrong", "arrow", "no", "three", "w", "off", "end", "index", "last", "gh", "only", "Right", "total", "back", "before", "d", "power", "ax", "row", "correct"], "middle": ["quarter", "shift", "nr", "grid", "mid", "field", "between", "offset", "edge", "start", "bottom", "first", "c", "column", "medium", "le", "third", "size", "old", "little", "group", "next", "angle", "low", "inner", "mini", "two", "lower", "role", "index", "end", "last", "small", "move", "front", "Middle", "fourth", "space", "normal", "div"], "B": ["P", "WB", "DB", "Z", " b", "D", "GB", "Second", "Beta", "Code", "AB", "I", "H", "b", "BF", "Other", "M", "Ab", "AP", "NB", "Bs", "G", "U", "N", "All", "BB", "BC", "BE", "W", "Number", "O", "BA", "E", "Part", "BD", "C", "a", "V", "Two", "L"], "count_b": ["count_l", "count67u", "count67B", "count67l", " count_B", "count_B", "count67a", "count67b", " count_u", " count_l", "count_u"], "count_a": ["count_A", "countJA", " count_A", "count_c", " count_f", "countJb", "count_f", " count_c", "countJa", "countJf"], "T": ["step", "P", "section", "Q", "DT", "TS", "K", "Z", "D", "TH", "unit", "t", "H", "I", "n", "connection", "M", "NT", "TE", "type", "TC", "ID", "TW", "WT", "Time", "TA", "PART", "G", "FT", "N", "length", "W", "O", "TB", "Part", "E", "C", "Length", "S", "V"], "count": ["P", "size", "key", "t", "error", "case", "max", "col", "n", "b", "found", "connection", "span", "call", "partial", "group", "order", "int", "type", "child", "name", "parent", "d", "id", "p", "limit", "file", "list", "num", "match", "th", "length", "info", "offset", "base", "depth", "weight", "counter", "len", "start"], "part": ["quarter", "art", "t", "key", "b", "connection", "int", " Part", "name", "chapter", "id", "phase", "field", "point", "offset", "start", "c", "section", "month", "j", "size", "case", "minute", "partial", " PART", "order", "group", "element", " partition", "inner", "mini", "bound", "base", "a", "year", "number", "patch", " component", "error", "pair"], "i": ["l", "key", "ti", "t", "ih", "b", "qi", "phi", "uri", "int", "multi", "id", "bis", "start", "c", "instance", "ini", "ci", "si", "j", "r", "xi", "m", "ni", "ix", "mini", "base", "a", "at", "gi", "end", "index", "u", "col", "I", "s", "ui", "slice", "parts", "ie"], "data": ["step", "config", "format", "size", "database", "alpha", "case", "key", "error", "rate", "input", "Data", "flat", "DATA", "slice", "source", "array", "group", "change", "next", "partial", "dat", "parts", "batch", "arr", "area", "ata", "d", "ds", "p", "pos", "list", "response", "di", "action", "info", "da", "cache", "series", "sample"], "result": ["new", "obj", "page", "final", "complete", "df", "valid", "error", "r", "value", "found", "source", "array", "raw", "total", "default", "compl", "arr", "dict", "current", "work", "ret", "event", "err", "success", "list", "val", "res", "response", "match", "row", "mess", "json", "info", "attr", "status", "report", "record", "var", "diff"]}}
{"code": " \n  \n  if __name__ == \"__main__\":\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          values = map(int, sys.stdin.readline().strip().split(' '))\n          _N, S, p = values[0:3]\n          t = values[3:]\n          min_normal = p + 2 * max(0, p - 1)\n          min_surprising = p + 2 * max(0, p - 2)\n          cnt_normal = len(filter(lambda x : x >= min_normal, t))\n          cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal\n          print \"Case #%d: %s\" % (i + 1, cnt_normal + min(cnt_surprising, S))\n", "substitutes": {"T": ["P", "Q", "DT", "TS", "Z", "D", "Size", "H", "I", "n", "TR", "M", "A", "NT", "total", "TC", "WT", "Time", "time", "TA", "G", "U", "N", "TN", "TI", "length", "W", "O", "E", "C", "Length", "V", "L", "X", "number", "TT", "Y", "K", "B", "CT"], "i": ["l", "ip", "j", "z", "chi", "cli", " ip", "ti", " I", "iter", "u", "I", "im", "n", "s", "v", "inf", "b", "phi", "uri", "int", "xi", "type", "bi", "k", "li", "d", "id", "pos", "iu", "x", "pi", " z", "ix", " j", " il", "e", "sp", "h", "zi"], "values": ["versions", "VAL", "lines", "keys", "size", "args", "sets", "changes", "ims", "Values", "ints", "ms", "n", "eps", "value", "v", "s", "data", "tests", "stats", "grades", "default", "sv", "frames", "errors", "events", "blocks", "lists", "objects", "time", "als", "position", "ns", "settings", "val", "flows", "maps", "details", "times", "places"], "_N": ["_n", "_C"], "S": ["P", "Q", "J", "sq", "Z", "D", "Size", "ss", "n", "I", "s", "M", "SU", "A", "se", "SN", "sv", "site", "G", "U", " s", "N", "Sa", "SE", "Ns", "W", "ps", "sp", "O", "sample", "E", "SP", "C", "V", "q", "L", "X", "Si", "Y", "K"], "p": ["P", "l", "lp", "ip", "j", "min", "z", "per", "pp", "api", "u", "n", "r", "b", "s", "v", "pe", "cp", "pressure", "phi", "np", "jp", "k", "part", "d", "pos", "m", "x", "pi", "tp", "N", "point", "bp", "up", "pc", "ap", "e", "ps", " P", "sp"], "t": ["P", "l", "j", "z", "ti", "u", "n", "r", "b", "s", "v", "ot", "tt", "M", "span", "txt", "it", "int", "type", "k", "wt", "d", "m", "template", "time", "x", "ta", "tp", "xt", "tw", "top", "e", "temp", "sp", "h", "y", "a", "f", "pt", "q"], "min_normal": ["minernorm", "min_neutral", "max_random", "min48normal", "max_fine", "max_norm", "minerfine", "minercommon", "max_normal", "min_fine", "max_common", "min_common", "min_random", "min48norm", "min48neutral", "min48random", "max_neutral", "min_norm", "minernormal"], "min_surprising": ["min_urprisingly", "min_urprise", "min_superprising", "min_generiosity", "min_generprise", "min_simprisingly", "min_generprising", "min_simprising", "min_serprising", "min_simiosity", "min_simprises", "min_simvey", "min_urvey", "min_serprise", "min_simprise", "min_supervey", "min_surprises", "min_superprise", "min_serprises", "min_superprisingly", "min_suriosity", "min_survey", "min_urprising", "min_surprise", "min_surprisingly", "min_generprises", "min_seriosity"], "cnt_normal": ["cnt_regular", "cst_norm", "cnt_total", "cnt10norm", "cnt10normal", "cnt_norm", "cst_total", "cnt_max", "cntsregular", "cNT_normal", "cnt10total", "cnt10max", "cnt67normal", "cntscustom", "cntsnormal", "cnt_custom", "cNT_norm", "cNT_custom", "cNT_regular", "cst_normal", "cnt67norm", "cnt67regular", "cntsnorm", "cst_max"], "cnt_surprising": ["cnt_purprising", "cnt_purprise", "cnt_surprise", "cnt_sertaining", "cnt_Surining", "cnt_simprising", "cnt_simprises", "cnt_surtaining", "cnt_purining", "cnt_serprises", "cnt_surprises", "cnt_Surprises", "cnt_serprise", "cnt_urprises", "cnt_purprises", "cnt_urtaining", "cnt_urprising", "cnt_simprise", "cnt_urprise", "cnt_urining", "cnt_simtaining", "cnt_surining", "cnt_serprising", "cnt_Surprising", "cnt_Surprise"]}}
{"code": " \n  def get_generators_up_to_length_n(n):\n      generators = []\n      for ii in range(1, n + 1):\n          generators += get_generators_length_n(ii)\n      return generators        \n  \n  def get_generators_length_n(length):\n      if length % 2 == 0: return get_even_generators_length_n(length)\n      else: return get_odd_generators_length_n(length)\n  \n  def get_odd_generators_length_n(length):\n      if length == 1: return [1, 2, 3]\n      else: \n          n = length / 2\n          generators = []\n          for ii in range(min(n, 4)):\n              for comb in itertools.combinations(range(1, n), ii):\n                  first_half = [\"1\"] + [\"0\"] * (n-1)\n                  for jj in comb:\n                      first_half[jj] = \"1\"\n                  second_half = list(first_half)\n                  second_half.reverse()\n                  palin = first_half + [\"0\"] + second_half\n                  generators.append(int(\"\".join([elem for elem in palin])))\n                  palin[n] = \"1\"\n                  generators.append(int(\"\".join([elem for elem in palin])))\n                  if ii <= 1:\n                      palin[n] = \"2\"\n                      generators.append(int(\"\".join([elem for elem in palin])))\n          generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (n - 1) + [\"0\"] + [\"0\"] * (n - 1) + [\"2\"])])))\n          generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (n - 1) + [\"1\"] + [\"0\"] * (n - 1) + [\"2\"])])))\n          generators.sort()\n          return generators\n  \n  def get_even_generators_length_n(length):\n      if length == 2: return [11, 22]\n      n = length / 2\n      generators = []\n      for ii in range(min(n, 4)):\n          for comb in itertools.combinations(range(1, n), ii):\n              first_half = [\"1\"] + [\"0\"] * (n-1)\n              for jj in comb:\n                  first_half[jj] = \"1\"\n              second_half = list(first_half)\n              second_half.reverse()\n              palin = first_half + second_half\n              generators.append(int(\"\".join([elem for elem in palin])))\n      generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (length - 2) + [\"2\"])])))\n      generators.sort()\n      return generators\n  \n  def is_palin(num):\n      string = str(num)\n      length = len(string)\n      ii = 0\n      while ii < length/2:\n          if string[ii] != string[-(1+ii)]:\n              return False\n          ii += 1\n      return True\n  \n  def gen_fair_and_squares(upper_limit):\n      fair_and_squares = []\n      for ii in range(1, upper_limit + 1):\n          if (is_palin(ii) and is_palin(ii*ii)):\n              fair_and_squares.append(ii)\n      return fair_and_squares\n  \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  gens = get_generators_up_to_length_n(60)\n  squares = map(lambda x: x*x, gens)\n  \n  for t in range(T):\n      A, B = map(int, f.readline().strip().split())\n      total = 0\n      for elem in squares:\n          assert(is_palin(elem))\n          if elem >= A and elem <= B: total += 1\n          if elem > B:\n              break\n  \n      print \"Case #%d:\" % (t + 1), total\n", "substitutes": {"n": ["l", "i", "b", "ne", "init", "ln", "zn", "name", "nor", "nr", "o", "nb", "nc", "nn", "h", "y", "c", "g", "adj", "j", "min", "size", "out", "core", "mn", "r", "inn", "nw", "np", "m", "ns", "x", "ni", "gn", "an", "no", "cn", "nm", "en", "output"], "generators": ["Generations", "operator", "genners", "generumers", "iterations", "genators", "generationitors", "formators", "terminners", "operers", "generers", "generations", " generappers", "terminers", "Generators", "termin1", "formers", "iterappers", "animers", "generors", "generationlers", "generitors", "generatedumers", "gen1", "generulators", "generlers", "variators", "variations", "iterers", "generappers", "variers", "generator", " generations", "produners", "variator", "genappers", "terminitors", "Generers", "Generors", "gener\n"], "ii": ["l", "iw", "i", "ti", "fi", "ih", "inf", "qi", "dim", "agi", "uri", "int", "ne", "init", "nr", "ei", "id", "io", "age", "ig", "ou", "nb", "iq", "nn", "y", "c", "ini", "ci", "si", "ij", "j", "min", "size", "jl", "iter", "xi", "ni", "ani", "Ni", "mini"], "length": ["address", "l", "character", "loc", "path", "model", "function", "definition", "id", "oct", "line", "o", "offset", "approximately", "h", "root", "maximum", "section", "multiple", "shape", "month", "j", "size", "case", "frequency", "bb", "value", "duration", "partial", "angle", "limit", "time", "sequence", "required", "Length", "code", "number", "view", "text", "zip"], "comb": ["opt", "union", "exp", " combo", "chi", "zip", "desc", "loc", " com", "lim", "ach", "sup", "decl", "loop", "expl", "uc", "dim", "coord", "chain", "lam", "acc", "fl", " zip", "cr", "bc", "sect", " mult", "gl", "go", "ctr", " combinations", "sel", "jo", "spl", "cl", "tw", "join", " combine", " recomb", " combined"], "first_half": ["First_quarter", "first_dim", "first_slave", " first_slave", "firstFhalf", " first_dim", "firstFquarter", "first__part", "first_part", "firstFlength", "first__quarter", "First_Half", "first_Half", "First_length", " first_quarter", "first_length", "firstFHalf", "first__half", "First_half", " first_part", "first_quarter", "first__dim"], "jj": ["bj", "note", "J", "adj", "uj", "mm", "JC", "j", "ij", "ji", "z", "jl", "yy", "bb", "jan", "sup", "inn", "v", " je", "qq", "john", "jp", "qa", "direction", "jam", " _", "ww", "aq", "dn", "ax", "x", "jad", "jo", "gn", "dj", "di", "jon", "ix", " j", "JJ"], "second_half": ["secondOquarter", " second_name", "second_part", "second_name", "second_size", "thirdParboth", "third_half", "secondWname", "secondWsize", "third_quarter", "thirdParquarter", "secondParhalf", " second_size", "secondParquarter", "third_both", "second_quarter", "secondOboth", " second_part", "secondParboth", "second_both", "secondOhalf", "thirdParhalf", " second_quarter", "secondWhalf"], "palin": ["harin", "spolin", "pealin", "pillin", "halan", "apillin", "spalid", "spillin", " pindal", "Parin", "apabil", "maline", " pillin", " palli", "apalin", "paline", "Palid", "apalli", "talli", "hillin", "apalid", "opillin", "talid", "Polin", "tpalin", " palid", "spabil", "opalin", " paline", "pabil", "tpolin", "polin", "tpalid", "opalan", "halin", " pabil", "malin", "pealid", "spindal", "spalli"], "elem": ["gelev", "Elee", " elete", "eelee", "pelev", "eelam", "eller", "ielement", " elee", "ielev", "selem", "telem", "elam", "oelee", " elege", "zelet", "oell", " eelement", "oelements", " ell", "leller", "seelement", "neelement", "Elem", "gelete", "zeller", "enlev", "Eleg", "eeelement", "oelem", "elev", "peleg", "elege", "ieleg", "enlem", "gelement", "elex", "ielem", "enle", "eelev"]}}
{"code": " \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      temp = map(int, f.readline().split())\n      N = temp[0]\n      S = temp[1]\n      p = temp[2]\n      scores = temp[3:]\n      non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))\n      if (p<=1):\n          surprising_scores = 0\n      else:\n          surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))\n      num_scores = non_surprising_scores + min(surprising_scores, S)   \n      print \"Case #%d:\" % (t + 1), num_scores\n", "substitutes": {"f": ["l", "ff", "folder", "z", "feed", "i", "df", "iter", "ref", "n", "r", "b", "s", "v", "fd", "loop", "inf", "stream", "fen", "fc", "handle", "fb", "tf", "d", "body", "bf", "m", "fx", "file", "form", "handler", "fr", "x", "o", "io", "os", "e", "buff", "h", "fw"], "T": ["P", "Q", "J", "DT", "TS", "Z", "D", "TP", "H", "I", "n", "IP", "M", "A", "NT", "TC", "Ts", "WT", "Time", "time", "TA", "G", "U", "TN", "W", "O", "E", "C", "Temp", "V", "Length", "PT", "X", "L", "TT", "Y", "K", "B", "F", "R"], "t": ["P", "l", "j", "z", "i", "ti", "n", "v", "qt", "prot", "ot", "tt", "trial", "all", "total", "int", "type", "name", "k", " now", "d", "template", "time", "pot", " ti", "x", "ta", "num", "tp", " z", "o", "tw", " tim", "e", "no", "y", "start", "tower", "pt", "tmp"], "temp": ["tc", "i", "loc", "input", "int", "buffer", "pot", "tp", "json", " Temp", "tmp", "pt", "c", "adj", "cel", "size", "out", "iter", "term", "data", "partial", "txt", "item", "m", "time", "inner", "err", "base", "cache", "output", "X", "w", "index", "tem", "fake", "zip", "null", "sol", "col", "adapt"], "N": ["P", "Q", "J", "size", "Z", "D", "Size", "H", "n", "I", "M", "A", "NT", "SN", "ns", "G", "num", "U", " n", "nb", "Ns", "W", " P", "O", "Num", "E", "C", "V", "L", "X", "Y", "K", "B", "F", "NS", "R"], "S": ["P", "Q", "J", "size", "Z", "D", "Size", "i", "H", "n", "I", "s", "M", "A", "SN", "Sp", "pos", "G", "U", "num", "SE", "Ns", "W", "sp", "O", "Num", "E", "SC", "SP", "C", "V", "L", "X", "Y", "K", "B", "w", "F", "g", "PS"], "p": ["P", "l", "ip", "j", "z", "pp", "api", "i", "u", "pn", "n", "r", "b", "s", "v", "cp", "count", "lp", "pe", "M", "python", "post", "pu", "jp", "np", "k", "part", "pa", "d", "m", "x", "pi", "tp", "point", "up", "pc", "ps", " P", "sp", "h"], "scores": ["cores", " scorer", "SCores", "secores", "Scores", "sporer", "secales", "scopes", " scors", "scales", "secors", "cales", "scors", " scales", "SCors", "copes", "Score", "corer", "spore", "Scats", "spats", "scorer", "cors", "SCorer", "escorer", "escore", "spores", "escores", " scopes", "Scorer", "secopes", "escats", "scats", "SCales", "score"], "non_surprising_scores": ["non_surprising_missores", "non_surprising_scors", "non_surprising_Scores", "non_surprising_Scatters", "non_surprising_missore", "non_surprising_scrons", "non_surprising_compatters", "non_surprising_SCrons", "non_surprising_SCors", "non_surprising_missors", "non_surprising_scatters", "non_surprising_compores", "non_surprising_compors", "non_surprising_SCores", "non_surprising_SCore", "non_surprising_missrons", "non_surprising_Scrons", "non_surprising_Score", "non_surprising_Scors", "non_surprising_compore", "non_surprising_score"], "surprising_scores": ["surprising_acores", "surprising_qureads", "surprising_acourses", "surprising_passurs", "surprising_suffores", "surprising_contore", "surprising_quore", "surprising_suffurs", "surprising_Scenses", "surprising_Score", "surprising_sprites", "surprising_passores", "surprising_scors", "surprising_quores", "surprising_scurs", "surprising_acenses", "surprising_contores", "surprising_spreads", "surprising_qurites", "surprising_Scrites", "surprising_scenses", "surprising_scourses", "surprising_spore", "surprising_scops", "surprising_passops", "surprising_scrites", "surprising_screads", "surprising_spores", "surprising_score", "surprising_contenses", "surprising_suffors", "surprising_acore", "surprising_contourses", "surprising_Scourses", "surprising_suffops", "surprising_Scores", "surprising_Screads", "surprising_passors"], "num_scores": ["num_accenses", "num_macorer", "num_ancurs", "num_Scored", "num_accore", "num_scors", "num_Scenses", "num_ancores", "num_scurs", "num_SCorer", "num_compore", "num_score", "num_SCores", "num_compenses", "num_macores", "num_SCors", "num_macurs", "num_Scores", "num_ancors", "num_scorer", "num_Score", "num_scored", "num_scenses", "num_ancorer", "num_accores", "num_compores", "num_accored", "num_compored", "num_macors", "num_SCurs"]}}
{"code": " \n  \n  \t\t\n  \t\n  def isPalindrome(S):\n  \ts = str(S) #so I dont need to make sure its a string\n  \tfor i in range(len(s)//2):\n  \t\tif not s[i] == s[-1 - i]:\n  \t\t\treturn False\n  \treturn True\n  \n  def FairAndSquare(infile=\"C-small-attempt0.in\", outfile=\"C-small-attempt0.out\"):\n  \tinF = open(infile, 'r')\n  \toutF = open(outfile, 'w')\n  \t\n  \tfor t in range(1, int(inF.readline().strip()) + 1):\n  \t\ttemp = inF.readline().strip().split()\n  \t\tA = long(temp[0])\n  \t\tB = long(temp[1])\n  \t\tcount = long(0)\n  \t\t\n  \t\ti = long(math.ceil(math.sqrt(A)))\n  \t\tm = long(math.floor(math.sqrt(B)))\n  \t\twhile i <= m:\n  \t\t\tif isPalindrome(i):\n  \t\t\t\tif isPalindrome(i**2):\n  \t\t\t\t\tcount += 1\n  \t\t\ti += 1\n  \t\t\t\t\t\n  \t\toutF.write(\"Case #\" + str(t) + \": \" + str(count) + \"\n\")\n  \t\n  \tinF.close()\n  \toutF.close()\n  \t\n  \tf = open(outfile, 'r')\n  \tprint f.read()\n  \tf.close()\n  \t\n  \t\n  if __name__ == \"__main__\":\n      FairAndSquare()\n", "substitutes": {"S": ["P", "TS", "SM", "Sample", "H", "I", "M", "SO", "SU", "String", "STR", "SN", "SR", "SA", "OSS", "SH", "G", "U", "N", "GS", "WS", "SE", "URI", "Ns", "W", "O", "SC", "OS", "C", "V", "Si", "L", "X", "T", "F", "IS", "SI", "SS", "NS", "R"], "s": ["l", "ts", "lines", "services", "ins", "u", "out", "sets", "ss", "states", "n", "ses", "b", "letters", "r", "su", "v", "input", "less", "source", "cs", "images", "se", "tests", "fts", "sv", "parts", "blocks", "d", "p", "qs", "words", "sg", "outs", "ns", "abs", "south", "bis", "its", "o"], "i": ["l", "ti", "ih", "b", "qi", "phi", "uri", "int", "multi", "ei", "id", "mu", "o", "h", "y", "start", "c", "ini", "ci", "si", "j", "size", "eni", "iter", "ri", "im", "r", "xi", "bi", "x", "ni", "ix", "mini", "idi", "hi", "a", "w", "gi", "at", "iii"], "infile": ["Inbase", "inline", "Infile", "inf", " inbase", "inbase", "outline", "outFile", "outf", "InFile", " inline", "Inline", "outbase", "Inf", "inFile", " inFile", " inf"], "outfile": [" outFile", " outfilename", "OutFile", "inline", "outfolder", "offfolder", "outfilename", "inf", "Outfolder", "Outf", "inbase", "offf", "outline", "againbase", "outFile", "offFile", "Outfilename", "outf", "Outfile", "offfile", " outfolder", "againline", " outline", "againfile", "againf", "infilename", "outbase", "inFile", " outbase", " outf"], "inF": ["INFile", " inFD", "inf", "INF", "INf", "inM", "inB", "outFile", "outf", "insFD", "INB", " inM", "insM", "InD", "insFile", "outFD", "insf", " inD", "InF", "inFD", " inB", "outM", "Inf", "inFile", " inFile", "outD", " inf", "InM", "outB", "insF", "inD"], "outF": ["OutF", " outFile", "againF", "OutFile", "inE", "inf", "Outf", "offY", "inM", "offf", "OutB", "inB", "outFile", "offFile", "OutE", "outf", " outM", "inY", "offF", " outE", " outf", "outY", "againf", "outM", "againY", "inFile", "outE", "againFile", " outB", "OutM", "outB"], "t": ["note", "l", "tc", "j", "z", "u", "ti", "out", "col", "n", "r", "v", "tt", "slice", "trial", "duration", "it", "total", "type", "tf", "name", "k", "tm", "current", "d", "id", "p", "template", "time", " ti", "tif", "x", "ta", "tp", "token", "o", "ty", "cont", " n", "e"], "temp": ["l", "tem", "margin", "format", "tc", "j", "fake", "size", "z", "zip", "sol", "case", "iter", "key", "unit", "loc", "py", "col", "n", "b", "flat", "term", "data", "slice", "partial", "txt", "order", "it", "int", "type", "sex", "part", "current", "p", "emp", "template", "wait", "tp", "str", "json"], "A": ["P", "Ca", "API", "Na", "As", "D", "AA", "LA", "Amount", "Az", "Auto", "H", "I", "Any", "au", "Data", "M", "GA", "NA", "AM", "Bu", "Ab", "AP", "Am", "Alpha", "Java", "Offset", "The", "G", "U", "N", "Avg", "At", "Sum", "W", "Ar", "One", "CA", "AF", "Average"], "B": ["Q", "P", "WB", "QB", "DB", "D", "AA", "GB", "UB", "H", "I", "AB", "b", "BF", "MP", "BW", "M", "BM", "Bu", "Ab", "HB", "SB", "AP", "Big", "NB", "BL", "Bs", "G", "U", "N", "BB", "CB", "BC", "BG", "BS", "W", "EB", "O", "BA", "E"], "count": ["log", "l", "note", "j", "size", "z", "case", "u", "error", "col", "n", "b", "r", "v", "I", "found", "total", "type", "part", "multi", "li", "id", "p", "list", "x", "num", "match", "o", "length", "info", "base", "e", "depth", "weight", "coll", "counter", "len", "y", "start", "C"], "m": ["l", "sm", "mm", "margin", "size", "u", "mr", "mn", "ms", "n", "b", "md", "r", "v", "mon", "range", "M", "pm", "man", "tm", "d", "cm", "p", "mass", "mc", "x", "mid", "mi", "fm", "mu", "mmm", "o", "length", "e", "hm", "h", "nm", "y", "km", "a"], "f": ["l", "ff", "j", "uf", "z", "fore", "u", "out", "feed", "n", "r", "b", "v", "fd", "inf", "found", "sf", "data", "full", "fe", "free", "fc", "fb", "tf", "function", "fl", "d", "p", "file", "form", "fr", "fac", "x", "field", "fm", "o", "info", "fin", "e", "h"]}}
{"code": "data_dict = {}\n  init = False\n  \n  \n  def partB(infile=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt\",\\\n                outfile=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt\"):\n      \n      linesA = []\n      for line in open(infile, 'r'):\n          linesA.append(line.strip())\n  \n      outA = []\n          \n      T = int(linesA[0])\n      for i in range(1, 1 + T):\n          caseA = linesA[i].split()\n          N = int(caseA[0])\n          S = int(caseA[1])\n          P = int(caseA[2])\n          \n          over_norm = 0\n          over_supr = 0\n          \n          for t in [int(conv) for conv in caseA[3:3+N]]:\n              if data_dict[t][0] >= P:\n                  over_norm += 1\n              elif data_dict[t][1] >= P:\n                  over_supr += 1\n          \n          outA.append(over_norm + min(over_supr, S))\n              \n              \n          \n      \n      out = open(outfile, 'w')\n      print \"\nOUTPUT\"\n      for i in range(1, 1 + T):\n          if i != 1:\n              out.write(\"\n\")\n          print \"Case #\" + str(i) + \": \" +str(outA[i-1])\n          out.write(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n      out.close()\n  \n  def dict_helper(total, depth=0, lowest=10):\n      pass\n  \n  def build_dict():\n      for i in range(31):\n          fullA = []\n          maxN = 0\n          maxS = 0\n          print str(i) + \": \"\n          for a1 in range(0,11):\n              for a2 in range(0,11):\n                  for a3 in range(0,11):\n                      if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):\n                          fullA.append((a1,a2,a3))\n                          \n                          print \"\\t\", fullA[-1],\n                          if max(a1,a2,a3)-min(a1,a2,a3) == 2:\n                              print \"*\"\n                              maxS = max(maxN, max(a1,a2,a3))\n                          else:\n                              print\n                              maxN = max(maxN, max(a1,a2,a3))\n          data_dict[i]=[maxN, maxS]\n      init = True\n      \n  if __name__ == \"__main__\":\n      build_dict()\n      partB()\n", "substitutes": {"data_dict": ["data_ict", "input_list", "data__list", "input_df", "data_list", "input_db", "input_dict", "data_df", "datajict", " data_view", "dat_list", "data_view", " data_body", "dat__dict", "data__file", " data_ict", "data__dict", "data_db", "dat_dict", "data2df", "dat__file", "datajdict", "datajview", "data_file", "data2list", "datajbody", "data2dict", "dat_file", "data_body", "data2db", "dat__list"], "init": ["log", "fixed", "format", "config", "size", "initialized", "cli", "progress", "unit", "random", "iter", "plot", "error", "misc", "fit", "sleep", "loop", "Init", "chain", "quit", "it", "bin", "gen", "id", "seed", "inner", "binary", "ignore", "reset", "info", "temp", "start", "debug", "timeout", "load", "initial", "update", "lib"], "infile": ["infil", "outfil", "outfilename", "inf", "inputfilename", "winf", "outfiles", "inif", "inputfil", "inputf", "winfile", "outf", "inifile", "inifiles", "winfilename", "inputfiles", "iniformat", "inputfile", "winfil", "informat", "infilename", "outformat", "inputformat", "infiles"], "outfile": [" outFile", " outfilename", "newname", " outpath", "outfilename", "inf", "inpath", "newFile", "Outf", "outFile", "Outfilename", "outf", "Outfile", "outname", " outname", "outpath", "Outpath", "inname", "newfile", "infilename", "newfilename", "inFile", " outf"], "linesA": ["linesa", "blocksAs", "blocksT", "inesA", "breaksAs", "filesa", "filesB", "linesLA", "linesB", "filesT", "rowsT", "inesC", "breaksB", "blocksLA", "linesC", " linesB", "inesa", "rowsAs", " linesC", "rowsLA", "linesAs", "casesAs", " linesAs", "inesB", "cellsB", "cellsC", "linesT", "casesa", "casesC", "cellsA", " linesa", "cellsa", "casesT", "breaksA", "breaksC", "rowsA", "casesA", " linesT", " linesLA", "blocksA"], "line": ["LINE", "log", "l", "section", "cell", "reader", "lines", "obj", "byte", "page", "inline", "case", " lines", "unit", "comment", "error", "key", "url", "input", "r", "b", "header", "data", "model", "profile", "source", " Line", "all", "ln", "frame", "name", "li", "buffer", "p", "entry", "file", "block", "lined", "str", "response"], "outA": ["listC", "lineP", "caseAs", "listS", "lineAs", "outC", "OutA", "OutArray", "outAs", "listP", " outS", "caseC", " outC", "OutC", "listAs", "OutS", "Outa", " outP", "caseP", " outa", "resultP", "outArray", "lista", "OutP", "resulta", "outS", "resultA", " outArray", "outa", "lineC", "listA", "outP", "lineA", "listArray", "resultC"], "T": ["Q", "J", "DT", "TS", "Z", "D", "Ti", "TH", "Size", "TP", "TM", "H", "I", "IP", "OT", "M", "A", "NT", "Test", "PT", "TG", "ID", "TW", "WT", "TF", "Time", "TA", "G", "FT", "U", "TN", "KT", "TI", "TPS", "Tu", "W", "O", "Total", "E", "C"], "i": ["l", "alpha", "key", "ti", " I", "fi", "b", "ih", "dim", "qi", "phi", "uri", "all", "int", "name", "multi", "area", "ei", "id", "mu", "o", "io", "iq", "h", "y", "start", "c", "g", "ini", "ci", "si", "lo", "j", "ij", "eni", "ri", "im", "r", "me", "DI"], "caseA": ["dataP", " caseS", "caseS", "codea", "instanceA", "iceI", "caseB", "caseAs", "catchAs", "dataA", " caseB", "caseN", "iceA", "catcha", "casea", "icea", "CaseI", " caseAs", "CaseB", "codeN", "Casea", "dataa", "catchN", "catchB", "pathAs", "iceB", "CaseN", "typea", "codeB", "pathS", "caseI", "CaseAs", "pathP", "instanceAs", "typeB", "caseP", "codeA", "pathA", "catchI", "catchA"], "N": ["Q", "J", "PIN", "Size", "D", "Z", "H", "I", "n", "RN", "M", "NA", "A", "Len", "NT", "NG", "SN", "NP", "NN", "NE", "Nat", "NM", "G", "NL", "U", " n", "Ni", "Ns", "W", "O", "Total", "E", "Sn", "C", "Ne", "V", "MN", "L", "X", "Y"], "S": ["Q", "J", "TS", "Z", "D", "Size", "H", "n", "I", "s", "M", "SU", "A", "SN", "SA", "SK", "SH", "G", "U", "Sa", "GS", "WS", "SE", "CS", "Ns", "W", "O", "SL", "Sn", "SC", "SP", "OS", "C", "V", "Si", "L", "X", "Y", "B", "F"], "P": ["Q", "J", "PIN", "WP", "API", "D", "TP", "Ps", "H", "I", "IP", "M", "PD", "A", "AP", "NP", "p", "PA", "G", "U", "PG", "PI", "PE", "PUT", "FP", "Py", "PP", "W", "Port", "O", "HP", "E", "Part", "Point", "C", "SP", "V", "PT", "X", "L"], "over_norm": ["over__orm", "over___normal", "over\u00b7loop", "hard_normal", "over_gl", "hard__normal", "over_Norm", "over67transform", "over___norm", "over\u00b7orm", "under__loop", "under__normal", "under_orm", "over\u00b7normal", "over_transform", "Over__rand", "hard__norm", "hard_norm", "Over__transform", "under_normal", "under__orm", "Over__Norm", "Over_Norm", "under__norm", "hard_gl", "under_norm", "over\u00b7norm", "over_rand", "under_loop", "hard__ord", "over67rand", "over___loop", "Over_rand", "over_ord", "over__normal", "over___orm", "over__norm", "over67norm", "over__Norm", "Over__norm"], "over_supr": ["over_surrt", "over_suprl", "over_sqro", "over_pprar", "over_sqr", "over_suphr", "over__supR", "over_suporr", "over_descorr", "over_suprg", "over_suprar", "over_surhr", "over_sqorr", "over_descr", "over_ppr", "over_surr", "over_supprt", "over__suprar", "over_pporr", "over_surrs", "over_supR", "over_supro", "over_ppro", "over_descrl", "over_impr", "over_imprg", "over_descro", "over_sqrl", "over_supprs", "over_suprt", "over_pprl", "over_impR", "over_imprar", "over_pprg", "over_ppR", "over_suppr", "over_supphr", "over__supr", "over__suprg", "over_suprs"], "t": ["opt", "l", "j", "target", "unit", "ti", "u", "ont", "col", "n", "b", "v", "qt", "tt", "tu", "port", "txt", "te", "it", "put", "int", "type", "tf", "tm", "wt", "d", "id", "p", "att", "m", "ret", "x", "ta", "num", "xt", "tp", "str", "ty", "mat", "ct"], "conv": ["Q", " trial", "cell", "det", "tri", "text", "tc", "D", "unit", "ti", "u", "trans", " seq", " ii", "I", "b", "bit", "v", "qt", "false", "trial", "M", "tu", "np", "tf", "tv", "gen", "li", "TW", "id", "m", "bc", "G", "x", "num", "U", "tp", "TN", "ta", "self"], "out": ["log", "ex", "co", "image", "exp", "exec", "Out", "new", "size", "page", "obj", "final", "window", "error", "max", "key", "one", "n", "connection", "call", "group", "net", "dot", "write", "name", "gen", "parent", "again", "p", "file", "home", "outs", "list", "err", "lock", "block", "plain", "prefix", "o", "io"], "total": ["size", "example", "desc", "complete", "iter", "max", "null", "I", "count", "input", "n", "full", "trial", "partial", "array", "toc", "all", "order", "raw", "net", "multi", "current", "words", "cat", "list", "table", "num", "length", "mini", "info", "result", "temp", "Total", "mult", "this", "doc", "sum"], "depth": ["format", "D", "case", "random", "iter", "mode", "input", "count", "dim", "python", "reverse", "scale", "style", "tests", "level", "default", "name", "d", "id", "seed", "time", "inner", "tips", "stack", "deep", "length", "cases", "weight", "version", "levels", "padding", "tree", "debug", "repeat", "cost", "height", "root"], "lowest": ["smallests", "smallEST", "lower", "older", "lowests", "oldests", "oldest", "lowEST", "smallest", "oldEST", "smaller", "miner", "minests", "minEST", "minest"], "fullA": ["quickG", " fullB", "FullB", " fullG", "fullG", "fullY", "quickB", "completeY", "FullA", "completeA", "fullAn", "fullB", "FullG", "FullAn", "quickAn", " fullAn", "completeB", "quickA", " fullY", "completeG", "FullY"], "maxN": ["MaxC", "caseC", "MaxN", " maxP", " maxC", "maxC", "caseP", "MaxP", "maxP", "caseN"], "maxS": ["maxP", "MaxH", "MaxN", "tempP", " maxH", " maxP", "tempH", "tempN", "tempS", "MaxP", "MaxS", "maxH"], "a1": ["aa5", "Aone", "ga3", "a01", "saone", " a01", "A3", "A2", "A121", "ca2", "ca3", "alpha01", "sa1", " a121", "alpha3", "gaone", "aa3", "anOne", "A1", "an1", "ca1", " aone", "sa01", "alpha2", "ca121", "aa2", "aa1", "alpha1", "AOne", "sa2", "ga1", "aOne", "alphaone", "ga2", " a5", "a5", "A5", "an3", "an2", "alphaOne"], "a2": ["ga5", "atwo", "sa3", " atwo", "va1", "A4", "A3", "A2", "sa1", "A02", "alpha3", "alpha4", "na3", "sa02", "va182", "alpha02", "a02", "da2", "A1", "alpha2", " a182", "a4", "va2", "da182", "ga4", "alpha1", "sa2", " a4", "ga1", "a182", "da1", "ga2", " a5", "a5", "na2", "A5", " a02", "datwo", "na02", "na1"], "a3": ["A4", "A3", "A2", " a83", " a15", "alpha3", "aa3", "alpha4", "va83", "ha15", "A1", "ha2", "alpha2", "ha1", "aa2", "aa1", "a4", "va2", "alpha1", " a4", "a03", "alpha15", "A03", "va3", "a83", "alpha83", " a03", "va4", "a15", "ha3", "aa03"]}}
{"code": "\"\"\"Usage:\n      X.py < X.in > X.out\n  \"\"\"\n  \n  def isqrt(x):\n      \"returns int(floor(sqrt(x))) using only integer math\"\n      assert x >= 0, 'Undefined %r' % locals()\n      n = int(x)\n      if n == 0:\n          return 0\n      a, b = divmod(n.bit_length(), 2)\n      x = 2**(a+b)\n      while True:\n          y = (x + n//x)//2\n          if y >= x:\n              return x\n          x = y\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, **ignore):\n      P = map(int, infile.next().split())\n      return locals()\n  \n  def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      low = isqrt(P[0])\n      high = isqrt(P[1])+1\n  \n      def is_pal(n):\n          n = str(n)\n          for i in range(len(n)/2+1):\n              if n[i]!=n[len(n)-1-i]:\n                  return False\n          return True\n  \n      res = 0\n      for i in range(low, high+1):\n          if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):\n              res += 1\n  \n      return 'Case #%s: %s\n' % (testcase, res)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n", "substitutes": {"x": ["ex", "l", "input", "xx", "int", "rx", "ct", "tx", "xs", "h", "c", "Y", "g", "px", "j", "size", "yy", "case", "cross", "data", "python", "array", "xy", "xi", "xxxx", "ww", "m", "ix", "xxxxxxxx", "ed", "no", "X", "number", "w", "xp", "index", "anything", "u", "dx", "s"], "n": ["l", "ne", "ln", "zn", "name", "nor", "nr", "o", "nb", "names", "Ns", "nc", "nn", "h", "c", "g", "adj", "j", "size", "eni", "r", "anon", "nw", "np", "m", "ns", "ni", "an", "no", "cn", "en", "number", "bn", "network", "w", "nu", "nt", "nan", "pn", "u"], "a": ["l", "aa", "ai", "wa", "j", "ab", "z", "u", "va", "am", "oa", "r", "ba", "s", "au", " A", "A", "sa", "area", "d", "p", "ae", "m", "na", "ax", "ac", "da", "e", "an", "h", "ad", "ca", "f", "af", "c", "ma", "w", "fa", "index", "pa"], "b": ["l", "aa", "j", "ab", "py", "u", "bb", "rb", "r", "s", "v", "ba", "wb", "A", "db", "k", "bi", "d", "ae", "p", "bf", "m", "eb", "bc", "bs", "bp", "lb", "nb", "e", "base", "cb", "ca", "h", "f", "dy", "c", "g", "B", "w", "beta"], "y": ["l", "j", "z", "yy", "py", "u", "max", "wy", "xxx", "xx", "v", "value", "yi", "xy", "int", "k", "d", "p", "vy", "m", "ky", "yn", "cy", "ym", "o", "ty", "ye", "oy", "yd", "ya", "ey", "zy", "e", "hy", "h", "start", "f", "dy", "X", "c"], "infile": ["INile", "INFile", "inline", "instream", "insfile", " infilename", " instream", "Infile", "outfilename", "Infilename", "outfiles", "insile", " inbase", "inbase", "INbase", "insstream", " inile", "outline", "outFile", "inputline", "INstream", "inputFile", "insfilename", "outfile", "inputfiles", " inline", "INfile", "Infiles", "inputfile", "inile", "INfiles", " infiles", "INfilename", "infilename", "Inline", "outbase", "inFile", "INline", "infiles"], "testcase": ["Testtest", "Testclass", "trainCase", " testpath", "testsection", "testingcase", "testingCase", "Testsection", "testingsection", " testsection", "testCase", " testtest", "TestCase", " testfile", "testclass", "testfile", "testingfile", " testclass", "Testpath", " testCase", "testpath", "trainpath", "testtest", "traincase", "Testfile", "Testcase", "trainclass", "traintest"], "P": ["Q", "Price", "API", "D", "Ps", "Po", "NP", "DP", "PI", "ap", "PP", "PN", "Port", "Point", "L", "Y", "Pi", "Ch", "Python", "TP", "H", "M", "PK", "U", "PC", "Pe", "RP", "O", "E", "XP", "V", "X", "B", "Primary", "CP", "R", "Points", "PIN", "IP", "Page"], "N": ["Q", "J", "Z", "D", "H", "IP", "M", "A", "NT", "NP", "NN", "p", "G", "NL", "U", "PN", "Ns", "W", "O", "E", "V", "L", "X", "Node", "Y", "K", "B", "CN", "F", "NS", "R"], "I": ["Q", "J", "Z", "D", "H", "IP", "M", "A", "IL", "ID", "p", "G", "pi", "U", "PI", "W", "O", "E", "MI", "V", "L", "X", "IM", "Y", "Pi", "B", "F", "CI", "SI", "IT", "R"], "T": ["Q", "DT", "TS", "Z", "Ti", "D", "TH", "TP", "H", "TR", "M", "A", "NT", "Th", "TC", "Te", "Ts", "TF", "WT", "TA", "G", "U", "TN", "TI", "W", "O", "E", "Length", "V", "PT", "X", "L", "TT", "Y", "K", "B", "TB", "F", "Type", "CT"], "S": ["Q", "SF", "TS", "Ps", "H", "s", "M", "A", "SN", "SR", "SA", "Sl", "SH", "G", " s", "U", "Sa", "SE", "CS", "Ns", "W", "O", "SL", "SC", "SP", "V", "Si", "X", "ST", "SI", "PS", "SS", "NS", "R", "RS"], "C": ["Cu", "Ca", "D", "Code", "H", "Cr", "NC", "M", "A", "Can", "G", "U", "CR", " c", "CC", "W", "O", "CA", "VC", "E", "SC", "Cl", "Cs", "V", "Con", "X", "c", "K", "Count", "CT", "CN", "F", "B", "CI", "CL", "R", "Ch"], "low": ["small", "lo", "l", "min", "size", "new", "max", "Low", "loc", "old", "lim", "range", "one", "v", "pe", "little", "scale", "left", "level", "good", "limit", "d", "p", "mid", "o", "length", "offset", "e", "base", "hi", "no", "len", "start", "diff", "lower", "f", "bottom", "long", "c", "off"], "high": ["maximum", "min", "null", "max", "rest", "old", "upper", "lim", "range", "pe", "pen", "full", "pop", "live", "Hi", "default", "peak", "limit", "fill", "p", "close", "round", "hop", "index", "mid", "highest", "num", "prev", "higher", "win", "length", "up", "top", "bound", "above", "hi", "large", "h", "High", "long"], "i": ["lo", "l", "ai", "ip", "j", "z", "chi", "u", "ti", "ki", "ri", "r", "v", "s", "ui", "qi", "ori", "ic", "yi", "phi", "it", "uri", "int", "xi", "ie", "k", "bi", "li", "ei", "d", "id", "p", "m", "iu", "pi", "ni", "di", "o", "io", "e"], "res": ["reg", "es", "values", "ins", "complete", "ras", "rest", "right", "core", "ris", "nos", "ros", "ms", "eps", "pres", "r", "req", "s", "cons", "Rs", "range", "gr", "cs", " Res", "errors", "arr", "rich", "ress", "id", "re", "cr", "resp", "rss", "RES", "ret", "err", "success", "details", "num", "response"], "common": ["small", "union", "specific", "tc", "similar", "same", "new", "null", "random", "set", "core", "public", "standard", "family", "data", "fast", " custom", "all", "total", "general", "TC", "simple", "name", "current", "form", "special", "TA", "stack", "other", "local", "normal", "regular", "original", "extra", "base", "unique", "no", "shared", "recent", "tree"], "t": ["l", "unt", "text", "tc", "z", "out", "r", "s", "v", "tt", "python", "te", "it", "total", "int", "type", "tf", "both", "name", "tm", "d", "p", "m", "template", "time", "table", "ta", "tp", "ty", "o", "normal", "e", "temp", "h", "tower", "f", "mult", "c", "g", "ut"]}}
{"code": "\"\"\"Usage:\n      X.py < X.in > X.out\n  \"\"\"\n  \n  \n  \n  class Solver(object):\n      cache = {}\n  \n      def __init__(self, infile, testcase):\n          self.testcase = testcase\n          self.P = P = map(int, infile.next().split())\n  \n      def init_cache(self):\n          if 'main' in self.cache:\n              return\n  \n      def solve(self):\n  \n          N, S, p = self.P[:3]\n          G = sorted(self.P[3:], reverse=True)\n  \n          r = 0\n          s = 0\n          for g in G:\n              if g >= 3 * p - 2 and g >= p:\n                  r += 1\n              elif g >= 3 * p - 4 and g >= p:\n                  if s == S:\n                      break\n                  r += 1\n                  s += 1\n  \n          return r\n  \n  \n  def main():\n      T = int(sys.stdin.next())\n      for t in xrange(T):\n          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n  \n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"cache": ["config", "l", "graph", "clear", "case", "ref", "pool", "run", "core", "n", "hash", "v", "call", "model", "lib", "data", "chain", "store", " Cache", "cycle", "np", "init", "complex", "parse", "sync", "memory", "parent", "Cache", "gc", "m", "list", "table", "binary", "pi", "lock", "block", "play", "cells", "ac", "module"], "self": ["co", "disk", "ref", "connection", "static", "driver", "all", "function", "utils", "host", "other", "cl", "o", "proc", "h", "tmp", "c", "ctx", "instance", "reader", "j", "case", "me", "plugin", "data", "func", "words", "m", "resp", "go", "er", "x", "client", "module", "spec", "base", "layer", "http", "w", "ng"], "infile": [" inclass", "INFile", " infilename", "Infile", "inputfilename", "Infilename", "Inclass", "InFILE", "inFILE", "INFILE", "inputfiles", "inputclass", "InFile", "INfile", "Infiles", "inputfile", "inclass", " infiles", " inFILE", "INfilename", "infilename", "inFile", " inFile", "infiles"], "testcase": ["serverCase", "trainCase", " testpath", "testcases", "traincases", "servercase", "valcase", " testcases", "testCase", "TestCase", "Testcode", "Testpath", " testCase", "testpath", "testcode", "valcode", "valCase", "traincase", "serverpath", "Testcase", " testcode", "Testcases", "servercases"], "P": ["Q", "J", "PIN", "D", "TP", "Python", "H", "I", "pressure", "IP", "PO", "pair", "M", "PU", "PD", "A", "EP", "BP", "Po", "PR", "NP", "DP", "PA", "position", "U", "PC", "point", "PE", "PI", "PUT", "length", "RP", "PF", "PP", "HP", "W", "O", "PM", "pointer", "E"], "N": ["Q", "J", "Z", "D", "H", "n", "I", "NC", "M", "A", "NT", "np", "NP", "NN", "ns", "U", " n", "Ni", "Ns", "W", "O", "E", "C", "V", "L", "X", "Node", "c", "Y", "K", "B", "F", "NS", "R", "nu"], "S": ["Q", "J", "Z", "D", "u", "Ps", "H", "n", "SG", "I", "M", "SU", "A", "SR", "SA", "Sp", "SH", "U", "GS", "SE", "ps", "W", "sp", "O", "E", "SC", "SP", "C", "V", "Si", "L", "X", "Y", "K", "B", "F", "w", "ST", "SI", "PS"], "p": ["l", "j", "z", "pp", "py", "u", "i", "case", "n", "lp", "b", "v", "cp", "M", "A", "phi", "np", "k", "part", "d", "pos", "m", "power", "x", "pi", "tp", "pc", "e", "ps", "pg", "sp", "h", "E", "y", "pre", "C", "f", "a", "q", "c"], "G": ["J", "Q", "MG", "Gs", "D", "GT", "H", "I", "GA", "M", "GF", "A", "GR", "GU", "CG", "GG", "U", "GE", "PG", "GS", "Ga", "GH", "W", "E", "Ge", "C", "GP", "V", "GI", "L", "X", "GV", "Y", "K", "B", "Pg", "F", "Gr", "gs", "R"], "r": ["l", "i", "rb", "b", "pr", "all", "rt", "re", "fr", "rx", "o", "rus", "h", "c", "rr", "kr", "reg", "j", "hr", "mr", "rd", "m", "err", "er", "x", "yr", "a", "w", "R", "br", "ur", " R", "u", "Rs", "it", "SR", "k", "arr", "d", "lr"], "s": ["rl", "l", " rs", "es", "j", "size", "args", "i", "u", "sets", "ss", "eps", "n", "b", "v", "Rs", "groups", "cs", "rors", "hs", "ats", "breaks", "ds", "ags", "d", "m", "rss", "sg", "als", "ns", "x", "er", "res", "its", "sr", "ges", "ans", "os", "rows", "e"], "g": ["l", "reg", "mg", "eg", "j", "game", "tg", "gru", "agg", "u", "i", "gh", " gp", "n", "b", "v", "ge", "gt", "ug", "ic", "group", "it", "rg", "gre", "gas", "yg", "gen", "ga", "d", "gc", "m", "sg", "go", "x", "num", "erg", "gn", "gap", "gam", "ag"], "T": ["Q", "DT", "TS", "Z", "D", "Ti", "H", "I", "n", "TR", "M", "A", "NT", "Test", "int", "TW", "WT", "time", "TA", "x", "TN", "length", "W", "O", "Total", "E", "C", "Length", "V", "L", "X", "TB", "TT", "Y", "B", "CT", "F", "R", "test"], "t": ["l", "tip", "unt", "tc", "j", "z", "target", "u", "out", "i", "ti", "n", "v", "qt", "ot", "tt", "te", "int", "type", "name", "k", "wt", "d", "id", "m", "time", "x", "ta", "tp", "num", "tz", "xt", "ty", "o", "tw", "ant", "e", "temp", "h", "y"]}}
{"code": " \n  def is_fair(n):\n      n = str(n)\n      for i in range(long(len(n) / 2)):\n          if n[i] != n[len(n) - i - 1]:\n              return False\n      return True\n  \n  def is_square_and_fair(n):\n      if not is_fair(n): return False\n      root = math.sqrt(n)\n      if root != math.floor(root): return False\n      if not is_fair(long(root)): return False\n      return True\n  \n  def process():\n      a, b = sys.stdin.readline().split()\n      a = long(a)\n      b = long(b)\n      \n      count = 0\n      for i in range(a, b + 1):\n          if is_square_and_fair(i): count = count + 1\n  \n      return count\n  \n  def main():\n  \n      count = int(sys.stdin.readline())\n      for index in range(count):\n          result = process()\n          print \"Case #%d: %s\" % (index + 1, result)\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"n": ["log", "l", "j", "z", "t", "u", "nan", "pn", "out", "r", "nu", "v", "s", "node", "ot", "nw", "array", "np", "ne", "net", "an", "ln", "name", "k", "d", "p", "m", "na", "dn", "ns", "x", "ni", "num", "N", "o", "rn", "nat", "nb", "e", "names"], "i": ["ai", "l", "ip", "j", "z", "eni", "key", "u", "ti", "t", "ri", "ib", "col", "I", "r", "v", "s", "ui", "qi", "ori", "ic", "yi", "phi", "int", "xi", "ie", "bi", "k", "li", "ei", "d", "id", "p", "m", "iu", "list", "x", "ni", "pi", "di"], "root": ["size", "alpha", "null", "ow", "random", "error", "br", "loc", "right", "rew", "core", "path", "max", "r", "range", "node", "central", "zero", "ot", "rup", "array", "order", "bin", "ne", "total", "child", "parent", "rt", "oot", "p", "rank", "seed", "round", "ree", "x", "deep", "num", "row", "o", "length"], "a": ["aa", "ai", "l", "wa", "sta", "ab", "ama", "za", "u", "va", "am", "oa", "r", "s", "ba", "au", " A", "A", "sa", "asa", "name", "k", "aw", "ga", "area", "ae", "d", "p", "na", "x", "o", "ac", "ya", "da", "la", "ea", "e", "self", "an", "ad"], "b": ["xb", "l", "aa", "j", "ab", "abb", "br", "ib", "u", "bb", "rb", "boot", "emb", "r", "s", "ba", "wb", "v", "job", "db", "bh", "fb", "name", "bi", "k", "d", "body", "p", "bf", "m", "eb", "be", "bc", "bs", "ob", "x", "other", "bis", "mb", "length"], "count": ["key", "process", "false", "all", "int", "name", "id", "list", "val", "line", "offset", "coll", "counter", "start", "first", "c", "Count", "follow", "add", "size", "case", "core", "data", "true", "group", "array", "limit", "time", "base", "cache", "cb", "en", "code", "number", "patch", "more", "nt", "end", "null", "col"], "index": ["condition", "page", "obj", "key", "out", "error", "loc", "insert", "col", "input", "value", "found", "connection", "data", "slice", "coord", "append", "style", "expression", "int", "level", "type", "name", "see", "current", "pos", "id", "active", "position", "x", "val", "num", "prefix", "point", "row", "match", "di", "ix", "length", "inc"], "result": ["summary", "page", "obj", "final", "error", "valid", "comment", "df", "url", "rate", "r", "value", "found", "data", "msg", "array", "default", "content", "func", "compl", "dict", "entry", "work", "resp", "round", "ret", "fr", "runner", "list", "success", "err", "val", "res", "response", "match", "search", "draw", "json", "grade", "length"]}}
{"code": " \n  \n  def calculate_max_score(scores_sum):\n      if scores_sum % 3 == 1:\n          max_score = (scores_sum + 2) / 3\n          return (max_score, max_score)\n      if scores_sum % 3 == 2:\n          max_score = (scores_sum + 1) / 3\n          return (max_score, max_score + 1)\n      max_score = scores_sum / 3\n      if max_score == 0:\n          return (0, 0)\n      return (max_score, max_score + 1)\n  \n  def find_max_dancers(s, p, *scores_sums):\n      dancers_count = 0\n      for scores_sum in scores_sums:\n          (normal_max, surprise_max) = calculate_max_score(scores_sum)\n          if normal_max >= p:\n              dancers_count = dancers_count + 1\n              continue\n          if surprise_max >= p and s > 0:\n              s = s - 1\n              dancers_count = dancers_count + 1\n              continue\n      return dancers_count\n  \n  def main():\n  \n      case_count = int(sys.stdin.readline())\n  \n      for case_index in range(1, case_count + 1):\n          line = sys.stdin.readline().strip().split(' ')\n          s = int(line[1])\n          p = int(line[2])\n          scores_sums = [int(scores_sum) for scores_sum in line[3:]]\n          print 'Case #%i: %s' % (case_index, find_max_dancers(s, p, *scores_sums))\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"scores_sum": ["scores_average", "scores_max", "scores__min", "scores6sum", "scoresessession", "scors_size", "scors_session", "scoresesmatch", "scorespmatch", "scoresescount", "scoresacsum", "scores2um", "scoresJloc", "scopes_col", "scopes_count", "scors_mass", "scores__um", "scores_size", "scores6average", "scoresacloc", "scores_min", "scores__total", "scores_index", "scores2count", "scoresaccount", "scoresxnum", "scores2min", "scors_min", "scores__num", "scores64sum", "sccore_sum", "scoresJcount", "scors_cum", "scorespcount", "scoresacsim", "scors_average", "scores_dot", "scors_total", "scores6raw", "scors_raw"], "max_score": ["max33call", "maxfulscale", "max48score", "max\u00b7score", "std_live", "stdFcall", "maxJsquare", "max_feature", "key_square", "max_speed", "maxlyscar", "maximum_score", "max\u00b7match", "maxdscore", "max33live", "max28score", "max67clean", "maxLclean", "max64match", "best64source", "max_scale", "max64sc", "maxlysquare", "maximum_sum", "maxedscore", "maxalllive", "maxLscore", "std_status", "maxfulcall", "rootfulscale", "key_speed", "rootfulscore", "max48grade", "maxedsquare", "max_status", "best64sum", "maxallscore", "max_sc", " max_match", "max_match"], "s": ["l", "i", "t", "b", "sa", "tests", "stats", "sh", "tp", "service", "o", "posts", "xs", "h", "y", "start", "string", "c", "params", "g", "sb", "si", "lines", "size", "case", "ims", "ses", "sf", "se", "storage", "sync", "m", "ns", "x", "ops", "spec", "sp", "ls", "ssl", "a"], "p": ["P", "l", "ip", "j", "pm", "z", "pp", "per", "py", "i", "t", "u", "progress", "null", "pn", "api", "eps", "n", "lp", "b", "pr", "pe", "cp", "v", "op", "port", "pu", "jp", "np", "ping", "part", "current", "d", "m", "pid", "wp", "power", "x", "pi", "er"], "dancers_count": ["dancers6count", "dores_sum", "dancers6sum", "ders__core", "ders__list", "dancersaccatch", "dancersacmin", "dards_sum", "dancers__core", "dancers_cache", "dancers6catch", "dancers__catch", "dorers_all", "dancers36sum", "dorers_count", "dards_count", "dancers___type", "dancers__count", "dancers_type", "dancers___length", "dores_count", "dancers_min", "dancersaccount", "dancers___list", "dards___length", "dancers___sum", "dancers___core", "dancers6max", "dancersJcount", "dancers__max", "ders__count", "dancers___cache", "dancers__type", "ders_count", "dancers36catch", "ders_core", "dancersJlist", "dancers_max", "dores_catch", "dancersJtype"], "normal_max": [" normal_rank", "custom_total", "normalacmin", " normal_first", "normalacbox", "normal_rank", " normal_min", "normal\u00b7box", "normal\u00b7max", "normal_min", "normalacmax", "normalicalrank", "custom_min", "normalicalmin", "normal\u00b7total", "normal_first", "normalicalmax", "normalactotal", "normal_box", "normalicalfirst", "custom_max", "custom_box", "normal\u00b7min", "normal_total"], "surprise_max": ["surprise2max", "surprises_max", "surprises_min", "surprise2min", "surprising_max", "surprise_min", "surprise2mod", "surprising_rank", "surprises_mod", "surprise_rank", "surprise_mod", "surprising_min"], "case_count": ["casejindex", "cases_range", "casePrange", " case_total", " case_start", "casePindex", "cases_class", "casePcount", "case_range", "casejrange", "casePclass", "casejcount", "case_class", "case_total", "cases_index", "casejclass", "case_start", "cases_count"], "case_index": ["caseIDpos", "caseIDlabel", "case_label", "case__ind", " case_id", "caseIDindex", "case__index", "caseIDcount", "case__count", "case_pos", " case_ind", "case__id", " case_pos", " case_label", "case_ind", "case_id"], "line": ["co", "l", "inline", "key", "shell", "stroke", "b", "de", "ne", "frame", "name", "file", "look", "list", "lf", "cle", "string", "c", "column", "LINE", "log", "section", "le", "lo", "lines", "case", "out", "data", "profile", "group", "se", "item", "sync", "entry", "time", "no", "code", "use", "date", "end"], "scores_sums": ["scores_nsessions", "scores_dum", "scores_dubs", "scores_summ", "scores_setsamples", "scores_nsums", "scores_dums", "scores_subs", "scores_pessions", "scores_gsims", "scores_tessions", "scores_sessions", "scoresallsums", "scores_ssum", "scores_gsouls", "scores_gsunks", "scores_nessions", "scores_dims", "scores_nsumm", "scores_statsunks", "scores_nims", "scoresallsunks", "scores_gsubs", "scores_setsessions", "scores_ssunks", "scores_setsums", "scores_namples", "scores_gsums", "scores_nsets", "scores_pum", "scoresallstatsum", "scoresallstatsums", "scores_ssums", "scoresallstatsouls", "scores_tets", "scores_statsums", "scores_pets", "scores_statsum", "scoresallsouls", "scores_pums"]}}
{"code": "'''\n  Created on Apr 12, 2013\n  \n  @author: Moatasem\n  '''\n  \n  \n  \n  def isPalindrome(word):\n      isPalin=False\n      if(len(word)%2==0):\n          f_half=word[0:len(word)/2];\n          s_half=word[len(word)/2:len(word)][::-1]\n          if( f_half==s_half):\n              isPalin= True\n      else:\n          f_half=word[0:len(word)/2]\n          s_half=word[(len(word)/2)+1:len(word)][::-1]\n          if( f_half==s_half):\n              isPalin= True\n      return isPalin\n      \n  def getNumberOfFairAndSquare(range_):\n      start=range_[0]\n      end=range_[1]\n      count_=0\n      for i in range(start,end+1):\n          root=math.sqrt(i);\n          if(root.is_integer() and isPalindrome(str(int(root))) and isPalindrome(str(i))):\n              count_+=1\n      return count_\n          \n          \n      \n  \n  f_r = open('C.in',\"r\")\n  n_test=int(f_r.readline().strip()) \n  f_w = open(\"C.out\", \"w\")\n  for i in range(n_test):\n      range_ =map(int,f_r.readline().split())\n      result=getNumberOfFairAndSquare(range_)\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n  f_r.close()\n  f_w.close()\n", "substitutes": {"word": ["address", "color", "byte", "key", "way", "character", "input", "int", "function", "name", "sex", "list", "language", "line", "point", "video", "string", "question", "char", "tag", "feature", "doc", "speech", "image", "double", "voice", "case", "old", "value", "term", "Word", "phrase", "words", "time", "x", "token", "hyp", "layer", "year", "make"], "isPalin": [" isMargout", " isMargsin", "isPalnin", "isHamnin", "isSchatin", "isMargine", " isPalsin", " isSpind", "isPalatin", "isResins", "ispalinn", "isMalnin", "isResine", "isPalins", " ispalunin", " isPaline", "isMargin", "isPaline", " isPalatin", "isMargout", "isHamin", "isKaline", "isMargatin", "isSchin", " isPalnin", "isKalini", "isKalsin", "isValini", "isKalin", " isMargin", " isPalinn", "isSpind", "ispalunin", "isPalunin", "isValsin", "isSchout", " isSpins", "isResind", " isPalout", "isSchoin"], "f_half": ["fpsize", "f_right", " f_partial", "ssOsize", " f_both", "f_near", "in_half", "in_right", "ss_slice", "f_slice", "iachalf", "f_size", "ssOhalf", "iacscale", "ss_half", "fOhalf", "iaccenter", "f_partial", "fipnear", "i_half", "i_scale", " f_part", "fpboth", "in_kel", "facscale", "fphalf", "faccenter", "fappcount", "fipkel", "f_part", "ssOslice", "fappscale", "f_both", "fOslice", "fOsize", "f_scale", "fOboth", "i_center", "fachalf", "iaccount"], "s_half": [" s_part", "soyhalf", "s_pair", "s_far", "savehat", "seyside", "s_part", "seyhalf", "savehalf", "s_len", "s_la", "s_full", "sayside", "s_middle", "soylen", "soysize", "seymiddle", "s_near", "sianpair", "siannear", "s7far", "saytwo", "savela", " s_far", "s_size", "s7hat", "s7la", " s_pair", "soypart", " s_near", "seytwo", " s_la", " s_hat", "r_middle", "rayside", "sianhalf", "r_side", "saymiddle", "raymiddle", "rayhalf"], "range_": [" range2", "range__", "ange2", "rangePool", "framePool", "frame__", "Range_", "resource1", "feature_", "Range__", " range__", "RangePool", "Range2", "numberPool", "resource__", "range1", "rulePool", "ange_", "rule__", "Range1", " rangePool", "number_", "frame1", "resource_", "resourcePool", "rule_", "range2", "number1", "number__", "rule1", "frame_", " range1"], "start": ["step", "l", "j", "min", "size", "case", "max", "art", "rest", "loc", "set", "n", "range", "r", "now", "shift", "source", "scale", "front", "next", "int", "name", "k", "part", "id", "p", "rank", "work", "time", "index", "mid", "length", "offset", "head", "year", "stop", "first", "f", "c", "use"], "end": ["END", "ff", "open", "size", "z", "api", "max", "then", "after", "loc", "set", "rest", "old", "n", "range", "r", "post", "append", "order", "pos", "id", "entry", "limit", "ion", "inner", "index", "x", "until", "win", "send", "ended", "length", "est", "offset", "End", "e", "edge", "ed", "ad", "en"], "count_": ["depth__", " count2", "list__", "count2", "depth2", "total_", " count__", "list_", "catch2", "depth_", "count__", "sum_", "catch_", "list2"], "i": ["l", "ti", " I", "b", "qi", "phi", "uri", "int", "iri", "multi", "ei", "id", "o", "io", "iq", "h", "y", "c", "ini", "ci", "si", "j", "ri", "im", "r", "xi", "bi", "m", "inner", "x", "ali", "ix", "mini", "strength", "series", "ice", "a", "gi", "index", "cli"], "root": ["roc", "ip", "alpha", "null", "ow", "error", "ib", "rest", "right", "ri", "loc", "path", "src", "core", "n", "r", "range", "count", "ih", "node", "rup", "ic", "order", "uri", "total", "bin", "iri", "type", "child", "ie", "init", "parent", "nr", "ro", "id", "p", "rank", "seed", "round", "go"], "f_r": ["f24r", "f24ro", "f_right", "f_out", "f24sr", "f5r", "f___l", "f2out", " f2out", "f2w", "sf_r", " f2R", "f5ro", "f_sr", "fader", " f2r", "f5w", "fpyR", " f_out", "sf_l", "fen_w", "f24e", "f_ro", "fen_R", " f_sr", "f_R", "sf_ro", "f5l", "fen_r", "fpyr", " f_R", " f_ro", "fadee", " f_e", "f___r", "f_e", " f2w", "fadesr", "fpyout", "fpyw"], "n_test": ["n_match", " n_match", " n__test", "n__trial", "N_match", "n2match", "n2testing", "n_testing", " n__match", " n_case", "N_train", " n__trial", "n2test", "N_test", "n_train", "n__case", " n_trial", "N_testing", " n__case", "n_trial", "n__match", "n__test", "n_case", "n2train"], "f_w": ["f_raw", "f__l", "f7w", "f_out", "fockwa", "f7l", "f__w", "f_wa", "input_raw", " f_rw", "input_w", "input_r", "f_l", "input8out", "f_ws", " f_wa", "f___raw", "f_rw", " f_ws", "f8wa", "input8raw", "f8rw", "f8r", "fockrw", " f_out", "f8w", "f__ws", "f7ws", "input8w", "fockw", "f___r", "f___out", "input_out", "f8out", "f8raw", "f7out", " f_l", "input8r", "f___w", "fockout"], "result": ["answer", "example", "case", "error", "df", "valid", "description", "rate", "range", "r", "count", "value", "data", "default", "arr", "dict", "mer", "re", "work", "resp", "ret", "runner", "err", "success", "block", "val", "res", "response", "match", "str", "row", "grade", "length", "our", "cache", "report", "resolution", "diff", "output", "message"], "output_str": ["output_string", " output_string", "outputGstr", "Output_str", "outputablestress", "Output_sr", "outputGStr", "outputablestr", "outputGstring", "outputablesr", " output_temp", " output_Str", "output_sr", "outputGtemp", "output_temp", "output2Str", "Output_Str", "output2temp", "output2str", "outputableStr", "output2string", "output_Str", "output_stress", "Output_stress"]}}
{"code": "'''\n  Created on Apr 14, 2012\n  \n  @author: moatasem\n  '''\n  \n  \n  def isSurprising(t):\n      if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):\n          return True\n      else:\n          return False\n  \n  \n  def getAllTriplets(n):\n      h=[]\n      for i in xrange(11):\n          for j in xrange(i,11):\n              for  k in xrange(j,11):\n                  if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):\n                      h.append((i,j,k))\n              \n      return  h\n  \n  def getInfo(p,total,S):\n      g= getAllTriplets(total)\n      if(S):\n          s_=len(g)\n          indcies=[]\n          for i in xrange (s_):\n              if(isSurprising(g[i])):\n                  indcies.append(i)\n          for i in xrange (len(indcies)):  \n              g.remove(g[indcies[i]])\n      equ=False\n      sur=False\n      sur_equ=False\n      for i in xrange(len(g)):\n          if(max(g[i])>=p):\n              if(isSurprising(g[i])):\n                  sur_equ=True\n              else:\n                  equ=True\n          elif(isSurprising(g[i])):\n                  sur=True\n      return sur_equ,equ,sur\n             \n  f = open(\"b_.in\", \"r\")\n  n=int(f.readline().strip())\n  for k  in xrange(n):\n      d=f.readline().strip()\n      googlers=[]\n      g=[int(i) for i in d.split(\" \")]\n      N=g[0]\n      S=g[1]\n      noSu=False\n      if(S==0):\n          noSu=True\n      p=g[2]\n      count=0\n      equ_count=0;\n      both_count=0;\n      sur_count=0;\n      first_count=0;\n      googlers=g[3:len(g)]\n      for o in xrange(N):\n          info=getInfo(p,googlers[o],noSu)\n          if(info[0]==True and info[1]==False and S<>0): #101 /100\n              count+=1\n              S-=1\n          elif(info[0]==True and info[1]==True):#110 / 111\n              first_count+=1\n          elif(info[1]==True and info[2]==True):#011\n              both_count+=1\n          elif(info[1]==True):#010\n              count+=1\n          elif(info[2]==True):#001\n              sur_count+=1\n      count+=first_count\n      if(S>0):\n          if(first_count>S):\n              S=0\n          elif(first_count <=S) :\n              S-=first_count\n              if(S>0):\n                   if(both_count>S):\n                      both_count-=S\n                      S=0\n                   else:\n                      both_count=0\n      count+=both_count\n      \n      print 'Case #'+str((k+1))+\": \"+str(count)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n      \n  \n", "substitutes": {"t": ["l", "unt", "z", "u", "r", "b", "s", "v", "ot", "tt", "tu", "te", "int", "it", "type", "tf", "rt", "m", "time", "table", "x", "ta", "tp", "tz", "ant", "lat", "e", "y", "to", "pt", "a", "the", "q", "yt", "c", "T", "ut", "dt", "w", "at"], "n": ["l", "nv", "un", "cn", "z", "size", "pn", "u", "r", "b", "v", "s", "qi", "np", "net", "ne", "nor", "m", "na", "ns", "x", "ni", "num", "pi", "nb", "e", "nt", "nc", "nn", "an", "no", "y", "en", "len", "sn", "ny", "q", "c", "number", "network"], "h": ["l", "oh", "ssh", "z", "auth", "u", "hr", "help", "gh", "H", "r", "b", "s", "v", "hash", "ih", "roth", "ha", "bh", "hand", "hs", "it", " H", "ch", "id", "m", "host", "sh", "he", "th", "ah", "e", "hy", "hm", "hi", "y", "en", "a", "hhh", "q"], "i": ["l", "iw", "ti", "fi", "ih", "b", "qi", "phi", "uri", "int", "init", "multi", "ei", "id", "io", "y", "c", "ini", "ci", "si", "ij", "eni", "ri", "im", "r", "isi", "xi", "bi", "m", "inner", "x", "ni", "ix", "mini", "hi", "a", "gi", "iii", "index", "cli"], "j": ["ak", "J", "uj", "l", "ip", "ji", "z", "ij", "jl", "u", "ki", "py", "ke", "im", "I", "b", "v", "js", "ijk", "qi", "s", "yi", "jp", "ik", "xi", "ie", "ch", "li", "id", "m", "sh", "x", "pi", "jo", "je", "dj", "jj", "th", "jon", "e"], "k": ["ak", "l", "kk", "z", "u", "ki", "dk", "iv", "ke", "r", "b", "s", "v", "ku", "ijk", "ks", " sk", "_", "ic", "ko", "jp", "uk", "ik", "xi", "kn", "ch", "unk", "id", "ok", "m", "kg", "kw", "ky", "go", "mk", "sh", "x", "pi", "e", "y"], "p": ["P", "l", "ip", "z", "per", "pp", "u", "pn", "r", "b", "s", "v", "pr", "lp", "pe", "cp", "port", "op", "jp", "np", "m", "po", "x", "pi", "tp", "bp", "point", "pc", "os", "e", "ps", " P", "sp", "pre", "pg", "y", "pt", "a", "sn", "q"], "total": ["mm", "ip", "sq", "size", "chi", "null", "final", "complete", "iter", "random", "max", "ss", "sup", "ski", "full", "scale", "next", "all", "it", "net", "phi", "parent", "current", "id", "seed", "na", "pi", "num", "tp", "rec", "length", "pg", "Total", "no", "sc", "q", "T", "cost", "ng", "w"], "S": ["P", "J", "Q", "D", "Sc", "ss", "Su", "I", "SG", "H", "s", "M", "SO", "SU", "A", "se", "SN", "sv", "SR", "SA", "SK", "SH", "Sl", "sh", "G", " s", "U", "Sa", "GS", "Sur", "SE", "WS", "CS", "Ns", "W", "Se", "sp", "O", "SL", "Sn"], "g": ["l", "graph", "b", "dr", "gc", "gl", "sh", "ig", "gp", "y", "cfg", "c", "bg", "gg", "reg", "size", "ing", "r", "data", "group", "gen", "ga", "m", "go", "x", "erg", "gn", "ag", "play", "og", "google", "w", "gi", "gs", "groups", "eg", "agg", "u", "gh", "ge"], "s_": ["sDiv", " sDiv", "ns_", "states_", "ions_", "cs_", "nsDiv", "ionsDiv"], "indcies": ["ndcies", "innger", "ndcy", "infger", "Indcies", "Indence", " indcy", "inccy", "ndcs", "investcy", " indger", "investcies", "indcs", "investcia", "indace", "indger", "innence", "infcia", "indc", "infcy", "Indcia", "inscus", "innc", "inncies", "intcus", "indcus", "inccies", "Indcy", " indcia", "intace", "intcies", "inncy", "incc", "ndcus", "indence", "inncia", "intcs", "indcia", "inscs", "intc"], "equ": ["cur", "aqu", "qu", "wh", "answer", "esc", "yet", "desc", "ste", "cc", "adequ", "eight", "loc", "lev", "ur", "sw", "public", "sup", " Equ", "im", "st", "intern", "su", "eq", "upp", "equal", "squ", "ev", "electric", "ell", "ship", "ec", "zen", "fl", "form", "Equ", "sect", "round", "cv", "ef"], "sur": ["esc", "sea", "loc", "sa", "stream", "ptr", "name", "round", "fr", "sh", "subject", "mix", "nn", "supp", "char", "est", "quant", "qu", "ser", "im", "sf", "SU", "ell", "face", "ra", "Equ", "ident", "imp", "sil", "spec", "sp", " Sur", "en", "rect", "st", "sub", "square", "zip", "ur", "u"], "sur_equ": ["Sur_qu", "sur_Equ", "Sur_Equ", "Sur_equ", "Sur_esc", "sur_esc", "sur_eq", "sur_en", "Sur_eq", "Sur_en", "sur_qu"], "f": ["exp", "ff", "fer", "fore", "page", "rf", "folder", "z", "feed", "df", "fig", "ref", "fit", "fi", "sf", "b", "r", "fd", "inf", "fy", "full", "fast", "fe", "fen", "fc", "tf", "afe", "func", "fx", "bf", "m", "file", "arf", "handler", "form", "fr", "fac", "fm", "elf", "io"], "d": ["l", "ld", "dc", "z", "vd", "D", "u", "bd", "r", "b", "s", "v", "cd", "dim", "fd", "de", "data", "did", "md", "dl", "dat", "dot", "do", "ds", "dict", " D", "id", "m", "ded", "std", "rd", "dn", "di", "dom", "da", "e", "dad", "dh", "ad", "du"], "googlers": ["moogling", "googlasses", "moogglasses", "gonglings", "pooglr", "goowlers", "googgblers", "pooglers", "mooggling", "Googsblers", "poogglers", "Googslers", "poogglr", "Googsles", "poogglings", "goowlasses", "googgler", "googglasses", "goowlings", "goonglers", "Googler", "pooglings", "googles", "pooggler", "moogglings", "googslings", "goongles", "goongler", "googsblers", "Googsler", "Googblers", "moogglers", "poogler", "googglers", "gongler", "googlr", "googgling", "mooglasses", "googslers", "googglings"], "N": ["P", "J", "Q", "size", "z", "D", "Z", "NI", "H", "I", "NC", "RN", "M", "NA", "A", "ne", "NG", "SN", "NB", "NE", "TW", "ns", "G", "No", "U", "Ni", "Ns", "W", "O", "E", "C", "Ne", "V", "L", "X", "c", "K", "Y", "T", "B"], "noSu": [" Nosu", "noneSu", "nosu", "noSl", "NOCs", "noneSl", "nonesu", " NoHom", " noCs", " noHom", "noCs", "zerosu", "NOSus", "NOSu", "yesSus", "zeroSu", " noSus", " NoSu", " nosu", "noSus", " NoCs", "yessu", "NOSl", "noHom", "noSequ", "zeroSequ", " NoSus", "yesHom", "zeroSl", "yesSu", " noSequ", " NoSl", " noSl", "noneSequ"], "count": ["size", "case", "iter", "error", "set", "col", "seq", "found", "call", "group", "order", "all", "name", "low", "id", "position", "list", "num", "match", "length", "offset", "base", "cache", "depth", "weight", "coll", "counter", "len", "start", "code", "c", "Count", "cost", "sum", "index", "test", "last"], "equ_count": [" equ_size", "equ_sum", " equ_sum", "equ_size"], "both_count": ["both_len", "two_counter", "two_cache", "both_counter", "bothaccount", "twoaccache", "both_cache", "bothaccache", "two_len", "twoaccount", "twoaclen", "bothaclen", "bothaccounter", "twoaccounter", "two_count"], "sur_count": ["sur_sum", "equ_sum", "equ_length", "sur_weight", "equ_weight", "sur__length", "sur__sum", "sur__count", "sur_length", "sur__weight"], "first_count": ["sec_const", "sec_counter", "first_const", "first2const", "first64const", "sec_count", "sec2count", "first2counter", "sec_low", "first2count", "sec2counter", "first64counter", "first\u00b7count", "first_low", "sec2const", "first\u00b7low", "first\u00b7const", "first2low", "first64low", "sec2low", "first_counter", "first\u00b7counter", "first64count"], "o": ["lo", "co", "l", "OO", "ji", "chi", "obj", "ow", "out", "ti", "oc", "iv", "yo", "oa", "so", "ino", "v", "OT", "ui", "ot", "op", "bo", "object", "nw", "oid", "wo", "xi", "oo", "ie", "do", "li", "id", "ok", "m", "iu", "go", "ob", "po", "pi", "ta"], "info": ["ip", "size", "z", "obj", "Info", "api", "error", "help", "loc", "inf", "thin", "op", "data", "source", "init", "type", "part", "ch", "li", "INFO", "stat", "id", "num", "json", "rec", "extra", "result", "hi", "buff", "diff", "fw", "q", "w", "fo", "sum", "index"]}}
{"code": " \n  def isqrt(num):\n      return int(sqrt(num))\n  \n  def is_square(num):\n      return isqrt(num)**2 == num\n  \n  def is_palindrome(num):\n      return str(num) == \"\".join(reversed(str(num)))\n  \n  def is_fair_and_square(num):\n      return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))\n  \n  def solve(A,B):\n      count = 0\n      for i in range(A,B+1):\n          if is_fair_and_square(i):\n              count += 1\n      return count\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          A,B = [int(x) for x in raw_input().split()]\n          print \"Case #%d: %d\" % (i, solve(A,B))\n          \n", "substitutes": {"num": ["abc", "input", "b", "inf", "all", "uri", "int", "init", "name", "multi", "nom", "mu", "o", "dom", "nam", "test", "h", "gnu", "c", "g", "hex", "Num", "note", "valid", "im", "mon", "term", "mom", "np", "begin", "m", "go", "binary", "umi", "no", "du", "nm", "a", "code", "com"], "A": ["API", "alpha", "D", "Ma", "Data", "SA", "TA", "One", "BA", "Pi", "Input", "Y", "Num", "Fa", "Na", "DA", "H", "AB", "M", "NA", "Am", "KA", "App", "U", "AW", "AD", "AI", "Bar", "Ar", "O", "CA", "Ra", "a", "X", "mA", "FA", "Ak", "AR", "AU", "AA"], "B": ["Q", " b", "D", "UB", "Other", "b", "RB", "LB", "VB", "Bs", "BER", "BB", "EB", "BA", "Bal", "L", "Y", "Num", "WB", "QB", "DB", "IB", "Beta", "AB", "H", "M", "Base", "BU", "PB", "BL", "ABC", "U", "BC", "W", "O", "E", "MB", "V", "X", "OB"], "count": ["cond", "add", "size", "case", "t", "key", "col", "seq", "n", "b", "loop", "found", "call", "array", "order", "all", "total", "int", "type", "default", "child", "part", "current", "id", "p", "rank", "list", "val", "match", "length", "offset", "base", "find", "cache", "depth", "weight", "result", "self", "div", "counter"], "i": ["ai", "l", "ip", "j", "chi", "cli", "ib", "u", "ti", "t", "I", "n", "b", "ih", "v", "input", "qi", "r", "s", "span", "trial", "ic", "yi", "slice", "phi", "it", "uri", "int", "xi", "type", "ie", "k", "bi", "li", "multi", "d", "id", "p", "m", "iu"], "T": ["P", "Q", "TS", "Z", "D", "TH", "t", "H", "I", "n", "TR", "M", "NT", "total", "TC", "ID", "TW", "WT", "TF", "Time", "time", "G", "U", "N", "TN", "length", "W", "O", "Total", "TB", "E", "C", "S", "V", "L", "X", "number", "TT", "Y", "Count"], "x": ["rex", "xb", "ex", "exp", "z", "u", " X", "xe", "dx", "xxx", "xd", "n", "r", "xx", "v", "ux", "xf", "xy", "xi", "xc", "k", "xxxx", "xes", "ww", "id", "p", "work", "wx", " xp", "ax", "rx", "val", " c", "ix", "tx", "e", "xxxxxxxx", "xs", "y", "q"]}}
{"code": "def max_of_triplets(n):\n      a = n//3\n      if (n % 3) == 0:\n          if a == 0 : return (0,0)\n          return (a, a+1)\n      if (n % 3) == 1:\n          return (a+1, a+1)\n      if a == 9: return (10, 10)\n      return (a+1, a+2)\n  \n  def solve(scores, S, p):\n      t = 0\n      for s in scores:\n          a,b = max_of_triplets(s)\n          if a >= p:\n              t += 1\n          elif b >= p and S > 0:\n              t += 1\n              S -= 1\n      return t\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          nums = map(int, raw_input().strip().split())\n          N = nums[0]\n          S = nums[1]\n          p = nums[2]\n          scores = nums[3:]\n          if len(scores) != N:\n              print \"WTF\", i\n          print \"Case #%d: %d\" % (i, solve(scores, S, p))\n      \n", "substitutes": {"n": ["l", "un", "j", "size", "z", "max", "pn", "u", "nu", "v", "r", "nw", "all", "net", "ne", "k", "on", "d", "m", "na", "dn", "ns", "x", "num", "o", "nb", "e", "Ns", "nc", "nn", "an", "cn", "y", "en", "no", "f", "sn", "c", "number", "w"], "a": ["alpha", "art", "am", "au", "sa", "asa", "ha", "aw", "area", "active", "ta", "action", "o", "ap", "ea", "y", "af", "c", "ma", "pa", "aa", "wa", "ab", "r", "array", "about", "existing", "ga", "m", "ana", "x", "auto", "ac", "da", "an", "xa", "w", "at", "off", "fa"], "scores": ["compens", "expores", " scorer", "squares", "SCores", "cores", "squales", "todes", "escodes", "Scores", "core", "scens", "Scales", "squatters", "tales", "scategories", "codes", " Score", "scales", " Scores", " score", "scares", "tategories", "categories", "exporer", "compales", "cales", " scales", "Scens", "SCatters", "expens", "Score", "escategories", "squores", "scorer", " scatters", "escores", " scares", " scens", "SCares"], "S": ["Q", "D", "Sign", "Ps", "Sin", "sa", "int", "SA", "AS", "o", "SE", "St", "Ns", "SL", "L", "Y", "g", "sb", "SS", "si", "size", "H", "M", "SU", "se", "SN", "ns", "U", "WS", "W", "sp", "O", "E", "V", "X", "B", "w", "SI", "R", "TS"], "p": ["P", "l", "lp", "ip", "j", "z", "pp", "per", "py", "u", "pn", "api", "pro", "pressure", "v", "pr", "cp", "pe", "pair", "r", "python", "op", "press", "M", "jp", "np", "NP", "k", "d", "m", "wp", "power", "x", "pi", "tp", "point", "pad", "o", "vp", "pc"], "t": ["l", "j", "z", "null", "u", "r", "v", "ot", "tt", "tu", "all", "it", "int", "type", "tf", "k", "wt", "rt", "d", "m", "time", "table", "x", "ta", "tp", "o", "offset", "e", "ed", "h", "y", "pt", "f", "c", "el", "dt", "at", "ut", "g", "w"], "s": ["l", "es", "sq", "z", "size", "services", "sets", "ss", "sw", "states", "ses", "v", "su", "span", "sa", "se", "sv", "k", "d", "sg", "ns", " self", "tp", "o", "space", "os", "types", "e", "ps", "sp", "ls", "xs", "y", "sn", "sc", "f", "c", "params", "sit", "g"], "b": ["l", "aa", "j", "ab", "z", "ib", "u", "r", "v", "ba", "sa", "A", "fb", "bi", "pa", "d", "ae", "m", "bc", "bs", "x", "bp", "o", "ac", "nb", "ap", "e", "ca", "h", "an", "ad", "y", "f", "c", "g", "B", "w", "sb", "sub", "pb"], "T": ["P", "Q", "DT", "TS", "Z", "D", "TH", "Ti", "Size", "H", "I", "M", "A", "NT", "WT", "Time", "TA", "G", "U", "TN", "length", "W", "O", "E", "C", "Length", "V", "L", "X", "TB", "TT", "Y", "K", "B", "PT", "F", "Num", "R"], "i": ["P", "ai", "l", "ip", "j", "z", "chi", "u", "ti", " I", "ri", "H", "I", "r", "v", "ui", "phi", "it", "uri", "int", "xi", "type", "init", "k", "multi", "li", "d", "id", "pos", "m", "iu", "inner", "x", "pi", "num", "di", "str", "PI", "info", "end"], "nums": ["unubes", "ynums", "tums", " nrams", "cumbers", " numps", "nummies", "unumer", "cems", " nummies", "ynummies", "Nules", " num", "Nums", "cum", "Nems", "numeric", "nems", "tumeric", "Numbers", " nules", " numbers", "ynubes", "nules", "nubes", "Nrams", "numer", "Numps", "nrams", " nubes", "numps", "ynumer", "num", "onumps", " nults", "nults", " nems", "numbers", "unummies", "Numeric"], "N": ["P", "Q", "J", "Size", "D", "Z", "NI", "I", "NC", "M", "NA", "Len", "NT", "A", "NUM", "NG", "SN", "NN", "NE", "NR", "ns", "NL", "G", "num", "NM", "Ni", "Ns", "W", "Number", "O", "Num", "C", "MN", "V", "Ne", "L", "X", "Y", "K", "B"]}}
{"code": " \n  def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      A, B = read_integers()\n      A_root = int( ceil( sqrt( A ) ) )\n      B_root = int( floor( sqrt( B ) ) )\n      count = 0\n      for root in range( A_root, B_root + 1 ):\n          word = str( root )\n          if word == word[ : : -1 ]:\n              word = str( root*root )\n              if word == word[ : : -1 ]:\n                  count += 1\n      print 'Case #%i:' % ( t + 1 ), count\n", "substitutes": {"x": ["xb", "ex", " dx", "z", "i", "u", " X", "dx", "xe", "xxx", "n", "r", "xx", "v", "bit", "data", "xf", "xy", "int", "xi", " you", "sex", "name", "xc", "xxxx", "pos", "d", "p", "id", "wx", " xp", " ff", "event", "ax", "rx", " c", "ix", " f", "e", " xx"], "T": ["P", "DT", "TIME", "Z", "D", "TH", "H", "I", "IP", "M", "NT", "int", "TC", "PT", "TW", "TF", "Time", "time", "TA", "G", "U", "N", "TN", "length", "Text", "W", "O", "Total", "E", "C", "Length", "S", "V", "L", "X", "number", "TT", "Y", "TB", "Count"], "t": ["l", "text", "j", "z", "unit", "u", "i", "col", "n", "b", "s", "v", "qt", "ot", "tt", "trial", "all", "it", "total", "int", "lit", "type", "tf", "k", "d", "id", "p", "m", "time", "tz", "tp", "o", "ty", "ct", "length", "e", "temp", "h", "y", "len"], "A": ["AR", "P", "Ca", "API", "Na", "As", "D", "AU", "AA", "Ma", "LA", "Az", "OA", "H", "I", "AB", "GA", "NA", "AN", "AM", "AP", "AH", "Alpha", "SA", "PA", "App", "TA", "AS", "G", "U", "AW", "EA", "AI", "W", "Ar", "O", "CA", "AF", "One", "E"], "B": ["Q", "P", "J", "WB", "API", "QB", "DB", "D", "FB", "GB", "UB", "Beta", "H", "I", "AB", "b", "BF", "Other", "M", "BU", "PB", "NB", "BL", "Bs", "BBC", "G", "U", "N", "BER", "BB", "BC", "BG", "BE", "BS", "W", "EB", "O", "BA", "E", "C"], "A_root": ["A_roots", " A_row", "A__core", "A__length", " A_length", "A__root", "B__length", "A_row", "B__core", "A_parent", "A_core", "Apyroot", "B__roots", " A_parent", "B_core", "Apyroots", "B_length", "Apycore", "A__roots", "B__root", "Apylength", "A_length", "B_roots"], "B_root": ["B_bot", "b_root", "B67Root", " B_Root", "B_child", "b_roots", " B_bot", "B__root", "B67bot", "B__bot", "b_child", "B_roots", "B67root", "B_Root", "B__Root"], "count": ["log", "add", "text", "size", "case", "key", "error", "max", "iter", "col", "n", "r", "now", "found", "node", "call", "order", "total", "leaf", "type", "name", "part", "tail", "current", "id", "rank", "time", "list", "read", "num", "match", "line", "race", "length", "info", "skip", "base", "comp", "depth", "weight"], "root": ["step", "division", "case", "key", "ow", "rew", "core", "loc", "path", "col", "url", "n", "r", "value", "node", "term", "nw", "chain", "array", "order", "total", "leaf", "child", "type", "level", "name", "default", "parent", "ro", "id", "rank", "round", "time", "val", "num", "prefix", "row", "token", "line", " i"], "word": ["byte", "tool", "key", "way", "right", "b", "wl", "all", "int", "name", "rank", "list", "point", "line", "o", "rule", "start", "tree", "string", "c", "char", "tag", "feature", "speech", "case", "core", "old", "value", "term", "Word", "level", "phrase", "unk", "words", "token", "W", "no", "year", "number", "w"]}}
{"code": "def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 ),\n      line = iter( read_integers() )\n      N = line.next()\n      S = line.next()\n      p = line.next()\n      t = sorted( line )\n      count = 0\n      while t and ( t[ -1 ] + 2 )/3 >= p:\n          t.pop()\n          count += 1\n      if p > 1:\n          while S and t and ( t[ -1 ] + 4 )/3 >= p:\n              t.pop()\n              S -= 1\n              count += 1\n      print count\n", "substitutes": {"x": ["xb", "ex", "l", " dx", "z", "i", "u", " X", "xe", "dx", "xxx", "r", "xx", "v", "xf", "xy", "xi", "xc", "name", "k", "xxxx", "xes", "pos", "fx", "d", "id", "wx", " xp", " ff", "ax", "rx", "val", " z", " c", "ix", "e", " xx", "xxxxxxxx", "xs", " v"], "T": ["P", "Q", "DT", "TS", "Z", "D", "H", "I", "n", "LT", "M", "A", "NT", "ID", "WT", "Time", "TA", "G", "U", "length", "Text", "W", "O", "Total", "E", "C", "Length", "V", "PT", "X", "number", "TT", "Y", "L", "TB", "B", "F", "Type", "K", "MT"], "t": ["l", "i", "b", "ot", "int", "rt", "id", "table", "ta", "tp", "point", "o", "ct", "h", "y", "start", "pt", "tree", "stop", "c", "g", "ut", "j", "out", "iter", "set", "r", "qt", "python", "txt", "se", "et", "m", "time", "token", "sp", "en", "a", "tim", "w"], "line": ["l", "inline", "i", "ne", "id", "phase", "file", "list", "cl", "point", "o", "rule", "edge", "start", "cle", "c", "online", "LINE", "log", "section", "le", "lo", "lines", "case", "out", "core", "set", "group", "next", "se", "order", "level", "sync", "do", "limit", "entry", "no", "code", "w", "cell"], "N": ["P", "J", "Q", "Z", "D", "H", "n", "I", "M", "A", "NT", "NN", "NB", "ns", "G", "NL", "U", " n", "Ns", "W", "O", "E", "Sn", "C", "V", "L", "X", "number", "Y", "K", "B", "F", "NS", "R", "nt"], "S": ["P", "Q", "Na", "TS", "size", "Z", "D", "Size", "out", "ss", "H", "n", "I", "s", "M", "slice", "SU", "A", "Sp", "Time", "SK", "Sl", "SH", "G", "U", " s", "Sa", "SE", "W", "ps", "sp", "O", "SL", "E", "SC", "SP", "C", "f", "V", "Si"], "p": ["P", "l", "ip", "j", "per", "pp", "i", "u", "pn", "n", "r", "b", "s", "v", "pr", "I", "pe", "M", "post", "cp", "op", "np", "NP", "d", "pos", "m", "PA", "pi", "tp", "point", "o", "pc", "ap", "e", "ps", " P", "sp", "h", "pre", "y"], "count": ["P", "cond", "cur", "l", "new", "size", "z", "case", "key", "error", "i", "old", "col", "seq", "n", "b", "now", "s", "call", "span", "data", "group", "left", "all", "total", "int", "type", "child", "level", "name", "part", "current", "limit", "id", "time", "num", "match", "length", "offset", "end"]}}
{"code": " \n  def isPalindrome(x):\n      x = str(x)\n      if x[0] != x[-1]:\n          return 0\n      y = x[::-1]\n      if x == y:\n          return 1\n      return 0\n  \n  def generate():\n      digits = [str(x) for x in range(0,10)]\n      dplus = digits + [\"\"]\n  \n      for x in range(1,10):\n          y = x**2\n          if isPalindrome(y):\n              print y\n  \n      for x in range(1,10**4):\n          x = str(x)\n          y = x[::-1]\n          pals = [ int(x+z+y)**2 for z in dplus ]\n          for p in pals:\n              if isPalindrome(p):\n                  print p\n  \n  if __name__ == \"__main__\":\n      f = open( sys.argv[1] )\n      sqpals = np.array([int(l) for l in f])\n      sqpals.sort()\n      f.close()\n  \n      f = open( sys.argv[2] )\n      t = int(f.readline())\n      t = 1\n      for l in f:\n          a,b = [int(x) for x in l.split()]\n          mt = sqpals >= a\n          lt = sqpals <= b\n          output = sum( mt&lt )\n          print \"Case #%s: %s\"%(t,output)\n          t += 1\n      \n", "substitutes": {"x": ["ex", "alpha", "rax", "i", "loc", "input", "xx", "int", "sex", "name", "id", "host", "file", "rx", "point", "o", "ct", "tx", "xs", "h", "string", "c", "Y", "g", "px", "hex", "image", "j", "r", "data", "cross", "python", "array", "xy", "xi", "xxxx", "ww", "m", "time", "ix"], "y": ["i", "xx", "sky", "yz", " py", "ym", "o", "h", "c", "Y", "j", "yy", "py", "yo", "python", "xy", "ies", "xi", "vy", "m", "my", "yr", "ya", "zy", " yo", "iz", "iy", "year", "X", "w", " Y", "u", "wy", "ady", "fy", "yi", "isy", "ly", "k", "d"], "digits": [" Digbits", " Digitals", "multiplit", "positals", "multiplits", "posbits", " digbits", " digites", "Digits", "digists", "digit", "posures", " digit", "digures", "digitals", "Digists", "posits", " digists", "Digites", "digbits", " Digits", "multiplists", "multiplites", " Digures", " digitals", "digites", " digures", "Digit"], "dplus": [" dappa", "adraw", " dminus", " dPlus", "dminus", "dappa", "fdplus", " draw", "lraw", "lminus", "fdappa", "DPlus", "Dplus", "draw", "Dappa", "adminus", "fdminus", "fdPlus", "dPlus", "Dminus", "lplus", "adplus"], "pals": ["lale", "palls", "lalls", "lals", "Pales", "Pins", " pins", " palls", "ppals", "pales", "Pale", "Pals", "pins", "Palls", "ppale", "pale", "lins", "cpales", "ppins", "ppalls", "cpalls", "cpals", " pales", "cpins"], "z": ["j", "Z", "zip", "alpha", "za", "i", "u", "zh", "n", "r", "s", "v", "yi", "xy", "int", "zen", "k", "d", "cz", "yz", "m", "vy", "pos", "id", "wx", "pi", "tz", "zy", "e", "ze", "h", "zi", "iz", "nz", "long", "code", "q", "c", "Y", "g"], "p": ["P", "ip", "j", "pp", "amp", "pl", "i", "pn", "py", "n", "lp", "pm", "v", "pe", "cp", "pr", "op", "array", "jp", "np", "int", "part", "d", "pos", "par", "m", "pot", "wp", "pi", "bp", "tp", "point", "pad", "o", "pc", "ap", "e", "ps", "sp", "gp"], "f": ["fun", "uf", "i", "feed", "fi", "inf", "fen", "all", "fc", "frame", "file", "handler", "fr", "line", "o", "io", "lf", "conf", "h", "fw", "af", "c", "g", "fp", "fo", "le", "fer", "j", "iter", "r", "sf", "fe", "al", "m", "fold", "ft", "files", "w", "fa", "u"], "sqpals": ["squarepals", "sqPals", "sqiulas", "sqpales", "sqialls", "squarepalls", "qcpals", "qcpels", "sqhals", "qqcpals", "sqcpalf", "squarecpales", "qpall", "sqlales", "sqPalls", "qpales", "sqPales", "sqlalls", "squarecpalls", "sqpulas", "qcpales", "qpals", "sqcpels", "sqhels", "qpels", "qqcpalls", "sqrepals", "sqmals", "sqrepalf", "sqmels", "sqpalf", "sqPulas", "squarecpals", "sqcpals", "sqlals", "sqhalls", "qqpals", "qpalls", "sqcpalls", "sqPalf"], "l": ["le", " L", "j", "lines", "pl", "i", "u", "loc", "n", "lp", "s", "v", "yl", "r", "dl", "left", "it", "lit", "xi", "ell", "ln", "li", "al", "d", "fl", "m", "file", "list", "cl", "lis", "line", "o", "lin", "e", "il", "ls", "lu", "len", "ul", "ml"], "t": ["text", "tc", "j", "i", "u", "out", "n", "r", "s", "v", "count", "tt", "trial", "total", "int", "type", "tf", "tm", "rt", "d", "m", "trace", "time", "tz", "ta", "tp", "num", "o", "tw", "bot", "offset", "tn", "e", "temp", "h", "start", " T", "pt", "tmp", "q"], "a": ["aa", "ai", "sta", "ab", "alpha", "api", "i", "u", "am", "n", "r", "s", "ba", "au", " A", "A", "sa", "array", "area", "ae", "d", "m", "ta", "o", "ac", "la", "ap", "ea", "e", "an", "ad", "ca", "ar", "c", "ma", "at", "w", "pa", "aj"], "b": ["bars", "j", "ab", "abb", "bl", "ib", "rb", "i", "u", "n", "r", "s", "v", "wb", "ba", "fb", "bi", "d", "be", "bf", "m", "eb", "bc", "bs", "ob", "bp", "o", "lb", "nb", "e", "base", "bt", "diff", "c", "B", "w", " B", "beta", "sb", "end"], "mt": ["format", "mm", "sm", "sta", "mr", "mn", "ms", "mp", "lp", "md", "mot", "qt", "gt", "tt", "meta", "int", "lag", "type", "struct", "utm", "tm", "wt", "rt", "li", "pos", "bf", "m", "ta", "tp", "mu", "mi", "tta", "mat", "fm", "ct", "alt", "vt", "nat", "bt", "nm"], "lt": ["log", "ld", "unt", "min", "br", "bl", "unit", "GT", "au", "gt", "flat", "wl", "Lt", "left", "dl", "ilt", "int", "ne", "ln", "wt", "fl", "li", "rt", "pot", "lr", "bc", "xt", "alt", "offset", "nat", "let", "ol", "ls", "lett", "len", "elt", "tmp", "mult", "LP", "lc"], "output": ["config", "format", "section", "text", "summary", "log", "new", "example", "progress", "out", "contract", "Output", "complete", "target", "unit", "input", "print", "flat", "data", "put", "qa", "type", "struct", "write", "article", "dot", "wt", "document", "current", "phase", "response", "prefix", "mat", "ilo", "control", "offset", "ou", "result", "temp", "version"]}}
{"code": " \n  \n  if __name__ == \"__main__\":\n  \n      f = open( \"B-small-attempt1.in.txt\" )\n      g = open( \"output_small.txt\", \"w\" )\n  \n      f.readline()\n      line = f.readline()\n      caseI = 1\n      while line != \"\":\n          line = [ int(x) for x in line.split() ]\n          N = line[0]\n          surprise = line[1]\n          p = line[2]\n          points = line[3:]\n          points.sort()\n          points.reverse()\n  \n          maxp = 0\n          either = 0\n          make_surprise = 0\n          for x in points:\n              this_p = (x+2)/3\n              if x in [0,1,29,30]:\n                  if this_p >= p:\n                      maxp += 1\n              elif this_p >= p:\n                  either += 1\n                  maxp += 1\n              elif this_p == p-1 and (x+2)%3 > 0:\n                  make_surprise += 1\n              else:\n                  either += 1\n  \n          if make_surprise >= surprise:\n              make_surprise -= surprise\n              maxp += surprise\n              make_surprise = 0\n          else:\n              maxp += make_surprise\n  \n          g.write( \"Case #%s: %s\n\"%(caseI,maxp) )\n  \n          line = f.readline()\n          caseI += 1\n  \n      f.close()\n      g.close()\n      \n", "substitutes": {"f": ["log", "l", "j", "uf", "rf", "z", "folder", "feed", "df", "t", "i", "u", "iter", "fi", "sf", "b", "s", "v", "fd", "inf", "r", " df", "fe", "group", "fen", "fc", "xf", "fb", "tf", "al", "d", "fx", "bf", "m", "file", "form", "fr", "fac", "fm", "o"], "g": ["bar", "log", "l", "reg", "graph", "mg", "j", "game", "out", "u", "t", "gh", "vg", "n", "ge", "b", "r", "v", "s", "msg", "group", "gr", "FG", "rg", "ga", "d", "m", "gc", "gd", "sg", "go", "gl", "mc", "G", "erg", "gn", "gui", "gap", "ag", " gn"], "line": ["l", "inline", "i", "model", "eline", "live", "frame", "name", "phase", "id", "file", "list", "val", "point", "o", "lf", "edge", "L", "string", "c", "cle", "column", "online", "LINE", "log", "section", "note", "lo", "lines", "obj", "case", "out", "iter", "data", "group", "cycle", "se", "item", "sync", "do"], "caseI": ["Casei", "catchE", " caseN", "caseN", "caseID", "CaseID", "CaseI", "catchID", "testI", "catchN", "CaseN", " casei", "caseE", " caseE", "testN", "catchI", " caseID", "CaseE", "testi", "casei"], "x": ["ex", "l", "t", "i", "abc", "xd", "xx", "all", "int", "sex", "name", "rx", "point", "tx", "xs", "h", "y", "c", "px", "j", "case", "r", "working", "data", "cross", "python", "xy", "xi", "sync", "m", "time", "my", "ix", " exam", "ice", "code", "X", "number", "patch", "w"], "N": ["P", " network", "Z", "n", "M", "next", "it", "np", "choice", "nor", "nr", "G", "sequence", "num", "any", "No", " n", "est", "nb", "Ns", "Number", "O", "nc", "no", "nz", "Point", "C", "axis", "X", "Y", "T", "network", "correct", "Num", "R", "Points"], "surprise": ["syprise", "syprising", "curvey", "Survey", "promprise", "syvey", "enterrage", "surprising", "curprises", "currage", "survey", "seprising", "promprising", "promvey", "enterprise", "syprises", "surprises", "Surprising", "Surprises", "enterprises", "promprises", "surrage", "curprising", "enterprising", "seprises", "sevey", "seprise", "Surprise", "Surrage", "curprise"], "p": ["P", "l", "j", "z", "pp", "case", "t", "i", "u", "n", "r", "b", "lp", "s", "v", "pe", "np", "part", "k", "pa", "pos", "d", "m", "position", "pi", "tp", "bp", "point", "up", "pc", "ap", "e", "ps", " P", "sp", "pre", "h", "y", "start", "pt"], "points": ["P", "format", "elines", "features", "lines", "z", "years", "example", "sections", "ins", " lines", "case", "ices", "eps", "path", "n", "shows", "codes", "data", "images", "faces", "grades", "parts", "breaks", "events", "grid", "pos", "phase", "words", "works", "position", "objects", "time", "notes", "chains", "charges", "details", "point", "times", "steps"], "maxp": ["maxpt", "Maxpt", " maxP", "Maxi", "MAXp", " maxpt", "maxpoint", "Maxc", "centp", "totalf", "minc", "totalP", "totalp", "centP", "MAXpoint", "Maxf", "showP", "maxpc", " maxf", "Maxp", "MAXP", "maxc", " maxi", " maxpc", "Maxpoint", "minp", "centpr", "mini", "maxf", "showpt", "minP", "totalpc", "maxpr", "maxi", " maxpoint", "Maxpr", " maxpr", "showc", " maxc", "showp"], "either": ["third", "tri", "anything", "yet", "along", "typically", "then", "way", "right", "could", "may", "error", "only", "one", "r", "often", "annot", "never", "rice", "pair", "each", " any", "both", "choice", "maybe", "usually", "nor", "multi", "nr", "asi", "exclusive", "oct", "also", "sequence", "rx", "any", "other", "enter", "even", "currently"], "make_surprise": ["make_servey", "make_curprise", "make_surprises", "make_Surprising", "make_currance", "make_turvey", "make_turrance", "make_turprise", "make_serprising", "make_serprises", "make_curception", "make_enterrance", "make_serprise", "make_Surprises", "make_enterprising", "make_enterception", "make_entervey", "make_enterprises", "make_promvey", "make_survey", "make_surception", "make_promprise", "make_subprise", "make_enterprise", "make_curprises", "make_Surprise", "make_Survey", "make_turprises", "make_promprises", "make_curvey", "make_surrance", "make_curprising", "make_surprising", "make_subprising", "make_subprises", "make_subception", "make_promprising"], "this_p": [" this_point", " this_pre", "this_c", " this_z", " this_c", "This_p", "this_z", " this_P", "this_point", "This_c", "this_P", "This_P", "this_pre", "This_point"]}}
{"code": " \n  possibles = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]\n  \n  for case in xrange(codejam.readint()):\n      A, B = map(int, codejam.readstring().split())\n      count = 0\n      for possible in possibles:\n          if A > possible:\n              continue\n  \n          if B < possible:\n              break\n  \n          count += 1\n  \n      print \"Case #%d: %d\" % (case + 1, count)\n", "substitutes": {"possibles": [" possibilities", "possIBLE", "posible", "pOSSible", "Possibilities", "POSSibilities", " possibility", " posibilities", "positibles", "POSSIBLE", "possibility", "Possibles", "pposIBLE", "pposible", "POSSibles", "pposibility", "possibilities", "Possible", "POSSible", " posibles", "pposibilities", "pOSSibility", "posibilities", "positibilities", "positIBLE", "posibles", "pOSSibles", "pOSSIBLE", "positible", "PossIBLE", "pposibles", " posible", "pOSSibilities", " posibility", "posibility"], "case": ["section", "Case", "address", "ASE", "example", "ce", "mode", "me", "loop", "data", "trial", "pair", "slice", "chain", "ase", "chance", "call", "int", "app", "batch", "ace", "phase", "time", "position", "nce", "bc", "num", "x", "match", "line", "race", "client", "cases", "test", "bug", "cmp", "result", "ice", "asm", "code"], "A": ["P", "State", "API", "As", "DA", "D", "AA", "From", "LA", "Code", "AB", "I", "H", "Data", "M", "GA", "NA", "AM", "AP", "Am", "Alpha", "HA", "RA", "IA", "AL", "This", "ABC", "PA", "Class", "G", "U", "N", "EA", "AD", "AI", "Bar", "BB", "UA", "If", "CA"], "B": ["P", "J", "WB", "DB", "D", " b", "AA", "GB", "IB", "AB", "Other", "H", "b", "BF", "RB", "M", "LB", "VB", "SB", "PB", "AP", "NB", "BL", "Bs", "G", "U", "N", "BER", "BB", "CB", "BG", "BC", "BE", "BS", "EB", "BA", "E", "BD", "C", "MB"], "count": ["cond", "size", "i", "key", "error", "label", "cc", "old", "process", "col", "seq", "e", "b", "loop", "found", "call", "main", "next", "int", "type", "default", "child", "app", "part", "current", "id", "p", "time", "allow", "num", "match", "race", "length", "fail", "base", "bug", "every", "cache", "weight", "depth"], "possible": ["possibly", "cpcould", " possibly", "cpossibly", "hpossibility", "Possibly", " possibility", "hpected", "pair", "possibility", "apair", "Pair", "cpossible", "Possible", " pcould", "hpossibly", "hpossible", "lpossibility", "lpcould", "pcould", "apossible", "Possibility", "lpossible", "lpossibly", " pected", "pected", "cpossibility", "apossibility", "cpected", " pair", "apossibly"]}}
{"code": " \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n", "substitutes": {"start": ["step", "l", "add", "middle", "j", "size", "src", "set", "n", "count", "range", "s", "v", "shift", "source", "next", "se", "int", "ie", "part", "k", "pos", "id", "p", "seed", "index", "x", "send", "length", "space", "offset", "skip", "e", "sp", "len", "like", "diff", "f", "stop", "c"], "elems": ["elmas", "elns", " elemas", "elma", "elens", " elens", "elemes", "elms", " elements", "lemns", " elemes", " elecs", "elmes", "elem", "lemcs", "elema", "Elemas", "elments", "lemm", "lemma", "elemas", "lemments", "lemms", " elema", "Elecs", "elm", "Elems", "elements", "elecs", "Elemes", "elcs", " elem", "lemmes"], "i": ["l", "ai", "j", "z", "ki", "ti", "u", "ri", " I", " ii", " u", "col", "n", "I", "fi", "b", "v", "qi", "ui", "ori", "int", "xi", "k", "bi", "li", "pos", "id", "p", "m", "iu", "x", "pi", "mi", "di", "o", " c", "ix", " j", "idi", " z"]}}
{"code": " \n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tyield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 1\n  \t\tcase = []\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not line_index % n:\n  \t\t\t\tyield case_counter, case\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 0\n  \t\tnew_case = True\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tif new_case:\n  \t\t\t\tnew_case = False\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\n  \t\t\t\tlines_left = int(line.strip())\n  \t\t\t\tif not lines_left:\n  \t\t\t\t\tnew_case = True\n  \t\t\t\t\tyield case_counter, case\n  \t\t\t\tcontinue\n  \t\t\tif lines_left:\n  \t\t\t\tlines_left -= 1\n  \t\t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not lines_left:\n  \t\t\t\tnew_case = True\n  \t\t\t\tyield case_counter, case\n  \t\t\t\n  def part_of_list_to_int(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(int(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_int(array):\n  \treturn part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(float(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_float(array):\n  \treturn part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  \telem_len = len(array[0])\n  \tassert index < elem_len\n  \tfor elem in array:\n  \t\tassert elem_len == len(elem)\n  \tmax_sub = array[0][index]\n  \tmax_elem = array[0]\n  \tfor elem in array:\n  \t\tif elem[index] > max_sub:\n  \t\t\tmax_sub = elem[index]\n  \t\t\tmax_elem = elem\n  \treturn max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  \tlist_len = len(a_list)\n  \tif list_len == 1:\n  \t\tif a_list[0] == value:\n  \t\t\treturn pos\n  \t\treturn -1\n  \tif a_list[list_len/2] > value:\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  \telse:\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  \t\n  def list_index_in_sorted_list(a_list, value):\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\n  \t\n  def check_palindrome(value):\n  \tval_str = str(value)\n  \tlength = len(val_str)\n  \tfor i in xrange(length):\n  \t\tif val_str[i] != val_str[length - 1 - i]:\n  \t\t\treturn False\n  \treturn True\n  \n  def calc_result(case):\n  \tA = int(case[0])\n  \tB = int(case[1])\n  \t\n  \tA_sqrt = int(math.ceil(math.sqrt(A)))\n  \tB_sqrt = int(math.floor(math.sqrt(B)))\n  \t\n  \tprint \"\\tinterval: %s\" % [A, B]\n  \tprint \"\\tsqrt_int: %s\" % [A_sqrt, B_sqrt]\n  \t\n  \tcount = 0\n  \tfor i in xrange(A_sqrt, B_sqrt + 1):\n  \t\tif check_palindrome(i):\n  \t\t\tif check_palindrome(i * i):\n  \t\t\t\tcount += 1\n  \t\t\t\tprint \"\\tfound: %d, %d\" % (i, i * i)\n  \t\n  \tprint \"\\ttot: %d\" % count\n  \tprint \n  \tresult = \"%s\" % count\n  \treturn result\n  \n  def main(filepath):\n  \tstart_time = time.time()\n  \twith file('output.txt', 'wb') as f_out:\n  \t\t\n  \t\tfor case_index, case in iterate_cases_1lpc(filepath):\n  \t\t\t\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\n  \t\t\tresult = calc_result(case)\n  \t\t\t\n  \t\t\tf_out.write(\"Case #%d: %s\n\" % (case_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n", "substitutes": {"filepath": ["Filetext", " filesize", "baseath", " filePath", "filePath", "workname", " fileath", " fileflow", "ilesystem", "fpointer", "fflow", "fsize", "fileflow", "fname", "lineflow", "fPath", "Filename", " filesystem", "filename", "workpath", "filetext", "filesize", "fileath", "Filepath", "linesize", "linesystem", "ilePath", "fcache", "ilepath", " filepointer", "linepath", "workath", "basename", "linePath", "filesystem", "linepointer", "filecache", " filetext", "linecache", "basepath"], "line_index": ["line67index", "link_address", "line6initial", "link_index", "frame24ind", "edgeIdcounter", "line_length", "line6connection", "link67length", "case_number", "frame_counter", "linePcounter", "line67address", "frame_initial", "lineIdinitial", "line_axis", "case_address", "edge_index", "line___index", "line__index", "line6ind", "frame_size", "link67letter", "layer_sum", "lineIdin", "lanePlength", "link67index", "lane_index", "line__length", "frame_connection", "link_letter", "line__in", "line08address", "line24index", "line67letter", "line_type", "lane_counter", "layer_type", "edge_in", "line_point"], "line": ["byte", "inline", "key", "character", "input", "shell", "connection", "de", "model", "chain", "frame", "name", "buffer", "phase", "file", "look", "list", "point", "rule", "edge", "cle", "string", "column", "char", "office", "LINE", "section", "log", "note", "le", "lo", "lines", "out", "label", "data", "profile", "item", "level", "sync", "entry"], "n": ["l", "j", "size", "max", "t", "pn", "u", "b", "r", "nu", "node", "span", "nw", "all", "np", "net", "ne", "ln", "k", "nr", "p", "m", "dn", "ns", "x", " N", "num", "N", "rn", "nat", "nb", "e", "ed", "nc", "nn", "no", "y", "en", "a", "f"], "case_counter": [" case_manager", "case24count", "case24finder", "cases_current", "case_number", "case_finder", "case_consumer", "case__count", "case_Counter", "case24chain", "ice_count", "case24number", "ice_consumer", "case__consumer", "caseJcount", "base_instance", "case24current", "caseJlimit", " case_count", "case_offset", "line_count", "case64current", "cases_count", "cases_chain", "ice_counter", " case_keeper", "case24offset", "case\u00b7sum", "iceJlimit", "case_count", "case_book", "base_book", "cases_counter", "case\u00b7length", "case__limit", "base_manager", "iceJcount", "iceJcounter", "ability_sum", "case_keeper"], "case": ["address", "key", "feed", "ce", "character", "path", "connection", "create", "chain", "ase", "name", "ace", "id", "phone", "rule", "switch", "first", "c", "char", "instance", "ride", "section", "shape", "size", "core", "me", "data", "true", "se", "choice", "do", "time", "sequence", "client", "fold", "base", "cache", "ide", "code", "make"], "new_case": [" new_Case", "newfCase", "new_change", "new_sea", "New_case", "New_ce", "new67case", "newfcase", "new_division", "newfcases", "new67Case", " new_section", "new_cases", "new67section", " new_part", "new67sea", "new_section", "new_ce", " new_cases", "new_part", " new_division", "new_Case", "newfchange", "New_Case", " new_change", " new_sea"], "lines_left": ["linesaclock", "liners_top", "lines_below", "lines6Left", "line_end", "lines_top", "lines128below", "lines_leave", "lines128loaded", "sections_lock", "linesacbelow", "sections_below", "lines_center", "lines6top", "sections_left", "lines6null", "sectionsacloaded", "lines_end", "lines6right", "lines___top", "lines_lock", "lines_less", "lines___left", "lines_joined", "cases_right", "line_left", "lines6end", "lines_null", "lines128left", "liners_center", "liners___leave", "cases_joined", "lines6left", "cases_top", "liners___top", "lines128lock", "sectionsaclock", "liners___center", "sections_loaded", "lines_Left"], "array": ["address", "input", "all", "complex", "function", "multi", "area", "integer", "file", "allow", "list", "ray", "action", "analysis", "coll", "atomic", "string", "instance", "initial", "feature", "image", "section", "multiple", "target", "data", "true", "group", "order", "element", "site", "assembly", "auto", "audio", "arrow", "application", "base", "queue", "a", "com", "view"], "flags": ["fires", "windows", "rings", "all", "stats", "alls", "utils", "weights", "ils", "file", "list", "ffff", "atts", "flag", "fits", "plugins", "dates", "planes", "ols", "vals", "strings", "orts", "versions", "image", "values", "lines", "reports", "data", "les", "allows", "leans", "frames", "words", "rules", "settings", "details", "mask", "local", "tools", "items"], "output": ["address", "process", "input", "model", "all", "int", "struct", "function", "write", "utils", "list", "other", "accept", "offset", "string", "update", "console", " Output", "image", "add", "double", "target", "production", "complete", "out", "core", "exit", "public", "profile", "element", "protected", "dict", "binary", "settings", "send", "control", "cache", "ed", "en", "code"], "index": ["address", "alpha", "key", "loc", "connection", "model", "name", "id", "active", "val", "point", "action", "lead", "fail", "offset", "column", "Index", "initial", "update", "root", "office", "image", "j", "complete", "valid", "label", "insert", "level", "sync", "fill", "x", "end", "open", "example", "unit", "error", "run", "col", "node", "slice"], "elem": ["gelev", "gele", "elev", "eelee", "eelements", "celee", "selement", "elee", "elelements", " elements", "gelem", " ele", "gelement", "ele", "eject", "cele", "eelev", " elee", "element", "gelements", "eeject", "selee", "elelem", "selem", "celement", "geject", "eele", "elelement", "ehem", " element", " ehem", "gelee", "sehem", "elelev", "eehem", "selev", " eject", "eelem", "elements", "sele"]}}
{"code": " \n  class Triplet(object):\n  \tdef __init__(self, i, j, k):\n  \t\tself.i = i\n  \t\tself.j = j\n  \t\tself.k = k\n  \t\tself.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))\n  \t\tself.valid = self.max_diff <= 2\n  \t\tself.surprise = self.max_diff == 2\n  \t\n  \tdef get_tuple(self):\n  \t\treturn (self.i, self.j, self.k)\n  \t\n  \tdef get_redundancies(self):\n  \t\treturn [(self.i, self.j, self.k),\n  \t\t\t\t(self.i, self.k, self.j),\n  \t\t\t\t(self.j, self.i, self.k),\n  \t\t\t\t(self.j, self.k, self.i),\n  \t\t\t\t(self.k, self.i, self.j),\n  \t\t\t\t(self.k, self.j, self.i)]\n  \n  class Googler(object):\n  \tdef __init__(self, total_points):\n  \t\tself.total_points = total_points\n  \t\tself.regular_triplets = []\n  \t\tself.surprise_triplets = []\n  \t\t\n  \t\tfor i in xrange(0, 11):\n  \t\t\tif i > total_points:\n  \t\t\t\tbreak\n  \t\t\tfor j in xrange(i, 11):\n  \t\t\t\tif i + j > total_points:\n  \t\t\t\t\tbreak\n  \t\t\t\tk = total_points - i - j\n  \t\t\t\tif k > 10:\n  \t\t\t\t\tbreak\n  \t\t\t\ttriplet = Triplet(i, j, k)\n  \t\t\t\tself.add(triplet)\n  \t\t\n  \t\tself.can_surprise = len(self.surprise_triplets) > 0\n  \t\tself.actual_triplet = None\n  \t\tself.best_result = -1\n  \t\t\n  \tdef add(self, triplet):\n  \t\tif not triplet.valid:\n  \t\t\treturn\n  \t\tif triplet.surprise:\n  \t\t\tself.add_uniquely(triplet, is_surprise=True)\n  \t\telse:\n  \t\t\tself.add_uniquely(triplet, is_surprise=False)\n  \t\t\t\n  \tdef add_uniquely(self, triplet, is_surprise):\n  \t\tif is_surprise:\n  \t\t\tinput_list = self.surprise_triplets\n  \t\telse:\n  \t\t\tinput_list = self.regular_triplets\n  \t\tfor triplet_redundancy in triplet.get_redundancies():\n  \t\t\tif triplet_redundancy in input_list:\n  \t\t\t\treturn\n  \t\tinput_list.append(triplet.get_tuple())\n  \t\n  \tdef __str__(self):\n  \t\treturn \"regular: %s\nsurprise: %s\" % (self.regular_triplets,\n  \t\t\t\t\t\t\t\t\t\t\t  self.surprise_triplets)\n  \t\n  \tdef set_googler(self, is_surprise=False):\n  \t\tif not is_surprise:\n  \t\t\tself.actual_triplet = self.regular_triplets[0]\n  \t\telse:\n  \t\t\tself.actual_triplet = self.surprise_triplets[0]\n  \t\tself.calc_best_result()\n  \t\n  \tdef calc_best_result(self):\n  \t\tself.best_result = max(self.actual_triplet)\n  \n  \t\t\n  class Contest(object):\n  \tdef __init__(self, num_of_googlers, results):\n  \t\tself.num = num_of_googlers\n  \t\tself.googlers = []\n  \t\tfor i in xrange(self.num):\n  \t\t\tself.googlers.append(Googler(results[i]))\n  \t\n  \tdef calc(self, num_of_surprises, p):\n  \t\tmax_googlers_over_p = 0\n  \t\tfor surprise_perm in self.get_permutations(num_of_surprises):\n  \t\t\tif not self.validate_permutation(surprise_perm):\n  \t\t\t\tcontinue\n  \t\t\tcount = 0\n  \t\t\tfor index, googler in enumerate(self.googlers):\n  \t\t\t\tgoogler.set_googler(index in surprise_perm)\n  \t\t\t\tif googler.best_result >= p:\n  \t\t\t\t\tcount += 1\n  \t\t\tif count >= max_googlers_over_p:\n  \t\t\t\tmax_googlers_over_p = count\n  \t\treturn max_googlers_over_p\n  \t\n  \tdef get_permutations(self, num_of_surprises):\n  \t\tresults = get_perms(0, self.num, num_of_surprises)\n  \t\tif not results:\n  \t\t\treturn [[]]\n  \t\treturn results\n  \t\n  \tdef validate_permutation(self, perm):\n  \t\tfor googler_index in perm:\n  \t\t\tif not self.googlers[googler_index].can_surprise:\n  \t\t\t\treturn False\n  \t\treturn True\n  \n  def get_perms(start_index, finish_index, amount):\n  \tif amount == 0:\n  \t\treturn []\n  \tresult_list = []\n  \tfor i in xrange(start_index, finish_index):\n  \t\tif amount == 1:\n  \t\t\tresult_list.append([i])\n  \t\t\tcontinue\n  \t\tfor result in get_perms(i + 1, finish_index, amount - 1):\n  \t\t\tnew_result = [i]\n  \t\t\tnew_result.extend(result)\n  \t\t\tresult_list.append(new_result)\n  \treturn result_list\n  \t\t\n  def main(filepath):\n  \twith file('dancing_output.txt', 'wb') as f_out:\n  \t\twith file(filepath, 'rb') as f_in:\n  \t\t\tfor line_index, line in enumerate(f_in):\n  \t\t\t\tif line_index == 0: #T\n  \t\t\t\t\tcontinue\n  \t\t\t\tinput_list = line.strip().split(' ')\n  \t\t\t\tnum_of_googlers = int(input_list[0])\n  \t\t\t\tnum_of_surprises = int(input_list[1])\n  \t\t\t\tp = int(input_list[2])\n  \t\t\t\tresults = []\n  \t\t\t\tfor res in input_list[3:]:\n  \t\t\t\t\tresults.append(int(res))\n  \t\t\t\tcontest = Contest(num_of_googlers, results)\n  \t\t\t\tresult = contest.calc(num_of_surprises, p)\n  \t\t\t\t\n  \t\t\t\tprint\n  \t\t\t\tprint line.strip()\n  \t\t\t\tprint result\n  \t\t\t\t\n  \t\t\t\tf_out.write(\"Case #%d: %d\n\" % (line_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n", "substitutes": {"self": ["exc", "co", "l", "graph", "pp", "auth", "ref", "right", "b", "connection", "static", "model", "false", "driver", "all", "hand", "function", "name", "master", "utils", "us", "system", "host", "by", "also", "sh", "list", "other", "field", "cl", "point", "o", "map", "request", "proc", "github", "lf", "conf", "h", "tmp"], "i": ["l", "ti", "fi", "b", "ih", "qi", "phi", "int", "ei", "id", "sh", "o", "io", "h", "y", "start", "c", "ini", "ci", "si", "ij", "eni", "ri", "im", "ish", "xi", "bi", "m", "x", "ni", "ani", "ix", "hi", "a", "ami", "gi", "u", "I", "s", "ui"], "j": ["J", "uj", "l", "key", "t", "ih", "b", "pr", "qi", "em", "sh", "json", "o", "io", "jing", "jit", "h", "y", "start", "c", "ini", "ci", "si", "ij", "jl", "py", "ju", "im", "r", "js", "ish", "java", "xi", "m", "x", "jo", "jj", "sp", "a", "aj"], "k": ["l", "key", "right", "kick", "b", "qi", "ko", "kn", "tk", "id", "kw", "sh", "o", "h", "y", "kid", "c", "g", "kh", "kin", "kr", "kk", "unk", "m", "ek", "x", "ked", "kar", "w", "ak", "u", "dk", "ke", "ku", "ik", "uk", "d", "work", "kg", "ka"], "max_diff": ["maxlexDiff", "max64dist", "max64error", "max64distance", "max_Diff", "max64Diff", "maxlexerror", " max_Diff", "max64diff", "max_error", "maxlexdev", "max_dev", "maxlexdiff", " max_dev", " max_dist", " max_error", "max_distance", " max_distance", "max_dist"], "valid": ["open", "same", "Valid", "new", "complete", "iter", "error", "random", "found", "compatible", "visible", "full", "post", "stable", "live", "all", "total", "dat", "parse", "bad", "multi", "good", "supported", "parent", "running", "dead", "active", "train", "form", "show", "orig", "cat", "err", "val", "verified", "match", "util", "draw", "local", "confirmed"], "surprise": ["serprising", "serprises", "subprising", "curvey", "suvey", "subvey", "servey", "surprising", "curprises", "suprising", "survey", "subprises", "surprises", "suprises", "subprise", "suprise", "curprising", "serprise", "curprise"], "total_points": [" total_groups", "totalxpoints", "max67groups", "total__points", "total67groups", " totalallPoints", "totalxps", "all_points", " total_marks", "total_players", "total36maps", " totalallgroups", "totalThemaps", "total48points", "max_pointers", "max_point", "total__eps", "total36point", "multi_points", "max67Points", "total67points", "total_months", "total36lines", "totalallpoints", "total48point", "totalalpoints", "total48cycles", "all_point", "total_pointers", "total67maps", "total_point", "all_lines", "totalallmarks", " total_eps", "max_Points", " totalallmarks", "totalThepoints", " total_Points", "totalxplayers", "total_groups"], "regular_triplets": ["regular_trippings", "regular_tups", "regular_droplet", "regular_tuplet", "regular_traps", "regular_trappings", "regular_traqs", "regular_tuplets", "regular_promplet", "regular_triqs", "regular_tuqs", "regular_promppings", "regular_traplet", "regular_drops", "regular_tuppings", "regular_traplets", "regular_triplet", "regular_droplets", "regular_droqs", "regular_trips", "regular_promps", "regular_promplets"], "surprise_triplets": ["surprise_triples", "surprise_traplet", "surprise_trips", "surprise_triplet", "surprise_tuplet", "surprise_traps", "surprise_traplets", "surprise_multiplet", "surprise_requpps", "surprise_tripps", "surprise_tups", "surprise_multips", "surprise_trapps", "surprise_traples", "surprise_multiplets", "surprise_requplet", "surprise_tupps", "surprise_requplets", "surprise_multiples", "surprise_requps", "surprise_tuplets", "surprise_tuples"], "triplet": ["triple", " triplets", "trajet", "traple", "diple", "roupped", "Tript", "trips", "rouple", "Triplet", "diject", "Trijet", "diplets", "throplet", "tuject", " triple", "traplets", "tript", "traps", " tripped", "rouplet", "rouject", "Tripped", "traplet", " tript", "trapt", "Triplets", "throps", "tuple", "dijet", "diplet", "traject", "dips", "Triject", "tripped", "throplets", "Triple", "dipt", "roupt", "tuplet"], "can_surprise": ["can_surprising", "can_Survey", "can_Surprising", "can_suprises", "can_subprises", "can_Surprises", "can_suprise", "can_Surprise", "can_suvey", "can_subvey", "can_subprise", "can_survey", "can_surprises", "can_suprising", "can_subprising"], "actual_triplet": ["actual_promplet", "actual_triplets", "actual_promplets", "actual_trapt", "actual_tuplet", "actual_traplet", "actual_promple", "actual_tuplets", "actual_tuple", "actual_tupt", "actual_tript", "actual_traplets", "actual_triple", "actual_prompt", "actual_traple"], "best_result": ["best_results", "first_status", "first_results", "first_result", "best_round", "first_round", "best_status"], "is_surprise": ["is_subvey", "is_subprises", "is_enterception", "is_curception", "is_syprises", "is_curprises", "is_surception", "is_enterprising", "is_syvey", "is_surprises", "is_surprising", "is_curprising", "is_enterprise", "is_syprise", "is_suception", "is_curprise", "is_survey", "is_suprising", "is_curvey", "is_subprising", "is_suvey", "is_suprise", "is_suprises", "is_syprising", "is_enterprises", "is_subprise"], "input_list": ["input_diff", "inputiptype", "input_type", "inputPlist", "input_List", " input__listed", "actionMlist", "input_set", "action_set", " input_source", " input__list", "inputMsource", "input2list", "inputMset", "input2List", "inputMlist", "action_source", "input_listed", "inputiplist", "inputPset", "input__set", "inputipset", "inputiplisted", "actionMcount", "actionMset", " input_diff", " input_listed", "input2set", "inputMcount", "input__listed", " input_name", "action_list", "inputPList", "input_count", "input__type", " input__set", "inputPcount", "input_source", "inputPsource", " input_type"], "triplet_redundancy": ["triplet_redunency", "triplet_redountancies", "triplet_Redountancies", "triplet_Redountance", "triplet_redunant", "triplet_redandonancies", "triplet_redundant", "triplet_Redountancy", "triplet_redountency", "triplet_redandonance", "triplet_redundency", "triplet_Redundance", "triplet_redountancy", "triplet_redountance", "triplet_redundance", "triplet_Redountency", "triplet_redandonancy", "triplet_Redundancy", "triplet_Redountant", "triplet_redoffance", "triplet_redoffancies", "triplet_redoffency", "triplet_redountant", "triplet_redandonant", "triplet_redunancies", "triplet_redundancies", "triplet_redunancy", "triplet_Redundancies", "triplet_redoffancy", "triplet_Redundant", "triplet_redoffant", "triplet_Redundency"]}}
{"code": "def IsPal(n):\n      S = str(n);\n      return S == S[::-1];\n  \n  \n  def Gen():\n      LIM = 10**14;\n      N = 10**7;\n      LIST = [];\n      for i in range(1, N):\n          if IsPal(i):\n              if IsPal(i*i):\n                  LIST.append(i);\n      return LIST\n  \n  PP = Gen();\n  \n  T = int(raw_input());\n  for q in range(1,T+1):\n      [A,B] = map(int, raw_input().split());    \n      ANS = 0;\n      for i in range(len(PP)):\n          if B >= PP[i]**2 >= A:\n              ANS += 1;\n      \n      print \"Case #%d: %d\" %(q, ANS);\n", "substitutes": {"n": ["l", "j", "z", "t", "pn", "u", "r", "b", "s", "v", "nw", "net", "ne", "name", "k", "d", "p", "m", "na", "ns", "x", "ni", "o", "nat", "nb", "e", "Ns", "nt", "nc", "nn", "cn", "no", "y", "a", "sn", "f", "c", "g", "fn", "w"], "S": ["P", "Q", "TS", "D", "ASS", "H", "I", "Su", "s", "M", "SO", "SU", "Sing", "String", "SB", "STR", "SN", "SR", "SA", "SK", "SH", "G", "SAM", "SSL", " s", "GS", "SE", "ISS", "Ns", "W", "INS", "O", "SL", "SC", "SP", "OS", "C", "V", "Si", "L"], "LIM": ["LINK", "LAMP", " LINK", " LOM", "NLOM", "LROM", "NLINK", "NLAMP", "LRIM", "NLIM", "LRAMP", "LOM", " LAMP", "LRINK"], "N": ["Q", "P", "J", "Z", "D", "Size", "NI", "H", "I", "SIZE", "M", "NT", "Len", "NN", "NB", "NE", "NR", "G", "NL", "U", "KN", "PI", "NH", "Ns", "W", "O", "E", "C", "Ne", "V", "L", "X", "K", "Y", "F", "NY", "NS", "R"], "LIST": ["IST", "Q", "l", "IN", "API", "ALL", "Data", "all", "FACE", "list", "VERSION", "SE", "NAME", "PN", "SL", "EST", "L", "ENCE", "AT", "ST", "LO", "TP", " LI", "SIZE", "DATA", "array", "WH", "BL", "INFO", " list", "sequence", "GET", "PUT", "THE", "DO", "X", " List", "TS", "TH", "I"], "i": ["l", "t", "ti", "input", "b", "inf", "qi", "phi", "uri", "int", "id", "list", "o", "io", "h", "y", "start", "c", "g", "ini", "ci", "si", "j", "eni", "r", "xi", "bi", "m", "x", "ni", "mini", "a", "w", "gi", "iii", "index", "cli", "u", "I", "s"], "PP": ["P", "Q", "WP", "pp", "TP", " LP", "DC", "Ps", "AB", "MP", "IP", "PO", "TX", "LB", "PD", "EP", "BP", "NG", "PB", "TC", "PR", "NP", "DP", "BL", "TF", "PA", "GG", "PC", "INC", "PG", "PE", "IPP", "LG", "FP", "RP", "PF", "FF", "CC", "PN", "HP"], "T": ["Q", "P", "TS", "size", "Z", "D", "TH", "t", "TP", "H", "SIZE", "OT", "PO", "TX", "M", "NT", "TC", "VT", "TF", "WT", "G", "U", "KT", "TN", "TI", "length", "W", "Total", "E", "C", "V", "L", "X", "TT", "Y", "K", "CT", "F", "MT", "R"], "q": ["Q", "P", "l", "qu", "j", "sq", "count", "u", "t", "MQ", "I", "b", "r", "v", "qt", "_", "qi", "qq", "eq", "s", "qa", "dq", "int", "batch", "k", "d", "id", "p", "m", "aq", "x", "num", "o", "ix", "iq", "QU", "depth", "h", "ad", "y"], "A": ["AR", "P", "Q", "ai", "API", "As", "D", "alpha", "AA", "LA", "AB", "I", "M", "AN", "AM", "AP", "RA", "SA", "AL", "PA", "AS", "TA", "G", "U", "W", "Ar", "O", "AF", "BA", "E", "a", "C", "V", "L", "X", "Y", "K", "F", "AC", "AAA"], "B": ["AR", "P", "Q", "J", "WB", "II", " b", "D", "AA", "LA", "AB", "I", "b", "BF", "M", "Ab", "SB", "PB", "NB", "Bs", "PA", "AS", "G", "U", "BC", "BS", "W", "EB", "O", "AF", "BA", "E", "C", "V", "L", "X", "Y", "K", "F", "AC"], "ANS": ["\u03b1", "P", "Q", "AR", "ANN", "ANGE", "QB", "OPA", "ANT", "ANI", "AU", "ENA", "LA", "URN", "POS", "AB", "INA", " PA", "IDS", "SAN", "Ann", "ann", "EN", "NA", "AN", "ATES", "ING", "SN", "NN", "ATS", "KA", "SA", "OSS", "PA", "ON", "ENS", "AS", "ASC", " TRANS", "CON"]}}
{"code": "T = int(raw_input());\n  for i in range(T):\n     Data = map(int, raw_input().split());\n     N = Data.pop(0);\n     S = Data.pop(0);\n     p = Data.pop(0);\n     \n     Good = 0;\n     for score in Data:\n        if score >= 3*p-2:\n           Good += 1;\n        else:\n           if (S > 0) and (score >= 3*p-4) and (score >= p):\n              S -= 1;\n              Good += 1;\n  \n     print \"Case #%d:\" % (i+1),;\n     print Good;\n     \n  \n", "substitutes": {"T": ["P", "Q", "DT", "TS", "Z", "D", "t", "GT", "H", "I", "M", "A", "NT", "Test", "Time", "Do", "TA", "We", "G", "U", "TI", "Tu", "W", "O", "Total", "Tab", "E", "Part", "C", "Length", "V", "L", "X", "TB", "TT", "Y", "K", "B", "F", "Type"], "i": ["ai", "l", "ip", "j", "z", "key", "u", "ti", "t", "n", "I", "count", "b", "qi", "ui", "slice", "order", "phi", "uri", "int", "xi", "ie", "on", "k", "li", "ei", "pos", "d", "id", "bi", "iu", "multi", "x", "pi", "num", "ix", "oi", "e", "y", "start"], "Data": ["Distance", "Old", "D", "Row", " data", "Code", "Len", "Bytes", "Int", "Bu", "Extra", "Tools", "Dat", "Response", "Next", "Music", "Parts", "Results", "Memory", "Pi", "Count", "Input", "Index", "Num", "History", "Info", "Model", "Sample", "Values", "Content", "data", "DATA", "Event", "Queue", "Map", "Time", "Score", "Ni", "Length", "X"], "N": ["Q", "J", "P", "Na", "Z", "D", "Size", "NI", "n", "I", "M", "NA", "A", "Max", "NN", "G", "ni", "U", "num", "Ni", "Ns", "W", "Sum", "O", "E", "Sn", "C", "Ne", "V", "L", "Y", "K", "B", "Name", "F", "Num", "R"], "S": ["P", "Q", "J", "Size", "D", "Z", "I", "n", "H", "s", "M", "SU", "A", "System", "SN", "SR", "SA", "Sp", "Sl", "SH", "SK", "G", "U", "Sa", "SE", "Ns", "W", "O", "SL", "Sn", "SC", "SP", "E", "C", "Si", "V", "L", "X", "Y", "K"], "p": ["P", "l", "Q", "j", "z", "per", "pp", "alpha", "t", "u", "n", "I", "b", "s", "v", "r", "cp", "lp", "M", "data", "pe", "order", "np", "type", "k", "pa", "d", "pos", "m", "x", "pi", "tp", "point", "ap", "ps", " P", "sp", "h", "E", "y"], "Good": ["Some", "Ready", "Better", "Like", " good", "Same", "Cor", "Len", "Bu", "Got", "good", "Excellent", "Luck", "Er", "Winner", "Enough", "Improve", "Bad", "Che", "Done", "Important", "Y", "Count", "General", "Num", "Less", "Valid", "Grade", "Var", "Poor", "Gu", "Score", "Yes", "Error", "Wow", "Slow", "Fin", "Mor", "Best", "Default"], "score": ["key", " scores", "ne", "want", "name", "good", "rank", "o", "grade", "ranking", "Sn", "y", "c", "est", "si", "min", "size", "case", "core", "pro", "rate", "Grade", "value", "data", "order", "next", "np", " scoring", "Score", "err", "er", "ni", "nz", "E", "scoring", "pred", "code", "pri", "player", "ore"]}}
{"code": " \n  def isPalindrome(s):\n    length = len(s)\n    for i in xrange(length / 2):\n      if s[i] != s[length - 1 - i]: \n        return False\n    return True\n  \n  n = int(raw_input())\n  for i in range(n):\n    a, b = map(int, raw_input().strip().split(' '))\n    count = 0\n    for j in range(a, b+1):\n      if isPalindrome(str(j)):\n        s = math.sqrt(j)\n        if s == int(s) and isPalindrome(str(int(s))):\n          count += 1\n    print 'Case #%i: %i' % (i+1, count)\n", "substitutes": {"s": ["l", "aces", "sports", "t", "input", "sa", "stats", "sh", "o", "ans", "xs", "y", "start", "string", "c", "g", "sb", "strings", "si", "speech", "sec", "size", "sets", "ses", "sf", "r", "js", "less", "se", "ies", "qs", "m", "ns", "x", "os", "spec", "ls", "an", "ssl", "w"], "length": ["l", "shape", "size", "z", "zip", "case", "bb", "character", "range", "v", "distance", "slice", "value", "se", "level", "angle", "type", "k", "limit", "d", "p", "id", "time", "position", "sh", "x", "row", "o", "th", "e", "base", "depth", "h", "div", "len", "f", "Length", "long", "q", "dy"], "i": ["l", "ai", "ip", "z", "size", "eni", "chi", "u", "t", "ti", " ii", "I", "v", "qi", "r", "inf", "ui", "yi", "it", "phi", "int", "xi", "type", "ie", "bi", "k", "li", "multi", "d", "id", "p", "part", "m", "iu", "x", "pi", "ni", "di", "o", "io"], "n": ["l", "size", "z", "u", "max", "v", "r", "ne", "name", "k", "d", "p", "m", "ns", "x", " N", "num", "N", "o", "nb", "e", "nc", "an", "nn", "no", "len", "y", "en", "f", "sn", "q", "c", "number", "g", "fn", "w", "network", "nt"], "a": ["ak", "ai", "aa", "l", "ab", "ama", "u", "va", "am", "oa", "r", "ba", "au", "sa", "A", "asa", "int", "k", "d", "p", "ae", "x", "o", "ac", "offset", "da", "e", "an", "y", "f", "af", "c", "w", "fa", "ia", "pa", "aj"], "b": ["l", "abb", "z", "ab", "boot", "rb", "bb", "v", "range", "ba", "r", "wb", "fb", "k", "d", "body", "p", "bf", "m", "eb", "bs", "x", "num", "bot", "lb", "nb", "e", "cb", "h", "y", "f", "c", "number", "B", " B", "sb", "bd"], "count": ["l", "J", "cond", "size", "z", "case", "key", "ib", "col", "seq", "span", "call", "int", "name", "part", "k", "li", "limit", "id", "p", "list", "x", "err", "num", "offset", "nb", "base", "e", "conf", "counter", "len", "start", "y", "f", "diff", "code", "q", "c", "number", "split"], "j": ["bj", "note", "J", "uj", "l", "ip", "section", "ji", "obj", "ij", "z", "size", "jl", "ib", "t", "u", " ii", " dj", " p", " l", "so", "v", "js", "job", "r", "jp", "ne", "ie", "jam", "ch", "k", "li", "part", "d", "p", "m", "fr", "x", "ni", "jo"]}}
{"code": " \n  T = int(sys.stdin.readline())\n  for i in range(T):\n      line = sys.stdin.readline().strip()\n      values = map(int, line.split(' '))\n      N = values[0]\n      S = values[1]\n      p = values[2]\n      totals = values[3:]\n      ans = 0\n      for total in totals:\n          base = total / 3\n          remainder = total - (base * 3)\n          scores = [base, base, base]\n          j = 0\n          while remainder > 0:\n              scores[j] += 1\n              remainder -= 1\n              j = (j + 1) % 3\n          if max(scores) >= p:\n              ans += 1\n          else:\n              if S > 0:\n                  remainder = total - (base * 3)\n                  if remainder == 0 and base > 0:\n                      if base + 2 >= p:\n                          ans += 1\n                          S -= 1\n                  elif base + min(remainder, 2) >= p:\n                      ans += 1\n                      S -= 1\n      print 'Case #%s: %s' % (i+1, ans)\n", "substitutes": {"T": ["P", "J", "Q", "TS", "Z", "D", "t", "GT", "H", "I", "IP", "M", "Base", "A", "NT", "ET", "Time", "TA", "G", "U", "PI", "TI", "Tu", "W", "O", "Total", "E", "Part", "C", "Length", "V", "L", "X", "TB", "TT", "Y", "K", "B", "CT", "F"], "i": ["lo", "l", "J", "inter", "ip", "ji", "z", "chi", "ti", "u", " I", "I", "n", "im", "s", "r", "b", "ui", "slice", "uri", "int", "xi", "ie", "bi", "k", "li", "part", "d", "id", "m", "iu", "x", "pi", "num", "di", "ali", "io", "ix", "e", "jit"], "line": ["LINE", "log", "l", "section", "le", "cell", "ip", "reader", "lines", "lo", "byte", "out", "feed", "comment", "shell", "value", "b", "pe", "s", "data", "source", "raw", "se", "item", "handle", "parse", "sync", "side", "buffer", "entry", "file", "err", "block", "sel", "str", "response", "row", "lin", "lf", "e"], "values": ["versions", "vector", "docs", "ends", "lines", "features", "keys", "size", "years", "args", "sets", "Values", "ms", "ints", "verts", "s", "value", "v", "codes", "data", "tests", "stats", "grades", "default", "frames", "errors", "events", "blocks", "rules", "bytes", "lists", "objects", "settings", "val", "maps", "details", "flows", "times", "seconds", "boxes"], "N": ["P", "J", "Na", "Z", " I", "n", "I", "RN", "M", "NA", "A", "SN", "na", "ns", "G", "ni", "U", "PI", " n", "Ni", "nb", "Ns", " P", "Num", "C", "V", "L", "X", "number", "Y", "K", "Pi", "B", "F", "SI", "NS", "R"], "S": ["P", "J", "Q", "State", "TS", "ASE", "Z", "Size", "D", "Sc", "set", "ss", "H", "I", "n", "s", "M", "Base", "A", "se", "SN", "parts", "SR", "SA", "MS", "SK", "AS", "ns", "G", "species", "U", "Sa", "GS", "SE", "state", "CS", "os", "Sum", "series", "Ns"], "p": ["P", "l", "z", "per", "pp", "py", "t", "u", "api", "primary", "n", "r", "b", "s", "v", "cp", "lp", "pe", "jp", "np", "parts", "k", "part", "parent", "d", "par", "m", "power", "x", "pi", "tp", "bp", "point", "o", "local", "up", "e", "ps", " P", "sp"], "totals": [" TotALS", "Tfatalls", "tOTal", " TOTales", "totsals", "tfatales", "towal", " Total", " TOTals", "Tfatal", "tOTales", "totsales", " Totales", "totsal", "Totalls", "totalls", " TOTal", "towalls", "towales", "Totales", "Tfatals", "tOTals", "tfatal", "towals", "tfatals", "Total", "Totals", "totALS", "totsalls", " TOTALS", "tfatALS", "tOTALS", "totales", " Totals", "tfatalls", "Tfatales"], "ans": ["aning", "mean", "aus", "sa", "ase", "stats", "nas", "offs", "Ns", "nn", "si", "amps", "ras", " Ans", "annot", "ann", "anon", "AN", "ass", "aps", "errors", "ana", "ns", "ni", "san", "ani", "os", "ls", "an", "no", "a", "ano", "An", "aos", "aned", "nan", "can", "ins", "cons", "s"], "total": ["otal", "alpha", "t", "scale", "all", "multi", "tp", "tree", "bas", "basic", "root", "quant", "created", "note", "min", "size", "complete", "iter", "valid", "percent", "partial", "order", "site", "local", "confirmed", "mini", "no", "latest", "a", "padding", "central", "square", "nt", "null", "random", "error", "limited", "common", "equal", "stable"], "base": ["based", "fixed", "alpha", "b", "model", "scale", "ase", "name", "area", "id", "phase", "file", "offset", "nb", "y", "start", "c", "ma", "bas", "basic", "pa", "root", "si", "min", "size", "ASE", "case", "py", "core", "set", "family", "Base", "order", "se", "bi", "limit", "m", "site", "x", "auto"], "remainder": ["resaincer", "Remainingser", "remainingnder", "remainingser", "remainingter", "remainDER", "resainsder", "REMainsnder", "remainscer", "Remainingder", "remainedner", "remainster", "remainsDER", "Remainingter", "resainsner", "resainder", "remainnder", "remarianser", "RemainDER", "resainler", " remainedder", "remainter", "remainingler", "Remainler", "Remainter", "remainser", "REMainnder", "remariannder", "REMainter", "remainedcer", "remainingner", "remainsner", "remainedler", "Remainder", "remainler", "remainedser", " remainDER", "REMainder", "remarianter", "remaincer"], "scores": ["escares", "quatters", " Scares", "escatters", " scors", " Scors", "scales", " Scores", "descares", "scares", "quares", "ucales", "ascales", "scors", " scales", "ucores", "quors", "scans", "descors", "escors", "ucans", " Scatters", "ascors", "scanners", "escores", " scares", "ascores", "quores", "ucors", " scans", "quanners", "descanners", "descores", "scatters", " scanners", "ascans"], "j": ["bj", "P", "J", "l", "adj", "section", "uj", "ji", "z", "ij", "jobs", "obj", "jl", "t", "u", "min", "jan", "py", "I", "n", "b", "r", "v", "js", "job", "s", "_", "jp", "ie", "k", "part", "pos", "d", "m", "fr", "x", "jo", "dj", "jj", "o"]}}
{"code": " \n  \n  LIMIT = 10\n  \n  def check_palindrome(number):\n      rev = 0\n      runner = number\n      while runner > 0:\n          rev = rev * 10 + (runner % 10)\n          runner /= 10\n      if rev == number:\n          return True\n      else:\n          return False\n  \n  def list_to_number(number_list):\n      l = len(number_list)\n      res = 0; rres = 0\n      multi = 1\n      for i in xrange(1, l + 1):\n          res += number_list[l - i] * multi\n          rres += number_list[i - 1] * multi\n          multi *= 10\n      return (res, rres)\n  \n  def gen_one_side(side_length):\n      state = [0 for _ in xrange(side_length)]\n      done = False\n  \n      while not done:\n          if state[-1] != 0:\n              yield state\n          state[-1] += 1\n          curr = side_length - 1\n          while state[curr] == LIMIT:\n              if curr == 0:\n                  done = True\n                  break\n              state[curr] = 0\n              curr -= 1\n              state[curr] += 1\n  \n  def gen_odd_palindrome(side_length):\n      if side_length == 0:\n          for i in xrange(1, 10):\n              yield i\n      else:\n          multi = 10**side_length\n          for one_side in gen_one_side(side_length):\n              number, rnumber = list_to_number(one_side)\n              for i in xrange(LIMIT):\n                  yield number + i * multi + rnumber * multi * 10\n  \n  def gen_even_palindrome(side_length):\n      multi = 10**side_length\n      for one_side in gen_one_side(side_length):\n          number, rnumber = list_to_number(one_side)\n          yield number + rnumber * multi\n  \n  \n  def gen_palindrome():\n      l = 1\n  \n      while True:\n          if l % 2 == 1:\n              for odd_pal in gen_odd_palindrome((l - 1) / 2):\n                  yield odd_pal\n          else:\n              for even_pal in gen_even_palindrome(l / 2):\n                  yield even_pal\n          l += 1\n  \n  \n  cache = []\n  upper = 10**14\n  for pal in gen_palindrome():\n      pal2 = pal**2\n      if pal2 > upper:\n          break\n      if check_palindrome(pal2):\n          cache.append(pal2)\n  \n  cl = len(cache)\n  T = int(raw_input().strip())\n  for i in xrange(T):\n      low_ind = 0\n      high_ind = cl - 1\n      A, B = map(int, raw_input().strip().split(' '))\n  \n      while cache[low_ind] < A:\n          low_ind += 1\n      while cache[high_ind] > B:\n          high_ind -= 1\n  \n  \n      if low_ind <= high_ind:\n          print \"Case #%s: %s\" % (i + 1, high_ind - low_ind + 1)\n      else:\n          print \"Case #%s: 0\" % (i + 1)\n", "substitutes": {"LIMIT": ["DLimITS", "LIMITS", "SLIMITED", "DLimit", "LOBit", "LOBITED", "LIBITS", "ELIMit", "LOBIT", "LLimIT", "ELIMIT", "SLimIT", "LIMIt", "SLIMit", "SLimITED", "LOWITED", "ELimLimit", "DLIMITED", "ELimIt", "SLIMIT", "DLimITED", "ELimIT", "LLimit", "LIBIT", "LLimIt", "ELimit", "LimITED", "LimLimit", "SLimITS", "DLIMIT", "LimIT", "LIMLimit", "ELIMIt", "LOWIT", "LOWit", "Limit", "LOBITS", "LIMITED", "LimITS", "LimIt"], "number": ["address", "loc", "b", "uri", "int", "function", "name", "integer", "umber", "phone", "line", "BER", "o", "regular", "nb", "coll", "nn", "string", "c", "initial", "root", "multiple", "double", "un", "min", "size", "eni", "iter", "label", "reference", "r", "value", "amount", "begin", "m", "x", "token", "layer", "no", "en"], "rev": ["cur", "j", "min", "z", "obj", "br", "iv", "iter", "ref", "rest", " r", "run", "random", "url", "roll", "range", "r", "count", "v", "b", "reverse", "cycle", "order", "ie", "batch", "nr", "li", "id", "rank", "re", "cr", "inner", "err", "prev", "cv", "block", "val", "rec", "row", "ru"], "runner": ["cur", "config", "tri", "rf", "cli", "br", "unit", "random", "iter", "rb", " r", "run", "core", "mr", "loader", "r", "iron", "circ", "uc", "breaker", "trial", "chain", "duration", "walker", "uri", "rar", "ler", "master", "runners", "builder", "nr", "running", "uni", "lr", "orig", "inner", "err", "Runner", "ctr", "block"], "number_list": ["letter_info", "number___store", "letter_store", "array_list", "value_list", "array_map", "valuealcoll", "choice_count", "number___info", "numberallist", "choice_list", "number_count", "number___list", "number_l", "number_level", "number_map", "number_coll", "letter_list", "numberDl", "number___length", "numberDcount", "choice_level", "numberalpool", "value_info", "valueallist", "numberDlevel", "array_la", "valuealinfo", "array_l", "number_length", "number_info", "letter_length", "numberalcoll", "choice_l", "number_pool", "numberDlist", "valuealpool", "numberalinfo", "number_la", "value_pool"], "l": ["pl", "t", "loc", "lt", "b", "wl", "lit", "ln", "list", "line", "o", "la", "ol", "h", "y", "L", "c", "lic", "g", "lo", "le", "j", "bl", "jl", "lp", "r", "dl", "ell", "al", "limit", "m", "x", "lb", "ls", "ur", "u", "s", "left", "k", "fl"], "res": ["rl", "rex", "roc", "reg", "progress", "iter", "max", "ris", "loc", "ras", "mr", "ros", "col", "seq", "rest", "r", "range", "req", "gr", "rez", "arr", "ress", "p", "re", "cr", "resp", "rss", "RES", "ret", "lr", "mass", "err", "success", "x", "val", "rx", "response", "rec", "ru", "reset"], "rres": ["rxrem", " rreg", "srresults", "rresult", "rxresults", "rrs", "Rres", "srres", "nresult", " rresult", " rrs", "Rvals", " rrem", "Rresults", "Rrows", "srvals", "Rrem", "rrows", "nreg", "dreg", "dresult", "rreg", "srrows", "rxres", " rrows", "rresults", "drs", "rrem", " rresults", " rvals", "nres", "dres", "rxrows", "nrs", "rvals"], "multi": ["progress", "ti", "dim", "scale", "phi", "uri", "init", "complex", "master", "re", "micro", "list", "mid", "mu", "io", "Multi", "la", "mix", "coll", "c", "repeat", " mi", "ci", "avi", "wei", "si", " multiple", "lo", "multiple", "double", "tri", "complete", "rand", "mr", "r", "cum", "partial", "array", "group", "xi"], "i": ["ti", "t", "b", "qi", "phi", "uri", "int", "ei", "integer", "id", "list", "o", "io", "h", "y", "L", "c", "g", "ini", "ci", "si", "lo", "j", "eni", "iter", "ri", "r", "xi", "bi", "m", "x", "ni", "ani", "ix", "mini", "umi", "a", "w", "gi", "end"], "side_length": ["sidealheight", "side_count", "side_direction", "line_length", "side67count", " side_count", "axisalnumber", "line_position", " side_offset", "side_height", "sideglength", "side\u00b7family", "background_number", " side_sum", "sideqlabel", "side\u00b7label", "side_offset", "side64height", "side_side", "center_direction", "sideCsection", "background_length", "side_number", "axisalcollection", "sideqside", "side_start", "side_width", "background_start", "sidegstart", " side_family", "center_slice", "sideCdepth", " side_side", "line_depth", "side\u00b7count", "side_family", "axisalheight", "center_width", "side64number", "side_slice"], "state": ["State", "address", "progress", "key", "loc", "right", "statement", "scale", "all", "int", "master", "area", "ace", "id", "re", "list", "val", "line", "reset", "grade", "media", "rule", "start", "string", "tag", "update", "reg", "un", "j", "size", "case", "core", "r", "data", "order", "next", "sync", "dict", "inner", "err"], "_": [" r", " p", "n", "r", " num", " all", "all", "k", " one", "x", " self", " n", " v", " line", " x", "g"], "done": ["lo", "fun", "min", "size", "checked", "initialized", "progress", "final", "complete", "error", "desc", "after", "rand", "made", "set", "finished", "only", "one", "zero", "now", "de", "doing", "common", "did", "future", "lost", "ord", "graded", " continued", "init", "disabled", "ie", "do", "part", "current", "pos", "id", "released", "loaded", "uni"], "curr": ["charri", "urru", "curver", "perR", " curra", " curro", "urrd", "hurler", "derr", "hurr", "ferrier", "burro", "terr", "charp", "curro", "currd", "carr", " currier", "Curro", "perro", "hurri", "terpr", "burpr", "derR", "curri", "burror", "carpr", "curler", "curpr", "currier", "ferre", "curR", " curver", "curre", "urpr", "curp", "charler", "perr", "burR", "derra"], "one_side": ["once_side", "once_ide", "once67loc", "once67day", "eachjteam", "each_side", "each_team", "once67side", "one_section", "onejarea", " one_phase", "one___gap", "one67day", "one___phase", "once67ide", "one_team", " one_gap", "two_sample", "one67ide", "oneptteam", "once_day", "one_ide", "each_range", "oneptrange", "oneptarea", "each_area", "onejteam", "onejside", "two_section", "eachjside", "one67loc", "one_day", "one_phase", "one_sample", "eachjarea", "oneptside", "one_area", "onejrange", " one_day", "one_loc"], "rnumber": [" rnumbered", "drnum", "erspan", "rrcorrect", "ernum", "cdouble", " rnum", "drnumbered", "rnumbered", "drdouble", "runumber", "rvalue", " rvalue", "jvalue", "cnum", "cnumber", "runo", "erno", "Rnum", "rdouble", "cvalue", "rmajor", "drnumber", " rcorrect", "ernumber", "jnumbered", "rrmajor", "rno", "cnumbered", "rnum", " rdouble", "rucorrect", "jnumber", "rrnumber", "Rnumber", "rspan", " rno", "jnum", " rspan", "rcorrect"], "odd_pal": ["odd___color", "odd_side", " odd_panel", "oddCcal", "odd_color", "odd_loc", "even_poly", "odd_cal", "odd_panel", "oddCpoly", "even_loc", "even_cal", " odd_color", "odd___side", "oddCloc", " odd_side", "oddCpal", "odd_poly", "odd___panel", "odd___pal"], "even_pal": [" even_pl", "odd_real", "even_ph", " even_sal", "odd_al", "even_real", "even_sal", "odd_cal", "even_cal", "even_pl", " even_ph", "even_al"], "cache": ["color", "lines", "page", "py", "case", "max", "slice", "full", "chain", "reverse", "array", "next", "bin", "arr", "li", "pos", "id", "p", " outer", "inner", "stack", "prev", "block", "num", "gap", "cells", "base", "pack", "holes", "pre", " chain", "div", "bottom", "padding", "ver", "sum", "last"], "upper": ["exc", "fixed", "middle", "alpha", "final", "u", "loc", "range", "r", "che", "angle", "back", "ch", "parser", "um", "fr", "inner", "high", "higher", "local", "later", "pper", "up", "aster", "base", "above", "ger", "h", "ups", "wrapper", "ul", "lower", "bottom", "acer", "height", "fix", "outer", "sum"], "pal": ["margin", "adv", "color", "min", "page", "pl", "py", "bl", "alpha", "isal", "u", "max", "col", "range", "pr", "v", "mal", "flat", "chain", "style", "scale", "all", "opal", "bin", "int", "left", "cal", "pixel", "li", "al", "fill", "ace", "p", "ple", "area", "ill", "bal", "val", "num", "il"], "pal2": ["valtwo", "chal2", "Pal3", "pal5", "bltwo", "Pal2", "pal1", "Pal1", "Paltwo", "val3", "pal3", "val2", "Pal4", "chaltwo", "bl3", "bl4", "paltwo", "bl2", "pal4", "chitwo", "chi5", "Pal5", "chi1", "chal1", "chi2", "chal5", "val4"]}}
{"code": " \n  surprising = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]\n  regular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]\n  \n  f = open(argv[1], 'r')\n  T = int(f.readline().strip('\n'))\n  for i in range(T):\n  \tboth = 0\n  \tsurp_only = 0\n  \tline = f.readline().strip('\n').split(' ')\n  \tN = int(line[0]) # What for?\n  \tS = int(line[1])\n  \tp = int(line[2])\n  \tts = map(int, line[3:])\n  \tfor t in ts:\n  \t\tif reduce(max, map(max, regular[t])) >= p:\n  \t\t\tboth += 1\n  \t\telif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:\n  \t\t\tsurp_only += 1\n  \n  \tprint \"Case #%s: %s\" % (i + 1, both + min(surp_only, S))\n", "substitutes": {"surprising": ["Surprising", "Surplex", "surfacefaces", "serfaces", "surprise", "serprising", "surfaceplex", "surfaceprising", "surfaces", "serprise", "serplex", "surfaceprise", "Surfaces", "surplex", "Surprise"], "regular": ["fixed", "config", "reg", "shape", "external", "final", "random", "unit", "valid", " data", " irregular", "Regular", "standard", "flat", " general", "data", "full", "chain", "group", "all", "general", "complex", "special", "sequence", "match", " pattern", "normal", "optional", "pattern", "patch", "debug", "custom", "Pattern", "central", "perfect", "serial"]}}
{"code": " \n  main = do\n      interact (unlines . map showCase . zip [1..] . map (solve . interval) . tail . lines)\n  \n    where\n      interval :: String -> (Int64, Int64)\n      interval l =\n          let [a, b] = map read $ splitOn \" \" l\n          in (a, b)\n  \n      showCase :: (Int64, Int) -> String\n      showCase (i, r) = printf \"Case #%d: %d\" i r\n  \n  solve :: (Int64, Int64) -> Int\n  solve (a, b) =\n      length $ takeWhile (<= b) $ dropWhile (< a) [ sq\n          | x <- [0..], palindrome x, let sq = x * x, palindrome sq\n          ]\n    where\n      square x = x * x\n      start = truncate $ sqrt $ double a\n  \n  -- | Returns True if s is a palindrome.\n  palindrome s =\n      let s' = show s\n      in s' == reverse s'\n  \n  double :: Int64 -> Double\n  double = fromIntegral\n", "substitutes": {"main": ["log", "section", " result", "j", "obj", "pl", "example", "bl", "mode", "run", "core", "src", "shell", "loop", "js", "data", "partial", "all", "name", "gen", "id", "m", "file", "ile", "str", "util", "result", "lang", "Main", "script", "output", "long", "mult", " Main", "debug", "g", "seq", "test"], "l": ["rl", "le", " L", "j", "lines", "z", "pl", "ur", "t", "u", "i", "n", "r", "s", "v", "lp", "yl", "isl", "left", "ell", "ln", "li", "fl", "d", "p", "m", "list", "NL", "sel", "cl", "line", "o", " fl", "e", "ol", "il", "ls", "h", "ml", "ul"], "let": ["fore", "pl", "lt", "shell", "lit", "int", "init", "id", "list", "val", "line", "option", "alt", "lat", "la", "place", "pt", "L", "string", "char", "update", "led", "le", "section", "log", "case", "out", "iter", "set", "LET", "gen", "et", "local", "blast", "base", "ice", "var", "layout", "patch", "last"], "a": ["alpha", "art", "i", "t", "am", "au", "de", "another", "sa", "asa", "ha", "area", "ta", "action", "o", "la", "ea", "h", "y", "af", "c", "ma", "g", "pa", "aa", "wa", "sta", "ab", "j", "za", "ast", "r", "array", "ao", "se", "ga", "m", "auto", "ac", "da"], "b": ["aa", "j", "ab", "z", "abb", "ib", "i", "rb", "bb", "u", "t", "n", "r", "ba", "v", "wb", "s", "db", "bh", "fb", "bi", "part", "k", "d", "be", "p", "bf", "m", "eb", "body", "bc", "bs", "binary", "bp", "o", "sb", "length", "lb", "nb", "e"], "x": ["ex", "key", "i", "t", "xx", "int", "sex", "name", "id", "rx", "tx", "xs", "h", "y", "c", "g", "px", "image", "shape", "wa", "j", "out", "r", "value", "data", "cross", "python", "xy", "xi", "xxxx", "ww", "m", "time", "ix", "xxxxxxxx", "X", "xa", "w", "xp", "index"], "start": ["step", "cur", "z", "alpha", "unit", "case", "max", "i", "count", "range", "data", "shift", " end", "scale", "next", "pos", "id", "p", "index", " Start", " i", "length", "space", "offset", "result", "e", "ize", "len", "stop", " starts", "w", " stop", "end", "Start"]}}
{"code": " \n  main = interact (unlines . map showCase . zip [1..] . tail . lines)\n    where\n      showCase (i, t) = \"Case #\" ++ show i ++ \": \" ++ solve t\n  \n  solve = show . solve' . map read . words\n    where\n      solve' (n:s:p:ts) = \n          let pts = map maxPoints ts\n              directs = filter ((>= p) . fst) pts\n              surps = filter (\\(pd, ps) -> pd < p && ps >= p) pts\n          in length directs + min (length surps) s\n          \n  maxPoints :: Int -> (Int, Int)\n  maxPoints tot = \n      (maxScore $ scores normal, maxScore $ scores surprising)\n    where\n      scores cond = [ (x, y, z) |\n          x <- [0..10], y <- [0..10], z <- [0..10]\n          , x + y + z == tot, cond (x, y, z)\n          ]\n      normal t = bestScore t - badScore t <= 1\n      surprising t = bestScore t - badScore t <= 2\n      maxScore = maximum . map bestScore \n  \n  bestScore (x, y, z) = maximum [x, y, z]\n  badScore (x, y, z) = minimum [x, y, z]\n", "substitutes": {"main": ["log", "ite", "page", "obj", "pl", "example", "py", "mode", "run", "path", "me", "loop", "js", "trial", "ids", "np", "frame", "master", "name", "gen", "grid", "id", "Train", "mc", "ile", "mid", "gui", "ages", "Main", "script", " test", "mult", "title", "prime", "debug", "ng", "seq", "test"], "solve": ["solver", "psolves", "asolution", "ssolution", "insolution", "solving", "ssolved", "setsolving", "psolving", "Solution", "ssolver", " solution", "setsolver", "insolved", "insolver", "asolver", "setsolution", "asolved", "solved", "Solves", "insolve", "asolve", "solution", "Solved", "setsolve", " solver", "ssolve", "Solving", "Solve", " solved", "psolve", "psolver", "solves", "setsolves", " solving", "Solver"], "n": ["l", "adj", "j", "z", "i", "u", "r", "b", "s", "v", "span", "np", "ne", "name", "k", "pos", "d", "p", "m", "ns", "x", "N", "o", "e", "nc", "h", "y", "en", "f", "sn", "q", "c", "number", "network", "fn", "w", "g", "nt"], "pts": ["PTses", "inputsv", "ctsets", "pathsi", "strsp", "ctts", "ptls", "pathts", "PTps", "ptts", "PTp", "pathls", "inputsi", "ptsets", "inputs", "pathsp", "ptsi", "ntps", "ptsv", "nts", "ptses", "PTs", "ntses", "ntsets", "ctls", "ptsp", "pathsets", "Pathp", "Paths", "ptps", "paths", "Pathps", "strsv", "ntls", "strs", "ntp", "inputsp", "strsi", "cts", "pathsv"], "directs": [" directments", "directments", "directions", "Directly", "patterns", "Directes", "irections", "Directies", "Directments", " directly", "directies", "irects", "irectly", "directly", "Directs", "irectments", "pathions", "Directions", "pathies", "paths", "pathes", "patternies", "patternions", "directes", " directions", "patternes"], "surps": ["interps", "Surpped", "Surpes", "Surfaces", "urps", "interpped", "surfaces", "urp", "interpes", "Surps", "surpe", "Surp", "serps", "surpes", "surp", "urfaces", "serp", "surpped", "Surpe", "interp", "urpe", " surpe", " surp", " surfaces", "serpped", "serpes"], "tot": ["twoting", "toti", "dtot", "tots", " tota", "dtots", "dtoti", "Tota", "toting", " tiot", " tots", "Tiot", "twota", "tiot", " tow", "Tow", "Toting", " toting", "Tots", "Tot", "twow", "tota", "twot", "dtiot", "tow", "Toti", " toti"], "cond": ["log", "condition", "co", "det", "reg", "sec", "case", "ref", "cc", "col", "count", "cd", "uc", "eq", "comb", "int", "choice", "default", "xc", "part", "func", "pos", "resp", "cr", "pot", "sect", "list", "x", "val", "cl", "cont", "ct", "ac", "crit", "cmp", "comp", "filter", "pre", "no", "cn"], "t": ["l", "tc", "ti", "i", "b", "ot", "all", "int", "rt", "ta", "tp", "o", "ct", "h", "y", " T", "pt", "tree", "string", "c", "T", "g", "ut", "est", "tip", "j", "case", "out", "r", "qt", "et", "m", "time", "ret", "x", "token", "tools", "output", "a", "at"], "maxScore": ["maxPoint", "minscore", "MaxValue", "powerGrade", " maxscore", "lastScore", "maxGrade", "MaxMatch", "powerScore", "MaxPoint", "minPoint", " maxGrade", "powerscore", " maxValue", "minGrade", " maxMatch", "Maxscore", " maxPoint", "MaxGrade", "maxscore", "minScore", "maxMatch", "lastGrade", "lastMatch", "maxValue", "powerValue", "MaxScore"]}}
{"code": "def checkpalin(s):\n      k = len(s)//2\n      for i in range(k):\n          if s[i]!= s[-1-i]:\n              return False\n      return True\n  \n  goods = [1,2,3]\n  \n  for i in range(1000):\n      for j in ['']+list(range(10)):\n          test = str(i)+str(j)+(str(i)[::-1])\n          if checkpalin(str(int(test)**2)):\n              goods.append(int(test))\n  goods = list(set(goods))\n  goods.sort()\n  \n  T = int(input())\n  \n  for case in range(1,T+1):\n      A,B = [int(x) for x in input().split()]\n      ans = 0\n      for n in goods:\n          if A <= n*n <= B:\n              ans += 1\n      print(\"Case #\",case,\": \",ans,sep='')\n", "substitutes": {"s": ["l", "es", "sq", "z", "services", "aces", "keys", "u", "ins", "sets", "states", "ss", "input", "ses", "b", "ks", "js", "v", "su", "r", "cs", "ids", "tests", "ies", "parts", "ips", "ds", "d", "qs", "p", "words", "m", "objects", "bs", "ns", "abs", "south", "bis", "its", "o"], "k": ["ak", "l", "kk", "z", "t", "u", "max", "ki", "ke", "ks", "b", "v", "r", "ku", "kick", "ik", "ch", "d", "p", "ok", "m", "work", "N", "o", "length", "e", "h", " K", "y", "km", "f", "q", "kid", "sk", "c", "K", "g", "w", "kw"], "i": ["ai", "l", "ip", "ji", "ij", "z", "chi", "u", "ti", "t", "im", "I", "b", "v", "qi", "ui", "r", "yi", "it", "phi", "ik", "int", "xi", "ie", "bi", "li", "d", "id", "p", "m", "iu", "pi", "ni", "mi", "di", "o", "io", "info", "e", "h"], "goods": ["indns", "badps", "Goodsites", "tests", "gooders", "betters", "inds", "goodi", "Goodches", "bugns", "Goodes", "lookes", "badns", "kinds", "testes", "badies", "validns", "drawns", "lookers", "validlines", " goodtest", "foods", "Goodks", "goodes", "badstates", "bads", " goodes", "betterS", "Goodps", "lookresults", "goodb", "kindes", "buglines", " goodstates", "Goodies", "testresults", "goodns", "kinders", " goodks", "goodies"], "j": ["J", "ai", "l", "ip", "adj", "ji", "ij", "z", "obj", "br", "ib", " d", "u", "im", "b", "r", "v", "js", "_", "jp", "it", "ie", "jam", "li", "pos", "id", "p", "m", "d", " it", "num", "je", "dj", "jj", "gu", "oj", "o", "jump", "e", "temp"], "test": ["fake", "tri", "example", "py", "t", "valid", "rest", "key", "iter", "path", "server", "v", "pe", "flat", "tt", "cross", "trial", "style", "txt", "Test", "tests", "int", "type", "app", "p", "train", "err", "read", "val", "str", "match", "search", "ct", "length", "end", "result", "spec", "temp", "testing", "check"], "T": ["Q", "P", "Case", "J", "TS", "size", "Z", "D", "TH", "t", "H", "I", "M", "NT", "Test", "TC", "p", "time", "TA", "G", "sequence", "N", "TN", "length", "W", "O", "Total", "E", "C", "S", "V", "L", "X", "number", "TT", "Y", "K", "CT", "F", "R"], "case": ["config", "Case", "address", "section", "text", "z", "ASE", "t", "key", "ce", "cas", "mode", "b", "v", "pe", "trial", "ase", "int", "choice", "type", "ie", "xc", "name", "app", "li", "d", "ace", "p", "m", "time", "position", "nce", " cases", "num", "match", "line", "race", "length", "cases", "e"], "A": ["P", "Case", "Ca", "Na", "As", "D", "AA", "LA", "H", "I", "AB", "au", "M", "NA", "Ab", "AP", "Am", "p", "App", "Array", "G", "U", "N", "AD", "And", "At", "Ar", "O", "CA", "BA", "E", "Part", "a", "C", "S", "V", "Wa", "L", "X", "K"], "B": ["II", "P", "J", "WB", "ab", "Z", " b", "D", "GB", "AB", "I", "b", "BF", "LB", "M", "NUM", "Ab", "SB", "VB", "PB", "NB", "BL", "Bs", "G", "N", "BB", "BC", "BG", "BR", "CB", "BE", "nb", "BS", "W", "O", "BA", "E", "C", "L", "X"], "x": ["xb", "ex", "l", "exp", "z", "rax", "example", "u", " X", "dx", "xe", "xxx", "r", "xx", "v", "bit", "data", "xf", "xy", "int", "xi", "sex", "xc", "name", "xxxx", "d", "id", "p", "ww", "m", "wx", "na", "ax", "rx", "num", "val", "xt", "ct", "ix", "e"], "ans": ["ai", "ents", "can", "nes", "Na", "aces", "ins", "amps", "ras", "ations", "ms", "annot", "cons", "Ann", "ann", "ames", "ks", "span", "aus", "AN", "NA", "cs", "ase", "anas", "ays", "leans", "ats", "man", "ants", "p", "na", "ana", "ens", "ns", " cases", "ni", "ANS", "ani", "cases", "nas"], "n": ["P", "l", "aa", "Na", "z", "t", "u", "pn", "r", "b", "v", "nu", "span", "M", "all", "net", "int", "ne", "d", "p", "m", "na", "ns", "ni", "num", " N", "N", "o", "ac", "nat", "nb", "e", "Ns", "an", "nn", "nc", "no", "en", "y", "sn"]}}
{"code": "T=int(input())\n  for t in range(T):\n    l = [int(x) for x in input().split()]\n    n,huh,p = l[:3]\n    ss = l[3:]\n    nice, maybe = 0,0\n    for s in ss:\n      if s>= p+2*max(p-1,0):\n        nice += 1\n      elif s>= p+2*max(p-2,0):\n        maybe += 1\n    y = nice + min(maybe,huh)\n    print('Case #',t+1,': ',y,sep = '')\n  \n  \n", "substitutes": {"T": ["P", "Q", "J", "TS", "z", "Z", "D", "H", "I", "M", "A", "NT", "Test", "Time", "time", "G", "N", "TN", "TI", "length", "W", "O", "Total", "E", "C", "Length", "S", "V", "L", "X", "c", "TT", "Y", "K", "B", "F", "R", "test"], "t": ["j", "z", "u", "max", "iter", "i", "lt", "b", "v", "qt", "ot", "tt", "python", "int", "type", "k", "tail", "d", "pos", "m", "time", "num", "tp", "xt", "tz", "ta", "o", "e", "temp", "h", "start", "a", "f", "pt", "c", "dt", "at", "w", "st", "ts"], "l": ["rl", "le", " L", "pl", "i", "u", "lp", "b", "v", "r", "wl", "dl", "left", "ln", "k", "fl", "li", "d", "m", "los", "list", "lis", "o", "la", "lin", "ol", "e", "il", "ls", "h", "len", "ul", "f", "L", "c", "el", "lc", "ll", "g", "w"], "x": ["ox", "xb", "ex", "exp", "j", "z", "i", "u", " X", "dx", "xe", "xxx", "xx", "v", "ux", "cross", "xf", "xy", "int", "xi", "sex", "xc", "xxxx", "d", "id", "fx", "m", "pos", "wx", "na", " xp", "ax", "rx", "num", "xt", "point", " i", "ix", "e", " xx"], "n": ["j", "z", "pn", "iter", "u", "r", "b", "v", "it", "np", "net", "ne", "k", "na", "yn", "ns", " N", "ni", "num", "pi", "N", "o", "nb", "e", "nc", "nn", "cn", "h", "en", "sn", "f", "q", "c", "g", "w", "nu", "ny"], "huh": ["Huc", "Hugh", " hih", "huc", "workuh", "Hih", "pue", "Hoh", "hih", "poh", "Huh", "hoh", " hoh", " hue", "workuc", " hugh", "workih", " huc", "puh", "hugh", "workugh", "hue", "Hue", "puc"], "p": ["P", "ip", "j", "min", "z", "pp", "per", "py", "i", "u", "max", "case", "api", "lp", "r", "b", "pe", "cp", "v", "hp", "phi", "np", "k", "part", "d", "pos", "m", "pot", "pi", "tp", "point", "o", "pc", "e", "ps", " P", "sp", "pre", "h", "a"], "ss": ["css", "hess", "sq", "z", "pp", "dd", "yy", "cas", "ess", "me", "cp", "pe", "su", "xx", "ross", "less", "style", "cs", "np", "stats", "ass", "struct", "sim", "sync", "oss", "ds", "ress", "pos", "rss", "sect", "bs", "ens", "ns", "ni", "pi", "str", "iss", "skip", "spec", "ps"], "nice": ["small", "wh", "tri", "min", "chi", "size", "some", "care", "py", "case", "iter", "max", "happy", "ise", "core", "fit", "cp", "flat", "nz", "bug", "nick", "np", "xy", "ne", "want", "choice", "ie", "int", "good", "pos", "pie", " nic", "ni", "pi", "clean", "poor", "Nice", "ignore", "ix", "info"], "maybe": ["some", "anything", "z", "happy", "api", "py", "max", "picked", "might", "ski", "kick", "now", "stuff", "sky", "kids", "ie", "sim", "really", "tiny", "sync", "bad", "li", "asi", "something", "pi", "yes", "auto", " probably", "guy", "ix", "optional", "info", "hack", "perhaps", "always", "pick", "bug", "perfect", "just", "spec"], "s": ["es", "sq", "lines", "z", "size", "aces", "ins", "i", "u", "ims", "eps", "sw", "ses", "b", "su", "cs", "ers", "se", "np", "sav", "stats", "ies", "ats", "sync", "ds", "pos", "stat", "ns", "settings", "abs", "ni", "tp", "ches", "its", "er", "iss", "os", " S", "rows", "ops"], "y": ["j", "idy", "z", "chi", "py", "i", "yy", "wy", "isi", "ish", "python", "yi", "xy", "int", "ies", "sky", "sim", "d", "vy", " pretty", "ky", "yn", "cy", " py", "kit", "ye", "Py", "ya", "ey", "zy", "e", "test", "h", "dy", "yt", "c", "Y", "sy", "pretty", "ny"]}}
{"code": " \n  \n  \n  \n  problem = \"C\"\n  tag = \"small\" #commonly sample, small, or large\n  suffix = \"-attempt0\" #used sometimes for indexing later input files\n  table_of_fairs = np.array([0, 1, 4, 9, 121, 484, 676, 10201, 12321, 14641, \n  40804, 44944, 69696, 94249, 698896, 1002001, 1234321, 4008004, 5221225, 6948496, \n  100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, \n  404090404, 522808225, 617323716, 942060249, 10000200001, 10221412201, 12102420121, \n  12345654321, 40000800004, 637832238736, 1000002000001, 1002003002001, 1004006004001, \n  1020304030201, 1022325232201, 1024348434201, 1086078706801, 1210024200121, \n  1212225222121, 1214428244121, 1230127210321, 1232346432321, 1234567654321, \n  1615108015161, 4000008000004, 4004009004004, 4051154511504, 5265533355625, \n  9420645460249, 100000020000001, 100220141022001, 102012040210201, 102234363432201, \n  121000242000121, 121242363242121, 123212464212321, 123456787654321, \n  123862676268321, 144678292876441, 165551171155561, 400000080000004, \n  900075181570009, 4099923883299904, 10000000200000001, 10002000300020001, \n  10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, \n  10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, \n  10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, \n  12120030703002121, 12122232623222121, 12124434743442121, 12321024642012321, \n  12323244744232321, 12341234943214321, 12343456865434321, 12345678987654321, \n  40000000800000004, 40004000900040004, 94206450305460249, 1000000002000000001, \n  1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, \n  1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, \n  1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, \n  1232344458544432321, 1234323468643234321, 4000000008000000004, 4253436912196343524, \n  6158453974793548516, 100000000020000000001, 100002000030000200001, 100004000060000400001, \n  100020201040102020001, 100022201252102220001, 100024201484102420001, \n  100200120040021002001, 100202122050221202001, 100204124080421402001, \n  100220341262143022001, 100222343474343222001, 102010002040200010201, \n  102012022050220210201, 102014042080240410201, 102030405060504030201, \n  102032425272524230201, 102132537636735231201, 102210100272001012201, 102212122262221212201, \n  102214144272441412201, 102230523292325032201, 102232545484545232201, 102234567696765432201, \n  104190107303701091401, 121000000242000000121, 121002200252002200121, 121004400282004400121, \n  121020021070120020121, 121022221262122220121, 121024421474124420121, 121220122262221022121, \n  121222324272423222121, 121240161292161042121, 121242363484363242121, 121244565696565442121, \n  123210002464200012321, 123212222474222212321, 123230205292502032321, 123232425484524232321, \n  123234645696546432321, 123432124686421234321, 123434346696643434321, 184398883818388893481, \n  400000000080000000004, 400004000090000400004, 522815090696090518225, 906086675171576680609, \n  942064503484305460249, 6916103777337773016196, 10000000000200000000001, 10000220001410002200001, \n  10002002100400120020001, 10002222123632122220001, 10020010200400201002001, 10020230421612403202001, \n  10022014302620341022001, 10022234545854543222001, 10201000020402000010201, 10201222221612222210201, \n  10203022140604122030201, 10203244363836344230201, 10221210222622201212201, 10221432643834623412201, \n  10223234344844343232201, 10224609234443290642201, 12100000002420000000121, 12100242003630024200121,\n  12102202302620320220121, 12102444325852344420121, 12122010222622201022121, 12122252443834425222121, \n  12124214524842541242121, 12321000024642000012321, 12321244225852244212321, 12323222344844322232321, \n  12343210246864201234321, 12384043938083934048321, 12599536942224963599521, 16593841302620314839561, \n  40000000000800000000004, 1000000000002000000000001, 1000002000003000002000001, \n  1000004000006000004000001, 1000020200104010020200001, 1000022200125210022200001, 1000024200148410024200001, 1000200030004000300020001, 1000202030205020302020001, 1000204030408040304020001, 1000220232126212320220001, 1000222232347432322220001, 1002001002004002001002001, 1002003004005004003002001, 1002005006008006005002001, 1002021222306032221202001, 1002023224327234223202001, 1002201232026202321022001, 1002203234227224323022001, 1002221454348434541222001, 1002223456569656543222001, 1020100000204020000010201, 1020102020205020202010201, 1020104040208020404010201, 1020120402306032040210201, 1020122422327232242210201, 1020300010207020100030201, 1020302030406040302030201, 1020304050607060504030201, 1020320414309034140230201, 1020322434528254342230201, 1020324454749474544230201, 1022121002226222001212201, 1022123024227224203212201, 1022141424528254241412201, 1022143446549456443412201, 1022321210249420121232201, 1022323232448442323232201, 1022325254649464525232201, 1210000000024200000000121, 1210002200025200022000121, 1210004400028200044000121, 1210020020107010200200121, 1210022220126210222200121, 1210024420147410244200121, 1210220032026202300220121, 1210222232227222322220121, 1210242254148414522420121, 1210244454369634544420121, 1212201002226222001022121, 1212203204227224023022121, 1212221040509050401222121, 1212223242528252423222121, 1212225444549454445222121, 1212421234248424321242121, 1212423436449446343242121, 1232100000246420000012321, 1232102220247420222012321, 1232120202329232020212321, 1232122422348432242212321, 1232124642369632464212321, 1232322032448442302232321, 1232324252649462524232321, 1234321002468642001234321, 1234323224469644223234321, 1821056104269624016501281, 4000000000008000000000004, 4000004000009000004000004, 4618627222542452227268164, 6942236477330337746322496, 9420645034800084305460249, 40460195511188111559106404, 100000000000020000000000001, 100000220000141000022000001, 100002002010040010200200001, 100002222012363210222200001, 100020001200040002100020001, 100020221222161222122020001, 100022003410262014300220001, 100022223434585434322220001, 100200100020040020001002001, 100200320240161042023002001, 100202104032060230401202001, 100202324254383452423202001, 100220121220262022121022001, 100220341462383264143022001, 100222125432484234521222001, 102010000002040200000010201, 102010222202161202222010201, 102012022032060230220210201, 102012244234383432442210201, 102030201204060402102030201, 102030423426181624324030201, 102032223434282434322230201, 102212100022262220001212201, 102212322442383244223212201, 102214124054282450421412201, 102232321224484422123232201, 121000000000242000000000121, 121000242000363000242000121, 121002202210262012202200121, 121002444212585212444200121, 121022001220262022100220121, 121022243242383242342220121, 121024203630484036302420121, 121220100022262220001022121, 121220342242383242243022121, 121222304234282432403222121, 121242121242484242121242121, 123210000002464200000012321, 123210244202585202442012321, 123212222232484232222212321, 123232201224484422102232321, 123432100024686420001234321, 400000000000080000000000004, 923860899791363197998068329, 4872133543202112023453312784, 9658137819052882509187318569, 10000000000000200000000000001, 10000002000000300000020000001, 10000004000000600000040000001, 10000020200010401000202000001, 10000022200012521000222000001, 10000024200014841000242000001, 10000200021000400012000200001, 10000202021020502012020200001, 10000204021040804012040200001, 10000220221212621212202200001, 10000222221234743212222200001, 10002000102000400020100020001, 10002002102200500220120020001, 10002004102400800420140020001, 10002020304030603040302020001, 10002022304232723240322020001, 10002200143002620034100220001, 10002202143222722234120220001, 10002220345234843254302220001, 10002222345456965454322220001, 10020010000200400200001002001, 10020012002200500220021002001, 10020014004200800240041002001, 10020030220410601402203002001, 10020032222412721422223002001, 10020210221220602212201202001, 10020212223240704232221202001, 10020230441632823614403202001, 10020232443654945634423202001, 10022010100002720000101022001, 10022012102202620220121022001, 10022014104402720440141022001, 10022030322230903222303022001, 10022032324432823442323022001, 10022034326634943662343022001, 10022210341004940014301222001, 10022212343224842234321222001, 10022214345444944454341222001, 10201000000020402000000010201, 10201002020020502002020010201, 10201004040020802004040010201, 10201020402030603020402010201, 10201022422032723022422010201, 10201200001200700210000210201, 10201202021220602212020210201, 10201204041240704214040210201, 10201220403410901430402210201, 10201222423432823432422210201, 10201224443454945434442210201, 10203020102040604020102030201, 10203022122240704222122030201, 10203040506070807060504030201, 10203042526272927262524030201, 10203220123022922032102230201, 10203222143242824234122230201, 10203224163462926436142230201, 10221210000222622200001212201, 10221212022222722222021212201, 10221230422432823422403212201, 10221232444434943444423212201, 10221412221442824412221412201, 10221414243462926434241412201, 10223232102244844220123232201, 10223234124444944442143232201, 12100000000002420000000000121, 12100002200002520000220000121, 12100004400002820000440000121, 12100020020010701002002000121, 12100022220012621002222000121, 12100024420014741002442000121, 12100220023002620032002200121, 12100222223022722032222200121, 12100242243214841234224200121, 12100244443236963234444200121, 12102200102202620220100220121, 12102202302402720420320220121, 12102220124030903042102220121, 12102222324232823242322220121, 12102224524434943442542220121, 12102420145204840254102420121, 12102422345424942454322420121, 12122010000222622200001022121, 12122012202222722220221022121, 12122032240432823404223022121, 12122034442434943424443022121, 12122230223242824232203222121, 12122232425262926252423222121, 12124212102424842420121242121, 12124214304624942640341242121, 12321000000024642000000012321, 12321002220024742002220012321, 12321020202032923020202012321, 12321022422034843022422012321, 12321024642036963024642012321, 12321222023224842232022212321, 12321224243244944234242212321, 12323220102244844220102232321, 12323222322444944422322232321, 12343210000246864200001234321, 12343212222246964222221234321, 16799008923862526832980099761, 40000000000000800000000000004, 40000004000000900000040000004, 44431002775280908257720013444, 98693567900935453900976539689, 1000000000000002000000000000001, 1000000220000014100000220000001, 1000002002001004001002002000001, 1000002222001236321002222000001, 1000020000300004000030000200001, 1000020220302216122030220200001, 1000022002321026201232002200001, 1000022222323458543232222200001, 1000200010020004000200100020001, 1000200230042016102400320020001, 1000202012221206021222102020001, 1000202232243438343422322020001, 1000220012320026200232100220001, 1000220232344238324432320220001, 1000222014541248421454102220001, 1002001000002004002000001002001, 1002001220222016102220221002001, 1002003004005006005004003002001, 1002003224225238325224223002001, 1002021020302206022030201202001, 1002021240524418144250421202001, 1002023024325228225234203202001, 1002201210022026202200121022001, 1002201430264038304620341022001, 1002203214225228225224123022001, 1002221232322248422232321222001, 1020100000000204020000000010201, 1020100222200216120022220010201, 1020102022021206021202202010201, 1020102244221438341224422010201, 1020120200302206022030020210201, 1020120422504418144052240210201, 1020122222343228223432222210201, 1020302010020406040200102030201, 1020302232242418142422322030201, 1020304032241608061422304030201, 1020322212322428242232122230201, 1022121000002226222000001212201, 1022121222422238322242221212201, 1022123024025228225204203212201, 1022141220304428244030221412201, 1022323210022448442200123232201, 1210000000000024200000000000121, 1210000242000036300002420000121, 1210002202201026201022022000121, 1210002444201258521024442000121, 1210022000320026200230002200121, 1210022242322238322232422200121, 1210024202541048401452024200121, 1210220010022026202200100220121, 1210220252044038304402520220121, 1210222212423228223242122220121, 1210242012342048402432102420121, 1212201000002226222000001022121, 1212201242222238322222421022121, 1212203204205228225024023022121, 1212223020322428242230203222121, 1212421210024248424200121242121, 1232100000000246420000000012321, 1232100244200258520024420012321, 1232102222221248421222222012321, 1232122200322248422230022212321, 1232322010022448442200102232321, 1234321000002468642000001234321, 4000000000000008000000000000004, 4844486878939076709398786844484, 6574372239019762679109322734756, 9403095533541415141453355903049, 9659504223792743472973224059569, 9848294822582726272852284928489\n  ])\n  \n  filtered_table = np.array([0, 1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001,\n         1234321, 4008004, 100020001, 102030201, 104060401, 121242121,\n         123454321, 125686521, 400080004, 404090404, 10000200001,\n         10221412201, 12102420121, 12345654321, 40000800004, 1000002000001,\n         1002003002001, 1004006004001, 1020304030201, 1022325232201,\n         1024348434201, 1210024200121, 1212225222121, 1214428244121,\n         1232346432321, 1234567654321, 4000008000004, 4004009004004,\n         100000020000001, 100220141022001, 102012040210201, 102234363432201,\n         121000242000121, 121242363242121, 123212464212321, 123456787654321,\n         400000080000004, 10000000200000001, 10002000300020001,\n         10004000600040001, 10020210401202001, 10022212521222001,\n         10024214841242001, 10201020402010201, 10203040504030201,\n         10205060806050201, 10221432623412201, 10223454745432201,\n         12100002420000121, 12102202520220121, 12104402820440121,\n         12122232623222121, 12124434743442121, 12321024642012321,\n         12323244744232321, 12343456865434321, 12345678987654321,\n         40000000800000004, 40004000900040004, 1000000002000000001,\n         1000220014100220001, 1002003004003002001, 1002223236323222001,\n         1020100204020010201, 1020322416142230201, 1022123226223212201,\n         1022345658565432201, 1210000024200000121, 1210242036302420121,\n         1212203226223022121, 1212445458545442121, 1232100246420012321,\n         1232344458544432321, 1234323468643234321, 4000000008000000004,\n         100000000020000000001, 100002000030000200001, 100004000060000400001,\n         100020201040102020001, 100022201252102220001, 100024201484102420001,\n         100200120040021002001, 100202122050221202001, 100204124080421402001,\n         100220341262143022001, 100222343474343222001, 102010002040200010201,\n         102012022050220210201, 102014042080240410201, 102030405060504030201,\n         102032425272524230201, 102212122262221212201, 102214144272441412201,\n         102232545484545232201, 102234567696765432201, 121000000242000000121,\n         121002200252002200121, 121004400282004400121, 121022221262122220121,\n         121024421474124420121, 121220122262221022121, 121222324272423222121,\n         121242363484363242121, 121244565696565442121, 123210002464200012321,\n         123212222474222212321, 123232425484524232321, 123234645696546432321,\n         123432124686421234321, 123434346696643434321, 400000000080000000004,\n         400004000090000400004, 10000000000200000000001,\n         10000220001410002200001, 10002002100400120020001,\n         10002222123632122220001, 10020010200400201002001,\n         10020230421612403202001, 10022014302620341022001,\n         10022234545854543222001, 10201000020402000010201,\n         10201222221612222210201, 10203022140604122030201,\n         10203244363836344230201, 10221210222622201212201,\n         10221432643834623412201, 10223234344844343232201,\n         12100000002420000000121, 12100242003630024200121,\n         12102202302620320220121, 12102444325852344420121,\n         12122010222622201022121, 12122252443834425222121,\n         12124214524842541242121, 12321000024642000012321,\n         12321244225852244212321, 12323222344844322232321,\n         12343210246864201234321, 40000000000800000000004,\n         1000000000002000000000001, 1000002000003000002000001,\n         1000004000006000004000001, 1000020200104010020200001,\n         1000022200125210022200001, 1000024200148410024200001,\n         1000200030004000300020001, 1000202030205020302020001,\n         1000204030408040304020001, 1000220232126212320220001,\n         1000222232347432322220001, 1002001002004002001002001,\n         1002003004005004003002001, 1002005006008006005002001,\n         1002021222306032221202001, 1002023224327234223202001,\n         1002201232026202321022001, 1002203234227224323022001,\n         1002221454348434541222001, 1002223456569656543222001,\n         1020100000204020000010201, 1020102020205020202010201,\n         1020104040208020404010201, 1020120402306032040210201,\n         1020122422327232242210201, 1020302030406040302030201,\n         1020304050607060504030201, 1020322434528254342230201,\n         1020324454749474544230201, 1022121002226222001212201,\n         1022123024227224203212201, 1022141424528254241412201,\n         1022143446549456443412201, 1022323232448442323232201,\n         1022325254649464525232201, 1210000000024200000000121,\n         1210002200025200022000121, 1210004400028200044000121,\n         1210022220126210222200121, 1210024420147410244200121,\n         1210220032026202300220121, 1210222232227222322220121,\n         1210242254148414522420121, 1210244454369634544420121,\n         1212201002226222001022121, 1212203204227224023022121,\n         1212223242528252423222121, 1212225444549454445222121,\n         1212421234248424321242121, 1212423436449446343242121,\n         1232100000246420000012321, 1232102220247420222012321,\n         1232122422348432242212321, 1232124642369632464212321,\n         1232322032448442302232321, 1232324252649462524232321,\n         1234321002468642001234321, 1234323224469644223234321,\n         4000000000008000000000004, 4000004000009000004000004,\n         100000000000020000000000001, 100000220000141000022000001,\n         100002002010040010200200001, 100002222012363210222200001,\n         100020001200040002100020001, 100020221222161222122020001,\n         100022003410262014300220001, 100022223434585434322220001,\n         100200100020040020001002001, 100200320240161042023002001,\n         100202104032060230401202001, 100202324254383452423202001,\n         100220121220262022121022001, 100220341462383264143022001,\n         100222125432484234521222001, 102010000002040200000010201,\n         102010222202161202222010201, 102012022032060230220210201,\n         102012244234383432442210201, 102030201204060402102030201,\n         102030423426181624324030201, 102032223434282434322230201,\n         102212100022262220001212201, 102212322442383244223212201,\n         102214124054282450421412201, 102232321224484422123232201,\n         121000000000242000000000121, 121000242000363000242000121,\n         121002202210262012202200121, 121002444212585212444200121,\n         121022001220262022100220121, 121022243242383242342220121,\n         121024203630484036302420121, 121220100022262220001022121,\n         121220342242383242243022121, 121222304234282432403222121,\n         121242121242484242121242121, 123210000002464200000012321,\n         123210244202585202442012321, 123212222232484232222212321,\n         123232201224484422102232321, 123432100024686420001234321,\n         400000000000080000000000004, 10000000000000200000000000001,\n         10000002000000300000020000001, 10000004000000600000040000001,\n         10000020200010401000202000001, 10000022200012521000222000001,\n         10000024200014841000242000001, 10000200021000400012000200001,\n         10000202021020502012020200001, 10000204021040804012040200001,\n         10000220221212621212202200001, 10000222221234743212222200001,\n         10002000102000400020100020001, 10002002102200500220120020001,\n         10002004102400800420140020001, 10002020304030603040302020001,\n         10002022304232723240322020001, 10002200143002620034100220001,\n         10002202143222722234120220001, 10002220345234843254302220001,\n         10002222345456965454322220001, 10020010000200400200001002001,\n         10020012002200500220021002001, 10020014004200800240041002001,\n         10020030220410601402203002001, 10020032222412721422223002001,\n         10020210221220602212201202001, 10020212223240704232221202001,\n         10020230441632823614403202001, 10020232443654945634423202001,\n         10022012102202620220121022001, 10022014104402720440141022001,\n         10022032324432823442323022001, 10022034326634943662343022001,\n         10022212343224842234321222001, 10022214345444944454341222001,\n         10201000000020402000000010201, 10201002020020502002020010201,\n         10201004040020802004040010201, 10201020402030603020402010201,\n         10201022422032723022422010201, 10201202021220602212020210201,\n         10201204041240704214040210201, 10201222423432823432422210201,\n         10201224443454945434442210201, 10203020102040604020102030201,\n         10203022122240704222122030201, 10203040506070807060504030201,\n         10203042526272927262524030201, 10203222143242824234122230201,\n         10203224163462926436142230201, 10221210000222622200001212201,\n         10221212022222722222021212201, 10221230422432823422403212201,\n         10221232444434943444423212201, 10221412221442824412221412201,\n         10221414243462926434241412201, 10223232102244844220123232201,\n         10223234124444944442143232201, 12100000000002420000000000121,\n         12100002200002520000220000121, 12100004400002820000440000121,\n         12100022220012621002222000121, 12100024420014741002442000121,\n         12100220023002620032002200121, 12100222223022722032222200121,\n         12100242243214841234224200121, 12100244443236963234444200121,\n         12102200102202620220100220121, 12102202302402720420320220121,\n         12102222324232823242322220121, 12102224524434943442542220121,\n         12102420145204840254102420121, 12102422345424942454322420121,\n         12122010000222622200001022121, 12122012202222722220221022121,\n         12122032240432823404223022121, 12122034442434943424443022121,\n         12122230223242824232203222121, 12122232425262926252423222121,\n         12124212102424842420121242121, 12124214304624942640341242121,\n         12321000000024642000000012321, 12321002220024742002220012321,\n         12321022422034843022422012321, 12321024642036963024642012321,\n         12321222023224842232022212321, 12321224243244944234242212321,\n         12323220102244844220102232321, 12323222322444944422322232321,\n         12343210000246864200001234321, 12343212222246964222221234321,\n         40000000000000800000000000004, 40000004000000900000040000004,\n         1000000000000002000000000000001, 1000000220000014100000220000001,\n         1000002002001004001002002000001, 1000002222001236321002222000001,\n         1000020000300004000030000200001, 1000020220302216122030220200001,\n         1000022002321026201232002200001, 1000022222323458543232222200001,\n         1000200010020004000200100020001, 1000200230042016102400320020001,\n         1000202012221206021222102020001, 1000202232243438343422322020001,\n         1000220012320026200232100220001, 1000220232344238324432320220001,\n         1000222014541248421454102220001, 1002001000002004002000001002001,\n         1002001220222016102220221002001, 1002003004005006005004003002001,\n         1002003224225238325224223002001, 1002021020302206022030201202001,\n         1002021240524418144250421202001, 1002023024325228225234203202001,\n         1002201210022026202200121022001, 1002201430264038304620341022001,\n         1002203214225228225224123022001, 1002221232322248422232321222001,\n         1020100000000204020000000010201, 1020100222200216120022220010201,\n         1020102022021206021202202010201, 1020102244221438341224422010201,\n         1020120200302206022030020210201, 1020120422504418144052240210201,\n         1020122222343228223432222210201, 1020302010020406040200102030201,\n         1020302232242418142422322030201, 1020304032241608061422304030201,\n         1020322212322428242232122230201, 1022121000002226222000001212201,\n         1022121222422238322242221212201, 1022123024025228225204203212201,\n         1022141220304428244030221412201, 1022323210022448442200123232201,\n         1210000000000024200000000000121, 1210000242000036300002420000121,\n         1210002202201026201022022000121, 1210002444201258521024442000121,\n         1210022000320026200230002200121, 1210022242322238322232422200121,\n         1210024202541048401452024200121, 1210220010022026202200100220121,\n         1210220252044038304402520220121, 1210222212423228223242122220121,\n         1210242012342048402432102420121, 1212201000002226222000001022121,\n         1212201242222238322222421022121, 1212203204205228225024023022121,\n         1212223020322428242230203222121, 1212421210024248424200121242121,\n         1232100000000246420000000012321, 1232100244200258520024420012321,\n         1232102222221248421222222012321, 1232122200322248422230022212321,\n         1232322010022448442200102232321, 1234321000002468642000001234321,\n         4000000000000008000000000000004], dtype=object)\n  \n  \n  def read_input(infile):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints():\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #change the dtype?\n      \n      A, B = read_bigints()\n      \n      return (A, B)\n  \n  def is_palindrome(num):\n      digits = []\n      num = int(num)\n      while num > 0:\n          digits.append(num % 10)\n          num = num / 10 #n.b. int division (discard remainder)\n  \n      return digits == digits[::-1]\n  \n      for i in range(len(digits) / 2): #n.b. int division (skips center)\n          if digits[i] != digits[-i+1]:\n              return False\n      return True\n  \n  def solve_case_simple(case):\n      A, B = case\n      \n      if B > table_of_fairs[-1]:\n          raise ValueError, \"Ranges too big for lookup table!\"\n      \n      valid = (A <= filtered_table) * (filtered_table <= B)\n      return valid.sum()\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      \n      output = solve_case_simple(case)\n      return output\n  \n  \n  if __name__ == \"__main__\":\n      infile = open(\"%s-%s%s.in\" % (problem, tag, suffix), 'r')\n      outfile = open(\"%s-%s%s.out\" % (problem, tag, suffix), 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n", "substitutes": {"problem": ["ox", "strip", "ex", "unit", "ins", "s", " module", "standard", "pe", "print", " category", " fmt", "lab", " marker", "ply", "scale", "purpose", "ID", "pos", "fx", " anchor", "component", " features", "pad", " unit", "action", " feature", " pattern", " padding", "module", " pad", "base", " id", " prog", " border", " spec", " component", " prefix", "fix", " char"], "tag": ["include", "opt", "target", "unit", "key", "mode", "comment", "member", "label", "standard", "header", "tags", " marker", "oid", "purpose", "id", "pid", "component", "scope", "category", "prefix", "option", " feature", "flag", "module", "method", "channel", "word", "var", "prop", "feat", "head", "ype", "kind", "product", "float", "char", "feature"], "suffix": ["accprefix", "suffance", " suffixed", " suffance", "descixed", "accance", "suffixed", "accix", "descprefix", "suffprefix", " suffprefix", "descix", "descance", "accixed"], "table_of_fairs": ["table_of_fpair", "table_of_fair", "table_of_pairs", "table_of_cfays", "table_of_fays", "table_of_cfpair", "table_of_pays", "table_of_cfairs", "table_of_cfair", "table_of_flpair", "table_of_flays", "table_of_flairs", "table_of_ppair", "table_of_pair", "table_of_flair"]}}
{"code": " \n  \n  case = 1\n  problem = \"B\"\n  practice = False\n  \n  if practice:\n      practice = \"-practice\"\n  else:\n      practice = \"-attempt0\"\n  if case == 0:\n      infile = open(\"%s-%s%s.in\" % (problem, \"sample\", practice), 'r')\n      outfile = open(\"%s-%s%s.out\" % (problem, \"sample\", practice), 'w')        \n  elif case == 1:\n      infile = open(\"%s-%s%s.in\" % (problem, \"small\", practice), 'r')\n      outfile = open(\"%s-%s%s.out\" % (problem, \"small\", practice), 'w')    \n  elif case == 2:\n      infile = open(\"%s-%s%s.in\" % (problem, \"large\", practice), 'r')\n      outfile = open(\"%s-%s%s.out\" % (problem, \"large\", practice), 'w')   \n  else:\n      raise ValueError, 'Invalid case'\n      \n  lookup = {}\n  \n  def check_total(total, p):\n      assert type(total) == int\n      resid = total % 3\n  \n      min_nosurprise = (total / 3)    \n      max_nosurprise = (total / 3) + min(1, resid)\n      \n      \n      if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):\n          if max_nosurprise >= p:\n              return 1\n          else:\n              return -1\n  \n      if max_nosurprise >= p:\n          return 1\n      elif max_nosurprise == p-1:\n          return 0\n      else:\n          return -1\n      \n  cases = int(infile.readline().strip('\n'))\n  for i in range(cases):\n      print 'case %i of %i' % (i+1, cases)\n      line = infile.readline().split()\n      N = int(line[0])\n      S = int(line[1])\n      p = int(line[2])\n      points = []\n      for item in line[3:]:\n          points.append(int(item))\n      assert N == len(points)\n      assert p <= 10\n      assert p >= 0\n      assert S >= 0\n      assert S <= N\n      \n      always = 0\n      possible = 0\n      \n      for total in points:\n          if (total, p) in lookup:\n              depends = lookup[total, p]\n          else:\n              depends = check_total(total, p)\n          \n          if depends == 1:\n              always += 1\n          elif depends == 0:\n              possible += 1\n      \n      output = '%i' % (always + min(possible, S))\n      \n      outfile.write('Case #%i: %s\n' % (i+1, output))\n      \n  infile.close()\n  outfile.close()\n", "substitutes": {"case": ["step", "section", "Case", "condition", "division", "config", "shape", "address", "ASE", "zip", "size", "example", "key", "error", "ce", "comment", "rest", "DC", "path", "count", "value", "connection", "pe", "call", "model", "pair", "command", "trial", "group", "scale", "ase", "order", "chance", "chain", "password", "type", "choice", "definition", "name", "part"], "problem": ["study", " problems", " situation", "fit", "model", "past", "theme", "function", "name", "chapter", "concept", "system", "computer", "phase", "team", "string", "question", "feature", "section", "conference", "issue", "reference", "project", "term", "plugin", "data", "python", "picture", "purpose", "sequence", " demo", "module", "application", "layer", "hello", "episode", "example", "error", "behavior", " clue"], "practice": ["address", "study", "mm", "piece", "progress", "formation", "jury", "am", "theme", "scale", "function", "name", "ace", " Practice", "mc", "grade", "asm", "question", "repeat", "instance", "feature", "perfect", "magic", "shape", "care", "size", "complete", "rate", "mage", "training", "period", "true", "order", "purpose", "average", "phrase", "sequence", "race", "cache", "workshop"], "infile": ["INFile", "inline", "incfile", "outfolder", "infolder", "incomplete", "instream", "cincomplete", " infilename", "outcomplete", "Infile", "outfilename", "inf", "outfiles", " incomplete", " inlock", "INf", "outile", "cinFile", " inile", "outline", "outFile", "inputline", "incline", "outf", "INstream", "inputFile", "inclock", "inputfiles", "InFile", "outlock", " inline", "INfile", "inputfile", "inile", " infolder", "Instream", " infiles", "INfilename", "infilename"], "outfile": ["outputline", " outFile", " outfilename", "outputFile", "outfil", "outputfil", " outile", "outfilename", "OUTf", "workfilename", "outputf", "outputfile", "outile", "outline", "outputfilename", "outFile", "OUTline", "outf", "OUTFile", "OUTfile", "workfile", "workile", " outfil", " outline", "workfil", "OUTfilename", "outputile", " outf"], "lookup": ["Lookdown", "LookUp", "setups", "setdown", "lookdown", "lookUp", "setUp", "followups", "Lookup", "followUp", "Lookups", "followdown", "setup", "lookups", "followup"], "total": ["P", "otal", "open", "size", "null", "final", "t", "max", "complete", "valid", "u", "n", "count", "percent", "value", "full", "trial", "less", "partial", "scale", "all", "net", "stats", "type", "part", "multi", "parent", "current", "d", "id", "pa", "m", "active", "gross", "last", "pha", "num", "tp", "gap", "local"], "p": ["l", "pp", "pl", "t", "b", "op", "tp", "point", "o", "proc", "ap", "h", "y", "start", "L", "c", "fp", "T", "pa", "j", "min", "per", "py", "set", "lp", "r", "np", "dp", "m", "x", "bp", "sp", "E", "a", "number", "patch", "w", "at", "u", "I"], "resid": [" resite", "resnum", "preside", " resident", "rezid", "rasid", " reskid", "oskid", " resids", "specid", "rezident", "reside", "ResID", "speckid", "resmid", "reznum", "osids", "osident", "Resid", "rasmid", " resID", "rasident", "osid", "specids", "presid", " resnum", "oside", "resID", "rasnum", "Reside", " reside", "resids", "rezmid", "specident", "resite", "osite", "presite", "reskid", "resident", "Reskid"], "min_nosurprise": ["min_nosaurprise", "min_nosubprise", "min_nossurvey", "min_nosurvey", "min_posurprises", "min_posurprising", "min_nosubprises", "min_posurprise", "min_posureprise", "min_posureprising", "min_nosureprising", "min_nosubprising", "min_nossurprise", "min_posurevey", "min_nosureprise", "min_nossurprises", "min_nosurprises", "min_nosaurprising", "min_posureprises", "min_nosurevey", "min_nossurprising", "min_posurvey", "min_nosurprising", "min_nosaurprises", "min_nosaurvey", "min_nosureprises", "min_nosubvey"], "max_nosurprise": ["max_posureprise", "max_nosourvey", "max_nosubprise", "max_nosurevey", "max_posurparty", "max_posurprise", "max_nosureparty", "max_nosureprises", "max_nosourprise", "max_posurprises", "max_nosubprising", "max_nosourrance", "max_nosearvey", "max_posureprising", "max_nosaurprising", "max_posureparty", "max_nosubvey", "max_nosureprising", "max_nosubprises", "max_nosaurvey", "max_nossurvey", "max_nosearprising", "max_nosourprises", "max_nosaurparty", "max_nosurprises", "max_nosurrance", "max_nosurerance", "max_nosearprises", "max_nosurvey", "max_nossurprise", "max_nosureprise", "max_posurprising", "max_nosaurprise", "max_nosubrance", "max_posureprises", "max_nossurprising", "max_nosaurprises", "max_posurerance", "max_nosurprising", "max_nosurparty"], "cases": ["config", "Case", "section", "shape", "es", "features", "lines", "values", "size", "sections", "changes", "path", "count", "codes", "groups", "cs", "ids", "tests", "limits", "errors", "breaks", "events", "blocks", " tests", "tips", "chains", "settings", "details", "ches", "times", "its", "cells", "steps", "comments", "runs", "terms", "types", "rows", "base", "checks"], "i": ["ip", "j", "adi", "z", "chi", "eni", "ti", "I", "n", "r", "qi", "ui", "slice", "phi", "uri", "int", "xi", "type", "ie", "bi", "multi", "li", "pos", "id", "d", "iu", "x", "pi", "num", "val", "di", "bis", "row", "mi", "ix", "mini", "end", "e", "hi", "h"], "line": ["co", "l", "detail", "inline", "key", "handle", "frame", "phase", "file", "look", "list", "point", "rule", "lf", "edge", "cle", "LINE", "log", "le", "iter", "group", "cycle", "se", "element", "sync", "entry", "ide", "code", "date", "liner", "end", "strip", "band", "cell", "unit", "error", "ge", "pin", "slice", "object"], "N": ["P", "Q", "J", "Z", "D", "NI", "H", "I", "n", "s", "IP", "M", "NA", "A", "NT", "Len", "Max", "SN", "NP", "NB", "ns", "G", "NL", "U", "PI", " n", "nb", "Ns", "W", "Number", "O", "Total", "Num", "E", "NO", "OS", "C", "Ne", "V", "L"], "S": ["P", "J", "Q", "TS", "Z", "D", "Ps", "H", "I", "n", "s", "IP", "M", "SU", "A", "SA", "d", "MS", "SK", "SH", "AS", "ns", "G", "U", "Sa", "SE", "Ns", "W", "ps", "sp", "O", "SL", "E", "SP", "OS", "C", "V", "Si", "L", "X"], "points": ["features", "lines", "values", "sections", "sets", "changes", "s", "letters", "marks", "data", "tests", "faces", "tops", "parts", "games", "breaks", "events", "blocks", "pos", "words", "works", "objects", "tips", "notes", "chains", "charges", "details", "flows", "point", "times", "steps", "cells", "pieces", "types", "posts", "checks", "models", "series", "ps", "holes"], "item": ["step", "ip", "page", "anything", "amp", "atom", "unit", "member", " I", "loc", "character", "piece", "I", "value", "node", "_", "data", "object", "array", "it", "element", "article", "name", " _", "day", "li", "ace", "id", " Item", "entry", "site", "position", "event", " it", "x", "val", "num", "other", "individual", "point"], "always": ["Q", "J", "Z", "Ps", "H", "I", " end", "x", "steps", " trials", "Times", "E", "V", " cs", "X", "L", "Y", " phase", "Points"], "possible": ["features", "new", "size", "example", "path", "count", "_", "all", "function", "pos", "index", "response", "match", "times", "length", "pattern", "check", "number", "end"]}}
{"code": " \n  \n  def is_palindrome(num):\n      s1 = str(num)\n      s2 = s1[::-1]\n      return s1 == s2\n  \n  fair_numbers = []\n  for i in range(pow(10, 7)+1):\n      if is_palindrome(i):\n          num = i*i\n          if is_palindrome(num):\n              fair_numbers.append(num)\n  \n  N = int(sys.stdin.readline())\n  for T in range(1, N+1):\n      min_val, max_val = map(int, sys.stdin.readline().strip().split())\n  \n      ans = 0\n      for num in fair_numbers:\n          if num < min_val:\n              continue\n          if num > max_val:\n              break\n          ans += 1\n      print 'Case #%(T)s: %(ans)s' % locals()\n", "substitutes": {"num": ["ti", "t", "loc", "dim", "fen", "int", "init", "name", "multi", "nr", "id", "don", "nom", "o", "dom", "nb", "nam", "nic", "nc", "nn", "gnu", "ci", "Num", "note", "un", "min", "valid", "mn", "im", "mon", "term", "nw", "mom", "nick", "np", "gen", "m", "x", "ni", "umi"], "s1": ["hs01", "S3", "hs2", "p3", "hs3", "ss2", " s01", "abs3", "s01", "abs2", "ssone", " sone", "p1", "abs1", "Sone", "hs1", "sone", "S2", "S1", " s3", "ss1", "ss3", "abs01", "p2", "s3"], "s2": [" s0", " s_", "ss2", "ss4", "S0", "ss0", "s_", "s0", "p1", "s4", "S2", "S1", "p0", "S4", "ss1", "p_", "S_", " s4", "p2"], "fair_numbers": ["fair_nodes", "fairallnotumbered", "fair_longumbers", "fair_notumbered", "fair_gnums", "fair_pnals", "fair_pnumbered", "fair_longums", "fair_cookulas", "fair_codes", "fair_noffs", "fair_numums", "fairallnotodes", "fair_gnulas", "fair_norodes", "fair_pnumbers", "fair_numbered", "fairPnategories", "fair_cookoffs", "fairallnotals", "fairPnodes", "fair_cumbers", "fair_longodes", "fair_gnoffs", "fair_longategories", "fair_cookums", "fair_nategories", "fair_cookumbers", "fairallnals", "fair_notodes", "fairPnumbers", "fairallnumbers", "fair_cums", "fair_nulas", "fair_numulas", "fair_notumbers", "fair_gnumbers", "fair_notals", "fair_numoffs", "fair_norumbers"], "i": ["ai", "l", "ip", "j", "z", "chi", "eni", "u", "t", " I", "ri", "ti", "n", "I", "ih", "b", "s", "qi", "yi", "it", "phi", "int", "xi", "init", "ie", "k", "li", "d", "id", "p", "m", "iu", "x", "ni", "pi", "mu", "mi", "o", "io", "ix"], "N": ["P", "Size", "D", "Z", "NI", "ND", "n", "I", "NC", "M", "NA", "Len", "NT", "NUM", "SN", "NP", "NN", "NB", "NE", "Nat", "NR", "NM", "ns", "No", "U", "NL", "Ni", " n", "Ns", "O", "Num", "NO", "Ne", "MN", "S", "V", "C", "L", "X", "Node"], "T": ["P", "j", "Z", "D", "unit", "t", "u", " I", "I", "term", "M", "NUM", "TC", "k", "d", "m", "time", "G", "U", " NUM", " F", "O", "h", "C", "f", "S", "L", "c", "number", "K", "tim", "F", "ind", "Num"], "min_val": ["min__val", "max_vals", "min_vals", "min__Val", "min_value", "max_value", "min_Val", "max_Val", "min__vals", "min__value"], "max_val": [" max_eval", "max__val", " max_pid", "max2eval", "max\u00b7val", " max_Val", "max__pid", "max_pid", "max2value", "max_vals", " max_vals", "max_eval", "max\u00b7Val", " max_value", "max_value", "max\u00b7pid", "max_Val", "max__Val", "max2vals", "max2val", "max__value", "max\u00b7value"], "ans": ["ents", "can", "Na", "aces", "aning", "ins", "ras", "cas", "ations", "ms", "ks", "cons", "ann", "anon", "span", "aus", "AN", "NA", "rors", "anas", "ays", "anes", "ats", "errors", "ants", "na", "ana", " spans", "ens", "ns", "ates", "yes", "ANS", "san", "ani", "nas", "ops", "offs", "ases", "ions"]}}
{"code": " \n  \n  for i, line in enumerate(sys.stdin):\n      if i == 0:\n          continue\n  \n      params = [int(n) for n in line.split(' ')]\n      (N, S, p) = params[:3]\n      scores = params[3:]\n  \n      (clear, possible) = (0, 0)\n      normal_min = max(p * 3 - 2, 0)\n      suprising_min = max(p * 3 - 4, 0)\n      for score in scores:\n          if p > score:\n              continue\n          elif score >= normal_min:\n              clear += 1\n          elif score >= suprising_min:\n              possible += 1\n  \n      ans = clear + min(possible, S)\n      print 'Case #%(i)s: %(ans)s' % locals()\n", "substitutes": {"i": ["ai", "l", "j", "chi", "z", "cli", "eni", "ti", "I", "fi", "s", "v", "b", "qi", "ui", "ori", "it", "phi", "uri", "int", "xi", "type", "name", "bi", "li", "d", "id", "sci", "x", "pi", "ni", "num", "di", "o", "io", "e", "zi", "y", "a", "f"], "line": ["LINE", "log", "l", "band", "cell", "lines", "page", "obj", "case", "out", " lines", "iter", "comment", "url", "col", "path", "ino", "v", "de", "_", "data", "object", "source", "frame", "name", "on", "li", "d", "pos", "file", "time", "x", "block", "lined", "val", "str", "o", "row", "lin", "lf"], "params": ["config", "shape", "ip", "es", "lines", "page", "args", "py", "amps", "eps", "changes", "lp", "pm", "s", "v", "Par", "python", "abilities", "param", "array", "np", "net", "scan", "parse", "phrase", "pixel", " parameters", "pos", "words", "par", "rules", "resp", "phase", "settings", "details", "ores", "res", "rams", "pi", "response"], "n": ["l", "j", "z", "pn", "t", "u", "r", "b", "s", "span", "it", "np", "net", "ne", "all", "ln", "name", "k", "on", "d", " nan", "m", "na", "ns", "ni", "num", "gn", "o", "rn", "nb", "skip", "e", "nt", " fn", "nc", "nn", "cn", "an", "no", "a"], "N": ["P", "Q", "J", "Z", "D", "Size", "NI", "H", "I", "M", "NA", "A", "NT", "SN", "NN", "NR", "G", "U", "Ns", "W", "O", "no", "Num", "Sn", "C", "V", "L", "X", "Y", "K", "T", "B", "network", "F", "NS", "R"], "S": ["small", "P", "Q", "Z", "D", "PS", "Sc", "ss", "I", "SAN", "s", "M", "SU", "A", "scan", "Single", "SN", "SY", "SK", "SH", "AS", "G", "ASC", " s", "U", "Sa", "south", "SE", "Ns", "W", "sp", "sample", "SC", "SP", "OS", "C", "sc", "V", "Si", "L"], "p": ["l", "pp", "t", "b", "rank", "tp", "PI", "o", "ap", "h", "y", "c", "T", "g", "fp", "j", "per", "py", "case", "r", "lp", "np", "m", "x", "bp", "cache", "sp", "a", "number", "w", "ore", "pn", "u", "error", "I", "s", "cp", "pair", "k", "d"], "scores": ["oscases", "swore", "cores", " screens", "oscreens", "scriptores", "scases", "scales", "scences", "oscore", "swores", "canners", "cales", " scales", "oscores", "scriptences", "scriptales", "swases", "scanners", " scases", "swreens", " scences", "cences", "screens", " scanners", "scriptanners"], "clear": ["adv", "center", "missing", "save", "open", "case", "complete", "error", "move", "enable", "mark", "core", "set", "present", "valid", "count", "zero", "pres", "stage", "order", "scan", "init", "complex", "avoid", "simple", "parse", "default", "rich", "id", "rank", "close", "active", "allow", "err", "clean", "deep", "pad", "south", "draw", "play"], "possible": ["possibly", "Pierra", " possibly", "npossible", "spossibly", "Possibly", " possibility", "psossibility", "impossibly", "pierra", "psierra", "possibility", "npossibly", "impossibility", "spierra", "Possible", "npossibility", "impossible", "Possibility", "npodd", "psossible", " podd", "psossibly", "podd", "spossible", "spossibility", "spodd"], "normal_min": ["normal_mins", "normal67max", " normal_lower", "normal_lower", "normal67min", "normal_main", "normal_max", " normal_mins", "normal67main", " normal_main", " normal_len", "normal67lower", "normal_len", " normal_max"], "suprising_min": ["suprising_mins", "suprising_all", "supraising_min", "supraising_diff", "suprising_max", "suprising_diff", "supraising_mins", "supraising_max", "supraising_mini", "suprising_mini", "supraising_all"], "score": [" result", "mean", "name", "rank", "ores", "grade", "y", "start", "c", "est", "size", "case", "core", "set", "rate", "mage", "che", "np", " scoring", "Score", "err", "er", "race", "no", "ize", "en", "scoring", "code", "orer", "pri", "number", "player", "done", "ore", "end", " scorer", "error", "une", " winner", "content"], "ans": ["ces", "es", "ins", "cas", "ians", "ks", "ann", " ads", "AN", "asa", "ian", "cs", "anas", "ays", " signs", "ants", "na", " spans", "ens", "ns", "ANS", "san", "ani", "nas", "plan", "an", "ons", "ars", "sn", " scans", "sk", "An", "sd", " means", " suggests", "aned", " plans"]}}
{"code": " \n  \n  \n  def calculatepalindromes(ndigits):\n      if ndigits == 1:\n          return 3\n  \n      result = 0\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)/2)\n  \n      if isEven:\n          result += 1\n      else:\n          result += 3\n  \n      for numones in range(0, min(6, fillingdigits) + 1):\n          combinations = int(math.factorial(fillingdigits) / (math.factorial(fillingdigits-numones) * math.factorial(numones)))\n          result += combinations\n          if not isEven:\n              result += combinations\n  \n      return result\n  \n  \n  def findpalindromes(ndigits):\n      if ndigits == 1:\n          return [1, 2, 3]\n  \n      result = []\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)/2)\n  \n      if isEven:\n          result.append(int(\"2\" + \"0\"*(fillingdigits*2) + \"2\"))\n      else:\n          result.append(int(\"2\" + \"0\"*fillingdigits + \"0\" + \"0\"*fillingdigits + \"2\"))\n          result.append(int(\"2\" + \"0\"*fillingdigits + \"1\" + \"0\"*fillingdigits + \"2\"))\n          result.append(int(\"1\" + \"0\"*fillingdigits + \"2\" + \"0\"*fillingdigits + \"1\"))\n  \n      for numones in range(0, min(6, fillingdigits)+1):\n          ones = fillOnes([], fillingdigits, numones)\n          for o in ones:\n              if isEven:\n                  result.append(int(\"1\" + \"\".join(o) + \"\".join(list(reversed(o))) + \"1\"))\n              else:\n                  result.append(int(\"1\" + \"\".join(o) + \"0\" + \"\".join(list(reversed(o))) + \"1\"))\n                  result.append(int(\"1\" + \"\".join(o) + \"1\" + \"\".join(list(reversed(o))) + \"1\"))\n  \n      return result\n  \n  def fillOnes(combination, size, remainingOnes):\n      if len(combination) == size:\n          return [combination]\n      result = []\n      if remainingOnes > 0:\n          c = combination + [\"1\"]\n          result += fillOnes(c, size, remainingOnes - 1)\n      if remainingOnes < size - len(combination):\n          c = combination + [\"0\"]\n          result += fillOnes(c, size, remainingOnes)\n      return result\n  \n  \n  \n  ncases = int(sys.stdin.readline())\n  \n  for t in range(1, ncases+1):\n      fairsquare = 0\n      (a, b) = sys.stdin.readline().strip().split(\" \")\n      intA = int(a)\n      intB = int(b)\n      ndigitsA = len(a)\n      ndigitsB = len(b)\n      ndigitsARooted = math.ceil(ndigitsA/2)\n      ndigitsBRooted = math.ceil(ndigitsB/2)\n  \n      if ndigitsBRooted == ndigitsARooted:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA and p ** 2 <= intB:\n                  fairsquare +=1\n      else:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA:\n                  fairsquare +=1\n  \n          for i in range(ndigitsARooted + 1, ndigitsBRooted):\n              fairsquare += calculatepalindromes(i)\n  \n          palindromes = findpalindromes(ndigitsBRooted)\n          for p in palindromes:\n              if p ** 2 <= intB:\n                  fairsquare +=1\n  \n      print(\"Case #%d: %d\" % (t, fairsquare))\n", "substitutes": {"ndigits": ["ngigions", "ndiggits", "ngigenits", "mdigets", "ndigbits", "ddigsals", "ndigges", "unddigets", "ndighins", "ndligites", "ntigets", "ndignit", "ldigenits", "ndligets", "ldigits", "ntigites", "ngigals", "nddigals", "ngigenals", "ndimbits", "ndIGbits", "ldigites", "ndigites", "ndigit", "ddigals", "ndigsals", "undigites", "ndligands", "undignit", "undigases", "undignbits", "ndIGions", "mdigsets", "ndighit", "mdigsit", "ndigsets", "ddigites", "ngigenases", "ndigets", "ndligits"], "result": ["progress", "desc", "rest", "all", "function", "master", "buffer", "also", "fr", "runner", "list", "table", "other", "json", "grade", "test", "Results", "coll", "string", "feature", "follow", "root", "section", "case", "complete", "df", "valid", "rate", "r", "term", "data", "true", "duration", "array", "group", "element", "compl", "dict", "ret", "details"], "isEven": ["isDown", "isiElectric", "lisDeep", "isoExactly", "sDown", "phisElectric", "phisOpen", "phisExactly", " iseven", "isAll", "phisEqu", "lisOpen", "isySingle", " isElectric", "lisEven", "isExactly", "nisEven", "iseven", "isYet", "ishAll", "uriDue", "isiSquare", "risExactly", "lisDue", "ishEven", "sExactly", "siElectric", "bisEven", "isiOpen", "isDue", "doesFin", "isElectric", "bisExactly", "isDeep", "risYet", "phisEven", "lisSingle", " isEn", "doesEqu", "isoEqu"], "fillingdigits": ["falingdigit", "fillingDigbits", "filingmultiplites", "fillingdigites", "fillingdimITS", "fillingmultiplists", "fillingdigets", "fillingbigins", "fillinglogITS", "fillingsignitives", "filledsignITS", "fillingDigensions", "falingdigites", "fillingdecins", "filledDigits", "fillingdigitins", "fillingdecites", "filleddigals", "fillingsignites", "fillingbigit", "fillingDigins", "fillingdigitites", "fillingdigbits", "fillingmultiplractions", "filldigits", "filledlogitives", "fillingdigitives", "fillingsignits", "fillinglogits", "fillingsignists", "fillingmultiplbits", "fillingmagITS", "fillinglogets", "finingdigits", "fillinglogit", "filledDigets", "fillingdigit", "filldigITS", "filledsignists", "fillingsignals"], "numones": ["ncells", "numtones", "mutcycles", "numbertimes", "numoes", " nummany", "nomONES", "numless", "nomones", "numubes", "Numcycles", "nummany", "numletters", "mutones", "nommany", "nbcycles", "Numone", "noes", "Numubes", " numoes", " numlines", "Numlines", "nones", "Numodes", "nomubes", "Numletters", "NumONES", " numless", "namless", " numtimes", " numONES", "Numless", "numONES", "nbodes", "mutodes", "nomtimes", "numcells", "Numones", "namones", "numberones"], "combinations": ["Combinates", " combins", "cominations", "combinators", "clination", "comination", "clinations", "Combinations", "clinates", " combinates", "clines", "combins", "combinates", "clinators", "comines", "Combination", "Combinators", "combines", " combines", "Combins", "cominators", " combinators", "clins"], "ones": ["ox", "lo", "ubes", "videos", "lines", "z", "oes", "onents", "these", "aves", " phones", "nos", " zones", "oning", "one", "zero", "cons", "many", "cross", "ords", "eros", "faces", "members", "alls", "frames", "odes", "zone", "none", "objects", "outs", "notes", "other", "x", "tones", "flows", "olutions", "times", "cells", "plus", "rons"], "o": ["co", "l", "ot", "bo", "op", "oo", "objects", "other", "od", "io", "\u00f3", "oice", "ou", "ol", "y", "online", "office", "lo", "j", "obj", "out", "yo", "r", "less", "oe", "do", "m", "go", "po", "x", "os", "ed", "O", "no", "iso", "off", "ode", "ox", "u", "oa"]}}
{"code": " \n  \n  def findbest(score):\n  \tif score == 0: return (0, 0)\n  \n  \tbest = math.ceil(score / 3)\n  \tbestsurp = round(score / 3) + 1\n  \n  \treturn (best, bestsurp)\n  \t\n  sys.stdin.readline()\n  \n  casenum = 0\n  for line in sys.stdin:\n  \tcasenum += 1\n  \n  \tdata = line.strip().split(' ')\n  \tmaxsurprising = int(data[1])\n  \tp = int(data[2])\n  \tscores = data[3:]\n  \tmaxgooglers = 0\n  \n  \tfor s in scores:\n  \t\t(best, bestsurp) = findbest(int(s))\n  \t\tif best >= p:\n  \t\t\tmaxgooglers += 1\n  \t\telse:\n  \t\t\tif bestsurp >= p and maxsurprising > 0:\n  \t\t\t\tmaxgooglers += 1\n  \t\t\t\tmaxsurprising -= 1\n  \n  \tprint(\"Case #%d: %d\" % (casenum, maxgooglers))\n", "substitutes": {"score": ["game", "size", "z", "case", "scene", "error", "rice", "core", "server", "rate", "count", "sf", "une", "give", "confidence", "fit", "distance", "ward", "scale", "live", "order", "level", "speed", "rank", "seed", "time", "Score", "go", "err", "success", "num", "match", "draw", "grade", "length", "si", "result", "depth", "weight", "status"], "best": ["mate", "new", "size", "obj", "alpha", "pp", "case", "final", "max", "rest", "right", "core", "ss", "ast", " Best", "one", "me", "value", "largest", "python", "style", "live", "star", "hest", "ale", "default", "master", "name", "average", "ave", "good", "current", "parser", "rank", "worst", "home", "last", "success", "x", "gross"], "bestsurp": ["bestsURper", "bestsarc", "bestsulm", "bestsulpe", "bistsaurP", "bestsulp", "bestscurp", "bestsurtping", "bestssurp", "bestsaurP", "bessesurP", "bastsulv", "bestsaurpit", "bastsurc", "bestsURp", "bestsurtf", "bestssurpit", "bestsURpe", "bestsarv", "bastsurp", "bistsurping", "bestsaurping", "bessesurper", "bestsarpe", "bistsurf", "bestsulv", "bestsurtP", "bastsurv", "bessescurper", "bestsurP", "bessescurp", "bestsurv", "bastsulp", "bestsurpit", "bessesurp", "bastsurm", "bestsarp", "bastsulm", "bestsurper", "bistsurpit"], "casenum": ["casen", "Casum", "catum", " casen", "casumer", "ctxeng", "ancumer", " casenary", " casumer", "caten", "sitemia", "sitnum", " casnum", "casum", "ctxenum", "ancum", "ancenum", " casemia", "cashenum", "cashum", "caseng", "catenum", " caseng", "ancenary", "ctxen", "ctxum", "sitenum", "Casnum", "casemia", "casenary", "Casemia", "Casenum", "cashenary", "cashumer", " casum", "casnum", "situm", "cateng"], "line": ["LINE", "log", "section", "l", "reader", "cell", "lines", "page", "byte", "screen", "example", "case", "out", " lines", "unit", "error", "inline", "feed", "comment", "server", "ino", "found", "job", "header", "profile", "source", "raw", "int", "frame", "name", "sync", "day", "buffer", "entry", "file", "block", "cpu", "lined", "str", "match"], "data": ["alpha", "key", "i", "feed", "input", "Data", "shift", "write", "buffer", "file", "list", "fail", "test", "video", "start", "string", "lines", "case", "DATA", "group", "array", "raw", "next", "dat", "ata", "sequence", "series", "record", "items", "output", "a", "code", "number", "done", "end", "text", "missing", "zip", "error", "slice"], "maxsurprising": ["maxcurprises", "maxsimprisingly", " maxsurpiring", "bestcurprise", "bestsurprises", "maxsurprises", "lastsurprisingly", " maxsurprisingly", "maxsimprises", "maxSurprisingly", "maxcurprisingly", "maxSurpiring", "bestsurprise", "bestcurprisingly", "bestcurprising", "maxurprisingly", "maxsurprisingly", " maxSurprises", "lastsurprises", "lastcurprises", "bestsurprising", "maxcurprise", "maxurprises", " maxSurpiring", " maxsurprises", " maxSurprising", "maxurprise", "lastsurprise", "maxsurprise", "bestsurprisingly", "maxurprising", "maxSurprising", "lastcurprising", " maxSurprisingly", "lastsurprising", "maxsurpiring", "maxSurprise", "maxSurprises", "bestcurprises", "lastcurprise"], "p": ["P", "l", "size", "per", "pp", "case", "i", "t", "u", "after", "max", "primary", "n", "lp", "r", "b", "v", "pe", "span", "cp", "python", "it", "np", "jp", "type", "part", "k", "pa", "d", "rank", "m", "power", "x", "pi", "tp", "bp", "point", "pad", "vp", "pc"], "scores": ["oscopes", "oscances", "expores", " scorer", "Scores", " Scorer", "scances", "scopes", "Scors", " scors", " Scors", " Scores", "accatters", "scors", "Score", "oscores", "accores", "oscatters", "expatters", "scorer", "accopes", "expopes", "accances", "Scorer", "scatters", " Score", "expances"], "maxgooglers": ["maxnoogling", "maxmoogles", "maxnoogsgers", "maxgooggling", "maxnoogsling", "maxgooggglers", "maxmoogserers", "maxmoobglers", "maxmoogsglers", "maxgoagling", "maxgoogsblers", "maxgouglers", "maxmoogling", "maxgoogsles", "maxgoogblers", "maxgougerers", "maxgooggerers", "maxmoogsles", "maxmooglers", "maxgougglers", "maxnoogblers", "maxgoogerers", "maxgoogsgers", "maxgoogsriers", "maxmoobles", "maxgoogriers", "maxgoongling", "maxgoogles", "maxmoogsgers", "maxgoogglers", "maxgoobglers", "maxgoobblers", "maxgoaglers", "maxmoogblers", "maxgoongles", "maxmooggers", "maxgooggers", "maxgoogling", "maxnooggers", "maxgouggers"], "s": ["small", "es", "sq", "sec", "server", "i", "src", "set", "ss", "ess", "sw", "sets", "n", "ses", "b", "r", "sf", "su", "span", "slice", "less", "scale", " ss", "scan", "sync", "parser", "pos", "words", "site", "sg", "ores", " self", "str", "search", "its", "os", " S", "rows", "spec", "self"]}}
{"code": " \n  def is_square(n):\n      if n in square:\n          return True\n      if is_fair(n):\n          root = int(math.sqrt(n))\n          if root**2 != n:\n              return False\n          ss = is_fair(root)\n          if ss: square.add(n)\n          return ss\n      return False\n  \n  def is_fair(n):\n      if n in fair:\n          return True\n      if n in unfair:\n          return False\n      sn = str(n)\n      l = len(sn)\n      mid = math.ceil(n/2)\n      if sn[0:mid] == sn[mid::-1]:\n          fair.add(n)\n          return True\n      else:\n          unfair.add(n)\n          return False\n  \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n              \n      fair = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11])\n      unfair = set([12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n      square = set([1, 4])\n  \n      t = int(f.readline())\n      for _t in range(t):\n          s = f.readline()\n          if s:\n              x, y = s.split()\n              Total = sum([is_square(n) for n in range(int(x), int(y)+1)])             \n              print (\"Case #\" + str(_t+1) + \": \" + str(Total))\n      \n  \n", "substitutes": {"n": ["i", "b", "ot", "false", "all", "ne", "init", "int", "ln", "name", "nor", "nr", "nin", "nil", "o", "nb", "nic", "nc", "h", "nn", "L", "c", "g", "nd", "note", "log", "j", "size", "r", "ann", "nw", "np", "m", "ns", "ni", "gn", "an", "no", "cn", "nm"], "root": ["section", "min", "size", "alpha", "null", "random", "error", "rand", "i", "right", "core", "loc", "rew", "src", "r", "node", "eq", "rup", "order", "total", "child", "parent", "rt", "ro", "id", "p", "rank", "seed", "rss", "round", "nr", "inner", "rx", "num", "row", "sr", "length", "rn", "top", "rule"], "ss": ["ssh", "css", "hess", "es", " SS", "sq", "z", "null", " iss", "ros", "ess", "sw", "uss", "sf", "score", "st", "xx", "su", "cross", "ross", "sa", "less", "cs", "wn", "se", "all", "stats", "fts", "ass", "eff", "sv", "struct", "oss", "ds", "ress", "pos", "us", "ww", "rss", "std"], "sn": [" SN", "size", "z", "i", "pn", "sw", "mn", "sf", "inn", "v", "su", "conn", "wn", "sky", "kn", "ne", "ln", "SN", "name", "sv", "sync", "zn", "fl", "nr", "p", "na", "dn", "ns", "sh", "syn", "ni", "gn", "si", "rn", " Sn", "nb", "nc", "nn", "cn", "ls"], "l": ["rl", "le", "lo", "j", "z", "i", "lp", "b", "dl", "left", "lit", "ell", "ln", "k", "low", "li", "fl", "limit", "d", "p", "m", "cl", "la", "lin", "ol", "ls", "vl", "len", "lan", "long", "L", "c", "lc", "ll", "nl", "sl", "lon"], "mid": ["le", "ld", "mm", "middle", "min", "i", "max", "rand", "loc", "mad", "mr", "lim", "ms", "r", "lt", "md", "left", "int", "ln", "level", "part", "low", "li", "aid", "d", "limit", "id", "pos", "m", "ni", "cl", "mi", "val", "Mid", "lat", "lin", "hi", "depth", "no", "nm"], "f": ["fun", "ff", "fore", "df", "i", "feed", "u", "iter", "fi", "b", "v", "fd", "sf", "inf", "r", "input", "fe", "stream", "fen", "fc", "xf", "fb", "handle", "tf", "function", "fl", "d", "fx", "p", "bf", "m", "body", "file", "form", "arf", "fr", "handler", "o", "io", "e"], "fn": ["fun", "ren", "FN", "pn", "loc", "src", "path", "fi", "sf", "fd", "term", "node", "orn", "wl", "full", "conn", "unc", "fil", "fen", "fc", "np", "kn", "wn", "ln", "function", "name", "func", "filename", "fl", "fat", "p", "bf", "file", "dn", "ns", "syn", "gn", "fm", "o", "rn"], "fair": ["address", "rough", "right", "rew", "respect", "bear", "ross", "master", "round", "allow", "field", "ground", "fork", "rust", "approximately", "brown", "over", "owship", "core", "have", "public", "ast", "farm", "cross", "array", "protected", "market", "release", "court", "aster", "wake", "social", "cover", "truth", "shadow", "own", "library", "open", "only", "friend"], "unfair": ["nobavored", "uncore", "unavored", "unmarket", "nobfair", "unbroad", "unnfair", "anfair", "anmatch", "Unaster", "unflower", "unncore", "unaster", "Unmarket", " unavored", "ancore", "unmatch", "uninavored", " unsafe", "anbroad", " unaster", "uninmatch", "uninsafe", "uninbroad", "untmarket", "uninfair", "unincore", " unflower", " unmarket", "Unflower", "nobsafe", "untflower", "uninaster", "Unfair", "unsafe", "unnbroad", "untfair", "unnmatch", "nobaster", "untaster"], "square": ["rough", "clear", "right", "rew", "respect", "bear", "scale", "sky", "company", "system", "rank", "round", "corn", "sh", "cube", "repeat", "owship", "conference", "shape", "qu", "tri", "py", "roll", " squares", "cross", "circle", "array", "time", "court", "angelo", "black", "social", "fresh", "shadow", "sharp", "small", "union", "same", "une", "node"], "t": ["tip", "j", "z", "i", "r", "b", "v", "qt", "ot", "tt", "te", "total", "int", "type", "tf", "tm", "d", "p", "m", "ta", "tz", "tp", "o", "offset", "e", "h", " T", "tower", "pt", "tick", "q", "c", "title", "T", "dt", "at", "w", "g", "ts", "nt"], "_t": ["_v", "_f", "_T", " _T", "_tf", " _test", "_test", " _tf", " _v", " _f"], "s": ["ts", "es", "sq", "lines", "aces", "size", "sys", "new", "i", "u", "out", "sets", "states", "r", "b", "ses", "v", "su", " squares", "ves", "shell", "source", "cs", "se", "stats", "sv", "ds", "us", "d", "p", "m", "your", "sg", "outs", "ns", "south", "str", "ches", "bis", "o"], "x": ["ex", "ip", "z", "key", "i", "u", "case", "dx", "r", "b", "v", "xx", "pe", "data", "xy", "int", "xi", "name", "k", "on", "d", "pos", "p", "id", "m", "ax", "rx", "num", "xt", "line", "o", "ix", "e", "xs", "h", "en", "a", "q", "X", "c"], "y": ["j", "z", "yy", "i", "u", "py", "col", "b", "v", "data", "yi", "type", "name", "k", "d", "id", "p", "vy", "m", "hop", "num", "cy", "o", "ty", "yr", "oy", "ya", "ey", "zy", "e", "ry", "h", "iy", "a", "dy", "yt", "c", "Y", "sy", "w"], "Total": ["Mass", "Price", "Net", "Cost", "Size", "Summary", "Info", "Amount", "Last", "Square", "Token", " total", "Duration", "Bonus", "Rest", "Available", "Scale", "total", "Big", "Max", "Ton", "Diff", "Found", "Ph", "Value", "Complete", "Time", "Percent", "Full", "New", "N", "All", "Avg", "Basic", "Fat", "Sum", "Number", "Average", "Root", "Line"]}}
{"code": " \n  def decode_data(input):\n      output = \"\"\n      for letter in input:\n          if letter in library:\n              output += library[letter]\n      return output\n  \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())    \n      for _t in range(t):\n          s = f.readline()\n          s = s.split()\n          N = int(s[0])\n          S = int(s[1])\n          p = int(s[2])\n          low_scores = (p - 1) * 2\n          ti = s[3:]\n          ti.sort()\n          r = 0\n          ti = [int(x) for x in ti]\n          for i in ti:\n              score = i - low_scores\n              if p <= i:\n                  if score >= p:\n                      r += 1\n                  elif score >= p - 2 and S > 0:\n                      S -= 1\n                      r +=1\n          print (\"Case #\" + str(_t+1) + \": \" + str(r))\n      \n  \n", "substitutes": {"input": ["include", "config", "image", "library", "reader", "text", "format", "address", "feed", "df", "out", "path", "inf", "xml", "data", "wl", "model", "command", "source", "stream", "raw", "interface", "array", "bin", "int", "python", "type", "frame", "child", "document", "current", "buffer", "system", "parent", "file", "form", "language", "argument", "io", "audio"], "output": ["config", "library", "format", "text", "summary", "l", "new", "null", "unit", "out", "final", "Output", "help", "written", "path", "n", "value", "v", "export", "print", "xml", "data", "model", "python", "true", "style", "all", "type", "ln", "write", "function", "name", "default", "filename", "document", "current", "dict", "d", "file", "binary"], "letter": ["format", "address", "text", "external", "knife", "v", "null", "unit", "key", "character", "letters", "print", "term", "lace", "family", "wl", "object", "void", "model", "source", "style", "cycle", "data", "element", "item", "type", "function", "name", "elta", "parent", "fat", "phase", "entry", "file", "pipe", "handler", "digit", "event", "service", "language"], "f": ["l", "z", "folder", "rf", "df", "u", "feed", "sf", "b", "v", "fd", "fi", "n", "inf", "full", "fast", "fe", "fen", "fc", "fb", "tf", "function", "fl", "d", "bf", "m", "file", "form", "handler", "fr", "o", "io", "proc", "e", "self", "lf", "h", "y", "fw", "af"], "fn": ["fun", "library", "format", "FN", "ren", "loc", "path", "sf", "fi", "n", "fd", "wl", "full", "python", "source", "txt", "fil", "fen", "fc", "bin", "kn", "fb", "wn", "tf", "function", "name", "ln", "func", "filename", "fl", "document", "fat", "bf", "file", "dn", "binary", "syn", "fm", "o", "rn"], "t": ["l", "tc", "j", "z", "size", "u", "n", "count", "v", "ot", "tt", "tu", "int", "type", "tf", "tm", "wt", "d", "pos", "m", "time", "tz", "tp", "ta", "ty", "o", "length", "tn", "e", "h", "y", "start", "tick", "pt", "c", "T", "dt", "at", "ts", "nt"], "_t": ["_task", "_T", " _T", " _l", "_token", "_tp", "_ts", " _token", "_l"], "s": ["l", "b", "us", "bis", "o", "comments", "xs", "y", "string", "c", "g", "sb", "strings", "online", "si", "lines", "sets", "ses", "sf", "js", "sync", "words", "qs", "m", "bs", "tips", "ns", "settings", "details", "its", "os", "ops", "sis", "spec", "ls", "items", "a", "w", "gs", "es"], "N": ["Q", "P", "z", "Z", "size", "H", "I", "n", "span", "M", "A", "NT", "NR", "ns", "G", "ni", "num", "U", "o", " n", "nb", "Ns", "W", "O", "E", "Sn", "C", "L", "X", "Y", "T", "B", "w", "F", "Num", "R", "nt"], "S": ["P", "Q", "TS", "size", "Z", "Size", "Sc", "ss", "H", "I", "n", "Rs", "Su", "M", "SU", "A", "SN", "SR", "SA", "SY", "site", "Score", "G", "U", "Sa", "SE", "W", "sp", "O", "E", "SC", "OS", "C", "V", "Si", "L", "X", "Y", "T", "B"], "p": ["P", "l", "j", "z", "pp", "per", "case", "u", "pn", "core", "I", "lp", "n", "b", "v", "pr", "pe", "cp", "jp", "np", "k", "d", "pos", "m", "position", "wp", "po", "pi", "tp", "bp", "o", "length", "rep", "pc", "ap", "e", "ps", "sp", "h", "y"], "low_scores": ["low_Scales", "low_Scores", "low_encores", "low_scorer", "low_encors", "low_SCors", "low_SCales", "low_compares", "low_corer", "low_sumores", "low_encales", "low_sumales", "low_compors", "low_encares", "low_scales", "low_compores", "low_SCares", "low_compales", "low_scors", "low_cales", "low_sumorer", "low_cores", "low_Scorer", "low_SCores", "low_scares"], "ti": [" vi", "ita", " chi", "fi", "qi", " Ti", " si", "phi", "iri", " Xi", "rt", " li", "ta", "PI", "uti", " di", "ini", " mi", "ci", "wei", "si", "tip", "tri", "eni", "ri", "isi", "xi", "bi", "edi", "ni", "tta", "TI", "Ni", "mini", " tri", " Ni", "gi", "sd", "nu", "nt"], "r": ["rl", "P", "l", "ir", "j", "z", "rf", "br", "ur", "rb", "u", " R", "mr", "hr", "right", "rate", "n", "b", "range", "v", "pr", "Rs", "order", "rg", "SR", "k", "nr", "rt", "d", "ro", "re", "m", "rank", "rss", "NR", "lr", "cr", "Rh", "err", "rd"], "x": ["xb", "ex", "l", "j", "z", "u", " X", "dx", "xe", "xxx", "b", "xx", "v", "ux", "data", " y", "xf", "xy", "int", "xi", "xc", "k", "d", "id", "ww", "m", "wx", "na", " xp", "ax", "rx", "pi", "xt", "o", " c", "ix", "e", " xx", "xs", "h"], "i": ["P", "l", "ai", "ip", "ir", "j", "z", "chi", "u", "ri", "I", "n", "b", "v", "qi", "ori", "it", "phi", "int", "xi", "ie", "k", "bi", "li", "d", "id", "m", "iu", "pi", "ni", "mi", "o", "io", "e", "sp", "ice", "h", "y", "a", "ar"], "score": ["ester", "ir", "z", "rice", "case", "error", "core", "pro", "rate", "fit", "value", "pr", "v", "cor", "span", "scale", "np", "ie", "cer", "nr", "ro", "rank", "cr", "Score", "strike", "err", "er", "ni", "num", "match", "race", "sr", "grade", "ate", "ignore", "result", "e", "sp", "zi", "iz"]}}
{"code": " \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      \"\"\" Returns True iff y is within relative or absolute 'epsilon' of x.\n          By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      return [c for c in fd.readline().strip()]\n  \n  def read_ints(fd):\n      return [int(p) for p in fd.readline().strip().split()]\n  \n  def read_floats(fd):\n      return [float(p) for p in fd.readline().strip().split()]\n  \n  class Mtrx(object):\n      \n      def __init__(self, readfunc):\n          self.readfunc = readfunc\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in range(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in range(self.rows)]\n      \n      def readfromfile(self, fd):\n          self.data = []\n          self.rows, self.cols = read_ints(fd)\n          for _ in range(self.rows):\n              line = self.readfunc(fd)\n              assert len(line) == self.cols\n              self.data.extend(line)\n              \n      def __str__(self):\n          res = \"\"\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + \"\n\"\n          return res\n               \n  class IntMatrix(Mtrx):\n      def __init__(self):\n          super(IntMatrix, self).__init__(read_ints)\n  \n  class SymMatrix(Mtrx):\n      def __init__(self):\n          super(IntMatrix, self).__init__(read_syms)\n  \n  class memoizeit(object):\n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          try:\n              return self.cache[args]\n          except KeyError:\n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  class timeit(object):\n      def __init__(self, func):\n          self.func = func\n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          print self.func.__name__, \"{:7.3f}s, (res: {})\".format(delta, value)\n          return value\n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n", "substitutes": {"x": ["l", "ex", "image", "cell", "ip", "wa", "z", "t", "u", "right", "dx", "n", "b", "xx", "v", "pe", "python", "ic", "left", "xy", "int", "xi", "sex", "xc", "pixel", "k", "ch", "on", "d", "fx", "id", "m", "wx", "time", "ay", "ax", "rx", "cy", "xt", "point"], "y": ["l", "lon", "j", "z", "sys", "size", "yy", "t", "py", "yo", "wy", "ady", "n", "b", "xx", "v", "ish", "yi", "isy", "sky", "xy", "ies", "ery", "ch", "ys", "yz", "d", "vy", "m", "ky", "yn", "cy", "my", "ym", "ty", "o", "yr", "ye", "oy", "yd"], "epsilon": ["apsilon", "epilln", "apsilen", "wpsilan", "apillen", "epliton", "epositen", "epiolon", "epill\u00f3n", "epiloni", "epositron", "epsilen", "eprilON", "apsilony", "apsilono", " epcolON", "epsalons", "epositon", "eprilen", "epsilond", " epsiloni", " epcolon", "epilsono", "epilloni", "epsilON", "epeltony", "epsillon", "eposit\u00f3n", "epillolon", "epsilloni", "EPill\u00f3n", "epsalond", "ppsilons", "epeltoni", "ppilond", "epkilly", "epcoloni", " epsilolon", "epssiloni", "epipolon"], "fd": ["ld", "l", "cond", "fore", "feed", "ird", "rb", "path", "xd", "fi", "input", "driver", "stream", "fen", "fc", "handle", "frame", "function", "filename", "file", "handler", "fr", "fin", "lf", "cmd", "fw", "af", "fed", "flow", "fp", "nd", "reader", "df", "bb", "sf", "draft", "fe", "dl", "bf", "wr"], "c": ["co", "l", "arc", "t", "ce", "loc", "input", "b", "fc", "int", "ec", "cl", "ct", "ap", "nc", "h", "g", "fp", "ci", "oc", "m", "csv", "ac", "cn", "a", "code", "w", "cell", "dc", "u", "col", "s", "cp", "uc", "ic", "cs", "vc", "k", "d", "cat"], "p": ["P", "l", "ip", "j", "pm", "pp", "py", "t", "u", "col", "n", "lp", "mp", "v", "cp", "pr", "pe", "op", "b", "hp", "python", "jp", "np", "type", "pb", "part", "ch", "dp", "d", "pos", "pid", "m", "wp", "cat", "pi", "tp", "bp", "vp", "point", "o"], "self": ["co", "l", "pp", "ref", "b", "connection", "static", "driver", "ko", "all", "hand", "struct", "master", "function", "us", "host", "handler", "sh", "other", "field", "cl", "request", "proc", "github", "lf", "h", "like", "ctx", "g", "instance", "reader", "j", "per", "case", "bb", "old", "public", "plugin", "python", "group"], "readfunc": ["readerfunc", "readingfunction", "loadfunc", " readfunction", "Readproc", "readerfun", "writefun", "Readfunc", "Readfun", "readingdoc", "readdoc", " readdoc", "loadproc", "writeFunction", "readerfunction", "writedoc", "loadfunction", "readFunction", "readerFunction", "readfunction", "ReadFunction", "readerproc", "readingfunc", "readfun", "readproc", "loadfun", " readproc", " readfun", "Readfunction", "writefunc", "writefunction"], "r": ["l", "ir", "cell", "j", "u", "rb", "right", "n", "b", "range", "v", "s", "pair", "dr", "array", "rg", "k", "nr", "d", "re", "m", "cr", "entry", "lr", "fr", "err", "er", "ru", "row", "o", "sr", "attr", "e", "h", "ar", "f", "q", "rc", "g", "rs"], "i": ["l", "ai", "cell", "ip", "j", "ij", "z", "chi", "iw", "ib", "u", "t", "ti", "ri", "loc", " ii", " I", "col", "cu", "n", "b", "I", "v", "s", "qi", "ui", "ih", "ic", "yi", "it", "int", "xi", "ie", "bi", "ch", "li", "k", "d", "id", "ei"], "data": ["image", "aa", "config", "reader", "cell", "lines", "size", "alpha", "window", "input", "Data", "model", "groups", "group", "array", "scale", "style", "all", "dat", "frame", "batch", "parts", "memory", "content", "multi", "ata", "grid", "buffer", "bytes", "read", "table", "list", "block", "align", "pad", "response", "devices", "sequence", "actions", "json"], "rows": ["values", "lines", "keys", "features", "ins", "ros", "cats", "heads", "forms", "ks", "reports", "views", "codes", "tracks", "rings", "images", "cs", "relations", "faces", "members", "ats", "ows", "frames", "blocks", "orders", "users", "index", "headers", "fields", "flows", "devices", "row", "cells", "boxes", "length", "ries", "cases", "runs", "types", "posts"], "cols": ["velgs", " coles", "celows", " cold", "Cols", "methods", "cold", "columnb", "coles", "Colts", "Coles", "colds", " colops", "cels", "Colops", "colp", "Colows", "Colb", "velds", "COLs", "Colp", "COLds", "colops", "columnes", "celd", "columns", "colts", "colows", " colows", "Cold", "colb", "columnops", "vels", "colgs", "celp", " colp", "methodgs", " colts", "columnows", "COLgs"], "_": ["j", "ip", "col", " all", "all", " col", "k", " __", " int", "of", "C"], "line": ["LINE", "log", "l", "section", "cel", "cell", "text", "band", "lines", "page", "zip", "inline", "unit", "error", "character", "comment", "loc", "n", "range", "header", "model", "item", "frame", "parse", "sync", "write", "part", "area", "buffer", "pos", "entry", "d", "file", "block", "sel", "cl", "str", "point", "row", "lin"], "res": ["css", "pres", "re", "val", "json", "Results", "vals", "reg", "values", "out", "ras", "mr", "js", "array", " Res", "resp", "ret", "bs", "err", "details", "os", "rem", "R", "es", "br", "changes", "ms", "cons", "cs", "arr", "RES", "response", "row", "rep", "runs", "results", "des", "final", "max", "ros"]}}
{"code": " \n  OEXT = \".out\"\n  IN_S = \"small.in\"\n  IN_L = \"large.in\"\n  CASE_PRFX = \"Case #%s: \"\n  \n  \n  def avg(L):\n      return 1.0*sum(L)/len(L)\n  \n  triplets = [[0,0,0], [0,0,1], [0,1,1], \n              [0,0,2], [0,2,2], [0,1,2],\n              [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],\n              ]\n  \n  def analyze_sum(sm, tgt):\n      av = 1.0 * sm / 3\n      av_cls = av % 1\n  \n      if av_cls > 0.1:\n          ns_max_val = math.ceil(av)\n      else:\n          ns_max_val = av \n      \n      s_max_val = 0 \n      if sm >= 2 and sm <= 28:\n          if av_cls > 0.5:\n              s_max_val = math.ceil(av) + 1\n          elif av_cls > 0.1:\n              s_max_val = math.ceil(av) \n          else:\n              s_max_val = av + 1\n      \n      if ns_max_val >= tgt:\n          res = [ns_max_val, None]\n          kind = 1\n      elif s_max_val < tgt:\n          res = [None, None]\n          kind = 0\n      else:\n          res = [None, s_max_val]\n          kind = 2\n          \n      print sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind\n      return res, kind\n  \n  def analyze_triplet(trip, tgt):\n      sm = sum(trip)\n      analyze_triplet(sm, tgt)\n      \n  \n  def read_input(filename):\n      data = []\n      with open(filename, \"r\") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              case = f.readline().strip().split()\n              case = [int(c) for c in case]\n              data.append({\"ngoog\": case[0], \"ssurp\": case[1], \"ptgt\": case[2],\n                           \"trips\": case[3:]})\n      return data\n  \n  def make_output(fname, output):\n      fname = fname + OEXT\n      with open(fname, \"w\") as f:\n          restext = []\n          for i, v in enumerate(output):\n              restext.append(CASE_PRFX % (i+1,) + str(v) + \"\n\")\n          f.writelines(restext)\n      \n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          ansys = [analyze_sum(c, case[\"ptgt\"]) for c in case[\"trips\"]]\n          non_surp_is_enough = len([k for _, k in ansys if k == 1])\n          surp_needed = len([k for _, k in ansys if k == 2])\n          if surp_needed >= case[\"ssurp\"]:\n              res = non_surp_is_enough + case[\"ssurp\"]\n          else:\n              res = non_surp_is_enough + surp_needed\n          output.append(res)\n      print \"output:\", output\n      make_output(fname, output)\n       \n  \n  main(\"examples.in\")\n  main(\"small.in\")\n", "substitutes": {"OEXT": ["UINFO", "MOEXT", "Hext", "HINTER", "UEXT", "MOext", "MOINTER", "HINFO", "HEXT", "OINFO", "OINTER", "MOINFO", "Uext", "UINTER", "Oext"], "IN_S": ["In_N", "IN_SU", "In_S", "In_SI", "IN_SI", "IN_N", "In_SU"], "IN_L": ["OutJECTG", "INJECTLI", "IN2L", "IN2CL", "IN2G", "Out_G", "IN_G", "IN2LI", "IN_CL", "Out_LI", "INJECTL", "INJECTG", "OutJECTLI", "OutJECTCL", "INJECTCL", "IN_LI", "OutJECTL", "Out_L", "Out_CL"], "CASE_PRFX": ["CASE_RELOPS", "CASE_POUN", "CASE_PROOPS", "CASE_PROUN", "CASE_POOP", "CASESPROUN", "CASESPROPS", "CASE_PROINT", "CASESPRINT", "CASE_RELINT", "CASE_POOPS", "CASE_PRINT", "CASE_PRUN", "CASESPROOPS", "CASESPROINT", "CASE_PROOP", "CASESPRUN", "CASE_PROP", "CASESPROP", "CASE_RELOP", "CASE_RELUN", "CASE_PROPS", "CASESPROOP", "CASE_POINT"], "L": ["P", "l", "Q", "LO", "LC", "SM", "D", "LA", "H", "M", "LB", "XL", "UL", "IL", "BL", "DL", "LE", "VL", "Sl", "LL", "NL", "Li", "SSL", "G", "N", "LU", "LV", "LG", "LOC", "dL", "W", "O", "LR", "SL", "E", "TL", "LM", "C", "ML", "S"], "triplets": ["Triplets", "triples", " triples", "traples", "triplet", "Triples", "traplets", " trips", "traps", "trips", "Triplet", "traplet", " triplet", "Trips"], "sm": ["mm", "amp", "sea", "lim", "am", "nav", "em", "sa", "area", "mass", "nom", "serv", "sh", "ym", "service", "ism", "imm", "LM", "bm", "sb", "spe", "si", "scl", "mn", "im", "sf", "pm", "vm", "sav", "m", "ns", "iam", "sp", "nm", "sur", "sd", "mem", "small", "api", "sw"], "tgt": ["atft", "Tgd", "rtgt", "reticket", "tht", "tgz", "Tgt", "ptgt", "tgd", "rummy", "atnt", " tgz", " tgd", "rtlt", "retgd", " ticket", "utft", "utgat", "untnt", " tft", "tummy", "atgd", "Tgz", "atgt", "untgz", "retnt", "Tht", "rnt", "tnt", "retgt", "atummy", "Tft", "atgh", "untgt", "tgh", "tft", "ticket", " tht", " tlt", "sgz"], "av": ["mm", "alpha", "auth", "lim", "am", "au", "nav", "Av", "aim", "all", "aw", "area", "round", "avia", "allow", "other", "nas", "attr", "ap", "af", "over", "aval", "initial", "avi", "raft", "aa", "image", "wa", "ab", "r", "ann", "true", "array", "sav", "aps", "average", "ra", "m", "ns", "abs"], "av_cls": ["av_pathains", "av_Clains", "av_sls", "av_CLs", "av_CLls", "av_velin", "av_Clb", "av_fls", "avaccls", "av_pli", "av_Clgs", "av_clusters", "av_CLc", "av_claims", "av_clgs", "av_clabs", "av_clin", "av_plains", "av_CLi", "av_pls", "av_pathgs", "av_glb", "av_cli", "av_Cli", "av_clos", "av_gls", "av_selos", "av_flos", "av_velusters", "av_clains", "av_clls", "av_pathi", "av_vels", "av_selgs", "av_claimid", "av_claimabs", "av_Clid", "av_CLid", "avacclusters", "av_Clabs"], "ns_max_val": ["ns_max_max", "ns_maxMlib", "ns_min_Val", "ns_maxgmax", "ns_maxMvals", "ns_max_Val", "ns_max_vol", "ns_maxMval", "ns_maxpVal", "ns_maxpvalue", "ns_maxgval", "ns_min_val", "ns_min_max", "ns_min_len", "ns_maxMVal", "ns_maxpval", "ns_min_vals", "ns_min_vol", "ns_max_lib", "ns_maxplen", "ns_max_len", "ns_maxgVal", "ns_min_lib", "ns_max_vals", "ns_maxgvals", "ns_max_value"], "s_max_val": ["s_maxxVal", "s_max_eval", "s_maxqpol", "s_max__val", "s_max64label", "s_max2eval", "s_min_val", "s_maxglabel", "s_maxgval", "s_maxpval", "s_max_valid", "s_min_label", "s_min_max", "s_maxxval", "s_maxqVal", "s_max64val", "s_max_grad", "s_max_max", "s_maxgvalid", "s_max67grad", "s_max67vals", "s_min_Val", "s_maxqmax", "s_min_vals", "s_max2Val", "s_min_valid", "s_maxxpol", "s_maxpvalue", "s_max_len", "s_max_vals", "s_max2val", "s_max_label", "s_max67Val", "s_max_value", "s_max67val", "s_min_grad", "s_max64valid", "s_max2vals", "s_max__Val", "s_max2all"], "res": ["progress", "rest", "right", "pres", "id", "re", "rx", "mid", "val", "rus", "like", "risk", "resh", "params", "rr", "rap", "reg", "obj", "ras", "mr", "r", "raw", "ra", "resp", "ret", "err", "details", "os", "spec", "series", "resources", "act", "error", "ms", "req", "s", "arr", "part", "work", "RES"], "kind": ["desc", "rest", "right", "kick", "init", "name", "good", "id", "rank", "mid", "Kind", "cmd", "start", "like", "risk", "kid", "char", " kinds", "nd", "shape", "obj", "misc", "meaning", "needs", "inner", "err", "need", "spec", "just", "no", "act", "year", "patch", "end", "error", "gh", "style", "what", "part", "d"], "trip": ["strip", "address", "shape", "ip", "tri", "zip", "move", "roll", "sup", "path", "mp", "nav", "slice", "rup", "trial", "source", "shift", "ship", "acc", "dot", "app", "sim", "speed", "serv", "wp", "track", "hop", "stack", "service", "match", "map", "ticket", "rape", "ap", "skip", "gp", "sp", "route", "rip", "travel"], "filename": ["rl", "summary", "save", "knife", "folder", "database", "jl", "figure", "loc", "path", "url", "stem", "wb", "mph", "Filename", "slice", "dll", "profile", "fil", "begin", "uri", "kn", "name", "phrase", "document", "bf", "location", "file", "binary", "tif", "nil", "FILE", "prefix", "mil", "download", "approximately", "il", "which", "script", "wav"], "data": ["config", "reader", "text", "lines", "database", "api", "sea", "input", "paper", "Data", "DATA", "trial", "shift", "picture", "array", "group", "model", "stuff", "dat", "default", "batch", "memory", "content", "arr", "part", "dict", "breaks", "area", "p", "li", "list", "table", "response", "json", "pad", "line", "map", "info", "space", "media"], "cases": ["config", "Case", "shape", "section", "values", "lines", "features", "children", "clips", "sections", "cats", "changes", "path", "shows", "count", "locks", "cd", "codes", "cs", "tests", "limits", "breaks", "events", "blocks", "words", "tips", "chains", "fields", "ches", "cl", "times", "boxes", "steps", "cells", "length", "runs", "rows", "types", "rooms", "ases"], "_": ["j", " b", "n", " num", "b", "all", "p", "m", "x", " j", " n", "of", "non", "f", "C", " x", "g"], "case": ["tc", "key", "sea", "ce", "character", "rest", "loc", "path", "chain", "shift", "ase", "all", "int", "name", "definition", "ace", "id", "cl", "line", "ct", "test", "edge", "switch", "g", "instance", "ride", "section", "add", "shape", "anch", "size", "item", "choice", "time", "client", "fold", "ed", "ice", "record", "code"], "c": [" code", "co", "l", "tc", "dc", " cursor", "sea", "cc", "ce", "character", "col", "cu", "n", "r", "cd", "b", "abc", "uc", "type", " bc", "xc", "ch", " character", "li", "d", "cm", "p", "ace", "m", " cc", "bc", " C", "category", "x", "cy", "cl", "ct", " cycle", "ac", " cd"]}}
{"code": "directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'\n  \n  \n  def is_palindrome (n):\n      l = list(str(n))\n      return list(reversed(l)) == l\n  \n  def prepare ():\n      global fair_and_squares\n      fair_and_squares = []\n      \n      for i in range(1,10**7):\n          if is_palindrome(i):\n              sqr = i**2\n              if is_palindrome(sqr):\n                  fair_and_squares.append(sqr)\n      return\n  \n          \n  def solve (f_in, f_out):\n      prepare()\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          A,B = [int(x) for x in f_in.readline().split()]\n          count = len([x for x in fair_and_squares if (x>=A and x<=B)])\n          f_out.write('Case #' + str(testcase) + ': ' + str(count) + '\n')\n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n", "substitutes": {"directory": ["D", "path", "input", "volume", "connection", "uri", "definition", "filename", "buffer", "file", "category", "service", "language", "download", "tmp", "tree", "c", "location", "root", "office", "third", "relative", "project", "DI", "minute", "python", "picture", "environment", "direct", "storage", "binary", "module", "application", "cache", "drive", "copy", "output", "three", "number", "specified"], "n": ["j", "z", "t", "u", "r", "b", "v", "node", "np", "net", "ne", "ln", "name", "nor", "k", "d", "p", "m", "na", "ns", "list", "ni", "N", "o", "rn", "nb", "e", "names", "nt", "nc", "no", "nn", "cn", "y", "en", "f", "sn", "q", "c", "network"], "l": ["rl", "le", " L", "lo", "j", "lines", "z", "t", "u", "r", "b", "lp", "v", "s", "isl", "wl", "dl", "all", "it", "ln", "function", "li", "al", "ql", "d", "p", "m", "los", "list", "lis", "line", "o", "la", "ol", "e", "lf", "il", "ls", "h", "E"], "fair_and_squares": ["fair_and_sqakes", "fair_and_shires", "fair_and_equares", "fair_and_sqared", "fair_and_qares", "fair_and_shared", "fair_and_qars", "fair_and_squars", "fair_and_shals", "fair_and_Squares", "fair_and_shares", "fair_and_squared", "fair_and_sqires", "fair_and_quares", "fair_and_Squires", "fair_and_sqares", "fair_and_quare", "fair_and_queries", "fair_and_qared", "fair_and_qals", "fair_and_quakes", "fair_and_squals", "fair_and_squakes", "fair_and_square", "fair_and_quals", "fair_and_Squars", "fair_and_Squeries", "fair_and_sqars", "fair_and_shars", "fair_and_equared", "fair_and_Square", "fair_and_squeries", "fair_and_equare", "fair_and_quars", "fair_and_quared", "fair_and_Squared", "fair_and_Squakes", "fair_and_equeries", "fair_and_squires"], "i": ["ai", "ip", "j", "ji", "z", "eni", "ib", "ti", "u", " I", "ri", "t", " ii", "I", "im", "b", "v", "r", "qi", "range", "s", "inf", "ori", "yi", "it", "phi", "int", "xi", "iri", "ie", "k", "li", "ei", "d", "id", "p", "m", "iu", "pi", "io"], "sqr": ["ipprr", " sqnr", "sqrage", "aqrt", "ippnr", "qqrr", "qqrs", "sqrr", "sqrs", "qnr", "aqr", " sqrt", "aqrage", "qqnr", " sqrs", "sqrt", " sqrage", "qqrage", "aqrs", "ippr", "qrs", "qqrt", "qrt", " sqrr", "qrr", "ipprs", "qqr", "qr", "sqnr"], "f_in": [" f_din", "f_bin", " floglogin", "f67isin", " f_login", " flogin", " flogbin", "f_In", "f_IN", "f64inn", " f_rin", "f67out", "firmin", " f_bin", " f_inn", "floginn", "f_win", "f64login", "flogin", "floglogin", "f_din", "f67in", "cf_inn", "f_login", "f67ins", "cf_in", " f_In", " f_win", "firmout", "f_isin", "f_inn", "f64bin", " f_ins", "cf_out", " floginn", " f_inc", "f_rin", "f_ins", "flogbin", "cf_login"], "f_out": ["f_bin", "fwbin", "f_again", "l_Out", "f2out", " f_outer", "f__outs", " f_bin", "fockout", " f_io", "f2Out", "f5outer", "fockin", "f_outer", "f_Out", "f__io", "f5bin", "fockagain", "f_outs", "f5out", " f_again", "fwin", "f__again", " f_Out", "f5in", " f_outs", "l_out", "f2in", "f__in", "fockouts", "f__Out", "l_in", "f_io", "fwout", "f__out", "fwouter"], "T": ["Q", "P", "DT", "TS", "size", "Z", "D", "TH", "t", "H", "I", "M", "NT", "duration", "Test", "type", "WT", "Time", "time", "G", "U", "N", "TN", "length", "W", "O", "Total", "E", "C", "Length", "S", "V", "L", "X", "number", "TT", "Y", "Count", "CT", "F"], "testcase": [" testtrial", "Testtest", "trainCase", "testcases", "xtest", "xCase", "traincases", " testcases", "testCase", " testtest", "TestCase", "xcase", "testtrial", " testCase", "Testtrial", "xtrial", "testtest", "traincase", "Testcase", "Testcases", "traintest"], "A": ["P", "Case", "Ca", "API", "Na", "As", "D", "AU", "AA", "Ma", "LA", "From", "H", "I", "au", "M", "GA", "NA", "Ab", "Am", "Alpha", "HA", "SA", "Ha", "G", "U", "N", "AW", "Sa", "At", "W", "Ar", "O", "CA", "E", "Ra", "a", "C", "S", "V"], "B": ["AR", "Q", "P", "WB", "Ub", "QB", "D", "AA", "LA", "UB", "AB", "I", "b", "BF", "LB", "M", "BU", "Ab", "SB", "BL", "Bs", "G", "U", "N", "BER", "BR", "BC", "BS", "W", "EB", "O", "AF", "BA", "E", "C", "S", "V", "Bal", "L", "X"], "x": ["exc", "co", "ex", "rax", "key", "t", "path", "xd", "abc", "b", "xx", "int", "sex", "name", "filename", "id", "re", "file", "rx", "cl", "ct", "tx", "mix", "xs", "h", "y", "string", "c", "ctx", "flex", "g", "px", "ci", "hex", "rix", "www", "XX", "image", "qu", "j"], "count": ["text", "size", "key", "case", "col", "b", "loop", "found", "span", "call", "order", "total", "type", "name", "part", "limit", "id", "p", "trace", "time", "list", "num", "N", "match", "race", "length", "age", "info", "offset", "base", "depth", "weight", "counter", "len", "start", "y", "C", "a", "code", "X"], "filenames": ["ilzenamed", "filrenaming", "filennaves", "frenames", "filzenues", "ilzenames", "fENaves", "filenaves", "filernames", "filzennames", "fillename", "ilzenamps", "ilenamps", "filename", "filerennames", "filennames", " filerenues", "fENames", "filennaming", "filennamps", "fillenaming", "filensaming", "filarenodes", "filzenamed", "filennodes", "fENodes", " filennames", "filerenames", " filerennames", "filernaming", "filrenames", "filENames", "fillenames", "fenames", "filarenAMES", "filzenaming", "ilenaming", "filenodes", "filzenodes", "filenAMES"], "l1": ["el1", "L1", "lione", "el4", " lone", "el2", "l91", "L2", "l4", "L91", " l2", " l4", "Lone", "elone", "li1", "L4", "l2", "li91", "li2", " l91", "lone"], "chosen_filename": ["chosing_filename", "chosen_queue", "chosenfqueue", "chosen_token", "chosen_Filename", "choin_selection", "chosenfFilename", "choinfFilename", "chosing_queue", "chosing_size", "choin_Filename", "chosenedname", "choinftoken", "chosen_name", "chosenfsize", "chosing_binary", "chosenftoken", "choin_token", "choin_filename", "chosen_location", "chosen_size", "chosen_binary", "chosenedbinary", "chosenedFilename", "chosenffilename", "choinffilename", "chosenfselection", "chosing_Filename", "chosing_location", "chosing_name", "chosen_selection", "choinfselection", "chosenedfilename"]}}
{"code": "directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'\n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      print ('Test cases : ',T)\n      for i in range(1,T+1):\n          line = f_in.readline()\n          nnn = [int(x) for x in line.split()]\n          S = nnn[1]\n          p = nnn[2]\n          t = nnn[3:]\n          if p > 1:\n              A = 0\n              B = 0\n              for t_i in t:\n                  if t_i >=3*p-2:\n                      A += 1\n                  elif t_i >= 3*p-4:\n                      B += 1\n              result = A + min(B,S)\n          if p == 1:\n              result = len([x for x in t if x>=1])\n          if p == 0:\n              result=  len(t)\n          f_out.write('Case #' + str(i) + ': ' + str(result) + '\n')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n  \n  \n  \n  main_run()\n", "substitutes": {"directory": ["path", "volume", "connection", "theme", "definition", "filename", "system", "category", "service", "language", "y", "tmp", "tree", "c", "location", "root", "office", "third", "reference", "project", "DI", "minute", "python", "picture", "environment", "direct", "storage", "binary", "sequence", "metadata", "module", "application", "drive", "du", "three", "number", "specified", "itory", "square", "library"], "f_in": ["e_in", "f_In", "f_IN", "f_err", " f_ini", "ffinn", "f_ini", "sf_out", "sf_IN", "focknin", "c_out", "fockout", " f_inn", "fockin", "ffinto", "e_ini", " f_inf", "fockins", "e_ins", "f_into", "c_inn", "sf_err", "f_inn", "sf_in", " f_nin", "c_In", "f_nin", " f_into", " f_ins", "c_in", "e_out", "f_inf", "f__ini", "f_ins", "f__in", "ffout", "ffin", "f__ins", "f__out"], "f_out": [" f_run", " f_output", "f_again", "fayin", " f_write", "f_run", "faywrite", " f__again", "fayrun", "f_list", "f_o", " f__out", " f__in", " f_off", " f_o", "f_output", " f_list", "fayout", "fipwrite", "fipout", "f__o", "fipin", " f_again", "f_off", "f__again", "f_writer", " f_writer", "f__out", "f__in", "f_write", "fiprun"], "T": ["P", "Q", "J", "DT", "TS", "Z", "D", "Size", "TH", "H", "I", "n", "IP", "M", "NT", "TE", "Test", "TW", "WT", "Time", "time", "TA", "G", "U", "N", "TN", "TI", "length", "W", "O", "Total", "E", "C", "Length", "V", "L", "X", "TB", "TT", "Y"], "i": ["lo", "ai", "inter", "ip", "j", "z", "chi", "eni", "u", "ti", "ri", "I", "im", "b", "n", "v", "qi", "ui", "trial", "phi", "uri", "it", "int", "xi", "type", "ie", "k", "on", "li", "bi", "d", "id", "iu", "ni", "num", "pi", "di", "o", "io", "ix"], "line": ["LINE", "log", "section", "l", "lo", "cell", "text", "le", "lines", "page", "zip", "inline", "unit", "case", "iter", "error", "comment", "out", "xml", "header", "model", "chain", "source", "stream", "eline", " Line", "ne", "frame", "sync", "li", "entry", "site", "file", "sequence", "block", "lined", "cl", "response", "sel", "row"], "nnn": ["nv", "tunv", "nnv", "ennb", "lnns", "knc", "nnb", "wnn", "nyb", "nyd", "knd", "np", "nnc", "ennn", "knns", "knv", "nnp", "nnd", "nyns", "NNd", "wnb", "wnns", "ennl", "knn", "tunc", "wnl", "nnns", "knl", "knner", "lnb", "nnner", "lnl", "nc", "nn", "tunn", "nnl", "lnner", "tunp", "knb", "lnn"], "x": ["co", "ex", "l", "rax", "key", "path", "xd", "b", "xx", "int", "sex", "name", "filename", "ace", "id", "re", "vent", "file", "rx", "val", "cl", "ct", "tx", "mix", "xs", "h", "y", "string", "c", "flex", "g", "ci", "hex", "rix", "www", "qu", "j", "per", "bl", "case"], "S": ["P", "Q", "TS", "size", "Z", "D", "u", "H", "I", "n", "b", "s", "v", "M", "SB", "SA", "Sp", "G", "U", "N", "Sa", "SE", "W", "sp", "O", "E", "SP", "C", "f", "V", "a", "L", "X", "Si", "Y", "g", "F", "w", "PS", "SS"], "p": ["l", "pp", "b", "pr", "ot", "op", "phi", "int", "tp", "point", "o", "proc", "ap", "h", "y", "pt", "c", "g", "fp", "pa", "j", "case", "r", "lp", "pu", "np", "m", "bp", "sp", "a", "patch", "at", "w", "api", "pn", "u", "I", "mp", "s", "cp"], "t": ["l", "b", "ot", "int", "rt", "table", "ta", "tp", "o", "ct", "h", "y", "start", "c", "g", "ut", "j", "case", "out", "r", "term", "M", "et", "m", "sequence", "sp", "a", "at", "w", "st", "nt", "u", "I", "s", "tt", "trial", "total", "k", "part", "tm"], "A": ["P", "Q", "API", "As", "D", "AU", "AA", "LA", "alpha", "H", "I", "AB", "b", "First", "M", "AM", "Ab", "AP", "SA", "PA", "TA", "G", "U", "N", "At", "W", "O", "AF", "E", "C", "a", "V", "L", "X", "Y", "K", "F", "AC", "R"], "B": ["P", "Q", "J", "WB", "Z", " b", "D", "BT", "Sc", "H", "I", "AB", "b", "s", "M", "LB", "BP", "Ab", "SB", "PB", "NB", "Sp", "Bs", "G", "U", "N", "BB", "W", " P", "O", "BA", "E", "Part", "C", "V", "L", "X", "TB", "Y", "K"], "t_i": ["t__iu", "T_p", "p_I", "T_j", "t_j", "T_i", "t__j", "t0c", "T_iu", "t__i", "t0i", "t_p", "p_p", "t0p", "t_iu", "p_c", "t0I", "t_c", "t_ini", "p_i", "T_ini", "t_I", "t__p"], "result": ["P", "format", "answer", "summary", "text", "new", "page", "RESULTS", "rf", "case", "final", "error", " Result", "valid", "df", "r", "count", "value", "su", "term", "data", "duration", "array", "order", "Test", "total", "type", "default", "function", "warning", "dict", "ret", "err", "success", "sequence", "successful", "val", "res", "response", "match"], "filenames": ["fillenetimes", "filrenaming", "filenname", "filernames", "fillename", "filternnames", "filename", "filenename", "filennames", "filagenetimes", "filenetimes", "filensumbers", "filrenumbers", "ilernumbers", "filensaming", "fillenaming", "finenname", "finennums", "sitenename", "filsennames", "filagenaming", "ilenumbers", "filernamer", "finenncodes", "filernaming", "filrenames", "siternnames", "ilernames", "fillenames", "ilername", "filbenames", "finenums", "finenames", "siternames", "sitenames", "ilenaming", " filagenetimes", "filbenums", "filenums", "filbencodes"], "l1": ["ll1", "L1", "ll3", "lione", "ll2", "lc1", "lcone", "L2", " l01", "L01", " l2", "li11", "Lone", "l3", "L11", "li1", "lc2", "l11", "L3", " l3", "l2", "lc11", "ll01", "li2", "l01", "lone"], "chosen_filename": ["chosing_queue", "chosed_username", "chosen_url", "chosen_location", "chained_Filename", "chosing_Filename", "chosen_file", "chosing_location", "chosenPlocation", "chosen_lane", "chosed_filename", "chosen_queue", "choseningusername", "chosen_Filename", "chained_lane", "choseningqueue", "chosen24filename", "chosing_url", "chosen24file", "chosing_filename", "choseninglocation", "chosen_name", "chosen24Filename", "chosenPurl", "chosenPFilename", "choseningFilename", "chained_file", "chained_filename", "chosenPfilename", "choseningurl", "chosed_name", "chosen24lane", "chosen_username", "choseningfilename", "chosing_username"]}}
{"code": " \n  def isPalindrome(n) :\n      return str(n) == str(n)[::-1]\n  \n  def findPalindrome(n) :\n      if n % 2 == 0 : return [start*(10**(n/2)) + int(str(start)[::-1]) for start in range(10**(n/2-1),10**(n/2))]\n      if n == 1 : return range(1,10)\n      return [start*(10**(n/2)) + int(str(start)[:-1][::-1]) for start in range(10**(n/2),10**((n+1)/2))]\n  \n  def findPalindromeInRange(a, b) :\n      num = range(len(str(a)), len(str(b)) + 1)\n      allPalindrome = []\n      for n in num : allPalindrome += findPalindrome(n)\n      return filter(lambda x : a <= x <= b, allPalindrome)\n  \n  f = open('C-small-attempt0.in', 'r')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in range(T) :\n      A, B = map(int, f.readline()[:-1].split())\n      a = int(math.ceil(A**0.5))\n      b = int(B**0.5)\n      res = len(filter(lambda x : isPalindrome(x**2), findPalindromeInRange(a, b)))\n      outString = 'Case #' + str(case+1) + ': ' + str(res) + '\n'\n      print outString[:-1]\n      g.write(outString)\n  \n  f.close()\n  g.close()\n", "substitutes": {"n": ["l", "t", "i", "all", "ne", "int", "zn", "name", "nor", "don", "o", "nb", "nc", "h", "nn", "y", "c", "nd", "j", "min", "size", "out", "mn", "r", "nw", "np", "m", "inner", "ns", "x", "ni", "an", "no", "cn", "nm", "en", "number", "network", "w", "ng"], "start": ["art", "key", "inf", "shift", "scale", "int", "init", "name", "focus", "id", "seed", "host", "mid", "grade", "offset", "y", "like", "stop", "first", "root", "add", "min", "size", "iter", "set", "data", "next", "begin", "origin", "limit", "fill", "time", "inner", "x", "join", "no", "starting", "use", "st", "date"], "a": ["aa", "ai", "l", "wa", "Na", "sta", "ab", "ama", "alpha", "art", "i", "u", "va", "ada", "am", "oa", "r", "ba", "s", "au", "aka", "sa", "asa", "ao", "k", "aw", "ga", "area", "ae", "p", "d", "m", "na", "ana", "ax", "x", "o", "ac", "up", "da"], "b": ["l", "abb", "i", "rb", "amb", "other", "o", "BB", "nb", "h", "y", "c", "bas", "sb", "aa", "j", "ab", "bl", "py", "bb", "r", "bi", "bad", "bf", "m", "bc", "bs", "x", "bp", "lb", "base", "cb", "number", "w", "beta", "br", "u", "s", "db", "fb"], "num": ["text", "new", "unit", "max", "loc", "run", "mn", "range", "count", "node", "dim", "umer", "NUM", "coord", "param", "begin", "bin", "np", "name", "gen", "cal", "nr", "pos", "id", "um", "nom", "m", "uni", "umber", "orig", "block", "N", " Num", "mat", " number", "gram", "nb", "nam", "result", "nt"], "allPalindrome": ["allEllindome", "allEllindrome", "allPhilinduster", "allPalintome", "allPalandrom", "allpalindome", "allPalindroma", "allPalandchrome", "allPalendome", "allPalintroma", "allPhilindchrome", "allEllintome", "allPalintrome", "allPalintchrome", "allPalintrom", "allPalinduster", "allPalanduster", "allPalindchrome", "allpalindrom", "allpalinduster", "allPhilintchrome", "allEllintroma", "allPhilintrome", "allPalindome", "allpalindrome", "allEllindrom", "allpalidrome", "allEllintrom", "allPalindrom", "allPalidome", "allpalidome", "allPalendrome", "allPalenduster", "allPhilindrome", "allPalidrom", "allpalidrom", "allPalidchrome", "allEllintrome", "allPalidrome", "allPalandrome"], "f": ["log", "l", "fun", "ff", "j", "uf", "fore", "z", "rf", "t", "df", "feed", "iter", "i", "u", "out", "fi", "r", "s", "found", "fd", "inf", "loop", "v", "full", "fast", "fe", "fen", "xf", "fc", "fb", "tf", "fl", "fat", "d", "fx", "p", "bf", "m", "file"], "g": ["log", "l", "eg", "j", "game", "t", "u", "out", "i", "gh", "vg", "r", "ge", "v", "s", "msg", "fe", "group", "gen", "k", "ga", "d", "p", "m", "gd", "file", "go", "err", "G", "x", "gu", "o", "io", "ig", "e", "og", "self", "gp", "h", "cfg"], "T": ["P", "Q", "J", "Case", "DT", "TS", "Z", "D", "Size", "TH", "t", "GT", "H", "I", "OT", "TR", "M", "Len", "NT", "type", "TC", "Ts", "TW", "Time", "G", "U", "N", "TN", "W", "O", "Total", "TB", "E", "C", "Length", "S", "V", "L", "X", "PT"], "case": ["exc", "section", "Case", "text", "size", "ASE", "example", "key", "max", "error", "t", "out", "rice", "ce", "count", "rial", "me", "pe", "data", "call", "trial", "pair", "slice", "change", "ase", "expression", "type", "choice", "name", "ace", "p", "file", "time", "position", "nce", "ion", "sequence", "match", "race", "length"], "A": ["P", "El", "Ca", "API", "Na", "D", "alpha", "AA", "Ma", "LA", "From", "Code", "OA", "H", "I", "Ax", "au", "Data", "M", "NA", "GA", "Len", "AP", "Am", "Alpha", "HA", "SA", "G", "U", "N", "Sa", "All", "And", "O", "CA", "Ra", "C", "S", "Wa", "L"], "B": ["P", "WB", "API", "QB", "DB", "D", "GB", "IB", "Beta", "AB", "Other", "BF", "LB", "Ab", "SB", "Big", "NB", "BBC", "G", "U", "N", "BER", "BB", "CB", "BR", "BC", "BG", "BE", "BS", "W", "EB", "BA", "E", "C", "MB", "Two", "Bal", "L", "X", "Bi"], "res": ["rex", "exc", "reg", "es", "sol", "RE", "ins", "out", "ras", "ris", "rest", "nos", "error", "mr", "ms", "pres", "Rs", "r", "req", "range", "cs", "ids", "tests", "ES", " Res", "errors", "arr", "Response", "ress", "re", "resp", "MS", "RES", "ret", "ns", "err", "details", "block", "ches", "response"], "outString": ["OutputLine", "againSite", " outFile", "outputStr", "outputArray", "outputFile", "resultFile", "plainLine", "OutputText", "outputString", "outLine", " outStr", "OutText", "OutSite", "plainStr", "outFile", "againLine", "OutArray", "againStr", "againString", "resultStr", "outText", "OutLine", "OutString", "outArray", " outText", "OutputString", "outStr", "plainSite", " outLine", "plainString", " outArray", "outSite", "OutputArray", "resultString", "OutStr", "resultArray"]}}
{"code": "fin = open('B-small-attempt0.in', 'r')\n  fout = open('B-output.txt', 'w')\n  \n  cases = int(fin.readline()[:-1])\n  \n  for case in range(cases) :\n      line = map(int, fin.readline()[:-1].split(' '))\n      N, S, p = line[:3]\n      T = line[3:]\n      okLimit = p + 2*max(p-1,0)\n      okIfSLimit = p + 2*max(p-2,0)\n      ok = len(filter(lambda x : x >= okLimit, T))\n      okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))\n      res = ok + min(okIfS, S)\n      fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')\n      \n  fin.close()\n  fout.close()\n", "substitutes": {"fin": ["fun", "cook", "progress", "prem", "fit", "fi", "pen", "fen", "init", "ln", "rt", "file", "fr", "ran", "fail", "proc", "fork", "rip", "tick", "start", "nir", "inv", "fp", "ini", "kin", "iter", "hr", "wire", "han", "inn", "inner", "err", "details", "spec", "en", "Fin", "fine", "fa", "end", "nu"], "fout": ["FOut", "fouter", " ffile", "dfouter", "afinner", " fw", "pin", "pfile", " fio", "fio", "pw", "ww", "fOut", "afouter", "wout", " fouter", "wfile", "win", "ffile", "wOut", "pout", " finner", "afio", "Fout", "finner", "Fin", "fw", "dfout", "Fw", "dfinner", "afout", "dfio", " fOut"], "cases": ["Case", "es", "features", "lines", "jobs", " Cases", "sections", "sets", "changes", "shows", "codes", "cs", "ids", "tests", "breaks", "events", "blocks", " tests", "works", "tips", "chains", "charges", "settings", "ches", "times", "its", "steps", "cells", "comments", "runs", "types", "rows", "rooms", "checks", "Times", "ases", "xs", "offs", "items", "testing"], "case": [" code", "nice", "Case", " trial", "address", "section", "ASE", "ise", " position", "rice", "example", "ce", "count", "pe", "uc", " count", "pair", "slice", "trial", "cycle", "ase", "choice", "li", "ace", "id", "ose", "position", "time", "nce", "sequence", "match", "race", "client", "fold", "test", "bug", "ice", "USE", "C", " match"], "line": ["LINE", "strip", "section", "l", "le", "cell", "ip", "lo", "lines", "page", "zip", "inline", "unit", " lines", "loc", "col", "s", "pe", "slice", "trial", "chain", "group", " Line", "item", "se", "ne", "type", "frame", "parse", "sync", "part", "day", "li", "pos", "phase", "entry", "file", "none", "list", "block"], "N": ["P", "Q", "J", "z", "Z", "D", "Size", "size", "n", "I", "M", "A", "NT", "init", "G", "U", "num", " n", "nb", "Ns", "O", "E", "NS", "y", "C", "V", "L", "X", "c", "Y", "K", "B", "F", "Num", "R", "nt"], "S": ["P", "Q", "J", "TS", "size", "Z", "D", "Size", "ss", "n", "I", "Rs", "s", "M", "A", "MS", "Sl", "RES", "G", "U", " s", "SE", "os", "Res", "Ns", "W", "ps", "sp", "O", "YES", "US", "E", "SC", "C", "sc", "V", "Si", "L", "X", "Y"], "p": ["P", "l", "ip", "j", "z", "pp", "pl", "t", "i", "max", "u", "n", "r", "b", "s", "cp", "pe", "v", "lp", "phi", "np", "int", "type", "k", "d", "pos", "m", "position", "pot", "x", "pi", "tp", "point", "bp", "o", "pc", "e", "ps", " P", "sp"], "T": ["P", "Q", "Case", "DT", "TS", "z", "Z", "D", "Ti", "t", "TP", "H", "I", "n", "s", "IP", "XT", "TX", "M", "A", "NT", "Test", "TW", "WT", "Time", "G", "x", "U", "TN", "W", " P", "Tx", "O", "E", "C", "V", "L", "X", "PT", "TT"], "okLimit": ["pLim", "OKLim", "joblimit", "caseLim", "jobLim", "okSize", "maxLim", "maxPosition", "checkLim", "jobSize", "checkLimit", "maxlimit", "checkPosition", "plimit", "checklimit", "okPosition", "caseLoop", "oklimit", "xLimit", "okLoop", "OKLimit", "checkSize", "pPosition", "caseLimit", "jobLimit", "xSize", "akLimit", "maxLimit", "okLim", "xlimit", "OKLoop", "akLim", "akLoop", "xLim", "pLimit"], "okIfSLimit": ["okIfSLimsiter", "okIfSLumit", "okIfSLimsIT", "okIfSlIMits", "okIfSLIMited", "okIfSLIMat", "okIfSLimited", "okIfSlimits", "okIfSLIMiter", "okIfSLumIT", "okIfSLimsat", "okIfSlIMiter", "okIfSlimiter", "okIfSLinit", "okIfSLumited", "okIfSLimits", "okIfSLimiter", "okIfSLumits", "okIfSlimited", "okIfSlimIT", "okIfSLIMit", "okIfSlimit", "okIfSLimat", "okIfSlimat", "okIfSLrimIT", "okIfSLinits", "okIfSLimIT", "okIfSLimsit", "okIfSLrimit", "okIfSLIMits", "okIfSlIMit", "okIfSlIMat", "okIfSLIMIT", "okIfSlIMIT", "okIfSLinIT", "okIfSLrimat", "okIfSLinited", "okIfSlIMited", "okIfSLrimiter"], "ok": ["ak", "size", "ise", "max", "oc", "oko", "error", "nos", "oa", "n", "s", "job", "op", "ori", "ase", "Ok", "ko", "ack", "sync", "k", "good", "ro", "id", "ax", "x", "ick", "success", "OK", "yes", "o", "clean", "auto", "length", "fail", "oks", "info", "os", "ol", "poly", "pick"], "okIfS": ["errorIFS", "errorIfR", "okifS", "okUnlessS", "okUnlessP", "okIFS", "OkIfP", "errorIfS", "okIfSU", "OkIfS", "okifSU", "okUnlessR", "okIfSi", "okIfA", "errorIfP", "okUnlessSU", "okIfP", "OkIfA", "okIFA", "errorIFSU", "okIFSi", "errorIFP", "errorIfSU", "okifSi", "okIFR", "OkIfSi", "okifA", "okIFSU", "errorIFR", "okIfR", "okifR", "okIFP", "okifP"], "res": ["exp", "reg", "es", "features", "min", "rise", "RE", "ras", "cas", "ris", "nos", "right", "rest", "ms", "rate", "pres", "Rs", "r", "s", "cs", "rez", " Res", "arr", "ress", "us", "re", "resp", "rss", "RES", "ret", "err", "details", "clean", "ores", "response", "rx", "win", "rev", "Res", "rel"]}}
{"code": " \n  \n  def palindromes():\n      for digits in count(1):\n          for n in xrange(10**(digits-1), 10**digits):\n              n = str(n)\n              yield int(n + n[-2::-1])\n          for n in xrange(10**(digits-1), 10**digits):\n              n = str(n)\n              yield int(n + n[::-1])\n  \n  def is_palindrome(n):\n      n = str(n)\n      return n == n[::-1]\n  \n  def solve(A, B):\n      count = 0\n      for n in palindromes():\n          square = n**2\n          if square > B:\n              break\n          if square >= A and is_palindrome(square):\n              count += 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n  \n              A, B = map(int,fin.readline().split())\n              soln = solve(A, B)\n  \n              print >> fout, \"Case #{0}: {1}\".format(case, soln)\n", "substitutes": {"digits": ["digals", "splals", "bigits", "signbits", "signins", "Digins", "dites", "multiplits", "logures", "digifiers", "multiplins", "splits", "bigests", "dit", "logits", " digbits", "multiplifiers", "bigins", "dings", "purits", "splbits", " digites", "Digures", "digests", "logings", "decites", "multiplbits", "decins", "logins", "purbits", "digings", "Digits", "digit", "dures", " digit", " digals", "dits", "digures", " digings", " digins"], "n": ["l", "t", "i", "b", "all", "ne", "int", "init", "ln", "zn", "name", " N", "o", "nb", "nc", "nn", "h", "y", "c", "g", "nd", "note", "adj", "j", "min", "size", "out", "r", "nw", "circle", "np", "m", "inner", "ns", "x", "ni", "gn", "an", "no", "cn"], "A": ["Ac", "API", "D", "alpha", "i", "abc", "au", "GA", "Bu", "function", "SA", "aw", "AS", "TA", "Math", "One", "BA", "L", "Y", "AY", "DA", "H", "AB", "M", "NA", "array", "Am", "ABC", "App", "U", "AW", "AD", "AI", "ac", "da", "W", "Ar", "O", "CA", "E"], "B": ["Q", "J", "D", " b", "UB", "b", "RB", "LB", "VB", "Bs", "BER", "BB", "EB", "BA", "L", "Y", "BY", "WB", "QB", "DB", "AB", "H", "M", "PB", "BL", "U", "BC", "W", "O", "E", "MB", "V", "X", "number", "OB", "R", "Z", "Bur", "I", "BF"], "count": ["cond", "key", "seq", "b", "all", "int", "name", "id", "file", "list", "val", "line", "counter", "start", "string", "c", "Count", "est", "log", "add", "lines", "size", "core", "array", "order", "cycle", "race", "fold", "base", "cache", "code", "number", "index", "nt", "text", "error", "col", "only", "found", "call"], "square": ["co", "clear", "screen", "right", "qq", "scale", "sky", "pixel", "area", "round", "corn", "sh", "cube", "chip", "edge", "c", "char", "repeat", "console", "feature", "image", "qu", "shape", "double", "size", "roll", " squares", "cross", "circle", "array", "se", "angle", "fill", "arrow", "black", "copy", "shadow", "number", "ape", "bar"], "T": ["P", "Q", "Case", "TS", "Z", "D", "Size", "TH", "t", "H", "I", "TR", "M", "trial", "NT", "Test", "TC", "WT", "Time", "trace", "time", "TA", "G", " t", "U", "N", "TN", "W", "O", "Total", "E", "C", "Length", "S", "V", "L", "X", "TT", "Y", "Count"], "case": ["step", "section", "Case", "address", "shape", "ASE", "size", "sea", "rice", "ce", "mode", "loc", "one", "loop", "pe", "call", "pair", "trial", "chain", "ase", "se", "choice", "type", "name", "back", "ace", "id", "p", "phase", "time", "position", "nce", "x", "match", "line", "race", "length", "cases", "bug", "ice"], "soln": ["Soln", "sol", " ssol", "Ssol", "solen", " sol", "foln", "fln", "fol", "folen", "sln", "ssln", "Sol", "Sln", "ssoln", "ssol", " solen", "ssolen", " sln"]}}
{"code": " \n  def solve(n, s, p, scores):\n      count = 0\n      for t in scores:\n          if ceil(t/3) >= p:\n              count += 1\n          elif 2 <= t <= 28 and ceil((t+2)/3) >= p and s > 0:\n              count += 1\n              s -= 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in range(1, T+1):\n              line = map(int, fin.readline().split())\n              n, s, p, *scores = line\n              result = solve(n, s, p, scores)\n              print(\"Case #{0}: {1}\".format(case, result), file=fout)\n", "substitutes": {"n": ["l", "j", "z", "u", "i", "out", "r", "b", "v", "nu", "node", "np", "net", "ne", "name", "k", "d", "pos", "m", "na", "ns", "x", "N", "o", "nb", "e", "nn", "cn", "y", "en", "f", "sn", "nit", "c", "g", "network", "w", "fn", "nt", "un"], "s": ["l", "i", "b", "stats", "us", "sh", "tp", "o", "steps", "h", "y", "start", "string", "c", "g", "sb", "si", "lines", "size", "sets", "r", "sf", "ses", "less", "se", "m", "ns", "abs", "x", "its", "os", "ops", "sp", "ls", "an", "a", "w", "es", "u", "states"], "p": ["P", "l", "ip", "j", "pm", "z", "pp", "pl", "py", "u", "i", "pin", "api", "pro", "lp", "r", "b", "pr", "v", "cp", "pair", "pe", "pu", "python", "jp", "np", "phi", "part", "d", "m", "pot", "wp", "pi", "tp", "vp", "point", "o", "up", "pc", "ap"], "scores": ["osccore", " scorer", " SCores", "ascorer", "Scores", "scents", "ascents", " sccore", "Scors", " scors", "escents", " score", "oscore", "scipes", " scoring", "scors", "Sccore", " SCents", "Score", "oscores", "Scoring", "escors", "ascore", "scorer", "oscoring", "ascors", "escorer", "escore", "escores", "ascores", "sccore", "scoring", " SCipes", "Scorer", "ascipes", "escipes", "score"], "count": ["cond", "l", "key", "i", "b", "all", "name", "id", "list", "table", "val", "counter", "start", "c", "Count", "g", "log", "size", "group", "order", "time", "race", "base", "cache", "ed", "sum", "code", "number", "use", "more", "index", "error", "col", "found", "call", "part", "d", "cat", "num", "depth"], "t": ["P", "unt", "l", "tc", "j", "size", "z", "art", "unit", "i", "out", "u", "r", "qt", "v", "b", "ot", "tt", "tu", "total", "int", "type", "tf", "tm", "d", "m", "time", "table", "fort", "ta", "num", "x", "str", "tp", "o", "tz", "e", "temp", "h", "y"], "T": ["step", "P", "section", "Case", "TS", "Z", "D", "TH", "H", "I", "connection", "M", "trial", "A", "duration", "NT", "type", "phase", "time", "TA", "sequence", "U", "N", "length", "W", "O", "E", "C", "Length", "S", "V", "L", "X", "c", "number", "Y", "TT", "B", "F", "Type"], "case": ["step", "section", "Case", "cell", "size", "example", "sea", "ce", "core", "one", "pe", "pair", "slice", "trial", "ase", "se", "int", "type", "choice", "name", "li", "ace", "trace", "position", "time", "x", "sequence", "match", "length", "cases", "space", "fold", "e", "ice", "f", "ide", "code", "switch", "string", "c"], "line": ["LINE", "log", "l", "co", "text", "lines", "page", "inline", "out", "iter", "error", "comment", "run", "i", "max", "r", "range", "call", "data", "source", "cycle", "se", "int", "type", "parse", "name", "gen", "pos", "id", "cr", "file", "list", "stack", "sequence", "block", "lined", "cl", "str", "match", "row"], "result": ["mate", "cur", "text", "new", "page", "example", "final", "complete", " Result", "comment", "valid", "r", "value", "found", "data", "object", "style", "total", "default", "function", "name", "dict", "current", "mer", "work", "trace", "file", "ret", "runner", "err", "success", "val", "res", "response", "match", " results", "length", "grade", "info", "rule"]}}
{"code": " \n  def solve(lower, upper, cache):\n      counter = 0\n      for item in cache:\n          if item > upper:\n              break\n          if item < lower:\n              continue\n          counter += 1\n      return counter\n  \n  def is_palindrome(test_int):\n      str_arg = str(test_int)\n      return str_arg == str_arg[::-1]\n  \n  def generate_cache():\n      \"\"\" Generates a list of 'fair and square' numbers between 1 and 10^100\n  \n      By observation of generating the first few of these numbers it became\n      obvious that the 'roots' fitted a very specific pattern, they are either\n      single digits and 1,2 or 3; multiple digits consisting of only 1s and 0s;\n      multiple digits with a 2 at the beginning and end and 1s and 0s in the\n      middle or an odd number of digits with a single 2 in the centre and 1s and\n      0s elsewhere.\n  \n      This function therefore only looks at these numbers to build a list of all\n      valid results. \"\"\"\n      cache = [9,]\n      counter = 1\n      if upper_bound is None:\n          upper_bound = pow(2,25)\n      while counter < upper_bound:\n          binary_part = \"{0:b}\".format(counter)\n          half_int = binary_part\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = \"%s%s\" % (binary_part, 2)\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = \"2%s\" % binary_part[1:]\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          counter += 1\n      return sorted(cache)\n  \n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                        help=\"read input from FILE\", metavar=\"FILE\")\n      parser.add_option(\"-c\", \"--cache\", dest=\"cache_filename\",\n                        help=\"read/write cache from/to CACHE_FILE\", metavar=\"CACHE_FILE\")\n      parser.add_option(\"-g\", \"--generate-cache\", dest=\"generate_cache\",\n                        help=\"generate the cache file\", action=\"store_true\")\n      cache = None\n      (options, args) = parser.parse_args()\n      if options.generate_cache:\n          cache = generate_cache()\n          if not options.cache_filename:\n              output_file = open(options.cache_filename, \"w\")\n              pickle.dump(cache, output_file)\n              output_file.close()\n      else:\n          cache_file = open(options.cache_filename, \"r\")\n          cache = pickle.load(cache_file)\n          cache_file.close()\n      if not options.filename:\n          parser.error(\"Must provide a filename.\")\n      input_file = open(options.filename, \"r\")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n          case_number += 1\n          lower,upper = input_file.readline().split()\n          lower = int(lower)\n          upper = int(upper)\n          data_args = (lower, upper, cache)\n          print \"Case #%d: %s\" % (case_number, solve(*data_args))\n  \n  if __name__ == \"__main__\":\n      main()\n", "substitutes": {"lower": ["small", "l", "middle", "min", "new", "old", "range", "zero", "little", "equal", "future", "less", "source", "front", "left", "both", "master", "simple", "part", "low", "file", "inner", "other", "south", "higher", "later", "Lower", "aster", "flower", "second", "letter", "diff", "sub", "first", "ner", "initial", "below", "outer", "central", "test"], "upper": ["inter", "middle", "older", "alpha", "final", "iter", "old", "range", "actual", "header", "future", "master", "inner", "prev", "er", "other", "highest", "high", "higher", "later", "pper", "up", "top", "inc", "cher", "aster", "result", "above", "empty", "absolute", "latest", "upt", "first", "ul", "cash", "over", "initial", "fix", "outer", "central"], "cache": ["co", "css", "clear", "menu", "chain", "function", "buffer", "file", "mc", "list", "table", "conf", "tree", "c", "ci", "update", "image", "case", "complete", "public", "array", "cycle", "order", "storage", "see", "sync", "bc", "binary", "sequence", "auto", "race", "local", "ac", "module", "base", "above", "queue", "output", "code", "history"], "counter": ["clear", "progress", "key", "all", "ception", "master", "name", "function", "buffer", "gc", "seed", "handler", "ctr", "list", "cher", "offset", "stop", "c", "instance", "repeat", "thread", "ester", "case", "loader", "iter", "timer", "exit", "value", "term", "amount", "begin", "phrase", "entry", "time", "inner", "sequence", "er", "race", "consumer", "cover"], "item": ["step", "section", "anything", "page", "amp", "case", "unit", "iter", "example", "obj", "key", "atom", "menu", "url", "rate", "loop", "value", "object", "container", "trial", "store", "order", "it", "int", "element", "level", "function", "name", "app", "area", "entry", "site", "time", "inner", "event", " it", "other", "x", "val", "hop"], "test_int": ["testing_integer", "testing_ind", "Test_arg", "testing_int", "test_integer", "testing_inter", "test_arg", "Test_id", "test_inter", "Test_inter", "test_id", "test_ind", "Test_int"], "str_arg": ["str2args", " str1min", "str_slice", " str_args", "str2Arg", " str_slice", " str6val", " str1mag", "str_Arg", "str1arg", "str2argument", "str_min", "str5Arg", "str1mag", " str_argument", "str2arg", "str_mag", "str_val", " str1arg", "str5min", "str5mag", " str_val", "str1Arg", "str1min", " str1Arg", "str_args", "str6arg", "str6args", " str6slice", " str6arg", " str_min", "str_argument", " str6args", "str5arg", " str_mag", " str_Arg", "str6val", "str6slice"], "upper_bound": ["upper_Bound", "upper67bottom", "upperboundlimit", "upper_limit", "outer_Bound", "lower_max", "lower_domain", "upperboundbound", "upperFrange", "lower_limit", "lower_range", "lower_bottom", "upperboundBound", "upperFbottom", "upperFdomain", "upper67range", "upper_domain", "lower_bound", "upper67domain", "upper67bound", "outer_depth", "upper_max", "upper_bottom", "upper_depth", "upperbounddepth", "upperFbound", "upper_range", "outer_bound", "outer_limit"], "binary_part": ["binary00party", "binary2Part", " binary_int", "binary67int", "padding00patch", "binary00part", "binary_word", "padding00field", "bin_string", "padding_part", " binary_format", "bin_part", "binary67Part", "binary00field", "binary67part", "binary00patch", "bin_word", "binary67section", "binary_format", "binary67format", "bin_Part", "binary_section", "binary2part", "padding00part", "binary_party", "binary2word", "binary_string", "binary_field", "padding00party", "padding_patch", " binary_section", "padding_field", "binary_int", "binary_patch", "padding_party", "binary2string", "binary_Part", " binary_Part"], "half_int": ["halfWexp", "half_next", "half_hard", "half67ani", "half67inc", "halfOint", "halfNINT", "halfedint", " half_inc", "half2INT", "halfedINT", "half___string", "halfhuint", "halffINT", "halfhintel", "half68exp", " half_ints", "half_exp", "half_uint", "halffuint", "half_integer", "halfPINT", "halfWint", "halfNnt", "largefhard", "halfWINT", "half68ind", " half_arg", "halfhINT", "half67index", "half68arg", "half_open", "halfFnext", "half64uint", "half_group", "halfFext", "half24uint", "half48nt", "halfOuint", "half2inter"], "pal_int": ["apple_uint", "pallint", "bel2int", "half_net", "palhints", "palJslice", "cell_inter", "style_int", "palldesc", "palgind", "panellint", "pal48uint", "pal67alt", "palPelement", "palFformat", "palMint", "panel_intel", "pal48integ", "apple48uint", "cel_alt", "pal67ind", "palFkey", "panel_desc", "isalhinteger", "palPconst", "pal_inter", "palJalt", "palguint", "cell_nt", "pal_window", "pal67element", "panelPin", "apple_int", "pal33uint", "panel_int", "palhint", "real_ind", "pal_integ", "palMind", "palFalt"], "pal_square": ["al_close", "pal24steel", "palMsingle", "isal_inter", "cellkint", "pal_steel", "global_circle", "palpysquare", "palJout", "fill_circle", "palPvoid", "pal_radius", "palhquarter", "palxhole", "isal_private", "panel_out", "palMarrow", "al_sky", "palMint", "globalMarrow", "fill_square", "pal_powder", "panel_word", "pal_sky", "palfsquare", " palicalint", "pal_inter", "palFsingle", "palfgroup", " palPvoid", " pal_center", "palkrange", "panelMint", "panel_steel", "panel_cross", "pal24radius", "palJgroup", "pal_hole", "pal_private", "paljscreen"], "parser": ["section", "config", "reader", "upload", "per", "loader", "py", "api", "server", "menu", "lp", "pm", "s", "au", "node", "xml", "plugin", "pair", "command", "python", "post", "group", "se", "general", "init", "maybe", "parse", "default", "part", "utils", "system", "parent", "p", "Parser", "entry", "template", "manager", "book", "inner", "wp"]}}
{"code": " \n  def solve(N,S,p,t):\n      if p == 0:\n          return N\n      outright_wins = 0\n      potential_surprises = 0\n      win_cutoff = (p * 3) - 3\n      surprise_cutoff = win_cutoff - 2\n      for score in t:\n          if score == 0:\n              continue\n          elif score > win_cutoff:\n              outright_wins += 1\n          elif score > surprise_cutoff:\n              potential_surprises += 1\n      if potential_surprises < S:\n          return outright_wins + potential_surprises\n      else:\n          return outright_wins + S\n  \n  def parse_case(data_line):\n      bits = data_line.split()\n      N = int(bits[0])\n      S = int(bits[1])\n      p = int(bits[2])\n      t = [int(x) for x in bits[3:]]\n      return N,S,p,t\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                        help=\"read input from FILE\", metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error(\"Must provide a filename.\")\n      input_file = open(options.filename, \"r\")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n      \tcase_number += 1\n      \tdata_args = parse_case(input_file.readline())\n      \tprint \"Case #%d: %d\" % (case_number, solve(*data_args))\n  \n  if __name__ == \"__main__\":\n  \tmain()\n", "substitutes": {"N": ["P", "J", "Q", "Net", "Na", "Size", "D", "Z", "NI", "max", "nos", "n", "NC", "I", "RN", "M", "NA", "A", "NT", "Len", "NG", "Max", "SN", "NP", "NN", "NE", "Nat", "NR", "Nic", "G", "No", "U", "num", "All", "Ni", " n", "Network", "Ns", "W", "O"], "S": ["P", "Q", "TS", "sq", "Z", "D", "out", "Sc", "Ps", "ss", "H", "n", "I", "s", "M", "SU", "A", "se", "SN", "SA", "ID", "OSS", "Sp", "SK", "SH", "Sl", "G", "SSL", " s", "U", "Sa", "GS", "WS", "SE", "si", "St", "Ns", "W", "ws", "sp"], "p": ["l", "pp", "pl", "i", "path", "b", "pr", "op", "pixel", "pot", "tp", "o", "ap", "h", "y", "pt", "c", "T", "g", "fp", "pa", "j", "per", "case", "lp", "r", "pressure", "period", "python", "np", "m", "bp", "sp", "padding", "w", "pn", "u", "mp", "s", "cp"], "t": ["P", "l", "format", "opt", "j", "game", "z", "target", "unit", "i", "window", "out", "ti", "n", "r", "b", "s", "v", "term", "ot", "tt", "flat", "span", "trial", "python", "tu", "tests", "it", "total", "te", "type", "tf", "tm", "wt", "d", "m", "time", "table", "tz", "tp"], "outright_wins": ["outright_twalls", "outright_weouts", "outright_watches", "outright_twins", "outright_wains", "outright_Wits", "outright_wain", "outright_waits", "outright_wits", "outright_twin", "outright_Walls", "outright_weins", "outright_win", "outright_kwin", "outright_walls", "outright_twatches", "outright_twits", "outright_waouts", "outright_wealls", "outright_waatches", "outright_Win", "outright_wein", "outright_kwatches", "outright_kwins", "outright_waalls", "outright_kwalls", "outright_wouts", "outright_twouts", "outright_Wins"], "potential_surprises": ["potential_surprising", "potential_generprise", "potential_wraacters", "potential_suracters", "potential_turprise", "potential_generprising", "potential_Surries", "potential_genergeries", "potential_serries", "potential_turprising", "potential_curprise", "potential_generprises", "potential_wraprises", "potential_curvey", "potential_curacters", "potential_wraprising", "potential_urprises", "potential_curprising", "potential_Surprises", "potential_turprises", "potential_serprising", "potential_curprises", "potential_surprise", "potential_Surgeries", "potential_wraprise", "potential_survey", "potential_urprise", "potential_surries", "potential_urprising", "potential_turgeries", "potential_serprise", "potential_Survey", "potential_urvey", "potential_curries", "potential_serprises", "potential_Surprise", "potential_Surprising", "potential_surgeries", "potential_turacters"], "win_cutoff": ["win_Cutoffs", "win_CutOff", "win_cutoffer", "win_Cutoff", "win_potoffs", "win_Cutout", "win_cutsdown", "win_cutsoff", "win_taildown", "win_cutsoffs", "win_cutsOff", "win_tailoff", "win_cutOff", "win_potension", "win_cutdown", "win_cutsension", "win_potoff", "win_Cutoffer", "win_cutout", "win_cutension", "win_potout", "win_Cutdown", "win_cutoffs", "win_tailoffer", "win_Cutension", "win_cutsout", "win_tailoffs"], "surprise_cutoff": ["surprise_cutsout", "surprise_Cutout", "surprise_coff", "surprise_cutsoffs", "surprise_cutOff", "surprise_cutoffs", "surprise_cutsoff", "surprise_Cutoff", "surprise_CutOff", "surprise_cutout", "surprise_Cutoffs", "surprise_cout", "surprise_cutsOff", "surprise_coffs"], "score": ["key", "path", "fit", "scale", "stats", "rank", "category", "grade", "y", "feature", "est", "si", "ester", "fer", "size", "case", "core", "set", "rate", "np", "level", "ose", "Score", "err", "cache", "sp", "ize", "en", "year", "scoring", "pred", "code", "orer", "pri", "number", "player", "ore", "sd", "pn", "error"], "data_line": ["data_entry", "datamatlines", "case_line", "case_block", "case_lin", "data_block", "datamatblock", "datamatlin", "data_lines", "input_entry", "input_name", "data_name", "input_lines", "input_line", "data_lin", "case_lines", "datamatline"], "bits": ["address", "piece", "key", "b", "tests", "stats", "nets", "utils", "cells", "steps", "bles", "fits", "pins", "xs", "planes", "lins", "vals", "Bit", "lines", "value", "codes", "data", "ids", "frames", "blocks", "words", "bs", "ns", "settings", "notes", "details", "binary", "abs", "mask", "chains", "its", "gets", "ops", "base", "items"], "x": ["xb", "ex", " ex", "exp", "ip", "z", "i", " X", "dx", "xe", "xxx", "xd", "abc", "xx", "v", "bit", "python", "xf", "xy", "int", "xi", "sex", "xc", "xxxx", "xes", "id", "wx", " xp", "event", "ax", "rx", "num", " c", "ix", "e", " cx", " xx", "xxxxxxxx", "xs", " XX"], "parser": ["config", "section", "reader", "per", "loader", "py", "random", "could", "server", "jack", "process", "lp", "pm", "s", "v", "au", "plugin", "pair", "slice", "command", "python", "trial", "group", "se", "init", "type", "maybe", "parse", "function", "default", "part", "app", "parent", "Parser", "file", "book", "inner", "list", "er", "tp"], "options": ["includes", "menu", "stats", "name", "utils", "file", "objects", "other", "option", "o", "io", "comments", "posts", "plugins", "checks", "c", "params", "vals", "ends", "strings", "section", "values", "lines", "obj", "py", "data", "words", "rules", "settings", "details", "its", "ops", "spec", "resources", "Options", "points", "files", "http", "groups", "es"], "args": ["config", "exp", "image", " arg", " params", "obj", "cli", "py", "flags", "help", "v", "_", "data", "init", "parts", "parse", "gen", "arr", "dict", "atts", "argument", "Args", "module", " defaults", "ig", "ext", "cmd", "arg", " arguments", "params", "w", "gs", "aux", "kw"], "input_file": ["accept_string", "input_string", "inputfulclass", "input_class", "inputfulline", "input_handle", "input64string", "input64size", "input_body", "initialpbody", "initial_body", "input64handle", "inputamFile", "output_lane", "input_File", "output_line", "inputambuffer", "inputpbuffer", "initialpbuffer", "initialpFile", "inputfclass", "output_file", "inputambody", "initial_buffer", "initial_file", "inputFFile", "initial_File", "accept_handle", "input_lane", "inputpFile", "input64file", "inputflane", "inputfullane", "inputffile", "accept_file", "output_class", "input_buffer", "inputFbody", "input_size", "inputfulfile"], "total_cases": [" total_frames", "all_cases", "total_posts", "total_frames", "totalalcases", "totalCcases", "totalaltests", " total_tests", "totalCtests", " total_posts", "totalalposts", "total_tests", "all_points", "all_tests", "totalCcase", "totalalframes", "total_points", "all_case", "totalCpoints", "total_case"], "case_number": ["case_count", "caseidinfo", "caseIdcount", " case_code", "Case_number", "case_numbered", "Case_num", "caseCcondition", "caseFcode", "caseidno", "case_condition", "case_info", "caseCnumber", " case_info", " case_no", "case_n", "caseIdno", "caseCn", "caseFnumber", " case_count", "caseidcondition", "caseidnumber", "caseIdinfo", "caseidn", "caseIdnumber", " case_n", " case_condition", "caseidcount", "case_code", "caseCno", " case_note", "Case_numbered", "case_no", "caseFno", "case_note", "caseFnote", "Case_no", "case_num"], "data_args": [" data_params", "data____args", "data__options", "data_options", "data____arg", "data____options", "case_fields", "case_args", "data____params", "data__args", "data_lines", " data_options", "data__fields", "data_fields", "data_arg", "data_params", "case_arg", " data_arg", "data__params", "data__arg", "case_lines", "data__lines"]}}
{"code": " \n  \n  def is_palindrome(x):\n      candidate = list(str(x))\n      while len(candidate) > 1:\n          if candidate.pop(0) != candidate.pop():\n              return False\n      return True\n  \n  \n  def square(x):\n      return x * x\n  \n  \n  def solve_case(ab, case_number):\n      fs = 0\n      root = int(math.sqrt(ab[0]))\n      sq = square(root)\n      if sq < ab[0]:\n          root += 1\n          sq = square(root)\n  \n      while sq <= ab[1]:\n          if is_palindrome(root) and is_palindrome(sq):\n              fs += 1\n  \n          root += 1\n          sq = square(root)\n  \n      print \"Case #%d: %d\" % (case_number, fs)\n  \n  \n  def main():\n      r = sys.stdin\n      if len(sys.argv) > 1:\n          r = open(sys.argv[1], 'r')\n  \n      total_cases = r.readline()\n      for case_number in range(1, int(total_cases) + 1):\n          ab = map(int, r.readline().strip().split(' '))\n          solve_case(ab, case_number)\n  \n  if __name__ == \"__main__\":\n      main()\n", "substitutes": {"x": ["rex", "xb", "ex", "l", "image", "exp", "z", "example", "case", "i", "null", "u", "max", "xe", "xxx", "abc", "n", "b", "xx", "v", "xml", "input", "s", "cross", "full", "python", "fe", "array", "fc", "xy", "xf", "xi", "sex", "xc", "xes", "d", "fx", "p", "host", "wx"], "candidate": [" candidation", "homidated", "indinate", "palider", "confidation", "indise", "homue", "Candidation", "candidated", "cellmate", "promidate", "candue", "Candue", "homidates", "validate", "valididate", "prominate", "promise", "confidates", "prommate", "candise", "Candidate", "chidation", "Candidated", "cellidate", "candidates", "chidate", "palidate", "candider", " candider", "palidated", "confidate", "validated", "cellinate", "valididated", "homidate", "candidation", "candinate", " candidated", "validue"], "ab": ["l", "abb", "rb", "rest", "am", "abc", "b", "au", "bel", "aus", "access", "lab", "lam", "area", "aba", "abe", "ray", "rob", "ap", "af", "c", "sb", "bl", "case", "bb", "ast", "AB", "array", "aps", "bi", "al", "bf", "bc", "assembly", "bs", "abs", "ac", "lb", "base", "tab"], "case_number": ["caseingnumber", " case_expression", "caseingstring", "case__numbered", "caseIDnumbered", " case_text", "caseingnumbered", "caseIDnumber", "caseIdexpression", "caseIdnum", "caseIDnum", "caseNdirectory", "case_directory", "case_numbered", "casedaytext", " case_size", "case__number", "caseNnumber", " case_range", "caseNnum", "caseIdtext", " case_type", "caseIDstring", "case_range", "case_string", "caseIDrange", "caseIDdirectory", "case_num", "case_expression", "caseIDtype", "case_size", "case_text", "caseIdnumber", " case_numbered", " case_string", "casedaynum", "casedaynumber", " case_directory", "case__size", "caseNrange"], "fs": ["fee", "ff", "oots", "features", "lines", "rf", "Fs", "sec", "folder", "feed", "df", "ros", "ss", "ms", "sf", "loop", "fd", "farm", "dim", "family", "fe", "cs", "fc", "xf", "fts", "fb", "fif", "ows", "ds", "blocks", "fps", "fx", "qs", "bf", "seed", "vers", "rss", "bs", "frac", "ns"], "root": ["fixed", "feed", "right", "rew", "b", "scale", "fc", "ows", "area", "rt", "rank", "seed", "box", "round", "rx", "hour", "ground", "offset", "bottom", "fw", "af", "string", "fp", "rw", "section", "oots", "size", "ow", "case", "df", "core", "farm", "array", "bf", "bc", "frac", "ns", "os", "base", "above"], "sq": ["qq", "shift", "sky", "area", "rt", "rank", "seed", "sh", "rx", "sql", "request", "iq", "nn", " squared", " square", "qu", "shape", "sec", "size", "zz", "kk", "ow", "scl", "core", "sf", " squares", "array", "se", "np", " ss", "sync", " SQ", "ww", "qs", "ql", "frac", "sci", "arrow", "secure", "sub"], "r": ["rl", "l", "reader", "ir", "br", "ur", "t", "rb", "hr", "ri", "mr", "b", "range", "pr", "usr", "dr", "gr", "rg", "rar", "nr", "rt", "d", "ro", "p", "re", "rd", "ra", "cr", "wr", "lr", "fr", "runner", "err", "er", "rx", "res", "str", "ru", "sr", "e"], "total_cases": ["Total_cs", "totalEtimes", "total_times", "Total_pieces", "totalEpieces", " total_tests", "Total_times", "totalEcases", " total_cells", "total_cs", "total_tests", "total_pieces", "total00cases", "total00cs", "total00times", "totalEcs", "total00pieces", "total_case", " total_case", "total_cells", "Total_cases"]}}
{"code": " \n  mod_plus_conv_with_s = {0:1, 1:1, 2:2}\n  mod_plus_conv_without_s = {0:0, 1:1, 2:1}\n  \n  def solve_case(s, p, scores,case_number):\n  \tans = 0\n  \tfor score in scores:\n  \t\tif p <= (score / 3) + mod_plus_conv_without_s[score % 3]:\n  \t\t\tans = ans + 1\n  \t\telif s > 0 and (score / 3) > 0: \n  \t\t\tif p <= (score / 3) + mod_plus_conv_with_s[score % 3]:\n  \t\t\t\tans = ans + 1\n  \t\t\t\ts = s - 1\n  \tprint \"Case #%d: %d\" % (case_number, ans)\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n  \tr = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n  \tcase_line = map(int, r.readline().rstrip().split(' '))\n  \tsolve_case(case_line[1], case_line[2], case_line[3:], case_number)\n  \n", "substitutes": {"mod_plus_conv_with_s": ["mod_plus_conv_withrictd", "mod_plus_conv_with_c", "mod_plus_conv_with_ssl", "mod_plus_conv_without_c", "mod_plus_conv_withricts", "mod_plus_conv_without_d", "mod_plus_conv_withrictc", "mod_plus_conv_with_d", "mod_plus_conv_with_n", "mod_plus_conv_without_n", "mod_plus_conv_withrictssl", "mod_plus_conv_without_ssl"], "mod_plus_conv_without_s": ["mod_plus_conv_with_c", "mod_plus_conv_with_e", "mod_plus_conv_without_c", "mod_plus_conv_with_f", "mod_plus_conv_without_d", "mod_plus_conv_with_d", "mod_plus_conv_without_f", "mod_plus_conv_without_e"], "s": ["l", "aces", "i", "t", "b", "aus", "sa", "stats", "us", "ores", "o", "ap", "xs", "y", "c", "g", "sb", "strings", "si", "lines", "size", "sets", "ses", "sf", "se", "np", "m", "ns", "settings", "x", "os", "ops", "sp", "ls", "a", " cs", "w", "sd", "ips", "gs"], "p": ["P", "l", "ip", "pp", "per", "case", "t", "i", "u", "py", "pn", "n", "lp", "cp", "v", "b", "pm", "span", "op", "pair", "ot", "pr", "param", "pe", "jp", "np", "d", "rank", "m", " xp", "x", "pi", "tp", "bp", "pc", "ap", "e", "ps", "sp", "an"], "scores": ["SCores", "Scores", "Scales", "Scors", "scales", " Scores", "SCales", "ncales", "scamples", "Scamples", "scors", " scales", "sors", "ncores", "samples", " Scales", "sales", "ncore", "sores", "SCamples", "SCors", " Score"], "case_number": ["case__numbered", "case_numbered", "case__number", "caseIDlength", "caseidnumbered", "case__count", "line_numbered", "caseIDname", "case_num", " case_num", "case64number", "caseIDnum", "case_position", "case64num", "caseftitle", "caseidnumber", "line_count", "line__numbered", "casefnum", "line__counter", "case__length", "case_count", "line__count", "case_counter", "line__number", "case__num", " case_length", " case_position", "caseidcount", " case_title", "case64numbered", "case__counter", "line_number", " case_name", "case64position", "caseIDnumber", "caseidcounter", "casefnumber", "case_title", "case__name"], "ans": ["aces", "aning", "am", "ations", "au", "aus", "ase", "ace", "outs", "nas", "offs", "names", "xs", "ents", "lines", "case", "amps", "ras", "ann", "anon", "les", "AN", "abilities", "ids", "leans", "aps", "ana", "ns", "san", "ani", "os", "ang", "eds", "acts", "ls", "an", "acs", "ano", "aned", "can"], "score": ["desc", "key", "path", " scoreboard", "scale", "live", "stats", "name", "id", "rank", "seed", "line", "grade", "team", "board", "y", "c", "feature", "si", "size", "case", "core", "rate", "order", "np", "level", " scoring", "site", "time", "Score", "sci", "goal", "cache", "scoring", "year", "code", "orer", "pri", "number", "player"], "r": ["rl", "ruby", "l", "reader", "ir", "br", "ur", "t", "rb", "hr", "run", "u", "ri", "b", "pr", "v", "usr", "dr", "gr", "rg", "rar", "nr", "rt", "ro", "parser", "re", "rd", "d", "cr", "ra", "wr", "fr", "runner", "err", "er", "rx", "res", "str", "ru", "sr"], "total_cases": ["total54jobs", "Total_cells", "Total_tests", " total_lines", "total_jobs", "total54lines", "total54cases", "Total_devices", "total68grades", "total___cells", "total48cases", "total_grades", "total48tests", "total68jobs", "total_tests", " total_jobs", "total54grades", "total_lines", "total68lines", " total_grades", "total68cases", "total_devices", "total___devices", "total___cases", "total48devices", "total___tests", "total48cells", "total_cells", "Total_cases"], "case_line": ["caselypart", "casebooklines", " case_lines", "casejtext", " case_text", "casealbase", "casebedlink", "caseFlin", "casejlines", " case_part", "case_lin", " case_non", "caseFline", "casealline", " case_lin", "caselyline", "casebedline", "casebookliner", "casebookline", "case_layer", "caseFliner", "casejbase", "case_part", "case_liner", " case_link", "casebooklin", "case_non", "case_text", "case_link", "caselylines", "caseFlines", "casealtext", " case_base", " case_layer", "casejline", "casebednon", "caselylayer", "case_base", "casebedlines", "caseallines"]}}
{"code": " \n  def isPalindrome(n):\n  \tn = str(n)\t\n  \tfor i in xrange(len(n)/2):\n  \t\tif n[i] != n[(-i-1)]:\n  \t\t\treturn False\n  \treturn True\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file(\"output.txt\", \"w\")\n  \n  T = eval(f.readline())\n  \n  for case in xrange(T):\n  \tdata = f.readline().split()\n  \tA = eval(data[0])\n  \tB = eval(data[1])\n  \n  \ti = A\n  \tfound = []\n  \twhile i <= B:\n  \t\tif isPalindrome(i):\n  \t\t\tsqrtI = math.sqrt(i)\n  \t\t\tif sqrtI == int(sqrtI):\n  \t\t\t\tif isPalindrome(int(sqrtI)):\n  \t\t\t\t\tfound.append(i)\n  \t\ti += 1\n  \n  \tfout.write(\"Case #%d: %d\n\" %(case + 1, len(found)))\n", "substitutes": {"n": ["l", "j", "z", "t", "u", "out", "pn", "r", "b", "s", "v", "node", "np", "net", "ne", "ln", "name", "k", "d", "p", "m", "na", "ns", "x", " N", "num", "ni", "N", "o", "nb", "e", "Ns", "nt", "nc", "nn", "cn", "h", "no", "y", "en"], "i": ["l", "ti", "t", "fi", "b", "inf", "qi", "shift", "phi", "uri", "int", "iri", "multi", "ei", "id", "o", "io", "h", "y", "start", "c", "g", "ini", "ci", "si", "j", "eni", "ri", "r", "xi", "bi", "m", "x", "ni", "sequence", "ix", "mini", "hi", "a", "gi"], "inputFileName": ["inputfileName", "inputFilenameName", "outputFilePath", "inputTablePath", "inputFileCopy", "outputFileSize", "inputFilenamePath", "inputFilesName", "inputTableSize", "inputFileSize", "inputFilesPath", "inputFilesCopy", "outputDirHandle", "outputDirName", "inputDirSize", "inputFilenameCopy", "inputfileCopy", "inputTableHandle", "inputDirName", " inputFilePath", " inputfileCopy", " inputfilePath", "inputFilePath", " inputFileHandle", "inputDirHandle", "outputFileHandle", "inputFileHandle", "inputFilesHandle", " inputFileCopy", "inputfilePath", "outputDirPath", "inputTableName", "inputFilesSize", "inputDirPath", "outputDirSize", "outputFileName", "inputFilenameHandle", " inputfileHandle", "inputfileHandle", " inputfileName"], "f": ["l", "z", "obj", "t", "u", "df", "feed", "iter", "fit", "input", "b", "s", "v", "fd", "r", "sf", "inf", "loop", "stream", "fc", "fb", "tf", "function", "d", "fx", "p", "m", "file", "form", "fr", "x", "fm", "o", "io", "e", "self", "result", "buff", "a", "fw"], "fout": ["FOut", "fouts", "feouts", "FOUT", " foutput", "fOUT", "fein", "woutput", "fOut", "dout", "din", "Foutput", "wout", " fin", "win", "fin", "wOut", "Fout", "Fin", "dOUT", "feOUT", "feout", "Fouts", "foutput", "douts", " fOut"], "T": ["P", "Q", "TS", "z", "Z", "D", "TH", "t", "H", "I", "Data", "M", "NT", "total", "p", "TF", "WT", "Time", "time", "G", "N", "length", "Text", "W", "O", "E", "C", "Length", "S", "V", "L", "X", "TT", "Y", "It", "F", "K", "LT", "IT", "Num"], "case": ["section", "Case", "ite", "size", "ise", "rice", "key", "ce", "loc", "ue", "core", "me", "count", "pe", "su", "slice", "trial", "shift", "ase", "se", "choice", "ie", "name", "bi", "ace", "d", "id", "seed", "position", "time", "nce", "sequence", "match", "line", "race", "length", "cases", "result", "ice", "C"], "data": ["config", "aa", "text", "j", "lines", "z", "missing", "database", "alpha", "t", "u", "valid", "feed", "complete", "loc", "input", "b", "s", "Data", "v", "DATA", "slice", "source", "array", "next", "int", "dat", "function", "batch", "content", "d", "pos", "p", "na", "inner", "list", "x", "response", "search", "o"], "A": ["P", "ai", "API", "Na", "As", "Z", "D", "alpha", "AA", "LA", "am", "H", "I", "b", "Data", "M", "NA", "Ab", "Am", "Alpha", "p", "G", "x", "U", "N", "W", "O", "ad", "AF", "E", "C", "a", "S", "L", "X", "c", "K", "Y", "g", "F"], "B": ["P", "Q", "J", "WB", "ab", "Z", "D", " b", "GB", "AB", "I", "H", "b", "BF", "BW", "M", "LB", "Ab", "NB", "Bs", "G", "U", "N", "BB", "BC", "length", "bound", "BS", "W", "EB", "O", "BA", "E", "C", "S", "V", "L", "X", "TB", "Bi"], "found": ["created", "fixed", "l", "missing", "new", "z", "where", "error", "valid", "identified", "iter", "old", "count", "shown", "inf", "flat", "fe", "lost", "array", "all", "left", "front", "less", "Found", "errors", "good", "fl", "d", "pos", "id", "loaded", "founded", "file", "sent", "err", "placed", "used", "num", "defined", "search"], "sqrtI": ["supprtI", "sqrtB", " sqrti", "sqratE", " sqntB", "sqntL", "squarertB", "sqrtE", "sqrtU", "sqRTI", "sqrcB", "sqntI", "squarercI", "suppRTL", " sqrati", "squarerti", "sqrati", "squarercB", "supprtU", "sqrci", "sqnti", "squarerci", "sqrcI", "sqrotI", "sqrti", "squarercL", " sqrtE", "sqrotU", "sqratI", "squarertL", " sqratI", "sqratL", "supprtB", " sqntU", " sqntI", "sqrotB", "sqRTB", "sqratU", "sqntU", " sqrtB"]}}
{"code": "arq = file(\"input.in\")\n  n_cases = eval(arq.readline())\n  out = file(\"output.txt\", \"w\")\n  \n  for case in xrange(n_cases):\n  \n  \tdata = arq.readline()\n  \tdata = data.strip()\n  \tdata = data.split(\" \")\n  \n  \tn = eval(data[0])\n  \ts = eval(data[1])\n  \tp = eval(data[2])\n  \n  \tscores = []\n  \tn_googlers_with_best_result = 0\n  \tcandidates = 0\n  \n  \tfor j in data[3:]:\n  \t\ti = eval(j)\n  \t\tif i%3 == 0:\n  \t\t\tscore = i/3\n  \t\t\tscores.append([score, score, score])\n  \t\telif (i+1)%3 == 0:\n  \t\t\tscore = (i+1)/3\n  \t\t\tscores.append([score-1, score, score])\n  \t\telse: #(i+2)%3 == 0\n  \t\t\tscore = (i+2)/3\n  \t\t\tscores.append([score-1, score-1, score])\n  \n  \tfor score in scores:\n  \t\tif score[2] >= p:\n  \t\t\tn_googlers_with_best_result +=1\n  \t\telif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:\n  \t\t\tcandidates += 1\n  \n  \tn_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)\n  \n  \tout.write(\"Case #%d: %d\n\" % (case+1, n_googlers_with_best_result))\n", "substitutes": {"arq": ["arqs", "earq", "earQ", "earqual", "iarflow", "irq", " arqs", " arqu", "earqs", "arqual", "urq", "erq", "araqs", "araqual", "erqu", " arflow", "irQ", "iarqu", "erqs", "arQ", "iarqs", "arenqs", "araq", "earqi", "urqi", "araQ", "arenq", "arenQ", "arqi", "irqi", "arqu", "irqs", "arenqual", "urQ", "erflow", "urqs", "iarq", "arflow"], "n_cases": ["nb_rows", "nNrows", "nXtests", "nb_trial", "n_rows", "nXtrial", "nXcases", "nb_tests", "nb_cases", " n_cells", " n_lines", "n_cells", "n_lines", "nNtests", "n_tests", "nXrows", " n_tests", "nNtrial", "nNcases", "n_trial"], "out": ["log", "image", "ex", "Out", "obj", "null", "key", "error", "path", "v", "flat", "call", "full", "object", "conn", "append", "raw", "net", "bin", "dot", "write", "name", "gen", "part", "parent", "again", "work", "file", "outs", "list", "err", "lock", "o", "io", "writer", "up", "result", "ext", "temp", "word"], "case": [" code", "section", "Case", " trial", "address", "size", "ASE", "example", "rice", "ce", "core", "count", "loop", "de", "uc", "slice", "trial", "change", "ase", "chance", "cycle", "choice", "name", "li", "ace", "phase", "seed", "position", "time", "bc", "x", "match", "line", "race", " c", "length", "cases", "e", "bug", "edge"], "data": ["key", "feed", " Data", "input", "Data", "shift", "frame", "write", "function", "file", "read", "list", "val", "json", "line", "o", "fail", "analysis", "video", "start", "first", "string", "reader", "lines", "size", "complete", "value", "DATA", "array", "raw", "next", "dat", "ata", "sequence", "module", "cache", "series", "output", "a", "code"], "n": ["l", "z", "size", "t", "nu", "b", "count", "v", "r", "span", "np", "net", "ne", "k", "nr", "li", "m", "na", "ns", "x", "ni", "num", "N", "nb", "nc", "nn", "cn", "y", "en", "sn", "c", "number", "fn", "w", "nt", "ny"], "s": ["l", "es", "features", "z", "size", "sq", "services", "sec", "u", "ins", "sets", "eps", "r", "b", "v", "ses", "less", "cs", "stats", "sync", "d", "ns", "settings", "sym", "details", "south", "ches", "e", "spec", "series", "ps", "sp", "ls", "ws", "y", "a", "f", "S", "sum", "sc"], "p": ["P", "l", "ip", "z", "pp", "per", "u", "t", "py", "after", "lp", "b", "v", "r", "cp", "op", "pe", "jp", "np", "k", "current", "d", "m", "x", "pi", "tp", "pad", "point", "o", "up", "pc", "e", "ps", "sp", "pre", "h", "y", "a", "f", "padding"], "scores": ["Scanners", " scorer", "SCores", "escodes", "Scores", "incanners", "Scales", "squscore", "compodes", "Scors", " scors", "squors", "compors", "candoring", "scales", "escscore", "candores", "incores", "candors", " scoring", "compscore", "scors", "Scodes", "squodes", " scales", "scscore", "Scoring", "escors", "squores", "scorer", "SCorer", " scodes", "escorer", "scros", "incorer", "SCodes", "scanners", "escores", "incoring", "escoring"], "n_googlers_with_best_result": ["n_googlers_with_better_score", "n_googlers_with_best_Result", "n_googlers_with_better_match", "n_googlers_with_better_Result", "n_googlers_with_better_results", "n_googlers_with_best_score", "n_googlers_with_better_result", "n_googlers_with_best_results", "n_googlers_with_best_match"], "candidates": ["Candles", "candles", "candances", "charores", " candidate", "Candicators", "charances", "indidates", "Candances", " candicators", "candicators", "candores", "Candidate", "indores", " candores", "Candores", "charidate", "charles", "candidate", " candles", "charidates", "Candidates", "indicators", " candances", "indidate"], "j": ["bj", "J", " trial", "l", "adj", "ji", "obj", "z", "ij", "ite", "jl", "t", "u", " r", "jack", " dj", " l", "r", "b", "v", "js", "job", " je", "trial", "yi", "jp", "xi", "ie", "jam", "k", "li", "d", "m", " section", "je", "dj", "jj", " z", "oj", " c"], "i": ["l", "ai", "ji", "z", "chi", "eni", "api", "u", "ti", "t", "ri", "ski", "I", "b", "v", "isi", "qi", "ui", "ori", "ic", "yi", "phi", "uri", "int", "xi", "init", "ie", "bi", "multi", "li", "ei", "d", "id", "m", "iu", "inner", "x", "pi", "ni", "mi"], "score": ["color", "key", "fit", "ward", "scale", "live", "name", "degree", "id", "rank", "seed", "runner", "nil", "ores", "line", "grade", "team", "rule", "ranking", "video", "nc", "y", "risk", "c", "char", "feature", "est", "si", "note", "fee", "size", "core", "set", "rate", "value", "rage", "order", "chance", "level", "average"]}}
{"code": " \n  \n  def isPal(n):\n      l = str(n)\n      return l == l[::-1]\n  \n  def solve(a, b):\n      l = int(math.ceil(math.sqrt(a)))\n      u = int(math.floor(math.sqrt(b)))\n  \n      count = 0\n      for x in range(l, u + 1):\n          if isPal(x):\n              if isPal(x*x):\n                  count += 1\n      return str(count)\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n          result = solve(a, b)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  \n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"n": ["j", "z", "t", "pn", "r", "s", "v", "nw", "net", "ne", "ln", "name", "k", "d", "p", "m", "ns", "ni", "o", "nb", "e", "Ns", "nt", "nc", "no", "nn", "ny", "y", "en", "f", "sn", "c", "el", "g", "network", "w", "nu", "nan"], "l": ["rl", " L", "j", "z", "pl", "ur", "t", "r", "s", "v", "lp", "dl", "left", "ell", "ln", "ly", "k", "li", "fl", "d", "p", "m", "NL", "val", "o", "length", "lb", "e", "ol", "il", "ls", "lu", "y", "len", "ul", "f", "L", "c", "el", "lc"], "a": ["ak", "aa", "ai", "wa", "sta", "ab", "ama", "alpha", "api", "va", "ada", "am", "oa", "r", "ba", "v", "s", "au", "A", "sa", "asa", "front", "k", "area", "ga", "d", "p", "ae", "m", "na", "o", "ac", "da", "la", "ea", "e", "an", "ca", "ad", "y"], "b": ["j", "ab", "z", "bb", "rb", "r", "s", "v", "ba", "range", "wb", "fb", "name", "bi", "k", "part", "d", "be", "p", "bf", "m", "eb", "body", "bc", "bs", "ob", "binary", "other", "bis", "o", "length", "lb", "nb", "e", "cb", "base", "h", "y", "f", "c"], "u": ["j", "z", "chu", "ur", "ue", "cu", "Lu", "v", "uy", "ui", "su", "tu", "uc", "pu", "uv", "k", "us", "d", "p", "m", "iu", "pi", "U", "num", "ua", "ru", "o", "up", "ou", "e", " U", "uu", "lu", "y", "ul", "f", "q", "c", "eu", "g"], "count": ["size", "z", "case", "max", "key", "label", "loc", "col", "seq", "found", "call", "left", "total", "int", "type", "child", "name", "ch", "li", "current", "limit", "id", "p", "m", "list", "val", "num", "race", "length", "info", "e", "base", "depth", "coll", "weight", "cache", "counter", "len", "y", "start"], "x": ["ex", "t", "input", "xx", "int", "id", "rx", "o", "ct", "xs", "h", "y", "c", "g", "px", "ci", "www", "j", "out", "r", "cross", "data", "xi", "al", "xxxx", "m", "ns", "ix", "ac", "an", "no", "en", "code", "X", "number", "w", "xp", "ng", "index", "ox"], "N": ["P", "Q", "Na", "size", "Z", "D", "Size", "NI", "max", "H", "I", "NC", "M", "NA", "A", "NT", "Len", "NN", "NB", "NE", "p", "NR", "ns", "G", "No", "U", "num", "length", "Ni", "Ns", "W", "O", "Num", "E", "C", "Ne", "S", "V", "L", "X"], "i": ["lo", "ai", "ip", "ir", "j", "z", "chi", "cli", "ti", " I", "ri", "col", "I", "ih", "v", "ui", "qi", "slice", "phi", "uri", "int", "xi", "type", "bi", "multi", "li", "k", "pos", "d", "id", "p", "m", "iu", "uni", "pi", "di", "o", "io", "ix", " j"], "result": ["answer", "text", "new", "obj", "final", "df", "valid", "comment", "rb", "url", "ge", "r", "value", "found", "pair", "data", "array", "acc", "default", "function", "arr", "func", "dict", "current", "entry", "work", "resp", "ret", "root", "list", "success", "err", "val", "res", "response", "match", "line", "repl", "status", "report"]}}
{"code": " \n  \n  \n  def solve(num_surprises, p, ts):\n      s = 0\n      u = 0\n      for t in ts:\n          a = int(t/3)\n          r = t % 3\n          if a+1 >= p and not r == 0:\n              u += 1\n          elif a >= p and r == 0:\n              u += 1\n          elif a > 0 and a+1 >= p and r == 0:\n              s += 1\n          elif a+2 >= p and r == 2:\n              s += 1\n  \n      return min(num_surprises, s) + u\n          \n          \n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          line = [int(x) for x in sys.stdin.readline().split()]\n          num_surprises = line[1]\n          p = line[2]\n          ts = line[3:]\n          result = solve(num_surprises, p, ts)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"num_surprises": ["num_projectities", "num__surfaces", "num_disprise", "num_discharges", "num_surcharges", "num_curacters", "num_curprise", "num_disprising", "num_emerprises", "num_useprises", "num_traprising", "num_usegeries", "num_sweprises", "numjuseacters", "numjuseprises", "num_Surceptions", "num_curprising", "num__surceptions", "numjsuracters", "num__sweprises", "num__swefaces", "num_projectprises", "num_surfaces", "num_disprises", "num_emeracters", "num_curprises", "num_surceptions", "num__surprises", "numjuseprising", "num_interfaces", "numjsurprising", "numjsurgeries", "num_swefaces", "num_surgeries", "num_projectpes", "num_surities", "num_curgeries", "num_Surprises", "num_surprising", "num_sweceptions"], "p": ["l", "pp", "pl", "b", "pr", "op", "pot", "tp", "point", "ap", "h", "y", "pt", "c", "g", "pa", "ep", "j", "per", "lp", "pm", "hp", "python", "pu", "np", "par", "m", "po", "sp", "points", "w", "at", "st", "pin", "cp", "pair", "k", "part", "current", "d"], "ts": ["tc", "ations", "tests", "stats", "Ts", "tes", "td", "outs", "ta", "tp", "steps", "tx", "xs", "ments", "y", "pt", "T", "strings", "lines", "ims", "uts", "ids", " times", "qs", "m", "time", "tips", "ns", "sp", "ls", "points", "tim", "st", "nt", "TS", "eps", "ements", "tt", "cs", "te"], "s": ["l", "es", "sq", "min", "z", "lines", "sections", "ur", "sets", "ss", "states", "n", "b", "v", "so", "su", "ui", "span", "sa", "cs", "se", "sv", "ds", "us", "d", "m", "sg", "ns", "num", "south", "seconds", "o", "sr", "os", "e", "ps", "ls", "h", "y", "ul"], "u": ["l", "z", "ur", "cu", "n", "b", "v", "Lu", "ui", "su", "tu", "au", "SU", "int", "k", "us", "d", "m", "iu", "ns", "U", "mu", "num", "ru", "o", "auto", "up", "os", "ou", "e", " U", "uu", "lu", "h", "y", "ul", "f", "q", "c", "eu"], "t": ["l", "j", "z", "art", "window", "ont", "n", "b", "v", "ot", "tt", "tu", "duration", "put", "int", "k", "tm", "et", "d", "m", "time", "ret", "table", "num", "ta", "xt", "str", "tp", "ty", "tz", "o", "e", "temp", "sp", "h", "y", " T", "start", "pt", "f"], "a": ["aa", "ai", "wa", "sta", "ab", "z", "ama", "alpha", "api", "va", "art", "am", "ach", "n", "ba", "b", "au", "A", "sa", "asa", "eta", "qa", "aw", "area", "ga", "ae", "ra", "ata", "m", "d", "na", "ana", "ax", "ta", "o", "ac", "da", "la", "ap", "ea"], "r": ["rl", "l", "rad", "ir", "j", "rf", "br", "ur", "rb", "right", "ri", "mr", "rate", "n", "b", "range", "v", "pr", "rage", "rar", "ler", "k", "nr", "rt", "d", "ra", "re", "m", "ro", "cr", "rd", "err", "ran", "er", "res", "rator", "ru", "rev", "sr", "o"], "N": ["P", "Q", "Na", "z", "Size", "D", "Z", "NI", "I", "n", "NC", "RN", "M", "NA", "A", "NT", "Len", "NO", "NG", "NB", "NR", "ns", "G", "No", "U", "num", "length", " n", "Ni", "Ns", "W", "O", "y", "NS", "Line", "C", "f", "S", "V", "Ne"], "i": ["step", "lo", "l", "ip", "j", "z", "chi", "page", "cli", "ti", "I", "n", "v", "slice", " y", "phi", "uri", "int", "xi", "type", "bi", "multi", "li", "k", "pos", "id", "d", "m", "iu", "pi", "di", "row", "o", "io", " z", "ix", "mini", "info", "e", "depth"], "line": ["LINE", "log", "l", "le", "lo", "cell", "link", "co", "lines", "page", "inline", "unit", "out", "key", "comment", "col", "input", "range", "b", "n", "v", "pe", "pin", "step", "header", "data", "object", "source", "group", "se", "ne", "type", "frame", "parse", "name", "sync", "tail", "d", "pos", "entry"], "x": ["ex", "l", "inter", "ip", "z", "out", " X", "xxx", "n", "b", "xx", "v", "_", "data", "xf", "xy", "xi", "int", "xc", "d", "id", "m", "wx", "time", " xp", "rx", "num", "row", "ct", "ix", "e", "xs", "h", "y", "f", "code", "q", "www", "X", "number"], "result": ["cur", "text", "new", "page", "obj", "case", "final", "error", "valid", "df", "complete", "ri", "exit", "ge", "found", "su", "data", "duration", "uri", "xi", "default", "compl", "dict", "entry", "m", "ret", "err", "success", "val", "res", "response", "match", "str", "grade", "our", "spec", "status", "report", "counter", "diff"]}}
{"code": " \n  def ispal(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  def ispalsq(n):\n      sqrt = int(math.sqrt(n) + .01)\n      if sqrt ** 2 != n:\n          return False\n      return ispal(n) and ispal(sqrt)\n  \n  def search(s, l, idx):\n      if l % 2 == 0:\n          m = s + s[::-1]\n      else:\n          m = s[:-1] + s[::-1]\n      assert ispal(m)\n      n = int(m) ** 2\n      if not ispal(n):\n          return 0\n  \n      r = 1 if (a <= n <= b) else 0\n      for i in xrange(idx, len(s)):\n          s2 = list(s)\n          s2[i] = str(int(s2[i])+1)\n          s2 = ''.join(s2)\n          r += search(s2, l, i)\n      return r\n  \n  \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          a, b = map(int, f.readline().split())\n  \n          total = 0\n          for l in xrange(1, 150):\n              if 10 ** (l-1) > b:\n                  break\n              total += search(\"1\" + \"0\" * ((l-1)/2), l, 0)\n          print \"Case #%d: %d\" % (_t+1, total)\n  \n", "substitutes": {"n": ["un", "j", "z", "u", "mn", "nu", "v", "node", "h", "nw", "np", "net", "ne", "ln", "name", "nor", "k", "on", "d", "p", "na", "dn", "ns", "x", "num", "N", "yes", "o", "nb", "e", "Ns", "names", "an", "nn", "nc", "no", "cn", "en", "y", "len"], "s": ["sa", "tests", "sh", "o", "ans", "xs", "h", "y", "string", "c", "g", "sb", "strings", "si", "values", "j", "sets", "ses", "se", "qs", "words", "ns", "x", "os", "ls", "ssl", "w", "gs", "small", "es", "ins", "u", "eps", "states", "ms", "source", "cs", "parts", "ds", "d"], "sqrt": ["qrate", "integrate", " sqrot", "sqrate", "shr", "dqRT", "sqrot", "qnt", "squrot", "dqnt", "dqrot", "sqnt", "integRT", "dqrt", " sqrate", "qrot", "shnt", "shRT", " sqr", "integr", "shrot", "qRT", "qrt", " sqnt", "squRT", "sqr", "integrt", "sqRT", " sqRT", "shrt", "squnt", "qr", "squrt"], "l": ["le", "j", "z", "size", "pl", "u", "url", "col", "v", "lp", "lt", "count", "dl", "int", "ln", "k", "li", "al", "d", "fl", "p", "limit", "list", "x", "lis", "tl", "o", "line", "length", "lin", "e", "ol", "il", "ls", "lu", "h", "len", "y", "ml", "ul"], "idx": ["idex", "idy", "midz", "idexs", "idz", " idv", "midx", "idxs", "Idx", "midv", "idey", " idy", "Idz", "midxs", "Idv", "idv", " idxs", "Idxs", "Idy", " idz", "idez"], "m": ["sm", "mm", "j", "z", "size", "u", "mr", "mn", "ms", "v", "im", "md", "M", "int", "k", "tm", "d", "cm", "p", "mc", "x", "mi", "fm", "mu", "ym", "o", "mo", "e", "hm", "an", "h", "nm", "y", "len", "rm", "q", "c", "ma", "g", "dm"], "r": ["ir", "j", "z", "ur", " R", "rb", "u", "run", "mr", "right", "url", "range", "pr", "v", "array", "all", "rg", "function", "arr", "k", "nr", "ro", "d", "p", "re", "cr", "trace", "lr", "err", "er", "x", "res", "str", "ru", "rev", "sr", "result", "e", "self", "h"], "i": ["ai", "ip", "j", "ij", "z", "ji", "eni", "u", " I", "ri", "I", "v", "qi", "fi", "ui", "ori", "yi", "left", "it", "phi", "int", "xi", "ie", "name", "k", "bi", "li", "ei", "d", "id", "p", "multi", "iu", "list", "x", "ni", "num", "pi", "di", "mi"], "s2": ["S62", "a8", "s1", "ss5", " s0", "sestwo", "i8", "s5", "psII", " s1", "p3", "a2", "SII", "ps62", "es62", "c8", "es2", "ss2", "p8", "l0", "sII", " s5", "c1", "ssII", "Stwo", "l5", " s6", " sII", "ss0", "c0", "s0", "ps2", "i2", "ses2", "ss6", "mtwo", "p1", "stwo", "s8", "m62"], "f": ["fun", "ff", "uf", "z", "fore", "df", "feed", "u", "fi", "sf", "v", "fd", "inf", "found", "full", "fe", "fen", "fc", "fb", "tf", "function", "fl", "d", "body", "p", "bf", "fx", "file", "form", "handler", "fr", "x", "o", "io", "fin", "e", "conf", "buff", "h", "fw"], "fn": ["rl", "fun", "format", "ren", "FN", "pn", "src", "loc", "path", "fi", "sf", "qt", "fd", "orn", "thin", "wl", "full", "fe", "conn", "txt", "unc", "fen", "fc", "bin", "kn", "np", "fil", "ln", "function", "name", "func", "filename", "fl", "fat", "wt", "p", "bf", "file", "dn", "fr"], "t": ["j", "z", "u", "v", "qt", "now", "ot", "tt", "int", "type", "rt", "d", "pos", "p", "x", "ta", "tp", "tz", "tl", "ty", "o", "length", "offset", "e", "len", "y", "start", "pt", "L", "c", "T", "dt", "at", "ts", "nt", "test"], "_t": ["_n", "_tt", "_T", "_b", " _T", " _l", "_l", " _tt", " _b", " _n"], "a": ["aa", "ai", "wa", "sta", "ab", "z", "alpha", "u", "va", "am", "oa", "ba", "au", "v", "sa", "A", "all", "k", "aw", "ga", "d", "ae", "p", "x", "pi", "ta", "o", "ac", "offset", "da", "la", "e", "an", "ca", "ad", "y", "ar", "c", "ma", "w"], "b": ["bar", "j", "ab", "z", "abb", "bl", "u", "bb", "v", "ba", "db", "next", "fb", "batch", "k", "bi", "d", "be", "p", "bf", "bc", "bs", "binary", "x", "num", "mb", "auto", "o", "length", "bot", "lb", "nb", "bound", "e", "base", "cb", "h", "y", "c", "number"], "total": ["otal", "ALL", "pl", "key", "au", "scale", "all", "chapter", "multi", "id", "ta", "offset", "la", "ma", "complete", "iter", "valid", "value", "percent", "partial", "next", "base", "tax", "no", "number", "done", "nt", "last", "error", "found", "tt", "meta", "toc", "eta", "part", "fat", "current", "cat", "num", "gap"]}}
{"code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          ns = map(int, f.readline().split())\n          n = ns[0]\n          s = ns[1]\n          p = ns[2]\n          assert len(ns) == n + 3\n          scores = ns[3:3+n]\n  \n          sure = 0\n          if_surprising = 0\n          for x in scores:\n              not_surprising = (x + 2) / 3\n              is_surprising = (x + 4) / 3\n              if not_surprising >= p:\n                  sure += 1\n              elif (2 <= x <= 28) and is_surprising >= p:\n                  if_surprising += 1\n          print \"Case #%d: %d\" % (_t+1, sure + min(if_surprising, s))\n", "substitutes": {"f": ["l", "ff", "uf", "rf", "df", "feed", "u", "i", "iter", "fi", "sf", "b", "v", "fd", "r", "inf", "fe", "fen", "fc", "xf", "fb", "tf", "d", "body", "bf", "m", "fx", "file", "arf", "form", "fr", "handler", "o", "io", "e", "lf", "buff", "h", "fw", "af"], "fn": ["typ", "fun", "format", "ren", "FN", "loc", "path", "fi", "b", "sf", "fd", "flat", "wl", "full", "fil", "unc", "txt", "fen", "fc", "wn", "kn", "fb", "source", "tf", "function", "name", "ln", "func", "filename", "fl", "wt", "fat", "bf", "file", "form", "dn", "syn", "fm", "o", "fin"], "t": ["l", "tc", "j", "z", "size", "i", "ti", "lt", "b", "v", "qt", "ot", "tt", "tu", "int", "type", "tf", "k", "tm", "d", "m", "ta", "tz", "num", "tp", "ty", "o", "tn", "e", "temp", "y", "len", "start", "pt", "c", "T", "dt", "at", "ts", "nt"], "_t": ["_n", "_f", "_tt", " _tp", "_tp", "longtt", "longt", " _tt", "longp", " _p", "_p", " _f", " _n"], "ns": ["b", "tests", "int", "ums", "nis", "nets", "breaks", "outs", "cells", "nas", "posts", "nb", "names", "Ns", "xs", "nc", "y", "c", "vals", "strings", "lines", "nos", "codes", "ids", "np", "aps", "sync", "ains", "qs", "words", "bs", "abs", "details", "os", "sp", "ls", "ips", "gs", "nt", "es"], "n": ["l", "j", "z", "i", "pn", "u", "nu", "b", "v", "count", "np", "net", "ne", "k", "d", "m", "na", "ni", "num", "pi", "N", "o", "ct", "nb", "e", "Ns", "nc", "nn", "cn", "no", "h", "y", "en", "sn", "c", "number", "w", "nl", "nt", "ny"], "s": ["l", "sec", "z", "size", "sys", "ins", "u", "i", "sets", "ss", "r", "b", "v", "su", "sa", "less", "cs", "stats", "sv", "sync", "ds", "d", "m", "sg", "tp", "south", "o", "sb", "state", "os", "spec", "e", "ps", "ws", "sp", "xs", "ls", "an", "y", "a"], "p": ["P", "l", "ip", "j", "z", "pp", "py", "pn", "i", "u", "lp", "b", "pm", "cp", "v", "pr", "r", "op", "hp", "python", "pe", "jp", "np", "d", "m", "wp", "pi", "tp", "bp", "o", "up", "pc", "ap", "e", "ps", "sp", "pre", "h", "y", "q"], "scores": ["oscopes", "oscurs", "SCores", "oscamples", "Scopes", "Scores", "scurs", "scopes", " scors", " scored", "incores", "scamples", "Scamples", "squopes", "scors", "scuries", "oscores", "squurs", "incors", "scored", "squores", " scuries", "incored", "SCored", "SCuries", "incuries", "Scurs", "SCors", "squamples"], "sure": ["know", "asty", "shape", "notice", "tri", " surely", "clear", "care", "happy", "py", "necessary", "case", "mad", "core", "say", "only", "now", "cum", "su", "sam", "msg", "sa", "stuff", "stable", "raw", "live", "chance", "sufficient", "store", "maybe", "ave", "sim", "parse", "sync", "simple", "um", "sg", "success", "Sure", "yes"], "if_surprising": ["if_surprisingly", "if_simprising", "if_simessing", "if_Surprise", "ifnotsurprises", "if_curprising", "if_suressing", "ifnotsurprise", "if_urprisingly", "if_simprise", "if_uressing", "if_curprises", "ifnotcurprises", "if_surprise", "ifnotsurprisingly", "ifnotcurprising", "if_Surprisingly", "if_urprise", "if_surprises", "ifnotcurprise", "ifnotsurprising", "if_curprise", "ifnotcurprisingly", "if_Surprises", "if_curprisingly", "if_Surprising", "if_Suressing", "if_urprising", "if_simprises", "if_urprises"], "x": ["ex", "l", "i", "b", "xx", "inf", "int", "sex", "id", " xp", "rx", "o", "ct", "xs", "nc", "h", "y", "c", "px", "j", "case", " num", "cross", "python", "xy", "xi", "m", "time", "ix", "xxxxxxxx", " index", "code", "X", "w", "xp", "ng", "index", "nt", "u", "dx"], "not_surprising": ["not_urprise", "not_serprises", "not_surpiring", "not_urprises", "not_suppprising", "not_serpiring", "not_surprisingly", "not_serprise", "not_suppvey", "not_surprise", "not_servey", "not_surprises", "not_Surprisingly", "not_Surprises", "not_serprisingly", "not_Surprising", "not_Surprise", "not_suppprises", "not_urvey", "not_supppiring", "not_serprising", "not_urpiring", "not_urprisingly", "not_survey", "not_urprising"], "is_surprising": ["is_urprises", "is_urprising", "is_Suritative", "is_Surprising", "is_urprise", "is_suppprises", "is_purprise", "is_surprise", "is_Surprise", "is_uritative", "is_surprises", "is_purprising", "is_surprisingly", "is_puritative", "is_suppprising", "is_purprises", "is_suritative", "is_urprisingly", "is_Surprisingly", "is_suppprisingly", "is_Surprises", "is_suppprise"]}}
{"code": " \n  \n  def readfile(file):\n    \"\"\"\n      input:\n  \n  \t\tT (number of test cases)\n  \n  \t\tA B\n  \n    \"\"\"\n  \n    tests = []\n  \n    T = int(file.readline().strip())\n  \n    for i in xrange(T):\n  \t\ttest = {}\n  \n  \t\tline = file.readline().strip()\n  \t\tparts = line.split(\" \")\n  \n  \t\tif len(parts) != 2:\n  \t\t\tprint \"HORRIBLE ERROR IN TEST CASE %d\" % (i+1,)\n  \t\t\treturn None\n  \n  \t\ttest['A'] = int(parts[0])\n  \t\ttest['B'] = int(parts[1])\n      \n  \t\ttests.append(test)\n  \n    return tests\n  \n  def isPalindrome(s):\n  \t\"\"\"\n  \t\tIs s a palindrome.\n  \n  \t\tS must be a string.\n  \t\"\"\"\n  \n  \tl = len(s)\n  \n  \tif (l % 2) == 0:\n  \t\tfrontHalf = s[0:l/2]\n  \t\tbackHalf = s[l/2:]\n  \telse:\n  \t\tfrontHalf = s[0:(l-1)/2]\n  \t\tbackHalf = s[(l+1)/2:]\n  \n  \tbackHalf = backHalf[::-1]\n  \n  \tif frontHalf == backHalf:\n  \t\treturn True\n  \telse:\n  \t\treturn False\n  \n  def isFairAndSquare(n):\n  \n  \tsqrtN = int(math.sqrt(n))\n  \n  \tif (sqrtN * sqrtN) != n:\n  \t\treturn False\n  \n  \tif not isPalindrome(str(n)):\n  \t\treturn False\n  \n  \tif not isPalindrome(str(sqrtN)):\n  \t\treturn False\n  \n  \treturn True\n  \n  def run(test):\n  \t\"\"\"\n  \t\tRun a test and return output.\n  \t\"\"\"\n  \n  \tcount = 0\n  \n  \tfor i in xrange(test['A'], test['B'] + 1):\n  \t\tif isFairAndSquare(i):\n  \t\t\tcount = count + 1\n  \n  \treturn count\n  \n  \ti = int(math.sqrt(test['A']))\n  \n  \tif (i * i) < test['A']:\n  \t\ti = i + 1\n  \n  \twhile i < test['B']:\n  \t\tif not isPalindrome(str(i)):\n  \t\t\ti = i + 1\n  \t\t\tcontinue\n  \n  \t\ts = i * i\n  \n  \t\tif s <= test['B']:\n  \t\t\tif isPalindrome(str(s)):\n  \t\t\t\tcount = count + 1\n  \t\telse:\n  \t\t\tbreak\n  \n  \t\ti = i + 1\n  \n  \treturn \"%s\" % (count, )\n  \n  file = open(sys.argv[1], \"rt\")\n  \n  tests = readfile(file)\n  \n  file.close()\n  \n  case = 1\n  \n  for test in tests:\n    result = run(test)\n    print \"Case #%d: %s\" % (case, result)\n    case = case + 1\n", "substitutes": {"file": ["feed", "path", "input", "connection", "model", "stream", "live", "handle", "function", "filename", "buffer", "phase", "handler", "ile", "table", "io", "rule", "h", "string", "fp", "console", "log", "section", "le", "un", "per", "py", "set", "data", "profile", "fil", "angle", "do", "time", "settings", "x", "FILE", "local", "module", "base"], "tests": ["t", "false", "stats", "breaks", "utils", "objects", "steps", "cells", "fits", "checks", "names", "XXX", " files", "strings", "suits", "videos", "lines", "attacks", "sets", "reports", "reads", "true", "errors", "rules", "users", "tips", "settings", "details", "its", "tools", "ls", "items", "packs", "files", "ests", "amples", "groups", "null", "sections", "it"], "T": ["P", "section", "Case", "TS", "Size", "D", "Z", "t", "H", "I", "M", "slice", "A", "Test", "total", "p", "Time", "time", "G", "x", "U", "N", "TN", "length", "W", "O", "E", "C", "Length", "S", "V", "f", "L", "X", "number", "TT", "Y", "Count", "B", "c"], "i": ["iw", "key", "ti", "t", " I", "b", "ih", "qi", "phi", "uri", "int", "init", "multi", "id", "o", "io", "iq", "you", "h", "y", "start", "c", "g", "ini", "ci", "si", "image", "j", "eni", "im", "r", "xi", "bi", "m", "time", "inner", "x", "ni", "my", "ix"], "test": ["address", "key", "t", "feed", "rest", "path", "input", "static", "create", "model", "scale", "all", "int", "master", "write", "train", "seed", "host", "list", "read", "table", "val", "ray", "fail", "rule", "h", "start", "tmp", "switch", "c", "g", "est", "root", "section", "hess", "tri", "target", "py", "contract", "valid"], "line": ["LINE", "log", "le", "section", "cell", "strip", "band", "lines", "page", "inline", "unit", " lines", "comment", "server", "url", "shell", "header", "slice", "chain", "source", "style", "live", "parse", "sync", "part", "side", "phase", "entry", "block", "cl", "response", "str", "row", "lin", "rule", "lf", "status", "sample", "letter", "word"], "parts": ["piece", "arts", "objects", "list", "bis", "steps", "cells", "Parts", "posts", "pins", "ples", "dates", "planes", "params", "section", "lines", "py", "valid", "rots", "data", "partial", "array", "ping", "blocks", "words", "ns", "settings", "x", "details", "base", "series", "ls", "items", "points", "files", "patch", "groups", "sections", "letters", "slice"], "s": ["aces", "sports", "t", "b", "stats", "sh", "bis", "service", "o", "cells", "comments", "ans", "xs", "ments", "h", "y", "start", "string", "c", "g", "sb", "strings", "si", "lines", "size", "sets", "say", "ses", "r", "sf", "js", "ves", "less", "ies", "storage", "sync", "blocks", "m", "ns", "settings"], "l": ["rl", "le", "log", "lo", "z", "pl", "bl", "jl", "t", "u", "loc", "lp", "b", "v", "wl", "dl", "left", "ell", "lit", "ln", "ly", "fl", "li", "lv", "d", "p", "al", "m", "list", "o", "length", "lb", "lin", "la", "ol", "lf", "e", "ls", "lu", "h"], "frontHalf": [" frontMade", "baseHalf", "bottomHalf", " frontWall", "backWall", "frontMade", "behindSide", "frontSide", "bottomSide", " frontWay", "behindHalf", "baseSide", "baseWay", "backSide", "behindWall", "backMade", "backWay", " frontSide", "bottomMade", "frontWall", "frontWay"], "backHalf": [" backPart", "frontPart", "BackPart", "Backhalf", "baseHalf", "fronthalf", "backWall", "frontMade", "homeMade", "basePart", "backPart", "backhalf", "BackHalf", "homeHalf", " backhalf", " backMade", "backMade", "homehalf", "baseWall", "frontWall", " backWall"], "n": ["nv", "j", "new", "z", "t", "u", "pn", "nu", "b", "v", "node", "r", "nw", "conn", "np", "net", "ne", "ln", "nor", "k", "d", "p", "m", "na", "dn", "nin", "ns", "x", "ni", "num", "nil", "N", "o", "normal", "native", "nb", "e", "nc", "no", "nn"], "sqrtN": ["sqrtA", "sqrectM", "sqRTC", " sqrM", "squrotN", "sqretC", "sqntC", "sqntL", "squrotM", "sqrotNs", "sqrotA", "qRTL", "sqrotN", "sqrL", "sqntA", "sqratL", " sqrN", "qrtC", " sqrtB", " sqrtC", "sqRTN", "sqratN", "sqrotn", "sqretB", "sqRTL", "sqrB", "sqrtL", "sqratn", "qrtL", "sqntB", "squrtN", " sqrtn", " sqrtM", "squrotA", "sqrtC", "qRTN", " sqrn", " sqrL", "sqrN", "sqrNs"], "count": ["key", "process", "b", "shift", "all", "init", "handle", "int", "name", "multi", "id", "list", "coll", "h", "counter", "start", "first", "c", "string", "Count", "g", "log", "size", "label", "core", "old", "say", "group", "next", "low", "race", "mini", "cache", "a", "code", "number", "end", "index", "nt", "last"], "case": ["exc", "section", "Case", "config", "size", "example", "key", "error", "unit", "mode", "path", "loop", "data", "call", "trial", "Test", "type", "app", "name", "id", "p", "list", " cases", "match", "cases", "temp", "diff", "tmp", "switch", "catch", "use", "instance", "seq", "index"], "result": ["new", "page", "final", "desc", "key", "comment", "r", "found", "su", "data", "db", "acc", "entry", "round", "ret", "event", "list", "success", "table", "err", "val", "res", "response", "match", "search", "row", "status", "report", "var", "diff", "output", "Result", "results", "date"]}}
{"code": " \n  def readfile(filename):\n  \t\"\"\"\n  \t\tThe first line of the input gives the number of test\n  \t\tcases, T. T test cases follow. Each test case consists of\n  \t\ta single line containing integers separated by single\n  \t\tspaces. The first integer will be N, the number of\n  \t\tGooglers, and the second integer will be S, the number\n  \t\tof surprising triplets of scores. The third integer will\n  \t\tbe p, as described above. Next will be N integers ti:\n  \t\tthe total points of the Googlers.\n  \t\"\"\"\n  \n  \tfile = open(filename, \"rt\")\n  \n  \tretval = {}\n  \n  \tT = int(file.readline().strip())\n  \tretval['T'] = T\n  \n  \ttests = []\n  \n  \tfor i in xrange(T):\n  \t\tline = file.readline().strip()\n  \n  \t\tparts = line.split(\" \")\n  \n  \t\tN = int(parts[0])\n  \t\tS = int(parts[1])\n  \t\tp = int(parts[2])\n  \t\tt = []\n  \n  \t\tfor j in xrange(N):\n  \t\t\tt = t + [int(parts[3 + j]), ]\n  \n  \t\ttest = { 'N' : N, 'S': S, 'p' : p, 't' : t }\n  \t\ttests = tests + [test, ]\n  \n  \tretval['tests'] = tests\n  \treturn retval\n  \n  def spread(triplet):\n  \treturn max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))\n  \n  def bestresult(triplet):\n  \tif triplet:\n  \t\treturn max(triplet)\n  \treturn 0\n  \n  def getcombos(points):\n  \t\"\"\"\n  \t\tReturns ([unsurprising possibilities, ], [surprising possibilities])\n  \t\"\"\"\n  \n  \tunsurps = []\n  \tsurps = []\n  \n  \tavg = points / 3.0\n  \n  \tavg = int(avg)\n  \n  \ttested = []\n  \n  \tfor i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\tfor j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\t\tfor k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\t\t\tif (i + j + k) != points:\n  \t\t\t\t\tcontinue\n  \n  \t\t\t\tscores = (i,j,k)\n  \t\t\t\tscores = sorted(scores)\n  \n  \t\t\t\tif scores in tested:\n  \t\t\t\t\tcontinue\n  \t\t\t\ttested.append(scores)\n  \n  \t\t\t\ts = spread((i,j,k))\n  \n  \t\t\t\tif (s < 2):\n  \t\t\t\t\tunsurps.append(scores)\n  \t\t\t\telif (s == 2):\n  \t\t\t\t\tsurps.append(scores)\n  \t\t\t\telse:\n  \t\t\t\t\tcontinue\n  \n  \treturn (unsurps, surps)\n  \n  def getbesttriplet(triplets):\n  \tbest = None\n  \n  \tfor i in triplets:\n  \t\tif best:\n  \t\t\tif (bestresult(i) > bestresult(best)):\n  \t\t\t\tbest = i\n  \t\telse:\n  \t\t\tbest = i\n  \n  \treturn best\n  \t\n  \n  def getmulticombos(peeps):\n  \t\"\"\"\n  \t\tReturn the best surprising and non-surprising possibility for\n  \t\teach person.\n  \t\"\"\"\n  \n  \tret = []\n  \n  \tfor p in peeps:\n  \t\tu,s = getcombos(p)\n  \n  \t\tbestu = getbesttriplet(u)\n  \t\tbests = getbesttriplet(s)\n  \n  \t\tret.append((bestu, bests))\n  \n  \treturn ret\n  \n  def getbestresults(scores, best, numsur):\n  \t\"\"\"\n  \t\tFigure out the maximum number of people that could have gotten\n  \t\ta single score >= best.  Limited to choosing only numsur surprising\n  \t\ttriplets.\n  \t\"\"\"\n  \n  \tpeeps = getmulticombos(scores)\n  \n  \tcount = 0\n  \tsurcount = 0\n  \n  \tfor p in peeps:\n  \t\tif (bestresult(p[0]) >= best):\n  \t\t\tcount = count + 1\n  \t\telif ((bestresult(p[1]) >= best) and (surcount < numsur)):\n  \t\t\tcount = count + 1\n  \t\t\tsurcount = surcount + 1\n  \n  \treturn count\n  \n  def process(test):\n  \tN = test['N']\n  \tS = test['S']\n  \tp = test['p']\n  \tt = test['t']\n  \n  \treturn getbestresults(t, p, S)\n  \n  data = readfile(\"B-small-attempt0.in\")\n  \n  for i in xrange(data['T']):\n  \ttest = data['tests'][i]\n  \n  \tresult = process(test)\n  \n  \tprint \"Case #%d: %d\" % (i+1, result)\n", "substitutes": {"filename": ["rl", "section", "ppa", "knife", "folder", "size", "database", "journal", "figure", "description", "url", "path", "sf", "connection", "fd", "Filename", "slice", "dll", "python", "password", "fil", "profile", "uri", "kn", "name", "phrase", "document", "binary", "nil", "FILE", "prefix", "subject", "application", "download", "tools", "il", "queue", "email", "f", "jet"], "file": ["le", "l", "log", "view", "reader", "wave", "page", "folder", "per", "feed", "iter", "pool", "server", "url", "File", "path", "pe", "bo", "data", "full", "port", "stream", "db", "handle", "angle", "name", "parse", "function", "parent", "buffer", "phase", "work", "die", "handler", "pipe", "ile", "table", "mail", "lock", "FILE"], "retval": ["reteval", "Retvals", "retvalue", "Retval", "rtvals", " retvalue", "rtvalue", " retVal", "retvals", "Reteval", "returnret", "retret", "experval", " reteval", "attVal", "Retvalue", "experVal", "rtval", "attvalue", "attv", "returnVal", "rteval", "attval", "retv", "returnval", "returnvals", " retret", "rtv", "rtVal", "Retv", "experret", " retv", "expervals", "retVal", "RetVal", " retvals"], "T": ["P", "J", "Q", "DT", "TS", "Z", "D", "Size", "TH", "GT", "H", "I", "TX", "TR", "M", "A", "NT", "TE", "Test", "TC", "Ts", "TG", "WT", "TF", "Time", "TA", "G", "TN", "length", "W", "O", "Total", "E", "C", "Length", "V", "L", "X", "TB", "TT"], "tests": ["docs", "features", "values", "lines", "TS", "example", "sections", "forms", "path", "seq", "reports", "tags", "txt", "stats", "fts", "tops", "breaks", "events", "tes", "words", "rules", "testers", "tips", "settings", "sequence", "details", "ches", "devices", "times", "ties", "steps", "tty", "its", "length", "pieces", "cases", "suits", "runs", "terms", "posts"], "i": ["l", "iw", "ti", "b", "qi", "phi", "int", "ei", "id", "o", "io", "jit", "iq", "h", "y", "c", "g", "ini", "ci", "si", "ij", "eni", "im", "ish", "xi", "bi", "m", "sci", "x", "ni", "ani", "ix", "hi", "ice", "a", "gi", "I", "ui", "ori", "ic"], "line": ["strip", "log", "l", "le", "section", "cell", "text", "LINE", "lines", "page", "inline", "unit", "out", "comment", "server", "url", "header", "slice", "data", "profile", "chain", "source", "item", "handle", "parse", "sync", "part", "day", "side", "phase", "entry", "block", "cl", "str", "response", "row", "lin", "rule", "lf", "word"], "parts": ["section", "format", "features", "lines", "piece", "bits", "args", "sections", "py", "ins", "forms", "cats", "letters", "data", "partial", "relations", "arts", "members", "tops", "part", "ands", "ds", "pos", "ants", "words", "qs", "bytes", "lists", "objects", "component", "ns", "list", "headers", "details", "pi", "ches", "steps", "cells", "places", "pieces"], "N": ["P", "J", "Q", "Na", "Out", "Size", "D", "Z", "NI", "H", "n", "NC", "RN", "M", "NA", "A", "Len", "NT", "NG", "SN", "NB", "NE", "Nat", "DN", "New", "G", "No", "U", "NL", " n", "Ni", "Ns", "W", "O", "One", "Num", "Sn", "E", "OS", "Ne"], "S": ["P", "J", "Q", "Size", "D", "Sign", "Sc", "n", "I", "M", "SU", "A", "se", "SN", "SA", "Sp", "SK", "SH", "Sl", "G", "U", "Sa", "SE", "St", "Ns", "W", "O", "Sn", "SP", "C", "V", "Si", "L", "X", "Y", "K", "B", "F", "SI", "PS"], "p": ["P", "J", "l", "ip", "z", "pp", "per", "py", "eps", "n", "r", "b", "v", "pressure", "pr", "pe", "lp", "M", "cp", "np", "part", "d", "pos", "m", "wp", "po", "sh", "x", "pi", "tp", "bp", "pad", "Pa", "pc", "ap", "ps", " P", "sp", "pg", "pre"], "t": ["P", "l", "tc", "z", "target", "n", "b", "v", "ot", "tt", "tu", "port", "trial", "it", "total", "type", "tf", "part", "wt", "rt", "d", "m", "trace", "time", "template", "tips", "table", "x", "ta", "tp", "o", "tw", "ant", "ty", "ap", "e", "temp", "tools", "h", "testing"], "j": ["J", "uj", "l", "b", "pr", "qi", "int", "ne", "sh", "o", "io", "h", "y", "pt", "c", "g", "si", "section", "adj", "ij", "jl", "im", "pm", "js", "se", "xi", "m", "x", "jo", "jj", "sp", "w", "aj", "br", "iv", "ke", "ui", "ik", "ie", "d"], "test": ["step", "trip", "ester", "section", "tri", "target", "py", "case", "valid", "unit", "example", "server", "value", "v", "flat", "tt", "data", "cross", "trial", "port", "Test", "type", "train", "testers", "sect", "track", "table", "match", "tty", "search", "ct", "th", "fail", "tx", "pattern", "temp", "testing", " testing", "check", "script"], "triplet": ["triple", "dipper", "prompper", "traple", "complet", "diple", "roupped", "Tript", "trips", "rouple", "Triplet", "tripper", "comple", "promps", "rouplets", "diplets", "throplet", " triple", "traplets", " trips", "tript", "rouplet", "Tripped", "traplet", " tript", "Trips", "trapper", "trapt", "Triplets", " tripper", "tuple", "tups", "thropper", "trict", "tripped", "Trict", "compped", "dipt", "throplets", "Triple"], "points": ["windows", "grades", "breaks", "objects", "point", "steps", "cells", "reset", "posts", "offs", "pins", "dates", "planes", "start", "Point", "pt", "params", "multiple", "lines", "out", "amps", "data", "words", "tips", "notes", "chains", "x", "poly", "holes", "pots", "months", "index", "end", "groups", "Points", "mag", "random", "eps", "slice", "trial"], "unsurps": ["untype", "Unsurpe", "untypped", "unwrape", "unserpe", "untrippings", "Unwrap", "unsurplet", "UnSurppings", "unserplet", "UnSurp", "unsurppings", "Unsurps", "UnSurpps", "Unwrape", "unsurp", "Unsurp", "unserp", "unserpped", "UnSurps", "unwraplet", "untripps", "untrips", "munserplet", "Unsurppings", "unSurp", "Unsurpped", "unsurpps", "unSurppings", "untyps", "munsurp", "munsurps", "unwrappings", "munsurplet", "munserps", "unsurpped", "munserp", "unwraps", "unwrapped", "Unwraps"], "surps": ["surples", "trip", "strips", "trips", "surplets", "stripps", "urples", "sup", "urplets", "urppers", "supps", "Surplets", "urps", "supoints", "urp", "traps", "sups", "trap", "Surps", "surpoints", "urpps", "Surpoints", "Surp", "simppers", "trapps", "surp", "surppers", "Surples", "Surpps", "trapoints", "strippers", "triples", "surpps", "simps", "simpps", "simples", "striples"], "avg": ["afge", "afga", "abc", "ravgar", " avgn", "abp", "svge", "AVG", "AVc", "ajgm", "avc", "apga", "avgo", "ravgz", "svga", "svgb", "avergb", "afG", " avgb", "afg", "avp", "aggo", "AvG", "afgn", "svgar", "AVgn", "ajgz", "ajg", "avgm", "agga", "avgs", " avmg", "AVga", "agG", "ajgar", "evn", "svgz", "agg", "abG", "afp"], "tested": ["handled", "videos", "closed", "rounded", "raped", "Testing", "aligned", "checked", "selected", "trained", "connected", "valid", "rolled", "opened", " Tests", "found", "actual", "fitted", "trial", " scored", "lost", "stable", "graded", "Test", "total", "classified", "protected", "breaks", "supported", "marked", " failed", "rated", " skipped", "testers", "worst", "fetched", "ranked", "proven", "times", "ored"], "k": ["ak", "ip", "kk", "z", "key", "iv", "ki", "dk", "max", "ke", "n", "ks", "b", "r", "v", "ku", "ijk", "pe", "ko", "ik", "uk", "kl", "kn", "tk", "ch", "d", "id", "ok", "m", "kg", "ka", "ky", "mk", "x", "pi", "point", "o", "kick", "h", "y"], "scores": ["scriptorer", "cores", " scorer", "SCores", "Scores", " Scorer", "sporer", "spopes", "missore", "locopes", "escenses", "scriptores", "scopes", "Scors", " scors", "scales", "accours", "SCore", " score", "locorer", " Scores", " Scors", " scoves", " scours", "scenses", "locores", "missores", "cales", "scors", " scales", "copes", "Score", "scriptors", "accores", "spales", "locales", "spors", "scours", "escors", "escopes"], "s": ["l", "es", "sq", "lines", "services", "sports", "ins", "sets", "ss", "states", "sup", "n", "sf", "ses", "v", "js", "su", "less", "hours", "cs", "sv", "sync", "ds", "side", "us", "words", "sg", "ns", "sym", "charges", "details", "south", "ches", "bis", "seconds", "o", "sb", "space", "ops", "e"], "triplets": ["dipps", "dropps", " triples", "trips", "Triplet", "polyps", "diplets", "tripps", "polyples", "traplets", " trips", "tript", "traps", "drops", "trapt", "Triplets", "trapps", "dropt", "dips", "Triples", "dipt", "droplets", "polyplets", "triples", "polyplet", "Trips"], "best": [" closest", "hess", "new", "suggest", "null", "final", "masters", "valid", "right", "value", "largest", " winner", "pop", "stable", "live", "all", "hest", "default", "master", "peak", "name", "good", "rank", "std", "home", "worst", "round", "tips", "last", "success", "list", "highest", "point", "match", "remote", "top", "end", "leader", "aster", "self"]}}
{"code": " \n  class Test(unittest.TestCase):\n  \tdef test_1(self):\n  \t\tself.assertEqual(main(1, 4), 2)\n  \tdef test_2(self):\n  \t\tself.assertEqual(main(10, 120), 0)\n  \tdef test_3(self):\n  \t\tself.assertEqual(main(100, 100000000000000), 2)\n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def main(M, N):\n  \tfns = 0\n  \tnum = M\n  \tmaior = math.sqrt(N)\n  \tint_maior = 0\n  \t\n  \tif maior.is_integer():\n  \t\tint_maior = int(maior) - 1\n  \t\tif fair(N):\n  \t\t\tif fair(int(maior)):\n  \t\t\t\tfns += 1\n  \telse:\n  \t\tint_maior = int(maior)\n  \t\t\n  \twhile int_maior >= 1:\n  \t\tif fair(int_maior):\n  \t\t\tquadrado = int_maior * int_maior\n  \t\t\tif quadrado >= M:\n  \t\t\t\tif fair(quadrado):\n  \t\t\t\t\tfns += 1\n  \t\tint_maior -= 1\n  \treturn fns\n  \n  def main2(M, N):\n  \tfns = 0\n  \tnum = M\n  \twhile num <= N:\n  \t\tresult = raiz(num)\n  \t\tif result:\n  \t\t\tif fair(num):\n  \t\t\t\n  \t\t\t\tif fair(result):\n  \t\t\t\t\tfns += 1\n  \t\tnum += 1\n  \treturn fns\n  \t\n  def fair(num):\n  \treturn str(num) == str(num)[::-1]\n  \t\n  def raiz(num):\n  \tresult = math.sqrt(num)\n  \tif result.is_integer():\n  \t\treturn int(result)\n  \telse:\n  \t\treturn False\n  \t\n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tN,M = [int(x) for x in sys.stdin.readline().split(' ')]\t\n  \t\tprint \"Case #%d: %d\" % (i + 1, main(N,M))\n", "substitutes": {"self": ["l", "ref", "eth", "connection", "driver", "function", "utils", "us", "host", "other", "cl", "proc", "github", "h", "ctx", "g", "instance", "root", "log", "case", "py", "me", "python", "func", "resp", "time", "go", "er", "client", "cache", "layer", "http", "w", "ng", "writer", "view", "error", "req", "node", "call"], "tCase": ["ttStep", "TCase", "ttCode", " tStep", "tcase", "TMatch", "btCase", "ttcase", "tCode", "tExample", "tStep", "Tcase", "tmCode", "ttBase", "tBase", " tCode", "btcase", "tmStep", "TExample", "tmCase", "btExample", " tBase", "tmBase", "tMatch", "ttExample", "ttCase", "btMatch", "ttMatch"], "M": ["P", "Q", "J", "MO", "EM", "Z", "D", "SM", "TM", "MU", "H", "n", "I", "Mi", "CM", "A", "NUM", "MM", "Mon", "FM", "AM", "MF", "MAN", "m", "DM", "MS", "Mo", "NM", "G", "MC", "U", "Man", "MX", "RM", "W", "OM", "O", "Num", "E", "NO"], "N": ["Q", "P", "Net", "J", "IN", "Na", "Z", "D", "Size", "ND", "H", "n", "I", "NC", "NA", "A", "NT", "Mon", "NUM", "Len", "NG", "NN", "NB", "NE", "m", "DM", "Mo", "NM", "NL", "G", "U", "MD", "No", "MC", "Wh", "Ni", "Ns", "W", "OM", "O"], "fns": ["fouts", "dfcs", "Fns", "Fls", "cfcs", "infns", "efnes", "cfsts", "fls", "Fds", "frites", "cfn", "fnets", "efns", "ofn", " fds", "efnets", "fcs", "ifcs", "efcs", "ufns", "bfns", " fnets", "fdouts", "ofaults", "cfls", "ifns", "ifsts", " frites", "fdns", "faults", "funls", "ofds", "ufn", "dfls", "fails", "ofails", "funcs", "funns", "fsts"], "num": ["loc", "lim", "am", "dim", "uri", "int", "init", "function", "name", "miss", "multi", "id", "nom", "umber", "NM", "nil", "mu", "dom", "offset", "nam", "nb", "mix", "nc", "nn", "known", "Num", "un", "valid", "mn", "value", "mon", "term", "true", " nu", "mom", "np", "begin", "m", "binary", "err"], "maior": ["maror", " maori", "mair", "hoajor", "masiro", "naior", "air", "aori", "hoolar", "etair", "aior", "hoiro", " maolar", "mmaori", "etaistor", "waoris", "maoris", "waior", "masior", "maolar", "nairo", "masir", "wairo", "maio", "maori", "waori", "mmaio", "mmairo", " mair", " maio", " maajor", " maror", "mmaior", "hoior", "airo", "mmaistor", "mmair", "mmaoris", "masori", "naio"], "int_maior": ["int_kaior", "int_dataor", "int_waor", "int_laajor", "int_dataior", "int_raori", "int2mmaior", "int_gaior", "int_maor", "int_haori", "int_gaajor", "int_madorge", "int_maorge", "int2maior", "int_mmaio", "int_laior", "int_kaori", "intsmaio", "int_masire", "int_maorr", "int_mmaore", "int_naira", "int_emaire", "int_laoire", "int_madior", "int_maajor", "int_laira", "int_mmaoris", "int_hairo", "intsmmaior", "int_waori", "int2mmaor", "int_maore", "int_masora", "int_mairo", "int_masore", "int_laio", "int_emaior", "int_haior", "int_madori"], "quadrado": ["quparao", "coarmao", "quadrad", " quadrabo", "coadrada", "qudratio", "quarrano", " qudrara", "quetrado", "quarmado", "quparados", "quarrado", "quarraco", " quetrabo", "quadrada", " qudraco", " quadratio", "qudrado", "quadratio", " quadraco", "quasiano", " quetrado", " quetrano", "coadrados", " quadrad", "quadrara", "quetrara", "quarrabo", "coadrao", "coarmados", "quparada", "quetrad", "quadrados", " qudrado", "quarado", "quarratio", "quasiado", "quetrabo", "quarmados", "quetratio"], "result": ["alpha", "desc", "false", "function", "master", "name", "rank", "runner", "val", "grade", "attr", "counter", "root", "case", "df", "valid", "mark", "rate", "r", "value", "term", "data", "true", "order", "begin", "compl", "ret", "err", "mask", "aster", "cache", "winner", "record", "math", "number", "done", "gi", "date", "end", "score"], "i": ["ip", "j", "ci", "z", "chi", " ip", "ib", "ti", " I", "ri", " ii", " l", "I", "im", "ih", "fi", "ui", "qi", "udi", " y", "ic", "yi", "phi", "uri", "ik", "int", "ie", "aci", "bi", "li", "d", "id", "hei", "p", "iu", "pi", "my", "mi", "di", " z"], "x": ["xb", "ex", "l", "z", "u", " X", "dx", "xe", "xxx", "xd", "xx", "v", "ux", " y", "xf", "xy", "int", "xi", " you", "sex", "xc", " XP", "k", "xxxx", "xes", "d", "id", "p", "wx", " xp", "rx", "xt", " c", "ix", "e", " cx", " xx", "xxxxxxxx", "xs", " XX"]}}
{"code": " \n  tCase = int(sys.stdin.readline())\n  \n  def alien(frases,case):\n  \t\n  \tcase = case.replace('(','[')\n  \tcase = case.replace(')',']')\n  \t\n  \tER1 = re.compile(case, re.I)\n  \tcount = 0\n  \tfor frase in frases:\n  \t\tif ER1.search(frase):\n  \t\t\tcount += 1\n  \treturn count\n  \n  \n  for i in xrange(tCase):\t\n  \tlinha = sys.stdin.readline().split()\n  \tP = int(linha[1])\n  \tT = int(linha[2])\n  \tlist = []\n  \tfor j in range (3,len(linha)):\n  \t\tlist.append(int(linha[j]))\n  \tlist.sort(reverse=True)\n  \trealT = T*3 - 2\n  \tsupT = realT - 2\n  \t\n  \tcount = 0\n  \tfor item in list:\n  \t\tif item >= realT:\n  \t\t\tcount += 1\n  \t\telif P > 0 and item >= supT and T >= 2:\n  \t\t\tcount += 1\n  \t\t\tP -= 1\n  \t\telif P > 0 and item >= realT and T == 1:\n  \t\t\tcount += 1\n  \t\t\tP -= 1\n  \t\telif T == 0:\n  \t\t\tcount += 1\n  \t\telse:\n  \t\t\tbreak\n  \t\t\n  \tprint \"Case #%d: %d\" % (i+1, count)\n  \t\n  \t\n  \n", "substitutes": {"tCase": ["TCase", "tTime", "ttCode", " tcase", "ttcase", "tcase", "lCase", "tfcase", "TTime", "tCode", "tfLoop", "tfCode", "Tcase", "lBase", "TBase", "TLoop", "tBase", "tfCase", "lcase", "ttLoop", " tBase", "ttCase", "TCode", "lTime", " tTime", "tLoop"], "frases": ["arrase", "frased", "brages", "arraces", "arrages", "Frases", "brased", " fraces", "irages", "brase", "brances", "iraces", "Fraces", "fraces", "irases", "brases", "irase", "frances", " frances", " frased", "frages", "Frances", "arrases", "Frased", "braces"], "case": ["address", "sea", "key", "ce", "rest", "character", "path", "chain", "ase", "name", "area", "ace", "file", "phone", "point", "line", "request", "rule", "test", "place", "when", "string", "c", "instance", "cast", "ride", "section", "shape", "size", "complete", "contract", "core", "project", "profile", "chance", "order", "choice", "phrase", "court", "fold"], "ER1": ["er1", " ER2", " EROne", "AR2", " ER3", "EROne", "ER2", "BER0", "BER2", "er2", " ER0", "erOne", "BEROne", "er3", "AR1", "BER1", "er0", "ER3", "AR3", "ER0"], "count": ["l", "cond", "key", "process", "all", "int", "handle", "name", "multi", "id", "allow", "val", "flag", "offset", "coll", "counter", "start", "string", "c", "Count", "follow", "add", "multiple", "size", "label", "old", "value", "amount", "group", "array", "order", "low", "limit", "time", "err", "base", "cache", "sum", "code", "number"], "frase": ["fASE", " fraser", "Frases", "Fraser", "flASE", "FrASE", "flace", "drace", "fases", "fase", "face", "draser", "Frace", "flases", "flase", "frace", "fraser", "drase", "frASE", "drases", " frace", "Frase"], "i": ["ai", "l", "ip", "ij", "z", "chi", "ib", "ti", "iter", "col", "I", "im", "n", "ui", "qi", "slice", "it", "phi", "uri", "int", "xi", "type", "ie", "k", "bi", "li", "multi", "limit", "id", "p", "iu", "x", "pi", "num", "mi", "di", "gu", "ix", "mini", "end"], "linha": ["elinwa", "ilha", "ilja", "plqa", "milha", "ilpa", "lnqa", "milqua", "elinja", "elinha", "vinhi", "Linha", "Linhi", "vinla", "linHA", "luba", " linja", "linhi", "vinja", "lnaga", "linwa", "luaga", " linaga", "milja", "jinwa", "jinpa", "Linla", "lnja", "milpa", " linHA", "plwa", "lnHA", "luja", "elinpa", "luha", "jinha", "lnpa", "lnqua", "linba", "plha"], "P": ["Q", "J", "API", "D", "Po", "NP", "DP", "PI", "PN", "PP", "Point", "L", "Y", "Count", "Pi", "Pat", "size", "TP", "H", "M", "PK", "U", "PC", "PUT", "RP", "W", "O", "E", "V", "X", "number", "B", "Type", "CP", "R", "PIN", "Case", "POS", "I", "IP"], "T": ["J", "Q", "DT", "TS", "Z", "D", "TH", "t", "TP", "GT", "H", "I", "IP", "TR", "M", "A", "NT", "TE", "total", "TC", "ET", "TG", "TW", "p", "TF", "WT", "TA", "G", "U", "N", "PE", "PUT", "TN", "Unit", "W", "O", "Total", "E", "C", "Length"], "list": ["l", "pl", "t", "path", "chain", "scale", "live", "all", "int", "listed", "table", "val", "cl", "cont", "lat", "coll", "tmp", "tree", "L", "add", "size", "obj", "bl", "set", "lp", "array", "order", "limit", "LIST", "sequence", "elist", "base", "cache", "copy", "queue", "code", "index", "where", "member", "pair"], "j": ["bj", "J", "uj", "ld", "adj", "ip", "ji", "obj", "z", "ij", "jl", "key", "u", " ii", " dj", "n", "r", "b", "v", "js", "job", "jp", "xi", "name", "jam", "k", "byn", "li", "pos", "d", "p", "m", "jen", "fr", "x", "jo", "je", "dj", "jj", "o"], "realT": ["imagT", "realP", "realt", "longL", "regularL", "regularP", "realN", "RealT", "complexT", "realM", " realt", "realTime", "longT", "specialt", " realY", "longP", " realP", "simY", "reallyP", "regularTime", "imagt", "simN", "regularT", "realL", "reallyt", "reallyT", " realM", " realTime", " realL", "realY", "complexN", "reallyTime", "longTime", "imagM", " realN", "RealM", "simT", "specialT", "specialTime", "Realt"], "supT": ["virtualT", " supt", "SUPT", " supM", "SupP", "virtualt", "supt", "virtualN", "scientificP", "scientificT", "scientificN", "supN", "SupT", "SupM", "supM", "supP", "SUPM", "SUPP", "virtualP", "SUPN", "scientifict", " supN", "SupN", " supP"], "item": ["amp", "key", "t", "ti", "character", "op", "int", "name", "area", "id", "other", "val", "hour", "option", "o", "offset", "h", "instance", "tag", "Item", "section", "image", "obj", "size", "iter", "value", "term", "order", "element", "level", "site", "time", "inner", "hop", "er", "layer", "items", "var", "X", "number"]}}
{"code": "def sqrt(x, ge):\n      if x == 1:\n          return 1\n      sx = x >> 1\n      step = sx >> 1\n  \n      while step:\n          if sx ** 2 >= x:\n              sx = sx - step\n          else:\n              sx = sx + step\n          step = step >> 1\n  \n      if ge:\n          while not sx ** 2 < x:\n              sx = sx - 1\n          while not sx ** 2 >= x:\n              sx = sx + 1\n      else:\n          while not sx ** 2 > x:\n              sx = sx + 1\n          while not sx ** 2 <= x:\n              sx = sx - 1\n  \n      return sx\n  \n  \n  def get_start_pali(a):\n      s = str(a)\n      ls = len(s)\n      if ls == 1:\n          return s, True\n      elif ls & 1:\n          return s[:ls >> 1 + 1], True\n      else:\n          return s[:ls >> 1], False\n  \n  \n  def get_next_pali(p, m):\n      if len(p) == p.count(\"9\"):\n          if m:\n              return \"1\" + \"0\" * (len(p) - 1), False\n          else:\n              return \"1\" + \"0\" * len(p), True\n      else:\n          return str(int(p) + 1), m\n  \n  \n  def pali_to_num(p, m):\n      if m:\n          return int(p + p[-2::-1])\n      else:\n          return int(p + p[::-1])\n  \n  \n  def is_pali(a):\n      s = str(a)\n      hls = len(s) >> 1\n      return s[:hls] == s[:-hls - 1:-1]\n  \n  for i in range(int(input())):\n      a, b = tuple(map(int, input().split()))\n      sqa, sqb = sqrt(a, True), sqrt(b, False)\n  \n      p, m = get_start_pali(sqa)\n      while pali_to_num(p, m) < sqa:\n          p, m = get_next_pali(p, m)\n  \n      count = 0\n  \n      while True:\n          curr = pali_to_num(p, m)\n          if curr > sqb:\n              break\n          if is_pali(curr ** 2):\n              count = count + 1\n          p, m = get_next_pali(p, m)\n  \n      print(\"Case #{}: {}\".format(i + 1, count))\n", "substitutes": {"x": ["exc", "co", "ex", "l", "t", "xd", "xx", "int", "sex", "host", "rx", "val", "tx", "test", "xs", "h", "y", "c", "ctx", "g", "px", "hex", "www", "shape", "wa", "case", "cross", "python", "xy", "xi", "sync", "do", "xxxx", "ww", "time", "something", "go", "ix", "ice", "com"], "ge": ["le", "min", "z", "ite", "max", "ce", "gh", "sw", "range", "me", "node", "gt", "ve", "gr", "fe", "scale", "se", "te", "next", "ne", "ie", "gen", "gate", "ga", "ae", "be", "go", "GE", "gap", "plus", "ges", "let", "skip", "e", "edge", "ger", "ice", "ze", "pack", "diff"], "sx": ["statesX", "dsxc", "statessex", "southx", "sswx", "southwx", "wsX", "gsX", "sxc", " sw", "sph", "gsx", "salxx", " sxc", "nswx", "dsxi", " sxx", "dsxes", "sxp", " sxs", "sesx", "sfx", "tsy", "salync", "sX", "sxx", "nsxes", "tsxx", "seswx", "psv", "bisx", " sxp", "wsy", "dsxx", " sfx", "tsx", " swx", "dsx", "esx", "gsxc"], "step": ["amp", "dimension", "key", "path", "input", "dim", "shift", "scale", "int", "name", "phase", "id", "round", "steps", "Step", "action", "ct", "grade", "mix", "edge", "start", "stop", "first", "flow", "g", "repeat", "update", "follow", "section", "shape", "min", "size", "case", "data", "group", "next", "STEP", "walk", "time", "go"], "a": ["l", "alpha", "art", "t", "am", "au", "another", "access", "sa", "asa", "ha", "aw", "area", "action", "la", "ap", "ea", "h", "y", "af", "c", "ma", "g", "pa", "aa", "wa", "ab", "r", "ga", "ana", "ns", "ac", "audio", "os", "da", "an", "w", "mA", "at", "fa"], "s": ["l", "t", "ations", "sa", "tests", "grades", "o", "ances", "ans", "posts", "xs", "ments", "h", "y", "string", "c", "g", "sb", "resses", "strings", "si", "values", "sts", "ing", "sets", "ses", "r", "ves", "less", "se", "ies", "sync", "ands", "words", "qs", "bs", "ens", "ns", "abs", "its"], "ls": ["las", "rl", "l", "le", "lo", "es", "lines", "ins", "ims", "ss", "ms", "lp", "lt", "els", "les", "less", "lab", "cs", "dl", "kl", "ats", "ln", "alls", "ly", "ds", "fl", "lv", "li", "qs", "ils", "los", "bs", "als", "lr", "ns", "bps", "ches", "lus", "lis", "tl"], "p": ["l", "pp", "pl", "t", "am", "pr", "op", "int", "tp", "point", "o", "ap", "h", "y", "pt", "c", "fp", "g", "pa", "j", "per", "py", "r", "lp", "pm", "data", "hp", "python", "pu", "np", "ping", "dp", "po", "bp", "cache", "sp", "patch", "w", "at", "api"], "m": ["l", "sm", "mm", "wm", "middle", "j", "mt", "z", "t", "u", "mr", "am", "mn", "ms", "n", "r", "md", "v", "pm", "mp", "im", "M", "vm", "em", "param", "int", "man", "me", "k", "tm", "om", "d", "cm", "um", "mass", "mc", "num", "mu", "fm", "ym"], "hls": [" hll", "rhla", "hsls", "shls", " hns", "qli", "hsps", "shll", "hsLS", "qns", "hns", "hli", "hps", "rhlt", "Hns", "hlt", "hla", " hla", "Hps", "shlt", "rhls", "zns", "hsns", "zlis", "shla", " hlis", "zls", "hll", "qls", " hps", "hLS", "HLS", "qlis", "rhll", "zli", " hLS", " hlt", "hlis", " hli", "Hls"], "i": ["ai", "l", "ip", "j", "z", "u", "ti", " I", "col", "I", "r", "n", "im", "it", "int", "k", "li", "d", "id", "iu", "num", "gu", "ix", " j", "end", "e", "y", "f", "code", "q", "c", "g", "ii", "gi", "ind", "ci", "index"], "b": ["xb", "l", "j", "abb", "ab", "ib", "rb", "bb", "emb", "n", "r", "v", "wb", "bel", "fb", "ben", "d", "be", "bf", "eb", "body", "bc", "bs", "ob", "other", "mb", "o", "lb", "nb", "e", "cb", "h", "y", "f", "ub", "c", "g", "B", "bas", "sb"], "sqa": [" sla", " sca", "nscca", " sna", "psma", "nssa", "ssa", "nsqua", "sna", "rsla", " sma", " squa", " sha", "psna", "sha", "sca", " ssa", "rsca", "Sqa", "scca", "Squa", "Sca", "sma", "squa", "rsqua", " scca", "psqa", "nsqa", "Sla", "psha", "rsqa", "sla"], "sqb": ["iqb", "qb", "qul", " sql", "dqn", "qur", "iqr", "qua", "iqba", "qa", "sqba", "ql", "dqb", "sqn", "qub", "sql", "dqr", "iqn", " sqr", " sqba", " sqn", "dqba", "sqr", "qr"], "count": ["cond", "l", "key", "all", "name", "bind", "multi", "id", "allow", "list", "val", "fail", "offset", "coll", "counter", "start", "first", "c", "char", "Count", "cast", "collect", "add", "size", "case", "label", "escape", "group", "order", "low", "limit", "time", "hide", "race", "join", "base", "every", "cache", "sum", "code"], "curr": [" currer", " curre", "surr", "verre", "currer", "perru", "Currer", "verrs", "surrs", "verrar", "earrer", "currs", "perr", "Curr", "urre", "earrs", "surru", "verr", "earr", "earre", "curru", " currs", "perre", "Curre", "perrs", " currar", " curru", "curre", "currar", "surre", "urrs", "urr", "Currs", "urrar"]}}
{"code": "def passes(p, t): #normal, surprising\n      q, r = divmod(t, 3)\n      if r == 0:\n          return q >= p, q + 1 >= p and q\n      elif r == 1:\n          return q + 1 >= p, q + 1 >= p and q\n      elif r == 2:\n          return q + 1 >= p, q + 2 >= p\n  \n  for case in range(int(input())):\n      st = input().strip().split()\n      n, s, p, t = int(st[0]), int(st[1]), int(st[2]), list(map(int, st[3:]))\n      result = 0\n      for i in t:\n          normal, surprising = passes(p, i)\n          if normal:\n              result += 1\n          elif surprising and s != 0:\n              result += 1\n              s -= 1\n      print(\"Case #{}: {}\".format(case + 1, result))\n", "substitutes": {"p": ["l", "pp", "pl", "b", "pr", "op", "phi", "pot", "tp", "point", "o", "h", "y", "pt", "c", "g", "fp", "pa", "j", "py", "lp", "hp", "python", "np", "par", "m", "pid", "po", "x", "bp", "local", "sp", "a", "w", "at", "u", "col", "cp", "port", "k"], "t": ["P", "l", "section", "ip", "j", "z", "u", "out", "unit", "b", "v", "ot", "tt", "tu", "port", "trial", "flat", "te", "total", "int", "type", "tm", "rt", "d", "pos", "m", "template", "time", "x", "ta", "tp", "tz", "sequence", "o", "ty", "ant", "cases", "types", "e", "temp"], "q": ["Q", "l", "ce", "b", "qi", "qq", "int", "id", "point", "o", "iq", "h", "y", "c", "question", "g", "quant", "qu", "ing", "out", "value", "qt", "ish", "qs", "m", "aq", "ill", "x", "er", "ix", "ac", "charge", "en", "a", "w", "u", "req", "eq", "k", "d"], "r": ["rl", "l", "ir", "rf", "ur", "rb", "hr", "right", " R", "mr", "u", "rate", "range", "b", "pr", "v", "rg", "rar", "nor", "k", "nr", "rd", "ro", "rt", "re", "cr", "m", "d", "fr", "err", "er", "rx", "rator", "res", "ru", "rec", "sr", "rn", "attr", "e"], "case": ["section", "Case", "shape", "ip", "tri", "ASE", "size", "rice", "ce", "character", "me", "count", "loop", "v", "pe", "slice", "trial", "chain", "shift", "change", "ase", "chance", "se", "choice", "ie", "phrase", "ace", "id", "d", "phase", "site", "time", "position", "bc", "x", "sequence", "match", "line", "race", "length"], "st": ["ld", "pp", "rest", "input", "lt", "b", "sa", "int", "us", "sh", "list", "cl", "ct", "St", "start", "pt", "stop", "first", "string", "c", "ut", "ST", "sett", "sb", "nd", "ust", "est", "si", "sta", "sec", "sts", "ost", "set", "ast", "inst", "data", "fe", "se", "stim", "sp"], "n": ["l", "z", "pn", "iter", "u", "b", "v", "ot", "net", "name", "k", "nr", "pos", "d", "m", "na", "ns", "x", "pi", "num", "N", "o", "nb", "e", "nc", "nn", "h", "en", "y", "a", "f", "sn", "c", "g", "w", "at", "nt"], "s": ["l", "es", "j", "features", "z", "size", "lines", "u", "ins", "ing", "ss", "states", "b", "v", "ses", "su", "sf", "se", "tests", "stats", "sv", "simple", "k", "d", "pos", "m", "site", "sg", "ns", "settings", "x", "res", "o", "steps", " results", "si", "comments", "cases", "rows", "ops"], "result": ["cur", "answer", "new", "page", "final", "error", "valid", "rest", "comment", "df", "range", "now", "value", "found", "su", "term", "count", "data", "future", "change", "order", "total", "acc", "default", "compl", "current", "mer", "re", "round", "trace", "ret", "cup", "runner", "err", "success", "sequence", "res", "response", "match", "search"], "i": ["l", "ip", "j", "chi", "z", "ti", "rest", "u", "I", "v", "b", "qi", "ic", "phi", "it", "int", "xi", "ie", "bi", "li", "d", "id", "m", "iu", "x", "pi", "e", "iq", "sp", "ice", "y", "start", "a", "f", "c", "ii", "ini", "ind", "ci", "si"], "normal": ["note", "notice", "new", "natural", "example", "unit", "random", "comment", "traditional", "v", "never", "standard", "static", "common", "flat", "ori", "found", "Normal", "partial", "general", "total", "default", "simple", "current", "special", "sequence", "successful", "rational", "unknown", "response", "o", "confirmed", "regular", "mini", "negative", "given", "real", "original", "second", "problem"], "surprising": ["urprisingly", "urprising", "urging", "srprising", "Surging", "srging", "Survey", " surprise", "Surprisingly", "urprises", "surprisingly", "surprise", "survey", "srvey", "urvey", "surging", "srprises", "surprises", "Surprising", "Surprises", " surprises", " surprisingly", "urprise", "Surprise"]}}
{"code": "lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,\n      100020001,102030201,104060401,121242121,123454321,125686521,400080004,\n      404090404,10000200001,10221412201,12102420121,12345654321,40000800004,\n      1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,\n      1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,\n      1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,\n      102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,\n      123456787654321,400000080000004]\n  \n  \n  def solve(lo,hi):\n      global lst\n      count = 0\n      for i in range(len(lst)):\n          if (lst[i] >= lo and lst[i] <= hi ):\n              count += 1\n      return count\n  \n  fname = raw_input(\"name of file: \")\n  oname = raw_input(\"output file name:\")\n  f = open(fname,\"r\")\n  out = open(oname,\"w\")\n  n = int(f.readline()[:-1])\n  case_num = 1\n  for line in f:\n      args = line[:-1].split()\n      lo = int(args[0])\n      hi = int(args[1])\n      out.write(\"Case #%d: %d\n\" %(case_num,solve(lo,hi)))\n      case_num += 1\n      \n  out.close()\n  f.close()\n      \n", "substitutes": {"lst": ["lrest", "lST", "Lrest", "elrest", "elsts", " lbl", "Lbl", "lsST", "lssp", " lST", "lcste", "lbl", "lcbl", "Lst", "rsts", "elst", "llST", "LST", "Lstr", " lste", "Lsp", "lsstr", "lsts", "elgest", "fst", "elbl", "fstr", " lgest", "lste", "lsst", "lgest", "lstr", "rgest", "rst", "elST", "elstr", "lcstr", "lcst", "llstr", " lstr"], "lo": ["LO", "le", "log", "co", "l", "elo", "min", "pl", "loc", "ri", "lim", "old", "oa", "range", "so", "ino", "zero", "loop", "bo", "little", "lab", "left", "ko", "ha", "Hi", "ne", "oo", "level", "ln", "bi", "low", "li", "ro", "ra", "pos", "micro", "los", "go", "lie", "po"], "hi": ["LO", "co", "wa", "ci", "chi", "size", "py", "max", "ri", "gh", "HI", "lim", "loc", "hub", "fi", "range", "inf", "thin", "ha", "phi", "Hi", "uri", "ho", "xi", "bi", "low", "li", "fat", "hei", "ra", "limit", "pos", "id", "rh", "po", "sh", "hop", "x", "pi", "mid"], "count": ["log", "cond", "co", "lines", "size", "case", "key", "max", "col", "seq", "value", "found", "s", "call", "left", "all", "child", "level", "type", "name", "ch", "low", "current", "limit", "id", "cr", "cat", "list", "val", "num", "match", "length", "fail", "info", "la", "base", "cache", "conf", "depth", "weight"], "i": ["ai", "l", "ip", "j", "ci", "z", "ji", "eni", "key", "ti", "u", "ri", "col", "I", "r", "ih", "fi", "ui", "qi", "yi", "uri", "int", "xi", "ie", "bi", "multi", "li", "ei", "pos", "id", "p", "part", "iu", "uni", "x", "pi", "ni", "mi", "di", "gu"], "fname": ["cename", "cnam", "fcame", " Fname", "fcname", "lfame", "ckey", "pkey", "fnam", "fcnamed", "pename", "fnamed", "Fnamed", "lfnamed", "Fname", "fcnam", "fame", "pnam", " Fnam", "fename", " Fkey", "fkey", "Fnam", "lfnam", "Fame", "cname", "lfname", "pname", " Fename"], "oname": ["onname", "Oname", " onam", " onamel", "uniname", "offnam", " onname", "nnam", "uninam", "onnam", "name", "offename", "Onename", "nname", "Onam", "uninamel", "Onamel", "onamel", "offame", " onnam", "onename", " onename", "onam", "nename", "uninename", "offname"], "f": ["l", "j", "fore", "z", "rf", "t", "u", "df", "feed", "r", "b", "fi", "v", "fd", "input", "s", "sf", "inf", "fe", "fen", "fc", "fb", "frame", "tf", "name", "fat", "fl", "d", "p", "bf", "m", "file", "form", "fr", "fac", "x", "o", "io", "up", "e"], "out": ["log", "ex", "co", "exp", "l", "Out", "error", "t", "r", "input", "v", "print", "flat", "call", "full", "group", "raw", "net", "bin", "ln", "tf", "name", "gen", "ch", "again", "p", "file", "wx", "outs", "inner", "err", "lock", "x", "o", "plus", "io", "up", "ou", "extra", "ext"], "n": ["l", "z", "size", "t", "r", "b", "s", "net", "ln", "name", "li", "nr", "d", "p", "m", "ns", "x", "num", "N", "o", "nb", "e", "nc", "no", "h", "len", "y", "en", "a", "sn", "c", "number", "g", "fn", "w", "nt"], "case_num": ["case2index", "case_count", "case0index", "Case_index", "Case_id", "case6NUM", "Case_number", "case6num", "Case_num", "case6id", "case_col", "case_NUM", "case_number", "case0num", "Case_col", "Case_sum", "Case_count", "case2count", "case2num", "case2number", "case0number", "case6no", "case_index", "case_no", "case_sum", "case0count", "case_id", "Case_no", "Case_NUM"], "line": ["LINE", "log", "l", "cell", "lines", "obj", "size", "page", "inline", " lines", "unit", "iter", "case", "col", "range", "header", "object", "group", " Line", "item", "ne", "ln", "frame", "name", "sync", "id", "body", "entry", "file", "list", "err", "block", "num", "lined", "str", "match", "row", "response", "lin", "lf"], "args": ["exc", "ex", " arg", "lines", "obj", "size", "bits", "py", "iter", "ras", "arms", "loc", "ins", "uses", "ms", "cons", "js", "call", "span", "data", "chain", "Arg", "cs", "stats", "grades", "limits", "parts", "arr", "part", "dict", "pos", "ants", "words", "bytes", "ams", "objects", "ns", "err", "charges", "align"]}}
{"code": "fileName = raw_input(\"File name: \")\n  \n  f = open(fileName,\"r\")\n  \n  t = int(f.readline()[:-1])\n  \n  tests = []\n  \n  for i in range (t):\n      tests += [f.readline()[:-1]]\n  \n  f.close()\n  \n  \n  def compute(raw):\n      dataN = [] # keeps the max mark for not surprising\n      dataS = [] # keeps the max marks for surprisings\n      \n      items = raw.split() \n      \n      for i in range (int(items[0])):\n          ti = int(items[3+i])\n          if ti < 1:\n              dataS += [0]\n              dataN += [0]\n          elif ti > 28:\n              dataS += [10]\n              dataN += [10]\n          else:\n              dataN += [int((ti+2)/3)] # put the values for all participants\n              dataS += [int((ti+4)/3)]\n          \n          \n  \n      \n      p = int(items[2])\n      s = int(items[1])\n      \n      n_vals = dataN\n      n_vals.sort()\n      \n  \n      i=0\n      minimum = 0 # how many numbers greater than p are there in \"not surprising\"\n      if n_vals[0] < p:\n          while n_vals[-1-i] >= p:\n              minimum += 1\n              i += 1\n      else:\n          minimum = len(n_vals)\n          \n  \n      s_vals = dataS\n      s_vals.sort()\n      i=0\n      maximum = 0 # how many numbers greater than p are there in \"surprising\"\n      if s_vals[0] < p:\n          while s_vals[-1-i] >= p:\n              maximum += 1\n              i += 1\n      else:\n          maximum = len(n_vals)\n      \n      return min(maximum, minimum+s) \n      \n  \n  for i in range (t):\n      print \"Case #%d: %d\" %(i+1,compute(tests[i]))\n  \n  \n      \n", "substitutes": {"fileName": [" filePath", "filePath", " fileInfo", "fname", " fileDir", "fPath", "Filename", "FileInfo", "filename", "fDir", "fileInfo", "fName", "fileDir", "FileDir", "fNames", "FileName", "fileNames", "fInfo", "FilePath", "FileNames", " fileNames", " filename"], "f": ["l", "ff", "uf", "folder", "rf", "u", "df", "feed", "r", "b", "sf", "v", "fd", "inf", "found", "loop", "full", "fe", "fc", "fb", "tf", "fl", "d", "fx", "bf", "m", "file", "form", "arf", "fr", "x", "fm", "elf", "o", "io", "fold", "e", "lf", "buff", "h"], "t": ["l", "tc", "j", "z", "size", "art", "u", "n", "r", "b", "v", "qt", "count", "ot", "tt", "trial", "txt", "int", "type", "tf", "tm", "tail", "d", "m", "time", "tz", "ta", "tp", "x", "o", "ct", "e", "temp", "h", "testing", "y", "tick", "start", "pt", "a"], "tests": ["loads", "versions", "docs", "features", "lines", "services", "Testing", "values", "sections", "forms", "states", "reports", " Tests", "views", "requires", "stats", "fts", "breaks", "events", "tes", "downs", "rules", "testers", "users", "tips", "Examples", "settings", "notes", "details", "ches", "devices", "times", "its", "steps", "suits", "cases", "terms", "gets", "projects", "types"], "i": ["l", "rest", "ih", "b", "qi", "shift", "phi", "uri", "int", "init", "multi", "ei", "integer", "id", "o", "io", "h", "y", "start", "c", "g", "ini", "initial", "ci", "si", "j", "min", "size", "eni", "ri", "im", "r", "udi", "xi", "bi", "m", "inner", "x", "ni", "sequence"], "raw": ["small", "strip", "RAW", "format", "view", "log", "new", "game", "feed", "valid", "rew", "server", "input", "xml", "static", "data", "full", "container", "source", "array", "stream", "partial", "events", "buffer", "package", "file", "form", "hook", "Raw", "inner", "clean", "details", "json", "response", "row", "remote", "line", "original", "rows", "spec"], "dataN": [" dataNs", "alphan", "DataL", "Datan", "dataT", "datan", "DATAS", "dataNs", "mediaN", " dataBox", "dataL", "ataBox", " dataC", "resultsL", " dataT", " datan", "DataNs", "DataT", "mediaS", "alphaN", "dataBox", "resultsN", "alphaNs", "mediaNs", "DataS", "DATAL", " dataL", "ataN", "ataC", "DataBox", "alphaS", "DataC", "dataC", "mediaT", "DATAN", "ataS", "DATANs", "resultsC", "DataN", "DATAC"], "dataS": ["datI", "dataO", " DataO", " DataI", " dataP", "datP", " DataN", "datS", "DataI", " DataP", " dataU", " dataSN", "dataI", "memoryS", "DataP", "dataU", " dataI", " DataS", "resultsS", "dataIs", "datN", "DataU", " dataNS", "resultsN", "DataO", "memoryI", "memoryNS", " DataIs", "DataS", "dataSN", " dataO", " dataIs", "resultsIs", "memoryN", "DataSN", "dataNS", "resultsP", "DataNS", "DataN", "datU"], "items": ["es", "features", "lines", "keys", "values", "example", "sections", "args", "ins", "bits", "forms", "eps", "reports", "xml", "data", "articles", "images", "ids", "item", "stats", "members", "parts", "ows", "events", "blocks", "words", "qs", "orders", "lists", "objects", "users", "chains", "notes", "x", "details", "flows", "json", "its", "cells", "steps"], "ti": ["reci", "ai", "osi", "mie", "fee", "tip", "ita", "chi", "Ti", "eni", "cli", "ki", "cin", "ri", "esi", "sea", "ski", "fi", "isi", "ku", "qi", "tis", "ui", "tu", "ori", "yi", "odi", "phi", "te", "iki", "shi", "ati", "xi", "iri", "bi", "li", "ei", "phis", "asi", "tti"], "p": ["l", "pp", "progress", "b", "pr", "past", "phi", "int", "tp", "point", "o", "ap", "h", "y", "start", "c", "pa", "j", "per", "out", "r", "lp", "python", "np", "ping", "pid", "m", "x", "local", "sp", "a", "at", "w", "null", "api", "pn", "u", "port", "part", "k"], "s": ["l", "es", "sq", "sec", "size", "services", "u", "sets", "ss", "states", "sw", "n", "ses", "sf", "b", "v", "su", "r", "sa", "cs", "se", "sv", "asi", "m", "ns", "x", "pi", "tp", "service", "seconds", "o", "steps", "space", "state", "spec", "e", "ps", "second", "sp", "ls"], "n_vals": ["n2als", "n_valid", "n2values", "n__vals", "n_als", "s_values", "nsvalues", " nsvalues", "n_mas", "p_als", "s_val", "p_valid", " n_values", "n__values", "nsports", "p_val", " nsvals", "n_data", " n_ports", "p_values", "n_values", "n__valid", "s_plays", " nsals", "n_val", " nsports", "n_ports", "n_plays", "p_mas", "p_data", "n2val", "n2vals", "n__val", " n_als", "nsals", "nsvals", "p_vals"], "minimum": ["mine", "dimension", "b", "largest", "uri", "filename", "nil", "negative", "approximately", "first", "Minimum", "instance", "initial", "medium", "location", "si", "multiple", "min", "ri", "reference", "me", "portion", "period", "minute", "partial", "duration", "begin", "m", "sequence", "highest", "my", "required", "latest", "starting", "number", "within", "uli", "index", "small", "member"], "s_vals": ["s___mas", "siglists", "s_als", "s___vals", "s___val", "rs_lists", "n_values", "s__eval", "s_eval", "sigcats", "s__val", "s_cats", "siggets", "rs_gets", "s_values", "s2val", "rs_vals", "s2als", "sigvals", "s_lists", "n_val", "s_gets", "s2vals", "s__vals", "s2values", "n_ettes", "n_als", "n_mas", "rs_cats", "s_mas", "n_eval", "s_ettes", "s_val", "s___ettes", "s__values"], "maximum": ["dimension", "significant", "largest", "actual", "model", "master", "filename", "mass", "request", "approximately", "you", "instance", "initial", "successful", "location", "multiple", "wa", "min", "complete", "reference", "portion", "period", "average", "limit", "sequence", "highest", "required", "latest", "number", "within", "specified", "network", "middle", "null", " Maximum", "information", "sufficient", "expression", "that", "memory"]}}
{"code": " \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(reader(f, *args, **kwargs))\n      return res\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      return read_ints(f)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%d'%res)\n      f.write('\n')\n  \n  \n  def aux(A, B, x, s):\n      res = 0\n      n = int(''.join(x[::-1]+x))\n      nn = n*n\n      if nn > B:\n          return res\n      if nn >= A:\n          res += 1\n      for c in [0, 1, 2]:\n          if s + c*c < 10:\n              n = int(''.join(x[::-1]+[str(c)]+x))\n              nn = n*n\n              if nn >= A and nn <= B:\n                  res += 1\n          if s + 2*c*c < 10:\n              res += aux(A, B, [str(c)]+x, s + 2*c*c)\n      return res\n  \n  def solve_small(case):\n      [A, B] = case\n      res = 0\n      for n in [1, 4, 9]:\n          if n >= A and n <= B:\n              res += 1\n      for c in [1, 2]:\n          res += aux(A, B, [str(c)], 2*c*c)\n      return res\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n", "substitutes": {"f": ["l", "fun", "fore", "uf", "t", "feed", "ref", "rb", "fit", "fi", "input", "inf", "fen", "fc", "frame", "function", "file", "handler", "fr", "fac", "field", "o", "io", "fin", "fits", "lf", "conf", "h", "y", "fw", "af", "fed", "g", "fp", "fo", "feature", "j", "df", "r", "sf"], "b": ["l", "j", "ab", "z", "bl", "ib", "t", "u", "rb", "bb", "r", "count", "v", "ba", "wb", "db", "bh", "fb", "type", "batch", "bi", "k", "part", "limit", "p", "bf", "m", "be", "eb", "bc", "bs", "abs", "bp", "o", "sb", "length", "lb", "nb", "e", "base"], "x": ["co", "ex", "l", "t", "input", "xx", "inf", "model", "int", "sex", "name", "id", "host", "rx", "line", "o", "tx", "xs", "h", "y", "string", "ctx", "g", "px", "ci", "image", "j", "out", "valid", "r", "data", "cross", "array", "xy", "xi", "xxxx", "ww", "m", "ix", "xxxxxxxx"], "d": ["l", "ld", "dc", "j", "z", "D", "t", "u", "dx", "xd", "r", "cd", "v", "fd", "md", "dim", "data", "dr", "dl", "db", "dir", "dat", "type", "direction", "name", "do", "k", "part", "ds", "dict", "id", "p", "m", "dn", "di", "o", "da", "e", "dh", "ad"], "R": ["P", "Q", "J", "D", " r", "RW", "H", "I", "r", "Rs", "range", "v", "RN", "DR", "Right", "M", "array", "OR", "RO", "SR", "RA", "p", "NR", "Rh", "JR", "G", "U", "N", "CR", "length", "RR", "Res", "RP", "W", "O", "C", "S", "V", "Range", "L"], "reader": ["step", "library", "loader", "feed", "df", "iter", "mode", "ri", "rb", "core", "r", "value", "slice", "driver", "source", "ride", "rar", "ctor", "ler", "function", "cer", "rot", "reading", "builder", "parser", "buffer", "entry", "seed", "cr", "handler", "Reader", "inner", "runner", "read", "er", "row", "io", "length", "client", "proc"], "res": ["exc", "co", "css", "rest", "pres", "xx", "false", "all", "init", "ne", "breaks", "us", "re", "val", "rx", "rus", "test", "Results", "coll", "resh", "vals", "rap", "RS", "reg", "values", "j", "obj", "out", "ras", "rand", "ri", "nos", "mr", "r", "me", "data", "relations", " Res", "blocks", "resp"], "i": ["l", "ai", "ip", "ir", "ij", "j", "chi", "z", "ib", "ti", "u", "t", "ri", "I", "im", "ih", "v", "r", "qi", "ui", "count", "ori", "it", "uri", "phi", "int", "xi", "init", "ie", "bi", "li", "ei", "id", "p", "pos", "m", "iu", "pi", "ni", "mi"], "solver": ["insver", "sol", "solving", "folution", "insolving", "Solution", "ssolver", " solution", "Searcher", "insolver", "folver", "sver", " solve", " sver", " sol", "solve", "ssver", "fearcher", "searcher", "folve", "solution", "ssolving", "ssol", "Solve", " searcher", "insol", " solving", "Solver"], "fn": ["l", "format", "fun", "FN", "rf", "out", "path", "fi", "r", "v", "fd", "node", "sf", "orn", "wl", "txt", "fen", "fc", "np", "kn", "fb", "ln", "function", "name", "sync", "write", "func", "filename", "fl", "fat", "wt", "p", "bf", "m", "file", "dn", "prefix", "gn", "o", "io"], "out_fn": ["out2fn", "outFilefn", "outningfp", "outningfil", "out_fil", "out2fc", "outFilefilename", "outFfilename", "out_fp", "out_fc", "outFfr", "in_fil", "out2n", "outingpath", "outFfn", "in_fin", "out_n", "in_filename", "in_path", "in_model", "outFilemodel", "out2fp", "in_fc", "in_n", "outingfn", "in_fr", "out_model", "in_fp", "outningfn", "outFilefr", "outFmodel", "out_path", "out_filename", "out_fr", "outingfin", "out_fin", "outningfilename", "outingfp"], "in_fn": ["out_fp", "inningfd", "inningfn", "out_conn", "out_fd", "inningcdn", "in_filename", "in_form", "inPconn", "inPform", "in_conn", "in_fp", "inPfilename", "in_cdn", "out_form", "out_cdn", "out_filename", "in_fd", "inningfp", "inPfn"], "T": ["P", "Q", "Case", "shape", "text", "J", "TS", "z", "Z", "Size", "D", "Ti", "t", "max", "GT", "H", "I", "M", "phi", "type", "p", "time", "TA", "G", "num", "U", "N", "TN", "o", "TI", "length", "cube", "e", "W", "O", "E", "C", "sc", "S", "V"], "case": ["exc", "co", "config", "Case", "key", "rice", "ce", "cas", "core", "fi", "r", "cp", "pe", "che", "call", "pair", "trial", "shift", "slice", "ase", "type", "cer", "ch", "ace", "id", "p", "m", "cr", "time", "cl", "match", "cases", "fold", "info", "e", "cache", "conf", "result", "ice", "force"], "A": ["AR", "P", "J", "Na", "As", "D", "AA", "LA", "AB", "I", "H", "M", "NA", "AN", "AM", "Ab", "AP", "Am", "AH", "Alpha", "SA", "App", "G", "U", "N", "AD", "CC", "W", "O", "AF", "BA", "E", "C", "a", "S", "V", "L", "X", "Y", "Ang"], "B": ["P", "Q", "J", "WB", "DB", "Z", "D", "AB", "I", "BF", "M", "LB", "BM", "NB", "BL", "Bs", "BBC", "G", "U", "N", "BB", "BC", "CB", "BE", "W", "O", "BA", "E", "C", "MB", "S", "V", "L", "X", "TB", "Bi", "Y", "K", "F", "BI"], "s": ["small", "l", "es", "sq", "z", "size", "t", "u", "ss", "sf", "ses", "v", "six", "su", "cs", "se", "sv", "ds", "us", "p", "m", "seed", "ns", "abs", "its", "o", "sr", "ix", "space", "os", "ans", "rows", "spec", "Ns", "ps", "e", "ls", "h", "y", "sn"], "n": ["l", "t", "ne", "ln", "function", "nor", "nr", " ng", "id", "o", "nb", "Ns", "coll", "nc", "y", "g", "nd", "adj", "add", "j", "min", "mn", "r", "python", "np", "func", "m", "ns", "ni", "ed", "an", "no", "cn", "nm", "en", "number", "w", "ng", "end", "nu"], "nn": ["co", "fee", "aa", "nv", "abb", "kk", "yy", "pn", "cc", "mn", "nu", "inn", "xx", "ann", "node", "span", "nw", "conn", "unc", "wn", "np", "ne", "kn", "acc", "ln", "SN", "sync", "NN", "byn", "nr", "fl", "nom", "na", "dn", "ns", "syn", "ni", "num", "N", "gn"], "c": ["l", "dc", "z", "cc", "t", "u", "cin", "col", "cu", "count", "r", "cd", "uc", "unc", "cs", "toc", "fc", "xc", "k", "cm", "p", "m", "cr", "bc", "mc", "num", "cy", "N", "rec", "ct", "ac", "pc", "e", "nc", "h", "cn", "ca", "y", "cus", "C"]}}
{"code": " \n  __file__ = sys.argv[0]\n  __path__ = os.path.dirname(__file__)\n  __prob__ = os.path.basename(__path__)\n  \n  def pout(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n  \n  def perr(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n  \n  def argmin(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best > y:\n              best = y\n              res = x\n      return res\n  \n  def argmax(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best < y:\n              best = y\n              res = x\n      return res\n  \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_word_arr(f, R):\n      res = []\n      for i in range(R):\n          res.append(read_word(f))\n      return res\n  \n  def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(read_ints(f, *args, **kwargs))\n      return numpy.array(res, dtype)\n  \n  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n      global ERR_FILE\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      err_fn = fn + '.err'\n      if start_case == 0:\n          append = True\n          if os.path.exists(out_fn):\n              with open(out_fn, 'r') as f:\n                  for l in f:\n                      if l[:6] == 'Case #':\n                          start_case = int(l[6:l.index(':')])+1\n      else:\n          append = False\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'a' if append else 'w') as fo:\n              with open(err_fn, 'w') as ERR_FILE:\n                  T = read_int(fi)\n                  for i in range(T):\n                      case = read_case(fi)\n                      if i+1 < start_case:\n                          continue\n                      print('Case #%d of %d'%(i+1, T))\n                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                      perr('case')\n                      res = solver(case)\n                      perr('res')\n                      write_case(fo, i, res)\n                      fo.flush()\n                      if end_case is not None and i+1 == end_case:\n                          break\n  \n  def test(start_case=1, end_case=None):\n      fn = os.path.join(__path__, 'test')\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small2(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case, fn + '2.out')\n  \n  def large(start_case=0, end_case=None):\n      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case)\n  \n  \n  def read_case(f):\n      Z = read_ints(f)\n      (N, S, p) = Z[:3]\n      t = Z[3:]\n      return (N, S, p, t)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%(i+1))\n      f.write('%s'%res)\n      f.write('\n')\n  \n  FAIL = 'NO SOLUTION'\n  \n  def solve_small(case):\n      (N, S, p, t) = case\n      res = 0\n      for i in range(N):\n          if p >= 2:\n              if t[i] >= 3*p-2:\n                  res += 1\n              elif S > 0 and t[i] >= 3*p-4:\n                  res += 1\n                  S -= 1\n          elif p == 1:\n              if t[i] >= 3*p-2:\n                  res += 1\n          elif p == 0:\n              res += 1\n      return res\n  \n  solve_large = solve_small\n  \n  pout = perr\n", "substitutes": {"__file__": ["__log____", " __path___", "__log__", "__log___", "__name___", "__path___", " __file___", " __file____", "__call____", "__call__", "__call___", "__name__", "__file___", " __path____", "__name____", "__path____", "__file____"], "__path__": ["__log____", " __path___", "__log__", "__dir___", "__method__", "__file_", "__log___", " __dir___", "__path_", "__path___", " __file___", "__method___", "__dir__", "__call__", " __path_", " __dir____", "__dir_", "__call___", "__log_", "__file___", " __path____", " __dir__", " __dir_", "__path____", "__dir____", "__file____"], "__prob__": ["__probe____", "__proc___", "__probe__", "__pebe____", "__proot___", "__probe___", "__prob____", "__proc____", "__pebe___", "__proc__", "__peb____", "__peb___", "__pebe__", "__peb__", "__proot____", "__prob___", "__proot__"], "s": ["input", "inf", "sa", "function", "name", "us", "id", "sh", "service", "o", "sql", "comments", "request", "ans", "posts", "conf", "h", "string", "c", "params", "g", "sb", "strings", "si", "j", "lines", "sec", "say", "sets", "set", "old", "r", "sf", "ses", "value", "js", "se", "sync", "storage", "func"], "back": ["support", "add", "backed", "D", "ce", "right", "pull", "input", "now", "backs", "stage", "BACK", "shift", "reverse", "front", "db", "left", "down", "child", "part", "before", "side", "id", "Back", "close", "round", "home", "time", "session", "length", "state", "short", "der", "da", "bug", "base", "self", "date", "depth", "force"], "f": ["fun", "uf", "fore", "feed", "ref", "fit", "fi", "input", "inf", "fen", "fc", "all", "frame", "function", "file", "handler", "fr", "fac", "field", "o", "lf", "conf", "h", "fw", "af", "fed", "c", "g", "fp", "fo", "feature", "root", "j", "df", "r", "sf", "family", "fe", "free", "func"], "d": ["ld", "D", "dim", "name", "td", "id", "o", "dom", "dh", "h", "start", "c", "g", "nd", "j", "r", "dB", "dash", "data", "dl", "dat", "do", "dp", "m", "da", "du", "w", "sd", "end", "dc", "u", "dx", "db", "k", "part", "ds", "side", "dn", "di", "dos"], "a": ["alpha", "am", "input", "au", "another", "access", "sa", "ha", "all", "aw", "area", "active", "o", "action", "ans", "la", "ap", "ea", "h", "af", "c", "ma", "aa", "wa", "sta", "ab", "za", "r", "array", "ao", "ga", "m", "ana", "auto", "ac", "da", "an", "w", "fa", "aj"], "res": ["css", "wcs", "ref", "rest", "right", "pres", "press", "ross", "arts", "breaks", "re", "box", "outs", "ores", "val", "rets", "repl", "rus", "names", "Results", "resh", "params", "g", "vals", "ours", "root", "RS", "ces", "reg", "values", "obj", "out", "ras", "valid", "core", "mr", "nos", "r", "js", "data"], "x": ["ex", "key", "abc", "xx", "inf", "all", " you", "int", "sex", "name", "id", "re", "rx", "o", "xs", "h", "c", "Y", "g", "www", "XX", "image", "j", "r", "data", "cross", "python", "xy", "xi", " _", "xxxx", "m", "ix", "sp", "code", "X", "xa", "w", "xp", "index"], "y": ["key", "uy", "sky", "good", "id", "re", "ym", "o", "ray", "h", "c", "Y", "pay", "g", "yang", "hot", "j", "min", "yy", "py", "out", "say", "ory", "python", "xy", "vy", "m", "err", "my", "ya", "zy", "hy", "iy", "year", "X", "iny", "w", "bar", " Y", "wy"], "best": ["key", "rest", "right", "rew", " Best", "largest", "ward", "all", "master", "good", "round", "prev", "bottom", "instance", "effective", "perfect", "est", "root", "maximum", "py", "rand", "ast", "value", "true", "ale", "stars", "average", "bad", "go", "err", "highest", "aster", " better", "no", "latest", "Best", "last", "missing", "null", "only"], "b": ["xb", "j", "ab", "z", "ib", "u", "rb", "bb", "n", "r", "v", "ba", "wb", "db", "fb", "part", "k", "bi", "id", "be", "m", "bf", "eb", "bs", "mb", "bp", "line", "o", "sb", "lb", "nb", "bound", "e", "base", "cb", "h", "dy", "c", "number", "g"], "R": ["P", "Q", "D", " r", "right", "RGB", "RW", "I", "r", "Rs", "RN", "range", "M", "A", "RH", "RA", "NR", "Array", "Rh", "G", "Rec", "U", "CR", "RR", "Res", "W", "O", "Ra", "C", "Length", "V", "Range", "L", "X", "RF", "K", "RG", "B", "rs", "F"], "i": ["ti", " I", "fi", "ih", "qi", "phi", "uri", "int", "name", "multi", "ei", "id", "o", "io", "iq", "h", "c", "g", "ini", "ci", "si", "j", "eni", "im", "r", "xi", "bi", "my", "ix", "mini", "ang", "hi", "w", "gi", "index", "cli", "api", "u", "I", "ui"], "append": ["include", "add", "text", "open", "pull", "insert", "attach", "data", "shift", "pop", "next", "left", "begin", "element", "init", "app", "write", "bind", "before", "cat", "pad", "join", "attr", "ext", "just", "push", "start", "remove", "patch", "delete", "repeat", "sort", "ind", "php", "end"], "pout": ["pdout", "procout", "procinc", "procobj", "pinc", "pobj", "wpOut", "wpout", "pdOut", "pOut", "wpobj", "pdobj", "procOut", "pdinc", "wpinc"]}}
{"code": "def esPal(x):\n  \treturn str(x) == str(x)[::-1]\n  \n  t = int(raw_input())\n  \n  for case in range(t):\n  \tline = raw_input().split(' ')\n  \ta = int(line[0])\n  \tb = int(line[1])\n  \n  \ti = int(a**.5)\n  \tif i*i != a:\n  \t\ti += 1\n  \tmax = int(b**.5)\n  \tcantidad = 0\n  \twhile i <= max:\n  \t\tif esPal(i) and esPal(i*i):\n  \t\t\tcantidad += 1\n  \t\ti += 1\n  \n  \tprint 'Case #'+str(case+1)+':', cantidad\n", "substitutes": {"x": ["ex", "text", "es", "z", "u", "xxx", "input", "n", "xx", "v", "s", "xml", "pair", "cross", "data", "python", "element", "xi", "xc", "name", "content", "xes", "d", "fx", "p", "m", "event", "rx", "tx", "e", "xs", "h", "y", "f", "code", "q", "X", "c", "lex", "string"], "t": ["l", "tc", "j", "z", "u", "n", "count", "s", "v", "ot", "tt", "port", "te", "int", "type", "k", "d", "p", "m", "template", "time", "ta", "o", "e", "temp", "h", "y", "diff", "start", "pt", "f", "tick", "the", "q", "c", "T", "dt", "g", "ut", "w"], "case": ["section", "Case", "address", "size", "rice", "sea", "ce", "loc", "mode", "count", "me", "pe", "slice", "trial", "shift", "ase", "chance", "se", "type", "choice", "ie", "name", "day", "d", "id", "p", "ace", "position", "time", "nce", "sequence", "match", "length", "cases", "test", "e", "ice", "f", "code", "switch"], "line": ["LINE", "log", "section", "l", "band", "cell", "text", "link", "strip", "page", "le", "zip", "inline", "feed", "unit", "comment", "loc", "range", "r", "shell", "data", "slice", "object", "chain", "source", "cycle", "style", "se", "ine", "ne", "frame", "parse", "sync", "do", "part", "day", "side", "pos", "phase", "entry"], "a": ["aa", "ai", "l", "wa", "sta", "ab", "ama", "min", "alpha", "api", "u", "va", "ada", "am", "oa", "n", "ba", "s", "au", "A", "sa", "array", "asa", "qa", "area", "ga", "ae", "d", "p", "o", "ac", "la", "da", "ea", "e", "ca", "an", "ad", "y", "f"], "b": ["l", "aa", "j", "min", "z", "ab", "alpha", "ib", "u", "rb", "n", "ba", "v", "s", "fb", "bi", "k", "li", "d", "body", "p", "limit", "m", "bf", "bc", "bs", "pi", "mb", "auto", "o", "ac", "bot", "nb", "e", "base", "ca", "h", "y", "f", "c"], "i": ["ai", "l", "ip", "j", "min", "z", "chi", "eni", "u", "ti", "ki", "ri", "api", "I", "n", "s", "v", "ui", "qi", "ori", "ic", "yi", "phi", "uri", "int", "xi", "ie", "k", "bi", "li", "ei", "d", "id", "p", "multi", "m", "iu", "pi", "ni", "mi"], "max": ["co", "min", "size", "right", "sup", "cu", "n", "range", "count", "now", "chain", "cycle", "it", "total", "int", "init", "Max", "default", "part", "k", "parent", "MAX", "limit", "id", "ace", "p", "work", "orig", "frac", "ax", "num", "cl", "auto", "mod", "ac", "base", "conf", "bug", "ca", "ad"], "cantidad": ["callit\u00e9", "cannity", " captity", "scantsidad", "callidad", " cantity", "scantidad", "cantiton", "lcantsilla", " canticity", "captilla", "cantsiton", "cantsity", "captity", "lcantidad", "cancit\u00e9", "lcantiton", " capticity", "lcantsidad", "cancidad", "cancicia", "cantity", "cantilla", "cantit\u00e9", "canticity", "centidad", "centicity", "cantsicity", "lcantity", " cantiton", "lcantilla", "lcantsiton", "centiton", "canniton", "cantsit\u00e9", "scantity", "scanticia", "cannidad", "scantsit\u00e9", "scantit\u00e9"]}}
{"code": "t = int(raw_input())\n  \n  max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]\n  \n  for i in range(t):\n  \tline = raw_input().split(' ')\n  \tn = int(line[0])\n  \ts = int(line[1])\n  \tp = int(line[2])\n  \n  \ttotal = 0\n  \n  \tfor j in range(3, len(line)):\n  \t\tt = int(line[j])\n  \t\tif t == 0:\n  \t\t\tif p == 0:\n  \t\t\t\ttotal += 1\n  \t\telif t%3 == 0:\n  \t\t\tif t/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\t\telif t/3 + 1 >= p and s>0:\n  \t\t\t\ttotal +=1\n  \t\t\t\ts -=1\n  \t\telif t%3 == 1:\n  \t\t\tif (t+2)/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\telse:\n  \t\t\tif (t+1)/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\t\telif (t+1)/3 + 1 >= p and s>0:\n  \t\t\t\ttotal +=1\n  \t\t\t\ts -=1\n  \n  \n  \n  \tprint 'Case #'+str(i+1)+':', total\n  \n  \n", "substitutes": {"t": ["l", "art", "ti", "lt", "b", "ot", "int", "rt", "table", "ta", "tp", "o", "ct", "h", "y", "start", "pt", "tmp", "c", "T", "g", "ut", "mt", "out", "set", "r", "qt", "m", "time", "x", "a", "w", "at", "st", "nt", "u", "gt", "tt", "te", "it"], "max": ["step", "maximum", "min", "size", "out", "iter", "count", "trial", "it", "all", "type", "default", "Max", "k", "current", "limit", "id", "m", "time", "list", "table", "x", "num", "times", "length", "top", "temp", "Total", "no", " T", "long", "q", "number", "c", "w", "ts", "end", "last"], "i": ["l", "ai", "ip", "ij", "z", "iw", "ib", "u", "ti", "col", "I", "im", "r", "v", "b", "ui", "count", "slice", "int", "xi", "type", "ie", "k", "li", "d", "id", "stat", "m", "iu", "uni", "pi", "jo", "num", "di", "o", "io", "ix", "info", "oi", "e"], "line": ["co", "l", "inline", "key", "input", "b", "shell", "chain", "ne", "frame", "name", "id", "file", "list", "cl", "point", "o", "rule", "cle", "string", "c", "column", "LINE", "log", "section", "le", "lo", "lines", "case", "out", "data", "group", "se", "item", "sync", "do", "entry", "time", "po", "no"], "n": ["l", "z", "size", "pn", "count", "b", "v", "ot", "span", "np", "net", "ne", "k", "nr", "d", "m", "na", "ns", "x", "ni", "num", "N", "nb", "e", "no", "en", "y", "sn", "f", "c", "number", "w", "nt"], "s": ["l", "b", "tests", "stats", "downs", "tp", "steps", "comments", "posts", "xs", "ments", "y", "c", "g", "resses", "strings", "si", "sec", "lines", "size", "ing", "sets", "ubs", "r", "percent", "less", "se", "blocks", "qs", "words", "m", "ns", "x", "its", "ries", "ges", "os", "spec", "sp", "ls"], "p": ["l", "pp", "b", "pr", "ot", "op", "prev", "tp", "point", "o", "proc", "ap", "h", "y", "pt", "c", "g", "pa", "per", "py", "r", "lp", "np", "et", "al", "m", "po", "x", "local", "sp", "a", "com", "http", "at", "w", "nt", "u", "col", "paper", "cp"], "total": ["otal", "alpha", "key", "right", "volume", "scale", "all", "stats", "multi", "active", "gross", "ta", "tp", "json", "start", "ma", "fo", "basic", "doc", "quant", "created", "note", "size", "complete", "iter", "valid", "r", "percent", "value", "less", "partial", "free", "next", "dat", "average", "token", "auto", "local", "confirmed", "no"], "j": ["bj", "note", "J", "uj", "l", "ip", "ji", "z", "obj", "ij", "jl", "u", "r", "b", "v", "jp", "all", "it", "ie", "k", "li", "nr", "pos", "id", "d", "m", "x", "num", "je", "dj", "str", "jj", "oj", "o", "e", "jit", "h", "y", "kj", "a"]}}
{"code": " \n  def is_palindrome(n):\n      s = str(n)\n      return s == s[::-1] \n  \n  palindromes = [[], [1,2,3,4,5,6,7,8,9], [11,22,33,44,55,66,77,88,99]]\n  all_palindromes = palindromes[1] + palindromes[2]\n  limit = [100]\n  \n  palindromic_squares = []\n  psqtop = 0\n  psqix = 0\n  \n  stdin = sys.stdin\n  for c in xrange(int(stdin.readline())):\n      a,b = map(int, stdin.readline().split())\n  \n      while psqtop < b:\n          while psqix >= len(all_palindromes):\n              ps = []\n              pp = 10 ** (len(palindromes)-1) + 1\n              for i in range(1,10):\n                  for p in palindromes[-2]:\n                      ps.append(i * pp + 10 * p) \n              palindromes.append(ps)\n              all_palindromes.extend(ps)\n  \n          sq = all_palindromes[psqix] * all_palindromes[psqix]\n          if is_palindrome(sq):\n              palindromic_squares.append(sq)\n          psqix  += 1\n          psqtop = sq\n  \n      aix = bisect.bisect_left(palindromic_squares, a)\n      bix = bisect.bisect_right(palindromic_squares, b)\n  \n      print \"Case #%i: %i\" % (c+1, bix-aix) \n", "substitutes": {"n": ["l", "j", "z", "t", "r", "v", "node", "nw", "np", "net", "ne", "ln", "name", "nis", "k", "nor", "d", "m", "na", "dn", "ns", "x", "N", "o", "nb", "e", "Ns", "names", "nt", "nc", "nn", "nm", "en", "y", "f", "sn", "nit", "network", "fn", "g"], "s": ["es", "lines", "services", "sys", "new", "ing", "ins", "t", "sets", "states", "ss", "ses", "js", "less", "source", "cs", "stats", "sv", "ips", "ds", "tes", "d", "ys", "m", "sg", "bs", "ns", "sym", "abs", "south", "str", "o", "sb", "os", "e", "Ns", "ws", "xs", "ls", "ings"], "palindromes": ["palndchromides", "palindrimides", "palindromeides", "palindrems", "palndchroms", "palendromists", "palindrumes", "palindchromers", "palintramES", "palindromee", "palindramES", "palindchromese", "palendchromions", "palindchromes", "palindreme", "palindromeers", "palindrames", "palindrumese", "palindromES", "palindrome", "palindremES", "palendromeides", "palintromES", "palindromeES", "palndromese", "palndchrome", "palndromee", "palindrones", "palindromists", "palendromides", "palindremes", "palndromees", "palindroms", "palendchromides", "palendromeES", "palindchromists", "palindromese", "palindronES", "palndroms", "palindramese"], "all_palindromes": ["all_palendromee", "all_palindronES", "all_palindromee", "all_palindromises", "all_palendromeES", "all_palindromeese", "all_palintrames", "all_palintrame", "all_palindramises", "all_palindchrome", "all_palendromeese", "all_palindremides", "all_palintramises", "all_palindchromises", "all_palindrame", "all_palintromES", "all_palindroms", "all_palindromeES", "all_palindramES", "all_palindromides", "all_palindromeides", "all_palindrones", "all_palindromeises", "all_palendrome", "all_palindrome", "all_palendromese", "all_palindramese", "all_palindremES", "all_palindchromese", "all_palindreme", "all_palindromees", "all_palindrams", "all_palindremes", "all_palendromES", "all_palindchromes", "all_palendromides", "all_palindchromides", "all_palendromees", "all_palendromes", "all_palendromeides"], "limit": ["shape", "ip", "min", "page", "pl", "unit", "iter", "lim", "path", "limited", "range", "source", "scale", "order", "limits", "default", "type", "batch", "buffer", "pos", "file", "position", "pi", "cl", "line", "ignore", "length", "info", "offset", "extra", "skip", "base", "filter", "cache", "Limit", "split", "timeout", "seq"], "palindromic_squares": ["palindromic_squests", "palindromic_Squared", "palindromic_shared", "palindromic_squers", "palindromic_collars", "palindromic_quakes", "palindromic_Squares", "palindromic_squakes", "palindromic_Squers", "palindromic_quares", "palindromic_collares", "palindromic_quests", "palindromic_shares", "palindromic_square", "palindromic_collests", "palindromic_Squests", "palindromic_shakes", "palindromic_sqars", "palindromic_Square", "palindromic_quers", "palindromic_quare", "palindromic_sqers", "palindromic_sqares", "palindromic_sqared", "palindromic_squared", "palindromic_squars", "palindromic_shars", "palindromic_quared", "palindromic_Squars", "palindromic_quars", "palindromic_collers"], "psqtop": ["insqbot", "psqbot", "inseqtop", "pswsize", "pesqtops", "psqunum", "inseqbot", "psdqnum", "pseqbot", "PSwbot", "PSwsize", "pschtop", "psqutop", "PSwTOP", "pesqdot", "pswtop", "pswTOP", "psqusize", "insqnum", "peschdot", "psdqtop", "psqqtops", "psqprefix", "psquprefix", "peschtop", "psdqbot", "pschprefix", "psqnum", "inseqnum", "pschtops", "PSwtop", "pseqsize", "PSqsize", "psqubot", "psdqix", "psqutops", "psquix", "PSqtop", "psqqtop", "peschtops"], "psqix": ["tsqfix", "tsqill", " pseqix", "psqutop", "psquantix", "ssqufix", "pspedom", "psqqdepth", " pseqtop", "tscoreix", "tsqix", "psquius", "psqlius", " psqfix", "psqacenter", "pscorefix", "psquanttop", "pqfix", "ipsqtop", "psqlfix", "pspefix", "psqlix", "psqqx", "psqdepth", "ssqutop", "pscoreix", "psquantx", "pseqdepth", "ipsqx", "psqaprefix", "pqdom", "psqux", "ipsqcenter", "ssqx", "pqufix", "psqcenter", "psqprefix", "psquantfix", "psqafix", "psquix"], "stdin": ["putin", "dustout", "stinf", "stdinf", " stdIn", "stdout", "stin", "dustIn", "STDIN", "ddin", "fileins", " stdinf", "stins", "STDin", "stdins", "putinf", "filein", "stIN", "STDdin", " stdout", " stdins", "stdIN", "stout", "STDinner", "dout", "dIN", "stddin", "fileino", "din", "dustin", "putout", " stdino", "STDout", " stdinner", "stino", "STDIn", "fileout", "stdIn", "putins", "stdinner"], "c": ["co", "l", "log", "dc", "z", "size", " pc", "case", "u", "t", "cc", "col", "abc", "r", "count", "cor", " count", "ic", "toc", "np", "xc", "k", "ch", "cm", "d", "ace", "bc", " cp", "x", "cl", "gu", "ct", "ac", " f", "pc", "e", "nc", "h", "cn", "y"], "a": ["ak", "ai", "aa", "wa", "ab", "alpha", "u", "va", "am", "ba", "sa", "A", "qa", "int", "aw", "ae", "d", "na", "ac", "up", "da", "ap", "la", "e", "ea", "an", "ad", "ca", "y", "ar", "f", "af", "q", "at", "w", "fa", "pa", "aj"], "b": ["l", "aa", "j", "ab", "null", "ib", "u", "rb", "bb", "emb", "r", "v", "wb", "ba", "db", "next", "bh", "fb", "back", "k", "bi", "d", "be", "bf", "m", "eb", "body", "bc", "bs", "binary", "x", "abs", "bp", "o", "lb", "bur", "nb", "e", "base", "cb"], "ps": ["pse", "es", "ppa", "pl", "py", "ras", "amps", "Ps", "eps", "ss", "ms", "mp", "lp", "pm", "ks", "pr", "pe", "cp", "js", "les", "cs", "hes", "aps", "ping", "alls", "ds", "ys", "qs", "bps", "bs", "po", "tips", "ns", "maps", "ases", "os", "posts", "vs", "pg", "sp"], "pp": ["P", "ff", "ip", "ppa", "j", "pl", "py", "pn", "pill", "sup", "mp", "lp", "pm", "cp", "pe", "pr", "ipp", "ppo", "upp", "pop", "jp", "np", "ping", "app", "pb", "dp", "k", "ppe", "wp", "po", "x", "pi", "tp", "bp", "length", "PP", "pg", "gp", "sp", "cpp"], "i": ["P", "ai", "l", "ip", "j", "z", "page", "u", "clip", " I", " pi", "I", "r", "v", "qi", "phi", "it", "int", "xi", "ie", "k", "li", "ei", "d", "id", "pos", "pid", "iu", "m", "x", "pi", "mi", "di", "ix", "e", "h", "abi", "start", "f", "q"], "p": ["P", "ip", "j", "plug", "py", "pn", " iP", " ip", "u", "col", " gp", "lp", "v", "pe", "cp", "op", "hp", "ic", "jp", "it", "np", "int", "k", "dp", "li", "pa", "d", "id", "par", "pid", "wp", " xp", " cp", "x", "pi", "bp", "tp", "point", "gu", "o"], "sq": ["esc", "seq", "qi", "qq", "sky", "sh", "sql", "ct", "iq", "supp", "rr", " square", "sb", "si", "qu", "hess", "scl", "sf", "np", "zen", "sync", "qs", "aq", "frac", "ix", "crit", "spec", "ape", "sub", "square", "small", "Squ", "sup", "col", "cap", "req", "cp", "eq", "cs", "db"], "aix": ["AIX", "Aix", "Aox", " aik", " aius", "aox", "aius", "baix", "Aik", "aIX", "baIX", "pik", "box", "pius", " aox", "bius", "pix", "baox", "pox", "aik", "bIX", "baius", "Aius"], "bix": [" bica", " biz", "cica", "bica", "sbox", "aox", "cix", "aius", " bik", "bik", "sbix", "box", " bius", "cik", "aiz", "sbiz", "biz", "bius", "aik", " box", "cius", "sbius", "aica"]}}
{"code": " \n  T = int(stdin.readline())\n  for i in xrange(1,T+1):\n  \tns = map(int, stdin.readline().split())\n  \tN,S,p = ns[0:3]\n  \t\n  \th = 0\n  \tz = 0\n  \n  \tfor n in ns[3:]:\n  \t\tif n <= 1:\n  \t\t\tif n >= p: h += 1\t\n  \t\telif (n+2) // 3 >= p:\n  \t\t\th += 1\n  \t\telif (n+4) // 3 >= p:\n  \t\t\tz += 1\n  \n  \tprint \"Case #%d: %d\" % (i, h + min(S,z))\n  \n  \n", "substitutes": {"T": ["P", "Q", "TS", "Z", "D", "Ti", "Size", "t", "ti", "H", "I", "M", "NT", "phi", "Time", "time", "G", "TN", "TI", "Ni", "Ns", "W", "O", "Total", "E", "y", "C", "f", "V", "L", "X", "c", "TT", "Y", "K", "B", "w", "F", "ts", "Num"], "i": ["l", "inter", "ip", "j", "chi", "ti", "u", "t", "ri", "I", "im", "b", "v", "inf", "it", "phi", "uri", "int", "xi", "init", "bi", "k", "li", "d", "id", "pos", "m", "x", "pi", "num", "ni", "di", "io", "ix", "end", "e", "nc", "no", "zi", "y"], "ns": ["features", "lines", "ins", "sts", "eps", "states", "ms", "s", "strings", "NT", "cs", "ids", "np", "net", "int", "stats", "ne", "aps", "models", "sync", "ats", "breaks", "nets", "pos", "works", "qs", "na", "bs", "outs", "ens", "notes", "abs", "ni", "Ni", "cases", "os", "nb", "vs", "Ns", "names"], "N": ["P", "Q", "J", "Z", "D", "Size", "H", "I", "M", "A", "NT", "G", "U", "PI", "Ni", "Ns", "W", "O", "C", "V", "L", "X", "c", "Y", "K", "B", "w", "F", "g", "NS", "R"], "S": ["P", "Q", "J", "Z", "D", "u", "H", "I", "s", "v", "M", "A", "Ds", "G", "x", " s", "U", "Sa", "o", "Ns", "W", "ps", "sp", "O", "SL", "y", "C", "V", "Si", "L", "X", "Y", "K", "B", "w", "F", "g", "SS", "NS", "R"], "p": ["P", "l", "j", "pp", "api", "t", "u", "pn", "H", "I", "b", "s", "v", "r", "cp", "lp", "pr", "np", "app", "k", "dp", "part", "pos", "d", "m", "x", "pi", "tp", "bp", "vp", "o", "point", "Py", "pc", "ap", "e", "ps", " P", "sp", "pre"], "h": ["log", "l", "oh", "j", "min", "alpha", "t", "u", "hr", "loc", "max", "gh", "H", "b", "s", "v", "ih", "hp", "shift", "phi", "bh", "hs", "ho", "hd", "k", "d", "pos", "m", "sh", "x", "he", "o", "length", "e", "hi", "hm", "dh", "y", "a", "f"], "z": ["P", "l", "exp", "wa", "hz", "j", "Z", "zip", "zz", "t", "u", "zh", "H", "r", "b", "s", "v", "so", "inf", "ih", "qq", "yi", "phi", "zen", "k", "az", "fl", "d", "cz", "yz", "m", "zone", "wx", "sh", "x", "ph", "o", "zo", "e", "hi"], "n": ["l", "t", "b", "ot", "all", "int", "ne", "nor", "id", "o", "nb", "Ns", "nc", "nn", "y", "c", "g", "nd", "j", "min", "size", "eni", "r", "m", "x", "ni", "an", "no", "en", "a", "network", "w", "nu", "nt", "pn", "u", "I", "s", "it", "k"]}}
{"code": " \n  N = 10**4\n  \n  def isp(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  fs = []\n  for i in range(N):\n      s = str(i)\n      n1 = int(s + s[::-1])**2\n      n2 = int(s[:-1] + s[::-1])**2\n  \n      if isp(n1):\n          fs.append(n1)\n      if isp(n2):\n          fs.append(n2)\n  \n  fs.sort()\n  \n  print(fs, file=sys.stderr)\n  \n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      board = []\n      A, B = map(int, fin.readline().split())\n  \n      i = bisect.bisect_left(fs, A)\n      j = bisect.bisect_right(fs, B)\n  \n      print(\"Case #%d: %s\" % (case, j-i))\n  \n  \n", "substitutes": {"N": ["P", "J", "Q", "Z", "D", "NI", "H", "I", "RN", "M", "NA", "NT", "Len", "SN", "NP", "NN", "NB", "NE", "NM", "ns", "G", "No", "Ni", "Ns", "W", "O", "Num", "E", "C", "Ne", "S", "V", "L", "X", "number", "K", "Y", "F", "NS", "R"], "n": ["l", "size", "z", "t", "r", "b", "v", "node", "ne", "net", "np", "name", "k", "d", "p", "m", "ns", "x", "num", "ni", "o", "nb", "Ns", "e", "nt", "nc", "nn", "no", "y", "a", "f", "sn", "c", "number", "g", "fn", "nu", "ny"], "s": ["l", "b", "stats", "ows", "o", "xs", "y", "start", "string", "c", "g", "sb", "ends", "strings", "si", "lines", "size", "ing", "sets", "ses", "sf", "js", "ves", "sie", "ies", "sync", "qs", "words", "m", "bs", "ns", "settings", "os", "spec", "ls", "ssl", "a", "sd", "ips", "gs"], "fs": ["jobs", "Fs", "feed", "fle", "tests", "fc", "ows", "ils", "outs", "list", "cells", "rets", "parents", "fits", "lf", "xs", "fw", "facts", "ails", "fp", "vals", "fo", "ends", "videos", "lines", "df", "reports", "ses", "sf", "farm", "ves", "ids", "frames", "blocks", "qs", "bf", "linux", "ns", "gets", "os"], "i": ["l", " ip", "ti", "ce", " I", "fi", "b", "ih", "qi", "ase", "int", "ace", "id", "o", "io", " ie", "y", "start", "c", "ini", "CI", "ci", "si", "ite", "ij", "eni", "ri", " ii", "r", "isi", "xi", "bi", "m", "bc", "x", "ni", "race", "ix", "base", "hi"], "n1": ["yn2", "N2", "null", "nb1", "nb2", "NA", "N1", "nn1", " nA", "n3", "nbA", "yn1", "nnull", "Null", "N3", "yn3", "nA", "nn2", " n3", "ynA", " null", "nn3"], "n2": ["atwo", "iTwo", "N2", "itwo", "n72", " n72", "a2", "e4", "Ntwo", "nb2", "aTwo", "eTwo", "N1", "ne02", " n02", "a02", "n02", " n4", "i2", "n4", "N02", "e2", "i02", "ntwo", " nTwo", "nb72", "nTwo", "netwo", "ne1", " ntwo", "ne2", "nb4", "nbTwo", "e72"], "fin": ["spin", "fun", "fer", "lines", "rf", "final", "iter", "trans", "finished", "fit", "fi", "r", "req", "fd", "data", "lib", "conn", "main", "fen", "net", "bin", "init", "ln", "fat", "pos", "close", "die", "file", "ret", "fr", "err", "line", "fail", "rin", "os", "lin", "fork", "skip", "proc", "spec"], "T": ["Q", "J", "Case", " trial", "P", "TS", "Z", "D", "Ti", "t", "H", "I", "M", "NT", "Test", "TW", "WT", "G", " t", "U", "TN", "TI", "W", "O", "E", "C", "S", "V", "L", "X", "TT", "Y", "K", "CT", "F", "R"], "case": ["exc", "config", "Case", "section", "ite", "size", "sec", "rice", "ce", "cas", "I", "count", "b", "me", "cp", "pe", "uc", "call", "slice", "trial", "shift", "ase", "se", "ie", "name", "bi", "li", "ace", "d", "p", "ose", "time", "position", "bc", "nce", "x", "match", "line", "race", "cases"], "board": ["ff", "fer", "feed", "cas", "ss", "ses", "loop", "found", "farm", "flat", "family", "cs", "se", "us", "pos", "trace", "file", "bc", " ff", "sequence", "cells", "fold", "proc", "os", "test", "base", "conf", "feat", "switch", " suite", "use", "lc", "finder", "fast", "ends", "seq", " suites"], "A": ["AR", "P", "J", "El", "Ca", "Case", "As", "DA", "D", "AA", "From", "LA", "H", "I", "AB", "AV", "NA", "AM", "Ab", "AP", "SA", "This", "The", "App", "AS", "G", "AE", "U", "AW", "He", "All", "AI", "At", "W", "Ar", "O", "CA", "AF", "BA", "E"], "B": ["P", "J", "Q", "Ub", "WB", "QB", "API", "D", " b", "FB", "GB", "LA", "IB", "UB", "AB", "I", "b", "BF", "M", "LB", "Band", "SB", "Ab", "PB", "AP", "VB", "NB", "BL", "Bs", "G", "U", "BER", "BY", "Blue", "FF", "BS", "W", "EB", "BA", "E"], "j": ["J", "l", "uj", "ai", "adj", "ji", "z", "ij", "JC", "br", "JD", "ib", "r", "b", "I", "v", "qi", "jp", "ne", "ie", "bi", "k", "li", "ch", "d", "pos", "p", "m", "uni", "ion", "ni", "jo", "je", "jj", "o", "jump", "IJ", "e", "a", "f"]}}
{"code": " fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      numbers = map(int, fin.readline().split())\n      N, S, p = numbers[:3]\n      T = numbers[3:]\n      normal_limit = p + 2*max(0, (p-1))\n      surpising_limit = p + 2*max(0, (p-2))\n  \n      normal_count = 0\n      surprising_count = 0\n  \n      for t in T:\n          if t >= normal_limit:\n              normal_count += 1\n          elif t >= surpising_limit:\n              surprising_count += 1\n  \n      result = normal_count + min(surprising_count, S)\n  \n      print \"Case #%d: %s\" % (case, result)\n  \n", "substitutes": {"fin": ["fun", "ir", "min", "br", "final", "iter", "hr", "han", "trans", "fi", "n", "inn", "req", "fd", "thin", "pen", "conn", "des", "fen", "dir", "bin", "init", "fb", "ln", "zen", "gen", "fat", "rt", "close", "die", "file", "fr", "inner", "err", "syn", "rec", "win", "rin", "os", "lin"], "T": ["P", "Q", "Case", " trial", "DT", "TS", "Z", "D", "Ti", "TH", "Python", "H", "I", "n", "count", "IP", "M", "A", "NT", "Test", "int", "type", " TT", "WT", "Time", "time", "TA", " C", "G", "U", "TN", " number", "length", " F", "W", " P", "Times", "O", "Total", "E"], "case": ["step", "P", "section", " trial", "Case", "address", "size", "page", "ASE", "sea", "ce", "mode", "core", "count", "loop", "pe", "pair", "slice", "trial", "ase", "chance", "se", "type", "choice", "name", "ace", "id", "phase", "trace", "time", "position", "x", "sequence", "point", "match", "line", "race", "length", "cases", "e"], "numbers": ["nnotations", "bynums", "neumber", "nNumbers", " nundreds", "numumbers", "nonumbers", " nNumbers", "numums", "neums", "Numbers", "neumbers", "bynumber", "enumbers", "numumber", "nonounters", "nounters", "neounters", "nums", "numnotations", "hounters", " number", "ennotations", "humber", "Number", "enums", "nonumber", "NNumbers", "bynumbers", "bynNumbers", "nundreds", "humbers", "bynundreds", "Nundreds", "number", "enumber", "hums", "nonums", "bynnotations"], "N": ["P", "Q", "Z", "D", "H", "n", "I", "M", "A", "NT", "np", "NP", "G", "U", "num", "PI", " n", "nb", "Ns", "W", " P", "Number", "O", "E", "C", "V", "L", "X", "number", "Y", "K", "Count", "B", "F", "Num", "R", "nt"], "S": ["P", "Q", "TS", "size", "Z", "D", "PS", "i", "n", "I", "s", "M", "SU", "A", "SN", "G", " s", "U", "Sa", "SE", "W", "sp", "O", "sample", "SL", "E", "SP", "C", "V", "L", "X", "Y", "B", "g", "F", "SI", "SS", "NS", "R", "sq"], "p": ["Q", "l", "pp", "i", "b", "phi", "pot", "tp", "point", "PI", "h", "y", "start", "pt", "c", "j", "per", "lp", "pressure", "r", "np", "limit", "m", "x", "bp", "sp", "number", "w", "api", "u", "s", "cp", "port", "d", "pos", "PA", "num", "pad", "pc", "C"], "normal_limit": ["normalslimits", "normalscount", "standard_count", "standard_limit", " normal_length", "normalslimit", "standard_limits", "normal_length", "standard_base", "normal_limits", "normalsbase", " normal_limits", "normal_base"], "surpising_limit": ["surpicing_limits", "surpisinginglimits", "surpising_lock", "surpise_limit", "surpisingingcount", "surpise_count", "surpicing_count", "surpisinginglimit", "surpicing_limit", "surpise_size", "surpisingingid", "surpising_count", "surpicing_id", "surpicingingid", "surpicinginglimits", "surpicinginglimit", "surpise_lock", "surpicingingcount", "surpising_id", "surpising_limits", "surpising_size"], "normal_count": ["normal__count", "normal_base", "normallylimit", "normallyoffset", "normalscount", "total_limit", "norm_base", "total_count", "normal67limit", "standard_count", "standard_limit", "normalslength", "normal67offset", "normalacbase", "normalaclength", "total__count", "normallyCount", "standard_offset", "normaccount", "normal67count", "normal__length", "total__length", "total__offset", "normacbase", "normal_length", "normal67length", "norm_count", "normallycount", "normal_offset", "normaclength", "normal__limit", "total_offset", "standard_Count", "normalsbase", "normalaccount", "norm_length", "normal_Count", "total__limit", "total_length", "normal__offset"], "surprising_count": ["surtaining_count", "surtaining_length", "surprising67count", "surprising_check", "surprising_total", "surtaining_size", "surjoining_base", "surprising67limit", "surprises_count", "surprises_total", "surprising64count", "surjoining67count", "surprises_Count", "surprising_Count", "surprising48total", "surprising64check", "surprising67base", "surjoining_count", "surprising_limit", "surprising64limit", "surprising_base", "surprising_size", "surjoining_limit", "surjoining67base", "surjoining67limit", "surjoining67check", "surprises_limit", "surprising67check", "surprising48limit", "surprising64base", "surprising48Count", "surprising48count", "surprising_length", "surjoining_check"], "t": ["l", "j", "z", "i", "ti", "u", "set", "ont", "iot", "n", "r", "b", "s", "v", "ot", "tt", "_", "trial", "it", "te", "total", "int", "type", "tf", "on", "d", "id", "ort", "ace", "m", "time", " it", " ti", "x", "ta", "tp", "num", "tif", " i", " c"], "result": ["cur", "answer", "new", "obj", "RESULTS", "page", "progress", "final", "error", "df", "comment", "description", "pl", "now", "value", "term", "data", "trial", "order", "acc", "type", "default", "name", "compl", "arr", "warning", "current", "id", "resp", "round", "position", "ret", "trace", "err", "success", "sequence", "res", "response", "match", "grade"]}}
{"code": " \n  def read_ints():\n      return map(int, stdin.readline().rstrip().split(' '))\n  \n  def is_palin(n):\n      s = str(n)\n      return s == s[::-1]\n      \n  def find(n, fas):\n      for i in xrange(len(fas)):\n          if fas[i] >= n:\n              return i\n      return len(fas)\n      \n  def gen_fas(max):\n      fas = []\n      fasappend = fas.append\n      square, base, d = 1, 1, 3\n      while square < max:\n          if is_palin(square) and is_palin(base):\n              fasappend(square)\n          square += d\n          d += 2\n          base += 1\n      return fas\n      \n  def main():\n      MAX = 1000\n      fas = gen_fas(MAX)\n      \n      T = int(stdin.readline())\n      for Ti in xrange(T):\n          A, B = read_ints()\n          answer = find(B + 1, fas) - find(A, fas)\n          print 'Case #{}: {}'.format(Ti + 1, answer)\n          \n  main()\n", "substitutes": {"n": ["l", "j", "z", "size", "t", "u", "nos", "r", "b", "nu", "v", "count", "nw", "all", "net", "ne", "name", "k", "p", "m", "ns", "x", "ni", "num", "N", "o", "nb", "e", "Ns", "names", "nc", "nn", "no", "cn", "y", "en", "len", "a", "f", "sn"], "s": ["l", "ts", "es", "sq", "features", "services", "values", "ends", "lines", "u", "ing", "ins", "t", "sets", "states", "ss", "ses", "b", "ks", "v", "less", "array", "cs", "hs", "sv", "parts", "ds", "p", "m", "sg", "bs", "als", "ns", "o", "space", "os", "e", "Ns", "ps", "self"], "fas": ["sfas", "fingas", " fast", "lras", "sfAS", "frras", "lac", "infac", "fac", "pAS", "feast", "feas", "pase", "fras", "Faf", "infaos", "fare", "FAS", "Fa", "Fac", "cfras", " fAS", "tfAS", "cfAS", "fbAS", "fewas", "fase", "sfans", "tfac", "Fras", "faf", "fa", " faos", " fare", "Fas", "frAS", " fwas", "fraf", "fbaos", "pare"], "i": ["l", "ai", "ip", "j", "z", "D", "eni", "ti", " I", "ri", "u", "t", "I", "r", "v", "b", "qi", "ui", "ori", "it", "int", "xi", "init", "k", "bi", "li", "id", "p", "m", "iu", "x", "pi", "num", "ni", "N", "di", "mi", "o", "io", "ix"], "max": ["step", "shape", "min", "size", "z", "rand", "right", "cu", "count", "range", "node", "chain", "cycle", "cent", "total", "init", "Max", "k", "az", "limit", "id", "rank", "form", "std", "orig", "list", "ax", "x", "num", "rec", "auto", "mod", "line", "cache", "conf", "depth", "temp", "ca", "no", "div"], "fasappend": ["facend", "fASpush", "faosend", "fasterpush", " fasreplace", "fasend", "faosappend", " fASreplace", " fasend", "fASappend", " faspush", "facappend", "fasterreplace", "fasreplace", "fasterappend", "fASend", "fASreplace", "faospush", "faspush", "facpush", " fASpush", " fASappend", " fASend", "faosreplace"], "square": ["address", "ce", "right", "dim", "qq", "scale", "sky", "area", "ace", "rank", "round", "sh", "ball", "cube", "rule", "board", "char", "repeat", "feature", "le", "qu", "shape", "double", "size", "py", "cross", "circle", "se", "level", "maybe", "sync", "court", "x", "da", "layer", "copy", "du", "shadow", "number", "ape"], "base": ["based", "l", "address", "shape", "fixed", "center", "size", "null", "unit", "core", "ada", "range", "b", "count", "pe", "de", "ui", "Base", "circle", "scale", "se", "ase", "total", "array", "db", "ade", "name", "part", "bi", "area", "id", "p", "zone", "m", "site", "position", "sh", "index", "x", "pi"], "d": ["l", "dc", "min", "z", "D", "t", "u", "dx", "xd", "bd", "r", "b", "one", "distance", "data", "did", "dim", "dl", "db", "do", "part", "k", "ds", "p", "m", "ded", "dn", "x", "pad", "di", "o", "dom", "da", "e", "depth", "ad", "h", "y", "start", "pd"], "MAX": ["LINE", "Q", "RAW", "END", "Dim", "P", "ALL", "TS", "shape", "Size", "Z", "TH", "final", "D", "DC", "I", "SIZE", "EXT", "TYPE", "TX", "TR", "M", "DATA", "trial", "NUM", "MIN", "NT", "total", "init", "STEP", "Max", "Depth", "ID", "TW", "ION", "TA", "G", "U", "N", "FIX"], "T": ["Q", "P", "J", "TS", "Z", "D", "TH", "t", "H", "I", "TX", "TR", "M", "NT", "TC", "ID", "WT", "TA", "G", "U", "N", "TN", "TI", "length", "Tu", "W", "O", "Total", "E", "C", "Length", "S", "V", "L", "X", "TB", "TT", "Y", "K", "F"], "Ti": ["lo", "ai", "P", "Wi", "ip", "Na", "adi", "chi", "D", "ti", "t", "Sat", "I", "BI", "DI", "qi", "Po", "phi", "ie", "Ton", "bi", "ei", "Tok", "asi", "Ta", "Xi", "TA", " ti", "G", "ni", "U", "ta", "num", "N", "di", "pi", "TI", "io", "AI", "Ni"], "A": ["AR", "P", "Ac", "Ca", "API", "Na", "As", "AU", "D", "AA", "Ma", "LA", "Az", "AB", "I", "ACE", "AN", "AM", "Ab", "AP", "Am", "Alpha", "IA", "The", "Ha", "App", "TA", "AS", "G", "SAM", "U", "Answer", "N", "EA", "He", "AD", "AI", "W", "Ar", "O"], "B": ["P", "Q", "IO", "WB", "ab", "DB", "D", "BT", "IB", "UB", "Beta", "AB", "b", "BF", "LB", "BU", "VB", "Ab", "PB", "NB", "BL", "Bs", "Bo", "G", "U", "N", "BER", "BB", "CB", "BC", "BE", "W", "EB", "O", "BA", "Tab", "E", "MB", "S", "V"], "answer": ["support", "address", "uit", "text", "new", "size", "z", "abb", " answered", "error", "complete", "bb", "abc", "range", "au", "term", "air", "data", "duration", "array", "next", "order", "ell", "evidence", "average", "NN", "ace", "answered", "don", "Answer", "response", "option", "blank", "grade", "length", "BB", "offset", "result", "cache", "e"]}}
{"code": " \n  def program():\n  \tT = int(stdin.readline())\n  \tfor Ti in xrange(T):\n  \t\tnumbers = a = map(int, stdin.readline().rstrip().split(' '))\n  \t\tN, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]\n  \t\t\n  \t\tm = 0\n  \t\tcurr_S = S\n  \t\tfor i in xrange(N):\n  \t\t\tt = totals[i]\n  \t\t\t\n  \t\t\tif t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):\n  \t\t\t\tm += 1\n  \t\t\telif curr_S > 0 and t > 0:\n  \t\t\t\tif (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):\n  \t\t\t\t\tm += 1\n  \t\t\t\t\tcurr_S -= 1\n  \t\t\n  \t\tprint 'Case #%d: %d' % (Ti + 1, m)\t\n  \t\n  if __name__ == '__main__':\n  \tprogram()\n", "substitutes": {"T": ["P", "Q", "TS", "Z", "D", "Size", "TM", "H", "I", "n", "M", "A", "Test", "Ts", "TW", "Ta", "Time", "TA", "G", "TN", "TI", "Tu", "W", "O", "Total", "Tab", "E", "Part", "C", "Temp", "V", "L", "X", "TB", "TT", "Y", "K", "B", "F", "Num"], "Ti": ["P", "IO", "lo", "Wi", "Na", "chi", "ti", "u", "Vi", "I", "No", "qi", "Mi", "M", "tu", "Lt", "Po", "phi", "Hi", "Va", "Mon", "xi", " Xi", "Ton", "Pos", "Ts", "li", "ei", "Tok", "Ta", "Xi", "Time", "mi", "Mo", "TA", " ti", "Li", "pi", "U", "ta"], "numbers": ["nnotations", "monats", "tums", " nues", " nnotations", "cumbers", "nNumbers", "tumpy", "numumer", "enumer", "numters", "numumbers", " nats", " nlines", "Nums", " nNumbers", "monumbers", "tachers", "cues", "Numbers", "enumbers", " nters", "nats", "monhens", " nounters", "nounters", "numer", "dumbers", " nums", "nues", "clines", "Nats", "enters", "nums", "numnotations", " numpy", "counters", "nhens", " nhens", "ennotations"], "a": ["P", "l", "Na", "new", "z", "alpha", "args", "u", "r", "b", "s", "span", "data", "A", "sa", "array", "all", "Numbers", "total", "arr", "pos", "Array", "abs", "num", "o", "Args", "Total", "h", "y", "ar", "C", "c", "g", "B", "w", "Num"], "N": ["P", "Q", "Na", "Z", "D", "Size", "NI", "H", "I", "n", "M", "NA", "A", "NT", "Len", "NP", "Tw", "Nat", "G", "No", "U", "PI", " n", "Ni", "Ns", "W", "O", "Num", "E", "Sn", "Part", "C", "Ne", "V", "L", "X", "Y", "K", "B", "Pi"], "S": ["P", "J", "Q", "Z", "D", "PS", "u", "ss", "H", "I", "n", "s", "M", "SU", "A", "se", "SA", "G", " s", "U", "Sa", "SE", "W", "ps", "sp", "O", "E", "C", "V", "Si", "L", "X", "K", "Y", "B", "g", "F", "SI", "SS", "NS"], "p": ["P", "l", "lp", "ip", "j", "z", "pp", "per", "case", "u", "pn", "Ps", "n", "r", "b", "s", "pr", "v", "pe", "cp", "M", "au", "Po", "np", "int", "part", "k", "d", "x", "pi", "tp", "point", "PI", "o", "up", "pc", "Pa", "top", "e", "ps"], "totals": ["Tfatalls", "tOTalls", "totsals", "tfatales", "towal", "total", "tOTales", "totsales", "TfatALS", "Totalls", "totalls", "towalls", "towales", "Totales", "Tfatals", "TotALS", "tOTals", "tfatal", "towals", "totsALS", "tfatals", "Total", "Totals", "totALS", "totsalls", "tOTALS", "tfatALS", "totales", "tfatalls", "Tfatales"], "m": ["l", "sm", "mm", "j", "mt", "z", "u", "Ms", "mr", "ms", "n", "r", "b", "s", "v", "md", "im", "mon", "M", "em", "phi", "int", " M", "me", "tm", "om", "d", "cm", "mass", "time", "mc", "sym", "x", "pi", "my", "mu", "ym", "fm", "mi", "o"], "curr_S": ["currJP", "curR_N", "currs_s", "curr_s", "curr_T", "curr__s", "curR_C", "currs_P", "currs_T", "curr__N", "curr_N", "curr_P", "currJT", "curr__S", "currs_S", "currJS", "curR_S", "curR_s", "curr__C", "currs_N", "currJs", "curr_C"], "i": ["Is", "II", "ai", "Q", "l", "j", "z", "Z", "ti", " iP", " I", "u", " pi", "I", "n", "b", "s", "v", "A", " si", "Po", "phi", "it", "np", "int", "xi", "k", "li", "d", "id", "G", "x", "pi", "U", "ni", "mi", "PI", "o", "Py", "e"], "t": ["l", "tc", "art", "ti", "b", "ot", "all", "int", "id", "ta", "tp", "o", "ct", "h", "y", "start", "tmp", "pt", "tree", "c", "g", "note", "tip", "j", "mt", "out", "r", "M", "et", "time", "tips", "x", "tim", "at", "w", "st", "nt", "u", "s", "tt"]}}
{"code": " \n  def get_number_of_test_case():\n      return int(raw_input().strip())\n  \n  def solve_case(t):\n      A, B = [int(x) for x in raw_input().strip().split()]\n  \n      print 'Case #%d: %d' % (t, get_number_of_palindrome(B) - get_number_of_palindrome(A - 1),)\n  \n  def get_number_of_palindrome(n):\n      ret = 0\n  \n      nt = int(math.floor(math.sqrt(n)))\n      total_column = int(math.ceil(math.ceil(math.log10(nt + 1)) / 2.0))\n      upper_limit = 10 ** total_column\n  \n      counter = 0\n      while counter < upper_limit:\n          c_str = [c for c in str(counter)]\n          c_str.reverse()\n  \n          number = str(counter)\n          for c in c_str:\n              number += c\n          number = int(number)\n          number = number ** 2\n          if number <= n and is_palindrome(number):\n              ret += 1\n  \n          number = str(counter)\n          for c in c_str[1:]:\n              number += c\n          number = int(number)\n          number = number ** 2\n          if number <= n and is_palindrome(number):\n              ret += 1\n          \n          counter += 1\n  \n      return ret\n  \n  def is_palindrome(n):\n      if n == 0:\n          return False\n      num = str(n)\n      check_len = len(num) / 2\n      ret = True\n      for i in range(check_len):\n          ret &= num[i] == num[-i - 1]\n      return ret\n  \n  T = get_number_of_test_case()\n  t = 1\n  while t <= T:\n      solve_case(t)\n      t += 1\n  \n", "substitutes": {"t": ["l", "art", "b", "ot", "int", "lit", "rt", "table", "ta", "tp", "o", "alt", "h", "y", "start", "pt", "tmp", "stop", "ut", "j", "out", "r", "qt", "et", "m", "time", "token", "a", "tim", "at", "w", "st", "end", "text", "window", "u", "s", "tt", "te", "it"], "A": ["AR", "P", "Q", "Ca", "Na", "D", "AA", "LA", "H", "I", "AB", "M", "NA", "AN", "AM", "Ab", "AP", "AH", "SA", "AL", "PA", "App", "TA", "G", "U", "N", "AW", "AD", "AI", "W", "Ar", "O", "CA", "AF", "E", "a", "C", "S", "V", "AST"], "B": ["AR", "P", "Q", "J", "WB", "QB", "DB", "Z", " b", "D", "AA", "GB", "AB", "H", "b", "BF", "LB", "M", "NB", "BL", "Bs", "G", "U", "N", "BER", "Blue", "BC", "BG", "BB", "BE", "BS", "W", "O", "AF", "BA", "E", "BD", "C", "S", "V"], "x": ["xb", "ex", "l", "z", "u", " X", "dx", "xe", "xxx", "xd", "r", "xx", "v", "expl", "bit", "data", " y", "xf", "xy", "int", "xi", "sex", "name", "xc", "k", "xxxx", "d", "ww", "p", "wx", " xp", "rx", " f", "e", "xxxxxxxx", "xs", " v", "h", "y", "f"], "n": ["l", "b", "ne", "int", "ln", "ec", "name", "nor", "nr", "o", "nb", "nc", "nn", "y", "j", "size", "nov", "mn", "r", "inn", "nw", "np", "zen", "m", "ns", "ni", "gn", "an", "no", "google", "en", "account", "nm", "a", "code", "bn", "network", "w", "ng", "nu"], "ret": ["sat", "fun", "ref", "rest", "fit", "seq", "lt", "all", "int", "lit", "function", "rt", "id", "re", "round", "val", "rets", "reset", "alt", "vert", "offset", "ut", "Ret", "reg", "mt", "sec", "obj", "out", "iter", "pret", "exit", "r", "value", "print", "python", "true", "order", "resp", "err", "er"], "nt": ["det", "dc", "out", "col", "count", "qt", "gt", "term", "nw", "NT", "conn", "net", "int", "total", "nr", "rt", "pent", "entry", "seed", "oct", "std", "digit", "ctr", "cat", "ns", "ant", "cont", "ct", "length", "offset", "nat", "nb", "nc", "nn", "nz", "len", "feat", "no", "tmp", "sn"], "total_column": ["total_layer", " total_layer", "total_row", "total54column", "total54layer", "total_limit", " total_limit", "total64group", "total64column", "total64number", "total64row", " total_group", " total_row", "total54row", "total64layer", "total64limit", "total54group", " total_number", "total_group", "total_number"], "upper_limit": ["upper_lim", "lower_limit", "upperflowrow", "upper_limited", "upper_row", " upper_lim", "lower_lim", "upperflowlimit", "upperflowlim", "lower_limited", " upper_row"], "counter": ["b", "master", "name", "nr", "re", "umber", "ctr", "runner", "field", "reset", "ct", "cont", "offset", "cher", "cube", "nb", "nc", "controller", "stop", "repeat", "keeper", "ester", "obj", "iter", "mr", "timer", "exit", "r", "term", "nw", "order", "entry", "time", "inner", "err", "sequence", "er", "race", "no", "code"], "c_str": ["c7tree", "coutfr", "c6set", "c_char", "c7url", "ci_char", "c_set", "c2string", " c_arr", "coderurl", " coutfr", "c__string", "c6dict", "c2str", "c1string", "coutstr", " c7tree", "c6str", " c_url", "ci_dict", "coderarr", "c_string", " c7url", "c1cr", "c7arr", "c1str", " coutbr", "c_arr", "ci_set", "c_fr", "coutbr", "callfr", "c6string", "ci_cr", "c2cr", "c_dict", " coutstr", "c_tree", "c_br", "c_cr"], "c": ["co", "l", "esc", "arc", "ce", "b", "chain", "fc", "ec", "mc", "list", "cont", "ct", "nc", "h", "y", "string", "g", "ci", "case", "oc", "core", "r", "m", "bc", "ac", "isc", "cache", "a", "code", "com", "w", "can", "dc", "u", "col", "uc", "call", "ic", "cent"], "number": ["address", " result", "byte", "key", "character", "b", "connection", "int", "company", "function", "name", "nr", "integer", "umber", "phone", "digit", "category", "language", "line", "option", "regular", "offset", "nn", "string", "maximum", "note", "double", "month", "size", "reference", "r", "value", "amount", "group", "order", "wrong", "roman", "token", "even", "breaking"], "num": ["loc", "dim", "init", "int", "name", "multi", "umber", "nom", "box", "oct", "digit", "o", "dom", "cube", "nam", "nb", "test", "h", "Num", "note", "out", "valid", "im", "term", "mon", " nu", "mom", "np", "m", "binary", "no", "nm", "bn", "off", "index", "nu", "end", "text", "unit", "u"], "check_len": ["key_pos", "check64min", "key_no", "check64len", "keyacline", " check_min", "check_den", "keyacpos", "keyacno", "check64den", "check2line", "check1len", "check2len", "checkacpos", "check2no", "check2pos", "check_no", "keyaclen", "checkacline", "check64line", "key_line", "check1min", " check_line", "check_min", "checkaclen", "key_len", "check1den", "check_line", "check1line", "check_pos", "checkacno", " check_den"], "i": ["ai", "l", "ip", "j", "ji", "z", "eni", "ti", "u", " I", "ri", "col", "I", "r", "b", "bit", "v", "qi", "ui", "fi", "yi", "it", "int", "xi", "ie", "k", "bi", "li", "ei", "d", "id", "p", "m", "iu", "uni", "ni", "pi", "di", "mi", "gu"], "T": ["P", "END", "DT", "Ret", "TS", "Z", "TH", " R", "TM", "GT", "H", "I", "TR", "M", "NT", "Test", "VT", "TG", "TW", " TT", "WT", "TF", " NT", "TA", "G", " N", "N", "TN", "W", "O", "Total", "E", "C", "S", "V", "L", "PT", "X", "TT", "Y"]}}
{"code": "t = int(raw_input().strip())\n  t_count = 1\n  while t_count <= t:\n  \tline = raw_input().strip().split()\n  \tn = int(line[0])\n  \ts = int(line[1])\n  \tp = int(line[2])\n  \tti_list = line[3:]\n  \tp_min = max(p * 3 - 2, p)\n  \tp_min_surprise = max(p * 3 - 4, p)\n  \tresult = 0\n  \tfor ti in ti_list:\n  \t\tti = int(ti)\n  \t\tif ti >= p_min:\n  \t\t\tresult += 1\n  \t\telif p_min > p_min_surprise and ti >= p_min_surprise and s > 0:\n  \t\t\tresult += 1\n  \t\t\ts -= 1\n  \tprint 'Case #%d: %d' % (t_count, result,)\n  \tt_count += 1\n", "substitutes": {"t": ["l", "tc", "z", "i", "u", "count", "b", "v", "qt", "r", "ot", "tt", "tu", "toc", "it", "type", "tf", "tm", "d", "m", "template", "time", "trace", "x", "ta", "tp", "o", "ty", "tn", "e", "temp", "h", "y", " T", "tick", "f", "q", "c", "T", "dt"], "t_count": ["ticancache", "t_check", "i_cache", " tacset", "p_count", "t05cache", "iicancheck", "twnumber", "t__length", "p_code", "c_length", "p_sum", "c_loop", "t__count", "t_set", "twlength", " tacweight", "t64length", "t05check", "ticancheck", "t64count", "taccount", " taccount", " tacnumber", "t_cache", "t4weight", "c_time", "t_time", "t_weight", "t4number", "c__time", "tacweight", "t__loop", "twset", "ticancount", " t_number", "t05count", "c__length", "tacnumber", "tacset"], "line": ["l", "detail", "inline", "key", "feed", "i", "shell", "model", "chain", "ne", "frame", "name", "id", "file", "look", "list", "cl", "rule", "lf", "cle", "string", "column", "LINE", "log", "lo", "le", "section", "lines", "data", "group", "se", "item", "sync", "entry", "no", "output", "code", "date", "liner", "end"], "n": ["l", "size", "i", "pn", "u", "r", "b", "count", "span", "np", "nr", "li", "pos", "d", "na", "ns", "pi", "num", "ni", "N", "o", "nb", "e", "nc", "no", "y", "a", "sn", "f", "number", "c", "g", "fn", "w", "nt", " ni"], "s": ["l", "ts", "es", "sq", "j", "size", "z", "services", "sec", "sections", "i", "u", "sets", "ss", "ims", "sf", "b", "v", "r", "tis", "ses", "su", "sa", "less", "se", "stats", "sv", "ds", "d", "m", "sg", "ns", "settings", "sh", "x", "ties", "seconds", "its", "o", "os"], "p": ["P", "l", "ip", "j", "pp", "per", "py", "i", "pn", "u", "lp", "count", "v", "cp", "pe", "pr", "b", "pair", "port", "pu", "jp", "np", "k", "d", "m", "po", "power", "x", "pi", "tp", "bp", "point", "pc", "ap", "e", "ps", "sp", "h", "pai", "y"], "ti_list": [" ti_l", "ti2id", "ti2List", "tu2list", "tu_list", "tu2List", "ti2list", "tu2id", " ti_List", "ti_id", "ti_List", " ti_record", "ti_block", "ti9list", "tu_block", "ti_l", "ti9block", "ti9id", "tu_List", "ti_record", "ti2block", "tu2block", "ti9List", "tu_id"], "p_min": ["t__all", "p__Min", "pammin", "pPcount", "p__all", "p00minimum", "t_min", "p_max", "p_Min", "p00sign", "pPrange", "p_minimum", "p_count", "P_min", "p_range", "p__min", "P_max", "pamall", "p_sign", "t__Min", "t_Min", "P_sign", "p00max", " p_max", "p_main", "p__main", "t_all", "pPmax", "p00min", " p_range", "t_main", " p_count", "t__main", "t__min", "pammain", "p_all", "P_minimum", "pamMin", "pPmin"], "p_min_surprise": ["p_min_curprise", "p_min_surprises", "p_min_urvey", "p_min_surprising", "p_min_urprises", "p_min_curprises", "p_min_Surprise", "p_min_urprise", "p_min_curvey", "p_min_Survey", "p_min_Surprising", "p_min_urprising", "p_min_survey", "p_min_Surprises", "p_min_curprising"], "result": ["progress", "i", "int", "function", "nr", "id", "rank", "runner", "grade", "counter", "start", "feature", "si", "nv", "kk", "case", "r", "value", "term", "data", "duration", "order", "se", "compl", "ret", "err", "spec", "number", "score", "error", "total", "current", "cup", "num", "res", "response", "row", "sr", "report", "zi"], "ti": [" vi", "ita", "i", " chi", "qi", " tu", " si", "phi", "uri", "int", "nis", " li", "id", "ta", "tp", " ie", " di", "ini", " mi", "ci", "pa", "si", "eni", "ri", " dj", "isi", "qt", "xi", "bi", "edi", "ni", "tta", "TI", "wi", "mini", "sil", "sp", "iti", " TI", "gi"]}}
