{"id1": "18989018", "id2": "22611968", "code1": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"doSetInput": [" doGetInput", " doSetContent", "dosetOutput", "dosetContent", "doGetContent", "doGetOutput", " doGetOutput", "doSetOutput", "doProcessInput", " doSetText", "dosetInput", " doGetText", "doGetInput", "doProcessOutput", "doProcessContent", "doProcessText", " doGetContent", " doSetOutput", "doSetContent", "doSetText", "doGetText", "dosetText"], "input": ["text", "form", "method", "util", "select", "remote", "expression", "output", "current", "client", "session", "inner", "field", "instance", "config", " inputs", "model", "head", "view", "Input", "command", "enter", "image", "present", "project", "install", "IN", "magic", "definition", "agent", "q", "argument", "act", "resource", "storage", "operator", "progress", "img", "error", "inf", "initial", "null", "exec", "child", "upload", "container", "list", "element", "submit", "raw", "impl", "parser", "insert", "request", "pull", "temp", "key", "entry", "reader", "type", "inc", "xml", "audio", "context", "active"], "monitor": ["p", "method", "meter", "summary", "out", "timer", "client", "pin", "mod", "config", "system", "state", "param", "timeout", "processor", "watch", "dm", "console", "manager", " monitors", "condition", "loader", "m", "module", "resource", "metadata", "progress", "mx", "directory", "callback", "subject", "counter", " Monitor", "mon", "channel", "mi", "Monitor", "bm", "handler", "cm", " monitoring", "wm", "mc", "reader", "unit", "pm", "report"], "root": ["work", "p", "remote", "result", "media", "output", "table", "out", "cover", "instance", "config", "home", "system", "this", "store", "archive", "slave", "owner", "manager", "src", "tx", "or", "process", "writer", "m", "folder", "resource", "Root", "location", "storage", "n", "directory", "base", "array", "null", "server", "host", "container", "target", "region", "plugin", "mount", "collection", "r", "parent", "node", "cms", "roots", "library", "http"], "format": ["form", "style", "filename", "util", "output", "FORM", "feature", "f", "config", "at", "model", "title", "event", "image", "et", "data", "magic", "writer", "service", "object", "location", "record", "transform", "act", "class", "base", "name", "spec", "Format", "function", "term", "api", "string", "fn", "handler", "element", "plugin", "filter", "parser", "attribute", "temp", "version", "template", "atter", "unit", "type", "ant", "pattern"], "source": ["text", "remote", "result", "output", "token", "client", "session", "inner", "instance", "config", "info", "component", "view", "use", "via", "driver", "src", "ource", "image", "SOURCE", "data", "Source", "service", "object", "resource", "proxy", "storage", "description", "spec", "secure", "container", "string", "connection", "scope", "channel", "size", "rule", "reference", "slice", "id", "reader", "unit", "rate", "parent", "node", "target", "content"], "in": ["text", "init", "buffer", "gin", "out", "session", "config", "image", "con", "isin", "name", "ins", "In", "slice", "inn", "token", "pin", "i", "conn", "or", "IN", "data", "ini", "win", "img", "n", "io", "nin", "include", "pull", "id", "parent", "bin", "str", "update", "socket", "ource", "resource", "from", "is", "container", "element", "value", "version", "login", "reader", "get", "din", "inc", "doc", "p", "inner", "c", "download", "f", "pass", "src", "inside", "read", "m", "on", "it", "min", "body", "index", "connection", "again", "r", "err"], "path": ["work", "text", "remote", "out", "session", "config", "alias", "PATH", "image", "loc", "location", "directory", "core", "base", "name", "log", "code", "true", "key", "template", "dir", "slice", "type", "pattern", "token", "sync", "this", "model", "component", "ath", "one", "data", "loader", "object", "binary", "password", "api", "thin", " Path", "mount", "id", "parent", "method", "str", "Path", "point", "link", "folder", "resource", " filename", "container", "string", "value", "step", "reader", "node", "content", "p", "filename", "port", " string", "pointer", "src", "host", "child", "index", "full", "route", "part", "walk"], "s": ["p", "ls", "sb", "ps", "ss", "sync", "session", "c", "f", "store", "sym", "e", "i", "l", "services", "src", "ds", "an", "m", "sys", "folder", "service", "ws", "storage", "n", "g", "sa", "si", "b", "share", "spec", "os", "fs", "sl", "secure", "stores", "h", "scope", " storage", "gs", "settings", "ns", "space", "abs", "sharing", "r", "ssl", "slice", "sf", "o", "sv", "S", "v", "js", "d", "http"], "file": ["p", "Image", "x", "filename", "remote", "copy", "File", "fp", "port", "output", "media", "f", "info", "store", "archive", "use", "il", "ile", "e", "l", "image", "xml", "data", "folder", "object", "resource", "binary", "open", "storage", "up", "directory", "FILE", "io", "base", "name", "b", "pe", "files", "string", "fn", "future", "full", " File", "value", "lib", "feed", "dir", "slice", "sf", "unit", "icon", "section", "node", "audio", "content"], "uri": ["text", "uni", "uid", "filename", "util", "username", "Url", "gi", "i", " URI", "image", "data", "abi", "service", "object", "location", "resource", "storage", "io", "base", "name", "database", "server", "URL", "ui", "query", "pi", "api", "address", "term", "iri", "connection", "rule", "prefix", "qi", "handler", "range", "attribute", "route", "cli", "dir", "URI", "id", "entry", "ri", "http"], "url": ["text", "ref", "str", "Url", "config", "store", "link", "l", "src", "ource", "image", "data", "object", "resource", "location", "sr", "io", "base", "name", "URL", "address", "sl", "string", "channel", "fr", "layer", "ul", "ssl", "key", "id", "user", "ri", "rel", "http"], "cd": ["CE", "cy", "cs", "CR", "md", "xc", "cf", "clean", "c", "lab", "de", "ca", "ds", "ci", "DC", "ce", "CD", "vd", "C", "CC", "cr", "nd", "pd", "gd", "dr", "rc", "cc", "arch", "cp", "dd", "cm", "co", "def", "xd", "CS", "ct", "cand", "ck", "cb", "d", "CF", "dc"], "valid": ["local", "Invalid", "normal", "style", "current", "Valid", "available", "empty", "successful", "all", "compatible", " invalid", "vals", "visible", "val", "present", "defined", "data", "required", "vari", " Valid", "allowed", "cert", "missing", "stable", "supported", "good", "multi", "VAL", "complete", "array", "standard", "multiple", "post", "secure", "list", "regular", "full", "legal", "iter", "bad", "value", "def", "sign", "id", "acceptable", "broken", "v", "correct", "pattern", "active"], "stream": ["flow", "message", "form", "video", "sw", "output", "client", "clean", "model", "content", "trans", "image", "read", "data", "writer", "object", "resource", "transform", "body", "container", "string", "Stream", "channel", "handler", "raw", "serial", "temp", "row", "feed", "response", "reader", "v", "draw", "context"], "document": ["text", "style", "filename", "video", "media", "output", "author", "system", "model", "this", "ocument", "image", "material", "data", "writer", "Source", "record", "object", "resource", "metadata", "description", "io", "Document", "Filename", "_", "Reader", "collection", "response", "template", "feed", "reader", "parent", "xml", "doc", "content"]}}
{"id1": "23008590", "id2": "10176678", "code1": "            public void run() {\n                URL url;\n                try {\n                    url = new URL(Config.UPDATE_SITE_URL);\n                    InputStream is = url.openStream();\n                    Writer writer = new StringWriter();\n                    char[] buffer = new char[1024];\n                    Reader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n                    int n;\n                    while ((n = reader.read(buffer)) != -1) {\n                        writer.write(buffer, 0, n);\n                    }\n                    String updatePage = writer.toString();\n                    is.close();\n                    writer.close();\n                    System.out.println(\"DOWNLOAD PAGE :\\n\" + updatePage);\n                    int pos1 = updatePage.indexOf(\"[ANA-CABV]\") + 10;\n                    int pos2 = updatePage.indexOf(\"[/ANA-CABV]\");\n                    int pos3 = updatePage.indexOf(\"[ANA-CABVURL]\") + 13;\n                    int pos4 = updatePage.indexOf(\"[/ANA-CABVURL]\");\n                    String currentVersion = updatePage.substring(pos1, pos2);\n                    currentVersionLabel.setText(currentVersionLabel.getText() + currentVersion);\n                    if (Double.valueOf(Config.VERSION) < Double.valueOf(currentVersion)) {\n                        downloadButton.setEnabled(true);\n                        label0.setText(mw.getLangMap().get(\"Update_Avalaible\"));\n                    } else label0.setText(mw.getLangMap().get(\"Update_NonAvalaible\"));\n                    downloadURL = updatePage.substring(pos3, pos4);\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n", "code2": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "label": 0, "substitutes": {"run": ["process", " Run", "output", "load", "java", "init", "install", "server", "apply", "info", "submit", "report", "Run", "work", "build", "start", "exec", " deploy", "login", "update", "Main", "execute", "test", "running", "up", "launch"], "url": ["lr", "image", "r", "blog", "service", "sl", "i", "host", "feed", "proxy", "il", "id", "page", "server", "address", "bel", "loc", "http", "location", "URL", "resource", "path", "hub", "ssl", "keeper", "file", "str", "f", "Url", "api", "base", "update", "download", "loader", "article", "name", "l", "browser", "string", "web", "ur", "uri", "source", "config", "www"], "is": ["lis", "r", "os", "in", "ai", "ip", "Is", "iterator", "image", "bis", "ie", "stream", "src", "i", "s", "app", "was", "its", "il", "ls", "id", "es", "isi", "address", "ris", "IS", "info", "ui", "or", "iss", "http", "ios", "io", "has", "ir", "out", "ini", "ais", "iter", "fs", "api", "ri", "err", "it", "browser", "ar", "as", "uri", "iv"], "writer": ["r", "in", "wire", "ner", "creator", "worker", "key", "feed", "layer", "write", "ee", "parent", "page", "maker", "handler", "server", "Writer", "written", "ler", "writers", "editor", "war", "word", "out", "work", "wr", "file", "director", "riter", "winner", "letter", "null", "zip", "data", "builder", "temp", "wer", "player", "er", "w", "driver", "writ", "string", "parser", "ws", "journal", "writing", "widget", "source", "walker"], "buffer": ["position", "bytes", "batch", "block", "queue", "transfer", "feed", "character", "slice", "sequence", "page", "Buffer", "cache", "phrase", "address", "stack", "source", "result", "padding", "resource", "buff", "row", "uffer", "iter", "buf", "binary", "base", "data", "player", "b", "border", "char", "wave", "memory", "bin", "string", "counter", "seed", "vector", "read", "layer", "length"], "reader": ["r", "iterator", "in", "ner", "worker", "Reader", "stream", "rer", "i", "input", "e", "rx", "handler", "per", "ler", "dr", "editor", "io", "ir", "rr", "row", "reading", "rar", "iter", "f", "ri", "loader", "er", "oder", "parser", "ser", "read", "source", "bird"], "n": ["r", "ne", "m", "j", "p", "ner", "h", "nor", "pos", "i", "s", "na", "nn", "e", "ns", "nt", "sn", "ng", "t", "N", "dn", "nc", "not", "num", "nin", "z", "out", "count", "nr", "len", "en", "x", "f", "o", "no", "k", "u", "b", "y", "number", "l", "d", "nl", "nb", "c"], "updatePage": ["updatedVersion", "updateUrl", "updateFile", "currentpage", "UpdateUrl", " updateVersion", "downloadPage", "updateLine", "currentLine", " updatepage", "downloadUrl", "currentServer", "downloadpage", " updateUrl", "downloadVersion", "updatedFile", " updateServer", " updateSite", "workLine", "updateSite", " updateLine", "updatedServer", "updatedPage", "updatedpage", "updateVersion", "updatedLine", "UpdateFile", "Updatepage", "UpdateVersion", "downloadLine", "workSite", "updateServer", "UpdatePage", "updatepage", " updateFile", "currentSite", "updatedUrl", "currentUrl", "currentPage", "workPage"], "pos1": ["POS3", " posOne", "positionOne", "Pos1", "POS0", "position0", "Pos2", "position2", "position3", "POSOne", "Pos4", "Pos3", "POS1", "posOne", " pos0", "pos0", "position1", "position4"], "pos2": ["posSecond", "index3", "index5", "po22", "pos5", "POS4", "index4", "POS5", "po5", "pos22", "position2", "position3", "POS2", "index1", "po2", "POS22", "index22", "index2", "positionSecond", "indexSecond", "position1", "po4", " posSecond"], "pos3": ["Pos1", "position03", "pos03", "pose1", "Pos2", "position2", "position3", "pose2", " pos03", "Pos3", "pose3", "pos43", "position1", "Pos43", "position43", "Pos03", "pose43"], "pos4": ["index7", "pos04", "index3", "position7", "pose4", "pose1", "po1", "index4", " pos04", "position2", "position3", " pos7", "po04", "posefour", "pofour", "pos7", " posfour", "index2", "pose04", "posfour", "po4", "position4"], "currentVersion": [" currentName", "reportedUrl", " currentPage", "updatePackage", " currentRelease", "reportedVersion", "currentRelease", "initialPackage", "CurrentPatch", "CurrentUrl", "CurrentRelease", "updateRelease", "CurrentName", " currentPackage", "CurrentVersion", "currentName", "updateVer", "updateVersion", "reportedName", "currentPackage", "currentVer", "initialPage", " currentUrl", "initialVer", " currentPatch", "CurrentPackage", "CurrentVer", "currentPatch", "reportedPatch", "CurrentPage", "currentUrl", "initialVersion", "currentPage"], "downloadURL": ["updateLocation", "updateUrl", "updateURL", "installUrl", "downloadLocation", " downloadLocation", "installURL", " downloadUrl", "installLocation", "downloadUrl"]}}
{"id1": "11562173", "id2": "364438", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkFileStream", " checkOutputChannel", "checkOutputStream", "checkOutputSteam", "checkOutputChannel", "checkIOStream", " checkInputSteam", "checkFileSteam", "checkIOstream", "checkFileChannel", " checkInputChannel", " checkOutputstream", " checkInputstream", "checkOutputstream", " checkOutputSteam", "checkIOChannel", "checkIOSteam", "checkInputSteam", "checkFilestream", " checkOutputStream", "checkInputChannel", "checkInputstream"], "in": ["into", "ins", "image", "In", "connection", "io", "data", "inc", "input", "din", "IN", "inn", "index", "is", "source", "ack", "reader", "src", "login", "inner", "min", "bin", "c", "con", "ic", "up", "ini", "as", "x", "plus", "comp", "again", "p", "isin"], "cmp": ["conv", "asc", "prefix", "np", "roc", "mp", "omp", "cp", "rc", "pixel", "loc", "prev", "cho", "spec", "cpp", "coll", "ch", "index", "sort", "ci", "cb", "clip", "code", "cc", "ctrl", "comment", "upp", "config", "co", "cache", "match", "pc", "amp", "c", "mom", "sup", "up", "ctx", "pre", "diff", "proc", "op", "lc", "comp", "cs", "cup", "fp", "p", "cop", "com"], "all": ["asc", "partial", "array", "default", "one", "call", "parent", "null", "except", "best", "none", "acl", "each", "allow", "not", "valid", "coll", "All", "sum", "cl", "and", "only", "process", "total", "al", "l", "a", "ann", "any", "local", "match", "ALL", "alpha", "list", "am", "global", "full", "both", "auto", "always", "p"], "stream": ["null", "speed", "Stream", "form", "this", "steam", "port", "raw", "socket", "channel", "output", "model", "impl", "document", "result", "input", "stack", "coll", "feed", "test", "temp", "instance", "progress", "source", "ack", "roll", "ream", "client", "reader", "self", "track", "src", "user", "round", "transform", "object", "trans", "string", "v", "platform", "up", "per", "host", "context", "pool", "response", "cont", "wrapper", "comp", "iterator", "sw"], "out": ["prefix", "array", "image", "copy", "null", "parent", "b", "io", "outer", "data", "project", "this", "sync", "inc", "part", "not", "output", "result", "block", "exp", "o", "index", "sum", "Out", "comment", "point", "outs", "user", "v", "bin", "c", "obj", "name", "list", "other", "option", "full", "OUT", "up", "extra", "response", "x", "again", "p"], "i": ["k", "u", "uri", "e", "j", "b", "n", "fi", "init", "io", "info", "si", "f", "it", "index", "d", "end", "key", "type", "ci", "oi", "ji", "h", "abi", "multi", "li", "di", "l", "mi", "hi", "pi", "xi", "slice", "r", "ind", "id", "ti", "v", "gi", "c", "start", "ri", "I", "ai", "ix", "strength", "ini", "ii", "ui", "x", "bi", "qi", "lc", "p"]}}
{"id1": "14001795", "id2": "804637", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyOverWebFile", "copyOverWarfile", "copyOverWARPath", "copyoverwarPath", "copyOverwarPath", "copyOverwarFiles", "copyOverWARFiles", "copyOverwarFile", "copyoverWarFiles", "copyOverWebPath", "copyoverWarFile", "copyoverwarfile", "copyOverwarfile", "copyoverWarPath", "copyOverWARFile", "copyOverWARfile", "copyOverWebfile", "copyoverwarFile", "copyoverWarfile", "copyOverWebFiles", "copyOverWarPath", "copyoverwarFiles", "copyOverWarFiles"], "dir": ["folder", "df", "dc", "group", "local", "class", "window", "keep", "zip", "clean", "cache", "ir", "http", "dist", "d", "log", "fd", "manager", "dn", "desc", "feed", "di", "doc", "wd", "download", "DIR", "handler", "def", "build", "store", "loc", "up", "part", "coll", "url", "cur", "work", "dr", "config", "pkg", "director", "direct", "Dir", " directory", "lib", "draft", "handle", "directory", "direction", "data", "md", "r", "plugin", "parent", "lock", "db", "file"], "ff": ["df", "fe", "fff", "sf", "cpp", "xff", " buff", "aff", "fx", "ft", "uff", "fd", "bd", "FF", "feed", "buf", "cf", "fam", "fold", "pp", "ef", "dd", "TF", "cl", "ph", "fw", "iff", "ffe", "now", "fox", "eph", "uf", "fed", "eff", "upp", "cb", "fp", "bb", "fl", "fb", "bf", "ffff", "lf", "buff", "rf", "flow"], "files": ["fa", "pages", "names", "fe", "classes", "bs", "lines", "apps", "results", "images", "sections", "objects", "events", "ums", "groups", "plugins", "locks", "fs", "s", "ls", "balls", "keys", "blocks", "split", "features", "flows", "data", "fl", "items", "Files", "ps", "iles", "rows", "users", "jobs", "file", "models"], "f": ["fa", "fe", "fr", "F", "fc", "of", "n", "c", "sf", "d", "aff", "fd", " fa", "feed", "cf", "fold", "fn", "handler", "p", "fs", "l", "tf", "part", "x", "flat", "e", " file", "i", "filename", "fp", "fen", "v", "inf", "fl", "fb", "bf", "t", "lf", "info", "name", "file", "rf"], "newFile": ["updatefile", "oldDir", "NewFolder", " newFolder", "smallfile", "oldFiles", "smallDir", " newLine", "updateF", "NewFile", "oldF", "newFiles", "andfile", "andFile", " newF", " newDir", "updateLine", " newfile", "NewFiles", "nextFile", "andDir", "newLine", "existingLine", "NewF", "existingF", "nextFiles", "newFolder", "updateFile", "nextFolder", "newfile", "nextDir", "existingfile", "oldFile", "existingFile", "NewDir", "smallFile", " newFiles", "newDir", "newF"], "fi": ["fa", "fy", "fe", "wi", "si", "qi", "fc", "uci", "ini", "ii", "pi", "py", "sf", "afe", "fin", "abi", "ifi", "cci", "flo", "cf", "ifa", "afi", "shi", "bi", "ife", "fs", "ico", "fine", "fw", "ffe", "sci", "isi", "i", "fp", "Fi", "FI", "zi", "xi", "fb", "lf", "info", "fr"], "fo": ["fa", "fe", "si", "so", "wo", "o", "sf", "ko", "afe", "obo", "ofi", "ato", "di", "obi", "io", "os", "co", "flo", "cf", "osa", "tto", "afi", "shi", "ico", "fw", "ki", "ho", "FO", "zo", "uf", "xf", "ni", "bo", "inf", "lo", "po", "oo", "info", "olo", "mo"]}}
{"id1": "16590954", "id2": "12783713", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"createJAR": ["createPHAR", "createJARS", "createPHARS", "createJPJar", " createPHARS", "createJJar", " createJJar", "createPHAP", " createPHAP", "createAMARS", " createJARS", " createPHAR", " createJAP", " createPHJar", "createJPAP", "createJPAR", "createJPARS", "createJAP", "createAMJar", "createPHJar", "createAMAP", "createAMAR"], "fileString": ["loadString", "linestring", "FileStr", "FileText", "FileString", "baseStr", "fileStream", "resourceStream", "FileFile", "fileName", "lineString", "fileStr", "fileArray", "baseString", "Filestring", " fileName", "modelText", " fileText", " fileStr", "loadstring", "modelStr", " fileFile", "FileName", "lineName", "baseFile", "loadText", "resourceText", "FileStream", "lineArray", "fileFile", "fileText", "resourceString", "resourceStr", "filestring", "basestring", " filestring", "modelString", "loadName", "FileArray", " fileArray", "modelStream"], "ext": ["enc", "end", "content", "format", "version", "req", "exp", "text", "zip", "xt", "filename", "info", "prot", "extra", "txt", "class", "code", "dist", "external", " Ext", "path", "Ext", "type", "v", "x", "app", "name", "EXT", "exe", "dep", "data", "ax", "str", "append", "desc", "ex", "config", "url"], "file": ["File", "folder", "log", "model", "base", "force", "resource", "wave", "unit", "module", "change", "ile", "let", "fe", "up", "http", "cache", "zip", "local", "filename", "use", "queue", "l", "b", "ger", "full", "output", "page", "url", "class", "pe", "files", "buffer", "path", "work", "single", "doc", "part", "line", "place", "it", "build", "flat", "fp", "FILE", "le", "socket", "name", "test", "bar", "h", "binary", "parent", "per", "get", "jar", "source", "db", "f"], "i": ["ini", "mi", "index", "j", "yi", "hi", "phi", "ii", "mini", "slice", "key", "l", "ui", "pi", "c", "abi", "li", "ind", "ci", "p", "uni", "si", "ni", "xi", "multi", "eni", "v", "x", "ai", "uri", "it", "ip", "ori", "qi", "iu", "limit", "f", "di", "I"], "dir": ["folder", "base", "module", "DIR", "prefix", "coll", "format", "direction", "domain", "cur", "src", "zip", "ir", "filename", "output", "area", "info", "string", "class", "dist", "path", "doc", "type", "div", "rel", "uri", "Dir", "manager", " directory", "tmp", "name", "loc", "data", "id", "jar", "str", "pkg", "lib", "config", "db", "url", "directory"], "jarFile": ["tarFile", "jarSourceFile", "javaFile", "javaF", " jarDir", "archiveDir", "sessionfile", "jarfile", "jarFiles", "reportSourceFile", "jarF", "tarSourceFile", "archiveFolder", " jarFiles", "javaFiles", "sessionFile", "reportF", "archiveFiles", " jarLine", " jarFolder", "jarFolder", "javaFolder", "tarF", "jarDir", "sessionLine", " jarfile", "tarfile", "tarLine", "javaDir", "archiveFile", "reportfile", " jarSourceFile", "reportFile", "javaSourceFile", "jarLine", "sessionSourceFile", "javafile"], "fstrm": ["fbrm", "fstrcm", "fsrcm", " fsrM", " fsrm", " fstrcm", " fsrcm", "fsrmd", " fstrum", "Fstrmd", "fbrum", "Fstrcm", "fstmd", "fgrm", "Fsrcm", "fsrum", "fstcm", "fstum", "fstM", "fsrm", "fsrM", " fsrum", "fgrmd", "Fsrm", "fbrM", " fstrM", "fbrcm", "FsrM", "fstm", "fgrM", "fgrcm", "fstrM", "fstrmd", "Fsrmd", "Fstrm", "FstrM", "fstrum"], "in": ["image", "login", "stream", "inner", "inn", "gin", "to", "input", "In", "up", "sync", "l", "bin", "conn", "read", "c", "pin", "IN", "r", "again", "p", "part", "nin", "io", "min", "pull", "ins", "is", "into", "init", "ac", "inside", "rin", "binary", "id", "reader", "n", "or", "m", "din", "f", "socket", "inc", "s"], "out": ["flow", "err", "image", "pool", "resource", "outer", "this", "self", "inner", "to", "outside", "plain", "net", "channel", "group", "exp", "up", "sync", "output", "OUT", "bin", "conn", "b", "writer", "null", "c", "again", "outs", "plus", "doc", "source", "line", "part", "io", "v", "all", "Out", "client", "off", "init", "server", "user", "call", "connection", "m", "inc"], "temp": ["folder", "unit", "base", "storage", "form", "w", "input", " Temp", "or", "zip", "cache", " temporary", "local", "output", "key", "api", "writer", "full", "home", "c", "export", "store", "buffer", "path", "single", "doc", "p", " tmp", "Temp", "template", "wrap", "it", "build", "v", "dest", "controller", "tmp", "test", "emp", "clean", "dump", "archive", "server", "Output", "porary", "fake", "tem", "get", "iter", "pipe", "config", "source", "db", "f", "directory"], "fstrm2": ["fstrp0", "fstrmr1", "fstM1", "fstrm002", "fstrM02", "fstrM002", "fhrm02", "fstm2", "fstM2", "fstrp1", "fstrmr2", "fstrp2", "fstrmr02", "fstm0", "fstrms2", "fstrms0", "fstM0", "fhrm002", "fstrm02", "fhrms2", "fhrm2", "fstrm1", "fstrms1", "fstrmr002", "fstrM1", "fhrms02", "fstrM0", "fstrms002", "fstm1", "fhrm1", "fstrms02", "fhrms1", "fstrm0", "fstrM2", "fhrms002"], "ostrm": ["obrm", "ophm", "ostm", "oscrm", "odmr", "ophmr", "odrt", "oscmr", "oodrob", "obmr", "ostrt", "istmr", "othermr", "istrt", "odm", "obsrem", "otherrm", "oodrem", "istrom", "ostmr", "obrom", "ooprm", "odrm", "obsrm", "istrm", "ooprom", "oscm", "ostrom", "ophrt", "oodrt", "otherrom", "otherrt", "oopmr", "obsrt", "ooprt", "obrt", "oscrt", "ostrob", "ostrem", "oodrm", "obsrob", "ophrm"], "docFile": ["documentFile", "documentF", "DocDir", "documentFiles", " docDir", "documentDir", "DocF", " docFiles", "docFiles", " docF", "docDir", "docF", "DocFiles", "DocFile"]}}
{"id1": "11477906", "id2": "16092702", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"loadDefaultSettings": ["getDefaultParameters", "loadGlobalsettings", "loadGlobalParameters", "loaddefaultConfiguration", "loaddefaultParameters", "loadApplicationSettings", "getdefaultConfiguration", "getdefaultParameters", "getdefaultsettings", "loadDefaultConfiguration", "loadDefaultsettings", "loadApplicationParameters", "loaddefaultsettings", "loaddefaultSettings", "loadDefaultParameters", "getDefaultSettings", "loadApplicationsettings", "getdefaultSettings", "getDefaultsettings", "loadGlobalSettings", "loadGlobalConfiguration", "loadApplicationConfiguration", "getDefaultConfiguration"], "configFileName": ["configPlaceLocation", "configFILELocation", "configFileType", "configFilenameLocation", "configFullLocation", "fileFILEType", "fileFILETime", "configFILETime", "configFileUrl", "configFilesName", "fileFILELocation", "ConfigModuleUrl", "ConfigFileString", "fileFileType", "configFileLocation", "configModuleUrl", "configFilesType", "ConfigModuleLocation", "configModuleString", "fileFileName", "configModuleName", "fileFileTime", "configFullUrl", "configFilenameName", "ConfigFileLocation", "configFullName", "configPlaceName", "configFileTime", "fileFileLocation", "configPlaceString", "ConfigFileName", "configFilesTime", "configFilesLocation", "configPlaceUrl", "configFileString", "configModuleLocation", "configFullString", "ConfigModuleString", "configFilenameType", "ConfigModuleName", "configFILEType", "ConfigFileUrl", "fileFILEName", "configFILEName", "configFilenameTime"], "in": ["resource", "In", "pull", "pass", "pc", "plus", "again", "n", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "as", "log", "con", "this", "pin", "ins", "conn", "inn", "err", "it", "up", "init", "base", "url", "work", "config", "read", "f", "inside", "i", "nin", "a", "socket", "login", "ssl", "reader", "diff", "data", "r", "inc", "id", "source", "stream"], "out": ["timeout", "able", "again", "and", "string", "instance", "c", "o", "ex", "exp", "view", "d", "version", "bin", "Out", "copy", "log", "io", "outs", "this", "sync", "conn", "object", "user", "err", "it", "up", "default", "connection", "net", "s", "all", "prefix", "exec", "server", " back", "config", "f", "off", "set", " file", "password", "image", "lib", "socket", "writer", "to", "ext", "file", "output", "data", "ou", "write", "obj", "OUT", "point", "null", " output", "t", "inc", "error", "parent", "back", "client", "name", "one"]}}
{"id1": "17190057", "id2": "16092702", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"encode": ["unode", "uncode", "encescape", "enccode", "Enescape", "enode", "Enode", "unescape", "Encode", "enescape"], "input": ["request", "image", "in", "buffer", "amp", "alpha", "stream", "def", "i", "output", "form", "pattern", "crypt", "context", "instance", "address", "plus", "inf", "result", "format", "array", "audio", "ssl", "img", "raw", "str", "secure", "addin", "binary", "this", "null", "prefix", "xxx", "data", "temp", "Input", "text", "password", "reader", "string", "empty", "source", "config", "hex"], "NoSuchAlgorithmException": ["NoSuchAlryptionement", "NoSuchAlodingement", "NoSuchEdgorithmement", "NoSuchEdgorithmWarning", "NoSuchAlgoException", "NoSuchAlgoement", "NoSuchEdryptionWarning", "NoSuchAlgoWarning", "NoSuchAlodingError", "NoSuchEdgorithmException", "NoSuchAlryptionException", "NoSuchAlodingException", "NoSuchAlgorithmError", "NoSuchEdryptionException", "NoSuchAlryptionError", "NoSuchAlryptionWarning", "NoSuchEdryptionError", "NoSuchAlgoError", "NoSuchAlgorithmement", "NoSuchEdgorithmError", "NoSuchAlodingWarning", "NoSuchAlgorithmWarning", "NoSuchEdryptionement"], "md": ["mm", "mac", "mo", "db", "m", "dig", "mad", "key", "ad", "pd", "metadata", "um", "ma", "od", "code", "dc", "cd", "sum", "message", "amd", "mb", "nm", "df", "wd", "mand", "bd", "doc", "dm", "zip", "pm", "sha", "mi", "mt", "MD", "mp", "me", "mc", "mod", "mag", "hd", "d", "ms", "meta", "hash", "cmd", "dd", " MD"]}}
{"id1": "13657103", "id2": "4389475", "code1": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "code2": "    @Override\n    public URLConnection openConnection(URL url) throws IOException {\n        if (!url.getProtocol().equals(\"file\")) {\n            String name = url.getFile();\n            File f = new File(cacheFolder, ((name.charAt(0) == '/') ? name.substring(1) : name).replace('/', File.separatorChar));\n            if (!f.exists()) {\n                File f2 = new File(f.getParentFile(), f.getName() + \"-not_found\");\n                if (!f2.exists()) {\n                    try {\n                        f.getParentFile().mkdirs();\n                        downloadFile(url, f);\n                    } catch (IOException e) {\n                        f.delete();\n                        throw e;\n                    }\n                }\n            }\n            return f.toURI().toURL().openConnection();\n        }\n        return super.openConnection(url);\n    }\n", "label": 0, "substitutes": {"forBundle": ["forFixture", "getBale", "getBixture", "forBale", "getFale", "forLixture", "getBuddy", "getFixture", "forMuddy", "forBixture", "forLundle", "forMundle", "forFundle", "forMixture", "forBuddy", "forMale", "getFuddy", "forFuddy", "forFale", "forLuddy", "getBundle", "forLale", "getFundle"], "manip": [" manIP", "dami", "damip", "emanIP", "manic", "Manipp", "emani", "ManIP", "Manip", "Manic", " mani", "damIP", "emanim", "multip", "managerip", "manageri", "manIP", "manim", "damim", "manipp", "manageric", "mani", " manipp", "emanip", "multIP", "Mani", "emanipp", "managerIP", "multic", "multi", "Manim"], "bout": ["bOut", "baseash", "bbout", " bin", "bin", "basedump", " bouts", "ferr", "nout", "Bin", "bbOUT", "bdump", "sbagain", "Bout", "berr", "Bash", "sbin", "sberr", " bOUT", "fOUT", "bouts", "Berr", "bOUT", "BOUT", "sbouts", "bash", "Bouts", "ndump", "fagain", "baseOut", "bbouts", "zin", "zouts", "nOut", "BOut", "baseout", "nash", "zOUT", "fout", "sbOUT", "sbout", "bbin", "Bagain", "Bdump", "bagain"], "zout": ["zipcontainer", "zipOut", "azOUT", "zipout", "zhOut", "ZOut", " zagain", "ezraw", "zOut", "zenin", "zhstore", "zyout", "wio", "zipio", "ezquery", "zhraw", "ezout", "zyin", " zconn", "azerr", "zagain", "zraw", " zOUT", "zconn", "zstore", "azconn", "zencontainer", "zenagain", "zipin", "azouts", "azOut", "win", "wout", "azin", "zipraw", " zbox", "Zin", "zcontainer", " zerr", "ezOUT", "zenout", "ezOut", "zipbox", " zcontainer", "zipstore", "zquery", " zOut", "zipquery", "Zio", "zipagain", "zin", " zouts", "zbox", "zouts", "zerr", "zystore", "zio", "zOUT", "ezouts", "azstore", " zstore", "zhout", "ezconn", "zherr", "Zout", "azout", "azbox", "wOut", "zyOut", " zin", "zhquery"], "bundle": ["lorer", "bunch", "sbiler", "fuddy", " borer", "nuni", "liler", "eixture", "abundle", "fund", "foodle", "fixture", "nunch", "nundle", "fundle", " bund", "abider", "sborer", "euni", "sbuddy", "buration", "biler", "funi", "sbundle", " biler", "boodle", "aboodle", "bixture", "bider", "abuddy", " buddy", "bulp", "funch", " boodle", " bider", "eundle", "abund", "fider", "aburation", "furation", "lundle", "luddy", "abulp", "nixture", " buration", "buddy", " bulp", "eunch", "bund", "fulp", "borer", "buni"], "files": ["keys", "feed", "fs", "leases", "pages", "http", "resources", "results", "features", "apps", "qs", "Files", "reports", "errors", "ids", "workers", "fl", "items", "links", "iles", "users", "lines", "bugs", "blocks", "boxes", "children", "flows", "members", "names", "file", "classes", "data", "images", "objects", "models", "plugins", "ips", "issues", "groups", "web", "ls", "obs", "thumbnails", "fires", "books", "bytes", "fields", "rules", "xml", "events", "f", "download"], "url": ["string", "path", "address", "job", "id", "uri", "resource", "feed", "server", "user", "entry", "http", "filename", "rel", "html", "l", "location", "host", "URL", "el", "fr", "pattern", "fl", "source", "dir", "not", "browser", "ob", "config", "data", "file", "out", "channel", "page", "web", "ball", "coll", "image", "link", "sl", "Url", "layer", "pull", "b", "f", "element", "download", "loc"], "name": ["string", "path", "base", "info", "NAME", "address", "job", "id", "n", "resource", "uri", "filename", "end", "number", "child", "large", "ame", "api", "host", "el", "pass", "time", "key", "part", "type", "source", "no", "one", "up", "member", "connection", "old", "value", "common", "str", "default", "model", "alias", "parent", "data", "file", "names", "work", "object", "x", "size", "search", "Name", "e", "image", "action", "home", "label", "word", "full", "comment", "b", "block", "wheel", "error", "named", "definition", "orig"], "mf": ["smfs", "smdf", "lf", "fmc", "gfs", " mcf", "smfc", "Mc", "smf", "mcf", "fmtf", " mc", "Mtf", "gfc", "mdf", "fmf", "lfc", "gf", "Mcf", "Mf", "mc", "mtf", " mtf", "gdf", "mfc", "lfs", "fmcf", "ldf", "mfs"], "tmpFile": ["tempChannel", "poraryFile", " temporaryFiles", "tmpChannel", "tmpUrl", " temporaryFile", "tmpFunction", " tmpFiles", "poraryChannel", " tmpGlobal", " tmpDir", "tempEntry", "tempPath", "poraryUrl", "poraryFiles", "tempGlobal", "TempEntry", "TempFile", "TempPath", "tmpGlobal", "TempFiles", "TempChannel", "tempDir", " temporaryDir", " tmpFunction", "tmpEntry", "tmpFiles", "tmpDir", "poraryEntry", "TempUrl", "tempFile", "tempFiles", "poraryFunction", "TempFunction", "tmpPath", " temporaryGlobal", " tmpUrl", "poraryPath"], "ref": ["val", "fe", " binding", "id", " reference", "cmp", "bf", "lf", " nav", "rel", "loc", "instance", "col", "req", " comp", "comp", " cache", "Ref", "part", "type", "cache", "resp", " resp", "lib", "old", "aff", "ob", "config", " index", "Reference", "ef", " remote", "re", "eval", "ctx", "REF", "conf", "obj", "reference", "reg", "def", " req", "f", "service", " Ref"]}}
{"id1": "10451698", "id2": "19335986", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"copy": ["run", "cop", "paste", "share", "cat", "zip", "rm", "py", "Copy", "move", "process", "ignore", "list", "sync", "download", "archive", "part", "replace", "drop", "cp", "clone", "delete", "get", "load", " cp", "dump", "split", "transfer", "file", "remote", "change", "clip", "write", "type", "parent", "update", "lock", "ssh", "create"], "source": ["folder", "resource", "slave", "root", "plus", "class", "use", "section", "seed", "project", "string", "current", "site", "cache", "Source", "sf", "view", "proxy", "service", "scope", "ource", "path", "from", "slice", "client", "ce", "object", "archive", "unit", "ie", "connection", "document", "storage", "model", "server", "url", "config", "flat", "iter", "filename", "SOURCE", "start", "image", "remote", "result", "directory", "reader", "data", "secure", "target", "null", "parent", "stream", "info", "src", "name", "file"], "destinationDirectory": ["destinationsFolder", "destructionFolder", "destinatorDirectory", "destributionFile", "DestinationDir", "destributionDirectory", "destinatorPath", "destinationHome", "destinationPoint", " destinationDir", "destippingDir", "destinatorPoint", " destinationsDir", "destributionHome", "destructionDir", "destificationDirectory", "destributionFolder", "destributionDir", " destinationsFile", "DestinationDirectory", "destarationPoint", "destinationsDirectory", "DestinationFolder", "destinationPath", " destinationsFolder", "DestributionHome", "destributionPath", "destinationFile", "destarationPath", "destinationsDir", "destarationDirectory", "destructionDirectory", "destributionPoint", "destinationsFile", "destificationDir", "DestinationPath", "DestinationHome", " destinationsDirectory", "DestributionPoint", "destippingFolder", "DestinationPoint", " destinationFolder", "DestributionPath", "destificationFolder", "DestributionDirectory", "destippingDirectory", "destificationHome", "destippingHome", "destinationFolder", "destinationDir", " destinationFile", "DestributionFolder", "destructionFile", "DestributionDir"], "newDir": ["NewFolder", " newFolder", "NewFile", "Newdir", "nextDirectory", "nextFile", "newdir", "newFolder", "NewDirectory", "nextFolder", " newdir", "newDirectory", "nextDir", "nextdir", "NewDir", " newDirectory"], "children": ["names", "pages", "packages", "each", "words", "father", "current", "parents", "opens", "values", "list", "ools", "files", " Children", "ins", "events", "ums", "members", "content", "child", "begin", "loc", "tests", "roots", "when", "url", "ren", "projects", "scenes", "balls", "kids", "other", "blocks", "ul", "iblings", "filename", "uc", "Children", "rules", "data", "items", "mount", "sub", "parent", "web", "iv", "pes", "collection", "which", "sort", "rows"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "n", "ii", "k", "m", "pi", "ini", "o", "y", "d", "inner", "ci", "di", "io", "key", "slice", "ji", "ui", "in", "ri", "ie", "p", "it", "part", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "ori", "q", "start", "h", "gi", "v", "ti", "type", "ai", "mi", "b", "xi", "id", "info", "uri", "iv", "ix", "mu", "lc", "end"], "newFile": ["Newfile", "oldDir", "createFile", "nextSource", "newSource", "oldFiles", "NewFile", " newSourceFile", "nextfile", "newFiles", "createSource", " newfile", "NewFiles", "nextFile", "nextSourceFile", "nextFiles", "NewDirectory", "NewSourceFile", "newDirectory", "newfile", "nextDir", "oldFile", "createDir", "newSourceFile", "NewSource", "NewDir", "createfile", "oldDirectory", " newFiles", " newDirectory"], "output": ["resource", "temp", "application", "external", "again", "current", "ilo", "o", "option", "service", "response", "core", "outer", "after", "display", "operation", "object", "address", "unit", "generation", "connection", "out", "config", "complete", "oper", "other", "control", "image", "socket", "writer", "result", "page", "four", "error", "ou", "write", "kernel", "change", "target", "put", "web", "parent", "generated", "binary", "update", "console", "file", "Output", "flow"], "input": ["resource", "temp", "pull", "plus", "operator", "instance", "current", "context", "request", "http", "inner", "self", "feed", "text", "this", "in", "child", "ack", "print", "audio", "connection", "out", "storage", "exec", "work", "config", "index", "Input", "before", "ink", "image", "socket", "inf", "reader", "data", "error", "raw", "inc", "parent", "stream", "client", "buffer", "form", "keep", "flow"], "buff": ["bound", "txt", "fe", "ob", "cast", "comment", "bin", "uff", "shape", "feed", "char", "buf", "slice", "cod", "pad", "cf", "length", "boot", "count", "bug", "batch", "comb", "ph", "ff", "oct", "gb", "hello", "cp", "cmd", "cur", "load", "f", "gz", "uf", "bind", "cb", "bb", "data", "Buff", "b", "fb", "flush", "pack", "info", "buffer", "back", "text", "rb"], "read": ["reads", "ask", "run", "pass", "use", "ip", "send", "n", "and", " write", "readable", "k", "reading", "fill", "select", "READ", "lex", "io", "open", "feed", "add", "slice", "sync", "skip", "length", " count", "count", "seek", "play", "Read", " load", "rate", "exec", "find", "get", "load", "x", "config", "wait", "size", "f", "iter", "index", "len", "allow", "ink", "ind", "ok", "check", "start", "close", "transfer", "next", "reader", "se", "type", "write", "parse", "b", "en", "id", "loop", "buffer", "text", "end"]}}
{"id1": "20939940", "id2": "23677128", "code1": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "code2": "\tpublic FTPClient sample3a(String ftpserver, int ftpport, String proxyserver, int proxyport, String username, String password) throws SocketException, IOException {\n\t\tFTPHTTPClient ftpClient = new FTPHTTPClient(proxyserver, proxyport);\n\t\tftpClient.connect(ftpserver, ftpport);\n\t\tftpClient.login(username, password);\n\t\treturn ftpClient;\n\t}\n", "label": 0, "substitutes": {"createJavaProject": ["createJavaConnector", "createjavaApplication", "createJSApplication", "createjavaFolder", "createRubyConnector", "createJavaApplication", "createRubyFolder", "createJSFolder", "createRubyApplication", "createRubyProject", "getJavaConnector", "createjavaProject", "createJSProject", "createJSConnector", "getjavaConnector", "getjavaFolder", "getJavaApplication", "getjavaApplication", "getJavaFolder", "getjavaProject", "createjavaConnector", "createJavaFolder", "getJavaProject"], "proj": ["projet", "prob", "perj", "perject", " probj", "propjet", "proz", "produjs", "roud", " proje", "prok", "PROz", "Projs", "propj", "profj", " prouj", "sujet", "perjp", "profjs", "produjo", " proJ", "projs", " projet", "suje", "profJ", "pejo", "Prok", "prejo", "PROJ", "PROj", "produjp", "propje", "prouj", "upj", "Prouj", "suuj", "parjet", "produJ", "projc", "promjp", "probj", "preuj", "Proaj", " prob", "Proj", "roujc", "prej", "Projc", " project", "produb", "suz", "prez", "produjet", "produj", " proz", "rouJ", "proJ", "roujs", "prod", "coJ", " projc", "promz", "coj", "suk", "ProJ", " projo", "sujo", "perjs", "project", " prok", "produuj", "conjc", "peJ", "profject", "PROjp", "pez", "parb", " projs", "projp", "produz", "rouj", "produjc", "Proz", "conj", "rouaj", "upjo", "promj", "proaj", " projp", "pejp", "cojo", "Projp", "conJ", " proaj", "cobj", "Prod", "perJ", "upJ", "conjp", "perz", "upbj", "proje", "propjo", " prod", "parjc", "Projo", "parj", "promjo", "suj", "pej", "projo"], "desc": ["de", "dec", "pro", "ca", "description", "sup", "dep", "str", "id", "sec", "sub", "div", "name", "out", "obj", "struct", "doc", "Desc", "asc", "neg", "info", "des", "def", "esc", "text", "attr", "Description", "rec", "config", "loc", "anc", "dc", "rc", "sc", "dist", "summary", "contract", "dev", "details", " description", "txt", "comment"], "javaProject": ["javaUnit", "JavaProject", "JavaFolder", " javaServer", "rubyApp", "javaPlugin", "javaFolder", "JavaModule", " javaApp", "nativePlugin", "pythonProject", " javaModule", "jaProject", "jarModule", "rubyUnit", "pythonModule", "rubyProject", "javaApp", "javaServer", "jarServer", "jaModule", "nativeApp", "nativeProject", "pythonFolder", "jaUnit", "JavaApp", "JavaUnit", "javaModule", " javaFolder", "nativeFolder", "JavaPlugin", "pythonServer", "jaFolder", "jarFolder", " javaPlugin", "rubyFolder", " javaUnit", "jarProject"], "srcFolder1": ["srcDirectory81", "srcfolder1", "srcfolder0", "srcLocation1", "srcDirectory2", "rcDirectory2", "srcfolderOne", "rcDirectory1", "srcFileOne", "srcFolderOne", "srcFolder0", "rcFolderOne", "srcPath2", "srcfolder81", "rcFolder0", "srcDirectoryOne", "srcLocation0", "srcfolder2", "rcFolder81", "srcPath0", "srcLocation2", "srcFile81", "srcDirectory0", "rcFolder2", "srcPath1", "srcPathOne", "srcFile1", "rcDirectory0", "srcDirectory1", "srcFolder81", "rcDirectoryOne", "rcFolder1", "rcDirectory81", "srcFile2"], "srcFolder2": ["srcfolder1", " srcfolder1", "srcDirectory2", "rcDirectory2", "rcDirectory5", "rcDirectory4", "srcArea4", " srcfolderTwo", "rcDirectory1", " srcFolderTwo", "srcArea2", "rcFolderTwo", "rcDirectoryTwo", " srcfolder2", "srcfolder2", "srcDirectory4", "rcFolder4", "rcFolder2", "rcFolder5", "srcFileTwo", "srcFolder5", "srcfolder5", "srcfolder4", "srcFile1", "srcArea1", "srcFolder4", "srcAreaTwo", "srcDirectoryTwo", " srcfolder4", "srcFolderTwo", "srcDirectory1", "srcFile5", "rcFolder1", "srcfolderTwo", "srcDirectory5", " srcFolder4", "srcFile2"], "classpathEntries": ["classnameEnrys", "classpathEnries", "classpathentrys", "classpathentrs", "classpathEntrys", "classpathAddries", "classpathEntryEntry", "classpathAddEntry", "classPathEntEntry", "classpathEntryry", "classpathentories", "classPathEntries", "classPathAddry", "classpathEntryries", "classpathAddry", "classpathEntEntry", "classpathEntryrys", "classpathEntryrs", "classnameEnories", "classpathEnrs", "classpathEntories", "classpathentry", "classpathentries", "classpathentEntry", "classPathEntry", "classnameEnries", "classpathEnrys", "classnameEnrs", "classPathEntrys", "classPathAddrys", "classnameEntories", "classpathAddrys", "classnameEntries", "classnameEntrys", "classnameEntrs", "classpathEntrs", "classpathEnories", "classpathEntryories", "classPathAddEntry", "classpathEntry", "classPathAddries"], "binFolder": ["winfolder", "winUrl", "resultLoop", "baseLoader", "baseFolder", "basefolder", "winDirectory", " binLoop", "baseDir", "resultUrl", "baseProject", "binLoop", "workFolder", "binaryLoop", "workfolder", "workDir", "winFolder", "workProject", "binaryFolder", "binDir", "binfolder", "binaryProject", "binaryDir", " binLoader", "binUrl", "binaryLoader", " binDirectory", "binaryUrl", "binDirectory", "binProject", "binaryDirectory", "resultfolder", " binUrl", "binaryfolder", " binfolder", "binLoader"], "testFolder": ["resultLoop", "mainfolder", "resultOrg", "testOrg", "mainDirectory", "testDirectory", "matchOrg", "resultDirectory", "matchPath", " testOrg", " testfolder", " testLoop", "testPath", " testPath", "resultPath", "resultfolder", "testLoop", "testfolder", "mainLoop", " testDirectory", "matchFolder", "mainFolder"], "resultFolder": ["returnFolder", "testLayer", "resultSection", "ResultPath", "messageFolder", "testingfolder", "testingFolder", "testSection", "testingLayer", "messagePath", "testingSection", "resultLayer", "returnDirectory", "messageLayer", "ResultLayer", "messageDirectory", "ResultFolder", " resultSection", "returnPath", "resultPath", "resultfolder", "ResultDirectory", "testfolder", " resultfolder", " resultLayer", "resultDirectory", "returnLayer"]}}
{"id1": "4973095", "id2": "2736184", "code1": "    public Wget2(URL url, File f) throws IOException {\n        System.out.println(\"bajando: \" + url);\n        if (f == null) {\n            by = new ByteArrayOutputStream();\n        } else {\n            by = new FileOutputStream(f);\n        }\n        URLConnection uc = url.openConnection();\n        if (uc instanceof HttpURLConnection) {\n            leerHttp((HttpURLConnection) uc);\n        } else {\n            throw new IOException(\"solo se pueden descargar url http\");\n        }\n    }\n", "code2": "    public static String getURLContent(String urlPath, String requestData, String charset) {\n        BufferedReader reader = null;\n        HttpURLConnection conn = null;\n        StringBuffer buffer = new StringBuffer();\n        OutputStreamWriter out = null;\n        try {\n            URL url = new URL(urlPath);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"POST\");\n            conn.setDoOutput(true);\n            conn.setUseCaches(false);\n            conn.setDefaultUseCaches(false);\n            conn.setConnectTimeout(10000);\n            conn.setReadTimeout(60000);\n            out = new OutputStreamWriter(conn.getOutputStream(), charset);\n            out.write(requestData);\n            out.flush();\n            int repCode = conn.getResponseCode();\n            if (repCode == 200) {\n                int count = 0;\n                char[] chBuffer = new char[1024];\n                BufferedReader input = new BufferedReader(new InputStreamReader(conn.getInputStream(), charset));\n                while ((count = input.read(chBuffer)) != -1) {\n                    buffer.append(chBuffer, 0, count);\n                }\n            }\n        } catch (Exception ex) {\n            logger.error(\"\", ex);\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n                if (reader != null) {\n                    reader.close();\n                }\n                if (conn != null) {\n                    conn.disconnect();\n                }\n            } catch (Exception ex) {\n            }\n        }\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"url": ["string", "path", "base", "buffer", "address", "ssl", "rest", "server", "uri", "resource", "feed", "ado", "user", "http", "c", " web", "lr", "l", "host", "api", "URL", "all", "client", "source", "use", "lib", "connection", "not", "r", "str", "open", "config", "file", "web", "ll", "null", "u", "conn", "e", " URL", "image", "link", "bad", "sl", " http", "full", "Url", "www", "ur", "b", "xml", "gl", "service", "download", "loc"], "f": ["info", "buffer", "fat", "fe", "sf", "i", "fa", "fs", "rf", "bf", "df", "ref", "c", "filename", "fc", "fi", "fp", "l", "fn", "fr", "d", "aff", "g", "w", "fed", "file", "flat", "fb", "x", "p", "u", "fo", "e", "io", "t", "m", "F", "fd", "files", "fen", "b", "v", "tf", "inf"], "by": ["ssl", "buffer", "server", "serv", "feed", "report", "as", "j", "html", "BY", "via", "in", "content", "source", "reader", "browser", "r", "open", "body", "out", "web", "log", "or", "re", "to", "it", "By", "v", "with", "acc", "service", "from"], "uc": ["cu", "tc", "cc", "sc", "ud", "cf", "rc", "http", "con", "c", "ru", "fc", "su", "dc", "uu", "cus", "ec", "client", "cv", "ws", "lc", "cas", "ct", "connection", "auc", "uh", "acc", "https", "xc", "ub", "usc", "u", "conn", "coll", "ci", "uci", "ucc", "pc", "mc", "us", "soc", "bc", "BC", "cci", "contract", "ac", "UC", "ul", "SC", "FC", "unc", "cur", "cca", "loc"]}}
{"id1": "2022160", "id2": "2518655", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "label": 1, "substitutes": {"write": ["next", "process", "writer", "connect", "service", "size", "sync", "kill", "read", "flow", "output", "feed", "copy", "written", "run", "wrote", "open", "code", "out", "send", "lex", "end", "store", "Write", "cycle", "close", "exec", "set", "update", "data", "append", "put", "w", "call", "export", "writ", "play", "add", "flush", "dump", "create", "writing", "pipe"], "byteBuffers": ["connectionbuffERS", "bytesBuffatters", "connectionbuffeners", "bytebuffresses", "bytePackapers", " byteComplers", "byteBuffresses", "ByteBuffresses", "byteOrders", "byteBuffererers", " byteOffters", "byteWritlers", "byteBufferelines", "doubleHeadered", "ByteOrderers", " byteOffors", "byteCornatters", "byteOrdERS", "byteHeaders", " byteBuffares", "byteBuffapers", "byteBuildERS", "bytesPackers", "bytesBuffors", "connectionBuffeners", "byteBuffizers", "bytebuffings", "bytesCornatters", "byteDefelines", "connectionbuffers", "bytesPackerers", "byteCornests", "bytePackerers", "doubleHeadERS", "ByteOrdresses", "ByteBufflers", "byteBuffereners", "ByteBuffers", "byteIntegers", "byteDefers", "ByteOrdERS", "bytesBuffizers", "bytesBuffERS", " byteOrdlers", "doubleHeadings", "bytebuffests", "ByteBuffERS", "byteOrderers", "byteOffERS", "bytePackERS", "byteCornered", "bytesCorners", " byteBuffinals", " byteBuffors", "byteBufferERS", "bytebuffeners", "byteAkelines", " byteOrderers", "ByteBufferers", " byteBufflers", "bytesBuffelines", "byteDefatters", " byteCompERS", "byteInferers", "byteComplers", "bytebuffors", "byteChers", "byteCornares", "connectionBuffERS", "byteBuffinals", "byteInteginals", "bytesDefelines", " byteOrders", "bytebuffered", "wordBuffatters", "connectionBuffers", "byteBuilderers", " byteBuffeners", "byteAkizers", "byteChERS", "byteWritelines", "byteOffters", "bytesAkizers", "wordBuffers", "byteOrdeners", "byteOrdlers", "byteWritors", " byteOrdinals", "doubleBuffered", "byteWriters", "byteBuffters", " byteOffERS", " byteOrdERS", " byteOffers", "byteBufferers", "byteBuilders", " byteBuffters", "bytesAkers", " byteBuffERS", "byteDefERS", "byteBufferatters", "bytebuffiners", "doubleHeaders", "byteIntegERS", "byteIntegatters", "bytesBuffapers", "byteCompares", "bytesBuffers", "byteBuffERS", "byteHeadERS", "bytePackers", "bytebuffinals", "byteIntegeners", "bytebuffelines", "byteBuffelines", "bytesAkelines", "wordBufferers", "bytesDefERS", " byteCompares", "bytebuffERS", "byteOffers", "byteAkors", "byteOrdapers", "bytesDefers", "byteBuffings", "connectionbufferers", "bytebuffizers", "ByteOrders", "bytebuffers", "byteAkers", "byteBufflers", "byteChered", "bytebufflers", " byteCompers", "bytesBuffests", "doubleBuffERS", "byteCornERS", " byteOrdeners", "byteCompERS", "byteWritizers", "bytesPackapers", "bytesAkors", "byteChings", "byteBuffatters", "bytebufferers", "doubleBuffers", "byteInfers", " byteBuffiners", "wordBuffERS", "byteIntegelines", "byteHeadings", "byteHeadered", "bytesCornests", "bytesBuffered", "byteCompers", "byteOrdresses", "byteOrdinals", "byteCornlers", "connectionBufferers", "byteBuffered", "byteBuffests", "bytebuffatters", "doubleBuffings", " byteBufferers", "byteBufferlers", "byteOrdiners", "bytesBufferers", "byteCorners", "byteInfatters", "byteBufferapers", "byteWritiners", "byteBuffiners", "byteBuildatters", "byteInfERS", "bytesCornered", "byteWriterers", "byteBuffors", "byteOffors", " byteOrdiners", "byteBuffeners", "bytesPackERS", "bytebuffters", "bytesDefatters", "byteBuffares"], "m_initialOutBuffer": ["m_initialOutBuff", "m_initialAuthBuffer", "m_finalOutChannel", "m_initialShortChannel", "m_InitialOutLayer", "m_initialInLine", "m_initialoutAddress", "m_initialOutLine", "m_initialOutCache", "m_initialShortCache", "m_initialOutputBuff", "m_initialOutFile", "m_initialOutputHeader", "m_initialNewBuff", "m_initialAuthFile", "m_initialSocketBuffer", "m_initialSocketHeader", "m_finalInBuffer", "m_finalOutMessage", "m_initialNewMessage", "m_finalOutBuff", "m_initialOutHeader", "m_finalInMessage", "m_initialShortBuffer", "m_initialoutLine", "m_originalOutAddress", "m_InitialOutBuffer", "m_finalInChannel", "m_InitialOutFile", "m_InitialOutputHeader", "m_finaloutChannel", "m_initialClientLine", "m_originaloutBuffer", "m_initialInMessage", "m_InitialOutputLayer", "m_initialNewBuffer", "m_originalOutLine", "m_finalInFile", "m_initialoutFile", "m_initialInChannel", "m_initialoutChannel", "m_finalOutLine", "m_finalOutFile", "m_InitialOutHeader", "m_initialoutBuff", "m_initialShortFile", "m_finalInLine", "m_initialClientBuffer", "m_initialOutLayer", "m_initialSocketLayer", "m_finalInBuff", "m_initialInCache", "m_initialNewFile", "m_originaloutFile", "m_initialClientBuff", "m_finaloutBuffer", "m_originalOutBuffer", "m_originaloutAddress", "m_initialOutAddress", "m_finaloutFile", "m_initialOutMessage", "m_initialOutChannel", "m_finalOutCache", "m_initialSocketFile", "m_originalOutFile", "m_initialOutputChannel", "m_initialAuthAddress", "m_InitialOutputFile", "m_initialInBuff", "m_initialInLayer", "m_initialInFile", "m_finalOutBuffer", "m_finalInCache", "m_finaloutBuff", "m_initialOutputBuffer", "m_initialoutBuffer", "m_initialoutCache", "m_InitialOutputBuffer", "m_initialInAddress", "m_initialOutputFile", "m_initialInBuffer", "m_originaloutLine", "m_initialClientFile", "m_initialAuthLine", "m_initialOutputLayer", "m_initialInHeader", "m_initialOutputMessage"], "buffer": ["FFER", "cell", "comment", "Buffer", "address", "bc", "fb", "iter", "buf", "engine", "base", "re", "builder", "er", "shell", "reader", "string", "window", "flush", "back", "client", "batch", "console", "view", "feed", "input", "page", "cache", "stack", "array", "response", "message", "buff", "pool", "uffer", "file", "table", "event", "holder", "writer", "worker", "output", "object", "slice", "copy", "limit", "port", "phrase", "cur", "row", "url", "null", "callback", "channel", "wave", "source", "layer", "timeout", "template", "block", "queue", "transfer", "server", "ker", "resource", "f", "binary", "data", "temp", "loader", "document", "header", "bridge", "read", "config"], "buffers": ["ufers", "ufering", "buffERS", "bufering", " buffators", "transformERS", "affaches", "transformler", "Buffered", " buffered", "bufages", "buffler", "bufler", "transformers", " buffler", " buffars", " buffages", " buffERS", "Buffers", "bufered", " buffresses", "buffaches", "affors", "phages", "phators", "buffresses", "buferers", "transformering", "ufors", "Bufferers", "ufaches", "affering", "buffering", " bufferers", "buffors", " buffering", "bufators", "bufars", "bufresses", "phers", "bufferers", "buffars", "Buffars", "bufaches", "bufERS", "buffators", "buffered", "bufers", "bufors", "buffages", "phresses", "affers"], "result": ["request", "r", "success", "error", "match", "rate", "card", "flash", "output", "rc", "view", "use", "default", "comment", "consumer", "user", "future", "cache", "valid", "complete", "val", "json", "info", "diff", "or", "ver", "grade", "response", "report", "resource", "message", "Result", "successful", "inner", "ret", "results", "out", "manager", "function", "row", "date", "sr", "winner", "f", "acc", "url", "session", "data", "err", "cup", "er", "runner", "test", "status", "search", "driver", "res", "true", "event", "re", "up"], "encrypted": ["image", "pad", "selected", "flash", "entry", "stream", "transfer", "internal", "cache", " data", "source", "padding", "inner", "available", "binary", "channel", "temp", "loader", "packed", "secret", "text", "body", "reader", "interrupted", "extra", "flush", "layer", "config"]}}
{"id1": "8047989", "id2": "19134229", "code1": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getHashedID": ["getHachedID", "getHashIP", "getHashingUID", "getHashUID", "getShashUID", "getShashedUID", "getHashingID", "getHachedIP", "getShashedIP", "getHashedIP", "getHashedUID", "getHashingId", "getHachedUID", "getHashingIP", "getHashID", "getShashIP", "getHashedId", "getShashedID", "getShashID", "getShashedId", "getHashId", "getShashId", "getHachedId"], "ID": ["DATA", "RI", "NAME", "prefix", "STR", "MAC", "ENT", "AD", "API", "IR", "ED", "INT", "DB", "EXT", "IP", "GET", "IDS", "hash", "Code", "URL", "Id", "IN", "INFO", "Address", "code", "JSON", "Name", "MD", "Path", "SHA", "TEXT", "id", "UID", "string", "URI", "name", "Hash", "IDs", "VERSION", "KEY"], "md5": ["id2", "MD8", "id512", " md8", "cmd25", "id5", "sha512", "sha25", "sha2", "cmd5", "MD512", " md512", " md7", "sha5", " md25", "MD5", " md2", "md7", "md2", "md4", "MD7", "id8", "md25", "md8", "cmd7", "sha7", "MD4", "MD2", " md4", "cmd512", "sha4", "md512"], "digest": ["mdester", "mdse", "longHash", "longse", "Digace", "Digester", "Digest", " digpe", "mdested", "signace", "signest", "codpe", "DigHash", " digests", "codest", "signested", "mdace", "digse", "Digested", "digester", "signester", "Digests", "digests", "codse", "digpe", "mdHash", "digested", "Digse", "mdest", "longests", "Digpe", "digHash", "digace", " digse", "longest", "mdests", "codests"], "bytes": ["ls", "values", "maps", "proxy", "keys", "rows", "Bytes", "details", "body", "letters", "ps", "data", "parts", "ones", "es", "bs", "zip", "vs", "classes", "devices", "lines", "ips", "out", "seconds", "objects", "results", "is", "tes", "pieces", "files", "units", "pages", "ids", "outs", "bits", "base", "address", "id", "string", "errors", "codes", "cells", "binary", "blocks", "words", "content", "services", "strings", "items", "its", "bb", "issues"], "i": ["k", "m", "u", "z", "uri", "e", "j", "b", "n", "fi", "io", "info", "si", "in", "field", "pos", "f", "it", "o", "index", "d", "end", "h", "type", "val", "s", "oi", "ci", "abi", "multi", "li", "l", "di", "hi", "pi", "inner", "xi", "slice", "r", "id", "uli", "ti", "v", "gi", "c", "t", "ri", "I", "ai", "phi", "ii", "ui", "x", "bi", "mu", "qi", "p"]}}
{"id1": "18374478", "id2": "481364", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"updateUser": ["updateRole", "addWord", " updateMember", "deleteuser", " updateRole", " updateuser", "editUser", "editUsers", "deleteMember", "updatedUser", "updatedWord", "updateduser", "UpdatePassword", "updatePassword", "createUser", "updateWord", "UpdateMember", "editRole", "updateuser", " updateAccount", " updateWord", "UpdateRole", "deletePassword", "createRole", "adduser", "updateAccount", "UpdateUsers", "editAccount", "deleteRole", "updateMember", "addUsers", "deleteWord", "UpdateUser", "updatedUsers", "updateUsers", " updatePassword", "addUser", "Updateuser", "UpdateWord", "createAccount", "deleteUser", "createUsers", " updateUsers", "deleteUsers"], "user": ["result", "ver", "client", "account", "job", "system", "project", "str", "view", "site", "use", "app", "current", "model", "log", "User", "row", "users", "session", "plugin", "name", "creator", "profile", "string", "contact", "bug", "this", "character", "self", "auth", "username", "you", "custom", "connection", "used", "null", "object", "parent", "rule", "config", "author", "per", "update", "message", "post", "resource", "person", "p", "version", "content", "page", "me", "data", "pool", "match", "ro", "USER", "server", "member", "instance", "full", "group", "record", "manager", "response", "module"], "conn": ["exec", "cm", "url", "mc", "client", "ca", "ann", "cache", "util", "uc", "ob", "el", "ou", "reg", "cb", "db", "log", "pt", "connect", "sql", "host", "core", "cr", "cp", "oss", "sth", "lock", "c", "cc", "ci", "org", "ct", "ec", "connection", "Connection", "n", "config", "enc", "loc", "nt", "co", "pub", "sync", "cond", "socket", "dc", "api", "close", "pg", "h", "rc", "col", "cli", "pool", "cn", "ch", "act", "server", "coll", "pc", "con", "nc", "ac", "cat", "Conn", "serv", "part", "conf", "ctx", "ha", "pr"], "autoCommit": ["automaticCommend", "autoCitting", "autoDebite", " autoCommite", "autoCited", "automaticDebIT", "autoRebits", "autoCommits", "autoCommited", "autoDebit", "autoDebmit", " autoComits", " autoCommited", "automaticDebend", "autoCommIT", "autoBlend", "autoComit", "autoComits", " autoDebit", "autoDebitting", "automaticDebmit", "autoBlmit", " autoCommits", " autoDebmit", "autoCmit", "autoRebit", " autoDebited", " autoDebitting", "autoComIT", "automaticCommIT", "automaticDebit", "autoAbitting", "autoBlit", "autoRebite", "autoCommend", "autoCit", " autoCommmit", "autoComite", "autoDebited", "autoAbmit", "autoDebend", "autoCommitting", "autoAbit", "autoAbited", "autoDebits", "automaticCommit", "automaticCommmit", " autoComite", "autoBlIT", "autoCommmit", "autoCommite", "autoDebIT", "autoComend", " autoCommitting", " autoComit"], "deleteRoles": ["deleteRsoles", "destroyRols", "deleteSlole", "deleteLoles", "deleteDoots", "destroyNoots", "deleteGrils", "insertRoases", "deleteLodes", "destroyNols", "deleteDules", "deleteDils", "delLoles", "delLole", "deleteRules", "deleteDases", "deleteRooles", "deleteDole", "deleteNoots", "deleteCases", "deleteSlases", "insertRooles", "deleteDols", "destroyRoots", "insertRoules", "insertRole", "delRoles", "deleteGroles", "deleteRils", "deleteRodes", "deleteRsules", "delLases", "destroyNils", "destroyRils", "insertRases", "deleteRoole", "deleteRoules", "delRole", "deleteRoots", "delRodes", "deleteRsases", "delRases", "deleteLole", "deleteNils", "deleteGrols", "destroyNoles", "deleteRsole", "deleteRole", "deleteRases", "deleteSloles", "deleteNols", "deleteRoases", "deleteRols", "insertRoole", "deleteCodes", "destroyRoles", "deleteCole", "deleteSlodes", "deleteDoles", "deleteGroots", "insertRules", "deleteNoles", "deleteLases", "delLodes", "deleteColes"], "insertRoles": ["updateLols", "insertLoots", "copyRules", "insertGoots", "updateRoles", "insertRsles", "insertRows", "insertLles", "insertLules", "copyRoles", "insertRsules", "insertRodes", " insertShole", "updateLoles", "insertSules", "copyGows", "copyGules", "insertRsoles", "updateRules", " insertRules", " insertSholes", " insertRodes", "insertSodes", "deleteRanges", "insertSloots", "copyRows", " insertRole", "insertRsanges", "insertRsodes", "insertLoles", "insertRoots", "copyGoots", "insertRols", "updateRols", "insertSlanges", "insertSole", "copyGoles", "insertSoles", " insertShules", "copyRoots", "insertRles", "updateLules", "insertSholes", "insertRanges", "insertLols", "insertShole", "insertRules", "insertGules", "insertShules", "insertLows", "deleteSlanges", "deleteSloots", "insertRsoots", "updateRles", "insertRsows", " insertShodes", "insertRole", "deleteRodes", "insertSloles", "insertGoles", "insertSlodes", "deleteRoots", "updateLles", "deleteSloles", "insertRsols", "deleteSlodes", "insertGows", "insertShodes"], "role": ["shadow", "slave", "de", "base", "error", "alias", "force", "Role", "relation", "one", "rol", "function", "row", "val", "label", "string", "profile", "range", "to", "link", "or", "username", "zone", "type", "repl", "route", "tag", "rule", "guard", "service", "resource", "key", "l", "entry", "roller", "ro", "member", "ole", "group", "rl", "tool", "le", "module"]}}
{"id1": "160739", "id2": "22046596", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"createOutputStream": [" createInputReader", "createInputStream", " createInputFile", "createOutputSteam", " createIOReader", "createInputFile", " createByteReader", " createByteStream", " createIOStream", " createOutputFile", " createIOFile", "createInputSteam", " createInputSteam", " createByteFile", " createIOSteam", " createOutputSteam", " createOutputReader", " createInputStream", "createInputReader", "createOutputReader", " createByteSteam", "createOutputFile"], "inFile": ["incFiles", "inputfile", "inStream", "inputStream", "insFiles", "outFiles", "inputFiles", "sourceFile", "sourcefile", "inputFile", "outStream", "insfile", "incfile", "incFile", "outfile", "insStream", "incStream", "inFiles", "infile", "insFile", "sourceFiles", "sourceStream"], "outFile": ["workingStream", "workTime", " outStream", "inputfile", " outDirectory", "outTime", "workfile", "workingfile", "inputDir", " outfile", "outDir", "workFile", "workingFile", "targetStream", "inTime", "outDirectory", "workingDirectory", "inputFile", "targetfile", "targetFile", "workDir", "outStream", "inputTime", "outfile", "targetDirectory", "inDir", "infile"], "k_blockSize": ["k_lockLength", "k_bitCount", "k_blockCode", "k_byteCount", "k_byteLength", "k_lockCode", "k_lockLen", "k_blocksSize", "k_blockLen", "k_BlockSize", "k_bitSize", "k_bitInfo", "k_lineSize", "k_lockCount", "k_BlockLength", "k_lineCount", "k_BlockCount", "k_byteLen", "k_blocksLength", "k_byteSize", "k_BlockCode", "k_blockInfo", "k_byteInfo", "k_blockLength", "k_blocksCount", "k_blockCount", "k_lockSize", "k_lineInfo", "k_blocksLen", "k_byteCode"], "byteCount": [" byteSum", " byteLen", "flushSize", "ByteSize", "ByteSum", "blockCount", " bytecount", "byteLen", "characterSize", "flushcount", "Bytecount", "byteLength", "flushLength", "blockLength", " byteSize", "byteSize", "characterLength", "byteSum", "bytecount", " byteLength", "characterCount", "ByteLen", "characterLen", "blockSum", "flushCount", "ByteLength", "blockSize", "ByteCount"], "buf": ["base", "cmd", "feed", "vec", "config", "flush", "feat", "src", "queue", "bag", "uf", "bytes", "b", "cb", "bh", "cap", "background", "font", "buff", "border", "buffer", "rc", "fd", "fb", "bf", "result", "Buff", "len", "img", "cas", "tmp", "alloc", "ucc", "la", "brace", "loc", "data", "cv", "rb", "ctx", "seq", "batch", "Buffer", "exc", "append"], "ofp": ["fort", "afl", "OFp", "OFnp", "OFl", "Oftp", "forp", "Ofc", "afnp", "Ofp", "OFtp", "ofl", "Ofnp", "OFt", "oft", "ofnp", "forc", "oftp", "afp", "Oft", "fortp", "afc", "ofc", "Ofl", "OFc"], "zos": ["z", "iffs", "zes", "zx", "ls", "lins", "oda", "liquid", "webkit", "zon", "tz", "zy", "nox", "forge", "bes", "os", "zers", "zl", "iframe", "rez", "modules", "zen", "fits", "los", "rons", "za", "kos", "gz", "uz", "zar", "ops", "zig", "bos", "hz", "nz", "packs", "ZA", "zn", "inos", "obs", "core", "outs", "zag", "ros", "ossus", "obb", "bitcoin", "dylib", "zona", "oses", "soon", "budget", "zi", "lol", "zb", "utils", "osi", "zip", "zyk", "ws", "ZI", "ogl", "zo", "abi", "ozo", "zik", "robe", "zh", "enos", "zer", "js", "cfg", "zin", "css", "cos", "ses", "owicz", "oS", "bs", "jas"], "osw": ["lswo", "eshell", "osy", "ossow", "osssw", "isnow", "osow", "ossww", "essw", "osswd", "oshell", "bwo", "isd", "eswd", "esow", "osnow", " osow", "osws", "ossfw", "esnow", "osd", " osfw", "issw", "esfw", "esy", "isw", "lsx", "osshell", "ossnow", "osfw", "esww", "esd", "bsws", " osww", "osx", "ossw", "ishell", "oswo", "oswd", "bws", "bsx", "iswd", "osww", "lsw", "bsw", "ossy", "lsws", "esw", "isy", "bx", "bswo", "ossd"], "bw": ["bbw", "Bw", "lw", "Bew", "lbsw", "bbwh", " bws", "bwe", "fr", "owa", "fbW", "bbaw", "oaw", "Bws", "bz", "fbw", "Bwa", "bbew", "abwe", "baw", "lbz", "abw", "fsw", "ebwe", "lbw", "owu", "fw", "fbwe", "bbz", " bew", "ow", "lbws", "ebW", "fwh", "fwa", "lbwh", "lx", "abwd", "ebw", " bwu", "lwa", "bwu", " bwa", "bew", " baw", "fx", "bws", "bwh", "fbwd", "bW", "bbwa", " bz", "lsw", "bwa", "lbwa", "bbwu", "bsw", "bwd", "ebwd", "bbws", "bx", "abW", "lbr", " bwh", "lbx"], "zot": ["zerott", "aziot", "jit", "zita", "zeros", "azor", "zerot", "zerori", "zerit", "azot", " ziot", "azott", "Zot", "zott", "Zott", "Zit", "ziot", "jot", "Zita", "jori", "Zor", "Ziot", "zor", "zori", "jos", "azit", " zori", "zerita", " zor", "azita"], "ifp": ["IFi", "ipb", " iff", "ifi", "Ifi", "ifb", "Ifc", " ifi", " ifl", "IFb", "IFf", "ipl", "IFl", "ifc", " ifb", "Iff", "ipc", "iff", "ifl", "ipp", "IFp", "IFc", "Ifp", " ifc"], "zis": ["jis", "zisi", " zib", "jisi", "jit", " zIS", "xits", " zisi", "zib", "zip", "xais", "xisi", " zits", "zenais", "zeis", "xit", "zenis", "Zis", "zenIS", "jits", "zipits", "zipiss", "xIS", "zeip", "Zits", "Ziss", "Zip", "zeiss", "xis", "zIS", "zeits", "xib", " zais", "zenib", "ziss", "zais", "zits", "zipip", "zipis"], "isr": ["irrc", "rispr", "iscr", "risr", "risrb", "ISrc", "ispr", "ISr", "isscr", " isrs", "issrs", "ISpr", "irr", " issr", "isrs", "irrb", "IScr", "isssr", "isrc", "ISrs", "isrb", "issr", "risrc", "irpr", " iscr", "ISsr", "ISrb"], "br": ["body", "err", "bsp", "lr", "fr", "kr", "HR", "bl", "arr", "cro", "ocr", "yr", " fr", "b", "ch", "ctr", "bp", "sp", "r", "ber", "gr", "tr", " dr", "ibl", "bro", "obl", "div", "Br", "ibr", "BR", "mr", "img", "rs", "hr", " BR", "bar", "sr", "rib", "ob", "browser", "str", "rb", " Br", "bc", "bh", "obi", "shr"], "zit": ["zith", "zite", "xic", "zeita", "zic", "jit", "zita", "zipith", "zipite", "zip", "zipIT", "zenits", "zenit", " zip", "zeIT", "jic", "jita", "zenith", " zits", "zitter", "jip", "zeitter", "xit", "jIT", "zipit", "zipita", "xi", "jite", " zi", " zic", " zite", "jits", "ji", "zipits", "zIT", "zipitter", "zenitter", "zeith", "zeits", "zeit", "xith", " zith", "jith", "zits", "zipip", "zi"]}}
{"id1": "15516136", "id2": "20568568", "code1": "    public static synchronized BufferedImage loadBufferedJPEGImage(URL url) {\n        BufferedImage image = null;\n        if (url != null) {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);\n                image = decoder.decodeAsBufferedImage();\n            } catch (Exception e) {\n                log.severe(\"URL: \" + url + \" - \" + e.getMessage());\n                image = null;\n            } finally {\n                try {\n                    if (in != null) in.close();\n                } catch (IOException ioe) {\n                    log.severe(\"URL: \" + url + \" - \" + ioe.getMessage());\n                }\n            }\n            if (image != null) {\n                log.config(\"Image type : \" + image.getType());\n                if (image.getWidth() <= 0 || image.getHeight() <= 0) {\n                    log.severe(\"URL: \" + url + \" =0\");\n                    image = null;\n                }\n            }\n        }\n        return image;\n    }\n", "code2": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"loadBufferedJPEGImage": ["loadBufferedJPNGMedia", "loadBufferedJPEGMedia", "loadBufferedMPPGMedia", "loadBufferedJPELFile", "loadBufferedMPEGMedia", "loadBufferedMPEGimage", "loadBufferedJPEGimage", "loadBufferedJPELMedia", "loadBufferedMPEGFile", "loadBufferedJPNGFile", "loadBufferedMPEGImage", "loadBufferedMPPGImage", "loadBufferedJPPGImage", "loadBufferedJPPGMedia", "loadBufferedMPPGFile", "loadBufferedMPPGimage", "loadBufferedJPNGimage", "loadBufferedJPPGimage", "loadBufferedJPELImage", "loadBufferedJPEGFile", "loadBufferedJPPGFile", "loadBufferedJPNGImage", "loadBufferedJPELimage"], "url": ["play", "path", "string", "address", "buffer", "loader", "base", "ssl", "server", "uri", "resource", "feed", "job", "id", "http", "remote", "filename", "ref", "location", "l", "large", "URL", "host", "el", "dl", "email", "source", "rule", "connection", "media", "alt", "config", "data", "file", "src", "page", "object", "ll", "bb", "log", "href", "style", "name", "coll", "blog", "link", "sl", "mount", "Url", "layer", "www", "stream", "pull", "ur", "xml", "found", "f", "gl", "service", "download", "loc"], "image": ["zip", "pin", "eye", "output", "resource", "ini", "document", "large", "database", "Image", "picture", "cm", "thin", "cover", "model", "default", "build", "file", "archive", "bug", "container", "xml", "element", "jpg", "info", "audio", "game", "site", "result", "ui", "icon", "source", "cache", "up", "connection", "value", "ami", "work", "parent", "page", "object", "pixel", "job", "i", "video", "message", "slice", "inner", "show", "upload", "p", "issue", "m", "available", "gallery", "position", "photo", "shadow", "error", "im", "api", "auto", "view", "copy", "instance", "manager", "hole", "media", "pm", "feature", "config", "data", "out", "size", "layer", "figure", "age", "gif", "f", "img"], "in": ["IN", "impl", "pin", "ssl", "i", "input", "ex", "n", "id", "inas", "cf", "serv", "ini", "gin", "con", "c", "socket", "inner", "l", "ins", "el", "bin", "pass", "is", "part", "source", "reader", "doc", "login", "min", "inside", "r", "inc", "data", "rin", "out", "file", "fb", "conn", "init", "or", "again", "m", "ax", "isin", "In", "nin", "kin", "a", "fd", "stream", "err", "b", "ac", "container", "cin", "xml", "inn", "f", "win", "din"], "decoder": ["decoded", "deode", "Decoded", "deenter", "recoder", "Decoding", " decode", "Decenter", "recode", "encode", "decoding", " decoded", "decenter", "recenter", "deoding", "recoding", "Decode", "deoder", "encoder", "decode", " decoding", "encoded", "encoding", "Decoder"]}}
{"id1": "942693", "id2": "11952735", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"convert": ["CONverting", "subverting", "Conversion", "oconversion", "oconverting", "Converting", "CONversion", "unversion", "CONvert", "conversion", "CONception", "oconverted", " deconverted", "converting", "CONverted", "subvert", "oconvert", "Conception", "unvert", "converted", " deconverting", "subversion", "Converted", "unception", "unverted", "subverted", " deconversion", "conception", "Convert", " deconvert"], "src": ["impl", "string", "path", "sel", "ssl", "sin", "input", "sc", "uri", "resource", "sys", "spec", "rc", "Source", "video", "cmp", "username", "filename", "ref", "slice", "cb", "fp", "fn", "s", "prot", "code", "inst", "feat", "cpp", "req", "gb", "back", "source", "reader", "load", "proc", "sb", "rb", "sit", "buf", "component", "dist", "upload", "SourceFile", "config", "file", "tmp", "Dest", "supp", "attr", "img", "href", "storage", "name", "sth", "gz", "RC", "rl", "ctx", "secure", "url", "scene", "stream", "obj", "st", "stage", "sn", "ource", "download", "loc"], "dest": ["path", "class", "temp", " dst", "cont", "fn", "bin", "dc", "std", "txt", "source", "dir", "lib", "target", "dist", "tmp", "Dest", "null", "test", "home", "di", "obj", " destination", "dat", "disk", "orig", "img"], "in": ["IN", "val", "pin", "i", "input", "ex", "n", "inas", "ini", "as", "ins", "bin", "pass", "is", "reader", "d", "source", "doc", "up", "login", "r", "inc", "data", "file", "io", "t", "isin", "In", "a", "stream", "err", "inn", "ps", "f", "inf", "win", "din"], "p": ["P", "i", "pi", "op", "wp", "pre", "lp", "per", "py", "c", "j", "fp", "o", "l", "s", "pb", "cop", "part", "cp", "d", "pr", "pp", "pm", "r", "g", "parser", "h", "np", "po", "tp", "m", "e", "t", "pc", "jp", "pa", "bp", "pe", "b", "sp", "v", "ps", "f", "pd", "pg"], "ds": ["services", "uds", "ays", "docs", "ants", "dos", "s", "ins", "dp", " DS", "parts", "points", "gs", "els", " props", "des", "ts", "js", "utils", "ths", "ys", "gd", "sys", "df", "lp", "bs", "dc", " ps", "dt", "sync", "lines", "eps", "vs", "ges", "amps", "ipes", "pd", "dd", "sts", "DS", "cons", "ks", "ns", "qs", "ld", "hs", "d", "dist", "ans", "ads", "xs", "models", "plugins", "groups", "tests", "ss", "di", "os", "posts", "styles", "rs", "dl", "tools", "ded", "ups", "data", "vals", "scripts", "Ds", "ls", "obs", "dm", "db", "ils", "nas", "dates", "da", "cs", "words", "dds", "ps", "dat", "icks", " sd"], "format": ["letter", "string", "path", "class", "handler", "spec", "filename", "act", "version", "table", "fp", "fn", "host", "tag", "record", "layout", "feat", "magic", "Format", "pattern", "form", "filter", "at", "type", "source", "part", "model", "parser", "config", "data", "file", "sche", "struct", "ant", "language", "style", "plugin", "template", "name", "frame", "t", "function", "prefix", "fd", "nat", "url", "unit", "atter", "f", "scale", "api"], "hasPixelData": ["hasPixeldata", "showsPixelDATA", "hasPixelDATA", "hasPicturedata", "hasByteSize", "hasByteDATA", "hasByteData", "haspixelData", "hasPixelStyle", " hasPixelSize", "showsByteDATA", "hasPictureSize", " hasPixeldata", "haspixeldata", "showsBytedata", "hasPictureData", "haspixelSize", "showsByteData", "showsPixelData", "showsByteStyle", "hasPixelSize", "hasByteStyle", "showsPixelStyle", "hasBytedata", "showsPixeldata"], "inflate": ["inadequating", "insflode", "insvenating", "inffated", "Inflation", "InFlation", "inflating", "Inflated", "inflATE", "InFlace", "insvenate", "inadequode", "InFlated", "insflate", "infolATE", "infface", "invenode", "InFlate", "inffation", "inflated", "inFlation", "infolode", "infloace", "insvenATE", "infloate", "invenATE", "inFlate", "inadequATE", "insflATE", "infloation", "invenating", "inffate", "insvenode", "inadequate", "Inflace", "inflation", "inflode", "inFlated", "Inflate", "infolate", "inFlace", "infloated", "invenate", "infolating", "inflace", "insflating"], "pxlen": ["pxdata", "xpsize", "pxlin", "pngcount", "mxsize", "campos", "fxlen", "pxl", "pgLen", "axlen", "ppLen", "mxcount", "fxln", "pxlon", "pxln", "pcln", "pglen", "ppl", "pxlength", "ppden", "camln", "txln", "pngsize", "pxpos", "pclon", "camlen", "mxdata", "axln", "axlon", "mxlength", "mxpos", "mxlen", "xplen", "txlin", "pxden", "pxcount", "fxpos", "txlon", "pclin", "pxsize", "fxdata", "pxLen", "mxln", "xpcount", "pgl", "fxLen", "axlin", "pnglen", "xplength", "fxl", "pgden", "fxden", "pclen", "pnglength", "txlen", "pplen", "camdata"], "out": ["step", "server", "output", "copy", "sys", "user", "lock", "OUT", "inter", "outs", "line", "co", "query", "post", "session", "cache", "lib", "up", "group", "store", "parent", "work", "page", "log", "gen", "conn", "again", "Out", "io", "dump", "obj", "v", "err", "state", "pad", "cli", "error", "re", "list", "point"]}}
{"id1": "17475530", "id2": "11952735", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkFromImage", "testAddLinkToFile", "testAddLinkFromPicture", "testAddLinkstoImage", "testAddLinkstoFile", "testAddLinkOfFile", "testAddLinkToLink", "testAddLinkOfLink", "testAddLinkstoLink", "testAddLinktoImage", "testAddLinkOfPicture", "testAddLinkFromLink", "testAddLinktoPicture", "testAddLinktoLink", "testAddLinkFromFile", "testAddLinkToPicture", "testAddLinksToPicture", "testAddLinksToLink", "testAddLinktoFile", "testAddLinkOfImage", "testAddLinksToFile", "testAddLinkstoPicture", "testAddLinksToImage"], "in": ["ini", "image", "err", "index", "resource", "login", "serv", "stream", "gin", "inn", "val", "input", "with", "din", "In", "at", "version", "exp", "bin", "conn", "pin", "r", "IN", "again", "pass", "token", "path", "work", "doc", "nin", "uri", "cin", "diff", "min", "out", "ins", "is", "xml", "as", "socket", "ssl", "name", "ac", "con", "data", "file", "isin", "rin", "ax", "id", "el", "ex", "i", "win", "reader", "n", "get", "or", "connection", "m", "source", "exec", "f", "url", "inc", "copy"]}}
{"id1": "8921716", "id2": "414258", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"MD5": [" MD8", "MP4", "SHA512", "MP8", "MP512", "MD8", " MD512", "MD4", "SHA4", "SHA8", "MP5", "MD512", "SHA5", " MD4"], "text": ["ext", " TEXT", "data", "name", "version", "str", " Text", "hex", "letter", "class", "binary", "format", "output", "contract", "txt", "content", "bytes", "EXT", "password", "key", "this", "secret", "buffer", "test", "source", "image", "template", "Text", "editor", "path", "struct", "object", "pattern", "url", "config", "number", "code", "in", "word", "prefix", "message", "token", "TEXT", "input", "length", "string", "font"], "UnsupportedEncodingException": ["UnsupportedEncodedception", "UnsupportedEncagingATION", "UnsupportedEncasingException", "UnsupportedEncagingException", "UnsupportedencodedException", "UnsupportedEncodedATION", "UnsupportedEncodingATION", "UnsupportedEncodingception", "UnsupportedencodingATION", "UnsupportedEncodedException", "UnsupportedencodingException", "UnsupportedEncagingception", "UnsupportedEncasingception", "UnsupportedencodedATION", "UnsupportedEncasingATION", "Unsupportedencodedception", "Unsupportedencodingception"], "md": ["meta", "df", "bd", "vd", "data", "mag", "mg", "manager", "cd", "rm", "wd", "method", "dd", "m", "body", "ma", " MD", "mt", "mode", "me", "match", "ld", "dig", "di", "mb", "mac", "cmd", "dm", "docker", "d", "MD", "mo", "mod", "hash", "amd", "mp", "code", "rpm", "metadata", "mm", "pm", "valid", "message", "sha", "cm", "bf", "mc", "ms", "pd", "mand", "pg", "od", "hd", "nm", "Cmd", "ad"], "md5hash": ["mddownsum", "md5Hash", "mand53html", "md5kh", "md2html", "md6hash", "md6kh", "md25hash", "md6Hash", " md6hex", "md25Hash", "md53hash", "md2sum", " md5Hash", "md2hash", "md4Hash", "mand5html", "md2version", "md53html", "md6hex", " md6Hash", " md6sum", " md5hex", "md25html", " md5kh", "md5version", "md5hex", "md2kh", "md53Hash", "md6sum", "md53version", "mand5Hash", "md5sum", " md6kh", "md4hash", "md5html", "mand53version", "md4hex", "md8sum", "md25version", " md6hash", "md8hex", "mddownHash", "md2Hash", "mddownkh", "mand53hash", "mddownhash", "mand5hash", " md5sum", "md8Hash", "md4sum", "mand53Hash", "md8hash", "mand5version"]}}
{"id1": "14567939", "id2": "2807585", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"baseHash": [" generateHash", " chainFile", " chainHash", "BaseSecret", "BaseFile", "Basehash", "basehash", "BaseHash", " generateSecret", " generatehash", " chainhash", " chainSecret", " generateFile", "baseSecret", "baseFile"], "name": ["image", "hello", "n", "key", "class", "host", "object", "user", "parent", "id", "address", "ame", "alias", "path", "resource", "word", "file", "part", "NAME", "prefix", "normal", "base", "definition", "data", "type", "secret", "Name", "names", "member", "style", "string", "named", "hash", "create", "account"], "password": ["account", "words", "crypt", "key", "profile", "pattern", "input", "attribute", "sword", "phrase", "source", "diff", "padding", "Password", "code", "path", "word", "value", "wd", "prefix", "device", "pass", "security", "wallet", "data", "paste", "token", "secret", "text", "auth", "string", "stroke", "seed", "hash", "priv", "PASS", "username"], "digest": ["mdr", " digested", "signest", "mdester", " digger", "digusher", "DigEST", "digger", "mdest", "diger", "Diger", "modested", "moder", "signger", "Digest", "Digger", " diger", "Digester", " digester", "signusher", "modest", "digester", "digEST", "decest", "mdEST", "modester", "Digr", "signer", "decester", "decEST", "Digusher", " digusher", "digested", "digr", "Digested", "decr", "signester"]}}
{"id1": "7945594", "id2": "20519261", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 1, "substitutes": {"fileDownload": ["filePull", " filedownload", " fileURL", "urlURL", "folderdownload", "folderDownload", "folderURL", "filedownload", "urlDownload", "urlPull", "fileURL", " filePull", "urldownload", "folderPull"], "fAddress": ["sfOrder", "rfMessage", "urlOrder", " fPath", "fEmail", "baddress", "FAddress", "fileAddress", "FAdd", "sfPath", " fMessage", "FLocation", "faddr", "urladdress", "rfaddress", "sfAdd", " fEmail", "fingaddr", "bAdd", "urlAdd", "fingEmail", "sfLocation", "sfaddress", "fileAdd", "bPath", "fOrder", "fPath", "fingAdd", "fMessage", "rfLocation", "faddress", "fLocation", "sfAddress", "bLocation", " fAdd", "baddr", "fingAddress", "urlAddress", "bAddress", "bEmail", "fAdd", "sfMessage", " fOrder", "fileLocation", " faddress", "rfAddress", " fLocation", " faddr"], "destinationDir": ["destributionDur", "destativeDIR", "DestributionDir", "destinatedDar", "declinationDur", "declinatedPath", "destativeArea", "declinatedDar", "DestinationDIR", "destinatedDir", "destinationDirectory", "destinationDar", "destinationDur", "destributionDirectory", "destributionDar", "destinatedPath", "destinePath", "destinationPath", "declinationDar", "destributionDIR", "destineDir", "destinationArea", "DestinationArea", "destippingArea", "DestributionArea", "destinationDIR", "declinationDir", "destinatedDur", "destativeDir", "destippingDir", "destributionPath", "destativeDirectory", "destineDur", "declinationPath", "destineDar", "destippingDIR", "DestinationDir", "destributionArea", "declinatedDir", "DestributionDIR", "DestributionDirectory", "destributionDir", "destippingDirectory", "declinatedDur", "DestinationDirectory"], "slashIndex": ["Slashedindex", "SlashLength", "slashedIndex", "slashLength", "SlashCount", "SlashIndex", "SlashedCount", "slushLength", "slashedCount", "slushIndex", "slargeindex", "slargeLength", "Slashindex", "slushindex", "sllashCount", "slargeCount", "slashedindex", "SlashedLength", "slargeIndex", "slashindex", "sllashindex", "sllashLength", "slashCount", "sllashIndex", "slashedLength", "SlashedIndex"], "periodIndex": ["moneyStart", "moneyindex", "dollarindex", " periodStart", "periodStart", "dollarIndex", " periodindex", "moneyIndex", "moneyOffset", "periodindex", " periodOffset", "dollarOffset", "periodOffset", "dollarStart"], "fileName": [" filePath", "FilePath", "filePath", " fileAddress", "fname", "fPath", "fName", "fileAddress", "FileAddress", "Filename", "FileName", "filename", " filename"], "url": ["path", "string", "base", "ssl", "ou", "server", "uri", "resource", "feed", "user", "http", "c", "socket", "rel", "l", "URL", "uu", "fl", "proxy", "up", "connection", "oc", "str", "ch", "ob", "open", "config", "org", "li", "channel", "web", "page", "ll", "bel", "log", "u", "conn", "image", "re", "blog", "link", "sl", "rl", "Url", "www", "bug", "ur", "ul", "download", "f", "plug", "service", "api", "loc"], "uc": ["anc", "cu", "ou", "tc", "cc", "sc", "um", "rc", "http", "con", "c", "fc", "uu", "nc", "cus", "ec", "union", "lc", "auc", "connection", "oc", "exc", "usc", "u", "conn", "ci", "uci", "ucc", "pc", "mc", "soc", "bc", "com", "stream", "cci", "ac", "UC", "ul", "unc", "hub", "cur"], "in": ["IN", "i", "input", "n", "rc", "ini", "gin", "into", "con", "c", "inner", "socket", "ins", "s", "bin", "is", "reader", "source", "up", "login", "inside", "r", "inc", "data", "conn", "init", "again", "io", "image", "it", "In", "nin", "stream", "lin", "b", "ac", "err", "cin", "inn", "f", "cli", "this", "din"], "file": ["zip", "path", "letter", "base", "class", "fe", "output", "resource", "ile", "filename", "per", "socket", "place", "fp", "o", "l", "line", "File", "source", "rule", "dir", "up", "book", "connection", "FILE", "parent", "data", "page", "log", "name", "folder", "e", "io", "to", "full", "files", "b", "f", "this"], "fos": ["fops", "fileOs", "sfis", "sfOS", "sfo", " fops", "FOs", "FOS", " fOs", " fOS", "Fis", "Fos", "fob", "fOs", "fileops", "fileob", "fo", " fis", " fob", "sfos", "Fops", "Fo", " fo", "fOS", "Fob", "fileos", "fis"], "out": ["string", "ou", "outer", "output", "copy", "net", "plain", "OUT", "inner", "o", "outs", "s", "line", "write", "bin", "sync", "up", "w", "work", "data", "inc", "down", "log", "init", "again", "exec", "Out", "io", "writer", "to", "flush", "update", "err", "b", "block", "f"], "inputLine": ["outputL", "outputRow", "inputRow", " inputRow", " inputBlock", "errorRow", " inputLINE", "outputline", "InputEl", "outputBlock", "inputEl", "InputLine", "Inputline", "errorL", "inputBlock", "InputBlock", "errorLINE", "inputL", "outputEl", "InputChar", " inputline", "InputL", " inputEl", "inputChar", " inputChar", "outputLine", "inputline", "outputChar", "outputLINE", "inputLINE", " inputL", "errorLine"]}}
{"id1": "8000624", "id2": "7499186", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"CopyTo": ["copyFile", " copyTo", " transferFrom", " transferTo", "copyto", "CopyFrom", "Copyto", " copyFrom", " transferFile", " copyFile", " copyto", "copyTo", " transferto", "CopyFile", "copyFrom"], "dest": ["folder", "txt", "temp", "done", "class", "exit", "rest", "opt", "table", "dist", "bin", "destroy", "transform", " Dest", "path", "desc", "die", "object", "content", "sup", "comb", "w", "orig", "tmp", "delete", "flat", "filename", "Dest", "img", "output", "test", "data", "write", "them", "obj", "target", " destination", "source", "wb", "cont", "src", "name", "later", "file"], "in": ["fa", "In", "pull", "pass", "plus", "issue", "again", "n", "ini", "IN", "m", "cin", "inner", "din", "bin", "input", "as", "con", "wave", "pin", "ins", "ac", "conn", "inn", "kin", "up", "l", "connection", "init", "win", "s", "rin", "lin", "isin", "x", "gin", "thin", "f", "inside", "i", "nin", "image", "lib", "h", "sin", "login", "reader", "ax", "ln", "vin", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "temp", "or", "plus", "external", "not", "again", "outside", "n", "cache", "o", "ex", "call", "inner", "bin", "Out", "copy", "outer", "io", "outs", "this", "sync", "pin", "conn", "no", "user", "object", "our", "err", "up", "app", "part", "w", "net", "exec", "url", "x", "other", "off", "i", "nin", "image", "lib", "socket", "writer", "ext", "file", "output", "data", "ou", "OUT", "vert", "b", "target", "inc", "client", "name", "one"], "c": ["dc", "ch", "pc", "fc", "u", "cm", "n", "m", "col", "o", "ca", "pointer", "d", "comment", "abc", "ci", "ic", "xc", "sc", "char", "ct", "cf", "cu", "ac", "ce", "content", "C", "oc", "p", "cr", "cl", "cc", "l", "rc", "exc", "x", "config", "bc", "f", "enc", "e", "code", "i", "arc", "uc", "cb", "v", "r", "t", "cy", "ec", "esc", "buffer", "lc"]}}
{"id1": "1097146", "id2": "8320469", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getContentdigests", "getMessageEncester", "getMessagedigests", "getContentDigests", "getMessagedigifier", "getMessageDigifier", "getMessageDigests", "getMessageSignifier", "getMessageEncifier", "getMessagedigester", "getMessageEncest", "getMessageSignester", "getMessageEncests", "getContentdigest", "getContentDigester", "getMessagedigest", "getMessageDigester", "getContentdigifier", "getMessageSignests", "getContentdigester", "getContentDigest", "getContentDigifier", "getMessageSignest"], "input": ["request", "image", "in", "buffer", "self", "amp", "accept", "element", "argument", "stream", "i", "output", "form", "object", "context", "instance", "parse", "parent", "address", "plus", "inf", "state", "target", "content", "inner", "submit", "audio", "message", "array", "container", "xml", "raw", "out", "now", "str", "binary", "this", "null", "definition", "model", "data", "temp", "type", "Input", "text", "document", "password", "reader", "string", "list", "empty", "source", "config"], "md": ["mac", "mm", "mo", "m", "bf", "mad", "mn", "metadata", "M", "um", "ma", "dr", "od", "dc", "bm", "rm", "amd", "cm", "mb", "nm", "df", "wd", "gd", "mand", "bd", "sm", "mg", "dm", "pm", "sha", "mt", "MD", "mp", "di", "me", "mc", "vd", "mag", "rpm", "d", "mod", "ms", "meta", "am", "cmd", "dd", " MD"], "bytes": ["vals", "words", "ipes", "ies", "files", "les", "s", "bs", "units", "strings", "its", "odes", "es", "address", "lines", "keys", "seconds", "tes", "bps", "Bytes", "codes", "gb", "pieces", "classes", "bits", "binary", "pages", "null", "base", "data", "blocks", "b", "values", "groups", "rows", "bles", "body", "string", "parts", "outs"]}}
{"id1": "11645260", "id2": "6371589", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "code2": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doGet": [" doGET", "doRead", "handleGet", "partialPut", "handlePut", " doRead", "partialGET", "partialGet", "handleGET", "partialRead", "doPut", " doPut", "doGET", "handleRead"], "request": ["image", "method", "model", "right", "in", "resource", "create", "child", "service", "view", "this", "current", "event", "forward", "input", "project", "order", "worker", "version", "req", "message", "queue", "key", "authorized", "info", "post", "object", "QUEST", "application", "string", "position", "condition", "subject", "external", "session", "next", "query", "path", "join", "Request", "hello", "type", "require", "result", "uri", "rest", "client", "context", "xml", "report", "name", "server", "user", "data", "reference", "e", "call", "instance", "reader", "complete", "web", "enter", "connection", "requ", "host"], "response": ["re", "onse", "body", "model", "image", "service", "resource", "wave", "feed", "site", "view", "this", "event", "Response", "respons", "function", "json", "fire", "version", "http", "message", "cache", "output", "queue", "api", "respond", "environment", "object", "writer", "page", "remote", "status", "application", "subject", "resp", "session", "success", "result", "client", "manager", "report", "ception", "esi", "server", "user", "document", "error", "results", "res", "complete", "connection", "host", "parent", "reply"], "target": ["force", "base", "resource", "site", "point", "root", "content", "format", "head", "Target", "open", "pattern", "blank", "top", "src", "output", "remote", "href", "replace", "object", "home", "params", "route", "external", "session", "token", "path", "join", "template", "source", "type", "result", "it", "uri", "dest", "context", "name", "location", "test", "bean", "loc", "component", "shadow", "range", "port", "parent", "timeout", "arget", "follow", "rel", "host", "project", "address"], "requestUrl": ["requestURL", "queryEl", "nextLocation", "requestElement", "queryURL", " requestURL", "adjustHost", " requestHost", " requestLocation", "adjustElement", "raiseUrl", "adjustLocation", "requestLocation", "nextURL", "requestHost", "queryUrl", "raiseElement", " requestElement", " requestEl", "raiseLocation", "adjustUrl", "queryLocation", "nextEl", "raiseHost", "requestEl"], "en": ["enc", "de", "in", "ern", " EN", "end", "env", "EN", "eng", "et", "ener", "fen", "ane", "ne", "den", "que", "un", "ann", "En", " En", "set", "ven", "pe", "wen", "au", "er", "ren", "ent", "an", "len", "eni", "es", "ens", "ena", "ae", "esi", "on", "oa", "e", "gen", "el", "n", "een", "enn", "ec", "m", " e"], "nextUrl": [" nextURL", "NextURL", "newEl", " nextEl", "NextUrl", "newURL", "nextURL", "NextLine", "nextPage", "newPage", "newUrl", " nextPage", "NextPage", "nextLine", "nextEl", "newLine", "NextEl", " nextLine"], "allowedToAccess": [" allowedToAuth", "allowedFromaccess", "allowedtoaccess", "allowedFromAccess", "allowedTOAuth", "allowedTOAccess", " allowedtoAccess", "allowedtoAuth", " allowedtoRead", "allowedTORead", "allowedtoAccess", " allowedtoAuth", "allowedToAuth", "allowedToRead", " allowedToaccess", "allowedFromRead", "allowedTooAuth", "allowedToaccess", "allowedtoRead", "allowedTooRead", " allowedTOaccess", " allowedToRead", " allowedTOAccess", " allowedTORead", "allowedTOaccess", "allowedTooAccess", " allowedtoaccess"], "is": ["image", "ib", "its", "in", "address", "can", "serv", "isi", "inner", "vs", "abs", "ops", "over", "ls", "up", "src", "cms", "ir", "http", "does", "has", "api", "info", "ui", "conn", "bb", "IS", "iv", "ri", "ise", "ack", "was", "ic", "ci", "p", "ie", "ris", "it", "os", "uri", "isl", "ai", "isa", "iss", "ip", "ins", "cos", "as", "close", "app", "iso", "us", "ori", "bs", "id", "ob", "isc", "ios", "browser", "Is", "i", "ais", "get", "or", "loc", "web", "s"], "out": ["ou", "err", "log", "image", "pool", "in", "o", "outer", "temp", "resource", "can", "gin", "inner", "to", "obj", "up", "exp", "group", "cache", "sync", "output", "OUT", "remote", "bin", "conn", "writer", "object", "c", "external", "again", "outs", "path", "not", "io", "Out", "client", "block", "cos", "as", "off", "app", "name", "socket", "init", "ext", "co", "ac", "con", "parent", "lock", "error", "ex", "no", "win", "get", "timeout", "inc", "exec"], "url": ["image", "log", "URL", "base", "resource", "www", "config", "impl", "stream", "mount", "ul", "Url", "cur", "channel", "http", "l", "page", "c", "rc", "path", "source", "uri", "plug", "blog", "client", "bug", "ur", "ssl", "server", "user", "sl", "get", "bc", "connection", "loc", "host", "web", "f"], "uc": ["ou", "lc", "UC", "in", "uu", "cci", "self", "ud", "ub", "ul", "um", "nc", "pc", "usc", "anc", "up", "http", "fc", "conn", "connection", "uci", "soc", "c", "unic", "rc", "path", "sc", "ci", "uri", "su", "unc", "xc", "client", "cc", "oc", "ucc", "cus", "auc", "us", "ac", "con", "union", "cv", "mc", "uca", "bc", "ec", "loc"], "buf": ["wb", "pool", "box", "cmd", "br", "vec", "ba", "av", "ff", "queue", "bag", "uf", "b", "cb", "bytes", "bin", "pad", "cap", "cat", "bh", "cf", "buff", "buffer", "rc", "fd", "bb", "fb", "lb", "bf", "bd", "len", "block", "cas", "ucc", "map", "loc", "data", "cv", "af", "rb", "bc", "seq", "batch", "ctx"], "bytesRead": ["secondsread", "wordsRead", "wordsCopy", "bytesread", "tesread", "tesTotal", "BytesRead", "unitsWritten", "secondsCopy", "tesWrite", "tesRead", "wordsWrite", "unitsHave", "secondsWrite", "bitsRead", "tesCopy", " bytesWritten", "unitsWrite", "BytesWritten", "BytesWrite", "secondsRead", " bytesWrite", "bytesTotal", "bytesCopy", "wordsread", "bitsWritten", "bytesHave", "BytesHave", "bitsread", " bytesHave", "bytesWrite", "bytesWritten", "unitsRead", " bytesTotal", " bytesread", "bitsTotal", "tesWritten"]}}
{"id1": "2396191", "id2": "9236363", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFromURLSafe", "getLinksfromURLfast", "getLinksFromStringSafe", "getLinksFromUrlfast", "getLinksfromURLSafe", "getLinksFromStringfast", "getLinksfromUrlSafe", "getLinksFromUrlSlow", "getLinksfromURLFast", "getLinksFromSSLfast", "getLinksFromSSLSlow", "getLinksfromUrlSlow", "getLinksfromUrlfast", "getLinksFromStringFast", "getLinksFromURLSlow", "getLinksFromUrlSafe", "getLinksFromStringSlow", "getLinksFromUrlFast", "getLinksfromUrlFast", "getLinksfromURLSlow", "getLinksFromURLfast", "getLinksFromSSLFast", "getLinksFromSSLSafe"], "p_url": ["pkurl", "pklink", "p_file", "e_layer", "pffile", "tp24link", "pfroot", "pxurl", "p25link", "pfpath", "p64path", "p_link", "tp24url", "ekhtml", "p9domain", "p9url", "pe_line", "piproot", "x_resource", "p__url", "x_domain", "p_page", "ekurl", " p_path", "tp24root", "p24file", "pfline", "p_root", " p_resource", "p_service", "p64line", "pe_url", "eklink", "pkhtml", "tp24file", "pamurl", "pfurl", "p25url", "p__name", "pxconfig", "p_resource", "tp_link", "pxroot", "p24url", "pe_config", "p64url", "e_html", "p__path", "pflink", "p__resource", "p_html", "p_path", "p6url", " p_name", "pfpage", " p_page", "p_layer", "pamlayer", "piplink", "p9resource", "p6config", "p_line", "eklayer", "p25html", "tp_url", "p_config", "p24link", " p_line", "pe_root", "p9service", "p_domain", "p_name", "p24root", "e_url", "tp_root", "pklayer", "p6root", "e_link", "p6line", "pxline", "x_service", "tp_file", "p64page", "pipurl", "pamhtml", "p25layer", "pamlink", "pipfile"], "x_url": ["x_host", " x_ssl", " x_log", "x_ssl", "p_loc", "p_host", "x_log", "x_loc", "p_conn", " x_resource", "x_resource"], "x_conn": ["x_conv", "x___con", "wx_cat", "x_db", "wx_conv", "x_client", "x___db", "x___conn", "x_cat", "x_con", "p_db", "p_conn", "wx_con", "wx_conn", "x___client", "p_client", "p_con"], "x_is_reader": ["x_is_writer", "x_ismldraft", "x_is_resource", "x_is_stream", "x_ismlmanager", "x_is_draft", "x_ismlstream", "x_is_manager", "x_ismlreader", "x_is_pointer"], "x_reader": ["x8reader", "x67reader", "x_stream", "cross_root", "X_result", "x24stream", "x8root", "cross8url", "X_parser", "x8url", "x8parser", "cross8reader", "cross8root", "cross_url", "x24parser", "cross8parser", "X_reader", "x67root", "cross_reader", "x67url", "x67parser", "x24result", "x24reader", "x_parser", "X_stream", "cross_parser"], "x_line": ["p_page", "x__page", "x__url", "xx_link", "xx_line", "x_comment", "x24line", "x24link", "xingcell", "xingrecord", "p_link", "xx_comment", "x_record", "x_lin", "xx_lin", "x24comment", "x_cell", "ex_record", "x__line", "ex_page", "x24lin", "ex_line", "ex_cell", "xingpage", "p_line", "x__link", "xingline"], "e": ["re", "body", "o", "eb", "end", "event", "je", "match", "entry", "fe", "ue", "exec", "ne", "E", " E", "b", "eur", "l", "engine", "code", "element", "c", "pe", "r", "driver", "ace", "g", "oe", "ze", "t", "d", "ie", "p", "ea", "line", "er", "en", "se", "eps", "v", "entity", "ce", "y", "le", "me", "eu", "edge", "es", "he", "ae", "esi", "ge", "ev", "file", "te", "ente", "el", "error", "n", "ec", "m", "ele", "f", "eve", "ee"], "x_match": ["xlgroup", "xlpattern", "ext_pattern", "ax_link", "x_tag", "x__pattern", "x5info", "xJmatch", "ax5case", " x_tag", "x_pattern", "extJpattern", "xlmember", "ax5match", "x_info", "x_member", "p_matched", "x_slice", " x_slice", "ax5link", " x__replace", "xldate", "ax_info", "e___matched", " x_replace", "xJpattern", "e_check", "x_date", "p__url", "x_matched", "e___check", "xjmatched", "x___check", "x_replace", "x__replace", "xlmatch", "p__match", "x_case", "x__match", "x__matched", "x5link", "xammatch", "x5match", "xJmember", "extJmatch", "xJsearch", "p__pattern", "xjpattern", "ax_case", "extJmember", "x_group", "xamcase", "p__matched", "x__url", "ext_member", "xamslice", "e___match", " x__case", "xlsearch", "x__case", "x__slice", " x_date", "ext_search", "x___matched", " x__slice", "e_match", "ax_match", "x_check", "xltag", "x5case", "p_match", "xjmatch", "p_pattern", " x_group", "e_matched", "e___meet", "xamreplace", "extJsearch", "x_search", "x___match", "x_meet", "x___meet", " x_case", " x__match", "ext_match", "ax5info", "e_meet", "xjurl"], "x_dir": ["x6dir", "x_file", "xnetfile", "x6group", "x6url", "xnetdir", "x6file", "x_group", "xnetgroup", " x_file", "xneturl", " x_group"], "x_root": ["x7alias", "x7directory", "x_alias", "xml_root", "xml_alias", "x7root", "xml_path", "x_directory", "x7path", "xml_directory", "x_path"], "x_links": ["x_ids", "x_lines", "x_points", "x67points", "x67ids", "x67lines", " x_ids", "x67links", " x_points", " x_lines"], "x_texts": ["x_urlls", "x_pathes", "x_urlches", "x_textes", "x_urles", "x_pathches", "x_logls", "x_paths", "x_textls", "x_logches", "x_urls", "x_pathls", "x_logs", "x_loges", "x_textches"], "x_buf": ["y__buf", "y__rc", "x__rc", "X_wb", "y_bag", "ex_buf", "y_uf", "x_wb", "X_buf", "x_buff", "x__wb", "X_buffer", "x_bag", "x___buf", "ex__tmp", "x1buf", "x__cb", "ex_tmp", "x64rc", "ex__cb", "x___uf", "X_buff", "y_rc", "x1cb", "x64bag", "x1buff", "x__buf", "x__buffer", "x_tmp", "x_cb", "ex_cb", "ex__buff", "x_rc", "x___bag", "x__uf", "x1tmp", "y_buf", "y__bag", "x64buf", "x__tmp", "y__uf", "x__buff", "x64uf", "ex_buff", "x__bag", "x_uf", "ex__buf", "x___rc", "x_buffer"], "x_matches": ["x__matures", "x_pathes", "x_attches", "x_calhes", "x_batches", "x_morched", "x_Matches", "x_patched", "x_morting", "x_calches", "x_textoms", "xKmathes", "x_locches", "x_Mathes", "x_matched", "x_matchchers", "x_batures", "x_batchers", "x_Matcher", "x_locched", "x_attcks", "x_morhes", "x_Matchers", "xKtextoms", "x__mathes", "xKmatches", "x_patches", "x_loches", "x_attched", "x_matcher", "xKtextches", "x_matcks", "x_texthes", "x_matchches", "x_matchcher", "x_matchcks", "x_Matures", "x_patcks", "x_matchched", "x_matchers", "x_matchoms", "x_caloms", "x_textings", "x_matchhes", "xKtextings", "x_locting", "x_calings", "x_matings", "x_matchings", "x_patcher", "xKtexthes", "x_atthes", "x_matting", "x_matoms", "xKmatings", "x__matchers", "x_matchting", "x_mathes", "x_bathes", "x_morches", "x__matches", "x_textches", "x_matures", "xKmatoms", "x_patchers"], "x_page": ["ex_loc", "X_page", "tx_feed", "X_path", "x_file", "X_url", "xerpage", "x67file", "xerfeed", "tx_link", "ex_file", "xerline", "tx_line", "x_feed", "tx_page", "x67page", "x67link", "ex_page", "ex_link", "x_loc", "X_line", "xerlink", "x67loc", "x_path"], "x_link": [" x_target", "xpubloc", "xpubline", "xpubtarget", "ex_page", "ex_line", "ex_link", "x_loc", " x_loc", "ex_url", "x_target", "xpublink"], "i": ["ini", "z", "index", "j", "o", "in", "oi", "chi", "hi", "phi", "ii", "ix", "count", "key", "b", "info", "ui", "iv", "ri", "pi", "c", "r", "gi", "k", "li", "ci", "p", "ie", "multi", "si", "xi", "io", "uri", "bi", "v", "x", "ai", "ji", "it", "y", "eni", "a", "ori", "ti", "qi", "id", "iu", "u", "f", "n", "di", "I", "zi"]}}
{"id1": "9096319", "id2": "3375724", "code1": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"handleNodeRegainedService": ["handleNodeReginedEvent", "handleNodeReginedService", "handleNoderegainsServices", "handleNodeRegainsEvent", "handleNoderegainedServices", "handleNoderegainedService", "handleNodeRegainingService", "handleNoderegainedEvent", "handleNodeRegainingServices", "handleNodeRegainsService", "handleNodeRegainedEvent", "handleNodeReginedServices", "handleNoderegainsEvent", "handleNodeRegainingEvent", "handleNodeRegainedServices", "handleNoderegainsService", "handleNodeRegainsServices"], "eventID": ["updateid", "issueName", "updateID", "issueid", "issueID", "issueId", "nodeId", "eventid", "serviceid", "nodeTime", "updateId", " eventid", "serviceName", "serviceTime", "eventId", " eventName", "serviceId", "eventName", "updateName", " eventId", "nodeName"], "nodeID": ["resourceID", "eventPath", "nodeResult", "nodeid", "packageID", " nodeResult", "siteId", "nodeRI", " nodeid", "globalid", " nodeName", "nodeId", "eventid", "odeID", "serviceid", "resourceId", "globalPath", " nodeRI", "nodePath", "packageId", "eventKey", " nodeKey", "objectId", "globalId", "objectName", "odeId", "eventResult", "siteName", "sourceID", "eventId", "sourceRI", "sourceId", " nodePath", "eventName", "odeName", "nodeKey", " nodeId", "serviceId", "resourceKey", "objectID", "siteid", "odeRI", "nodeName", "odeResult", "globalID", "objectid", "packageid", "siteID"], "ipAddr": ["ipAddressri", "ipAppr", " ipAttrs", "IPAdder", "ipAddrt", "ipAddressrt", "IPAddrs", "ipAtter", " ipAttr", "ipAddressrs", " ipAppvr", "ipaddress", "ipAddressvr", " ipAttri", "ipAppvr", "ipAttri", "ipaddr", "ipChn", " ipAddrs", " ipApprs", "IPAddr", "IPAddressrt", " ipAdder", "ipaddrs", "ipAder", "ipAddri", " ipAtter", "ipOffrt", "IPAddressn", "IPAddri", "ipAdder", "IPAddrt", "ipAttr", "ipAddvr", "ipadder", "ipAdrs", "ipaddvr", "ipAttrs", "ipApprs", "ipAddrs", "ipOffrs", " ipAddress", "ipAddn", "IPAddressri", "ipOffr", "IPAddressr", " ipAddvr", "IPAddresser", "IPAddressrs", "ipAddressress", "ipAttvr", "ipAdn", " ipAttvr", "ipChr", "ipAddressn", "ipAddressr", "ipCher", "ipAddress", " ipAddri", "ipAddresser", "ipaddri", "ipChrs", "ipOffri", "ipAdr", " ipAppr", "IPAddn"], "serviceID": ["featureID", "resourceID", "skillName", "eventIDs", "serviceIDs", " serviceHandle", "featureIP", "serviceHandle", " serviceX", " serviceNAME", "ServiceName", "ServiceIDs", "skillID", "featureId", "ServiceID", "resourceType", "ServiceIP", "eventX", " serviceName", "ServiceId", "processId", "ServiceHandle", "serverID", "skillNAME", "serviceX", "resourceId", " serviceId", " serviceIP", "ServiceNAME", "serviceName", "serverId", " serviceIDs", "serviceNAME", "eventId", "featureHandle", "processName", "serviceIP", "eventName", "serviceId", "ServiceType", "processID", "serverName", "serverX", "skillId", " serviceType", "serviceType"], "eventTime": ["EventName", "changePoint", "changeTIME", "changeTime", "errorTime", " eventType", "changeType", "EventTim", " eventPoint", "eventTIME", "processName", "processTim", " eventName", "eventName", "eventTim", "processID", "errorTIME", " eventTIME", "processTime", "errorType", "EventID", "EventTime", "eventType", "eventPoint", "errorPoint", " eventTim"], "log": ["event", "info", "path", "lo", "temp", "feed", "output", "lock", "entry", "LOG", "http", "tool", "net", "c", "ge", "l", "host", "pool", "tag", "write", "thread", "pl", "key", "fail", "loop", "type", "stat", "cache", "connection", "debug", "model", "cat", "ch", "w", "config", "level", "crit", "out", "build", "cl", "get", "put", "gen", "conn", "format", "or", "lex", "port", "exp", "blog", "it", "call", "db", "Log", "og", "full", "com", "url", "bug", "pe", "contract", "sign", "plug", "error", "sec", "stop"], "dbConn": ["dbConnection", "logConnect", "bbCon", "dbconn", "cbConnection", "fbCon", "logConn", "fbColl", "dbCt", "DBConnection", "DbConnection", "bbConn", " dbConnect", "DbConn", " dbCt", "logconn", "DbConnect", "DBConn", "fbCt", "dbLoc", "dbConnect", "realCon", "DbCt", "logDb", "databaseConn", " dbDb", "databaseConnection", "realCt", "cbConnect", " dbConnection", "bbconn", "fbConn", "DBConnect", " dbconn", "dbColl", " dbLoc", "realColl", "dbDb", " dbColl", "DbDb", "databaseconn", "bbConnect", "DBCon", "databaseLoc", "cbConn", " dbCon", "Dbconn", "DbLoc", "cbconn", "DBconn", "DBCt", "realConn", "bbConnection", "dbCon"], "outageUpdater": ["outageUtdter", "outageUpdraser", "outageUpdatedratter", "outageAppdator", "outageUprusher", "outageUnaser", "outageUpdrater", "outageUpdrator", "outageUpdatedraser", "outageUpnoster", "outageUpdatarter", "outageUpmter", "outageUpdatATER", "outageUpdarter", "outageUppater", "outageUpdroster", "outageUpnoder", "outageUpdoder", "outageUpdager", "outageUpdatedarer", "outageupdatter", "outageUpdatedATER", "outageUptatable", "outageChdator", "outageUpfatter", "outageUpnager", "outageUpdrarer", "outageUpdatedatter", "outageUnATER", "outageuplater", "outageUpfaser", "outageUpratter", "outageChdroster", "outageUpdrapper", "outageUpdroder", "outageupdaser", "outageAppdter", "outageChdrator", "outageUplusher", "outageAppnter", "outageUplatter", "outageUpparter", "outageUpfater", "outageUpnarer", "outageUpdoster", "outageUpfapper", "outageUpdatedrater", "outageChdoster", "outageUtdatter", "outageUpdrusher", "outageUpdrATER", "outageUpdatedatable", "outageUpdatater", "outageuplusher", "outageUpdatedrapper", "outageUpdatedratable", "outageUpdatatter", "outageUtdarter", "outageUtdatarter", "outageUpdratable", "outageUpdATER", "outageUpdarer", "outageuplaser", "outageAppnager", "outageUtdater", "outageUpdsoster", "outageUdater", "outageUptaser", "outageUppter", "outageChdater", "outageAppnater", "outageUpdusher", "outageUpdatable", "outageUpdatedater", "outageUpdatter", "outageUpdratter", "outageUpdatedrarer", "outageUpndater", "outageUdATER", "outageUpmager", "outageUpdator", "outageUpndarter", "outageUpnter", "outageUplaser", "outageUprater", "outageUpdsator", "outageChdoder", "outageUpnater", "outageUpnaser", "outageUppatter", "outageUppaser", "outageUpdatedapper", "outageUplapper", "outageUpndter", "outageUnarer", "outageAppdager", "outageUpnator", "outageUpmator", "outageupdusher", "outageUplater", "outageUpstager", "outageUpdatedrATER", "outageUpnATER", "outageUdaser", "outageuplatter", "outageUpdsater", "outageUpmater", "outageUppATER", "outageChdrater", "outageUtdatater", "outageUptater", "outageUpstater", "outageUdarer", "outageUnater", "outageAppdater", "outageUpdter", "outageAppnator", "outageUpdatedaser", "outageUptarer", "outageChdroder", "outageUtdatatter", "outageUpdataser", "outageUpdapper", "outageUpstter", "outageupdater", "outageUpstator", "outageUpdaser", "outageUpraser", "outageUpdatarer", "outageUpndatter", "outageUpdsoder", "outageUpdatatable"]}}
{"id1": "16572931", "id2": "5135688", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    private boolean saveNodeMeta(NodeInfo info, int properties) {\n        boolean rCode = false;\n        String query = mServer + \"save.php\" + (\"?id=\" + info.getId());\n        try {\n            URL url = new URL(query);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            byte[] body = Helpers.EncodeString(Helpers.ASCII, createURLEncodedPropertyString(info, properties));\n            conn.setAllowUserInteraction(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            setCredentials(conn);\n            conn.setDoOutput(true);\n            conn.getOutputStream().write(body);\n            rCode = saveNode(info, conn);\n        } catch (Exception ex) {\n            System.out.println(\"Exception: \" + ex.toString());\n        }\n        return rCode;\n    }\n", "label": 0, "substitutes": {"unJar": ["addTar", "updateJava", "updateServer", "copyjar", "copyJava", "updateTar", "putJava", "updatejar", "addServer", "putjar", "copyServer", "addjar", "putServer", "putTar", "addJava", "copyTar"], "jarPath": ["JarPath", "javaFile", "garLog", "relFile", " jarDir", "jarpath", "erbName", "jarLog", " jarUrl", " jarPo", "browserpath", "javapath", "jarName", "javaName", "garEntry", "JarDir", "JarEntry", "browserPath", "browserName", "javaPath", "jarUrl", "erbPath", "javaPo", "javaUrl", " jarpath", "garpath", "jarPo", "garPath", "JarUrl", "erbPo", "javaEntry", "JarName", "jarFile", "relDir", "browserEntry", "Jarpath", "jarDir", " jarFile", " jarName", "relEntry", "javaDir", "erbEntry", "javaLog", " jarLog", "JarFile"], "jarEntry": ["jarentry", "JarPath", "javaInfo", " jarDir", "jarInfo", "jarLog", " jarUrl", " jarEnt", "Jarentry", "dropPath", "jarName", "dropInfo", "javaName", "JarEntry", "xmlPath", " jarInfo", "irName", "jarJar", "xmlEntry", "javaPath", "zipUrl", "jarUrl", "irEntry", "javaUrl", "aliasInfo", "aliasEnt", "cookDir", "JarInfo", "cookEnt", "zipName", "javaentry", "javaEntry", " jarentry", "zipEntry", "irentry", "xmlLog", "dropentry", "jarDir", " jarName", "irJar", "jarEnt", "aliasName", "javaDir", "aliasEntry", "cookEntry", "javaJar", "javaLog", "xmlInfo", " jarJar", " jarLog", "dropEntry", "javaEnt", "zipDir", "cookPath"], "path": ["th", "model", "resource", "temp", "step", "skip", "mode", "next", "p", "it", "prop", "dir", "context", "name", "test", "file", "binary", "str", "source", "host", "parent", "directory", "folder", "log", "ion", "this", "content", "po", "patch", "pattern", "src", "sync", "conn", "wd", "cat", "string", "PATH", "code", "cel", "pass", "core", "archive", "id", "loc", "base", "right", "Path", "prefix", "inner", "entry", "text", "zip", "left", "home", "not", "ph", "type", "out", "zone", "request", "data", "lock", "default", "location", "mount", "address", "image", "end", "root", "key", "route", "work", "part", "uri", "ath", "dest", "clean", "config", "project", "url"], "relPath": ["relName", "revPath", "RelEntry", " relUrl", "relType", "Relpath", " relName", "relativeName", "relativePath", "relativeUrl", "revType", "RelType", "RelPath", "RelUrl", "relEntry", "relUrl", " relType", " relpath", "revEntry", "RelName", " relEntry", "relpath", "revpath", "relativepath"], "jar": ["z", "folder", "her", "j", "base", "dr", "tar", "module", "car", "gar", "tab", "Jar", "py", "ball", "gap", "open", "entry", "cur", "fire", "zip", "ler", "rar", "java", "bag", "b", " Jar", "gi", "drop", "job", "er", "ja", "le", "dir", "xml", "zone", "pack", "bar", "archive", "jo", "file", "war", "binary", "browser", "sl", "keeper", "pkg", "lib", "ar", "cook", "plugin", "url"], "ze": ["z", "ipe", "de", "za", "zes", "je", "zzy", "aze", "entry", "zip", "zee", "ke", "zer", "ine", "kee", "zy", "pe", "zed", "zin", "ZE", "oe", "be", "ie", "se", "ja", "zie", "ce", "le", "pse", " je", "ge", "te", "e", "zen", "sl", "ele", "sle", "zi"], "bin": ["kin", "log", "base", "in", "resource", "login", "inner", "bot", "ban", "bon", "zip", "bas", "brain", "bit", "b", "bb", "bed", "spin", "pin", "gi", "abi", "boot", "bi", "len", "cin", "jin", "cookie", "bian", "bis", "pack", "init", "proxy", "data", "file", "binary", "isin", "gen", "lock", "win", "abin", "lib", "sin", "web", "plugin"]}}
{"id1": "7872659", "id2": "6470716", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndmovieIndexfile"], "completePath": ["execVol", "correctCorp", " CompleteHome", "execLoader", "execPath", " completeRoot", "CompleteDir", "itepath", "donePath", "CompletePath", "itePath", " completeFile", "progresspath", "completeCh", "completeLoader", "successCh", "completeHome", " completeCorp", "doneVol", "completeVol", "flatCorp", "completepath", "completeMusic", "correctPath", "execpath", "flatPoint", " completeCh", " CompletePath", " completeHome", "completeCorp", "progressPath", "CompleteHome", " CompleteFile", "completePoint", "successPath", "correctRoot", "completeRoot", " CompleteDir", "successMusic", "CompleteFile", "iteCh", "flatPath", "progressVol", "flatRoot", " completeMusic", "progressLoader", "correctPoint", "donepath", " completeDir", "completeDir", "successpath", " completepath", "completeFile", "iteMusic", "doneLoader", " completePoint"], "masterFile": ["MasterFILE", "mastersFILE", "masterPath", "mastersFile", "MasterPath", "configPath", " masterFilename", "masterFILE", " masterName", "mastersPath", "masterFiles", "cacheFiles", "configName", "MasterFile", "cacheFile", "cachePath", "MasterName", "configFile", "cacheFILE", "MasterFiles", "MasterFilename", "mastersFiles", "masterFilename", " masterPath", "configFilename", "masterName"], "CustRatingFileName": ["CustRatingFilesPath", "CustIndexFileVersion", "CustIndexFilesName", "CustRateFilenameSize", "CustRatingFullName", "CustRatingFilesType", "CustRateFileName", "CustRatingClassType", "CustIndexFilesVersion", "CustRatingFilenameDesc", "CustRatingClassName", "CustRatingClassVersion", "CustRatingFilesName", "CustRatingLineType", "CustRatingFileVersion", "CustIndexFilePath", "CustRateFileDesc", "CustRatingFullSize", "CustRatingFilesDesc", "CustRatingFileDesc", "CustIndexFileName", "CustRatingLineVersion", "CustRatingFilenameSize", "CustRatingFilenamePath", "CustRatingLinePath", "CustRatingFilenameName", "CustIndexFilesPath", "CustRatingFullPath", "CustRatingClassPath", "CustIndexFilesType", "CustRatingLineName", "CustRatingFileType", "CustRateFilenamePath", "CustRateFilePath", "CustRatingFileSize", "CustRateFilenameDesc", "CustRateFilenameName", "CustIndexFileType", "CustRatingFilePath", "CustRatingFullDesc", "CustRateFileSize", "CustRatingFilesSize", "CustRatingFilesVersion"], "MovieIndexFileName": ["MovieIndexFilesName", "MovieConfigFolderFile", "MovieConfigFileHandle", "MovieIndexFSize", "MovieIndexFolderVersion", "MovieIndexFname", "MovieIndexFILEName", "MovieIndexClassUrl", "MovieEditFileSize", "MovieConfigFolderHandle", "MovieIndexFileHandle", "MovieIndexFilesname", "MovieIndexFileVersion", "MovieIndexPlaceHandle", "MovieEditFSize", "MovieEditFUrl", "MovieIndexClassname", "MovieIndexFileSize", "MovieEditFname", "MovieIndexFolderFile", "MovieIndexFilesSize", "MovieIndexFilesUrl", "MovieEditFileName", "MovieConfigFileFile", "MovieEditFileUrl", "MovieIndexFolderHandle", "MovieIndexFileFile", "MovieIndexClassName", "MovieIndexFolderName", "MovieIndexFileUrl", "MovieIndexFILEHandle", "MovieIndexFILEFile", "MovieIndexPlaceVersion", "MovieIndexFilename", "MovieIndexClassSize", "MovieConfigFolderName", "MovieIndexFUrl", "MovieEditFilename", "MovieIndexPlaceFile", "MovieConfigFolderVersion", "MovieIndexFName", "MovieIndexFILEVersion", "MovieConfigFileName", "MovieEditFName", "MovieIndexPlaceName", "MovieConfigFileVersion"], "inFile": ["incFile", " inSourceFile", "InSourceFile", "outFile", "outSourceFile", "inputfile", "outfile", "inputSourceFile", " infile", "infile", "inputFile", "incfile", "Infile", "inputF", "InF", "InFile", "outC", "incSourceFile", "incC", "inSourceFile", "inF", " inF"], "inC": [" inCC", "InCC", "innerCI", "inputCC", "outFile", "outF", " inCL", "inputFile", "inputC", "innerC", "outCL", "outCI", "InC", "innerCC", "inCL", "InCI", "outB", "inputF", "inCI", "inCC", "InF", "outCC", "InB", "InFile", "outC", "innerFile", "inB", "InCL", "inF", " inF", " inB"], "outFile1": ["outFId", "outputfile2", "outFName", "againFile2", "outfileName", "outPlace1", "againFile1", "outputfileName", "againC3", "outPathFirst", "againFileFirst", "againCFirst", "outfile1", "outPlace2", "outFile3", "outFileName", "outPlaceId", "outFiles3", "outFiles2", "outPath1", "outFilesFirst", "outfile2", "outPlaceName", "outFileFirst", "againFile3", "againC1", "outputFile1", "againC2", "outputFileName", "outF1", "outputfile1", "outCFirst", "outputFileId", "outFileId", "outputFile2", "outF2", "outFiles1", "outC3", "outputfileId", "outPath3", "outPath2", "outfileId"], "outC1": ["newcOne", "againCOne", "outD8", "outD1", "newc81", "outB8", "newC81", "outDOne", "againB8", "outDFirst", "outc81", "newC1", "outCOne", "newCOne", "againC8", "outcFirst", "outC8", "againBOne", "againC1", "againC2", "outFOne", "outF1", "outCFirst", "outD81", "outC81", "outBOne", "newcFirst", "againB2", "outcOne", "outD2", "againB1", "outF2", "newCFirst", "outB1", "outCFOne", "newc1", "outB2", "outCFFirst", "outCF81", "outF8", "outCF1", "outc1"], "outFile2": ["outputfile2", "outputFile4", "againFile6", "againFile2", "againFile1", "outFiles4", "outLine6", "outDirectory2", "outFile4", "outfile4", "outDirectoryTwo", "outChannel6", "againLine2", "outputFileTwo", "againLine6", "outFiles2", "outFile6", "againFileTwo", "outfileTwo", "outfile2", "outputfileTwo", "outFilesTwo", "outChannel2", "outfile5", "outLineTwo", "outLine1", "againLineTwo", "outputfile5", "outputFile5", "outputFile2", "outFiles6", "outFiles1", "againLine1", "outFile5", "outFileTwo", "outChannelTwo", "outDirectory5", "outChannel1", "outFiles5", "outDirectory4", "outputfile4", "outLine2"], "outC2": ["outFTwo", "outCache2", "outCache4", "outFile4", "outBTwo", "againBTwo", "outFII", "outF4", "OutFII", "againC4", "OutF1", "outB4", "againC1", "againC2", "outF1", "outFileII", "OutF2", "againB4", "againCTwo", "outCTwo", "OutF4", "outC4", "OutC1", "outCacheII", "outCII", "againB2", "outCache1", "OutC2", "againB1", "outF2", "outB1", "OutC4", "outFileTwo", "OutCII", "outB2"], "fileSize": ["resourceSize", "FileSize", "FileSIZE", "FileMode", "fileAddress", "fileLength", "fileMode", "FileLength", " fileSIZE", "imageSIZE", "imageLength", "bufferMode", " fileLength", "bufferLength", "resourceAddress", " fileMode", "imageSize", " fileAddress", "bufferSize", "fileSIZE", "FileAddress", "resourceSIZE"], "totalNoDataRows": ["totalNoPageRows", "totalNoDataCrows", "totalNoPageLrows", "totalNoDataRrows", "totalNoDataCOWS", "totalNoPageLOWS", "totalNoDataChrows", "totalNoDataROWS", "totalNoDataChues", "totalNoDataCows", "totalNoDataCues", "totalNoDataLOWS", "totalNoDataLues", "totalNoDataLows", "totalNoPageLows", "totalNoDataChows", "totalNoPageLues", "totalNoPageRues", "totalNoPageROWS", "totalNoDataLrows", "totalNoPageRrows", "totalNoDataChOWS", "totalNoDataRues"], "mappedBuffer": ["mappingStream", "machedFile", "mapedStream", "mppedStream", "mactedbuffer", "machedBuff", "mppedBuffer", "mppedChannel", "mappedbuffer", "mippedURL", "machedURL", "mashedBuff", "mactedBuffer", "mappedURL", "MachedBuffer", "mppedBuff", "MappingFile", "mappedStream", "mappingFile", "MappedBuff", "MachedBuff", "MappingBuff", "mapedURL", "MachedURL", "mapedBuffer", "mippedBuff", "mashedChannel", "mappingChannel", "mapedBuff", "mappingBuff", "machedBuffer", "machedbuffer", "MappingBuffer", "MachedChannel", "MappingChannel", "MappedChannel", "Machedbuffer", "MappedFile", "mashedBuffer", "mapedFile", "mappingbuffer", "MachedFile", "Mappedbuffer", "mashedFile", "mappingBuffer", "mippedStream", "mappedChannel", "MappedStream", "mactedStream", "MappedURL", "mippedBuffer", "MappedBuffer", "mappedFile", "machedStream", "mactedBuff", "mappedBuff", "machedChannel", "MachedStream"], "startIndex": ["startSection", "stopRow", "endRow", "endIndex", "startingSection", "initInfo", "endInfo", "useindex", "startPoint", " startPoint", " startindex", "endCode", "StartPosition", "useIndex", "endPosition", "startInfo", "StartInfo", "startCode", "startingPoint", "stopindex", " startCode", "startingIndex", "startOffset", "startPosition", " startOffset", "startRow", " startSection", "Startindex", " startRow", "StartOffset", "endSection", " startInfo", "StartIndex", "initindex", "endPoint", "initIndex", "stopIndex", "startingPosition", "useInfo", "stopCode", " startPosition", "usePosition", "initOffset", "endindex", "startindex"], "count": ["index", "total", "order", "max", "sum", "i", "close", "id", "more", "self", "list", "add", "first", "ind", "c", "current", "number", "limit", "find", "child", "length", "pool", "all", "col", "thread", "time", "key", "weight", "follow", "loop", "part", "allow", "type", "cache", "old", "len", "counter", "other", "group", "Count", "size", "keep", "test", "start", "coll", "force", "name", "call", "found", "code", "depth"], "currentMovie": ["parentmovie", " currentPicture", "parentPicture", "currentlyPicture", "CurrentTheme", "currentFilm", " currentmovie", "reportedFilm", "reportedmovie", "thismovie", "defaultMovie", "reportedMovie", "reportedPicture", "validTheme", "currentTheme", "reportedTheme", "thisPicture", "CurrentFilm", "thisMovie", "CurrentMovie", "reportedMusic", "defaultMusic", "reportedImage", "currentlyMusic", "currentImage", "Currentmovie", "currentlyMovie", "validMovie", "currentMusic", " currentFilm", "defaultFilm", "currentmovie", "thisFilm", "validmovie", "validFilm", "currentPicture", " currentMusic", " currentImage", "parentMovie", "parentFilm", "defaultImage"], "movieName": ["movieInfo", "MovieId", "moneyFamily", "movieFamily", "voiceName", "moviename", "filmFamily", "moneyNumber", "voiceInfo", "camname", "Moviename", "MovieFamily", "MovieInfo", " movieInfo", "voicename", "movieId", "filmname", "camFamily", "filmName", "movieNumber", "camName", "MovieNumber", "filmNumber", " movieId", " movieFamily", "MovieName", "voiceId", " moviename", "moneyName"], "customer": [" customeri", "CustomER", "mixer", "Customers", " customER", "Customer", "mixER", "ustomor", "ustomer", "customeri", "Customeri", " customers", "mixor", "ustomER", "ustomers", "customers", "mixers", "Customor", "ustomeri", "customor", "customER"], "rating": ["string", "info", "writing", "id", "resource", "rolling", "reading", "rc", "http", "number", "packing", "rank", "alpha", "score", "Rating", "rate", "type", "reader", "value", "ranking", "r", "feature", "rice", "data", "ruby", "including", "rr", "writer", "ing", "radius", "ring", "url", "comment", "rates", "range", "missing", "padding", "rated", "attribute", "setting", "error", "rage", "RC"], "outBuf1": ["outBuff0", "outBuff1", "outDuff11", "outBuff2", "outBum1", "outFbuf91", "outDuf3", "outBbuf01", "outBbuf3", "outBuffCloud", "outCuff0", "outBaf8", "outBummerCloud", "outKuf2", "outBaftn", "outBbuff3", "outBafCloud", "outFbufOne", "outBuf91", "outBuf3", "outDuf11", "outBufn", "outFufOne", "outBuff11", "outBalth2", "outBaft3", "outBafOne", "outBbuff1", "outDuf1", "outBuf11", "outBaft11", "outBum01", "outKuf1", "outBalth1", "outDuffn", "outBiff1", "outDufn", "outCuf0", "outDuff1", "outBuffn", "outKbuff3", "outBummer1", "outFaf1", "outBufCloud", "outCuff1", "outCuffOne", "outBuff8", "outBaft1", "outBiff01", "outFafOne", "outBbufOne", "outBiff91", "outCufOne", "outFbuf1", "outFbuf01", "outBbuffOne", "outKuf3", "outDuff3", "outBuf0", "outBbuff0", "outBbuf2", "outKbuf3", "outKbuf2", "outKufOne", "outBbuf11", "outKbuf1", "outBummerOne", "outFuf01", "outBbufn", "outCuf1", "outBbuf1", "outBuffOne", "outBuff3", "outFufCloud", "outKbuff1", "outBuf01", "outBumOne", "outBbuf91", "outFuf1", "outFafCloud", "outKbuffOne", "outBaf1", "outKuf8", "outBalth3", "outBuf8", "outBum91", "outBaf3", "outKbuff8", "outFuf91", "outBufOne", "outBbuff8", "outBaf0", "outBiffOne"], "outBuf2": ["outBuff0", "outBuff1", "outFbuffTwo", "outBuf82", "outBuff4", "outBait8", "outBuff2", "outBoff8", "outBbufferB", "outFuf8", "outBbuffer12", "outWBuf200", "outFbuf2", "outBait200", "outBbuffer4", "outWBuff0", "outFufTwo", "outBuf12", "outBuber2", "outBuff12", "outBbuff200", "outFuf2", "outBuf200", "outBufB", "outWBuf4", "outBbuff4", "outBbuffer2", "outFbuf4", "outWBuf2", "outFbuff1", "outFufB", "outFbuff82", "outBbuf4", "outBufTwo", "outWBufTwo", "outBoffTwo", "outWBbuffTwo", "outBbuff1", "outBbufTwo", "outBum82", "outBaitTwo", "outBum2", "outFuf4", "outBuber8", "outFbuff2", "outWBuff8", "outWBuf0", "outBuff8", "outBuf4", "outWBbuff200", "outBuber82", "outBoff200", "outFbuff20", "outBbufB", "outBbuff20", "outBuffTwo", "outFuf82", "outFbufB", "outBbuff2", "outFbuf12", "outBuf0", "outWBuff4", "outBbuff0", "outBbuf2", "outBbuff82", "outBuffB", "outWBbuff2", "outWBuf8", "outBuf20", "outFbuff4", "outBait2", "outBbuffTwo", "outBum20", "outBait4", "outBbuf1", "outFuf12", "outWBuff2", "outFuf1", "outBoff2", "outBait0", "outBum8", "outBbuf12", "outFbuff8", "outBuf8", "outBuber20", "outWBbuff8", "outBbuff8", "outFuf20"], "endOfIndexFile": ["End\n", "endOfLinkFiles", "endofLinkFiles", "endofindexTime", "endedfile", "endofindexFiles", "endOfLinkTime", "endOfindexFile", "endOfImageTime", "endOfIndexfile", "endOfindexfile", "endfile", "endOfLinkDir", "endOfClientFiles", "endOfImageFiles", "endofIndexDir", "endOfIndexTime", "endOfLinkFile", "endOfImageFile", "endOfDatafile", "endofIndexFolder", "endOfClientFile", "endofindexFolder", "endOfImageFolder", "endOfDataDir", "endOfClientTime", " endfile", "endOfindexFolder", "endofIndexFiles", "endOfClientDir", "ended\n", "endofLinkDir", "endofLinkTime", "Endfile", "endOfindexFiles", "endOfIndexFiles", "endOfDataFile", "endofIndexTime", "endofLinkFile", "endOfindexTime", "endOfDataTime", "endOfIndexDir", "endOfIndexFolder", " end\n", "endOfindexDir", "endOfLinkfile", "end\n", "endofIndexFile", "endofindexFile"]}}
{"id1": "3806532", "id2": "8490297", "code1": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"createNew": ["writeRemote", " createnew", "requestFile", "requestnew", "writeFile", "createRemote", "createnew", "requestNew", " createRemote", "writenew", " createFile", "createFile", "requestRemote", "writeNew"], "name": ["x", "connection", "ame", "ext", "data", "self", "type", "space", "base", "part", "time", "size", "domain", "content", "old", "alias", "e", "key", "address", "this", "source", "common", "value", "child", "request", "path", "parent", "filename", "url", "default", "names", "Name", "server", "n", "uri", "null", "code", "file", "id", "prefix", "word", "action", "resource", "host", "named", "none", "string", "NAME", "username"], "in": ["reader", "bin", "connection", "isin", "login", "f", "data", "type", "ins", "pin", "cin", "info", "min", "In", "inside", "conn", "part", "inner", "size", "win", "r", "work", "IN", "plus", "pull", " IN", "ini", "i", "source", "image", "inc", "path", "exec", "url", "config", "read", "pass", "thin", "id", "index", "len", "resource", "input", "record", "con", "diff"], "length": ["offset", "lock", "sequence", "type", "Length", "body", "info", "load", "timeout", "ength", "time", "size", "content", "capacity", "address", "buffer", "count", "padding", "limit", "path", "filename", "level", "width", "number", "duration", "id", "len", "string"], "contentType": ["ContentLength", "contentToken", " contentToken", "acceptToken", "acceptType", "ContentType", " contentLength", " contenttype", "contenttype", "Contenttype", "accepttype", "acceptLength", "ContentToken", "contentLength"], "dest": ["cdn", "trip", "data", "sup", "opt", "loc", "later", "down", " destination", "cont", "comb", "destroy", "gen", "proc", "output", "txt", "img", "done", "fn", "coord", "dist", "temp", "this", "dc", "d", "source", "ctx", "uc", "project", "path", "asc", "parent", " Dest", "cl", "default", "config", "store", "null", "route", "flat", "func", "folder", "wb", "up", "file", "src", "Dest", "resource", "target", "dir", "home", "de", "desc", "obj", "through", "tmp", "rest"], "out": ["ext", "data", "version", "channel", "pool", "outs", "loop", "b", "cmd", "err", "flow", "off", "o", "exec", "url", "null", "io", "exp", "point", "socket", "session", "log", "page", "conn", "cache", "output", "plus", "key", "client", "call", "init", "parent", "up", "home", "gin", "bit", "x", "job", "qa", "f", "one", "copy", "part", "all", "line", "writer", "temp", "lib", "image", "inc", "n", "raw", "Out", "obj", "connection", "bin", "extra", "array", "sync", "ex", "base", "again", "password", "OUT", "child", "v", "view", "pass", "file", "diff", "window"]}}
{"id1": "1357662", "id2": "9347451", "code1": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyChannelFile", " copyfileTO", " copyFileFile", "copyChannelFrom", "copyfileTo", "copyFileTO", " copyFileTO", " copyfileFrom", "copyfileTO", "copyfileFrom", "copyFilesFile", "copyChannelTo", "copyFilesTO", "copyFileFile", "copyFileFrom", "copyChannelTO", " copyfileTo", "copyfileFile", "copyFilesFrom", " copyfileFile", "copyFilesTo", " copyFileFrom"], "destination": ["destinations", " Destination", "distined", " destinator", "configinations", " destribution", "distinations", "destribution", "sourceinations", "Destinations", "destinator", "Destined", "destined", "separinator", " Destribution", "distruction", "configinated", " destined", "Destinator", "Destination", "targetruction", "destinated", "sourceinated", "destinate", "distinate", "targetinations", "targetinate", " Destinator", "destruction", "separination", "separinations", "Destribution", "sourceination", " destruction", "configination", "configinator", "sourceinator", "separinated", " destinate", "distination", "distinator", " destinations", "targetination"], "srcChannel": ["srcChan", "srcConnection", "srcchannel", "sourceContext", "destchannel", "destConnection", "rcContext", "rcChan", "destChan", "srcContext", " srcContext", " srcConnection", " srcChan", "sourcechannel", " srcchannel", "rcchannel", "rcChannel", "sourceChannel", "rcConnection", "sourceChan", "sourceConnection"], "destChannel": ["srcChan", "restChan", "srcConnection", "srcchannel", " destchannel", "descButton", "srcButton", "DestChan", "destchannel", " destChan", "destConnection", " destConnection", "restchannel", "DestConnection", "destChan", "sourcechannel", " destButton", "descchannel", "restChannel", "Destchannel", "sourceChannel", "destButton", "DestChannel", "descChannel", "sourceChan", "sourceConnection"]}}
{"id1": "11616716", "id2": "22993368", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResponseAsReader", "getCMSResultAsFile", "getCMSResultInFile", "getCMSResultInSteam", "getCMSResultWithSteam", "getCMSResponseAsSteam", "getCMSResponseasFile", "getCMSResultasFile", "getCMSResultasStream", "getCMSResponseasSteam", "getCMSResponseasReader", "getCMSResultWithFile", "getCMSResultWithStream", "getCMSResultasSteam", "getCMSResultasReader", "getCMSResponseasStream", "getCMSResultAsReader", "getCMSResultWithReader", "getCMSResultInStream", "getCMSResultAsSteam", "getCMSResultInReader", "getCMSResponseAsFile", "getCMSResponseAsStream"], "rqlQuery": ["srqlQuery", "rqlQu", "riliQuery", "riliQu", "srqlQ", " rqlMethod", "rsqlQuery", "rqlMethod", "rQLMethod", "srqlquery", "riliQ", "rQLQu", " rqlQu", "rQLQ", "srQLQu", "rQLquery", " rsqlQuery", "rsqlQu", "srQLQuery", "riliquery", "rQLQuery", "rSQLQuery", "rsqlMethod", "rsqlquery", " rsqlMethod", " rqlquery", "rSQLQu", "rqlquery", " rsqlQu", "srQLQ", " rsqlquery", "srQLquery", "rSQLquery", "rqlQ", "rSQLMethod", "srqlQu", "rsqlQ"], "osr": ["otsrm", "OSrt", "cosrt", "cosrr", "otsr", " ospr", "osssr", "osfr", "losr", "losrr", " oscr", "oswer", "opsR", "opsrar", " osrr", "osrw", "osrs", "otspr", " ossr", "bosrar", "osscr", "usrt", "oserr", "osrt", " osfr", "opsr", "boswer", "osspr", "ossr", "iospr", "osrr", "userr", "osserr", "ysrar", "bosr", "iosr", "obswer", "cosr", "obsrar", "ossrr", "osrar", "opswer", "losfr", "ossrt", "usrw", "ospr", "usrr", "ossrw", "ysr", "ossrm", "losrt", "obsr", "usrs", "OSrr", "ossrs", "ysrt", " osrar", "OSr", "osR", "OSerr", "iosrs", "otssr", " osrt", "iosrw", "obsR", "usr", " osrm", "cosfr", "bosR", "ossrar", "uspr", "oscr", "osrm", "yscr"], "url": ["connection", "open", "sl", "f", "org", "fl", "channel", "socket", "web", "base", "ssl", "ll", "ls", "lc", "blog", "b", "page", "l", "r", "client", "Url", "URL", "source", "path", "config", "nl", "uri", "server", "http", "file", "resource", "www", "host", "rl", "string", "fb", "ob"], "conn": ["connection", "nt", "open", "cur", "cb", "f", "loc", "cn", "rn", "reg", "org", "nc", "oss", "ca", "ct", "sync", "p", "enc", "en", "ec", "ann", "pc", "rc", "ssl", "lc", "pr", "wrapper", "cr", "l", "fn", "err", "client", "dc", "ci", "db", "connect", "ch", "ctx", "h", "exec", "attr", "conv", "n", "server", "rt", "http", "c", "Conn", "net", "coll", "con", "cp", "Connection", "col", "act"]}}
{"id1": "2668853", "id2": "8932510", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFiletoFiles", "decodeFileAsStream", "decodeString2file", "decodeFile2Stream", "decodeFiletoFile", "decodeFileToStream", "decodeFiletofile", "decodeFileAsFiles", "decodeFileTofile", "decodeStringToFile", "decodeStringTofile", "decodeStringToStream", "decodeFileAsFile", "decodeString2Stream", "decodeFile2File", "decodeString2File", "decodeFileAsfile", "decodeFiletoStream", "decodeFileToFiles", "decodeFile2file", "decodeStringToFiles", "decodeString2Files", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", "inputfp", " inFile", "inputFile", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "minfilename", "minFile", "minfp", "inputfilename", "infilename"], "outfile": ["infp", "outfull", "outputfile", " outfull", "outfilename", "outFile", " outFile", "infolder", "outputfolder", " outfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "outputfull", "Outfull", "Outfolder", "OutFile", "Outfile", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "i", "input", "inas", "ex", "ini", "gin", "ic", "con", "inner", "socket", "as", "ins", "s", "bin", "is", "reader", "source", "up", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "e", "image", "re", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ex", "output", "copy", "outer", "op", "lock", "on", "net", "OUT", "socket", "as", "inner", "outs", "o", "s", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "lib", "up", "target", "other", "inc", "work", "file", "conn", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "exp", "In", "ext", "b", "obj", "err", "error", "point"], "buffer": ["address", "base", "input", "Buffer", "uffer", "resource", "pause", "border", "server", "feed", "slice", "limit", "result", "length", "bin", "memory", "queue", "offset", "iter", "split", "reader", "source", "binary", "seed", "buff", "value", "buf", "wave", "data", "size", "bb", "null", "row", "bytes", "layer", "flush", "url", "shape", "b", "reference", "padding", "pad", "transfer", "batch"], "read": ["index", "Read", " receive", " r", "run", "ride", " get", "open", " copy", "get", "lex", " send", " check", "id", "feed", "add", "ind", "end", "find", " reach", "next", "sync", "use", "load", " sleep", "r", "work", "fill", "exec", "skip", "connect", " request", "play", " use", "reading", " parse", "limit", "se", "length", "write", "line", "ad", "sleep", "iter", "allow", "reader", " Read", "start", "tell", " load", "wait", " write", "input", "copy", " connect", "current", "reads", "pass", "select", " ride", "seek", "inc", " find", "check", "x", "size", " reader", "send", "k", "parse", "count", "READ"], "success": ["roll", "accept", "job", "response", "rolling", "ok", "continue", "ceed", "results", "warning", "better", "yes", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "selected", "default", "data", "safe", "null", "cess", "danger", "complete", "again", "status", " successful", "full", "correct", "good", "Success", "successful", "successfully", "rolled", "found", " succ", "zero", "error", "fast", "first", "winner", "initial"]}}
{"id1": "18097962", "id2": "5148212", "code1": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 0, "substitutes": {"getVersion": ["parseVersions", " getVersions", "parseVersion", "getVersions", "showRelease", "parseVERSION", "parseRelease", " getVERSION", "showVersion", "showVersions", "showVERSION", "getRelease", "getVERSION", " getRelease"], "version": ["feature", "ver", "name", "ception", "type", "versions", "python", "language", "install", "VERSION", "array", "latest", "info", "release", "status", "position", "model", "description", "format", "text", "output", "vert", "instance", "section", "content", "bug", "line", "vision", "secret", "comment", "source", "build", "image", "value", "project", "driver", "object", "v", "update", "server", "unit", "Version", "message", "action", "resource", "result", "cover", "string", "option", "element"], "version_url": ["versioningfile", "versioningurl", "version_URL", "version_feed", "ver_url", "versioningUrl", "version_file", " version_feed", "ver_Url", "ver_file", " version_str", "versioningresource", "ver_resource", "version_str", "version_resource", "version_Url", " version_URL"], "url": ["connection", "open", "sl", "f", "fl", "channel", "socket", "stream", "web", "download", "ll", "ssl", "base", "bb", "log", "ls", "conn", "page", "zip", "l", "fr", "client", "Url", "URL", "api", "cl", "server", "uri", "http", "c", "file", "www", "bel", "host", "resource", "rl"], "con": ["connection", "bin", "open", "cur", "login", "f", "cn", "cos", "channel", "socket", "un", "ins", " conn", "stream", "enc", "pub", "en", "pc", "plain", "log", "rc", "conn", "b", "win", "l", "IN", "Con", "ran", "init", "inc", "ch", "CON", "connect", "uc", "exec", "close", "conv", "Conn", "c", "http", "co", "coll", "ln", "Connection", "fc"], "in": ["reader", "bin", "connection", "isin", "login", "f", "data", "fac", "s", "ins", "hel", "pin", "stream", "cin", "ex", "In", "rec", "ssl", "kin", "is", "conn", "b", "inner", "again", "rin", "r", "din", "IN", "ini", "i", "init", "inc", "nin", "inn", "c", "file", "as", "impl", "lin", "on", "input", "out", "gin"], "inputLine": ["outputLine", "inputFile", "InputPart", " inputStream", "inputValue", "outputStream", " inputValue", "tempStream", "outputFile", "outputline", "inputL", "templine", " inputline", "outputPart", " inputPart", "InputLine", "InputValue", "rawLine", "tempLine", " inputFile", "InputL", " inputL", "Inputline", "inputStream", "InputFile", "rawline", "inputline", "rawValue", "inputPart", "rawL"]}}
{"id1": "1362", "id2": "10759917", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["ubblingsort", "bubbleOrder", "ubbleCompare", "ubbleOrder", "ubblingCompare", "ubblesort", "bubblessort", "bubblingOrder", "bubblerOrder", "bubblerCompare", "bubbleCompare", "bubblesCompare", "ubbleSort", "ubblingOrder", "bubblersort", "bubblingsort", "bubblesSort", "bubblingSort", "bubblesort", "bubblerSort", "ubblingSort", "bubblesOrder", "bubblingCompare"], "a": ["at", "m", "p", "array", "u", "oa", "A", "va", "tta", "e", "b", "aw", "an", "empty", "data", "all", "f", "area", "result", "apps", "aaa", "ga", "o", "index", "d", "ae", "aj", "s", "ack", "access", "l", "another", "work", "ad", "ata", "any", "na", "ba", "ac", "sa", "address", "au", "c", "alpha", "ma", "sup", "aux", "list", "am", "la", "ama", "ans", "auto", "as", "something", "ab", "abs", "active", "aa", "img"], "swapped": [" swaped", "rewaped", "waped", "swoped", "rewapping", "Swaped", "rewoped", "flapping", "floped", "rewaps", " swap", "swap", "rewapped", "wapping", "rewap", "swapping", "flap", "Swapped", "flapped", "swaped", " swapping", "wapped", " swaps", "swaps", "wap", "waps", "Swoped", "Swapping", "Swap"], "i": ["k", "m", "p", "u", "uri", "e", "module", "j", "anti", "b", "ki", "fi", "init", "ori", "io", "info", "adi", "si", "ie", "in", "f", "ni", "it", "iv", "index", "d", "ci", "iu", "h", "oi", "key", "uni", "mini", "api", "y", "ami", "multi", "li", "l", "mi", "ip", "pi", "hi", "xi", "di", "eni", "ind", "id", "ti", "v", "gi", "start", "sup", "ix", "I", "ai", "next", "ini", "ui", "ii", "x", "bi", "qi", "ri"], "tmp": ["bb", "m", "pad", "txt", "j", "append", "dest", "b", "mp", "cmp", "prev", "st", "tc", "ie", "part", "f", "stuff", "area", "tt", "opp", "test", "vt", "temp", "addr", "foo", "kk", " ff", "amp", "v", "tv", "obj", "alpha", "sup", "xxx", "t", "angle", "pre", "mmm", "qq", "yy", "x", "front", "nb", "emp", "pp", "p"]}}
{"id1": "4938100", "id2": "3745402", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"sha1": ["hashOne", "SHAOne", "shaOne", "sha256", " SHA1", " SHAOne", " SHA256", "hash1", "hash64", "SHA256", "SHA64", " SHA64", "sha64", "hash256", "SHA1"], "text": ["image", "font", "template", "bytes", " Text", "key", "output", "class", "object", "pattern", "input", "Text", "version", "code", "format", "content", "connection", "path", "message", "TEXT", "ext", "editor", "word", "translation", "value", "EXT", "str", "url", "letter", "this", "data", " TEXT", "struct", "secret", "token", "test", "number", "contract", "name", "password", "string", "source", "config", "hex", "txt"], "UnsupportedEncodingException": ["UnsupportedEncodedception", "UnsupportedEncodingception", "UnsupportedEncodingEx", "UnsupportedEncoderception", "UnsupportedEncodedException", "UnsupportedEncasingception", "UnsupportedEncasingEx", "UnsupportedEncasingException", "UnsupportedEncodedEx", "UnsupportedEncoderException", "UnsupportedEncoderEx"], "md": ["mac", "mm", "mo", "ind", "m", "Cmd", "dig", "bf", "mad", "map", "ad", "mn", "pd", "metadata", "valid", "ma", "cd", "code", "od", "rm", "editor", "message", "mb", "amd", "nm", "df", "wd", "gd", "mand", "bd", "sm", "mg", "mode", "dm", "data", "pm", "sha", "mt", "MD", "mp", "di", "me", "mc", "mod", "hd", "mag", "d", "body", "vd", "ld", "ms", "meta", "hash", "am", "cmd", "dd", " MD"], "sha1hash": ["sha4hash", "sha256sha", "sha5sha", "sha4hex", "sha001hash", "sha2address", "sha41sum", "SHA1check", "wa3dash", "sha3sum", "sha1dash", "SHA2sha", "wa3sum", "sha5Hash", "sha91address", "sha2hash", "SHA2hash", "sha4dash", "sha1Hash", "sha3hex", "wa1hash", "SHA1hash", "SHA2check", "wa1dash", "sha4sum", "sha256Hash", "sha91hash", "sha1address", "wa3hex", "sha5sum", "SHA2Hash", "sha001dash", "sha3dash", "SHA1sha", "SHA1sum", "sha41address", "sha001sum", "sha2sha", "sha91sum", "sha1check", "SHA1Hash", "sha001hex", "wa1sum", "wa1hex", "sha256hash", "sha41hash", "sha91check", "sha2sum", "sha2Hash", "sha256sum", "sha2check", "SHA2sum", "sha1sum", "sha41check", "sha3hash", "sha1hex", "wa3hash", "sha1sha", "SHA2address", "SHA1address", "sha5hash"]}}
{"id1": "20267500", "id2": "13657103", "code1": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 0, "substitutes": {"getWavFromURL": ["getWavFromurl", "getWavefromUR", "getWavForUR", "getWavefromUrl", "getWavefromURL", "getWavFromUR", "getWavfromUrl", "getWaveFromUR", "getWavForUrl", "getWaveFromUrl", "getWaveFromurl", "getWavForurl", "getWavfromURL", "getWaveFromURL", "getWavfromurl", "getWavefromurl", "getWavFromUrl", "getWavForURL", "getWavfromUR"], "urlstr": ["fileStr", "httpStr", "urlStr", "lStr", "urlSTR", "lSTR", " urlStr", "httpstring", "filestring", "urlpath", "llstr", " urlpath", "urlstring", "filepath", "llSTR", "lstr", "lstring", "llStr", "filestr", "httpstr", " urlSTR", "httppath", "llstring", " urlstring"], "url": ["lc", "cl", "str", "ob", "e", "feed", "URL", "cur", "path", "log", "sl", "fl", "Url", "host", "oc", "string", "conn", "u", "li", "ls", "image", "build", "org", "ssl", "connection", "b", "ll", "www", "loc", "ur", "ul", "uri", "lr", "api", "resource", "http", "l", "page", "source", "file", "server", "ch", "coll", "f", "rl", "plug"], "ais": ["mos", "aaa", " ads", "ai", "audio", "ays", "bb", "ois", "ami", "aos", "rs", "ia", "ws", "xml", "oci", "ay", " tapes", " arra", "cci", "asi", "ls", "ahi", "waves", "ci", "ios", "sa", " sax", "ians", "acs", "ava", "avi", " au", " audi", " audio", "aa", "ds", "ae", "plays", "Audio", " ado", "is", "oi", "aus", "audi", "ac", "aud", "rss", " ain", "ss", "as", "gae", "au", "ait", "ras"], "c": ["cm", "bc", "cf", "cl", "mc", "lc", "client", "e", "C", "conn", "cr", "cp", "u", "cc", "ci", "m", "ct", "ec", "a", "connection", "cu", "b", "cs", "enc", "fc", "co", "cd", "dc", "api", "p", "http", "l", "channel", "ch", "cn", "coll", "pc", "con", "nc", "ac", "ctrl", "cb", "f", "cmp"], "stream": ["cm", "uc", "audio", "reader", "cache", "w", "output", "e", "feed", "zip", "io", "path", "engine", "sl", "input", "host", "string", "context", "u", "s", "Stream", "m", "connection", "b", "object", "video", "fc", "p", "uu", "h", "form", "l", "in", "data", "channel", "source", "server", "d", "src", "coll", "sw", "f"]}}
{"id1": "442381", "id2": "14324112", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doVersioncheck", "doReleaseWork", "doReleasecheck", "doVersionTest", " doReleaseTest", "doReleaseCheck", " doReleaseCheck", "doversionTest", "doVERSIONTest", " doBuildcheck", "doReleaseTest", "doVersioncheck", " doBuildTest", " doVersionWork", "doversioncheck", "doVERSIONCheck", "doBuildWork", " doReleasecheck", "doBuildCheck", "doVersionWork", "doVERSIONcheck", "doBuildTest", " doBuildWork", "doversionCheck", " doVersionTest", " doBuildCheck", "doVERSIONWork", "doBuildcheck"], "view": ["form", "edit", "style", "app", "buffer", "cache", "widget", "port", "out", "client", "session", "cell", "update", "config", "this", "model", "View", "page", "event", "show", "e", "use", "gui", "input", "l", "image", "screen", "box", "q", "VIEW", "object", "comment", "self", "accept", "window", "display", "server", "change", "sel", "ui", "body", "see", "vis", "div", "lock", "views", "gu", "el", "full", "block", "html", "request", "row", "layout", "reader", "v", "can", "http"], "url": ["source", "buffer", "uri", "browser", "client", "path", "Url", "f", "bb", "input", "l", "socket", "image", "build", "blog", "loader", "web", "service", "resource", "open", "hub", "base", "log", "bel", "server", "host", "URL", "zip", "sl", "address", "string", "connection", "channel", "stream", "ll", "file", "lib", "ssl", "ob", "user", "http"], "in": ["source", "as", "init", "buffer", "gin", "inn", "out", "inner", "ac", "s", "i", "input", "socket", "sin", "IN", "data", "ini", "win", "con", "resource", "binary", "n", "isin", "b", "is", "nin", "ins", "cin", "stream", "lin", "In", "inc", "rin", "file", "login", "reader", "bis", "din"], "bin": ["init", "ln", "buffer", "inn", "gin", "out", "browser", "pin", "inner", "bb", "input", "socket", "border", "sin", "inline", "IN", "abi", "data", "loader", "win", "record", "con", "binary", "bot", "bi", "log", "b", "bn", "fin", "nb", "body", "lock", "cin", "lin", "spin", "ruby", "file", "kin", "lib", "part", "oin", "reader", "din", "run"], "line": ["text", "source", "message", "lf", "style", "look", "Line", "lines", "str", "parse", "cell", "day", "load", "lo", "home", "model", "page", "pass", "link", "e", "i", "word", "l", "inline", "data", "definition", "nl", "object", "comment", "ip", "up", "valid", "base", "name", "log", "b", "lc", "job", "pe", "band", "code", "ge", "split", "letter", "string", "rule", "LINE", "el", "lin", "cl", "layer", "ine", "block", "file", "part", "row", "key", "non", "entry", "end", "le", "unit", "site", "id", "no"], "develBuild": ["deployBuild", "develBuilder", "dewardbuild", "deployBuilt", "DEvelbuild", "dewardBuilder", "desvenRun", "DEvelBuilt", "desvenBuilder", "deviousBuild", "desvelbuild", "desvelBuilder", "deVELRun", "desvelRun", "deVELBuilder", "devenBuild", "develbuild", "desvelBuild", "deVELbuild", "develRun", "desvenRelease", "DEvelBuild", "deployBuilder", "devenBuilder", "develRelease", "desvelBuilt", "deelRelease", "DEVELBuilt", "deployRun", "dellBuild", "dewardBuild", "dewardBuilt", "devenbuild", "DEVELBuilder", "desvenbuild", "dellRun", "DEVELBuild", "DEvelBuilder", "deelBuilder", "dellBuilder", "desvenBuild", "DEVELbuild", "develBuilt", "desvenBuilt", "deviousbuild", "devenBuilt", "deelBuild", "deVELBuild", "devenRun", "deelRun", "dellRelease", "deviousBuilt", "deVELBuilt", "desvelRelease", "devenRelease", "deploybuild"], "stableBuild": ["basebuild", "latestBuilder", "stablebuild", "compatibleBuild", "latestbuild", "prettyBuilder", "stableVersion", "validBuilder", "securebuild", "prettybuild", "latestBuild", "compatibleBuilder", "baseBuild", "secureBuild", "compatiblebuild", "secureBuilder", "stableBuilder", "validBuild", " stablebuild", " stableVersion", "staticbuild", "validbuild", " stableBuilder", "baseVersion", "prettyVersion", "prettyBuild", "staticBuild", "baseBuilder", "staticBuilder"]}}
{"id1": "2461169", "id2": "3430784", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2Stream", "decodeFile2Stream", "decodeFileToString", "decodeFileToStream", "decodeFile2File", "decodeFileAsFile", "decodeFile2String", "decodeFileFromString", "decodeString2File", "decodeFileAsStream", "decodeStringToFile", "decodeFileFromStream", "decodeStringToStream", "decodeString2Files", "decodeString2String", "decodeFileToFiles", "decodeFileAsFiles", "decodeFileAsString", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeStringToFiles", "decodeStringToString"], "infile": ["infp", " infiles", "InFile", "inputfiles", "minstream", " inbase", "instream", "outfp", "inbase", "outfilename", "inFile", " inFile", "minbase", "inputfp", "infiles", "Infile", "Instream", "infilename", "inputfilename", "minFile", "inputfile", "Inbase", "outfiles", " instream", " infp", "minfile", " infilename"], "outfile": [" outfilename", " outpath", "outputfilename", " outfolder", "outputfolder", "inputFile", "inputdatabase", " outFile", "outfilename", "inFile", "outputFile", "outpath", "outdatabase", "outputdatabase", "inputpath", "outfolder", "infilename", "inputfile", "outputpath", "infolder", "outFile", " outdatabase", "outputfile"], "in": ["into", "m", "ins", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "log", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "channel", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "pass", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "obj", "err", "name", "up", "net", "ou", "OUT", "or", "again", "line", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "data", "Buffer", "raw", "channel", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "base", "queue", "slice", "address", "cache", "bin", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "r", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "func", "follow", " Success", "model", "status", "winner", "result", "primary", "fail", "valid", "positive", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "13122204", "id2": "8788371", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnzipModel", "unzipmodel", "unarchiveProject", "Unzipmodel", "unpatchmodel", "unarchivemodel", "unarchiveModel", "UnarchiveFile", "UnarchiveProject", "unpatchFile", "UnzipFile", "unpatchProject", "unzipFile", "unarchiveFile", "UnzipProject", "unzipProject", "unpackmodel", "UnarchiveModel", "unpackProject", "unpackModel", "unpackFile", "unpatchModel", "Unarchivemodel"], "filename": ["fp", "url", "FILE", "title", "fil", "kl", "model", "path", "folder", "utf", "nil", "location", "string", "name", "database", "files", "jet", "username", "SourceFile", "File", "directory", "loc", "fits", "uri", "fd", "l", "source", "fn", "file", "download", "src", "bf", "txt", "Filename", "f", "il", "module"], "tempdir": ["tmpdirectory", "Tempdirectory", " tempfolder", "tmpDir", " tempDir", "temdir", "TempDir", "temfolder", "tempDir", "temppath", "tmpfolder", "tempfolder", "temDir", "Tempdir", "tmpDIR", " tempdirectory", "TempDIR", "tmppath", " temppath", "Tempfolder", "tempDIR", "temdirectory", "tempdirectory", " tempDIR", "tmpdir", "tempath"], "dest": ["rest", "test", "result", "de", "cont", "st", "sup", "prop", "gen", "delete", "builder", "output", "transfer", "tmp", "zip", "exit", "comb", "proc", "folder", "log", "walk", "default", "export", "target", "flat", "session", "ui", "obj", "inner", "tar", "std", "Dest", "transform", "dat", "desc", "cdn", "handler", "loc", "walker", "nt", "sync", "wb", "done", "dc", "store", "di", "source", "file", "usr", "dist", "dir", "src", "die", "later", "home", "trans", "opt", "txt", " Dest", "temp"], "fis": ["filebis", " fiss", "flisa", "fid", "flis", "liss", "fliss", "fileisa", "fsisa", "fsbis", " fi", "fileis", "li", "lid", "fileid", "fsiss", " fid", "fsis", "filei", "lis", "fbis", "fiss", "fileiss", "fi", "flbis", "fisa"], "BUFFER": ["UPFF", " BUVER", "SAPER", "BUUCK", "BUFER", "BUFF", "CUVER", "TAPER", "BOFFER", "BOPER", "CUUCK", "SAUCK", "CUFFER", "TAVER", "UPFFER", " BUFER", " BUVEN", "CUVEN", "CUPER", " BUFIX", "BOFIX", "CUFF", "SAFFER", "TAFFER", "MAFIX", " BUFF", "MAPER", "BUPER", " BUUCK", "BUFIX", "UPVEN", "BUVEN", "MAFER", "MAFFER", "BOFER", "SAVER", " BUPER", "UPVER", "BUVER", "TAUCK"], "zis": ["zipis", " zists", " zbis", "zipisa", " zisa", "xiss", "diss", " zii", "zins", "Zas", "xis", " zos", "zin", "zii", "xi", "Zisa", " ziss", "zas", " zIS", "yis", "zipIS", "zipas", "zos", "zists", "Zins", "xii", "yin", " zin", "jos", "yIS", "jists", "zi", "Zis", "xos", "jis", "zipins", "dis", "zIS", "yisa", "xists", "zbis", "dbis", "zisa", " zas", "xbis", "dii", " zins", "ji", "zipin", " zi", "ziss"], "entry": ["de", "result", "lc", "reader", "enter", "e", "id", "zip", "feed", "inc", "ace", "ou", "valid", "cel", "je", "ge", "row", "name", "end", "li", "inner", "archive", "image", "next", "spec", "si", "or", "element", "ie", "info", "way", "pe", "ent", "connection", "Entry", "nt", "porter", "her", "pack", "la", "iterator", "jo", "rc", "line", "file", "ry", "se", "match", "source", "server", "ident", "ries", "cat", "part", "record", "ce", "module"], "count": ["base", "cache", "allow", "e", "use", "id", "feed", "current", "_", "Count", "log", "val", "index", "start", "length", "name", "max", "time", "end", "core", "ind", "c", "write", "len", "next", "code", "read", "type", "writer", "i", "counter", "b", "number", "list", "weight", "cond", "buffer", "iter", "add", "key", "line", "in", "file", "last", "low", "pos", "limit", "coll", "part", "sum", "size", "f"], "data": ["result", "base", "reader", "str", "id", "feed", "load", "raw", "DATA", "index", "input", "start", "length", "name", "image", "next", "write", "size", "len", "read", "format", "a", "info", "batch", "dat", "number", "body", "block", "message", "pack", "buffer", "media", "array", "bytes", "alpha", "content", "la", "shift", "pos", "d", "value", "record", "zero"], "fos": ["foes", "dfoes", "fOS", "dfoos", "afos", " foos", "xoes", "afOS", "bis", "xoos", "bOS", " fOS", "dfos", " fops", "afis", "bos", "dfops", "bops", "xos", "fops", " foes", "xops", "afops", "foos"]}}
{"id1": "13563706", "id2": "13666876", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", "handleGET", "handleget", "doget", "didget", "doPut", "handlePut", " doget", " doGET", " doPut", "didGet", "didPut", "doGET", "didGET"], "request": ["attribute", "req", "p", "url", "frame", "resource", "report", "server", "message", "image", "complete", "view", "Response", "connection", "remote", "event", "method", "data", "info", "application", "model", "document", "result", "input", "Request", "type", "xml", "instance", "create", "QUEST", "config", "client", "user", "queue", "object", "string", "query", "current", "buffer"], "response": ["resp", " Response", "description", "res", "writer", "subject", "respond", "report", "resource", "server", "message", "image", "view", "Response", "connection", "body", "reason", "output", "model", "application", "status", "result", "site", "document", "reply", "index", "error", "results", "api", "client", "header", "object", "wa", "re", "service", "location", "pool", "json", "query", "collection", "http", "feed", "onse"], "selectedPage": [" selectedHour", "namedpage", "selectedLine", "selectionFile", " selectedAction", "namedPage", "namedFile", "selectedButton", "lectedpage", "lectedFile", " selectedItem", "lectedLine", "selectionpage", "namedLine", "selectedpage", " selectedLine", "lectedSite", "lectedAction", "electedPage", " selectedFile", "electedLine", "selectedFile", "selectionItem", " selectedButton", "lectedPage", "electedpage", "lectedItem", "selectionAction", "namedSite", " selectedSite", "selectionButton", "electedButton", "lectedButton", "lectedHour", "selectedAction", " selectedpage", "selectedSite", "selectionPage", "selectedItem", "selectionLine", "selectionHour", "selectedHour"], "page": ["menu", "image", "parent", "html", "view", "pg", "profile", "row", "queue", "cache", "po", "per", "pp", "photo", "Page", "unit", "resource", "message", "server", "connection", "port", "display", "model", "result", "type", "plugin", "record", "article", "point", "change", "layout", "handler", "age", "proxy", "url", "channel", "site", "route", "rule", "me", "instance", "section", "user", "node", "account", "location", "block", "peer", "module", "pl", "item", "ge", "project", "je", "child", "phone", "document", "f", "client", "ice", "ip", "number", "position", "address", "language", " Page", "sp", "pool", "office", "fe", "p"], "portalRequest": ["portortalRequest", "PortortalUser", "portpalResponse", "portelQuery", "portelCommand", "portalAccess", "PortortalEvent", "portALEvent", "portugalEvent", "portallResponse", "portalResponse", "portugalUser", "portALUser", "portortalServer", " portialRequest", "portialQuery", "portbalQuery", "portallingPage", "portalPage", "PortortalAccess", "PortortalCommand", "portortalUser", " portialResponse", "portugalServer", "portialRequest", "PortalEvent", " portialQuery", "portALRequest", "portelRequest", "PortortalResponse", "portalEvent", "portpalRequest", "portALResponse", " portalQuery", "portbalResponse", "PortalOrder", "PortalCommand", "portailRequest", "portbalRequest", "PortalAccess", "portelResponse", "portugalResponse", "portallingResponse", "PortortalServer", "portallUser", "portailOrder", "portugalOrder", " portalResponse", " portalPage", "portialPage", "portallingRequest", "portalUser", " portialPage", "portpalPage", "portalServer", "portallingAccess", "portailUser", "PortortalRequest", "portallServer", "portortalOrder", "portelPage", "portortalPage", "PortalRequest", "portortalResponse", "portallRequest", "portalQuery", "PortalResponse", "PortortalOrder", "portortalEvent", "portbalPage", "portialResponse", "PortalUser", "portallingCommand", "PortalServer", "PortortalPage", "portugalRequest", "portalOrder", "portailResponse", "portortalCommand", "portortalAccess", "portpalAccess", "portalCommand", "PortalPage"], "pageProp": ["projectProp", "pluginPro", "projectProperty", "PageProp", "parentProperty", "pageObj", "pagePro", "agePro", "projectprop", "parentProp", "peerStr", "pluginProperty", "pluginprop", "PagePro", "parentObj", "pageprop", "resourceProperty", "resourceProp", " pageProperty", " pageObj", "PageProperty", "ageProperty", "pageProperty", "Pageprop", "ageprop", "PageStr", "peerProp", "resourcePro", "pluginProp", "pageStr", "ageProp", "projectPro", "peerProperty", "PageObj", " pagePro", "parentPro", " pageStr", "peerPro", "resourceprop"], "possiblePage": ["possibilityPage", "possibleItem", "puredPage", "permanentpage", "PossiblyPage", "possiblyGroup", "pablePages", "PossiblyItem", "PossibilityLine", "patchingGroup", "patchingpage", "possiblyLine", "Possiblepage", "patchedPage", "permanentLine", "PossibleGroup", "patchedOrder", "possiblePages", "possibleGroup", "patchingPage", "puredGroup", "possibleLine", "PossibleOrder", "possiblyPage", "PossiblyLine", "possiblyItem", "pablepage", "PossiblePages", "puredpage", "patchingItem", "possiblyPages", "possiblepage", "PossibilityPage", "PossibleLine", "possiblyOrder", "patchedpage", "permanentPage", "PossibilityPages", "possibilityPages", "PossiblePage", "Possiblypage", "puredItem", "possibilityLine", "pableLine", "possibilitypage", "PossibleItem", "PossiblyOrder", "pablePage", "patchedLine", "Possibilitypage", "PossiblyGroup", "permanentOrder", "possiblypage", "possibleOrder"], "property": ["prop", "prefix", "attribute", "p", "Property", "resource", "integer", "maximum", "uration", "term", "notation", "profile", "data", "project", "operator", "duration", "f", "result", "set", "key", "type", "binding", "class", "future", "config", "properties", "section", "header", "expression", "perties", "number", "feature", "table", "variable", "object", "address", "language", "string", "character", " Property", "name", "entity", "t", "binary", "layer", "function", "value", "label"], "referer": ["diffrer", "fere", "Referen", "referers", "refiner", " refre", "referen", "rerer", "reere", "redrer", "Referer", "redber", "Refeline", "Refender", "Refere", "affere", "Refre", "Refiner", "defrer", "afferen", "defere", "reiner", "deferer", "ferers", "rere", "refre", "reerer", "rederer", "differer", " referers", " refrer", " refender", "redeline", " refeline", "frer", "refber", "refeline", "affrer", "refender", "refere", "Referers", "defender", "afferer", "diffiner", "Refber", " referen", "diffender", " refere", "defber", "Refrer", " refiner", "refrer", "ferer", " refber"], "e": ["ee", "esi", "message", "one", "se", "null", "event", "this", "ie", "ele", "f", "es", "o", "d", "ae", "error", "me", "type", "see", "element", "i", "a", "er", "E", "de", "eme", "err", "ea", "or", "ed", "fe", "exc", "p", "ception"]}}
{"id1": "11183087", "id2": "6987642", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"doPost": ["doPOST", "doingSearch", " doPut", "doingPost", "handlePut", "doingPOST", "doPut", " doPOST", "handlePOST", "handlePost", "doingPut", " doSearch", "handleSearch", "doSearch"], "request": ["er", "data", "get", "current", "q", "error", "complete", "QUEST", "type", "create", "remote", "press", "info", "application", "web", "state", "event", "xml", "req", "model", "user", "rf", "instance", "r", "query", "e", "client", "subject", "pull", "external", "call", "buffer", "image", "child", "project", "object", "parent", "order", "Request", "url", "enter", "config", "view", "server", "hello", "post", "route", "rate", "pe", "http", "the", "right", "message", "frame", "context", "result", "input", "resource", "initial", "queue", "join", "report", "forward", "use", "have"], "response": ["connection", "pool", "respond", "body", "results", "application", "web", "Response", "status", "model", "page", "output", "writer", "client", "reply", "template", "api", "parent", "object", "next", "document", "view", "server", "http", "message", "guide", "result", "resource", "res", "report", "onse", "resp", "site"], "senha": ["sanha", "tonha", "zenHa", "suitsha", "zenha", " senwa", "snhi", "snha", "suithi", "sensha", "tonHa", "zenla", "snla", "zenca", "tonlah", "tonwa", " senlah", "renha", "senla", "senlah", " senaka", "sanwa", "zenhi", "renaka", "zenaka", "renHa", " senHa", "senHa", "sanlah", " senca", "zensha", "senaka", "suitla", "snsha", "sanHa", "senhi", "renca", "senca", "senwa", "suitha"], "email": ["office", "login", "data", "name", "language", "xml", "label", "Email", "letter", "model", "user", "mail", "zip", "alias", "line", "account", "password", "e", "address", "secret", "service", "fax", "business", "mobile", "example", "phrase", "environment", "url", "hello", "server", "file", "id", "message", "home", "string", "ip", "username"], "messageDigest": ["messageDend", "meDigher", "messagedigester", "meDigest", " messagedigEST", " messageDester", "medigester", " messagedigest", " messageDEST", "messageMailEST", " messageDest", "messagedigend", "messageDigester", "medigest", "medigher", "messagedigest", "messageDEST", "medigEST", " messageDigEST", "messageDher", "messageDigEST", "messageMailester", "messagedigEST", " messageDigester", "messageMailest", " messagedigester", "messageDigend", "meDigEST", "messageMailend", " messageDigend", "messagedigher", "messageDigher", "messageDester", " messageDend", "messageDest", "meDigester"], "usuario": ["ususillo", "usuirio", " usuiasio", "suluario", "usueario", "usguarius", "usguario", "usuiasio", "usuitasio", "ususarius", "usuariat", "sulurio", "usuiario", "usuitarium", " usuasio", " usuarius", "usituasio", " usuariat", "usuearius", "ussurio", "suuasio", " usuiario", "suurio", "usiturio", " ususarius", "uslurio", "ussuarium", "usuarial", "usluario", "ussuario", "usuarium", "usuiarium", "usuitrio", "usituario", "usueariat", "ussuasio", "suluarial", " usurio", " ususariat", "usuarius", "usguillo", "usluarial", "suuarial", "suuario", " ususario", "usurio", " usuarium", "usuasio", " usuirio", "usluasio", " ususillo", "ussuarial", " usuiarium", "usguariat", "ususariat", "usituarial", "usuitario", "usuillo", " usuillo", "usueillo", "suluasio", "ususario"], "redirect": ["reroute", "indrict", "predroute", " redurl", "Redirect", "indirection", "preduce", "predrict", "reirect", "redition", " redition", "redRECT", "RedRECT", " reduce", "edirection", "rerict", "Redroute", "Redirection", "predirect", "redurl", "induce", "Redition", "predRECT", "Redrict", "reduce", "indirect", " redirection", " redrict", "edurl", "reirection", "edition", "Redurl", " redRECT", "edirect", "redirection", "redroute", "redrict", "predirection"], "session": ["connection", "app", "sl", "data", "info", "state", "event", "Session", "ssl", "page", "cache", "user", "query", "client", "proxy", "service", "storage", "sp", "comment", "image", "child", "cookie", "object", "system", "config", "document", "view", "server", "group", "browser", "ession", "http", "person", "flash", "message", "result", "input", "sid", "use", "node", "site"]}}
{"id1": "17791385", "id2": "17716716", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFile", " copyStream", "CopyFiles", " copyFiles", "copyfile", " copyfile", "CopyStream", "transferfile", "copyFiles", "Copyfile", "transferStream", "copyStream", "transferFiles", "transferFile"], "src": ["ls", "ins", "txt", "uri", "url", "image", "resource", "dest", "b", "st", "loc", "rc", "back", "sb", "inst", "input", "rb", "s", "inf", "ipl", "sin", "source", "config", "filename", "stream", "files", "sc", "sit", "file", "obj", "upload", "dist", "sup", "sl", "sel", "http", "img"], "dst": ["Dlt", "ddest", "ddfd", "Ddest", "dft", "stdest", " dlt", "ddst", "ststs", "dfd", "dsts", "ddsp", "pdft", "fdft", " dsts", "ddft", "fdsp", "stst", "Dst", "fdst", "stlt", "fdfd", "dlt", "pdst", "pdfd", "pdsp", "Dsts", " ddest", "dsp"], "in": ["m", "ln", "ins", "url", "In", "n", "init", "data", "inc", "socket", "gin", "f", "oin", "impl", "input", "din", "IN", "lin", "inn", "h", "conn", "cin", "i", "is", "sin", "win", "rin", "reader", "kin", "inside", "nin", "pull", "login", "inner", "r", "id", "bin", "err", "con", "file", "pin", "ini", "as", "again"], "out": ["at", "ex", "writer", "server", "plain", "copy", "parent", "null", "n", "io", "outer", "off", "sync", "inc", "raw", "part", "output", "f", "exp", "o", "Out", "s", "conn", "temp", "i", "client", "self", "outs", "cache", "exec", "bin", "err", "file", "obj", "other", "up", "net", "w", "OUT", "x", "ext", "again", "line", "post"], "buf": ["fd", "cap", "uf", "pad", "fl", "length", "uc", "b", "count", "cmd", "loc", "rc", "off", "fb", "data", "bh", "raw", "bc", "bag", "rb", "batch", "bytes", "cb", "val", "cur", "bf", "cat", "bd", "buff", "ff", "base", "queue", "br", "v", "lim", "c", "bin", "ctx", "vec", "wb", "bl", "buffer", "seq", "bb"], "len": ["fd", "cap", "ln", "fl", "lf", "ll", "fin", "le", "length", "count", "n", "en", "data", "rev", "part", "no", "pos", "all", "f", "nt", "split", "lin", "cl", "Len", "end", "val", "el", "i", "size", "li", "l", "base", "ind", "bin", "c", "err", "lim", "name", "sl", "ix", "lc", "lt", "line"]}}
{"id1": "400275", "id2": "22879400", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"url": ["address", "base", "ob", "el", "id", "feed", "io", "URL", "path", "xml", "sl", "Url", "host", "location", "string", "name", "filename", "image", "link", "ssl", "connection", "html", "null", "ll", "www", "config", "loc", "loader", "ur", "buffer", "uri", "service", "resource", "fr", "bel", "lr", "http", "href", "l", "source", "file", "server", "ref", "rl", "f"], "in": ["gin", "ins", "reader", "din", "IN", "token", "login", "bin", "id", "io", "inc", "isin", "xml", "ini", "val", "input", "out", "In", "conn", "cms", "inner", "image", "err", "c", "this", "m", "or", "ssl", "a", "i", "r", "ex", "n", "again", "config", "socket", "nin", "inn", "resource", "min", "pin", "is", "data", "source", "file", "init", "inside", "rin", "con", "as", "part", "serv", "impl", "f"]}}
{"id1": "6517139", "id2": "15351863", "code1": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"getPrefsKey": ["getPrefixedSecret", "getPubixedSecret", "getPubixedKey", "getPubsSecret", "getPrefixKey", "getPrefesValue", "getPubsValue", "getPrefixSecret", "getPrefesKey", "getPrefsValue", "getPrefixKeys", "getPrefixValue", "getPrefixedKey", "getPrefesKeys", "getPubixedValue", "getPubsKey", "getPrefixedValue", "getPrefesSecret", "getPrefsKeys", "getPrefixedKeys", "getPrefsSecret", "getPubsKeys", "getPubixedKeys"], "key": ["keys", "string", "reason", "address", "base", "fee", "core", "temp", "id", "ace", "token", "original", "enc", "entry", "path", "message", "json", "result", "hex", "char", "password", "part", "type", "source", "cache", "seed", "value", "KEY", "connection", "str", "data", "text", "Key", "export", "empty", "msg", "name", "word", "ring", "prefix", "k", "secret", "pair", "wire", "sign", "block", "crypt", "cert", "phrase", "hash", "code"], "MD5": ["md6", "MT55", "AMD2", "MET2", "AMD5", "MET5", "SHA6", "SHA5", "DER2", "MET11", " MDse", "md5", "SHA3", "MD85", "MT5", "md4", "md55", "AMD4", "MET85", "mdse", "MD11", "SHA4", "MT4", "md2", "MD6", " MD3", " MD6", " MD4", "DER11", "Dse", "D1", " MD1", "D5", "md85", "MD3", "MDse", "MD2", "DER85", "md3", "MT6", "DER5", "MD4", "MD55", " MD55", " MD2", "MD1", "md11", "D4", "md1"], "resultBytes": [" resultBitcoin", "keyBytes", "responseBytes", "Resultbytes", "keybytes", " resultByte", "ResultBytes", "resultByte", "responsebytes", " resultbytes", "ResultByte", "responseBitcoin", "keyByte", "resultbytes", "resultBitcoin", "ResultBitcoin"]}}
{"id1": "4468255", "id2": "20128728", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "info", "ssh", "Copy", "replace", "move", "clip", "write", "save", "clone", "split", "sync", "cop", "cp", "load", "cat", " cp", "file", "share", "ignore", "get", "put", "log", "delete", "link", "dump", "update", "create", "parse", "paste", "rm", "process", "opy", "transfer", "download"], "from": [" the", "path", "original", "base", "zip", "string", "id", "resource", "vol", "user", "by", "add", "http", "entry", " form", "c", "o", "html", "se", "code", "ate", "form", "er", "part", "client", "one", "source", "ce", "at", "without", "dir", "connection", "old", "before", "the", "open", "parent", "data", "file", "config", "empty", "log", "context", "or", "name", "start", "e", "io", "normal", "back", "link", "url", "of", "stream", "left", "range", "with", "From", "missing", "os", "f", "so", "this", " file"], "to": ["root", "base", "temp", "output", "resource", "token", "eto", "http", "on", "as", "jo", "database", "son", "not", "file", "dis", "toc", "termin", "sp", "office", "plus", "by", "site", "all", "sync", "so", "source", "cache", "load", "dir", "connection", "parent", "about", "name", "process", "disk", "storage", "path", "tom", "system", "socket", "o", "se", "line", "tto", "TO", "two", "flo", "comp", "one", "stat", "back", "no", "To", "p", "null", "or", "template", "io", "yet", "os", "auto", "front", "user", "client", "target", "data", "de", "x", "size", "po", "but", "t", "db", "pe", "too", "me", "top"], "result": ["val", "event", "info", "method", "sum", "accept", "plus", "replace", "mask", "ult", "rc", "lock", "continue", "results", "res", "ure", "entry", "report", "var", "ok", "current", "match", "length", "pass", "ret", "follow", "fail", "die", "arr", "part", "allow", "true", "cache", "use", "source", "up", "diff", "member", "date", "r", "default", "work", "data", "math", "search", "test", "effect", "force", "status", "card", "function", "success", "ver", "url", "comment", "mer", "err", "compl", "future", "br", "sign", "Result", "found", "count", "error", "cur", "term", "valid"], "subFiles": ["Subfiles", "ubFiles", " subParents", " subFile", "partfiles", " subPages", "ubDir", "singfiles", "singFs", "ubfiles", "partParents", "newFiles", "partFiles", "subPages", "subContents", "subDir", " subFs", "ubPages", "subParents", "SubContents", "SubFiles", "newfiles", "newPages", " subDir", "subTokens", "newParts", " subParts", "singFiles", "SubPages", " subTokens", " subContents", "newsFiles", "subFile", "ubContents", "SubFile", "SubTokens", "newsParts", "subParts", "subFs", "newsfiles", "singParents", "ubFile", "newsTokens", "newFile", "subfiles", "partFs", "SubParts", " subfiles"], "i": ["index", "id", "n", "pi", "uri", "ini", "ie", "slice", "c", "inner", "j", "ri", "o", "l", "s", "si", "ui", "is", "ii", "ori", "key", "ti", "d", "phi", "q", "li", "ip", "x", "p", "h", "mi", "u", "bi", "ai", "name", "oi", "ci", "I", "e", "io", "it", "xi", "di", "gi", "hi", "a", "k", "b", "v", "y", "iu", "multi", "f", "iv", "ix"], "newDir": [" newD", "NewDirectory", "nowDIR", "nowDirectory", "nextQu", "oldDir", "NewD", "nextFile", "nextFolder", "subDir", "oldFile", "subFolder", "newJar", "newQu", "newDirectory", "newDIR", "NewJar", "subD", "NewFile", "nextDirectory", "newFolder", " newDIR", " newFile", "newD", "subFile", " newJar", " newFolder", "nextDir", "subDirectory", "nowDir", "subJar", "NewFolder", " newDirectory", "oldFolder", "oldDirectory", "subQu", "NewDir", "oldDIR", "newFile", " newQu", "nowFolder"], "in": ["IN", "index", "pin", "input", "ex", "id", "serv", "ini", "lock", "gin", "on", "ie", "con", "c", "inner", "socket", "o", "l", "ins", "bin", "is", "part", "reader", "thin", "source", "up", "login", "min", "diff", "r", "inc", "data", "file", "init", "conn", "again", "e", "m", "image", "re", "isin", "it", "In", "nin", "a", "pull", "url", "lin", "b", "err", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ou", "sum", "ex", "output", "n", "serv", "op", "lock", "on", "net", "OUT", "socket", "inner", "c", "outs", "o", "all", "off", "write", "line", "bin", "co", "post", "sync", "client", "at", "one", "lib", "up", "cat", "cy", "w", "ch", "inc", "file", "log", "conn", "again", "name", "exec", "Out", "writer", "io", "exp", "call", "word", "ext", "can", "b", "err", "obj", "with", "img"], "fileLength": ["lineLength", " fileSize", "FileSize", "fileSize", "Filelength", " fileLen", "pageName", "baseSize", "fileLen", " fileName", "filelength", "pageLength", "FileLength", " filelength", "fileName", "baseLen", "pagelength", "linelength", "FileLen", "pageSize", "lineSize", "baselength", "lineName", "baseLength"], "charBuff": ["stringMatrix", " charBuffer", " charMatrix", "stringBuffer", "pairMatrix", "charBuffer", "pairBuff", "pairBuffer", "stringBuff", "charMatrix"], "len": ["val", "id", "lf", "cmp", "n", "Len", " pos", "l", "line", "bin", "en", "iter", "split", "fl", "fin", "nt", "part", "li", "lit", "start", " split", "name", "pos", "rev", "ln", " Len", "ni"], "oneChar": [" oneCor", " oneCh", " onechar", "fourCor", " oneCharacter", "singleCar", "singlechar", "singleCharacter", "zeroCharacter", "nextChar", "zerochar", "onechar", "singleCh", "zeroChar", "singleChar", "zeroCor", " oneCar", "nextCh", "oneCar", "fourchar", "eachCharacter", "singleCor", "fourChar", "nextCor", "eachchar", "eachChar", "oneCharacter", "oneCh", "eachCor", "fourCharacter", "oneCor", "nextCar"]}}
{"id1": "21656668", "id2": "23335922", "code1": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 0, "substitutes": {"copyResourceToFile": ["copyResourcesToFiles", "copyResource2Resource", "copyResourcesToFolder", "copyResourceAsResource", "copyResourceFromFile", "copyResourceToFiles", "copyResourcesFromFile", "copyResourceAsFile", "copyResourcesFromFiles", "copyResourceFromResource", "copyResourcesToFile", "copyResourceToResource", "copyResourceToFolder", "copyResourceAsFolder", "copyResource2Files", "copyResource2Folder", "copyResource2File", "copyResourceFromFolder", "copyResourcesFromResource", "copyResourcesFromFolder", "copyResourcesToResource", "copyResourceFromFiles", "copyResourceAsFiles"], "resourceFilename": ["ResourceFilename", "requestPath", " resourceFile", "resourcePath", "ResourceString", " resourceString", " resourcefilename", "sourceSourceFile", " resourceSourceFile", "ResourceSourceFile", "sourceFilename", " resourcePath", "requestString", "sourceString", "resourceString", "resourcefilename", "Resourcefilename", "ResourceFile", "resourceSourceFile", "ResourcePath", "resourceFile", "sourceFile", "requestfilename", "requestFilename"], "destinationFilename": ["DestinationFilename", "destinationThumbnail", "destinatorSourceFile", "DestinationModule", "destinationModule", "destignmentFile", "destationFile", "destificationThumbnail", "destationSourceFile", "DestificationThumbnail", "destificationModule", "DestinationFile", "destificationFilename", "destificationSourceFile", "DestificationFile", "DestinationSourceFile", "destinationSourceFile", "destationModule", "destarationFile", "DestificationModule", "DestinationThumbnail", "destignmentFilename", "DestificationSourceFile", "destationFilename", "DestificationFilename", "destarationThumbnail", "destignmentThumbnail", "destinatorFile", "destinatorFilename", "destarationFilename", "destinationFile", "destificationFile", "destinatorModule"], "inStream": ["binstream", " inSt", "INstream", " inCh", "ninSteam", "inputSteam", "ninStream", "outstream", "binStream", " instream", "inCh", "inStreamer", "INSteam", " inSteam", "outFile", "binSteam", "inputSt", "outSteam", "binStreamer", "INFile", "inputStreamer", " inStreamer", " inFile", "outSt", "instream", "outStreamer", "inputCh", "inSteam", "ninstream", "inputStream", "outCh", "ninStreamer", "inputstream", "inSt", "INStreamer", "INStream", "inFile"], "outStream": ["inPath", "workSteam", "inputSteam", "outstream", "OUTSteam", " outSteam", "againstream", "outputStream", "againStream", "workStreamer", "inStreamer", "outFile", "oneSteam", " outstream", "outPath", "outSteam", "OutSteam", "outputStreamer", "OUTStreamer", "workstream", "OutPath", "inputStreamer", " outFile", "againSteam", "OUTFile", "oneDirectory", "OutStream", "instream", "outStreamer", "OUTStream", "oneStreamer", "inSteam", "oneStream", "inputStream", " outStreamer", "workStream", "againDirectory", "Outstream", "outputSteam", "inputDirectory", " outPath", "outDirectory", "againStreamer", "outputstream", "inFile"]}}
{"id1": "20365090", "id2": "13644375", "code1": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "code2": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"execute": [" refresh", " parse", " future", " generate", " produce", " go", " open", " async", " exec", " await", " resolve", " initialize", " feed", " work", " current", " prepare", " poll", " ping", " finish", " proceed", " dispatch", " flush", " pull", " perform", " serve", " handle", " fulfill", " end", " transfer"], "forwardResponse": ["forwardRequest", " forwardAnswer", "ForwardResp", "forwardResp", " backwardRequest", "forwardServer", "publicRequest", " backwardServer", " forwardresponse", "publicServer", " forwardResp", "wardresponse", "ForwardRequest", "wardResponse", " backwardAnswer", "forwardresponse", "publicAnswer", " forwardServer", "wardResp", "Forwardresponse", " backwardResponse", "publicResponse", " forwardRequest", "forwardView", "forwardAnswer", "wardView", "ForwardView", "wardRequest", "ForwardResponse", " forwardView"], "fetchSizeLimit": ["fetchCountLimit", "fetchCountUnit", "faitLimitGlobal", "fetchRangeRange", "fushSizeRange", "fatchSizeRange", "fushCountRange", "fetchLengthPage", "fetchSizeGlobal", "faitLimitBlock", "fetchsizeLimit", "fetchLengthLimited", "fetchLengthLock", "fetchLengthUnit", "fushCountPage", "faitSizeGlobal", "fushCountUnit", "fetchSizePage", "fushSizeLimit", "fetchCountBlock", "fetchLimitPosition", "fetchSizeRange", "fatchLengthLimited", "fetchRangeUnit", "fatchSizePosition", "fetchLengthBlock", "fushSizePage", "faitSizeLimit", "faitLimitLock", "fetchLengthLimit", "fatchSizeLimit", "fushSizeUnit", "fetchSizeLim", "fatchLengthPosition", "fatchLengthLimit", "fetchCountPosition", "fetchSizeUnit", "fetchLimitRange", "fetchLimitGlobal", "fetchLengthGlobal", "fetchLimitLock", "fetchLengthPosition", "fetchsizeLimited", "fatchSizeLock", "fushCountLimit", "fetchSizeLock", "fatchSizeLimited", "fetchsizeLock", "fetchSizeBlock", "fatchLengthLim", "fetchSizeLimited", "fetchLimitBlock", "fetchsizeGlobal", "fetchLengthLim", "fetchRangePage", "fetchSizePosition", "fetchLimitLimit", "fatchLengthRange", "fetchCountRange", "faitSizeLock", "faitLimitLimit", "fetchRangeLimit", "fetchsizeBlock", "fetchCountPage", "fetchLengthRange", "fatchSizeBlock", "faitSizeBlock", "fatchSizeLim", "fatchLengthLock", "fetchsizeLim", "fatchLengthBlock"], "lastContentRange": ["lastResourcerange", " lastHeaderRegion", " lastReadrange", "lastMessageRow", "lastReadRow", " lastContentRegion", "LastMessageLine", "lastContentRegion", " lastHeaderOrigin", "LastContentSpace", "lastContentArea", "LastContentResource", " lastSizeSpace", "lastFileResource", "lastContentInfo", " lastContentOrigin", "lastResourceRow", "lastResourceSpace", " lastContentrange", "lastReadSpace", "lastVersionrange", "lastContentResource", "lastSizeRange", "lastSizeSpace", " lastSizeRegion", "lastResourceArea", " lastReadResource", " lastContentSpace", "lastContentSpace", "lastReadRegion", "lastReadrange", " lastSizeRange", "lastCharacterRegion", "lastMessageLine", "lastHeaderLine", "latestFileRange", "lastHeaderResource", " lastContentRow", " lastHeaderRow", "lastReadInfo", "lastMessageResource", "lastReadResource", "lastContentOrigin", "LastMessageSpace", "LastContentRange", "lastCurrentRange", "lastReadArea", "latestContentRange", "latestFileResource", "lastCharacterRow", "latestContentRow", "lastVersionResource", "lastReadRange", "LastContentLine", "lastFileRange", "lastMessageRange", "lastCurrentResource", " lastHeaderRange", "lastResourceOrigin", "lastContentLine", "lastHeaderSpace", "lastMessageSpace", "lastCurrentLine", "latestContentResource", "lastCharacterOrigin", " lastReadInfo", "lastResourceRange", "lastHeaderRange", "lastResourceRegion", "LastMessageRange", " lastContentInfo", "LastMessageResource", "lastSizeArea", "lastHeaderOrigin", "lastSizeRegion", "lastResourceInfo", " lastReadRange", "lastContentrange", "lastResourceResource", "lastCharacterRange", "lastHeaderRegion", " lastSizeArea", "lastVersionRange", " lastContentArea", "latestFileRow", " lastContentResource", "lastVersionInfo", "lastFileRow", "lastHeaderRow", "lastContentRow", "lastCurrentSpace"], "old": ["folder", "base", "older", "other", "before", "current", "inner", "val", "to", "format", "common", "form", "expected", "ore", "less", "add", "existing", "local", "slice", "l", "list", "now", "ld", "object", "full", "after", "update", "element", "string", "future", "orig", "from", "front", "past", "ant", "original", "part", "build", "and", "diff", "small", "prev", "handle", "client", " Old", "la", "arrow", "ext", "OLD", "low", "file", "later", "last", "el", "normal", "or", "Old", "plugin", "obj"], "sendSize": [" sendLength", "sentSize", "endTime", "drawLimit", "pushTime", "sentSIZE", "drawSIZE", "loadLength", "transferSize", "drawSize", "forceSize", "pushLength", "forceTime", "writeRange", "sendLimit", " sendSIZE", "endSize", "updateLen", "sendOffset", "updateLimit", "pushLen", "forceLength", "loadRange", "sentLimit", "forceSIZE", "endSIZE", " sendTime", "writeSize", " sendStorage", "endLimit", "sendLength", "drawLength", "loadSize", "transferRange", "SendLength", "sendLen", "endLength", "SendSize", "loadSIZE", "pushSize", "updateSize", "sendStorage", "updateSIZE", "writeOffset", "sendRange", "pushSIZE", "SendStorage", "loadOffset", "sendEnd", "endStorage", " sendLen", " sendEnd", "sendTime", "transferOffset", "writeLength", "sendSIZE", "endEnd", " sendLimit", "SendEnd", "loadTime", "sentLength", "transferLength", "pushLimit"]}}
{"id1": "14773782", "id2": "9857412", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" testJPEGWatter", " testJPPGRasters", " testJPEGRotasters", " testJPEGRotast", " testJPPGrast", " testJPEGrasters", " testJPEGRotatter", " testJPEGratter", " testJPEGRasters", " testJPPGrasters", " testJPEGRast", " testJPPGraster", " testJPEGRatter", " testJPEGWasters", " testJPEGraster", " testJPEGrast", " testJPPGratter", " testJPPGRaster", " testJPEGWast", " testJPEGRotaster", " testJPPGRatter", " testJPEGWaster", " testJPPGRast"], "IOException": ["IPError", " IOError", "IPception", "OSception", "IOError", "OSException", "IOception", "OSError", "IPException", " IOception"], "start": ["base", "in", "end", "offset", "step", "pre", "art", "order", "load", "use", "info", "speed", "style", "left", "set", "scale", "pos", "starting", "from", "stage", "shift", "Start", "started", "diff", "ish", "min", "first", "length", "size", "init", "sum", "id", "data", "date", "get", "delay", "time", "source", "f"], "i": ["ini", "image", "mi", "index", "j", "oi", "yi", "hi", "inner", "phi", "ii", "ix", "fi", "slice", "key", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "abi", "li", "ci", "p", "ie", "uni", "si", "xi", "ni", "io", "multi", "v", "eni", "ai", "bi", "x", "ip", "qi", "ti", "id", "e", "iu", "f", "u", "di", "m", "I", "zi"], "url": ["image", "URL", "base", "in", "resource", "feed", "www", "download", "Url", "ls", "hub", "channel", "ref", "http", "src", "filename", "l", "href", "page", "string", "route", "album", "path", "fb", "source", "org", "uri", "img", "ur", "name", "id", "file", "data", "sl", "connection", "config", "location", "web", "f", "address"], "istream": ["ISTrib", "instep", "ISTstream", "stream", "step", "irstream", "istsore", "irstound", "ishream", "isep", "istsream", "istestream", "istep", "istsREAM", "istore", "instead", "stead", "istrib", "isagram", "stagram", "isead", "istound", "irstREAM", "ISTream", "istsep", "isream", "istsound", "isteream", "istsstream", "ishREAM", "iststream", "ISTep", "ishound", "instagram", "instream", "ishore", "istREAM", "irstore", "isterib", "isteep", "istagram", "istsrib", "istead"], "dec": ["enc", "de", " DEC", "des", "ode", "fr", "func", "vec", "dc", "cam", "draw", "dig", "exp", "sec", "rev", "rec", "DEC", "da", " decode", "c", "code", "r", "der", "oder", "next", "doc", "div", " Dec", "deg", "out", "img", "decl", "ra", "dir", "director", "neg", "data", "valid", "desc", "ec", "inc", "Dec", "s"], "raster": ["Raster", "arascal", "Roder", "rap", " rascal", "hatter", "araster", "Rap", "ratter", "eratter", "Rascal", "hap", "erasters", "eraster", "hasters", " rasters", "rascal", "rasters", " rap", "haster", " roder", "Ratter", "Rasters", "roder", "eroder", " ratter", "aroder", "arasters"], "width": ["z", "image", "flow", "ize", "dim", "wb", "shape", "Width", "density", "w", "duration", "write", "window", "age", "fw", "widget", "lon", "area", "full", "wd", "page", "left", "style", "scale", "wa", "d", "work", "en", "p", "gender", "frame", "x", "min", "img", "wn", "length", "wm", "size", "h", "layout", "weight", "west", "value", "n", "f"], "height": ["th", "dim", "right", "shape", "depth", "density", "deep", "w", "hd", "head", "window", "stroke", "dy", "pad", "rows", "padding", "work", "d", "k", "build", "v", "x", "rh", "img", "y", "length", "ady", "size", "crop", "thin", "h", "volume", "han", "angle", "inches", "Height", "max"], "stop": ["hide", "address", "shape", "change", "end", "step", "check", "ops", "skip", "output", "b", "speed", "hop", "page", "fill", "set", "summary", "cut", "exit", "drop", "clip", "sort", "remove", "snap", "sleep", "Stop", "number", "sign", "rest", "trip", "pop", "block", "pause", "keep", "spot", "roll", "limit", "comment", "zero", "wait", "delay", "save"]}}
{"id1": "14168494", "id2": "13595251", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferClass", " copiedClass", "copyFiles", " copyfile", " copiedfile", "transferFile", "transferfile", " copyFiles", " copiedFile", "transferFiles", "copyClass", " copyClass", "copyfile", " copiedFiles"], "dest": ["data", "loc", "name", "sup", "true", "later", " destination", "st", "destroy", "comb", "class", "orig", "output", "txt", "done", "dist", "temp", "this", "d", "source", "path", " Dest", "transfer", "null", "file", "wb", "Dest", "resource", "target", "out", "dir", "desc", "obj", "tmp"], "src": ["bin", "sl", "sin", "cb", "loc", "sup", "master", "gb", "ds", "s", "sc", "slice", "stream", "st", "sync", "inst", "download", "rc", "ssl", "copy", "rob", "img", "dist", "rb", "sq", "source", "sub", "storage", "filename", "url", "config", "sit", "file", "split", "Dest", "upload", "sel", "sb", "target", "tmp"], "srcChannel": ["sourceChan", "rcConnection", " srcStream", " srcButton", "rcCh", "destConnection", "srcSection", " srcchannel", "rcButton", "distStream", "distChannel", "destChan", "sourceButton", "sourceChannel", "distChan", "rcChan", " srcConnection", "rcSection", "srcCh", "srcChan", "rcStream", "inputConnection", " srcCh", "srcStream", "rcchannel", "srcButton", "sourcechannel", "destChannel", "srcchannel", "inputChannel", "rcChannel", "inputchannel", "destchannel", " srcSection", "distCh", "inputSection", "srcConnection", " srcChan"], "dstChannel": [" dstchannel", "Dstchannel", "drcchannel", "drcContext", "dstsConnection", " dstChan", " drdContext", "dstConnection", "drcChannel", "dstchannel", "dDestChannel", " drdchannel", "ddestConnection", "dsrcVideo", "drdchannel", "dstVideo", "dDestchannel", "drcChan", " dstsStream", " drdChan", "drdChannel", "DstChannel", "ddestChannel", "dstsStream", "Ddestchannel", " dstschannel", "dstContext", "dDestConnection", "ddestContext", "ddestChan", " dstStream", "ddestchannel", " dstConnection", "DstVideo", "DdestChannel", "dstChan", " dstsChannel", "DdestVideo", " drdChannel", "dDestStream", "ddestStream", "dsrcChannel", "drdContext", "dstschannel", "dstsChannel", "dsrcchannel", " dstContext", "ddestVideo", " dstsConnection", "drdChan", "dstStream", "drcVideo"]}}
{"id1": "18544890", "id2": "23677128", "code1": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "\tpublic FTPClient sample3a(String ftpserver, int ftpport, String proxyserver, int proxyport, String username, String password) throws SocketException, IOException {\n\t\tFTPHTTPClient ftpClient = new FTPHTTPClient(proxyserver, proxyport);\n\t\tftpClient.connect(ftpserver, ftpport);\n\t\tftpClient.login(username, password);\n\t\treturn ftpClient;\n\t}\n", "label": 0, "substitutes": {"get": ["match", "call", "create", "remote", "cache", "json", "load", "update", "download", "info", "show", "send", "data", "gets", "resource", "find", "next", "query", "list", "GET", "Get", "pull", "end", "debug", "start", "select"], "url": ["ls", "source", "uri", "str", "path", "Url", "download", "f", "date", "page", "l", "image", "loc", "service", "location", "resource", "email", "www", "base", "name", "server", "host", "URL", "address", "sl", "string", "rule", "connection", "ur", "queue", "layer", "ll", "file", "route", "key", "ssl", "feed", "href", "id", "http"], "lat": ["local", "street", "out", "port", "length", "tile", "at", "home", "alt", "point", "gal", "league", "l", "pos", "loc", "Lat", "west", "data", "location", "bot", "play", "base", "width", "address", "live", "las", "height", "range", "grid", "distance", "late", "route", "id", "game", "la", "offset"], "lon": ["ln", "position", "land", "depth", "length", "len", "lan", "level", "l", "pos", "val", "loc", "left", "nl", "location", "lb", "on", "online", "base", "log", "width", "number", "live", "lang", "vel", "layer", "ng", "lin", "range", "lag", "off", "ino", "fat", "la", "offset"], "count": ["cache", "depth", "length", "c", "load", "amount", "f", "all", "len", "timeout", "level", "scroll", "val", "found", "follow", "total", "age", "force", "n", "limit", "base", "log", "name", "num", "code", "pool", "number", "time", "index", "list", "size", "Count", "sum", "batch", "file", "more", "part", "id", "type", "error", "offset"], "req": ["work", "ref", "cache", "rr", "build", "loc", "fit", "wx", "ext", "post", "conf", "cur", "require", "cp", "jp", "fail", "ok", "def", "temp", "ctx", "fin", "sem", "orb", "http", "form", "client", "check", "ver", "reg", "conn", "qt", "pub", "io", "rob", "grad", "proc", "hr", "res", "gr", "worker", "ctr", "sq", "test", "rt", "pull", "pkg", "dq", "cb", "org", "call", "rx", "cf", "plug", "https", "socket", "serv", "next", "wa", "cook", "requ", "rb", "exp", "respond", "fr", "pr", "tr", "bur", "Request", "p", "c", "download", "f", "fb", "cmd", "resp", "q", "ru", "server", "exec", "fe", "query", "ur", "rf", "request", "r", "err"], "gl": ["gn", "ogl", "berg", "fx", "ml", "browser", "gi", "hl", "pl", "gal", "cal", "il", "view", "groups", "lim", "Gl", "console", "l", "bl", "gre", "GL", "global", "loc", "ang", "gall", "gg", "nl", "ger", "img", "g", "ga", "bel", "lc", "sel", "rl", "fl", "fe", "bg", "sl", "gm", "bs", "gb", "list", "gold", "fr", "las", "cl", "el", "ll", "coll", "ul", "gel", "go", "cm", "lol", "rg"], "br": ["bridge", "result", "bro", "bh", "arr", "str", "browser", "bar", "buf", "mr", "ler", "BR", "bl", "Br", "sr", "img", "io", "ar", "bc", "ber", "b", "hr", "cr", "ch", "res", "sp", "rb", "brush", "body", "dr", "gr", "div", "fr", "yr", "stream", "lr", "pr", "ctr", "tr", "r", "err", "reader"], "line": ["text", "source", "lf", "style", "char", "look", "Line", "lines", "str", "sync", "cell", "lo", "page", "link", "e", "word", "l", "bl", "cle", "pos", "inline", "data", "nl", "comment", "ne", "base", "log", "name", "pe", "lc", "ge", "sel", "code", "sl", "letter", "live", "string", "rule", "fr", "cl", "el", "lin", "LINE", "ine", "block", "co", "file", "row", "key", "ino", "entry", "end", "le", "unit", "jo"]}}
{"id1": "2936678", "id2": "2199604", "code1": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 0, "substitutes": {"getUniqueKey": ["getStringLink", "makeuniqueHash", "getStringKey", "makeUniqueLink", "getPrimaryKey", "getStringkey", "makeUniquekey", "getuniqueKey", "getUniquekey", "getUniqueHash", "getuniqueHash", "makeuniqueKey", "getPrimaryLink", "getStringHash", "makeuniqueLink", "makeUniqueKey", "getPrimaryHash", "makeUniqueHash", "getuniqueLink", "makeuniquekey", "getPrimarykey", "getuniquekey", "getUniqueLink"], "digest": ["dests", "digid", "dested", "genEST", "uuester", "longest", " digests", " digit", "Digester", "Digested", "longEST", "digested", " digEST", "digester", "dest", " digid", "DigEST", "longested", " digester", " digested", "Digid", "Digit", "digEST", "uuest", "genit", "dester", "Digests", "longester", "uuid", "genest", "digests", "digit", "Digest", "uuEST"], "md": ["dc", "df", "mb", "mg", "mp", "pd", "pm", "od", "mand", "mac", "Cmd", "m", "sm", " MD", "km", "d", "hm", "MD", "bd", "meta", "wd", "alg", "hd", "ad", "dd", "ld", "mc", "med", "cd", "gb", "ud", "cmd", "dh", "mn", " dd", "mag", "ma", "nd", "gd", "dm", "hash", "v", "gen", "nm", "amd", "dig", "rpm", "sd", "mm", "metadata", "de", "vd", "mad", "mt", "grad", "mo"], "timeVal": ["TIMEValue", "TimeVal", "TIMEval", "TIMEVal", " timeValue", " timeBu", "timeSeries", "TimeValue", "rateValue", " timeSeries", "TIMESeries", " timeval", "TimeLen", "timeValue", "rateBu", "rateLen", " timeLen", "Timeval", "timeBu", "TimeSeries", "rateVal", "timeval", "TimeBu", "timeLen"], "localHost": ["LocalHost", "LocalMac", "LocalAddress", "remotePort", "privatePort", "remoteMac", " localAddress", "localAddress", "privateAddress", "LocalPort", "privatehost", "localMac", "privateHost", "remotehost", " localPort", "localhost", "Localhost", "remoteHost", "localPort", "remoteAddress", " localhost", " localMac"], "randVal": [" randLen", "RandBu", " randValue", "RandomLen", "randValue", "randBu", "RandVal", "RandomVal", "randomStr", "Randomval", " randBu", "randomVal", "randval", "RandStr", "randStr", "randomval", "randomValue", "randLen", "RandValue", "randomLen", " randval", "randomBu", "RandomValue", " randStr"], "val": ["temp", "live", "pm", "string", "pr", "values", "abc", "msg", "vol", "pt", "key", "eval", "buf", "dev", "Val", "seq", "ret", "unit", "loc", "bl", "valid", "gb", "base", "addr", "reg", "x", "sl", "enc", "VAL", "value", "ind", "el", "format", "res", "v", "vals", "result", "test", "range", "data", "az", "id", "rev", "update", "grad", "sel", "db", "ref"]}}
{"id1": "20660203", "id2": "22611968", "code1": "    public static void main(String args[]) {\n        int temp;\n        int[] a1 = { 6, 2, -3, 7, -1, 8, 9, 0 };\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < a1.length; i++) {\n            System.out.print(\" \" + a1[i]);\n        }\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"temp": ["z", "num", "index", "stable", "prefix", "pt", "current", "pre", " Temp", "mini", "count", "cache", "modified", "output", "style", "null", "pi", "c", "t", "k", "p", "Temp", "v", "diff", "flat", "length", "size", "tmp", "emp", "perature", "test", "tc", "e", "level", "adj", "str", "fake", "empty", "tem", "n", "iter", "default", "partial", "m", "source", "parent", "f", "max"], "a1": ["as4", " a9", "aOne", "A100", "array1", " a0", " a127", "ama100", "A1", "safirst", "sa1", "alpha0", "an5", "aa1", "aa4", "alpha2", "an0", "a91", " aOne", "a0", "saone", "an2", "aa2", "aaone", "amaOne", "alpha4", "aone", "aa51", "an1", "Afirst", "ama1", "a51", " a100", "alphaOne", "a100", "ha2", " a001", "a5", " aone", "array5", "aa91", "A2", "ama51", "Aone", "A5", "anfirst", "eOne", "a4", "e100", "a2", "ha1", "alpha9", "alpha1", "arrayOne", "ama127", "p4", " afirst", " a4", " a2", "an100", "sa5", "a001", "AOne", " a51", "A0", "ama001", "saOne", "alphaone", "a9", "p2", "A91", "aa001", "A9", "ama4", "p0", "p1", "afirst", "as2", "ha100", "arrayfirst", "asone", "hafirst", " a91", "e1", "a127", "e127", "A4", " a5", "as1"], "j": ["z", "aj", "jc", "o", "oi", "jl", "ii", "ik", "l", "b", "jp", "js", "pi", "c", "g", "k", "d", "ind", "li", "ci", "p", "xi", "ni", "si", "bi", "ja", "v", "x", "ji", "it", "I", "y", "length", "jj", "a", "h", "J", "e", "u", "ij", "n", "di", "bj", "m", "f"], "i": ["ini", "z", "mi", "index", "o", "in", "yi", "anti", "phi", "cli", "ii", "ix", "fi", "mini", "slice", "ik", "api", "b", "l", "ui", "jp", "info", "ami", "ri", "pi", "c", "r", "gi", "g", "abi", "it", "li", "ci", "ie", "multi", "si", "xi", "ni", "bi", "I", "uri", "x", "ai", "ji", "io", "y", "v", "ip", "adi", "is", "init", "ori", "a", "qi", "h", "ti", "id", "e", "iu", "u", "vi", "f", "di", "ki", "oi"]}}
{"id1": "2668853", "id2": "8778962", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFiletoFiles", "decodeFileAsStream", "decodeString2file", "decodeFile2Stream", "decodeFiletoFile", "decodeFileToStream", "decodeFiletofile", "decodeFileAsFiles", "decodeFileTofile", "decodeStringToFile", "decodeStringTofile", "decodeStringToStream", "decodeFileAsFile", "decodeString2Stream", "decodeFile2File", "decodeString2File", "decodeFileAsfile", "decodeFiletoStream", "decodeFileToFiles", "decodeFile2file", "decodeStringToFiles", "decodeString2Files", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", "inputfp", " inFile", "inputFile", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "minfilename", "minFile", "minfp", "inputfilename", "infilename"], "outfile": ["infp", "outfull", "outputfile", " outfull", "outfilename", "outFile", " outFile", "infolder", "outputfolder", " outfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "outputfull", "Outfull", "Outfolder", "OutFile", "Outfile", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "i", "input", "inas", "ex", "ini", "gin", "ic", "con", "inner", "socket", "as", "ins", "s", "bin", "is", "reader", "source", "up", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "e", "image", "re", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ex", "output", "copy", "outer", "op", "lock", "on", "net", "OUT", "socket", "as", "inner", "outs", "o", "s", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "lib", "up", "target", "other", "inc", "work", "file", "conn", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "exp", "In", "ext", "b", "obj", "err", "error", "point"], "buffer": ["address", "base", "input", "Buffer", "uffer", "resource", "pause", "border", "server", "feed", "slice", "limit", "result", "length", "bin", "memory", "queue", "offset", "iter", "split", "reader", "source", "binary", "seed", "buff", "value", "buf", "wave", "data", "size", "bb", "null", "row", "bytes", "layer", "flush", "url", "shape", "b", "reference", "padding", "pad", "transfer", "batch"], "read": ["index", "Read", " receive", " r", "run", "ride", " get", "open", " copy", "get", "lex", " send", " check", "id", "feed", "add", "ind", "end", "find", " reach", "next", "sync", "use", "load", " sleep", "r", "work", "fill", "exec", "skip", "connect", " request", "play", " use", "reading", " parse", "limit", "se", "length", "write", "line", "ad", "sleep", "iter", "allow", "reader", " Read", "start", "tell", " load", "wait", " write", "input", "copy", " connect", "current", "reads", "pass", "select", " ride", "seek", "inc", " find", "check", "x", "size", " reader", "send", "k", "parse", "count", "READ"], "success": ["roll", "accept", "job", "response", "rolling", "ok", "continue", "ceed", "results", "warning", "better", "yes", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "selected", "default", "data", "safe", "null", "cess", "danger", "complete", "again", "status", " successful", "full", "correct", "good", "Success", "successful", "successfully", "rolled", "found", " succ", "zero", "error", "fast", "first", "winner", "initial"]}}
{"id1": "17716716", "id2": "160705", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public static boolean downloadFile(String url, String destination) throws Exception {\n        BufferedInputStream bi = null;\n        BufferedOutputStream bo = null;\n        File destfile;\n        byte BUFFER[] = new byte[100];\n        java.net.URL fileurl;\n        URLConnection conn;\n        fileurl = new java.net.URL(url);\n        conn = fileurl.openConnection();\n        long fullsize = conn.getContentLength();\n        long onepercent = fullsize / 100;\n        MessageFrame.setTotalDownloadSize(fullsize);\n        bi = new BufferedInputStream(conn.getInputStream());\n        destfile = new File(destination);\n        if (!destfile.createNewFile()) {\n            destfile.delete();\n            destfile.createNewFile();\n        }\n        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n        int read = 0;\n        int sum = 0;\n        long i = 0;\n        while ((read = bi.read(BUFFER)) != -1) {\n            bo.write(BUFFER, 0, read);\n            sum += read;\n            i += read;\n            if (i > onepercent) {\n                i = 0;\n                MessageFrame.setDownloadProgress(sum);\n            }\n        }\n        bi.close();\n        bo.close();\n        MessageFrame.setDownloadProgress(fullsize);\n        return true;\n    }\n", "label": 0, "substitutes": {"plainToMD": [" string2Hash", " string2String", " string2DER", " input2MD", " stringtoMD", " stringTODER", " string2MD", " input2String", " stringToString", " stringtoDER", " inputToDER", " stringTOHash", " inputToMD", " input2DER", " stringTOMD", " input2Hash", " stringTOString", " stringToMD", " stringToDER", " stringtoHash", " inputToHash", " stringToHash", " inputToString", " stringtoString"], "loggerCol": ["loggeCol", "loglercol", "loggingColumn", "loggerCollection", "progercol", "loggeeDr", "loggingCol", "pluggercol", "loggingCollection", "progingColumn", "logorerCol", "loglerCol", "loggeeCol", "progerColumn", "loggerDr", "loggeCor", "progingCol", "loggecol", "pluggingCor", "loggingDr", "loggeeCor", "loggingCor", "progerCol", "logorercol", "loggerCor", "loggercol", "progerCollection", "pluggingCol", "loggingcol", "pluggingcol", "progingcol", "pluggerDr", "loglerColumn", "loggeDr", "pluggerCol", "loggerColumn", "pluggingDr", "loglerCollection", "logorerCollection", "logorerColumn", "progingCollection", "loggeecol", "pluggerCor"], "input": ["image", "model", "base", "in", "cmd", "raw", "temp", "form", "inf", "format", "audio", "Input", "alpha", "text", "output", "list", "password", "url", "string", "null", "IN", "buffer", "state", "path", "plus", "container", "context", "xml", "ssl", "request", "data", "file", "instance", "str", "empty", "reader", "connection", "config", "source", "dict"], "byteHash": [" byteSum", "wordArray", " byteArray", "Bytehash", "bitSum", "blockHash", "byteSalt", "byteBlock", "stringHash", "stringSalt", "wordSum", "ByteSum", " byteBlock", "blockhash", "byteArray", "bithash", "bytesSalt", "bitBlock", "bitHash", " byteSalt", "bitArray", "blockBlock", "wordhash", "byteshash", "byteSum", " bytehash", "ByteHash", "ByteBlock", "wordHash", "bytesArray", "blockSum", "stringArray", "stringhash", "bytesHash", "bytehash"], "md": ["dd", "nm", "cmd", "dr", "meta", "am", "dig", "metadata", "ma", "amd", " MD", "um", "mm", "mo", "mu", "ms", "cd", "mp", "hash", "mn", "mand", "d", "ph", "bd", "ad", "doc", "pm", "df", "mg", "mt", "sm", "mac", "cc", "Msg", "cm", "MD", "Cmd", "mod", "msg", "dh", "pd", "mag", "rm", "dm", "mc", "pkg", "mb", "hm", "di", "m", "rpm", "f"], "md5result": [" md5Result", "md6package", "md7report", " md25result", "md5report", " md7Result", "md4response", " md305runner", "md53result", "md512Result", " md5report", "md512result", " md305results", "md6data", "mddownpackage", " md25data", "md5Result", "md5package", "md4results", "md4runner", "md5runner", "mddownResult", "md305results", "md305runner", "md6report", " md5data", "md7Result", " md305response", "md7result", " md7result", "md5results", "md7results", " md25Result", "md53runner", " md5results", "md25result", "md512report", " md25package", "md6results", " md5runner", "md305result", "md5response", "mddowndata", "md53response", "md53results", " md5response", "md25data", "md305response", " md7report", "md6result", "md512results", "md5data", " md305result", "md25package", " md7results", "md25Result", "mddownresult", " md5package", "md6Result", "md4result"], "i": ["z", "index", "j", "o", "oi", "hi", "ii", "fi", "key", "mu", "l", "b", "ui", "ri", "pi", "c", "r", "gi", "d", "li", "ci", "p", "multi", "si", "xi", "io", "I", "bi", "v", "x", "ai", "uri", "ji", "length", "ti", "h", "id", "qi", "e", "u", "n", "di", "f", "zi", "s"]}}
{"id1": "10214218", "id2": "23517481", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["enrypt", " encress", "deccrypt", "enress", "decrypt", "decress", "enccrypt", "encipher", " enccrypt", "decipher", " encipher", "enipher", "encress"], "plaintext": [" plaintxt", "battxt", "plainText", "plainstruct", "maintext", "battext", "mainsource", "batsource", "anytxt", " plainText", "batText", " plainstruct", "plainsource", " plainsource", "plaintxt", "anystruct", "anytext", "mainText", "anyText", "mainstruct", "batstruct"], "md": ["mb", "mg", "mp", "pd", "mage", "pm", "od", "ms", "mand", "cm", "mac", "Cmd", "m", "em", "pg", "sm", " MD", "d", "sha", "hm", "MD", "bd", "key", "meta", "wd", "ad", "dd", "ld", "mc", "mod", "cmd", "dh", "dr", "mag", "ma", "am", "arm", "dm", "nm", "amd", "data", "dig", "kg", "mm", "metadata", "message", "mad", "mt", "mu", "db", "mo"], "raw": ["row", "words", "full", "clean", "instance", "initial", "unknown", "input", "wave", "feed", "hex", "buf", "none", " RAW", "content", "original", "ack", "good", "ng", "rc", "rew", "load", "array", "enc", "Raw", "serial", "wrapper", "image", "bytes", "unsigned", "data", "null", "pack", "RAW", "binary", "buffer", "text", "block", "message", "dec"], "hash": ["hed", "sh", "mac", "cache", "Hash", "rh", "secret", "ruby", "sha", "response", "sum", "abi", "log", " hex", "hex", "key", "ashes", "header", "kh", "alpha", "ha", "base", "url", "ash", "array", "code", "her", "image", "h", "html", "data", "id", "message", "block", "version"]}}
{"id1": "19050432", "id2": "19006212", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["openParamingresource", "openNamedResources", "openNnamedResources", "openNamingResources", "openNestedresource", "openNamingresource", "openParamedResources", "openParamingResources", "openNestedResource", "openParamingURI", "openNamingURI", "openParamingResource", "openNnamedResource", "openParamedresource", "openNamedresource", "openNamingResource", "openNnamedresource", "openNnamedURI", "openNamedURI", "openNestedURI", "openParamedURI", "openParamedResource", "openNestedResources"], "name": ["source", "filename", "uri", "str", "path", "username", "ame", "NAME", "info", "word", "Name", "data", "names", "definition", "resource", "old", "n", "class", "url", "base", "address", "string", "size", "prefix", "full", "named", "file", "value", "version", "part", "key", "sea", "id", "type", "parent"], "in": ["source", "as", "result", "rec", "inn", "gin", "out", "token", "pin", "inner", "ac", "f", " out", "i", "input", "socket", "conn", "val", "get", "IN", "data", "con", "win", "resource", "ini", "url", "din", "pc", "b", "vin", "nin", "ins", "connection", "cin", "thin", "In", "fc", "inc", "again", "rin", "kin", "r", "oin", "login", "err", "reader", "edIn", "bin", "ic"], "propsURL": ["proopsLL", " propsUR", "proportsELF", "proppsUR", "prosUL", " propsSSL", "prorsUrl", "prorsurl", "propsCL", "prodsUrl", "proportsUL", " propsLL", "perrsurl", " propsUrl", "prosUrl", "propsLL", "propsUrl", " propsUL", "prosSSL", " prodsURI", "proopsURI", "PropsSSL", "probsURL", "proopsUrl", "probsLL", "procsSSL", " prodsURL", "procsURL", "prodsLL", "pronsURL", "protsURL", "protsurl", "prosLL", "perrsFile", " propsELF", " prolsSSL", "propdsUR", "prodsCL", "propsSSL", " prolsurl", "proopsUR", " propsurl", " prodsurl", "prodsSSL", "prosURL", "propdsUrl", "prodsURI", " propsCL", "prodsURL", "prodsFile", "progsURI", "ProsURI", " proportsUR", "protsFile", "proppsURL", "proppsLL", "prolsurl", "perpsURL", "propsELF", "prolsSSL", "PropsUrl", "probsUL", "prorsFile", "procsurl", "probsUrl", " proportsLL", " proportsUrl", " propsURI", "perpsFile", "propdsURL", " prodsCL", " proportsUL", "perrsURL", "prolsURI", "propsUR", "proportsURL", "propsUL", "prodsurl", "ProsSSL", "prorsELF", "proportsurl", "PropsURL", "propsFile", "propdsLL", "proportsUR", "pronsUrl", "propsurl", "procsURI", "proopsURL", "ProsURL", "proopsurl", "progsURL", "progsurl", "procsUrl", " prolsURL", "progsCL", "prodsUR", "proportsLL", " prolsURI", "prosURI", "proportsSSL", "prorsURL", "pronsLL", "proppsUrl", "propsURI", "proportsUrl", "proopsELF", "PropsURI", "proportsURI", "pronsUR", "prolsURL", " proportsURL", " proportsELF", "proopsCL", "ProsUrl", "perpsurl", "prorsUR"], "urlConn": ["httpconn", "URLConnect", "httpContext", "sslconn", "sslCod", "urlContext", "sslConn", "fileConn", "httpConnect", "urlCod", "sslCond", "URLConn", "URLContext", "httpCod", " urlCond", "urlconn", " urlConnect", "URLConf", "urlCond", "fileConnect", "httpConn", "urlCmd", "urlConnect", "sslCmd", " urlContext", " urlConf", "fileCond", "fileCmd", "sslConnect", " urlCmd", "urlConf", " urlconn", "httpConf", " urlCod"], "httpURL": ["httpsURI", "apiUR", "HttpUrl", "HttpURI", "autoUrl", "httpURI", "httpsUR", "httpsUrl", "apiML", "HttpURL", "httpSSL", " httpurl", " httpSSL", " httpML", "httpUrl", "apiURL", "httpsURL", "httpsurl", "httpurl", "httpsSSL", "HttpUR", " httpUR", "autoURL", "autoSSL", "apiUrl", "httpUR", " httpUrl", " httpURI", "autourl", "HttpML", "httpML"], "hdrVal": [" hheaderVal", "hrStr", "hhrval", "HhrVal", "hdValues", "Hhrval", "hreqStr", "hdrValues", "hrVol", "hDRval", "hndValue", "hdrVol", "hreqVal", " hdrStr", "HdrBu", "hdValue", "HdrValues", "hndBu", " hheaderVol", "HdrDef", "hdval", "hDRValue", "hhrDef", "hhrVal", "hrValue", "HhrBu", "hrcVal", "hrVal", "HhrValues", "Hdrval", "hrcValue", "hhrValues", "hhrValue", "hdVal", "hreqValue", "hheaderVal", " hheaderStr", "hheaderStr", "hndDef", "HhrDef", "hheaderValue", "HdrValue", "hdrDef", "HdrVal", "hDRValues", "hDRVal", "hdrStr", "hrcBu", "hndVal", " hheaderValue", "HhrValue", " hdrVol", " hdrValue", "hrcDef", "hdrval", "hreqVol", "hdrValue", "hheaderVol", "hhrBu", "hdrBu"], "code": ["text", "message", "result", "mode", "ode", "check", "c", "cat", "info", "status", "charge", "state", "success", "e", "one", "level", "ie", "count", "line", "data", "const", "age", "ce", "comment", "ec", "expected", "core", "class", "no", "url", "pc", "reason", "pe", "ge", "zip", "number", "grade", "msg", "Code", "index", "see", "ack", "cc", "category", "rule", "rc", "header", "string", "codes", "fail", "score", "test", "desc", "cod", "value", "version", "xx", "key", "response", "id", "rate", "type", "zone", "error", "co", "go", "content", "coded"]}}
{"id1": "647224", "id2": "20724937", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static TopicMap getTopicMap(URL url) {\n        String baseURI = url.toString();\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return getTopicMap(inputStream, baseURI);\n    }\n", "label": 0, "substitutes": {"uploadFile": ["Uploadfile", "uploadFiles", " uploadfile", " uploadDir", "uploadfile", "processDir", "UploadFile", "UploadDir", "processfile", "processFile", "uploadDir", " uploadFiles", "processFiles", "UploadFiles"], "inputFile": [" inputfile", "targetFolder", "inputPage", "InputFiles", "sourceLog", "inputFolder", "sourceType", "InputFile", " inputFiles", "InputDir", "targetDir", " inputDir", " inputFilename", " inputType", "sourceFolder", "initialFilename", "targetPage", "initialFolder", " inputFolder", " inputLog", "sourcePage", "targetStream", "targetFiles", "inputType", "sourceFile", "inputStream", "sourcefile", "initialFile", " inputStream", "inputFilename", "targetfile", "InputType", "targetFilename", "InputFolder", "inputDir", "initialStream", "inputfile", "targetLog", "inputFiles", " inputPage", "sourceStream", "inputLog", "InputStream", "Inputfile"], "targetFile": ["outputFiles", " targetName", "Targetfile", "outputLine", "outputName", " targetDir", "TargetName", "inputPlace", "targetPath", "targetDir", "TargetLine", "externalPath", " targetFiles", "externalFile", " targetfile", "TargetFile", "targetLine", "targetFiles", "sourcePlace", "sourceFile", "externalfile", "TargetDir", "targetPlace", "TargetPath", "outputPath", " targetLine", "targetfile", "inputDir", "TargetFiles", " targetPlace", " targetPath", "outputDir", "externalName", "sourcePath", "targetName", "sourceDir", "inputPath"], "outputFile": ["outputFiles", "outputStream", "inputPage", " targetDirectory", "currentFile", "currentFolder", "inputFolder", " outputFolder", "writeFile", "targetPath", "writeStream", "outputPlace", " targetFiles", "inputQueue", " outputPath", " outputDirectory", " outputPlace", "OutputFolder", "outPlace", "inputUrl", "outFolder", "targetFiles", " targetQueue", "targetQueue", " outputfile", "outputDirectory", "outfile", "currentPlace", "outputUrl", "inputStream", "outputQueue", "outputPath", "writeUrl", "targetfile", "outDirectory", "inputDirectory", "inputDir", " outputFiles", "OutputDir", "outputDir", "targetDirectory", "outputFolder", "inputfile", "outPath", "currentfile", "outputPage", " outputPage", "outFile", " outputUrl", " outputStream", "OutputFile", "inputFiles", " outputDir", "writePage", "Outputfile", "outputfile", "inputPath"], "in": ["rec", "ins", "url", "In", "init", "io", "data", "inc", "input", "din", "IN", "lin", "inn", "read", "s", "pass", "cin", "i", "is", "win", "pull", "reader", "kin", "issue", "inside", "nin", "stream", "rin", "login", "sub", "inner", "r", "id", "ac", "bin", "err", "con", "up", "diff", "pin", "ini", "source", "again", "serv", "isin"], "out": ["to", "page", "ex", "log", "writer", "console", "write", "report", "one", "image", "copy", "plain", "n", "cmd", "lock", "io", "off", "data", "outer", "sys", "this", "sync", "inc", "output", "o", "Out", "error", "s", "conn", "source", "print", "client", "co", "dump", "ger", "point", "user", "table", "r", "outs", "base", "cache", "inner", "exec", "bin", "file", "err", "println", "by", "inter", "net", "up", "OUT", "state", "again", "ext"], "line": ["page", "pe", "LINE", "log", "url", "frame", "unit", "e", "lf", "write", "le", "lock", "cell", "data", "link", "sync", "part", "limit", "range", "entry", "rule", "split", "lin", "lines", "job", "inline", "type", "row", "error", "code", "pass", "comment", "header", "base", "string", "file", "Line", "name", "word", "lc", "buffer", "ine", "block", "char"], "bytes": ["ls", "values", "rows", "Bytes", "items", "length", " lines", "count", "os", "ones", "pos", "es", "zip", "reads", "bs", "groups", "comments", "classes", "lines", "ines", "s", "ips", "code", "seconds", "i", "tes", "size", "les", "len", "pages", "units", "number", "files", "outs", "bits", " cycles", "steps", "eps", "codes", "binary", "blocks", "words", "cycles", "bps", "odes"]}}
{"id1": "8093133", "id2": "364438", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXMLfromUrl", "loadXMLFromurl", "loadXMLfromFile", "loadXmlfromFile", "loadXmlWithFile", "loadXmlAsURL", "loadXmlFromurl", "loadXMLfromURL", "loadXmlWithurl", "loadXmlAsurl", "loadXMLFromUrl", "loadXmlfromURL", "loadXmlFromFile", "loadXmlWithUrl", "loadXmlFromURL", "loadXmlfromUrl", "loadXMLFromFile", "loadXmlWithURL", "loadXmlfromurl", "loadXMLFromURL", "loadXmlAsFile", "loadXmlAsUrl", "loadXMLfromurl"], "url": ["image", "client", "buffer", "service", "sl", "obj", "host", "object", "feed", "user", "id", "page", "server", "address", "open", "loc", "conn", "location", "http", "URL", "path", "resource", "io", "ssl", "file", "str", "link", "Url", "base", "loader", "org", "l", "string", "uri", "source", "config"], "timeout": ["client", "buffer", "size", "sync", "capacity", "key", "socket", "delay", "limit", "port", "period", "server", "cache", "seconds", "time", "resource", "io", "sleep", "Timeout", "ssl", "out", "scroll", "unit", "until", "data", "type", "token", "offset", "wait", "resolution", "network", "duration", "window", "lock", "config", "length"], "xmlType": ["xmltype", "writerStyle", "mlClass", "writerType", "elementType", "writertype", "xmlFile", " xmlFile", "elementStyle", "mlFile", "phpFile", "xmlTypes", " xmlModel", "phpTypes", "mlTypes", "xmlStyle", "phpType", "elementModel", " xmlTypes", " xmltype", "xmlModel", "mlType", "xmlClass", " xmlClass", " xmlStyle", "writerModel", "phpClass", "elementtype"], "connection": ["position", "client", "connect", "union", "writer", "entry", "relation", "socket", "use", "proxy", "context", "character", "version", "section", "lc", "directory", "handler", "server", "conn", "open", "loc", "bc", "http", "container", "response", "resource", "index", "io", "con", "function", "which", "connected", "channel", "unit", "wrapper", "builder", "b", "database", "collection", "application", " Connection", "l", "reader", "ion", "communication", "network", "Connection", "uri", "event", "closed", "config", "c", "condition"], "buffInputStream": ["BuffOutputStream", "BuffOutputstream", "BuffReadSteam", "buffReadStream", "buffinputstream", "buffinputSteam", "buffOutputStream", "buffInputstream", "buffReadstream", "buffOutputstream", "BuffInputSteam", "buffInputSteam", "buffInstream", "BuffInputstream", "BuffReadStream", "buffInStream", "buffOutputSteam", "buffInSteam", "BuffInputStream", "buffReadSteam", "buffinputStream", "BuffOutputSteam", "BuffReadstream"]}}
{"id1": "7981642", "id2": "9479502", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"update": ["text", "edit", "create", "init", "copy", "set", "push", "check", "config", "send", "build", "updated", "data", "auth", "Update", "up", "and", "url", "u", "add", "change", "setup", "exec", "password", "post", "address", "append", "h", "UPDATE", "write", "sum", "replace", "put", "save", "insert", "register", "key", "sign", "login", "end", "apply", "user", "delete"], "mail": ["text", "contact", "source", "message", "group", "local", "who", "md", "uri", "phone", "username", "hello", "date", "alt", "company", "model", "front", "view", "gal", "m", "dial", "folder", "proxy", "old", "ip", "Mail", "url", "name", "server", "host", "ge", "label", "password", "msg", "zip", "address", "string", "lock", "ul", "Email", "fax", "html", "mails", "office", "file", "value", "login", "dir", "gmail", "id", "user", "xml"], "email": ["text", "message", "md", "uri", "phone", "username", "hello", "eu", "home", "info", "alt", "wd", "model", "archive", "note", "nick", "enter", "line", "cdn", "xml", "addr", "folder", "old", "ip", "n", "description", "online", "Mail", "url", "class", "name", "log", "server", "host", "password", "zip", "address", "li", "inet", "element", "el", "Email", "fax", "en", "office", "cn", "mails", "file", "dn", "login", "dir", "gmail", "id", "ail"], "pwd": [" pwa", "pws", "Ppassword", "cpws", "hwd", "ppass", " pWD", "cpwt", "pppassword", "ppwh", "hpass", "Ppass", "ppassword", "PWD", "pppass", "pwa", "hWD", " pws", "ppwd", "Pwt", " pwh", "hwa", " ppassword", "Pwh", "pwt", " pwt", "Pws", "cpWD", "pwh", "cpwd", "Pwa", "Pwd", "pWD", " ppass"], "firstname": ["caseName", "firstkey", "firstnames", "newname", "lastemail", "lastkey", "firstName", "hostName", "casepass", "lastpass", "lastnames", " firstName", "newnames", "hostkey", " firstkey", "firstuser", " firstemail", " firstpass", "firstemail", " firstuser", "hostname", "hostemail", "newuser", "firstpass", "lastuser", "caseemail", "casename", "lastName", " firstnames"], "lastname": ["firstkey", "firstn", "firstnames", " lastkey", " lastn", "lastday", "secondName", " lastName", "lastkey", "firstName", "secondkey", " lastnames", "lastaddress", "lastnames", "secondaddress", "secondname", " lastaddress", "firstday", "fullName", "fullname", "fullnames", "fullday", "firstaddress", "lastn", " lastday", "fulln", "lastName"], "connection": ["relation", "management", "client", "cf", "connected", "session", "c", "config", " Connection", "system", "this", "Connection", "ca", "conn", "Conn", "manager", "condition", "m", "con", "object", "communication", "directory", "connect", "document", "bc", "database", "b", "lc", "graph", "server", "pool", "sc", "function", "index", "cc", "h", "nc", "di", "handler", "creator", "response", "ion", "db", "context", "application"], "attrs": ["attr", "attks", "attars", "Attras", "attRS", "addRS", "attps", "matps", "atacts", "Attars", " attr", "attras", "addks", "addras", " attributes", "Attr", "atks", "addr", "Attributes", "matars", " attRs", "atRS", "matrs", " attps", "attacts", "addRs", "Attrs", "attributes", "Attps", "AttRs", "attRs", "atars", "atras", "Attacts", " attars", " attacts", "atps", "addars", "matributes", "atributes", "addributes", "atr", " attks", "addps", "atrs", " attRS", "addrs"], "sha": ["shi", "md", "mm", "alias", "va", "ca", "asha", "meta", "ema", "da", "pg", "ami", "mac", "ua", "pa", "sa", "ga", "wa", "base", "si", "sm", "a", "SHA", "lambda", "password", " SHA", "pi", "na", "h", "sche", "eta", "alpha", "sh", "sum", "acl", "ha", "HA", "ma", "ya", "ka", "la", "hi", "volume"], "digest": [" diged", "modEST", "Digester", "Digests", "mdested", "tagester", "DigEST", "digEST", "Digcode", "digested", " digests", "tagcode", "mdester", "diged", "mdgest", "moded", "modests", "diggest", "digests", " digEST", "tagest", " digcode", "Digest", "modest", " diggest", " digested", "Diggest", "Digested", "mdest", "digester", "digcode", " digester", "Diged", "tagested"], "hash": ["secret", "match", "message", "bh", "hed", "json", "cover", "ash", "ag", "dig", "image", "build", "kh", "auth", "mac", "url", "base", "array", "Hash", "code", "password", "hex", "body", "h", "enc", "sum", "sh", "raw", "block", "ha", "html", "value", "version", "key", "her", "user", "rh", "bin"], "ctx": ["cv", " cs", "cs", "xc", "client", "cf", "ctrl", "c", "config", "tc", " conn", "ca", "conn", "hw", "Context", "tx", "ci", "loc", "cci", "cas", "bc", "pc", " cx", "conv", "lc", " c", "fw", "cr", "sc", " rc", "rc", "cc", "cp", "cl", "jp", "qa", "cm", "sq", "cca", "cu", "cn", "vc", "anc", "mc", "ct", "pkg", "ck", "cb", "cmp", " context", "context"], "newName": [" newEmail", " newname", "Newname", "NewEmail", "newEmail", "oldname", "oldEmail", " newAddress", "NewAddress", "NewName", "oldAddress", "newname", "newAddress"], "oldName": ["oldname", "OldHome", "OldPath", " oldAddress", "origPath", "newEmail", "OldAddress", "oldAddress", " oldname", " oldHome", "OldName", "oldEmail", "Oldname", "origName", " oldPath", "newAddress", "origname", "origEmail", "newHome", " oldEmail", "oldPath", "oldHome", "OldEmail"]}}
{"id1": "11341711", "id2": "12380475", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"makeBackup": ["makePickup", "createbackups", "createbackUp", "createbackup", "makebackdown", "makePickups", "makeCleanup", "makeBackups", "makeCleanUp", "createBackdown", "makeBackUp", "makebackups", "makePickdown", "createBackups", "makebackUp", "makeCleanups", "makeCleandown", "createBackup", "makebackup", "createbackdown", "makePickUp", "makeBackdown", "createBackUp"], "dir": ["folder", "log", "base", "module", "DIR", "done", "root", "direction", "download", "up", "group", "zip", "cache", "ir", "run", "wd", "Directory", "dist", "store", "rc", "path", "d", "work", "dict", "doc", "io", "build", "dest", "diff", "director", "Dir", "manager", "init", "name", "md", "dep", "data", "file", "desc", "pkg", "lib", "config", "source", "db", "url", "directory"], "sourcedir": ["seedIR", "sortedir", "sourcedirs", "sodedore", "sourcesiri", "sodedirs", "ssodedIR", "asourcedIR", "asourcedore", "seedir", "sourcesirs", "sourceddir", "sortedIR", "sourcesIR", "seeddir", "sourcesdir", "sourcesir", "ssourceddir", "ssourcedIR", "sodediri", "ssourcediri", "sodedir", "sortedirs", "sourcesore", "sodedIR", "ssourcedir", "asortedirs", "asourcedir", "sourcedIR", "asortedIR", "asourcedirs", "ssodediri", "sourcedore", "seediri", "sodeddir", "sourcediri", "asortedir", "asortedore", "sortedore", "ssodedir", "ssodeddir"], "destinationdir": ["destinatorDIR", "dominationDir", "Destificationdirection", "destinationDIR", "Destificationfolder", "destificationfolder", "desturationfolder", "destificationdir", "Destinationfolder", "destificationDir", "dominationdir", "desturationdir", "dominatorDir", "destinateDIR", "destinatefolder", "destinatorfile", "dominationDIR", "destinatefile", "destificationdirection", "destinatedirection", "destinationfolder", "DestificationDir", "Destificationdir", "destinationsDir", "destinationsDIR", "destinationdirection", "destinatordir", "dominatorDIR", "destinatedir", "destinationsdir", "dominatordir", "destinatorDir", "desturationDir", "desturationdirection", "destinationDir", "Destinationdir", "destinationfile", "Destinationdirection", "dominatorfile", "destinationsfile", "DestinationDir", "destinateDir", "dominationfile"], "destinationDirEnding": ["destinationDirPassING", "destinationDirectorySignING", "destinationPathEndING", "destinationDirectoryEndining", "destinationDirectoryEndING", "destinationDirBegining", "destinationPathBeginging", "destinationDirEndING", "destinationDirectorySigning", "destinationDirSignening", "destinationDirEndining", "destinationDirPassging", "destinationDirectorySignening", "destinationDirPassing", "destinationDirSignING", "destinationPathBeginING", "destinationDirSignining", "destinationPathBeginning", "destinationDirLeadING", "destinationDirENDing", "destinationDirENDging", "destinationDirLeadining", "destinationDirEndening", "destinationDirSigning", "destinationDirectoryEnding", "destinationPathEndging", "destinationDirEndning", "destinationPathBegining", "destinationPathEnding", "destinationDirBeginning", "destinationDirectorySignining", "destinationDirBeginING", "destinationDirLeading", "destinationPathEndning", "destinationDirEndging", "destinationDirBeginging", "destinationDirectoryEndening", "destinationDirENDING", "destinationDirBeginining", "destinationDirENDning", "destinationDirPassning", "destinationDirBeginening", "destinationDirLeadening"], "files": ["resources", "log", "boxes", "books", "its", "index", "objects", "keys", "locks", "errors", "types", "bugs", "flows", "ls", "runs", "lines", "children", "services", "planes", "sections", "thumbnails", "rules", "ids", "links", "output", "l", "blocks", "events", "iles", "uploads", "tests", "projects", "groups", "rows", "ps", "images", " Files", "split", "Files", "parents", "fields", "actions", "items", "fs", "reports", "users", "xml", "ins", "models", "features", "ips", "docs", "pages", "data", "file", "modules", "classes", "names", "balls", "results", "words", "strings"], "checkdir": ["checkDIR", "checkFolder", "blockdraft", "checklog", "checkfile", "workDIR", "ckdirectory", "workfolder", "workdirectory", " checkDIR", "searchdir", "lockDir", "locklog", "blockdirectory", "ckDir", "checkdraft", "workfile", " checkd", "searchdirectory", "calldirectory", "CheckDIR", " checkDir", "calld", "workdraft", "lockFolder", " checklog", "blockdir", "searchDir", "checkdirectory", "workdir", "checkfolder", "calldir", "Checkfile", "worklog", "callfolder", "blockDir", "workDir", " checkFolder", "ckdir", " checkfile", "checkDir", " checkdirectory", "ckfolder", "CheckDir", "checkd", " checkfolder", "searchdraft", "ckd", "lockdir", "workFolder", "ckfile", "Checkdir"], "date": ["image", "log", "de", "late", "change", "event", "dat", "open", "at", "age", "day", "mu", "rate", "now", "update", "set", "Date", "state", "d", "m", "ate", "doc", "month", "dt", "mate", "sign", "start", "name", "zone", "ime", "ge", "data", "file", "user", "e", "contact", " Date", "time", "config", "tag", "md"], "msec": ["Msecond", "dseconds", "mnsec", "cseconds", " msc", "misec", "lseconds", "mnSec", "csecond", "lss", "dsecond", "rsec", "Msec", "lsecond", "disec", " minsec", "dsec", "msc", "mss", " minif", "mnif", " minSec", "Mseconds", " mif", " mSec", "fmsec", "css", "lsec", "mnsc", "fmisec", "mif", " minsc", "fmseconds", "mSec", "mseconds", "Misec", "fmsecond", "msecond", "rsecond", "csec", "rseconds", "rss"], "checkFile": ["CheckDirectory", " checkDirectory", "checkfile", "CheckFile", "workFiles", "checkLine", "checkDirectory", "workfile", "checkFilename", "changeFilename", "ckFiles", " checkDir", "CheckFiles", "checkFiles", "workFile", "ckFile", "ckDirectory", "Checkfile", "controlfile", "changeLine", "controlFile", "workDir", " checkfile", "checkDir", " checkFiles", "changefile", "changeFile", "controlLine", "controlFilename", "CheckDir", " checkFilename", " checkLine", "ckfile"], "i": ["ini", "index", "j", "field", "oi", "hi", "phi", "ii", "fi", "ix", "slice", "key", "mu", "b", "info", "ui", "ri", "pi", "gi", "li", "ci", "p", "ie", "part", "multi", "si", "xi", "io", "bi", "uri", "v", "x", "ai", "ji", "eni", "y", "ip", "is", "ti", "qi", "id", "e", "iu", "u", "im", "vi", "n", "di", "m", "I"], "f": ["folder", "j", "o", "fr", "q", "feed", "fun", "w", "F", "fe", "fi", "fc", "l", "b", "info", "cf", "r", "fd", "t", "d", "fb", "fl", "p", "v", "df", "fp", "fs", "fx", "h", "file", "fn", "e", "sf", "u", "n", "m"], "g": ["ga", "q", "gar", "G", "gin", "global", "w", "group", "ger", "l", "b", "gg", "rg", "gb", "r", "gh", "gi", "tg", "t", "eg", "d", "m", "ig", "pg", "p", "gc", "sg", "mg", "gd", "gu", "gs", "ge", "h", "erg", "file", "gn", "e", "s", "go", "og", "ng", "bg", "u", "reg", "msg", "n", "vg", "gm", "gp"], "destinationFile": ["destinationsFile", "DestinationFile", "destacementfile", "destiningFile", "DestationDir", "destinationFilename", "destificationDir", "Destinationfile", "destinatorDirectory", "DestinationLocation", "destiningDir", "destiningfile", "DestificationDir", "destificationLocation", "destiningFilename", "destationFile", "destinationsDir", "destinatorFile", "destificationFile", "destacementFile", "DestificationLocation", "DestificationDirectory", "destacementFilename", "destinatorDir", "destinationDir", "destinationfile", "destationfile", "destinatorLocation", "DestationFilename", "destationFilename", "destinationDirectory", "DestinationDir", "DestinationFilename", "DestinationDirectory", "destinationLocation", "Destationfile", "DestificationFile", "destinationsDirectory", "destacementDir", "destationDir", "destificationDirectory", "destinationsLocation", "DestationFile"], "sourceFile": ["sourceDirectory", "srcDir", "ourceDirectory", " sourceModule", "sourceDir", "SourceDir", "ourceFiles", "inputDirectory", "inputDir", " sourcefile", " sourceFiles", "inputFiles", "sourceModule", "SourceFile", "SourceModule", "inputFile", "sourcefile", "Sourcefile", "ourceDir", "srcfile", "srcFile", "sourceFiles", " sourceDir", "srcModule", "ourceFile", " sourceDirectory"], "infile": ["indir", "outf", "windir", "outdir", "inf", "outFile", "inputfile", "diffFile", "inputstream", "inFile", "InFile", "outstream", " instream", "Instream", "diffdir", " inFile", "indata", "difffile", "winstream", "inputdata", "inputFile", "winFile", "diffstream", "instream", "outdata", "winfile", "Inf", " indata", "inputf", "Infile"], "outfile": ["exstream", "intstream", "outline", "Outstream", " outpage", "outFile", "againFile", " outFile", "intFile", "inputfile", "outpage", "Outlive", "againpage", "outfunction", "outstream", "againfile", "inputline", "exfile", " outfunction", "intlive", "Outfunction", " outstream", "againstream", "inputfunction", "inputFile", "outlive", "intfile", "expage", "exFile", " outline", "OutFile", "Outline", "Outfile", " outlive"], "c": ["z", "lc", "enc", "esc", "index", "dec", "in", "ice", "o", "end", "cont", "w", "cl", "pc", "channel", "cu", "l", "ch", "b", "C", "code", "string", "r", "ct", "rc", "t", "d", "k", "ci", "p", "pointer", "v", "x", "cy", "xc", "character", "cm", "col", "ac", "a", "h", "id", "e", "char", "comment", "u", "abc", "n", "uc", "ec", "m", "cr"]}}
{"id1": "949327", "id2": "6403868", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"f": ["path", "fun", "fe", "sf", "n", "fs", "feed", "cf", "df", "fa", "lf", "bf", "rf", "filename", "c", "ref", "j", "fc", "fp", "fi", "l", "s", "fn", "fr", "ff", "form", "fold", "d", "r", "g", "w", "file", "flat", "h", "x", "p", "name", "folder", "e", "m", "io", "t", "fo", "fm", "function", "F", "fd", "self", "a", "fen", "of", "v", "b", "tf", "inf", "this", "fx"], "in": ["IN", "pin", "ssl", "fa", "token", "ini", "ic", "ins", "bin", "thin", "vin", "get", "gen", "it", "a", "with", "din", "ex", "serv", "lock", "part", "source", "up", "connection", "min", "r", "str", "g", "w", "rin", "again", "exec", "isin", "In", "lin", "b", "v", "inn", "win", "n", "gin", "con", "inner", "socket", "session", "reader", "d", "diff", "p", "init", "or", "m", "image", "nin", "ac", "cin", "fe", "input", "c", "l", "pass", "is", "login", "inc", "config", "data", "rec", "t", "err"], "cbuf": ["cbux", "dbuf", "zbuff", "bbuff", "fbbuf", "cfbuf", "rbuff", "bbull", "cbul", "bcul", "CBuc", "bcuc", "bcull", "CBuf", "CBuff", "zbuu", "cfuf", "fbuc", "bcurs", "dbuc", "rbuc", "cbutf", "rbuu", "cbbuf", "cburs", "CBul", "bault", "bux", "buff", "ebuu", "buf", "cfuc", "rbutf", "rbbuf", "rbull", "bcuf", "bcuff", "bcault", "ebuf", "fbuff", "rbux", "zbuf", "bcur", "ebutf", "cbuff", "rbuf", "rburs", "rbul", "cbull", "cbuc", "bbuf", "cbuu", "cfuff", "fbuf", "zbutf", "dbuff", "ebuff", "bburs", "bcux", "dbur", "cfur", "rbault", "cbur", "cbault"], "read": ["index", "Read", "each", "hex", "run", "ride", "en", "raw", "only", "q", "build", "open", "used", "get", "lex", "it", "readable", "ed", "print", "know", "buffer", "num", "id", "feed", "rc", "add", "report", "oct", "ack", "ind", "end", "find", "sync", "use", "load", "r", "g", "work", "w", "level", "un", " READ", "fill", "name", "bit", "ing", "full", "skip", "connect", " reading", "val", "play", "close", "reading", "ok", "socket", "se", "length", "write", "record", "iter", "sleep", "loop", "er", "allow", "reader", "d", "old", " Read", "bind", "insert", "start", "change", "io", "update", "create", "y", "wait", "repeat", " write", "ink", "error", "view", "valid", "ak", "input", "child", "draw", "reads", "pass", "key", "last", "select", "type", "want", "seek", "inc", "data", "text", "config", "check", "x", "size", "log", "put", "cel", "send", "call", "pe", "k", "parse", "stream", "ize", "count", "READ", "re", "orig"], "totRead": ["octotoLength", "tottedWrite", "TotGet", "tcotClose", "tcotRead", "dottLoad", "octotWrite", " totalBuild", "tottedGet", "tntReader", "tottUse", "octotoRead", "totLink", "totBuild", "towLength", "dottReader", "totoLength", "tazonClose", "tetReading", "toyDraw", "totClose", "totiBuild", " totWrite", "notLoad", "notWrite", "intottBuild", "tottLength", "tottAccept", "totalLoad", "towLoad", "totalLink", " totalWrite", "nottAccept", "towWrite", "nottRead", "totoSearch", "tochRead", "intotLoad", "tottReading", "tottWrite", "toyWrite", "tollRead", "tottedRead", "tottLoad", "octotLength", "TotConnect", "ntotWrite", "tetRead", "TotLoad", "totoUse", "tntRead", "dottUse", "octotReading", "TottConnect", "ntottLoad", "TotSearch", "TotaRead", "totoLoad", "tntLoad", "TotaLoad", "tottClose", "totDraw", "totLength", "towAccept", "TottReading", "tobyRead", "intotClose", "towReading", "totingSearch", "totaDraw", "totoWrite", "TotDraw", "nottLoad", "toyRead", "tcotBuild", "totReading", "totConnect", "octotRead", "ntottWrite", "totalAccept", "totalRead", "totLoad", "tazonBuild", "totalBuild", "tntWrite", "totoRead", "dotRead", "ntotRead", "totingWrite", "ntotLoad", "totReader", "notAccept", "totaRead", " totBuild", "tottSearch", "ntottReader", "notRead", "totingRead", "totWrite", "tazonLoad", "totingGet", "dotLoad", "dotReader", "dotUse", "dottFind", "tobyFind", "TotaWrite", "tochLoad", "tottedFollow", "ntotReader", "intotRead", "intottLoad", "totUse", "totaReading", "totaLoad", "totaWrite", "tcotLoad", "TottReader", "tottReader", "totiRead", "tatRead", "totiWrite", "dottWrite", "toyLoad", "TottFollow", "tottFollow", "tatLoad", "totingConnect", "dotFind", "tochReader", "tottConnect", "dottReading", "intotBuild", "TotReader", "totoFind", "tollLoad", "tochWrite", "tobyUse", "tottDraw", "dottRead", "totaLink", "tobyLoad", "totoConnect", " totalRead", "totingFollow", "TottLoad", "TottWrite", "TotaDraw", "tottRead", "tetWrite", "totFind", "nottWrite", "towRead", "TotReading", "totalWrite", "octotoReading", "tollReading", "tatReader", "tollWrite", "dotReading", "tottFind", "ntottRead", "intottRead", "totiLink", "totFollow", "tetLoad", " totalLink", "tazonRead", "totSearch", "TotFollow", "totGet", "octotoWrite", "TottRead", "TotRead", "totaBuild", "TottGet", " totLink", "intottClose", "totoReading", "tottGet", "TottSearch", "totaReader", "dotWrite", "totAccept", "tottBuild", "tatWrite", "TotWrite"], "out": ["ex", "output", "n", "plus", "outer", "net", "c", "OUT", "socket", "o", "outs", "l", "fn", "s", "off", "bin", "client", "sync", "part", "d", "up", "connection", "r", "g", "w", "inc", "parent", "file", "h", "x", "p", "conn", "init", "again", "exec", "Out", "io", "t", "exp", "writer", "In", "a", "ext", "conf", "v", "b", "err", "obj", "ac"], "i": ["index", "ini", "ic", "ii", "q", "chi", "ci", "I", "eni", "zi", "it", "hi", "iu", "multi", "info", "buffer", "id", "ind", "z", "ui", "ori", "ti", "source", "r", "g", "ip", "mi", "ai", "name", "oi", "e", "b", "v", "ik", "uri", "ei", "yi", "slice", "o", "length", "qi", "one", "ji", "d", "phi", "h", "p", "bi", "u", "init", "start", "m", "io", "di", "y", "ni", "api", "ix", "input", "pi", "ie", "c", "current", "j", "fi", "ri", "l", "si", "is", "key", "my", "data", "li", "x", "xi", "gi", "k", "me", "abi"]}}
{"id1": "15737836", "id2": "8046691", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"delete": ["de", "create", "del", "write", "process", "sync", "replace", "update", "clear", "sql", " Delete", "drop", "remove", "destroy", "where", "close", "execute", "id", " destroy", "Delete", "connect", " update", "get", " create", "select", "exec", "release", "save"], "site": ["image", "model", "unit", "base", "isite", "module", "section", "course", "sample", "project", "domain", "install", "target", "profile", "license", "cache", "sync", "remote", "environment", "conn", "space", "object", "page", "null", "set", "sql", "class", "status", "session", "item", "node", "note", "source", "type", "line", "result", "si", "se", "network", "blog", "sit", "xml", "ite", "edge", "Site", "name", "zone", "server", "data", "sites", " Site", "theme", "database", "config", "location", "db", "plugin"], "dbo": ["dho", "idebo", "jBo", "jba", " dBo", "fbo", " dBO", "dbi", "gBO", " dbi", "fBo", "gbo", "ideho", "Dbo", "drbi", "dbos", "drbc", "jBO", "drBo", " dbc", "idbl", "fBO", "dBO", "rdbi", "dbl", "pBO", "pba", "DBO", "gbos", " dba", "pBo", "idebl", "Dbos", "rdbc", "Dho", "Dbl", "dBo", "dbc", "ideBo", "rdBo", "fba", "idBo", " dbos", "jbo", "dba", "idbo", "Dba", "idho", "pbo", "drbo", "DBo", "rdbo", "gBo"], "connection": ["image", "unit", "index", "pool", "graph", "resource", "log", "section", "ion", "directory", "function", "channel", "Connection", "cache", "use", "table", "environment", "conn", "ongo", "connected", "management", "application", "builder", "driver", "c", "sql", "position", "condition", "engine", "session", "creator", "collection", "relation", "subject", "query", "node", "handler", "ci", "translation", "result", "io", "container", "response", "client", "character", "context", "manager", "statement", "communication", "con", "loc", "union", "server", "component", "document", "reference", "connect", "instance", "lock", "database", "bc", "ctx", "config", "db", "machine", "library"], "preparedStatement": ["prefixedHeader", "PreparedTransaction", "proparableStat", "prehedScope", "PreparedDocument", "previsedComment", "prepperConnection", "prequalifiedStat", "preciseStat", "eculatedstatement", "proparableStatement", "preppedTransaction", "PrearedService", "preppedComment", "preutedHeader", "preferredString", "partvisedStatement", "proparedStat", "preachedString", "preparableStat", "preformedTransaction", "preparedComment", "preparedInstance", "prefixedComment", "preculatedStatement", "preplacedQuery", "preformedString", "prearedScope", "eculatedTransaction", "preferredComment", "preplacedStat", "prefixedStatement", "preppedQuery", "preppedConnection", "PreparedParent", "prearedString", "psefixedScope", "prepperTransaction", "psefixedStatement", "pseparedComment", "preparedParent", "preparedHeader", "eparedStatement", "preamedString", "eparedConfiguration", "PreparedStatement", "preparableInstance", "preparedDatabase", "preciseStatement", "prequalifiedstatement", "partvisedQuery", "prelyingstatement", "preppedDocument", "prepperDocument", "preparedConnection", "caparedTransaction", "preamedStatement", "preparedOperation", "preparedDocument", "previousComment", "preparedConfiguration", "prefixedOperation", "partparedComment", "PreppedConnection", "eparedTransaction", "psefixedQuery", "preplacedComment", "prehedStatement", "pseparedQuery", "prearedService", "eparedstatement", "preachedDatabase", "partvisedComment", "PrearedString", "preferredStatement", "partparedStatement", "preparedTransaction", "prearedComment", "preamedStat", "PrearedStatement", "prehedComment", "preparedstatement", "proparedStatement", "preculatedTransaction", "PreparedDatabase", "PrearedQuery", "PreppedTransaction", "pseparedScope", "prefixedQuery", "PrearedHeader", "prefixedScope", "PrearedParent", "preciseString", "previsedStatement", "preparedScope", "preferredQuery", "proparedstatement", "PreparedQuery", "partparedQuery", "PreparedOperation", "prearedInstance", "preciseParent", "preplacedStatement", "prearedstatement", "eculatedConfiguration", "calyingTransaction", "preformedService", "preutedQuery", "preformedDatabase", "partparedStat", "preformedStatement", "prehedQuery", "prearedDatabase", "preppedString", "psefixedComment", "prepperStatement", "preppedStatement", "PreparedConnection", "proparableInstance", "prearedStatement", "previousTransaction", "PreparedStat", "prelyingComment", "prearedOperation", "preformedConfiguration", "previousstatement", "PreppedStatement", "prequalifiedStatement", "PrearedDatabase", "preutedStatement", "caparedStatement", "caparedstatement", "preachedStatement", "preamedParent", "PreparedService", "partvisedStat", "proparedInstance", "previousDocument", "preparedString", "preachedService", "previousConnection", "preparablestatement", "prearedStat", "prearedConfiguration", "preparedService", "PrearedStat", "previousStatement", "eculatedStatement", "prearedQuery", "preparedStat", "preculatedConfiguration", "caparedComment", "PreparedComment", "previsedQuery", "pseparedStatement", "calyingComment", "prelyingTransaction", "proparablestatement", "preparedQuery", "PreparedHeader", "PrearedOperation", "prearedParent", "prelyingStatement", "prearedHeader", "PreppedDocument", "preculatedstatement", "prequalifiedInstance", "preutedOperation", "preparableStatement", "PrearedComment", "previsedStat", "prearedTransaction", "calyingStatement", "calyingstatement", "PreparedString", "preformedstatement"], "resultSet": [" resultList", "ResultSource", " resultLine", "resultSource", " resultSource", "resultsLine", "resultGet", "ResultLine", "rowSet", "responseList", "rowSize", "ResultSize", "responseLine", "resultLine", "resultsSource", "ResultGet", "rowSource", "resultsSet", "responseSource", "ResultList", "rowGet", "ResultSet", "responseSet", " resultSize", "resultList", "resultSize", "resultsList", " resultGet"], "chkSql": ["chkPssql", "chksAsq", "chksAsql", "chksAsQL", "chKSsql", "chkPsq", "chkSQL", "chkPresql", "chkOsq", "chkOsql", "chkOssl", "chKSql", "chkRssql", "chksSql", "chkPresQL", "chkPsql", "chKRsq", "chkAsq", "chkSq", "chkRssl", "chkOsQL", "chkPressql", "chKSq", "chksSsql", "chkSsl", "chkOssql", "chkPssl", "chkRsql", "chKSsl", "chkAsQL", "chKRsql", "chksSQL", "chKRssl", "chkPresq", "chKRssql", "chksAssql", "chkSsql", "chkRsq", "chksSq", "chkAsql", "chkAssql"], "selfDefinePath": ["selfDefinedpath", "selfDefinesKey", "selfDeclinedpath", "selfDefenPath", "selfDefinedName", "selfDefineKey", "selfDefiningPath", "selfDeclineKey", "selfDefinedLocation", "selfDeclinepath", "selfDefinespath", "selfDeclineUrl", "selfDefenName", "selfDefinesPath", "selfDeclinedUrl", "selfDefineLocation", "selfDeclinedKey", "selfDefinesName", "selfDefinedKey", "selfDefiningKey", "selfDefinepath", "selfDefinedUrl", "selfDefenLocation", "selfDefiningUrl", "selfDeclinePath", "selfDefinesUrl", "selfDefineUrl", "selfDefinesLocation", "selfDefinedPath", "selfDefenpath", "selfDefiningpath", "selfDeclinedPath", "selfDefineName"], "sqlStr": [" sqlString", " sqlDec", "sqlString", "sqlDec", "sqlBr", "sqlText", "queryText", "SQLBr", "querystr", "SQLText", "SQLDec", "SQLWr", "sqlWr", "qlString", "SQLstr", "queryDec", "SQLStr", "sqlstr", "qlStr", " sqlText", " sqlWr", "SQLString", " sqlstr", "qlBr", "qlWr", " sqlBr", "queryStr"]}}
{"id1": "7981642", "id2": "4599372", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 0, "substitutes": {"update": ["save", "login", "data", "edit", "create", "put", "change", "send", "setup", "set", "add", "copy", "register", "user", "check", "text", "u", "and", "password", "key", "updated", "address", "Update", "build", "init", "exec", "h", "delete", "url", "config", "sum", "sign", "post", "up", "append", "replace", "UPDATE", "auth", "push", "insert", "write", "end", "apply"], "mail": ["ul", "msg", "office", "gmail", "alt", "login", "lock", "name", "phone", "mails", "m", "ge", "gal", "xml", "label", "Email", "local", "model", "html", "user", "text", "front", "zip", "old", "password", "address", "md", "proxy", "fax", "source", "value", "url", "hello", "uri", "server", "date", "group", "view", "file", "folder", "dial", "id", "message", "Mail", "contact", "dir", "host", "company", "who", "string", "ip", "username"], "email": ["office", "gmail", "ail", "cdn", "alt", "login", "cn", "name", "phone", "archive", "wd", "note", "mails", "el", "info", "dn", "en", "xml", "Email", "inet", "class", "log", "model", "description", "text", "online", "zip", "old", "line", "password", "address", "md", "nick", "fax", "url", "enter", "li", "n", "uri", "server", "hello", "eu", "folder", "file", "id", "message", "Mail", "dir", "host", "home", "addr", "ip", "element", "username"], "pwd": ["pwt", "cpwd", "cpws", " pWD", "Pws", "ppwd", "Ppassword", "hwd", "hwa", " ppass", "pwa", "hWD", "Pwd", "Pwh", " pwa", " pwt", "ppassword", "cpwt", "Ppass", " pwh", "cpWD", "pWD", "pwh", "Pwa", "ppwh", "hpass", "PWD", "Pwt", "pws", " pws", "pppassword", " ppassword", "ppass", "pppass"], "firstname": ["firstemail", "caseName", "lastkey", "lastuser", " firstName", "hostname", "lastnames", "casename", " firstuser", "lastName", " firstpass", "firstkey", "lastpass", "firstuser", " firstnames", "hostemail", "firstnames", "newuser", "firstpass", "casepass", "hostkey", "newname", " firstemail", "hostName", " firstkey", "caseemail", "lastemail", "newnames", "firstName"], "lastname": [" lastday", "lastkey", "firstday", "lastn", "secondName", "lastnames", "fullname", "lastName", "firstkey", " lastaddress", "firstaddress", "fulln", "lastday", " lastName", "secondname", "lastaddress", "secondkey", "firstnames", " lastnames", " lastn", "fullnames", "fullday", " lastkey", "fullName", "firstn", "firstName", "secondaddress"], "connection": ["manager", "nc", "pool", "handler", "database", "sc", "session", "creator", "ca", "m", "application", "lc", "di", "conn", "b", " Connection", "client", "this", "connected", "condition", "cc", "connect", "db", "cf", "h", "object", "response", "ion", "system", "context", "config", "document", "relation", "server", "Conn", "c", "function", "management", "index", "con", "directory", "Connection", "communication", "bc", "graph"], "attrs": ["attacts", "attks", "attributes", "attras", "Attps", " attks", "atras", "attars", "matps", "atributes", "attps", " attr", "atRS", "Attributes", "Attrs", " attRS", "AttRs", "addars", "atr", "addras", "atrs", "addributes", "attRs", " attRs", " attributes", "addRS", " attps", " attacts", "atps", "Attr", "addRs", "atars", " attars", "attr", "atks", "matars", "addps", "addrs", "matrs", "Attars", "attRS", "Attras", "atacts", "matributes", "Attacts", "addr", "addks"], "sha": ["ema", "meta", "volume", "ka", "ha", "sche", "si", "ua", "ca", "ma", "na", "da", "pi", "lambda", "shi", "base", "hi", "acl", "ami", "mac", "alias", "password", "va", "la", "md", "sm", "wa", "h", "asha", "sum", "sa", "mm", " SHA", "ga", "a", "pa", "eta", "pg", "alpha", "ya", "SHA", "sh", "HA"], "digest": ["mdest", "modEST", " digester", " digests", "DigEST", "diggest", "Digester", "digested", "moded", "modests", "Digcode", " diggest", "digester", "tagest", "digEST", "diged", " digcode", "mdested", "mdester", "mdgest", "digcode", "Diged", " digEST", "Digested", "Diggest", "modest", " diged", "tagester", "digests", "tagcode", " digested", "tagested", "Digest", "Digests"], "hash": ["rh", "bin", "ag", "ha", "hed", "version", "body", "array", "enc", "hex", "bh", "base", "match", "dig", "user", "mac", "her", "kh", "password", "key", "secret", "block", "image", "build", "value", "h", "url", "sum", "code", "raw", "message", "ash", "cover", "auth", "Hash", "json", "html", "sh"], "ctx": [" cx", " rc", "cb", "qa", "loc", "Context", "cn", " cs", "cca", "fw", "sc", "ca", " conn", "ct", "hw", "ck", "pc", "rc", "cs", "lc", " context", "cci", "conn", "jp", "cr", "client", "sq", "cmp", "ci", "cc", "vc", "anc", "cf", "xc", "context", "cl", "config", "conv", "cu", "cv", "c", "cas", "tc", " c", "ctrl", "cm", "mc", "cp", "tx", "bc", "pkg"], "newName": ["oldAddress", " newAddress", "newEmail", "Newname", "oldname", "oldEmail", "newAddress", "NewName", " newEmail", "newname", "NewAddress", " newname", "NewEmail"], "oldName": ["oldHome", "origname", " oldAddress", "OldName", "newHome", "OldHome", "newAddress", "OldAddress", " oldPath", "OldPath", "origName", " oldEmail", "Oldname", "oldname", " oldname", "oldPath", " oldHome", "oldAddress", "OldEmail", "newEmail", "oldEmail", "origPath", "origEmail"]}}
{"id1": "1362", "id2": "22752444", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubbleOrder", "bubblesort", "bubblerSort", "ubblesort", "ubbleOrder", "ubblingOrder", "bubblingCompare", "bubblingSort", "ubbleCompare", "ubblingSort", "bubbleCompare", "bubblingsort", "ubblingsort", "bubblessort", "bubblingOrder", "bubblesOrder", "ubbleSort", "bubblersort", "ubblingCompare", "bubblerCompare", "bubblesSort", "bubblerOrder", "bubblesCompare"], "a": ["an", "ga", "aaa", "address", "result", "img", "ata", "aw", "sup", "aux", "e", "am", "ba", "index", "abs", "ama", "A", "something", "auto", "s", "u", "another", "c", "sa", "aj", "m", "all", "au", "at", "active", "b", "empty", "any", "o", "ans", "aa", "list", "ma", "alpha", "la", "ab", "ae", "array", "p", "apps", "ad", "access", "tta", "l", "na", "data", "oa", "work", "d", "ac", "area", "f", "ack", "as", "va"], "swapped": ["rewapping", "Swapped", "waps", "swaps", "waped", "Swoped", "wapping", "rewaped", "rewapped", " swaps", "rewoped", "flapping", " swap", "rewaps", "wapped", "flapped", "rewap", "floped", " swapping", "swapping", "Swapping", "wap", "flap", "swap", "Swap", "Swaped", "swoped", "swaped", " swaped"], "i": ["qi", "v", "k", "iv", "ip", "ai", "sup", "ti", "mini", "I", "e", "ami", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "start", "ind", "u", "ui", "li", "hi", "multi", "ci", "next", "anti", "uni", "si", "mi", "ii", "y", "m", "j", "adi", "ie", "info", "ori", "b", "ki", "bi", "ri", "uri", "api", "p", "key", "gi", "h", "ix", "it", "fi", "in", "oi", "l", "di", "init", "ni", "d", "f", "pi", "module"], "tmp": ["foo", "emp", "v", "stuff", " ff", "test", "xxx", "st", "amp", "sup", "bb", "opp", "yy", "pre", "nb", "tt", "vt", "x", "tc", "obj", "angle", "kk", "m", "t", "j", "ie", "prev", "b", "front", "tv", "dest", "pad", "qq", "alpha", "p", "mmm", "addr", "append", "pp", "area", "part", "txt", "f", "mp", "cmp", "temp"]}}
{"id1": "21063400", "id2": "3024992", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"doImageProcess": ["doThumbnailFile", "doimageprocess", " doimageProcess", " doimageprocess", "doFileFile", "doimageProcess", " doImageprocess", "doImageFile", "doThumbnailProcess", " doimageFile", "doFileprocess", "doimageFile", "doFileProcess", "doImageprocess", "doThumbnailprocess", " doImageFile"], "request": ["image", "client", "writer", "query", "stream", "object", "input", "instance", "server", "result", "path", "report", "message", "resource", "xml", "url", "req", "model", "data", "type", "application", "method", "name", "Request", "reader", "header", "config"], "response": ["next", "image", "error", "success", "video", "client", "writer", "service", "full", " Response", "queue", "host", "output", "reply", "view", "object", "feed", "default", "version", "page", "server", "json", "complete", "cache", "example", "more", "result", "connection", "http", "location", "message", "report", "resource", "index", "pool", "results", "Response", "out", "description", "resp", "ception", "api", "onse", "model", "session", "collection", "status", "application", "wave", "document", "site", "body", "respond"], "imgSize": [" imgLength", "imgLen", "imgLength", "largeSize", "imageLength", "imageName", "hrType", "augLen", "imgWidth", "imgHeight", "imgsize", " imgWidth", "bgFamily", "augWidth", "dimsize", "imageSize", "imagesize", "bgLen", " imgsize", "imgScale", "imgC", "largeType", "ifName", "imgFamily", "imageLen", "dimLength", "imagType", "imgName", "refHeight", "imsize", "bgLength", "dimSize", " imgLen", "imagC", "refsize", "imSize", "imgType", "augFamily", "hrsize", "refSize", "imHeight", " imgFamily", "bgScale", "bgWidth", " imgScale", "imagsize", "bgSize", "largesize", "augSize", "largeC", "imLength", "ifLen", "dimHeight", "hrSize", " imgName", "hrC", "ifsize", "imagSize", "refLength", "imageScale", "ifSize"], "imageInputStream": ["photoInputStream", "imageStreamStream", "imageOutputStream", "imageFileStream", "imageUploadSteam", "imageContentStream", "imageStreamSteam", "fileInputString", "imageOutputView", "pictureInputSteam", "imageUploadFile", "imageInLength", "photoReadFile", "fileReadLength", "imageOutputSteam", "imageInputFile", "imageReadLength", "imageContentView", "fileInputLength", "imageUploadView", "imageInputView", "pictureInputstream", "imageInputSteam", "imageReadStream", "imageFileLength", "pictureInputStream", "imageContentSteam", "imageInString", "imageOutputstream", "pictureInputFile", " imageInputFile", "photoReadSteam", "fileInputstream", "fileReadStream", "imageStreamstream", "imageUploadstream", "imageContentFile", "imageStreamFile", "pictureUploadstream", "photoReadstream", "fileReadstream", " imageOutputSteam", "imageReadString", "imageInputLength", "pictureUploadSteam", "imageFilestream", "imageOutputFile", "imageFileString", "pictureUploadFile", "imageInputString", "photoInputstream", "photoInputFile", "fileInputStream", "imageInStream", "photoInputSteam", "fileReadString", " imageOutputView", "pictureUploadStream", "imageReadFile", " imageOutputStream", "imageUploadStream", " imageInputView", "imageInputstream", "photoReadStream", " imageInputSteam", "imageInstream", "imageReadstream", " imageOutputFile", "imageReadSteam"], "imageBytes": [" imageData", "fileBlocks", " imageBuffer", "imageByte", "imgbytes", "pictureData", "audiobytes", "pictureBytes", "imgData", "Imagebytes", "viewbytes", " imageByte", "ImageBytes", "imgBuffer", "imageBuffer", "viewBytes", "audioBuffer", "imageData", "pictureBlocks", "picturebytes", "viewData", " imageUrl", "filebytes", "ImageData", "audioByte", "fileBytes", " imagebytes", "audioBytes", "imageUrl", "imgBytes", "fileData", "imageBlocks", "ImageBlocks", "imagebytes", "imgByte", "viewUrl", "imgUrl"]}}
{"id1": "2022160", "id2": "5759961", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"write": ["writing", "flow", "written", "wrote", "service", "create", "send", "feed", "end", "flush", "w", "open", "run", "process", "play", "output", "sync", "add", "writer", "update", "read", "set", "code", "export", "store", "next", "Write", "out", "size", "close", "cycle", "dump", "data", "call", "connect", "put", "writ", "pipe", "kill", "lex", "exec", "append", "copy"], "byteBuffers": ["byteCompares", "bytesPackERS", "byteCornests", "bytebuffiners", "byteBuilderers", "byteOffers", " byteBuffERS", " byteCompares", "bytesBuffered", "byteOrdapers", "byteInfERS", "byteIntegelines", "bytebuffters", "byteCompers", "ByteOrdresses", "bytesDefers", "bytebuffinals", "byteBuffors", "byteBufferelines", " byteOffERS", " byteBuffors", "byteInferers", "bytesCornatters", "byteAkelines", "byteIntegers", "bytebufferers", "byteIntegatters", "byteDefERS", "byteOrderers", "wordBufferers", "byteCornlers", "bytesPackapers", "byteWritizers", "byteDefers", "byteBufferers", "bytesDefatters", " byteOffors", "byteWritlers", "bytesBuffests", " byteBuffiners", "byteChered", "byteAkizers", "byteBuffapers", "byteWritelines", "byteOrdresses", "bytebuffizers", "connectionBuffERS", "byteBuffinals", "connectionbuffERS", "byteChERS", " byteBuffeners", "byteBuffered", "byteComplers", "byteBuildERS", "byteBuffizers", "connectionBuffeners", "connectionBufferers", "byteBuffings", " byteBufferers", "bytesBuffERS", "ByteOrdERS", "byteBuffeners", "bytesCornests", "ByteOrders", "ByteOrderers", "bytesCorners", "byteBuffresses", "bytebuffers", "byteBuffererers", "byteBufflers", "byteHeadERS", "bytesBuffapers", " byteBuffinals", "byteCornatters", "byteOrdeners", "byteOrders", " byteOrdiners", "byteOrdiners", "ByteBufferers", "bytebuffests", "doubleHeadings", " byteBuffares", " byteOffters", "byteBuffereners", " byteOrders", "byteWritiners", "byteCompERS", "bytesBuffers", "byteBuffERS", " byteOrderers", "byteBuffests", "byteDefelines", "bytePackapers", "byteWriterers", "byteCornERS", "byteHeadings", "bytebuffelines", "doubleBuffered", "bytesDefelines", "ByteBufflers", " byteComplers", "byteAkers", " byteOrdeners", " byteBufflers", "wordBuffers", "bytesBuffatters", "byteBufferatters", "byteBuffelines", "bytesBuffelines", "byteHeaders", "ByteBuffERS", "bytebuffERS", "byteOrdinals", "connectionbufferers", " byteBuffters", "byteOffters", "byteBufferapers", "bytesAkelines", "byteHeadered", "byteIntegeners", "doubleBuffERS", "bytebufflers", " byteOffers", "bytebuffings", "byteOffERS", "byteInfers", "bytesPackerers", "byteWriters", " byteOrdinals", "byteChings", "bytesCornered", "bytesBufferers", "byteCornered", "bytesAkizers", "byteIntegERS", "ByteBuffresses", "doubleHeadERS", "bytesAkors", " byteCompers", "ByteBuffers", "connectionBuffers", "bytesPackers", "byteBufferlers", "bytePackerers", "bytebuffered", "wordBuffERS", "bytebuffresses", "byteOffors", "doubleHeaders", "doubleHeadered", " byteOrdERS", "byteDefatters", "bytebuffatters", " byteCompERS", "byteWritors", "bytebuffors", "byteInfatters", "byteChers", "byteBuilders", "bytePackERS", "byteBuffters", "byteBufferERS", "connectionbuffers", "connectionbuffeners", "byteCorners", "bytePackers", "bytesBuffors", "byteCornares", "bytesAkers", "byteOrdERS", "byteAkors", "bytesBuffizers", "byteBuffiners", "byteBuffares", "bytebuffeners", "bytesDefERS", " byteOrdlers", "byteBuffatters", "byteOrdlers", "doubleBuffings", "wordBuffatters", "byteBuildatters", "doubleBuffers", "byteInteginals"], "m_initialOutBuffer": ["m_initialoutLine", "m_initialInChannel", "m_InitialOutputBuffer", "m_finaloutChannel", "m_initialoutBuffer", "m_finalOutBuffer", "m_initialOutMessage", "m_initialInLine", "m_initialClientBuffer", "m_finalOutLine", "m_initialOutBuff", "m_finalInCache", "m_finaloutBuff", "m_initialNewMessage", "m_finalInBuffer", "m_initialAuthAddress", "m_initialAuthLine", "m_initialOutFile", "m_initialInFile", "m_originaloutFile", "m_InitialOutFile", "m_initialOutputLayer", "m_finaloutBuffer", "m_initialInBuffer", "m_initialOutputMessage", "m_initialOutLine", "m_finalOutMessage", "m_initialInMessage", "m_initialSocketBuffer", "m_finalInMessage", "m_originalOutLine", "m_initialNewBuffer", "m_InitialOutBuffer", "m_initialoutAddress", "m_initialOutLayer", "m_finalInFile", "m_initialSocketLayer", "m_initialInLayer", "m_originalOutFile", "m_initialShortFile", "m_InitialOutputFile", "m_originaloutLine", "m_initialoutCache", "m_initialOutChannel", "m_initialShortBuffer", "m_finalOutFile", "m_initialShortCache", "m_initialClientLine", "m_initialNewBuff", "m_finalOutChannel", "m_initialSocketHeader", "m_InitialOutputLayer", "m_InitialOutHeader", "m_originalOutBuffer", "m_initialClientFile", "m_initialoutFile", "m_initialOutputFile", "m_initialInAddress", "m_finalOutCache", "m_initialClientBuff", "m_initialOutputChannel", "m_initialInHeader", "m_initialShortChannel", "m_originaloutAddress", "m_finalOutBuff", "m_originaloutBuffer", "m_initialInBuff", "m_initialSocketFile", "m_initialAuthBuffer", "m_finalInLine", "m_initialOutHeader", "m_initialOutputHeader", "m_initialOutAddress", "m_initialAuthFile", "m_initialOutCache", "m_initialNewFile", "m_originalOutAddress", "m_initialOutputBuff", "m_finalInBuff", "m_initialInCache", "m_InitialOutputHeader", "m_finalInChannel", "m_initialoutChannel", "m_InitialOutLayer", "m_initialoutBuff", "m_initialOutputBuffer", "m_finaloutFile"], "buffer": ["resource", "temp", "window", "channel", "stack", "queue", "page", "null", "layer", "block", "file", "binary", "limit", "comment", "source", "f", "pool", "wave", "flush", "input", "cur", "cache", "slice", "output", "bridge", "table", "engine", "builder", "string", "read", "phrase", "response", "loader", "server", "document", "reader", "timeout", "console", "template", "Buffer", "header", "copy", "re", "base", "event", "worker", "shell", "object", "array", "fb", "uffer", "er", "row", "client", "FFER", "data", "port", "callback", "batch", "address", "feed", "view", "ker", "message", "back", "writer", "buf", "buff", "cell", "transfer", "iter", "bc", "config", "url", "holder"], "buffers": ["Buffers", "buffered", "bufaches", " buffars", "bufered", "buffors", "phresses", " buffler", "buffler", "Bufferers", "bufars", "affers", "buferers", "bufers", "affaches", " buffering", "ufors", "ufers", "buffages", "phers", "bufering", "bufresses", " buffresses", "bufERS", "buffering", "bufators", " buffages", "transformler", "transformering", "buffators", "Buffered", "buffaches", "affors", "ufaches", "transformers", "ufering", "Buffars", "buffERS", " buffERS", "phages", "phators", " buffators", "bufages", "buffresses", "transformERS", "bufler", " bufferers", "bufors", "affering", " buffered", "bufferers", "buffars"], "result": ["re", "err", "ver", "resource", "Result", "view", "inner", "event", "val", "function", "json", "grade", "match", "consumer", "or", "up", "cache", "message", "use", "output", "rate", "info", "status", "driver", "future", "flash", "r", "session", "rc", "success", "successful", "winner", "er", "ret", "diff", "out", "response", "row", "manager", "report", "test", "sr", "runner", "request", "search", "data", "user", "valid", "true", "cup", "card", "error", "comment", "complete", "results", "res", "date", "default", "acc", "f", "url"], "encrypted": ["image", "body", "temp", "stream", "inner", "flush", "entry", "channel", "available", "text", "cache", "packed", "extra", "pad", "flash", "padding", "selected", "layer", "secret", "interrupted", "loader", "internal", "binary", "transfer", "reader", "config", "source", " data"]}}
{"id1": "9236363", "id2": "873012", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"unJarStart": ["syncServerPath", "copyJarPath", "copyJarStart", "copyjarRest", "syncServerRest", "syncJarRest", "copyJarEnd", "copyServerRest", "copyjarEnd", "copyServerPath", "copyjarPath", "syncJarEnd", "copyJarRest", "copyZipRest", "syncJarStart", "copyjarStart", "copyServerEnd", "copyServerStart", "copyZipStart", "copyZipEnd", "syncServerEnd", "syncServerStart", "copyZipPath", "syncJarPath"], "jarPath": ["relEntry", "Jarpath", "jarLog", "jarText", "zipPath", "jamLog", "zippath", "archivePath", " jarpath", "javaPath", "jamPath", "javaCh", "jarName", " jarText", "JarName", "narCh", "jarContent", " jarContent", " jarUrl", "garText", "JarFile", "relFile", "archivepath", "javaFile", "badPath", "jarpath", "garUrl", "javaName", "badLog", "jarFile", "JarCh", "narPath", "javaText", " jarLog", "garPath", " jarFile", " jarDir", "javaEntry", "garFile", "javaUrl", "jarUrl", "jarCh", "archiveDir", "javapath", " jarName", "badpath", "javaLog", "badUrl", "archiveLog", "zipEntry", "zipFile", "jampath", "garpath", "narpath", "JarContent", "garContent", "jamDir", "relpath", "narName", "JarPath", "jarDir"], "jarEntryStart": ["jarEntSource", " jarEntryFollow", "jarEntPart", "jarEntryName", " jarImportStart", "tarEntryPart", "jarFileSource", " jarFileStart", "jarFileName", "jarImportPart", "jarEntryPart", "jarEntrySource", "jarEntStart", " jarFilePart", " jarEntrySource", "jarFileStart", " jarEntryEnd", "jarEntName", "jarFileFollow", " jarImportPart", "jarEntryFinish", "jarentryName", "jarFileEnd", "jarImportName", "jarentryStart", "tarentryName", "jarEntryFollow", "jarAttemptStart", "tarEntrySource", "jarEntryEnd", "jarImportStart", " jarFileEnd", "jarAttemptPart", "tarEntryStart", " jarFileFinish", "jarImportFollow", " jarImportEnd", "jarAttemptFollow", "jarentrySource", "jarFileFinish", " jarFileName", "jarImportFinish", " jarEntryFinish", "jarentryPart", "tarentryStart", "jarAttemptEnd", "jarFilePart", "tarentrySource", " jarImportFollow", "jarPartStart", "jarImportSource", "tarentryPart", "jarPartFinish", " jarFileSource", " jarEntryName", " jarEntryPart", "jarImportEnd", "jarPartEnd", "jarPartPart", "tarEntryName"], "path": ["zip", "then", "root", "base", "temp", "output", "resource", "patch", "host", "content", "default", "file", "archive", "context", "conn", "graph", "it", "mount", "url", "PATH", "ph", "step", "string", "id", "clean", "location", "next", "source", "cache", "dir", "ion", "ath", "work", "parent", "route", "object", "test", "name", "th", "left", "cookie", "boot", "directory", "uri", "json", "Path", "inner", "system", "mode", "dest", "wd", "session", "request", "p", "template", "image", "prop", "method", "error", "api", "pass", "key", "pattern", "type", "config", "data", "text", "log", "folder", "po", "home", "ha", "pointer", "prefix", "ctx", "ith", "right", "code", "loc"], "relPath": ["RelPath", "relativeDir", " relName", "RELPath", "RELpath", "Relpath", " relPos", " relDir", "RELPos", "relPos", "relativepath", "relDir", "RelName", "relativePath", "RelDir", "relativePos", "relName", "RELName", " relpath", "relpath", "relativeName"], "jar": ["zip", "ssl", "pkg", "her", " tar", "server", "mag", "drop", "fire", " manifest", "per", "ge", " parser", "java", "tar", " java", " capsule", "jo", " dir", "dr", "sheet", "zone", "keeper", "magic", "ler", "bag", " archive", "er", " war", "bar", "Jar", "cache", "tab", "dir", "browser", "sr", "open", "pipe", "war", "archive", " module", "rar", "log", "plugin", "ball", "folder", "start", "pack", "car", "sl", "spin", "url", "com", "ser", "parse", "sp", "cookie", "gap", "xml", "ar", "module", "space"], "entries": ["entryers", "countries", "ENTlements", "antlements", "countEntry", "addries", "entrys", "ientlements", "Entursions", "adders", "endories", "antursions", "entryensions", "entEntry", "quries", "entensions", "Entry", "entursions", "itrys", "iters", "counters", "Entrys", "Entries", "addensions", "quies", "endries", "antry", "endrys", "itries", "ENTies", "entlements", "countensions", "Entories", "enters", "qulements", "enties", "addEntry", "Entlements", "itories", "Entents", "ENTries", "entories", "Enters", "entryries", "ientry", "antries", "enders", "ENTents", "ientursions", "ientries", "entents", "entryEntry", "quents", "Enties"], "entry": ["zip", "ry", "address", "server", "resource", "be", "add", "ie", "ge", "se", "jo", "ries", "Entry", " Entry", "key", "ler", "la", "pie", "ent", "part", "reader", "ce", "module", "je", "r", "cat", "de", "or", "cel", "name", "e", "lie", "pack", "it", "parse", "mer", "obj", "oe", "element", "enter"], "jarEntry": ["jarentry", "jobentry", "carEnt", "serName", "jarName", "javaPath", "archiveEntry", "jarRule", "archiveElement", "archiveName", "archiveEnt", "celFile", "jobEntry", "jobPath", "javaFile", "serEntry", "javaElement", "javaName", "jarFile", " jarImport", " jarEnt", "javaEntry", "jobImport", "javaImport", "archiveRule", "javaentry", "jarEnt", "carEntry", "carPath", "serElement", " jarentry", "jarImport", "javaRule", "javaEnt", "serFile", "carElement", "celEntry", " jarElement", "celRule", "celEnt", "archiveFile", "jarElement"], "ze": ["zip", "fe", "zer", "ipe", "ke", "be", "zes", "zy", "ie", "kee", "ge", "z", "se", "aze", "jo", "ide", "te", "ine", " ace", "za", "ja", "ce", "je", "li", "ZE", "le", " je", "ne", "cel", "xe", "e", "zi", "sl", "pe", "zo", "zen", "code", "zie"], "bin": ["zip", "index", "info", "base", "sin", "pin", "bis", "resource", "lock", "ini", "inner", "abin", "arin", "zone", "in", "bar", "binary", "lib", "proxy", "login", "len", "bas", "data", "file", "body", "vin", "bb", "log", "bi", "bank", "init", "plugin", "bn", "bit", "isin", "kin", "gi", "di", "spin", "bot", "abi", "cin", "inn", "win", "boot"]}}
{"id1": "8119563", "id2": "18693224", "code1": "    protected boolean checkLink(URL url) {\n        try {\n            URLConnection connection = url.openConnection();\n            connection.connect();\n            return true;\n        } catch (IOException e) {\n            MsgLog.error(\"DapParser.checkLink(): IOException: \" + e.toString());\n            return false;\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"checkLink": ["checklink", "CheckLink", " checklink", "checkConnect", "loadConnect", "loadLink", " checkLine", "loadLine", "Checklink", "checkLine", "CheckConnect", "loadlink", "CheckLine", " checkConnect"], "url": ["link", "image", "base", "URL", "service", "resource", "Url", "open", "entry", "http", "l", "conn", "object", "page", "string", " URL", "class", "null", "element", "route", "uri", "client", "name", "location", "socket", "ssl", "proxy", "loc", "server", "host", "file", "instance", "str", "sl", "or", "config", "source", "address"], "connection": ["link", "image", "unit", "resource", "ion", "config", "function", "open", "channel", "Connection", "http", "l", "b", "conn", "writer", "object", "application", "builder", "c", "position", "relation", "handler", "io", "uri", "network", "response", "client", "character", "communication", "server", "data", " Connection", "connect", "i", "database", "timeout", "connected", "loc", "socket"]}}
{"id1": "13666876", "id2": "19549577", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"transformSingleFile": ["transformMultiSourceFile", " transformOneFiles", " transformOneSourceFile", "transform1File", " transformOneFile", "transformOnePath", "transformsinglefile", "transformSinglefile", " transformOnePath", "transformsingleFiles", "transformOnefile", "transformMultiFile", " transformSinglePath", "transformsingleSourceFile", "transformOneFile", "transformMultiFiles", "transform1SourceFile", "transformOneSourceFile", "transformsingleFile", "transformSingleFiles", " transformSingleSourceFile", "transformSinglePath", "transformOneFiles", " transformOnefile", "transformMultifile", "transformSingleSourceFile", " transformSinglefile", "transform1Files", " transformSingleFiles", "transform1Path"], "xed": ["xeded", " Xeb", "xxeb", "xxED", "exED", "xteds", "rexed", " xedited", " xended", "xted", "exed", " Xed", " xeds", "rexeds", "Xed", " xeded", "exEd", "xxended", "exeds", " xED", "xedited", "xxed", "exeded", "rexED", "Xended", "xxedited", "Xedited", "xeb", "exeb", "xED", "xeds", "xended", "Xeded", "xEd", "xxeded", " Xeds", " Xeded", "xxeds", "xtEd", "xtED", "rexeded", " xEd"], "node": ["event", "root", "index", "path", "copy", "op", "option", "document", "message", "Node", "slave", "instance", "child", "set", "location", "day", "query", "edge", "part", "source", "load", "no", "live", "component", "parent", "config", "file", "route", "none", "page", "object", "row", "name", "tree", "image", "leaf", "ode", "shape", "error", "menu", "loc"], "dob": ["ddod", "adub", "ddOB", " dod", "DOb", "ddOb", " dub", "dOB", "DOB", " dOB", "adOB", "dod", "dOb", "ddob", "adob", "ddub", " dOb", "adod", "Dub", "Dob", "dub"], "mySrc": ["MyAssrc", " myEssrc", "myssrc", "mySRC", "MyAsrc", "MyAsource", "MyEsRC", "myAsource", "myEsst", "MySsrc", "MySrb", "myDrc", "MySRC", "MyAsRC", "MySrc", "myAsRC", "myDsRC", "mySsrc", "MyEsrc", "mySst", " mySRC", "myDst", " mySsrc", " myEsrc", "myDssrc", "myEsRC", "MyEssrc", "myEsource", "myEssrc", " myEsst", "mySource", "myEsrc", "myDRC", "MySource", "myAsrb", " mySst", "mysrc", "myDsrc", "mysRC", "mysrb", "myEsrb", " myEsRC", "myAssrc", "mySrb", "MyEsrb", "myDsource", "myAsst", "myAsrc"], "mySrcF": ["mySRCf", "mySRCFile", "mySrcM", "mySRCM", "myCrcF", "mySsrcE", "mySsrcM", "myCRCf", "mySrcf", "mySourcef", "mySckF", "mySckM", "myEssrcf", "mySourceE", "mySRCE", "myCrcM", "myCRCE", "myEsrcFile", "mySsrcf", "myCrcE", "myEsrcF", "myEsrcE", "mySckf", "myCRCF", "myEsrcf", "mySourceF", "myCrcf", "mySourceFile", "mySRCF", "mySckE", "mySrcE", "mySsrcF", "mySsrcFile", "myEssrcF", "mySrcFile", "myEssrcFile", "myEssrcE", "myCRCM"], "myOutF": ["myInD", "myOutputC", "MyOutFile", " myOutE", "myOUTE", "myOUTFF", "myInFF", "myOutputF", "MyOutFF", "myInFile", "MyInD", "MyInF", "myOutQ", "myOutPF", "myOutputFile", "MyOutE", "MyInPF", "myInE", "myOutE", " myOutC", " myOutputFile", "MyInFF", "myOUTQ", "myOutFile", "myoutFile", "myInQ", "myInF", " myOutFile", "MyInQ", "myoutPF", "myoutE", "myoutF", "MyInFile", "myOUTF", "myOUTFile", "MyOutF", " myOutputE", "myOutputE", "myInC", "myoutC", " myOutputC", "MyInE", "myInPF", "myoutFF", "myOutC", "myOutFF", "MyOutQ", "MyOutPF", "myOUTD", "MyOutD", "myOUTPF", "myOutD", " myOutputF"], "co": ["aco", "cu", "lo", "colo", "fe", "cc", "ko", "ee", "cmp", "cf", "rc", "coe", "auto", " Co", "ck", "con", "mo", "c", "ctrl", "fc", "cb", "o", "cho", "bo", "CO", "company", "la", "oo", "flo", "oe", "so", "no", "ce", "lc", "cache", "ob", "BO", "ca", "bb", "che", "isco", "po", "coll", "fo", "ci", " CO", "pc", "mc", "CC", "bc", "ico", "Co", "pe", "can", "conf", "gro", "OO", "cur", "cca", "code", "cos", "loc"], "x3dvFile": ["x3rdvfile", "x3ndsvfile", "x3dvPage", "x3dsvSource", "x3dVfile", "x3dvfile", "x3dvsfile", "x3rdVFiles", "x3ndvSource", "x3ndvFiles", "x3ndsvSource", "x3dvFiles", "x3dsvFile", "x3dvsFile", "x3dffile", "x3rdvFile", "x3dfFile", "x3ndvFile", "x3dVSource", "x3dVFiles", "x3dsvFiles", "x3dVPage", "x3dsvfile", "x3rdVPage", "x3dvsPage", "x3dvSource", "x3ndsvFile", "x3ndsvFiles", "x3dfFiles", "x3dfSource", "x3rdVFile", "x3dVFile", "x3rdVfile", "x3ndvfile", "x3rdvPage", "x3dvsFiles", "x3dsvPage", "x3rdvFiles"], "fis": ["elfs", "elfisa", "fs", "elfiss", "elfus", " fs", "Fbs", "Fus", "fi", " fiss", "elfbs", "refiss", "fus", " fus", "refi", "refisa", "elfi", "fisa", " fi", "Fis", " fisa", "fbs", "refis", "fiss", " fbs", "Fs", "elfis"], "gzos": ["wxis", "gzis", "wxo", "zos", "zxos", "wxOS", "gzOS", "wxos", "gzo", "zipOS", "bagos", "bagOS", "zops", "bagis", "zipops", "zxops", "zis", "zxis", "zipis", "zipos", "zxo", "zipo", "gzops", "bago", "zOS", "bagops", "zxOS", "zo"], "buf": ["buffer", "bf", "bd", "bh", "uint", "cap", "lb", "cb", "result", "grab", "done", "bin", "ff", "feat", "queue", "uf", "la", "bag", "cv", "rb", "ab", "cas", "uc", "buff", "len", "data", "fb", "av", "box", "vec", "port", "dec", "db", "bytes", "bc", "Buff", "seq", "b", "br", "fab", "ba", "pad", "block", "batch", "cur", "loc"], "ret": ["val", "ry", "fun", "Ret", "num", "id", "att", "bf", "rf", "rc", "continue", "res", "ref", "result", "match", "rt", "ft", "en", "fin", "nt", "pet", "len", "r", "alt", "default", "rets", "out", "rep", "reply", " RET", "bit", "success", "ver", "b", "reg", "obj", "det", "count", "f", "repl", "RET", "re"]}}
{"id1": "22801734", "id2": "4016687", "code1": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        String sFTP = \"ftp.miservidor.com\";\n        String sUser = \"usuario\";\n        String sPassword = \"password\";\n        try {\n            System.out.println(\"Conectandose a \" + sFTP);\n            client.connect(sFTP);\n            boolean login = client.login(sUser, sPassword);\n            if (login) {\n                System.out.println(\"Login correcto\");\n                boolean logout = client.logout();\n                if (logout) {\n                    System.out.println(\"Logout del servidor FTP\");\n                }\n            } else {\n                System.out.println(\"Error en el login.\");\n            }\n            System.out.println(\"Desconectando.\");\n            client.disconnect();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"setup": ["test", "clean", "prep", "parse", "load", "Setup", "software", "boot", "strap", "set", "upload", "build", "construct", "info", "handler", "config", "install", "ize", "copy", " Setup", "up", "process", "init", "download", "figure", "exit", "run"], "path": ["address", "url", "base", "PATH", "cache", "alias", "platform", "zip", "folder", "host", "filename", "location", "string", "name", "context", "pointer", "Path", "archive", "pattern", "image", "prefix", "code", "format", "root", "route", "directory", "dest", "loc", "loader", "uri", "ath", "resource", "content", "source", "data", "file", "dir", "home", "temp"], "jarFile": ["jaDir", "jafile", "zipF", " jarF", "jaPlace", "jaFile", "JarDir", "rarBody", "zipPath", "zipfile", "zipDir", "jarF", "jarPath", "zipLibrary", "jarBody", "JarLibrary", "rarFile", "javaPlace", " jarBody", " jarPath", " jarLibrary", "jarDir", " jarfile", "JarFile", "jarLibrary", "zipFile", "JarF", " jarDir", "javafile", "javaFile", "Jarfile", "javaDir", "rarfile", "jarfile", "zipBody", "rarPath", "jarPlace", " jarPlace"], "f": ["v", "fp", "cf", "base", "url", "cache", "w", "e", "feed", "io", "folder", "x", "df", "tf", "fb", "rf", "flat", "fm", "s", "c", "fe", "files", "fa", "m", "t", "i", "r", "g", "b", "o", "F", "fc", "fr", "fs", "p", "h", "fd", "fi", "af", "l", "lf", "file", "dir", "fw", "d", "bf", "framework", "full", "sf"], "parent": ["test", "url", "base", "ip", "pa", "paren", "cache", "port", "child", "folder", "function", "host", "target", "location", "parents", "name", "offset", "to", "image", "prefix", "type", "root", "directory", "loc", "css", "resource", "p", "point", "line", "source", "pool", "file", "dir", "and", "Parent", "home", "part", "ctx", "fat", "cmp", "acl"], "buf": ["Buffer", "uf", "bc", "cap", "v", "header", "img", "exc", "bb", "gb", "ob", "bin", "tmp", "br", "cv", "bd", "bp", "func", "fb", "seq", "queue", "len", "bag", "batch", "lb", "Buff", "b", "config", "loc", "pad", "padding", "wb", "buffer", "ab", "la", "bytes", "rb", "fd", "data", "pool", "bh", "src", "bf", "lim", "abc", "cb", "buff", "bu"], "zipinputstream": ["zipimportsource", "zipinfcontrol", "zinputthread", "archiveInputstream", "zipInputstream", "archiveinputsample", "zipviewchannel", "fileoutputsource", "fileInputproblem", "zinputchannel", "fileoutputStream", "fileinputsteam", "zipviewstream", "zipinputthread", "zipinputchannel", "forceinputStream", "zipoutputsource", "zipoutputstream", "zipInputsource", "zipInputchannel", "zipoutputchannel", "zipentryStream", "fileoutputsteam", "zInputcontrol", "zipimportStream", "zipstreamStream", "zipoutputproblem", "archiveInputStream", "zipstreamsteam", "zipoutputsample", "zipinputsource", "zInputStream", "zipoutputsteam", "zipinputStream", "forceinputstream", "forceentryStream", "archiveinputstream", "zipinputsample", "zInputchannel", "zipinfStream", "zipimportstream", "zipbitStream", "zInputstream", "zipentrysteam", "zipInputproblem", "fileinputsource", "forceentrystream", "archiveinputStream", "zipbatchproblem", "fileinputproblem", "zipInputsteam", "forceinputsteam", "zipinputsteam", "zinputStream", "zipInputsample", "zipentrystream", "zipviewStream", "zinputcontrol", "zipbitthread", "zipoutputcontrol", "zipimportsample", "fileinputstream", "zipInputStream", "archiveInputsample", "zipinfstream", "zipoutputthread", "zipstreamstream", "forceentrysteam", "zInputthread", "fileinputStream", "zipoutputStream", "zipinputcontrol", "fileInputStream", "zipbatchStream", "zipinputproblem", "zipbitstream", "zipInputthread", "zinputstream", "zipbatchstream", "zipInputcontrol", "fileInputstream"], "zipentry": ["lockelement", "zipenter", "seaEntry", "zipelement", "Zipconnection", "Zipentry", "zipconnection", " zipconnection", "filearchive", "Zipenter", "ziparchive", "feedentry", "ceentry", "seaelement", "zoneentry", " zipEntry", "ceenter", "zoneapi", " ziparchive", "zarchive", "zEntry", "zipreader", "zipEntry", "zipapi", "cereader", "feedconnection", " zipenter", "ceEntry", "seaentry", "zipinner", "seaenter", "fileentry", " zipinner", " zipapi", "Ziparchive", "lockEntry", "installelement", "ZipEntry", "lockentry", " zipelement", "installinner", "Zipreader", "zoneEntry", "Zipapi", "installentry", "Zipelement", "feedEntry", "feedarchive", "fileelement", "zonereader", "lockenter", "zentry", "fileEntry", "zreader", "Zipinner", "installEntry", " zipreader"], "entryName": ["nextname", "fieldPart", "fieldname", " entryType", "imageEl", " entryPath", "EntryType", "nextPath", "imagename", "Entryname", "resourcePart", "nextEl", "fieldPath", "entryPath", "resourceType", "EntryPart", " entryname", " entryPart", "imageName", "entryPart", "entryEl", " entryEl", "nextName", "imagePath", "entryname", "fieldName", "EntryEl", "EntryPath", "resourceName", "EntryName", "resourceEl", "entryType"], "n": ["an", "v", "z", "k", "ng", "w", "N", "left", "e", "un", "nb", "x", "nl", "nr", "ns", "name", "s", "nor", "u", "ln", "c", "no", "len", "nn", "y", "m", "all", "t", "en", "j", "i", "r", "g", "b", "number", "nu", "o", "nt", "ner", "sn", "p", "h", "dn", "l", "na", "in", "pos", "num", "d", "ne", "nc"], "fileoutputstream": ["fileoutputtrack", "fileoutputuser", "filetextform", "filedownloaduser", "fileOutputtrack", "fileinformationview", "resourceoutputview", "zipOutputStream", "zipinputpool", "fileinputstream", "zipOutputtrack", "resourceoutputstream", "filetextStream", "fileinputfile", "fileinputmess", "fileconnectionStream", "zipOutputmess", "filetextpool", "fileconnectionuser", "fileinformationStream", "fileoutputform", "fileupdatestream", "fileoutStream", "fileOutputmess", "resourceOutputstream", "fileOutputuser", "fileoutputStream", "resourceOutputStream", "zipoutputtrack", "fileoutform", "fileoutstream", "resourceOutputfile", "fileinputpool", "zipOutputstream", "filetextstream", "fileoutputfile", "fileinformationfile", "fileupdatemess", "filedownloadstream", "fileinputStream", "zipoutputStream", "fileinputform", "zipoutputmess", "fileOutputstream", "fileOutputStream", "fileoutputpool", "filedownloadtrack", "fileconnectionstream", "fileinputview", "zipinputStream", "filedownloadStream", "fileoutpool", "fileoutputmess", "zipinputform", "fileOutputview", "resourceoutputStream", "fileinformationstream", "fileupdateStream", "zipoutputuser", "fileOutputfile", "resourceoutputfile", "fileconnectiontrack", "zipoutputstream", "zipOutputuser", "fileoutputview", "zipoutputpool", "resourceOutputview", "zipoutputform"], "newFile": ["newDir", "largeLine", "nextEntry", "oldLine", "updateDir", " newPlace", "baseFolder", " newEntry", "basefile", " newFolder", "newLine", "NewPlace", "newChild", "nextfile", "updateLine", " newDir", "NewDir", "newEntry", "updatePlace", "NewFile", "updateFile", "largeFolder", " newfile", "nextFolder", " newChild", "oldFolder", "largeFile", "baseFile", "oldFile", "oldChild", "newfile", "newPlace", "newFolder", "nextFile", "largeChild", "baseEntry", "NewLine", " newLine"], "arch": ["ure", "url", "error", "ver", "art", "app", "id", "platform", "dict", "ar", "ace", "model", "family", "ress", "boot", "itect", "host", "patch", "ext", "archive", "hard", "Arch", "code", "auth", "build", "chart", "archs", "type", "release", "arc", "aug", "library", "cast", "arm", "tag", "back", "anc", "oct", "install", "inst", "ARCH", "var", "array", "version", "mount", "mac", " architecture", "rc", "work", "addr", "ch", "act", "urn", "ror", "brand", "ith", "cat", "ask"], "key": ["pair", "k", "base", "client", "prop", "str", "id", "nice", "country", "x", "val", "KEY", "name", "string", "word", "section", "link", "character", "lease", "type", "ie", "connection", "rule", "Property", "option", "attribute", "service", "search", "Key", "col", "data", "char", "entry", "letter", "style", "secret", "keys", "field", "variable", "value", "part", "item"], "property": ["feature", "address", "position", "description", "prop", "model", "term", "function", "filename", "string", "language", "profile", "name", "section", "lock", "prefix", "argument", "character", "expression", "properties", "operation", "lease", "type", "username", "info", "ie", "class", "number", "object", "Property", "integer", "option", "attribute", "resource", "p", "service", "translation", "data", "style", "variable", "contract", "field", "value", "unit", "part", "item", "module"], "x64": [" x68", "xp68", "rx32", "xx224", "rx224", "ux59", "x58", "x224", "rx64", "xx48", "rx48", "rex64", "xx64", "rex32", "x48", "ex32", " x59", "ux58", "x59", "x32", "wx64", " x32", "xp58", "xp32", "rex68", " x58", "ex224", "wx59", "x68", "ex48", "xx32", "wx58", "xp64", "ux64", "rex58", "ex64"]}}
{"id1": "16215393", "id2": "19868933", "code1": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"importSequences": [" importsequements", " importSequFiles", "importMultipleements", " importSequence", "importsequements", "importMultipleences", "importSequements", "importInternence", "importMultipleence", " importSequements", "importInternements", "importSequence", "importInternences", " importsequence", "importMultipleFiles", "importInternFiles", "importsequences", "importSequFiles", " importsequFiles", "importsequFiles", " importsequences", "importsequence"], "names": ["words", "models", "files", "tags", "strings", "headers", "hops", "packages", "ns", "they", "pres", "ens", "lines", "keys", "objects", "obs", "services", "params", "images", "modules", "ons", "members", "frames", "codes", "states", "Names", "nos", "mas", "ames", "ans", "works", "users", "views", "ins", "ids", "named", "stars", "ports", "paces", "sheets"], "sequences": ["Sequences", "contencies", "equence", "equences", "Sequencies", "sequelines", "Sequances", "equations", "Sequelines", "contelines", "responsencies", "occupencies", "sequence", "responsences", "variencies", "occupations", "variances", "contences", "sequencies", "responsence", "sequances", "occupences", "equencies", "contances", "sequations", "occupence", "varielines", "responsations", "variences"], "is": ["lis", "os", "in", "ip", "Is", "h", "us", "p", "bis", "iso", "isa", "i", "s", "app", "init", "its", "ls", "es", "isi", "ris", "IS", "info", "or", "iss", "ios", "isc", "has", "ir", "out", "ais", "url", "close", "api", "sis", "are", "it", "ar", "as"], "helper": ["compen", "thelpers", "hypers", "Helhel", "Helpers", "permer", "hepers", "Heller", "helpar", "calar", "calping", " helPER", " Heller", "heper", "thelper", "comhel", "hyf", "helpper", "Helpen", "calPER", "helpmer", "calper", "perpers", " Helpers", "theller", "helping", "perper", "perler", " helar", "helf", "helhel", "shhel", "perf", "comper", "helpers", "helpping", " helping", "helpen", "shper", "thelmer", "hyler", "heller", "helmer", "Helper", "heler", "helPER", " Helper", "shpen", "helppers", " Helmer", "hemer", "comler", "hyper", "Helf", "shler", "helpPER", "helar", "helpler"], "ch": ["gr", "chan", "arch", "h", "p", "cher", "ctx", "cp", "q", "ce", "quote", "el", "sk", "che", "ci", "coll", "qu", "conn", "sh", "th", " chunk", "cht", "length", "code", "pr", "cho", "cur", "cor", "se", "change", "conf", "bh", "unch", "Ch", "CH", "col", "enc", "anch", "k", "div", "err", "ich", "char", "cl", "ach", "sch", "cha", "chi", "ech", "chu", "ur", "cmp", "zh", "cmd", "c", "och", "hex"], "line": ["job", "sl", "sync", "lf", "pos", "entry", "block", "cell", "e", "page", "lc", "cle", "lines", "Line", "lin", "code", "content", "word", "row", "file", "str", "end", "iter", "part", "url", "letter", "pass", "base", "inline", "data", "char", "cl", "LINE", "text", "l", "frame", "string", "header", "nl", "source", "c"], "tokenizer": ["okenize", " tokenner", " tokenize", "tokenize", "okenner", "Tokenner", "Tokenizer", "okenizer", "tokeniz", "Tokenizing", " tokenizers", "Tokeniz", "okenizing", "Tokenize", " tokenizing", "Tokenizers", " tokeniz", "tokenner", "tokenizing", "okeniz", "okenizers", "tokenizers"], "name": ["next", "size", "attr", "n", "label", "key", "object", "comment", "default", "id", "ame", "info", "alias", "connection", "path", "time", "word", "str", "part", "start", "NAME", "url", "letter", "prefix", "pass", "base", "data", "type", "er", "Name", "number", "search", "string", "named", "filename", "non"], "seq": ["vals", "job", "la", "buffer", "cas", "iq", "fast", "ctx", "sec", "queue", "quote", "sci", "chain", "feed", "sequence", "parse", "pkg", "lc", "phrase", "val", "que", "info", "length", "closure", "resp", "str", "config", "feat", "iter", "sel", "buf", "req", "unit", "vec", "zip", "conv", "data", " sequence", "sq", "struct", "live", "cl", "text", "wave", "sem", "frame", "string", "list", "cb", "c", " buf"]}}
{"id1": "18504192", "id2": "20190303", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferFiles", "copyfile", "copyStream", "CopyFile", "copyFiles", "transferfile", "transferFile", " copyfile", " copyStream", "Copyfile", "CopyFiles", "CopyStream", "transferStream", " copyFiles"], "in": ["buffer", "copy", "inn", "inner", "c", "ac", "at", "info", "i", "input", "src", "image", "or", "IN", "data", "m", "ini", "old", "io", "url", "base", "name", "b", "min", "index", "ins", "In", "inc", "again", "file", "parent", "part", "login", "id", "reader", "diff", "bin", "d"], "out": ["p", "call", "copy", "cache", "output", "client", "c", "point", "w", "ex", "OUT", "conn", "line", "data", "writer", "object", "dest", "io", "n", "base", "name", "b", "obj", "password", "exec", "string", "connection", "external", "prefix", "Out", "outs", "again", "file", "temp", "part", "err", "o", "inc", "target"], "source": ["copy", "se", "client", "sync", "use", "component", "view", "slave", "ie", "i", "input", "ources", "ource", "src", "project", "sin", "SOURCE", "get", "writer", "Source", "service", "proxy", "from", "storage", "self", "dest", "core", "clone", "null", "server", "sl", "secure", "connection", "scope", "origin", "size", "channel", "stream", "settings", "iter", "ssl", "slice", "reader", "unit", "parent", "start", "target"], "destination": ["declification", "destinated", "destification", "testinations", " destining", "Destinated", "testinated", "dependination", "continated", "Destinations", "declinator", "continator", "contination", " destinations", "declinated", "testinator", " destinator", "testination", " destinated", "Destining", "Destination", "dependinator", "declination", "destinator", "contining", "dependinated", "Destinator", "destinations", "Destification", "destining", "dependification"]}}
{"id1": "14390569", "id2": "13499897", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"title": ["image", "body", "html", "resource", "section", "prefix", "itle", " Title", "content", "format", "itles", "version", "alpha", "license", "text", "message", "details", "filename", "label", "page", "string", "summary", "heading", "subject", "phrase", "type", "part", "notes", "ppa", "Title", "size", "name", "term", "TIT", "chapter", "data", "id", "layout", "description", "theme", "desc", "msg", "url", "header"], "imageURL": [" imageurl", "mediaUrl", "ImageUrl", "pictureURI", "filePath", "imgPath", "ImagePath", "pictureUrl", "mediaURI", "imgURL", "ImageURI", "imgUrl", "fileURI", "imageURI", "mediaURL", "ImageURL", " imageUrl", " imageURI", "imageurl", "imageUrl", "fileURL", "fileurl", "fileUrl", "pictureurl", "imgURI", "pictureURL", "imagePath"], "jd": [" jdl", "je", "ajD", "qdh", " jdd", "Jb", "jjdh", "jds", "zl", "ajdos", "Jdos", "Je", "jjdo", "jackb", "jackf", "ajdl", "jdom", "ssdo", "Jdo", "jdi", "ajdh", "jobdo", "ssdi", " jdo", "jsdh", "jD", "jjb", "Jds", "adjdos", "qb", "ajdo", "zf", "jsdo", "jsb", "jobD", "zb", "ajdi", "zd", " jdh", "jf", "ajd", "qd", " jds", "jackdd", "jjd", "argdo", "qdo", "Jf", "argf", " je", "zdo", "jsd", " jdi", " jf", "adjdo", "qdom", "JD", "jdos", "zdd", "zds", "jobb", "jdd", "Jl", "Jdom", "jdh", "adjb", "jdo", " jdom", "ze", "ssd", "ajb", "jobd", "argd", "jdl", "Jd", "ajf", "argdl", "jackd", " jD", "ssD", "adjd"], "jl": ["j", "jc", "eb", "nl", "kn", "wl", "kj", "syn", "lf", "bl", "cli", "Label", "l", "label", "ld", "vd", "lp", "NJ", "uj", "hl", "chal", "kl", "li", "dl", "iji", "lb", "ja", "JM", "elly", "ji", "jon", "elt", "dj", "fp", "zl", "il", "jj", "oji", "iol", "bn", "lv", "kel", "ll", "adj", "el", "bj", "lu", "igl"], "icon": ["image", "pic", "action", "resource", "ion", "content", " Icon", "alias", "picture", "text", "fc", "iao", "label", "info", "ui", "ann", "Icon", "core", "token", "ic", "note", "uni", "io", "eye", "uri", "icons", "cha", "css", "img", "size", "bn", " image", "cn", "on", "gn", "artist", "png", "ico", "n", "plugin", "url", "header"], "chooser": ["Chooses", "Choosen", " choressor", "closer", "boosen", " choosen", " chooses", "clressor", "Chooder", "boressor", "choose", " choose", "chooses", "chooder", "choressor", "Choose", " chooder", "choosen", "dialoser", "joose", "boose", "booser", "Chooser", "close", "cler", "dialosen", "jooses", "closen", "dialer", "jooder", "choer", "jooser", "dialose", "Choer"], "jp": ["j", "JP", " pa", " dock", " JM", " cm", " gp", " ax", " pane", " app", " j", " bridge", " dj", "bj", " tmp", "ja", " bar", "ji", " robot", " np", " js", " je", " plugin", "Panel", " pic", " mp", " obj", " sp", " cp"], "jb": ["ajsb", " jcb", "jbb", "djcb", "qf", "jscb", "djb", "jf", " jbb", "ajcb", "ajb", " jsb", "djd", "qsb", "jsbb", "ajf", "qb", "qcb", "jsd", "djbb", " jf", "jcb", "jsb"], "e": ["de", " ate", "in", " fe", "event", "exc", " Event", "je", "et", "E", " E", "c", "pe", "t", "ie", "v", "x", "ce", "ception", "a", "ae", "ev", "te", "ctx", "ec", "f", "ee"], "returnVal": ["Returnval", "returnNum", "resultNum", "ReturnVal", " returnVAL", "ReturnVAL", "resultVal", "returnValue", "ReturnValue", "replyVAL", " returnNum", " returnValue", "replyVal", "resultval", " returnval", "resultValue", "replyval", "replyValue", "returnVAL", "ReturnNum", "returnval"], "file": ["model", "force", "unit", "ban", "filename", "queue", "full", "page", "show", "future", "single", "dir", "name", "binary", "comment", "lib", "parent", "f", "directory", "body", "folder", "log", "pool", "po", "function", "local", "play", "b", "info", "auto", "files", "core", "handler", "io", "build", "fp", "FILE", "il", "user", "document", "get", "book", "File", "base", "module", "ile", "parse", "zip", "use", "l", "object", "home", "path", "line", "type", "out", "data", "lock", "db", "image", "letter", "rule", "die", "picture", "load", "http", "message", "pe", "buffer", "work", "part", "live", "url"], "fileName": ["singlePath", " filePath", "imageName", "binaryPath", "fileType", "filePath", "singleType", "resourceInfo", "FileInfo", "filename", "resourcePath", "binaryUrl", "FilePath", "imagename", "imageInfo", "FileName", " fileUrl", "Filename", " fileType", " filename", "imageUrl", "resourceName", "singleName", "fileUrl", " fileInfo", "singlename", "binaryName", "fileInfo", "FileType", "imagePath", "singleInfo", "resourcename"], "ext": ["enc", "format", "eng", "ension", "feat", "version", "oct", "exp", "sec", "xt", "ch", "extra", "txt", "class", "pe", "orig", "ct", "ace", "t", " Ext", "path", "fb", "p", "Ext", "type", "phrase", "alg", "v", "xp", "name", "EXT", "word", "ax", " extension", "qt", "ex", "desc", "abc", "lib", "f", "obj"], "i": ["z", "ini", "mi", "j", "o", "ion", "ment", "phi", "cli", "ii", "mini", "api", "b", "info", "ui", "ri", "pi", "c", "gi", "li", "ci", "p", "multi", "si", "ni", "io", "xi", "bi", "v", "uri", "ai", "y", "ip", "is", "bis", "a", "ti", "id", "iu", "u", "di", "m", "I"], "doIt": ["DOIt", "DOIT", "DOWhich", " doIT", "doYou", "poIt", "poit", "diIts", "addIt", " doNot", "doNot", "doit", "hoit", "diIT", "diIt", "skipit", "odoIt", "poIT", "poYou", "skipIts", "hoIT", "addIT", "doIts", "doWhich", "doIT", "skipIT", "odoNot", "odoWhich", " doYou", "odoit", " doit", "addit", " doIts", "skipIt", "DOit", " doWhich", "odoIT", "hoIt", "diit", "addNot", "hoYou"], "src": ["conv", "rx", "sub", "impl", "storage", "stream", "gz", "RC", "input", "ff", "cur", "target", "fi", "fc", "slice", "sync", "b", "bb", "cb", "sup", "ources", "buf", "gb", "r", "dist", "cdn", "rc", "sn", "path", "split", "st", "sc", "cmp", "ource", "upload", "rel", "sb", "attr", "img", "pull", "rest", "sq", "secure", "cos", "rs", "tmp", "socket", "ssl", "us", "sel", "Dest", "inst", "sth", "sl", "desc", "rb", "ctx", "uc", "bc", "loc", "source", "url"], "dest": ["wb", "die", "dev", "cont", "config", "done", "dc", "dat", " Dest", "trans", "target", "output", "later", "ctr", "uv", "wd", "sup", "home", "comb", "usr", "exit", "dist", "cdn", "route", "st", "proc", "prop", "destroy", "rest", "img", "gd", "std", "dir", "tmp", "Dest", "dep", "inst", "gen", "desc", "uc", "di", "loc", "source"]}}
{"id1": "5237257", "id2": "4750967", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"download": ["output", "paste", "load", "update", "archive", "dump", "complete", "process", "release", "open", "url", "log", "transfer", "Download", "zip", "exec", "upload", "run", "submit", "file", "register", " downloading", "pack", "start", "select", "delete", "report"], "fileName": ["fileCode", "resourcePath", "fileDirectory", "resourceName", "fileType", "FileCode", " fileType", " fileDirectory", "FilePath", "fileFolder", "resourceDirectory", " fileFolder", "fileUrl", "FileFolder", "FileName", "resourceUrl", "FileUrl", "FileDirectory", "resourceCode", "FileType", "resourceFolder", "resourceType", " fileCode", " fileUrl"], "filePath": ["resourcePath", " fileFile", "FileLocation", "fileLocation", "resourceName", "filePart", "resourceFile", "resourceLocation", "FilePart", "fileFile", " filePart", "FilePath", "Filepath", "resourcePart", "FileName", "FileFile", " filepath", "filepath", "resourcepath", " fileLocation"], "in": ["work", "x", "source", "as", "init", "copy", "re", "gin", "inn", "sync", "pin", "inner", "ac", "f", "ax", "this", "i", "input", "l", "socket", "inside", "image", "IN", "data", "m", "con", "win", "ini", "resource", "issue", "on", "n", "up", "bin", "a", "url", "io", "name", "isin", "b", "is", "nin", "ins", "cin", "spin", "In", "lin", "inc", "again", "rin", "file", "r", "err", "login", "cgi", "id", "reader", "din"], "out": ["x", "source", "call", "copy", "cache", "output", "sync", "client", "path", "net", "inner", "at", "point", "with", "this", "extra", "view", "ex", "cmd", "one", "to", "socket", "OUT", "conn", "image", "line", "or", "IN", "by", "writer", "on", "n", "io", "up", "url", "base", "name", "log", "null", "outer", "ext", "server", "exec", "obj", "password", "nin", "string", "exp", "prefix", "option", "Out", "write", "In", "outs", "again", "off", "office", "file", "lib", "err", "o", "id", "user", "bin", "error"]}}
{"id1": "19006212", "id2": "19276022", "code1": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 0, "substitutes": {"Load": ["File", "Play", "download", "load", "add", "Read", "loaded", "New", "LOAD", "Loader", "Game", "Add", "upload", "Start", "loading", "Init", "Class", "Get", "Upload", "loader", "pack", "Process", "oad", "Create", "Import", "Loading", "Open"], "fname": ["ffname", "filenames", " fsource", "Fname", "fnames", "cnames", "cpath", "fnamed", "Ftype", "Fpath", "fName", "fcpath", " fsize", "filefile", "pfile", "Fbase", " fbase", "fileName", "xtype", "ffile", " fName", "fullsize", "filetype", "ttype", "fsource", "filename", "Fnamed", "fullename", "pbase", "tname", "fbase", "fullname", "fcnamed", "xname", "fsize", "fcname", "filesource", "tpath", "cname", "fpath", "FName", " fnamed", "xName", " fpath", "xpath", "fename", "ppath", "tName", "Fnames", "cName", "ffsize", "pName", "pnames", "filepath", "ffName", "fullName", "ftype", "psource", "fcName", " fename", " fnames", " ffile", "ffename", "pname"], "f": ["image", "base", "form", "fm", "F", "ref", "fc", "cache", "area", "l", "b", "object", "c", "cf", "buffer", "fd", "d", "p", "pointer", "frame", "fp", "fs", "fn", "e", "sf", "n", "m", "conf"], "aType": ["aVersion", "audioClass", " aSource", " aVersion", "aaVersion", "aaClass", " aClass", "audioSource", "aClass", "aaSource", "aaType", "audioVersion", "aSource", "audioType"], "aElement": ["anFile", "anElement", " aObject", "aFile", "oElement", "oDocument", " aDocument", "oFile", "aObject", "anObject", "anDocument", "oObject", " aFile", "aDocument"], "content": ["body", "model", "video", "resource", "Content", "script", "meta", "stream", "metadata", "transform", "entry", "version", "load", "text", "message", "media", "code", "path", "title", "data", "layout", "document", "comment", "description", "activity", "value", "config", "source"], "Ax": ["aw", "dec", "Num", "Content", "Width", "Index", "dx", "Pages", "ix", "Length", "AX", "A", "ord", "au", "Pos", "orient", "Code", "Id", "xx", "Title", "xp", "title", "ww", "Page", "axis", "ax", "Key"], "Ay": ["Az", "Key", "Sep", "Series", "Pi", "Loc", "XY", "Va", "Year", "Vert", "Unit", "Rev", "Py", "Ext", "Row", "Ws", "Desc", "Cy", "Dir", "Exp", "Ry", "Col", "Lo", "Yu", "By", "Vol", "Dim", "Sy", "Dec"], "aTemplate": ["aTitle", "aRepeat", "activeTitle", " aTitle", " atemplate", "titleRepeat", "activeRepeat", "atemplate", "activeTemplate", "titletemplate", "titleTitle", "titleTemplate", " aRepeat", "activetemplate"], "factory": ["Factory", "refiller", "spactory", "FFactory", "Fault", "refundle", "firm", "fiFactory", "refactory", "sfault", "fault", "fundle", "fiactory", "fiault", "fiddle", "sfFactory", "tactory", "fFactory", "spundle", "fiirm", "tiddle", "tiller", "refiddle", "filler", "spiddle", "spiller", "tundle", "Firm", "sfactory", "sfirm"], "data_read": ["buffer_received", "data__reads", "buffer_ready", "buffer_reads", "data_reads", "data__ready", "data_received", "data_ready", "buffer_read", "data__received", "data__read"], "url": ["image", "log", "URL", "base", "resource", "lr", "www", "feed", "fr", "impl", "stream", "coll", "ul", "Url", "ls", "http", "zip", "api", "l", "b", "page", "string", "r", "bel", "buffer", "path", "fl", "io", "rel", "uri", "layer", "il", "xml", "ur", "loader", "location", "ssl", "server", "data", "file", "ob", "browser", "el", "sl", "rl", "loc", "source", "address"], "parser": ["pool", " soup", "jack", " reader", " module", " parsed", "arser", " input", "function", "player", " xml", "worker", "parse", " builder", "http", " processor", "writer", "page", "builder", "driver", " parent", "oder", " scanner", "handler", "er", "p", " sys", "type", "se", " library", "Parser", "layer", "xml", "manager", "library", "loader", " plugin", " protocol", "server", "file", "document", "umper", "reader", " grammar", " pars", "plugin", " file", "processor"], "i": ["z", "ini", "index", "field", "j", "oi", "chi", "yi", "hi", "inner", "phi", "ii", "ix", "fi", "slice", "mu", "b", "info", "ui", "ri", "pi", "c", "gi", "abi", "d", "li", "ci", "ie", "p", "multi", "si", "ni", "xi", "uri", "io", "v", "x", "ai", "ji", "bi", "eni", "it", "ip", "ori", "ti", "qi", "id", "e", "iu", "u", "n", "di", "I", "zi"], "start_x": ["start___y", " start_xi", "start_X", "startNewy", "startNewx", "start_xi", "startNewxy", "startNewcross", "start___X", "start___xi", " start_X", " start_cross", "start_xy", " start_xy", "start___x", "start_cross"], "start_y": ["start_Y", "start_dy", " start_z", "start_vy", " start_Y", " start_vy", " start_dy", "start_z"]}}
{"id1": "3024987", "id2": "22441244", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStreamForencode", "testCopy_readerToOutputStreamForencoding", "testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStreamForEncoder", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStream_Coder", "testCopy_readerToOutputStream_Integoded", "testCopy_readerToOutputStream_Code", "testCopy_readerToOutputStream_Coded", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStreamForencoder", "testCopy_readerToOutputStreamForencoded", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStreamForEncoding", "testCopy_readerToOutputStream_encode", "testCopy_readerToOutputStream_Encode", "testCopy_readerToOutputStreamForEncoded", "testCopy_readerToOutputStream_Integoder", "testCopy_readerToOutputStream_Integoding", "testCopy_readerToOutputStreamForEncode", "testCopy_readerToOutputStream_Integode", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStream_Coding"], "in": ["url", "ins", "din", "IN", "re", "login", "bin", "id", "io", "inc", "include", "ini", "input", "In", "inner", "image", "err", "inas", "read", "or", "m", "Reader", "a", "i", "r", "n", "again", "with", "rec", "slice", "win", "buffer", "inn", "min", "is", "arin", "data", "source", "entry", "file", "init", "inside", "rin", "pass", "reading"], "reader": ["ra", "feed", "io", "rr", "worker", "x", "rer", "ler", "er", "input", "pointer", "inner", "stream", "driver", "iner", "read", "Reader", "or", "writer", "i", "r", "b", "rx", "handler", "oder", "per", "loader", "ner", "her", "parser", "buffer", "iter", "source", "file", "rar", "ink", "reading"], "baout": ["bain", "baparent", "waoutput", "BAoutput", "BAOUT", "BAout", "vaparent", "abain", "baoutput", "dain", "abaOUT", "daOut", "vaOut", "aaOut", "daout", "waout", "aaout", "aain", "BAin", "Baout", "vain", "wain", "BaOut", "aaoutput", "abaOut", "daOUT", "vaout", "baOut", "Baparent", "waOut", "abaout", "Bain", "BAparent", "BAOut", "baOUT"], "out": ["exec", "base", "OUT", "client", "outs", "cache", "builder", "output", "io", "inc", "arr", "obj", "ext", "inner", "to", "image", "err", "write", "inas", "Out", "lib", "writer", "user", "null", "object", "again", "parent", "o", "with", "buffer", "array", "line", "pool", "file", "up", "server", "ref"], "bytes": ["objects", "classes", "outs", "Bytes", "output", "zip", "seconds", "es", "ies", "odes", "ns", "string", "binary", "values", "lines", "cells", "ls", "size", "files", "bps", "os", "ones", "comments", "strings", "items", "rows", "null", "text", "body", "bits", "pieces", "css", "android", "blocks", "parts", "les", "content", "its", "ips", "pages", "data", "units", "reads", "ipes", "bs", "tes", "codes"]}}
{"id1": "22441244", "id2": "2511579", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"send": ["text", "message", "create", "set", "parse", "build", "from", "reply", "open", "export", "execute", "add", "sent", "transfer", "post", "exec", "address", "append", "Send", "write", "submit", "end", "get", "start", "delete", "mail"], "hsession": ["hession", "hesess", "openssession", "hsess", "hsSession", "hhessions", "hhort", "HSsession", "hSession", "hesort", "hsort", "hmSession", "hesession", "hsessions", "opensess", "hmsession", "hhess", "HSessions", "hmessions", "hessession", "opensession", "opensort", "opensessions", "hessions", "hmession", "opensSession", "HSSession", "hssession", "hhsession", "hhSession", "hhession", "HSession"], "session": ["message", "cache", "client", "port", "essions", "ession", "state", "event", "manager", "project", "proxy", "resource", "chat", "document", "class", "mail", "security", "server", "host", "sl", "connection", "parent", "response", "site", "Session", "context", "application"], "repositoryName": ["reposicationName", "reposositoryEmail", "reposessionEmail", "repositoryEmail", "reposicationFamily", "repoositoryNAME", "repositiveEmail", "repositoryPath", "repositoryNAME", "repoitoryEmail", "reposicationAddress", "repoositoryEmail", "repoitoryNAME", "repositiveName", "repoitoryPath", "reposositoryAddress", "reposicleName", "repositoryFamily", "repositiveNAME", "reposositoryFamily", "repoitoryFamily", "reposositoryName", "reposicleFamily", "reposessionNAME", "reposessionName", "repositivePath", "repoositoryFamily", "repoositoryName", "repoositoryAddress", "reposicleAddress", "reposositoryPath", "repoositoryPath", "reposicationEmail", "repositoryAddress", "repoitoryAddress", "repoitoryName", "reposicleEmail", "reposositoryNAME", "reposessionPath"], "ideIdint": ["ideInn", "ideidInt", "ideInints", "ideAuthints", "ideInfoint", "ideNameout", "ideTimeInt", "ideInInt", "IDEidint", "IDENamenumber", "ideAuthInt", "IDEIdints", "ideidint", "IDENameInt", "ideIdn", "IDEIdn", "IDEIdInt", "IDEidInt", "ideidn", "ideIdout", "ideNameint", "ideTimenumber", "ideInfonumber", "IDEidints", "ideAuthint", "ideInfoInt", "ideNameInt", "IDENameout", "ideIdints", "ideTimeint", "ideInint", "IDENameint", "ideNamenumber", "IDEIdnumber", "ideIdInt", "IDEidn", "IDEIdint", "ideIdnumber", "IDEIdout", "ideidints", "ideAuthn", "ideInfoout", "ideTimeout"], "to": ["account", "source", "contact", "message", "top", "about", "summary", "token", "TO", "client", "phone", "uri", "with", "company", "title", "options", "po", "by", "from", "location", "name", "mail", "sub", "address", "target", "prefix", "tel", "To", "settings", "office", "response", "template", "site", "mobile", "reply"], "cc": ["account", "contact", "cs", "phone", "client", "uc", "cf", "ac", "c", "company", "tc", "card", "ca", "ci", "from", "ce", "comment", "ec", "lc", "CC", "cr", "code", "sc", "password", "address", "cus", "rc", "nc", "cl", "cca", "cn", "ct", "ck", "cb", "dc"], "bcc": ["pce", "bbrc", " bck", "abcc", "brc", "abce", "fck", "bbck", "bc", "pc", " bc", "pck", "abck", " bce", "fc", "bbcc", "bce", " brc", "pcc", "frc", "bck", "bbc", "fcc", "abc"], "subject": ["message", "method", "filename", "uri", "phone", "username", "author", "head", "title", "state", "object", "format", "reply", "comment", "description", "reason", "host", "sub", "header", "prefix", "ject", "Subject", "request", "template", "response", "content", "mail"], "body": ["text", "source", "secret", "message", "normal", "style", "summary", "media", "pod", "length", "Body", "empty", "inner", "view", "pass", "how", "tree", "line", "data", "left", "resource", "money", "object", "comment", "description", "shell", "url", "base", "name", "reason", "code", "bound", "password", "function", "zip", "header", "string", "connection", "lock", "plain", "wrapper", "html", "part", "template", "response", "foot", "content"], "attachments": ["Attachments", "messings", "messents", "embedment", "embedments", "messment", "messments", "attachings", "Attachents", "embedents", "embedings", "attachents", "Attachings", "Attachment"], "isHtml": [" isChtml", "isChhtml", "isWhtml", "isHive", "isChive", "isWhive", "isHahtml", "isChtml", " isHttp", "isPhttp", "isPhtml", " isWhail", "isChttp", " isChttp", "isHttp", " isHive", "isHaail", " isWhive", " isWhhtml", " isChhtml", "isCail", " isChail", "isChail", "isWhhtml", "isHhtml", " isHail", " isWhtml", "isHatml", "isHattp", "isWhail", "isCive", "isPhail", "isCtml", "isPhhtml", " isHhtml", "isHail"], "charset": ["chARSete", "charsET", "charsetting", "chasesET", "chearsetting", "CharsET", "Charset", "charseting", "Charsetting", "chansetter", "chasesetting", "chacksET", "charsets", "cheansET", "chackset", "cheansete", "chanspace", "chasetter", "chearspace", "chashesET", "chasET", "chasheset", "chearset", "chaseting", "Charsets", "charsete", "chaspace", "chARSetting", "chaseseting", "chARSet", "chasetting", "chanset", "chansetting", "chearsetter", "charspace", "chasets", "Charseting", "chansET", "chansete", "chARSets", "cheanspace", "chearsete", "chaset", "chacksetting", "chaseset", "cheansetter", "chashespace", "cheanset", "cheansetting", "chARSeting", "chearsET", "chARSET", "charsetter", "chacksete", "chashesetter"], "headers": ["types", " recipients", "writers", "lines", " emails", "ers", "content", "options", "groups", "errors", "names", "strings", "metadata", "authors", "params", " messages", "files", "header", " cookies", "settings", "mails", "users", "properties", "classes", "comments", "status"], "priority": ["secret", " recipients", "mode", "phone", "length", "language", "author", "date", "title", "state", "level", " title", "comment", "class", "security", "reason", "code", "theme", "lang", "quote", "prefix", "queue", "template", "comments", " severity", "status", "reply"], "email": ["account", "text", "contact", "message", "create", "result", "business", "output", "international", "generic", "username", "update", "info", "lex", "model", "event", "view", "e", "note", "enter", "line", "oe", "default", "install", "data", "example", "service", "object", "print", "export", "online", "document", "url", "em", "name", "base", "core", "server", "article", "ext", "password", "zip", "entity", "address", "letter", "external", "element", "el", "Email", "engine", "fax", "auto", "en", "html", "test", "office", "ssl", "template", "response", "liner", "gmail", "ilo", "pm", "xml", "mail"], "user": ["account", "me", "uid", "role", "token", "client", "username", "author", "info", "model", "use", "person", "e", "friend", "USER", "unknown", "data", "object", "resource", "consumer", "ip", "character", "name", "string", "connection", "profile", "plugin", "creator", "users", "er", "member", "id", "type", "people", "mobile", "User"], "identity": ["authentization", "publicITY", "authoronymous", "authentifier", "identITY", "ethnicication", "publicity", "idication", "IdentITY", "authentity", "electricentity", "IDENTities", "personentity", "publiciciary", "identonymous", "authorities", "authentITY", "personifier", "ethnicentity", "identifier", "personITY", "ethnicifier", "electriconymous", "idity", "idization", "installity", "authority", "entityization", "electricity", "authorifier", "IDENTentity", "ethnicITY", "electricITY", "authorentity", "Idententity", "identities", "idententity", "IDENTity", "idifier", "entityonymous", "personity", "identication", "identiciary", "installonymous", "installITY", "authentication", "Identities", "authorication", "ethniciciary", "identization", "authorITY", "publicentity", "authoriciary", "ethnicity", "idonymous", "authentonymous", "IDENTITY", "Identity", "entityifier", "entityity", "installentity", "idITY"], "_returnPath": ["_returnHalf", " _returnHalf", "_relationId", "_resultHalf", "_backPart", "_returnpath", "_inputNode", "_correctId", " _backPath", "_correctDirectory", "_backName", "_relationPath", "_correctPath", " _backPart", "_returnId", "_returnText", "_backHalf", "_responsepath", "_returnUrl", "_replyPart", " _returnUrl", "_returnType", "_returnMid", "_replyPath", " _returnName", "_successId", "_backPath", "_displayNode", "_replyUrl", "_displayMid", "_successDirectory", "_responseType", "_returnPart", "_responsePath", "_returnDirectory", "_inputMid", "_resultTo", "_relationText", "_backTo", "_replyNode", "_backpath", "_relationDirectory", "_replyMid", "_returnTo", "_addType", "_addPath", " _backTo", "_resultName", "_returnNode", "_returnName", " _backName", "_successText", "_displayPart", " _backUrl", " _returnPart", " _backHalf", "_resultPath", "_backUrl", "_displayPath", "_addpath", "_inputUrl", "_backType", "_correctText", " _returnTo", "_inputPath", "_displayUrl", "_successPath"], "_from": ["placefor", " _owner", "_for", " _source", "blockto", "_who", "_with", "workto", "_From", "blockfrom", "placeowner", " _error", " _for", "_source", "existingowner", " _with", "blockerror", "_owner", "blockFrom", "workfrom", "placeto", "existingto", "_error", "workwho", " _From", "existingfor", "placefrom", "worksource", "existingfrom", " _who"], "_replyTo": ["_returnFrom", "_replyOf", "_commentTO", "_commentOf", "_commentFrom", "_addTo", "_reasonFrom", "_addPoint", "_respondAddress", "_respondTO", " _replyTO", "_commentTo", "_closeTo", "_respondTo", "_replyTO", "_closeFrom", "_reasonTO", "_replyAddress", " _replyFrom", "_addAddress", "_returnAddress", "_respondPoint", " _returnTO", "_returnTo", "_returnOf", "_closeOf", " _returnFrom", "_addFrom", "_reasonTo", "_returnTO", "_respondFrom", "_replyFrom", "_returnPoint", "_replyUrl", " _returnTo", "_replyPoint", "_returnUrl", "_respondUrl", " _replyUrl", "_closeTO", "_reasonUrl", " _returnUrl"], "_to": ["_about", "Jfrom", "Jtarget", " _about", "_target", "Jabout", " _target", "Jto"], "_cc": ["_cf", " _cd", " _ce", "_cd", "_ce", " _cf"], "_bcc": ["_sbcc", "_bcs", " _abcc", "_rbcs", " _bce", "_bce", " _bc", "_abce", "_rbc", "_sbc", " _abc", "_sbce", "_bc", "_abcs", "_abcc", "_sbcs", "_abc", "_rbce", "_rbcc", " _abce", " _bcs", " _abcs"]}}
{"id1": "947406", "id2": "17999474", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "label": 1, "substitutes": {"copy": ["get", "clone", "p", "sync", "cp", "transfer", "Copy", "write", "cat", " cp", "replace", "Cop", "clip", "cop", "csv", "file", "zip", "download", "log", "paste", "put", "split", "it", " Copy", "cmp", "dump", " transfer"], "src": ["sc", "sl", "stream", "files", "rc", "use", "s", "input", "sit", "rs", "id", "sin", "sb", "loc", "source", "rb", "inst", "resource", "cur", "stab", "gb", "img", "fn", "dist", "config", "bh", "sel", "url", "data", "sq", "ins", "name", "string", "js", "href", "uri", "ource", "sub", "filename", "rob", "txt"], "dest": ["de", "obj", " Dest", "output", "delete", "class", "tmp", "comb", "opt", "thin", "const", "home", "Dest", "replace", "target", "result", "desc", "orig", "later", "img", "wd", "sup", "dist", "dir", "die", "st", "wb", "rest", "des", "temp", "flat", "done", "test", "name", "bin", "d", "prop", "folder", "destroy", "dat", "source", "txt"], "in": ["r", "m", "pin", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "cf", "din", "conn", "info", "diff", "lin", "a", "inner", "vin", "pull", "nin", "con", "ini", "rin", "kin", "work", "url", "lib", "pass", "base", "this", "login", "data", "err", "download", "b", "trans", "it", "ins", "bin", "In", "reader", "IN", "as", "again", "lock", "win", "issue", "source", "up", "inc"], "out": ["Out", "image", "os", "timeout", "client", "writer", "plain", "sync", "one", "off", "obj", "up", "output", "socket", "app", "init", "ou", "user", "write", "id", "ex", "aos", "cache", "conn", "or", "exp", "ext", "index", "our", "io", "inner", "exit", "nin", "pool", "img", "file", "at", "part", "x", "o", "no", "exec", "this", "lib", "data", "err", "vert", "log", "w", "net", "call", "bin", "again", "outs", "outer", "source", "OUT", "inc"], "buf": ["fab", "pad", "bp", "buffer", "bytes", "seq", "batch", "p", "bf", "ctx", "pos", "block", "br", "off", "ff", "ab", "fd", "rc", "queue", "bn", "fl", "loc", "result", "bc", "rb", "fb", "num", "orig", "ref", "cur", "buff", "raw", "count", "uc", "box", "len", "bh", "bag", "bd", "f", "feat", "data", "b", "cv", "v", "cap", "uf", "bin", "nb", "cb", "c"], "n": ["ind", "ne", "m", "j", "p", "size", "max", "i", "na", "nn", "write", "ns", "nt", "sn", "ng", "t", "N", "length", "dn", "nc", "index", "num", "nin", "z", "count", "nr", "len", "x", "en", "f", "no", "o", "k", "u", "b", "v", "w", "nd", "number", "rn", "l", "un", "d", "nb", "c"]}}
{"id1": "19584877", "id2": "14231545", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileToStream", "encodeFileFromStream", "encodeFiletoFiles", "encodeString2File", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFile", "encodeFileFromString", "encodeStringToString", "encodeFileFromFiles", "encodeFiletoStream", "encodeFile2String", "encodeFileFromFile", "encodeStringToStream", "encodeString2String", "encodeString2Files", "encodeString2Stream", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFileToString", "encodeFile2Files", "encodeFile2File"], "infile": ["infp", " infiles", "InFile", "Infilename", "inputfiles", "inputFile", "Infiles", "outfp", "outfilename", "inFile", "inputfp", "infiles", "Infile", "infilename", "inputfilename", "inputfile", "outfiles", "outFile", " infp", " infilename"], "outfile": ["infp", " outfilename", "outputfilename", " outfolder", "outputfolder", "outputfp", "newfile", "outname", "outfp", " outFile", "outfilename", " outname", "Outfolder", "Outname", " outfp", "outfolder", "infilename", "newfolder", "newFile", "infolder", "outFile", "Outfile", "newname", "OutFile", "outputfile"], "in": ["into", "m", "ins", "image", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "vin", "din", "IN", "inn", "inas", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "base", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "source", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "err", "obj", "name", "up", "net", "ou", "OUT", "or", "again", "line", "on", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "fb", "data", "Buffer", "raw", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "len", "base", "slice", "queue", "address", "cache", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "input", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "close", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "respons", "func", "winner", " Success", "model", "status", "follow", "result", "primary", "fail", "valid", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "modified", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "1954410", "id2": "21489105", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"doExecute": ["doSendutes", "doexecuteutes", "submitExecApply", "doexecuteRun", "doExecutes", "submitexecuteRun", "submitexecuteute", "doSendApply", "doexecuteApply", "doExecApply", "submitexecuteutes", "submitexecuteApply", "doSendRun", "doExecRun", "doSendute", "submitExecRun", "submitExecute", "doexecuteute", "submitExecutes"], "mapping": ["amapping", "amatching", " matching", "fapping", " mapper", "matching", "amapper", "fatching", "mapper", " minding", "fapper", "aminding", "finding", "minding"], "form": ["forms", "page", "Form", "component", "url", "flow", "method", "field", "definition", "template", "formation", "xml", "builder", "config", "command", "transform", "control", "object", " forms", "submit", "FORM", "app", "pattern", "format", "dom", "feed", "post", "owner"], "request": ["req", "url", "uri", "frame", "resource", "message", "server", "report", "parent", "call", "complete", "view", "requ", "_", "Response", "HTTP", "method", "data", "this", "hello", "session", "application", "model", "result", "input", "route", "Request", "type", "Upload", "s", "xml", "instance", "pull", "QUEST", "create", "reader", "add", "client", "self", "worker", "user", "queue", "object", "address", "submit", "name", "re", "Accept", "ware", "Bytes", "context", "json", "query", "path", "current", "format", "q", "Reply", "use"], "response": ["resp", " Response", "page", "req", "res", "resource", "message", "report", "server", "view", "Response", "data", "output", "application", "status", "model", "result", "reply", "xml", "Resp", "client", " responses", "object", "v", "handler", "json"], "errors": [" logs", " this", " status", " management", " flashes", " Messages", " error", " mess", " messages", " messenger", " events", " managers", " session", " calls", " payload", " problems", " translations", " failures", " logger", " warnings", " responses", " commands", " streams", " updates", "mess", " replies", " acc", " changes", " messaging"], "isMultipart": ["isMultippedart", "isMultompPart", "isMultiage", "isMultiparts", "isMultiIPPart", "isMultippedost", "isMultippage", "isMultippart", "isMultiIPost", "isMultipPart", "isMultompost", "isMultIPart", "isMultompart", "isMultipparts", "isMultippedound", "isMultiart", "isMultipound", "isMultIPPart", "isMultipost", "isMultitage", "isMultompound", "isMultipated", "isMultiipart", "isMultiated", "isMultiipound", "isMultitated", "isMultipage", "isMultIPound", "isMultiipost", "isMultippedPart", "isMultiIPart", "isMultippated", "isMultitart", "isMultitarts", "isMultiIPound", "isMultIPost", "isMultiarts", "isMultiipPart"], "mailInstance": ["fileUsage", " emailInst", " mailManager", "fileManager", " emailinstance", "emailManager", " mailUsage", " emailInstance", "emailInst", "mailinstance", "fileinstance", " emailUsage", "mailUsage", "mailInst", "mailManager", " mailinstance", "emailinstance", "emailInstance", "fileInst", "fileInstance", " mailInst"], "fields": ["forms", "maps", "keys", "gets", "archives", "rows", "details", "links", "users", "data", "parts", "lists", "forces", "tags", "acks", "headers", "dates", "field", "loads", "plugins", "groups", "input", "features", "comments", "classes", "lines", "s", "flows", "objects", "posts", "facts", "holders", "properties", "qs", "states", "files", "pages", "ids", "models", "packs", "params", "cells", "locks", "atts", "checks", "views", "ments", "rules", "types", "words", "boxes", "events", "members", "utils", "uploads", "services", "strings", "changes"], "attachments": ["Attachments", "attees", "payments", "attachlements", "achparts", "attments", "Attachlements", "attachees", "payresses", "attlements", "payparts", "Attachees", "extments", "supplements", "attachps", "attachparts", "attions", "achment", "attment", " attachresses", "Attachps", " attachparts", "payment", "suppment", "extions", "achresses", "Attachers", "suppees", "Attachment", "achments", "attachresses", "suppments", "attachers", "attachment", "extps", "exters", "Attachions", "attachions", "atters", "attps", " attachment"], "items": ["keys", "ins", "rows", "apters", "links", "lists", "parts", "data", "reports", "apps", "Items", "es", "groups", "plugins", "lines", "ips", "children", "objects", "results", "alls", "qs", "files", "pages", "ids", "orders", "names", "models", "ers", "list", "locks", "ops", "types", "events", "phones", "its"], "iter": ["enter", "page", "altern", "http", "master", "itter", "ser", "loc", "ul", "event", "outer", "oper", "ner", "inc", "loop", "it", "zip", "exp", "finder", "coll", "upper", "end", "el", "ver", "gener", "i", "reader", "li", "keep", "ter", "er", "edit", "ip", "inner", "Iterator", "former", "slice", "walker", "skip", "ir", "file", "err", "list", "Iter", "inter", "ator", "izer", "order", "ite", "cher", "chain", "iterator"], "item": ["art", "widget", "image", "volume", "data", "more", "entry", "temp", "issue", "hop", "token", "anything", "file", "update", "page", "resource", "server", "event", "info", "folder", "all", "result", "coll", "index", "missing", "type", "element", "plugin", "i", "er", "object", "handler", "entity", "layer", "custom", "post", "attribute", "original", "url", "complete", "site", "storage", "val", "instance", "api", "section", "atom", "album", "user", "obj", "app", "extra", "up", "order", "next", "example", "it", "area", "container", "source", "reader", "li", "ip", "inner", "base", "slice", "Item", "load", "name", "other", "service", "full", "get", "or", "current"], "aux": ["asc", "imp", "buf", "prefix", "uf", "array", "des", " Aux", "frac", "uc", "ru", "cmp", "except", "aw", "off", "data", "ux", "aos", "anc", "alias", "offs", "etc", "fax", "axe", "ox", "cas", "auc", "union", "pkg", "aus", "packages", "sub", "ras", "amp", "au", "abc", "sup", "af", "extra", "aff", "ou", "lc", " auxiliary", "ups", "abs", "strings", "lang", "ants", "ext"], "part": ["art", "partial", " Part", "component", "one", "html", "parent", "b", "connection", "act", "info", "data", "parts", "back", "step", "pos", "field", "fact", "f", "area", "group", "no", "block", "ch", "ref", "and", "key", "type", "val", "player", "error", "element", "instance", "plugin", "class", "action", "add", "section", "pair", "PART", "l", "co", "pi", "base", "user", "point", "Part", "object", "joined", "po", "change", "id", "patch", "file", "obj", "start", "name", "list", "per", "full", "diff", "pre", "layer", "word", "comp", "format", "but", "on", "p", "join"], "baos": [" bao", "BAosh", " bais", "Bao", "haoss", "paOS", "baOs", "bao", "paot", "BAOs", "bois", "BaoS", "pao", " baOS", "bais", "boOS", " baot", "Baos", " baoS", "baosi", "abaOs", "BAoS", "hais", "Bais", "paosh", "baot", "haos", "baOS", "abais", "boot", "BAosi", "boos", "boosh", "boo", "pais", "abaos", "hao", "BAoss", "baoss", "BaOs", "abaosi", "baosh", "BAis", "BAos", "Baosi", "BAo", "paos", "baoS", " baoss"], "body": ["text", "description", "url", "message", "resource", "length", "null", "b", "html", "connection", "summary", "data", "parts", "options", "shell", "port", "headers", "output", "document", "zip", "reply", "translation", "template", "end", "type", "pass", "source", "comment", "header", "size", "media", "flash", "tree", "object", "string", "fee", "params", "name", "binary", "full", "json", "query", "content", "value", "state", "common", "Body"], "preferencesInstance": ["prefirmsInstance", "prefiesInstance", "prefferencesClient", "prefferencesInstance", "preffeesClient", "prefiesClient", "preffeesinstance", "prefirmsClient", "preferencesClient", "prefferencesinstance", "prefiesinstance", "prefeesClient", "prefeesInstance", "preferencesinstance", "prefeesinstance", "prefirmsinstance", "preffeesInstance"]}}
{"id1": "7809093", "id2": "23246123", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "label": 1, "substitutes": {"getContent": [" getEntity", "getData", "setData", "responseOutput", "GetData", "getOutput", "requestEntity", "requestBody", "responseContent", "GetBody", "getBody", " getBody", "requestOutput", "GetEntity", "setBody", "setEntity", "responseEntity", "responseBody", "setContent", "GetContent", "requestContent", " getData", "getEntity", "GetOutput"], "request": ["resource", "application", "route", "position", "string", "instance", "current", "method", "http", "Request", "xml", "input", "path", "report", "operation", "queue", "object", "user", "address", "handler", "connection", "server", "query", "url", "e", "q", "result", "data", "type", "req", "r", "QUEST", "message", "uri", "name", "reference"], "sb": ["ib", "usb", "bh", "nb", "bs", "pb", "sf", "bm", "bt", "abi", "bg", "bd", "sa", "obb", "bsp", "bp", "SB", "eb", "sup", "abb", "vm", "lab", "lb", "xb", "gb", "ls", "amb", "bc", "su", "lp", "zb", "BB", "fp", "cb", "bb", "sk", "sg", "bj", "b", "bf", "fb", "buffer", "binary", "wb", "ab", "src", "rb", "db"], "client": ["resource", "application", "container", "project", "c", "cache", "host", "current", "context", "channel", "call", "http", "proxy", "service", "con", "api", "contact", "util", "https", "force", "queue", "ce", "conn", "handler", "p", "bird", "cl", "connection", "app", "default", "net", "server", "url", "config", "per", "cli", "session", "connect", "remote", "ssl", "output", "plugin", "apache", "web", "uri", "Client", "console", "builder", "tc"], "httpParams": ["httpPoeters", "HTTPPoeters", "httpPARcs", "HTTPPARams", "httpParamas", "HTTPParparams", "httpParam", "httpPrams", "HTTPParamer", "httpPARums", "httpArums", "httpPrparams", "httpArcs", "HttpParam", "HTTPPoams", "httpParamer", "httpPareters", "HTTPPARcs", "HttpParams", "httpPreters", "httpPerparams", "httpPams", "httpPparams", "HTTPParums", "httpParparams", "httpPARparams", "HTTPParam", "httpPeram", "httpPoparams", "httpPoams", "HTTPPARums", "httpParcs", "HTTPPareters", "HTTPParcs", "httpPARam", "HTTPParams", "HTTPPARam", "httpPeters", "httpParums", "HTTPPoamer", "httpPerams", "HttpParparams", "httpPeramas", "httpPARamas", "HTTPPoparams", "HttpParamas", "httpArams", "httpAram", "httpPARams", "httpPoamer", "httpPramer", "httpPamer"], "response": ["Response", "resource", "application", "status", "respond", "reply", "http", "results", "view", "report", "api", "feed", "onse", "json", "relation", "object", "successful", "resp", "connection", "document", "model", "server", "success", "received", "result", "page", "output", "error", "data", "message", "body", "collection"], "entity": ["resource", "entry", "application", "media", "instance", "channel", "environment", "em", "xml", "http", "node", "api", "Entity", "json", "ce", "content", "object", "conn", "creator", "translation", "address", "connection", "document", "agent", "pe", "element", "model", "event", "server", "coll", "component", "article", "company", "e", "writer", "result", "output", "data", "type", "ent", "source", "body", "collection", "file", "person"], "reader": ["row", "ry", "reading", "oder", "inner", "ler", "input", "io", "ner", "feed", "driver", "in", "ri", "er", "handler", "iterator", "bird", "server", "loader", "read", "Reader", "rer", "per", "iter", "i", "worker", "editor", "writer", "ser", "rr", "r", "rx", "parser", "rar", "buffer", "stream", "source"], "line": ["inline", "entry", "row", "pass", "ip", "string", "lines", "word", "LINE", "str", "character", "comment", "le", "Line", "ge", "layer", "feed", "key", "char", "sync", "content", "no", "user", "header", "unit", "cl", "l", "base", "lin", "cell", "model", "url", "definition", "non", "sl", "iter", "link", "code", "len", "li", "el", "val", "page", "data", "r", "id", "message", "lf", "source", "job", "sel", "block", "name", "lc", "end"]}}
{"id1": "442381", "id2": "6682825", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    KeyStore getKeyStore() throws JarSignerException {\n        if (keyStore == null) {\n            KeyStore store = null;\n            if (providerName == null) {\n                try {\n                    store = KeyStore.getInstance(this.storeType);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                try {\n                    store = KeyStore.getInstance(storeType, providerName);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                } catch (NoSuchProviderException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (storeURI == null) {\n                throw new JarSignerException(\"Cannot load the keystore \" + \" error con el keystore\");\n            }\n            try {\n                storeURI = storeURI.replace(File.separatorChar, '/');\n                URL url = null;\n                try {\n                    url = new URL(storeURI);\n                } catch (java.net.MalformedURLException e) {\n                    url = new File(storeURI).toURI().toURL();\n                }\n                InputStream is = null;\n                try {\n                    is = url.openStream();\n                    store.load(is, storePass);\n                } finally {\n                    if (is != null) {\n                        is.close();\n                    }\n                }\n            } catch (Exception e) {\n                throw new JarSignerException(\"Cannot load the keystore \" + storeURI, e);\n            }\n            keyStore = store;\n        }\n        return keyStore;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVERSIONWork", "doversionTest", "doVersionTest", "doBuildCheck", " doReleaseTest", "doReleasecheck", " doVersionWork", " doBuildTest", "doBuildcheck", "doVERSIONTest", " doBuildWork", "doBuildWork", "doversionCheck", "doReleaseWork", " doBuildcheck", "doVersionWork", " doBuildCheck", "doReleaseCheck", "doBuildTest", "doVERSIONcheck", " doVersioncheck", " doReleasecheck", "doVERSIONCheck", " doVersionTest", "doVersioncheck", " doReleaseCheck", "doReleaseTest", "doversioncheck"], "view": ["body", "image", "model", "html", "box", "q", "change", "can", "this", "self", "event", "form", "input", "edit", "window", "accept", "http", "cache", "widget", "vis", "use", "l", "full", "ui", "object", "page", "show", "views", "update", "display", "style", "session", "buffer", "gui", "div", "v", "row", "out", "client", "block", "see", "gu", "app", "View", "request", "sel", "server", "layout", "cell", "port", "e", "VIEW", "comment", "lock", "reader", "el", "config", "screen"], "url": ["image", "log", "URL", "base", "resource", "service", "stream", "input", "Url", "open", "hub", "channel", "http", "zip", "l", "bb", "string", "bel", "buffer", "path", "uri", "build", "client", "blog", "loader", "ssl", "server", "user", "file", "ll", "ob", "host", "browser", "sl", "lib", "connection", "source", "web", "f", "socket", "address"], "in": ["ini", "resource", "login", "stream", "gin", "inn", "inner", "input", "In", "inc", "b", "IN", "buffer", "source", "nin", "sin", "cin", "out", "ins", "is", "as", "init", "bis", "ac", "con", "data", "file", "binary", "rin", "isin", "reader", "win", "i", "n", "din", "socket", "lin", "s"], "bin": ["kin", "body", "log", "nb", "gin", "inn", "inner", "input", "bot", "din", "inline", "run", "b", "bb", "ruby", "spin", "pin", "IN", "border", "buffer", "abi", "oin", "part", "record", "bi", "cin", "out", "loader", "init", "bn", "con", "ln", "data", "file", "binary", "browser", "lock", "reader", "win", "lib", "fin", "sin", "socket", "lin"], "line": ["look", "link", "lc", "log", "unit", "base", "rule", "letter", "model", "end", "site", "nl", "lf", "cl", "lines", "inline", "entry", "LINE", "up", "day", "text", "message", "parse", "load", "Line", "key", "l", "b", "object", "page", "ine", "string", "code", "style", "home", "definition", "pe", "pass", "split", "job", "part", "row", "layer", "le", "block", "ip", "name", "word", "ge", "data", "file", "valid", "cell", "e", "band", "lo", "id", "str", "el", "i", "no", "comment", "non", "source", "lin"], "develBuild": ["DEVELBuild", "DEvelbuild", "devenBuilt", "desvenBuilt", "dewardBuilder", "deelBuilder", "desvelBuilder", "deployBuilt", "devenbuild", "deviousBuilt", "DEVELBuilt", "deVELBuilder", "DEVELBuilder", "devenRun", "DEvelBuilder", "develRun", "devenBuilder", "DEvelBuild", "dewardbuild", "DEVELbuild", "desvelBuilt", "desvenRelease", "deVELbuild", "deployRun", "deVELBuilt", "dewardBuild", "deelRun", "deelRelease", "desvelRelease", "devenBuild", "deelBuild", "desvelRun", "desvelBuild", "deployBuild", "desvelbuild", "dellRelease", "deVELBuild", "devenRelease", "desvenBuilder", "DEvelBuilt", "develbuild", "dellRun", "develBuilder", "deploybuild", "dewardBuilt", "dellBuild", "desvenRun", "deVELRun", "desvenbuild", "desvenBuild", "deployBuilder", "deviousBuild", "dellBuilder", "deviousbuild", "develBuilt", "develRelease"], "stableBuild": ["stableBuilder", "compatibleBuild", "prettyBuild", "secureBuild", "validbuild", "compatiblebuild", "compatibleBuilder", "staticBuild", "baseBuild", "stablebuild", "stableVersion", "secureBuilder", " stableBuilder", "validBuild", "securebuild", "prettyBuilder", "latestBuilder", "latestbuild", "staticBuilder", "staticbuild", "prettyVersion", "baseBuilder", "latestBuild", "basebuild", " stableVersion", "prettybuild", "baseVersion", "validBuilder", " stablebuild"]}}
{"id1": "7087108", "id2": "23370621", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["processGet", "didGet", "processGET", "processPut", "doDownload", "didGET", "didDownload", "didPut", " doPut", "doGET", "doPut", " doDownload", " doGET", "processDownload"], "request": ["event", "info", "error", "buffer", "string", "input", "Request", "server", "resource", "uri", "user", "builder", "self", "report", "http", "subject", "message", "json", "version", "project", "current", "result", "forward", "instance", "child", "host", "query", "condition", "req", "client", "type", "reader", "use", "connection", "target", "model", "application", "config", "data", "parent", "route", "web", "object", "context", "complete", "name", "QUEST", "url", "create", "xml", "method", "this", "external", "view"], "response": ["remote", "server", "output", "resource", "report", "http", "results", "message", "document", "site", "version", "json", "result", "content", "client", "cache", "resp", "connection", "model", "application", "wave", "collection", "out", "body", "page", "object", "reply", "example", "status", "writer", "image", "Response", "respond", "reference", "method", "service", "view"], "path": ["directory", "index", "string", "info", "base", "id", "uri", "output", "resource", "http", "message", "filename", "Path", "location", "key", "pattern", "content", "filter", "cache", "dir", "value", "ath", "config", "data", "text", "route", "out", "object", "p", "format", "name", "folder", "image", "url", "PATH", "method", "point"], "file": ["directory", "zip", "info", "base", "handler", "class", "fe", "resource", "uri", "feed", "lock", "http", "filename", "socket", "fp", "l", "child", "File", "part", "source", "use", "rule", "dir", "up", "lib", "connection", "FILE", "work", "data", "out", "route", "local", "le", "object", "h", "log", "name", "folder", "image", "to", "it", "function", "full", "files", "url", "pe", "b", "f"], "in": ["IN", "pin", "i", "input", "id", "serv", "copy", "resource", "ini", "gin", "con", "c", "socket", "as", "inner", "s", "ins", "bin", "is", "source", "thin", "reader", "binary", "login", "r", "inc", "data", "out", "rin", "init", "ax", "isin", "it", "In", "nin", "kin", "stream", "lin", "b", "ac", "cin", "inn", "f", "win", "din"]}}
{"id1": "6159896", "id2": "9956095", "code1": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "code2": "    public void exportNotesToServer() {\n        boolean uploaded = true;\n        try {\n            File f = new File(UserSettings.getInstance().getNotesFile());\n            FileInputStream fis = new FileInputStream(f);\n            String urlString = protocol + \"://\" + UserSettings.getInstance().getServerAddress() + UserSettings.getInstance().getServerDir() + f.getName();\n            setDefaultAuthenticator();\n            URL url = new URL(urlString);\n            HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n            urlc.setDoOutput(true);\n            urlc.setRequestMethod(\"PUT\");\n            OutputStream os = urlc.getOutputStream();\n            int nextByte = fis.read();\n            while (nextByte != -1) {\n                os.write(nextByte);\n                nextByte = fis.read();\n            }\n            fis.close();\n            os.close();\n            if (urlc.getResponseCode() != HttpURLConnection.HTTP_CREATED && urlc.getResponseCode() != HttpURLConnection.HTTP_NO_CONTENT) {\n                uploaded = false;\n            }\n        } catch (SSLHandshakeException e) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.sslcertificateerror\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n            uploaded = false;\n        } catch (Exception e) {\n            uploaded = false;\n        }\n        if (uploaded) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"info.notesfileuploaded\"), I18N.getInstance().getString(\"info.title\"), JOptionPane.INFORMATION_MESSAGE);\n        } else {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.notesfilenotuploaded\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n        }\n    }\n", "label": 0, "substitutes": {"md5": ["sha5", "sha2", " md4", "MD2", "sha7", "md4", "md2", "md7", "sha4", "MD7", "MD4", " md2", " md7", "MD5"], "str": ["STR", "r", "in", "fr", "buffer", "m", "bytes", "obj", "br", "msg", "sp", "s", "strings", "input", "e", "Str", "stri", "result", "dr", "code", "exp", "hr", "f", "url", "st", "this", "doc", "data", "char", "spec", "text", "star", "arr", "name", "style", "string", "tr", "source", "self", "txt"], "md": ["mac", "mm", "db", "m", "Cmd", "de", "amp", "bf", "git", "pkg", "pd", "cd", "bm", "rm", "amd", "cm", "mb", "nm", "gb", "df", "wd", "dh", "mand", "bd", "gd", "mail", "f", "sm", "mg", "dm", "pm", "sha", "MD", "di", "mp", "cfg", "mc", "hd", "mag", "rpm", "d", "gm", "vd", "ld", "cmd", "mem", "dd", " MD", "vm", "hm"], "b": ["db", "abb", "buffer", "bytes", "p", "bf", "g", "br", "bis", "ab", "lb", "bs", "s", "bt", "emb", "ib", "bb", "e", "rb", "fb", "bl", "a", "mb", "ob", "buff", "gb", "pb", "bd", "B", "reb", "f", "binary", "buf", "wb", "base", "u", "ba", "l", "d", "body", "nb", "cb", "c"], "sb": ["lr", "db", "sc", "bp", "buffer", "abb", "sl", "bf", "src", "lb", "bs", "s", "tmp", "SB", "sk", "zb", "bt", "ib", "bb", "sa", "usb", "ls", "sf", "sg", "bc", "rb", "fb", "bg", "kb", "bps", "lp", "mb", "ob", "cca", "gb", "bj", "pb", "ub", "bh", "bd", "B", "acc", "buf", "wb", "BB", "sq", "bsp", "xb", "obb", "ss", "si", "nb", "lab", "sv", "orb", "cb", "sp"], "i": ["ai", "in", "ip", "h", "p", "j", "n", "g", "ie", "key", "s", "multi", "fi", "ix", "e", "phi", "id", "abi", "ci", "gi", "t", "val", "ui", "a", "index", "li", "ii", "io", "vi", "z", "ini", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "y", "oi", "it", "di", "l", "si", "qi", "uri", "I", "c"], "v": ["r", "m", "j", "p", "h", "n", "g", "vt", "q", "s", "uv", "nv", "e", "t", "val", "lv", "ver", "va", "ve", "vi", "vp", "vv", "tv", "value", "av", "cover", "x", "ev", "f", "o", " vi", "conv", "vc", "k", "u", "cv", "ov", "qv", "vg", "vs", "l", "vd", "d", "sv", "iv", "V", "c", "vol"], "cc": ["C", "sc", "ca", "ck", "cci", "cel", "ce", "rc", "cs", "CC", "cn", "lc", "cf", "ci", "coll", "lv", "cu", "bc", "code", "dc", "cca", "uc", "fc", " c", "esc", "tc", "sup", " ecc", "acc", "ch", "enc", "vc", "cv", "ucc", "cl", "ct", "co", " CC", "cmp", "cb", "c", "inc", "ec"], "returnString": ["resultstring", " returnstring", "resultStr", "Returnstring", "resultArray", "ReturnString", "returnLine", "returnArray", " returnLine", "ReturnLine", "resultLine", "ReturnArray", "returnStr", " returnStr", "returnstring", "resultString", "ReturnStr", " returnArray"]}}
{"id1": "9347451", "id2": "14231545", "code1": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"writeData": ["writeDATA", " writeText", "appendDATA", "WriteDATA", "writedata", "WriteData", "Writedata", " writeDATA", "appendData", "WriteText", "writeText", "appendText", " writedata", "appenddata"], "name": ["ame", "NAME", "prefix", "url", "report", "image", "parent", "n", "info", "data", "old", "title", "part", "model", "f", "str", "named", "index", "date", "key", "type", "out", "pass", "code", "temp", "time", "class", "Name", "size", "filename", "l", "base", "table", "id", "names", "string", "start", "path", "word", "active", "line"], "items": ["keys", "chains", "item", "jobs", "cases", "Items", "sections", "groups", "plugins", "features", "planes", "classes", "projects", "lines", "ips", "flows", "objects", "xml", "images", "days", "pieces", "files", "pages", "ids", "units", "steps", "names", "models", "tests", "locks", "amples", "blocks", "types", "events", "months", "ints"], "mzmin": ["mwmax", "mvmin", "mxstart", "mZstart", "dizstart", "MZstart", "mizmax", "mxmins", "mczstart", "dizmax", "mczmax", "mzstart", "mozMin", "mvmins", "dzmin", "Mzstart", "dzMin", "mizmin", "Mxmin", "mczMin", "mczmin", "mizMin", "mozstart", "mozmin", "mwmin", "Mzmax", "MzMin", "mozmins", "mizstart", "mozmax", "Mxmins", "mzmins", "mvMin", "mzMin", "mZmax", "mwstart", "mxMin", "Mzmin", "dizMin", "dzstart", "mZmin", "dizmin", "MZmin", "Mxstart", "dzmax", "mxmin", "mvstart", "Mzmins", "mxmax", "MZmax", "MxMin"], "mzmax": ["MzMAX", "MZax", "mxMAX", "mizmax", " mzhMax", "mZMax", " mzhend", "Mzlast", " mizmin", "mjMax", "Mzax", "MzMax", "mzend", " mzhmin", "mizmin", "mzax", "mZend", "mizlast", "mgzlast", "MZlast", "mzhmax", "mzMax", "mgzmin", " mzMax", "mZax", "mZlast", "Mzmax", "mxax", "mazmin", "mjlast", " mizMax", "mxlast", "mjmax", " mzhmax", "mazMAX", "mZmax", "mzMAX", "mizMax", "mazmax", "mgzMax", "Mzmin", "mzhmin", " mzend", " mizlast", "mZmin", "MZMax", "mxend", "MZmin", "mazax", "mzhMax", "mzlast", "mzhend", " mzlast", "mxmin", " mizmax", "mjmin", "mxMax", "MZMAX", "mZMAX", "mgzmax", "mxmax", "MZmax"], "tstart": ["pstart", "tnstart", "pmin", "fmin", " tstop", "fstart", "fadd", " tmin", "tend", "tadd", "fstop", "ttstop", "tnmin", "ttstart", "ttmin", " tadd", "pstop", "fend", "tnadd", " tend", "ttend", "tmin", "pend", "tstop"], "tdelta": ["tdatum", "tdiff", "ulediffs", "ndata", "ruedatum", "dtiffs", "ruediff", "ruediffs", "tdiffs", "ndiff", "dtiff", "TDiffs", "dtata", "ddiffs", "ruedelta", "TDelta", "ddiff", "TDiff", "uledelta", "TDatum", "ddata", "ndelta", "uledatum", "ddelta", "tdata", "ulediff", "ndiffs", "dtelta"], "peaks": ["meakers", "meakes", "keakes", "peak", "feaks", "speaked", "meaks", "peakers", "peasons", "feasons", "leakes", "teakes", "leaks", "keaks", "leak", "speak", "keaked", "teaks", "meak", "speasons", "feakes", "feakers", "leaked", "keak", "speakes", "teak", "feak", "speakers", "peakes", "teasons", "speaks"], "file": ["writer", "FILE", "report", "image", "core", "parent", "view", "letter", "single", "socket", "temp", "class", "l", "files", "place", "queue", "cache", "per", "wave", "page", "pe", "unit", "e", "resource", "server", "message", "form", "info", "this", "port", "group", "folder", "model", "result", "h", "el", "let", "handle", "parse", "ger", "object", "show", "loader", "global", "w", "path", "where", "feed", "save", "book", "log", "il", "io", "check", "tool", "site", "run", "out", "comment", "print", "db", "user", "File", "function", "buffer", "http", "use", "fp", "force", "sample", "module", "write", "ile", "le", "b", "lock", "output", "f", "it", "source", "reader", "work", "base", "bar", "table", "pipe", "load", "full", "get", "auto", "pool", "fit", "fe", "line", "lib"], "i": ["m", "p", "u", "z", "uri", "e", "n", "fi", "init", "io", "info", "adi", "si", "step", "ie", "part", "it", "ni", "f", "jj", "index", "d", "ci", "iu", "oi", "h", "is", "mini", "multi", "api", "y", "li", "di", "im", "mi", "ip", "eni", "xi", "hi", "pi", "slice", "l", "yi", "id", "uli", "ti", "gi", "v", "c", "start", "sup", "ri", "I", "ai", "ix", "phi", "ini", "ii", "ui", "bi", "x", "mu", "chi", "qi", "ik"], "nothing": ["sorry", " rest", " difference", "Nothing", "hack", "miss", "good", "thing", " no", "init", "yeah", " worst", "none", "info", "empty", "terror", "hello", "different", "tips", " tid", "no", "how", "it", "stuff", " stop", "tt", "done", "ta", "missing", "them", "broken", "T", "total", " tot", "life", "notice", "what", "shit", " trials", " it", "wrong", "anything", "show", " skip", "tests", "everything", "little", "xxx", "wait", "worst", "diff", " trial", "unknown", "whatever", "something", "things", "false", "zero", "huge", " tries", "dt", " total"], "fileLoc": [" fileLOC", "baseLocation", "fLoc", "Fileloc", "fileLOC", "FileLoc", "FileLOC", "floc", " fileloc", " fileLocation", "fileloc", "fLOC", "baseLOC", "fLocation", "fileLocation", "baseloc", "FileLocation", "baseLoc"], "tempDate": [" tempLine", "tmpDat", "tempdate", "tmpdate", "tmpDay", "TempDate", "fakeDat", "temdate", " tempDat", "temDat", "tmpLine", "fakedate", "fakeDate", "tmpDate", "TempLine", "TempDat", " tempdate", " tempDay", " tempSign", "TempSign", "TempDay", "tempDat", "Tempdate", "tempDay", "tempSign", "tmpSign", "tempLine", "temDate"], "t": ["at", "m", " difference", "e", "g", "tz", "n", "b", "flat", "ot", "duration", " tid", "it", "f", " ng", "tt", "d", "ta", "the", " tail", "out", "utt", " n", "that", "tf", "T", "total", "y", " tot", " p", "l", "target", "tim", " it", "ti", "c", " tf", " ta", "ts", " pt", " title", "p", "dt", " ti", " e"], "k": ["ks", "ky", "kr", "K", "dk", "uk", "u", "kat", "z", "kid", "e", "b", "g", "n", "ok", "ki", "ku", "ek", "kick", "f", "jj", "o", "d", "ck", "ka", "ko", "kn", "key", "ijk", "ak", "kh", "y", "work", "l", "kk", "kw", "kl", "v", "unk", "c", "kind", "ke", "w", "mk", "sk", "x", "tk", "q", "p", "ik"], "j": ["ij", "jen", "m", "js", "u", "fr", "z", "e", "b", "g", "n", "off", "kj", "jc", "ie", "f", "it", "jj", "jet", "ja", "o", "d", "ch", "dj", "job", "uj", "key", "aj", "ji", "J", "el", "pass", "jo", "pr", "y", "oj", "li", "l", "bj", "r", "ind", "br", "v", "err", "obj", "dy", "adj", "jl", "ii", "x", "jp", "q", "p", "ik"], "peaked": ["speaky", "cleaked", "meaker", "peaky", "peaker", "speaken", "feaking", "peak", "keaking", "ceaky", "meaken", "keake", "apeaking", "speaked", "cleaken", "paaked", "pak", "apeaked", "peake", "feaken", "cleaking", "ceaking", "ceaked", "paken", "paked", "feaked", "speak", "keaky", "keaked", "meaked", "cleake", "keaker", "peaking", "meaking", "apeaken", "ceaken", "ceak", "paaken", "paake", "keak", "paaking", "paky", "peaken", "ceaker", "feaker", "keaken", "apeaker"], "test": ["filter", "txt", "pack", "report", "server", "call", "build", "master", "scan", "here", "data", "this", "Test", "search", "loop", "f", "all", "py", "check", "result", "trial", "fail", "valid", "end", "out", "val", "pass", "ver", "temp", "iter", "driver", "reader", "print", "inner", "user", "tr", "table", "match", "show", "v", "err", " tests", "tests", "start", "diff", "cher", "runner", "testing", "train", "feed"]}}
{"id1": "19849797", "id2": "15797402", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "clonefile", "transferSource", "copySource", "cloneFiles", "copyfile", "transferfile", "cloneFile", " copyFiles", "copyFiles", "transferFiles", "cloneSource", " copySource", "transferFile"], "sourceFile": ["SourceDir", "destDirectory", "sourceDir", "SourceDirectory", " sourceDir", "destfile", "srcFile", "ourceFile", "SourceFolder", "sourceUrl", "ourcefile", "SourceFile", "SourceUrl", "ourceUrl", "sourcefile", "srcDir", "ourceDirectory", "srcFolder", "sourceDirectory", " sourcefile", "Sourcefile", "destUrl", "srcfile", " sourceFolder", "sourceFolder"], "destFile": [" destPoint", "destDirectory", "sourceDir", " destDirectory", "foreignPath", "DestPath", "destfile", "srcFiles", "srcFile", "destPoint", "targetFile", "resultfile", "DestFile", "targetFiles", " destFiles", "DestPoint", " destDir", "targetfile", "resultLine", "resultDir", "destFiles", "sourceFiles", "srcLine", "targetDir", "DestFiles", "targetPath", "foreignfile", " destfile", "foreignFiles", "destDir", "DestDir", "destPath", "srcDir", "Destfile", "DestDirectory", "foreignFile", "targetLine", "destLine", "sourcePoint", "srcfile", "resultFile", "srcDirectory"], "source": ["index", "root", "from", "remote", "core", "sin", "input", "id", "resource", "uri", "output", "server", "Source", "ie", "site", "slice", "slave", "inner", "current", "table", "result", "dest", "si", "manager", "SOURCE", "iter", "client", "session", "ce", "use", "reader", "proxy", "cache", "connection", "target", "scope", "component", "seed", "parent", "config", "channel", "src", "file", "route", "object", "size", "get", "context", "null", "start", "image", "status", "secure", "url", "scene", "stream", "ource", "unit", "reference", "wrapper", "this", "service", "api", "view", "storage"], "destination": ["Destruction", "distination", " destion", "Destion", " destribution", "Destinate", "participinate", "destation", "constribution", "construction", "identination", "dominated", " destinated", "generinator", " destruction", "constinator", "destinated", "distinated", "distruction", "destion", " destinator", "Destribution", "Destination", "Destinated", "distinator", "Destinator", "identinator", " destation", "distion", "generinated", "generination", "domination", "identinate", "destruction", "destribution", "destinator", "destinate", "generruction", "participination", "identinated", "domation", "Destation", "participinated", "constination", "dominator", "participinator"]}}
{"id1": "8069594", "id2": "665420", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferFolder", " copyfile", " copiedFile", " copiedFolder", " copiedFiles", "copyfile", " copiedfile", "transferfile", "copyFolder", " copyFiles", " copyFolder", "transferFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "base", "pin", "i", "input", "id", "ex", "lock", "ic", "inner", "as", "ins", "bin", "part", "at", "reader", "source", "up", "login", "min", "old", "diff", "inc", "work", "data", "file", "config", "x", "null", "or", "name", "again", "m", "exec", "image", "io", "it", "In", "a", "url", "err", "inn", "win", "this", "din"], "out": ["base", "ex", "output", "n", "server", "outer", "user", "plus", "plain", "version", "OUT", "c", "outs", "o", "all", "off", "write", "bin", "line", "outside", "at", "one", "source", "up", "not", "target", "old", "inc", "file", "object", "x", "p", "null", "conn", "about", "name", "again", "exec", "Out", "io", "writer", "image", "to", "ext", "update", "v", "err", "b", "vert", "this", "external"], "inChannel": ["binStream", "inputChannel", "INchannel", "inStream", "inputchannel", " inClient", "binClient", "inchannel", "binChan", "outContext", "InChan", "loginChannel", "inputChan", "Inchannel", "INChan", "INClient", "outStream", "inContext", "outchannel", "inputConnection", "outChan", "inChan", "InChannel", "loginContext", "InStream", "InConnection", "inputStream", "binChannel", "INStream", " inConnection", "INChannel", " inStream", "inputContext", "inConnection", "inClient", " inChan", "loginchannel", "loginStream", "INConnection"], "outChannel": ["innerStream", "OutStream", "outputConnection", "inStream", "againChannel", "oChannel", "OutChannel", "inchannel", "oChan", "outContext", " outConnection", "againChan", "oStream", "againContext", "againConnection", "OutChan", "outStream", "inContext", "outchannel", "innerChannel", "againStream", "outChan", "inChan", "ochannel", "outputStream", "outputChannel", "innerChan", "outConnection", "Outchannel", "againchannel", "outputChan", "inConnection", " outStream", "innerContext", " outchannel", " outChan"]}}
{"id1": "16079868", "id2": "350482", "code1": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"readIntoList": ["readIntonMap", "readIntoLog", "readTextoMap", "readInttoList", "readIntoMap", "readTextoList", "readInttoLog", "readTextoLog", "readIntonLog", "readIntonList", "readInttoMap"], "url": ["address", "base", "job", "feed", "io", "URL", "path", "remote", "input", "Url", "host", "location", "string", "name", "sl", "gl", "stream", "image", "link", "org", "ssl", "connection", "user", "object", "rule", "config", "buffer", "uri", "service", "resource", "date", "http", "l", "source", "file", "server", "data", "email", "channel", "rl"], "list": ["map", "test", "result", "client", "cache", "status", "view", "dict", "load", "index", "out", "name", "li", "lists", "obj", "queue", "this", "self", "code", "we", "all", "LIST", "menu", "info", "batch", "show", "user", "object", "parent", "join", "see", "listed", "table", "tree", "array", "detail", "get", "l", "data", "pool", "server", "nav", "member", "coll", "json", "group", "part", "record", "temp"], "in": ["gin", "ins", "reader", "din", "IN", "client", "token", "login", "re", "bin", "io", "inc", "raw", "ini", "input", "er", "out", "In", "inner", "stream", "image", "c", "err", "read", "m", "ssl", "a", "i", "r", "b", "again", "rec", "loader", "nin", "fr", "buffer", "iter", "inn", "min", "h", "is", "l", "data", "lin", "file", "source", "con", "as", "f"], "inputLine": [" inputFile", " inputText", "requestLine", "ifline", "outputString", "requestline", "ifName", "inputString", "InputBlock", "commandFile", "requestText", " inputName", "commandName", "InputText", "InputL", " inputStream", " inputLin", "inputFile", "commandLine", "issueLine", " inputString", "argumentBlock", "inputL", "issueline", "InputString", "InputFile", "commandItem", "issueLin", "outputL", "inputName", "inputStream", "Inputline", "InputName", "inputLin", "commandline", "argumentL", "inputline", "InputItem", "argumentLine", "requestL", "ifLine", " inputL", " inputItem", "ifLin", "InputLine", "inputItem", "outputText", "outputline", " inputline", "outputLine", "inputText", "argumentStream", "commandText", "InputStream", "issueName", "commandBlock", "outputFile", " inputBlock", "inputBlock"], "commandNameBegin": [" commandLineBegin", "commandPathBeginning", "commandLineCreate", " commandNameBeginning", "commandNamebegin", "commandParamBeginning", " commandTimeBegin", "CommandNameEnd", "commandLineBeginning", "commandTimeCreate", " commandLineEnd", "commandTimeBeginning", "commandStringBegin", "commandStringEnd", "CommandNamebegin", "commandLengthCreate", " commandNamebegin", "CommandNameBeginning", "commandNameCreate", "commandPathbegin", "commandLineEnd", "commandLengthBegin", "commandStringbegin", " commandNameCreate", " commandTimeBeginning", "commandParamEnd", " commandLinebegin", "commandTimeEnd", "commandLineBegin", "commandNameBeginning", " commandStringBeginning", "commandTimeBegin", "commandParambegin", "CommandLineBeginning", "commandPathEnd", "commandLengthBeginning", "commandLengthEnd", "commandLinebegin", " commandTimeCreate", "CommandLinebegin", "CommandLineEnd", "commandParamBegin", "CommandNameBegin", " commandStringbegin", "commandTimebegin", " commandStringBegin", "CommandLineBegin", " commandStringEnd", " commandTimeEnd", " commandLineBeginning", "commandPathBegin", "commandStringBeginning"], "commandNameEnd": [" commandLineBegin", "commandLineStart", "commandParamend", "operationParamStart", "commandPathBegin", "commandParamEND", "commandLineend", "commandPathend", " commandNameStart", "commandParamStart", " commandLineEnd", " commandLineStart", " commandNameEND", "commandTimeend", "commandNameend", "operationNameEnd", "commandPathStart", "commandLineEnd", "commandnameend", "commandLineEND", "operationNameend", "commandTimeEND", "operationNameBegin", "commandParamEnd", "commandTimeEnd", "commandLineBegin", "commandTimeBegin", "commandTimeStart", "operationParamBegin", "operationNameStart", " commandTimeEND", "commandPathEnd", "operationParamend", " commandLineend", "commandParamBegin", "commandnameEnd", "commandPathEND", "commandNameEND", "commandnameEND", " commandTimeend", " commandTimeEnd", "commandNameStart", "operationParamEnd", " commandNameend", " commandLineEND"], "item": ["result", "base", "ip", "client", "job", "builder", "el", "site", "app", "or", "xml", "owner", "plugin", "er", "hop", "name", "li", "ui", "response", "obj", "action", "image", "next", "link", "order", "si", "Item", "layer", "extra", "event", "items", "menu", "i", "element", "info", "user", "bar", "object", "parent", "handler", "edit", "update", "iter", "service", "api", "option", "admin", "p", "it", "add", "other", "page", "data", "entry", "up", "server", "article", "channel", "source", "instance", "area", "group", "atom", "part", "json", "manager", "temp"], "e": ["oe", "v", "esi", "error", "exc", " event", "Event", "change", "re", "edge", "force", " pe", "ise", "one", "x", "ea", "es", "er", "te", "u", "ee", "c", "err", "this", "E", "fe", "ze", "or", "event", "t", "a", "ie", "en", "ec", "i", "pe", "ce", "ite", "ception", "o", "handler", "ae", "p", "ve", "l", "me", "ev", "se", "ke", "d", "ne", " ev", "ed", "f", "le"]}}
{"id1": "12389873", "id2": "10728243", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"load": [" reload", "get", "process", "clone", "loading", "save", "sync", "transfer", "init", " loaded", "construct", " Load", "write", " loading", "ready", "Loading", "build", " loads", "link", "download", "Load", "test", "add", "read", "dump", "config", "select"], "conn": ["db", "pt", "client", "connect", "ca", "Conn", "h", "p", "ctx", "n", "cp", "cc", "cn", "pg", "ls", "ns", "cat", "cr", "nt", "ci", "cache", "coll", "sb", "reg", "ann", "loc", "Exec", "dn", "state", "connection", "dc", "nc", "con", "conf", "dh", "pub", "util", "oci", "ch", "enc", "sql", "exec", "col", "session", "rt", "ct", "pc", "co", "mc", "Connection", "act", "config", "c", "pr", "ec"], "stmt": ["strs", "STnt", "Stml", "elrs", "STmn", "astql", "putml", "slr", "Stmc", "STct", "ostmt", "stmd", "slnt", " stor", "putur", "playtr", "stpl", "putmb", "Stmb", "sttor", "str", "actmt", " stmi", "playml", "estmt", "STpl", " stpl", "stpr", "stm", "acttr", "Stnt", " stml", "ostager", "atmt", "tm", "Stbt", "dmt", "stmn", "Stdb", "plb", "themc", " stbl", "Stb", "dmd", "stql", "putbt", "fldo", " stm", "estdo", "stmr", "Stager", "Stmr", "atmn", "plmn", " sttor", " stmn", "stmi", "tmt", "atMT", "flmd", "astmn", "Stmd", "flk", "plmt", "cltr", "slager", "playmt", "stmc", "stur", "Stts", "STager", " sttr", "stMT", "strmt", "estth", " str", " stts", "STmt", "playor", "ostpr", "dnt", "putmi", "clmt", "actbl", "estql", "themt", " stmb", "astk", "Stbl", " stager", "Stmt", "Stmn", "tpl", "stbt", "estk", "putmt", "estmd", "strk", "Stur", " stct", "Stm", " stdb", "osttr", " stpr", " stk", "STql", "dMT", "sttr", "stager", "Sttor", "ostmn", "elml", "atb", "plnt", "ostct", "acttor", " stmc", "strmd", "ostpl", " strs", "strdo", "STmd", "Sttr", "stnt", "Stct", "tct", "estMT", "esttr", "stmb", "puttr", "putmn", "slmn", "stdb", " stmr", " stMT", "STMT", "putts", "stml", "stdo", "clmn", "stbl", "flmt", "elmt", " stb", "STbl", "stts", "slmt", "stor", "plMT", "StMT", "plr", "putrs", "Stql", "estmr", " stbt", "themn", "elmi", "stb", " stql", "Stor", "stct", "stk", " stnt", "STml", "theb", "playmn", " stth", "slk", "Stth", "estct", "stth", "clur", "astmt", "Stpl", "STk", "playpl", "STdb", "Stpr"]}}
{"id1": "11616716", "id2": "8320469", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResultAsSteam", "getCMSResultasStream", "getCMSResultInSteam", "getCMSResponseAsStream", "getCMSResultWithStream", "getCMSResponseasReader", "getCMSResponseasStream", "getCMSResultasReader", "getCMSResultInFile", "getCMSResponseasFile", "getCMSResponseAsFile", "getCMSResponseAsReader", "getCMSResponseAsSteam", "getCMSResultAsFile", "getCMSResponseasSteam", "getCMSResultInStream", "getCMSResultasSteam", "getCMSResultasFile", "getCMSResultWithReader", "getCMSResultWithSteam", "getCMSResultInReader", "getCMSResultAsReader", "getCMSResultWithFile"], "rqlQuery": [" rsqlQuery", "srqlquery", " rqlquery", "rqlQ", "rSQLQu", "rqlquery", "rsqlQuery", "riliQu", "srQLQu", " rsqlMethod", "riliquery", " rqlQu", "rQLQ", "rsqlquery", "rSQLquery", "rqlMethod", "rSQLMethod", "srQLquery", "rQLMethod", "rSQLQuery", "rsqlQu", "srqlQu", "rqlQu", "rQLQu", " rqlMethod", " rsqlQu", "riliQ", "rQLQuery", "riliQuery", "rsqlMethod", "srQLQuery", "srQLQ", "rQLquery", " rsqlquery", "srqlQuery", "srqlQ", "rsqlQ"], "osr": ["cosrt", "opsR", "ysr", "ysrt", " osrm", "cosfr", "yscr", "osfr", "oswer", "usrr", "ossr", "osrw", "iosr", "osserr", "otsr", "obsr", "ossrw", "OSrt", "osrr", "osspr", " ospr", "ossrm", "usrs", "otsrm", "iosrw", "osrm", "cosr", "losfr", "uspr", "otssr", "OSrr", "osssr", "ossrs", "otspr", "oscr", "bosR", "ossrt", "usrt", "usrw", "opsrar", " osfr", "oserr", "obsrar", "usr", "osrt", "ossrar", "losrr", "userr", "losrt", "obsR", "osR", "OSr", " osrar", "cosrr", "losr", " osrt", "bosrar", "ysrar", " oscr", "obswer", "ospr", " osrr", "osrar", "bosr", "boswer", "osscr", " ossr", "OSerr", "osrs", "iosrs", "iospr", "opsr", "ossrr", "opswer"], "url": ["resource", "ob", "string", "channel", "host", "blog", "http", "www", "URL", "path", "ll", "open", "Url", "rl", "l", "connection", "base", "ls", "server", "config", "sl", "f", "nl", "socket", "page", "ssl", "fl", "r", "b", "fb", "web", "uri", "source", "client", "org", "file", "lc"], "conn": ["dc", "ch", "pc", "n", "c", "Connection", "pr", "act", "ca", "col", "http", "Conn", "ann", "oss", "conv", "ci", "ctx", "con", "open", "rt", "sync", "attr", "ct", "client", "fn", "loc", "p", "err", "cr", "l", "connection", "net", "cn", "rc", "cp", "exec", "server", "coll", "cur", "reg", "f", "enc", "wrapper", "h", "cb", "rn", "ssl", "nt", "en", "nc", "ec", "connect", "org", "db", "lc"]}}
{"id1": "947406", "id2": "18693224", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "it", "put", "sync", "p", "download", "dump", "Cop", "log", "csv", "clip", "zip", "cop", "paste", "cmp", "cat", "Copy", "transfer", "split", "file", "clone", "replace", "cp", " cp", "write", " transfer", " Copy"], "src": ["cur", "sl", "sin", "loc", "data", "name", "gb", "s", "sc", "ins", "stream", "inst", "bh", "rc", "ource", "rob", "files", "txt", "img", "href", "rs", "fn", "dist", "rb", "sq", "source", "sub", "stab", "js", "filename", "url", "config", "uri", "sit", "id", "sel", "resource", "input", "sb", "string", "use"], "dest": ["prop", "const", "bin", "sup", "opt", "name", "later", "wd", "st", "destroy", "comb", "class", "orig", "die", "output", "txt", "img", "done", "dist", "temp", "test", "d", "source", " Dest", "delete", "thin", "flat", "wb", "folder", "des", "Dest", "result", "target", "dir", "dat", "replace", "home", "de", "desc", "obj", "tmp", "rest"], "in": ["reader", "bin", "lock", "isin", "login", "data", "issue", "it", "socket", "s", "ins", "pin", "m", "cin", "info", "download", "In", "vin", "base", "is", "kin", "conn", "b", "inner", "again", "rin", "win", "r", "din", "trans", "IN", "err", "work", "pull", "ini", "this", "i", "source", "init", "lib", "inc", "nin", "cf", "url", "pass", "thin", "inn", "as", "up", "id", "a", "lin", "input", "con", "diff", "gin"], "out": ["x", "bin", "app", "ext", "data", "socket", "at", "pool", "sync", "ex", "one", "outs", "timeout", "os", "plain", "log", "conn", "cache", "again", "output", "w", "part", "vert", "img", "user", "writer", "inner", "err", "o", "off", "OUT", "client", "this", "call", "lib", "source", "image", "init", "inc", "nin", "or", "exec", "outer", "exit", "no", "our", "io", "net", "up", "file", "index", "id", "aos", "ou", "exp", "Out", "write", "obj"], "buf": ["bin", "cur", "cb", "bd", "f", "data", "seq", "loc", "ff", "fl", "batch", "cap", "buff", "p", "bn", "fab", "bh", "rc", "feat", "orig", "b", "br", "box", "num", "bytes", "bp", "bag", "off", "rb", "buffer", "count", "block", "ctx", "uc", "v", "raw", "cv", "ab", "c", "nb", "pos", "len", "fd", "uf", "queue", "bf", "result", "pad", "ref", "fb", "bc"], "n": ["x", "nt", "nn", "f", "rn", "nc", "un", "sn", "m", "na", "p", "dn", "ns", "j", "k", "en", "ind", "u", "b", "w", "size", "num", "l", "max", "o", "d", "i", "count", "ne", "z", "t", "nin", "v", "no", "number", "nr", "N", "ng", "c", "index", "len", "nd", "length", "write", "nb"]}}
{"id1": "19494842", "id2": "10281203", "code1": "    private void callService() {\n        try {\n            URL url = new URL(baseUrl + servicePath + attributes);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            StringBuffer buf = new StringBuffer();\n            while ((inputLine = in.readLine()) != null) {\n                buf.append(inputLine);\n            }\n            in.close();\n            answer = buf.toString();\n        } catch (MalformedURLException e) {\n            answer = \"Malformed Url:\" + e.getMessage();\n            return;\n        } catch (IOException e) {\n            answer = \"I/O exception: \" + e.getMessage();\n            return;\n        }\n    }\n", "code2": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 0, "substitutes": {"callService": [" callServices", "testService", "Callservice", "callProxy", "callServices", "CallService", "CallServices", " callProxy", "CallProxy", "testServices", "callservice", "testservice", "testProxy", " callservice"], "url": ["log", "URL", "base", "service", "resource", "feed", "this", "stream", "Url", "json", "open", "http", "queue", "l", "b", "conn", "string", "r", "path", "uri", "client", "blog", "ur", "ssl", "server", "user", "file", "ll", "host", "e", "sl", "i", "connection", "source", "web", "f", "socket", "address"], "in": ["re", "err", "kin", "ini", "image", "login", "impl", "stream", "gin", "inner", "inn", "input", "In", "bin", "b", "c", "r", "IN", "buffer", "again", "fb", "doc", "source", "line", "out", "client", "ins", "is", "into", "lin", "init", "ssl", "h", "data", "file", "id", "reader", "i", "win", "din", "f", "socket", "inc", "s"], "inputLine": ["InputLine", "streamFrame", "outputRow", "inputValue", "readline", "Inputline", "readLine", "requestString", "outputline", " inputL", "outputValue", "inputline", "readRow", " inputValue", "InputL", "InputFrame", " inputFrame", "streamLine", "inputFrame", "requestL", "inputRow", " inputRow", "outputLine", "inputString", " inputline", "inputL", "requestLine", "readValue", "InputString", "requestline", "streamString", " inputString", "streamline"], "buf": ["log", "wb", "base", "conv", "pool", " buffer", "nb", "coll", "fun", "abs", "exc", "aux", "ff", "cache", "queue", "bag", "uf", "b", "cb", "bb", "bh", "pad", "string", "builder", "array", "gb", "buff", "cf", "buffer", "Buffer", "fb", "result", "sb", "fp", "cas", "context", "pb", "bu", "data", "cv", "binary", "af", "ob", "header", "rb", "pkg", "bc", "bf", "ctx", "br", "db", "f", "append", "ab"], "answer": ["reply", "question", "site", "prefix", "side", "fix", "order", "entry", "blank", "cache", "message", "swers", "update", "status", "option", "array", "say", "session", "sn", "settings", "attribute", "result", "ask", "uri", "su", "issue", "response", "name", "word", "search", "server", "answered", "knowledge", "Answer", "username", "description", "empty", "stuff", "complete", "value", " answers", "install", "address"]}}
{"id1": "9210168", "id2": "22879400", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"run": ["job", "background", "name", "apply", "un", "stop", "create", "launch", "base", "add", "loop", "register", "inner", "output", "work", "display", "runs", "test", "call", "show", "image", "process", "exec", "update", "code", "unit", "in", "running", "out", "render", "replace", "home", "execute", "invoke", "Run", "start", "runner"], "url": ["sl", "f", "loc", "ur", "remote", "str", "base", "ssl", "loader", "b", "plug", "user", "l", "err", "fr", "address", "Url", "service", "source", "URL", "image", "api", "path", "lr", "server", "uri", "nr", "browser", "http", "file", "id", "resource", "rl", "re", "string"], "fis": ["pIs", "fiss", "bIs", "fisa", " fisa", "flisa", "FIS", "bIS", "FIs", "piss", "flis", " fais", "fIs", " fIs", "pisa", "bais", "pis", "Fis", " fIS", "fliss", "Fiss", "bis", "Fais", " fiss", "flIs", "fais", "fIS", "biss"], "r": ["rh", "reader", "mr", "er", "f", "ri", "s", "ur", "R", "kr", "p", "vr", "ru", "rc", "is", "pr", "b", "rf", "cr", "rs", "ar", "l", "err", "fr", "e", "rus", "rr", "rb", "i", "d", "BR", "hr", "ir", "nr", "rt", "c", "wr", "sr", "rar", "tr", "res", "resource", "rl", "ler", "Reader", "rx"], "br": ["be", "reader", "mr", "Br", "ob", "HR", "arr", "vr", "str", "bh", "bl", "bb", "yr", "b", "B", "bridge", "cr", "err", "fr", "dr", "rb", "BR", "hr", "brush", "ch", "lr", "rt", "browser", "wr", "gr", "sr", "bro", "tr", "res", "result", "bf", "fb", "bc", "buf", "rx"], "line": ["le", "sl", "f", "data", "name", "char", "el", "ge", "str", "letter", "bl", "base", "lc", "inline", "part", "b", "cr", "l", "shell", "cell", "lines", "lf", "key", "column", "row", "buffer", "i", "comment", "style", "entry", "Line", "character", "cl", "li", "code", "number", "nl", "pass", "split", "file", "id", "LINE", "word", "sel", "lin", "header", "link", "rl", "string", "liner", "end"], "sb": ["SB", "BB", "bm", "cb", "bd", "sg", "si", "bj", "sn", "gb", "bs", "buff", "sth", "bt", "eb", "bh", "xb", "bl", "binary", "bb", "ls", "rob", "b", "mb", "erb", "sv", "bp", "rb", "buffer", "storage", "abb", "db", "lb", "zb", "bis", "lr", "sa", "ab", "pb", "amb", "wb", "nb", "src", "bsp", "bf", "sf", "usb", "obb", "fb", "bc", "ib", "buf"], "text": ["connection", "ext", "data", "name", "info", "str", "letter", "format", "output", "b", "txt", "content", "translation", "test", "buffer", "comment", "source", "entry", "value", "Text", "path", "object", "config", "code", "id", "title", "message", "result", "TEXT", "input", "string", "obj", "font"]}}
{"id1": "7149578", "id2": "8754809", "code1": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"parseContent": ["seDescription", "parserData", "seContents", "parserContent", "parseDescription", " parseDescription", "seContent", "parseContents", "parserDescription", "seData", " parseContents", "parserContents", " parseData", "parseData"], "streamLimiter": [" streamLimitter", "streamGrabiler", "streamlimizer", "urllimited", "streamlimitation", "streamGrabiser", "streamLimitter", "streamLimitite", "streamLimitation", " streamLimite", "streamLimititter", "streamGrabitter", "streamLimitited", "streamlimer", "streamlimite", "streamLimer", " streamLimiser", "urlLimitation", " streamLimititor", "streamlimited", " streamLimititter", "urlLimiter", "streamVisizer", "streamlimitor", "streamLimizer", "streamGrabiter", "streamLimititer", "urllimiter", "streamLimited", "urlLimite", "urlLimited", "streamLimiser", "streamLimititor", "streamLimitor", "urllimite", " streamLimitite", " streamLimiler", "streamViser", " streamLimer", "streamVisiter", "streamLimiler", "streamLimite", "streamVisitter", "urllimitation", "streamlimitter", " streamLimititer", " streamLimizer", "streamlimiter", "streamLimititation", " streamLimitor"], "forcedLang": [" sourceFlamp", " requestedLang", " sourceLevelang", " requestedFlph", " requestedLamp", " sourceLamp", " requestedFlamp", " sourceSang", " requestedFliang", " requestedLph", " sourceLph", " sourceLeveliang", " sourceFlang", " sourceFliang", " sourceSiang", " sourceLevelamp", " sourceFlph", " sourceSph", " requestedLiang", " requestedFlang", " sourceLiang", " sourceLang", " sourceSamp", " sourceLevelph"], "charset": ["charARSeter", "chanset", "Charspace", "chARSet", "chARSett", " Chansets", "chansset", "chapterset", "chaseter", "chaseset", "chARSset", "chaspace", "chararsets", "charspace", "ChasET", "cheARSet", "Chasets", "chararsett", "chasesets", "Chanset", "chearsets", "charsetter", "chacterseter", "chararseter", "charARSET", "chararsset", "charansetting", "cheaset", "hasesets", "chARSets", "chARSetter", "chapsets", "Charsets", "hasespace", "chARSeter", "chardsET", "chearsett", "Charsetting", "charansett", "ChARSett", " Chanset", "chaptersett", "charsetting", "Chansetter", "chactersetting", "chansett", "Charset", "chasetter", "chaptersets", "chearseter", "ChARSets", "ChansET", "charARSett", "charARSets", "cheARSetter", "chapset", "Chansets", "charsET", "cheARSett", "charseter", "chansets", "harspace", "chasets", "chasett", "charARSet", "charsets", "chansetter", "charsset", "chaptersET", " Charsets", " Charset", "chARSpace", "charARSetting", "Chaspace", "chararsET", "chapseter", "cheasets", "cheARSets", "chansetting", "chearsetting", "chasesET", " ChansET", "chardsetting", " Chansett", "chARSET", "chacterset", " Charsett", "charARSset", "harsets", "chasespace", "Charsetter", "chearset", " CharsET", "charsett", "chaptersetting", "Chaset", "haseset", "chapsetting", "chasET", "hasesET", "chansET", "chasetting", "chARSetting", "chardsset", "cheARSetting", "cheasetting", "chardset", "cheaseter", "chanseter", "harsET", "chararset", "chactersET", "chanspace", "CharsET", "harset", "charansET", "Charsett", "chaset", "chararsetting", "ChARSetting", "charanset", "chearsetter", "ChARSet"], "sourceDocument": ["SourceFile", "sourceDocuments", " sourceDoc", " sourcedocument", "SourceDoc", "siteDoc", "SourceContent", " sourceFile", "inputContent", "searchFile", "sourceDirectory", "srcDirectory", "siteContent", "sourcedocument", " sourceDirectory", "SourceDocument", "inputDocument", "sourceDoc", "sourceFile", "searchdocument", "siteDirectory", "siteDocument", "inputDirectory", "siteDocuments", "srcContent", "sourceContent", " sourceContent", " sourceDocuments", "searchDocument", "srcdocument", "SourceDocuments", "searchDocuments", "Sourcedocument", "srcDocument", "inputdocument"], "fieldValueItem": [" fieldValue2", "fieldTextItem", "fieldvalueElement", "fieldFamilyPart", "fieldNameItems", "fieldContentElement", "servervalueitem", "fieldName2", "fieldTypeElement", "fieldFamilyParser", "fieldTypeItem", " fieldNameElement", "stringValue1", "fieldKeyItem", "servervalueAct", "stringNameElement", "fieldContentItems", "fieldItemParser", "stringValueItem", "fieldPathIt", "fieldContent1", "fieldvalue2", "FieldFamilyPart", "fieldValueItems", "fieldValueFile", "fieldNamePart", "fieldValueIt", "fieldValue2", "fieldItemItems", "fieldTypeSource", "fieldPathitem", "fieldValueSource", "fieldProcessItem", "memberProcessItem", "memberValueElement", "fieldType2", "FieldFamilyItem", "fieldProcessitem", "servervalueIt", "fieldValueElement", "stringValueItems", "fieldValueitem", "fieldTypeIt", " fieldValueItems", "fieldvalueAct", "FieldValuePart", "fieldvalueIt", "FieldFamilyParser", "fieldTextElement", "memberProcessFile", "fieldNameParser", "fieldNameitem", "stringName1", "fieldType1", "fieldValueAct", "memberValueFile", "fieldItemPart", "fieldvalueItems", "FieldValueItem", "fieldTypeitem", "fieldvalueItem", "fieldValuePart", "FieldNameItem", "memberProcessElement", "memberValueItem", "fieldProcessFile", "fieldValueParser", "fieldPathAct", "fieldvalueitem", "stringValueElement", "fieldNameFile", "FieldNameSource", "FieldValueParser", "fieldNameElement", " fieldNameItems", "fieldContentItem", "FieldValueSource", " fieldName2", "FieldValueItems", "fieldFamilyItem", "fieldKeySource", "fieldNameSource", "memberValueitem", "fieldTypeAct", "fieldValue1", "servervalueItem", "FieldNameItems", "fieldProcessElement", "memberProcessitem", "fieldTypeItems", "stringNameItem", "fieldFamilyItems", "serverValueAct", "fieldItemItem", "serverValueitem", " fieldNameItem", " fieldValueElement", "FieldFamilyItems", "fieldPathItem", "fieldNameItem", "fieldName1", "fieldTextitem", "serverValueItem", "fieldKeyItems", "fieldTextFile", "serverValueIt", "stringNameItems"], "charsetWasNull": ["charsetISEmpty", "charsetWasNULL", "charsetISnull", "charsetwasEmpty", "charsetwasnull", "charsetWereNULL", "charsettingIsConstruct", "charsettingWasConstruct", "charsetIsnull", "charsetISNull", "charsettingIsEmpty", "charsettingWasNone", "charsetsWasNull", "charsetISNULL", "charsetWasFound", "charsettingWasNull", "charsetWasNone", "charsetPreviouslyNone", "charsetwasNULL", "charsetIsEmpty", "charsetWasnull", "charsetIsNull", "charsettingIsNone", "charsettingIsNULL", "charsetPreviouslyNull", "charsetIsFound", "charsettingIsNull", "charsetWasEmpty", "charsetPreviouslyConstruct", "charsettingIsnull", "charsettWasNull", "charsettingWasEmpty", "charsettWasNULL", "charsettWasFound", "charsetWasConstruct", "charsetWereNull", "charsetIsNone", "charsettingWasnull", "charsetwasNull", "charsetPreviouslyNULL", "charsetsWasnull", "charsetIsNULL", "charsetWereFound", "charsettingWasNULL", "charsetIsConstruct", "charsetsWasNULL"], "writer": ["WR", "text", "widget", "wr", "write", "build", "wrote", "outer", "data", "later", "writing", "parser", "engine", "external", "written", "writ", "output", "wrap", "document", "creator", "editor", "Writer", "out", "type", "xml", "temp", "rw", "source", "builder", "driver", "reader", "rew", "ws", "riter", "worker", "walker", "former", "r", "string", "wa", "handler", "wire", "loader", "w", "wb", "writers", "words", "wrapper", "word", "value", "buffer", "format", "ler", "pointer", "office", "author", "director"], "htmlProvider": ["apiReader", "contentManager", "HTMLLocation", "tmlider", "externalider", "HTMLProv", "tmlProvider", " htmlReader", "tmlManager", "phpProvider", "phpManager", "httpProv", " htmlider", "tmlProv", "htmlPool", "HTMLReader", "htmlFactory", "HTMLContext", "phpFactory", "contentProvider", "htmlManager", "htmlider", "tmlReader", " htmlPool", "phpProv", " htmlContext", " htmlFactory", "HTMLManager", "htmlReader", "tmlFactory", "tmlContext", "browserProvider", "httpider", " htmlLocation", "apiProv", "htmlLocation", "contentProv", "HTMLProvider", "tmlLocation", "browserPool", "tmlPool", "externalProvider", "httpProvider", "contentReader", " htmlProv", "htmlProv", "apiProvider", "browserider", " htmlManager", "htmlContext"], "contentType": ["characterName", "characterType", "nextBody", "ContentBody", "contentName", "Contenttype", "ContentTy", "modelTime", " contenttype", "changetype", "characterTypes", "changeTime", "nextName", " contentTypes", "characterTy", "nextType", "contentTyp", "ContentTypes", "ContentName", "contentTime", "modelType", "contentTy", "contenttype", "modelTyp", " contentTyp", " contentTy", " contentName", "changeTyp", " contentBody", "ContentType", "changeType", "modeltype", "contentTypes", " contentTime", "nexttype", "contentBody"], "contentTypeCharset": ["contentTypeChardsets", "contentTypeCasets", "contentTypeClarsette", "contentTypeCharsSet", "contentTypeChardset", "contentTypeChARSET", "contentTypeCaset", "contentTypeCurarset", "contentTypeCarsSet", "contentTypeChapesET", "contentTypeCurARSets", "contentTypeChARSets", "contentTypeChasET", "contentTypeChangett", "contentTypeCurarsET", "contentTypeCangets", "contentTypeCasetter", "contentTypeCurARSet", "contentTypeChansetting", "contentTypeCharsET", "contentTypeCurARSetting", "contentTypeClarsetting", "contentTypeCurARSET", "contentTypeChARSant", "contentTypeCasett", "contentTypeChasetter", "contentTypeChapterset", "contentTypeChansets", "contentTypeChapesets", "contentTypeEARSET", "contentTypeClarsets", "contentTypeChARSetting", "contentTypeEarsant", "contentTypeCurarsetting", "contentTypeChardsant", "contentTypeCarsett", "contentTypeChasette", "contentTypeChapesette", "contentTypeCangSet", "contentTypeCangetter", "contentTypeEarset", "contentTypeEARSet", "contentTypeChapeset", "contentTypeChansET", "contentTypeChaset", "contentTypeChaptersSet", "contentTypeChaptersets", "contentTypeChARSett", "contentTypeChangets", "contentTypeChanset", "contentTypeChaptersetter", "contentTypeChasetting", "contentTypeClarset", "contentTypeChansett", "contentTypeCarsets", "contentTypeChansant", "contentTypeCharsetter", "contentTypeChangetter", "contentTypeCharsetting", "contentTypeChangSet", "contentTypeEarsets", "contentTypeCarsetter", "contentTypeEARSets", "contentTypeChasets", "contentTypeCharsant", "contentTypeChARSet", "contentTypeCharsett", "contentTypeCharsets", "contentTypeChasant", "contentTypeCharsette", "contentTypeChapesant", "contentTypeChasett", "contentTypeEARSant", "contentTypeChardsetting", "contentTypeChapesetting", "contentTypeChARSSet", "contentTypeCurarsets", "contentTypeCarset", "contentTypeEarsET", "contentTypeChARSetter", "contentTypeChanget", "contentTypeCanget"]}}
{"id1": "7044153", "id2": "18974466", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendExceptionWithserver", "sendExceptiontoHost", "sendExceptiontoServer", "sendExceptionWithServer", "sendErrorToserver", "sendExceptionToService", "sendExceptionAsHost", "sendExceptionAsserver", "sendErrorToService", "sendErrortoHost", "sendExceptionAsService", "sendExceptionToserver", "sendExceptionWithHost", "sendErrortoService", "sendErrortoserver", "sendErrorToServer", "sendErrorToHost", "sendExceptionAsServer", "sendExceptionToHost", "sendErrortoServer", "sendExceptiontoService", "sendExceptiontoserver", "sendExceptionWithService"], "server": ["email", "base", "erver", "ssl", "Server", "conf", "domain", "root", "client", "address", "test", "proxy", "service", "db", "port", "ser", "null", "http", " host", "prefix", "header", "host", "addr", "serv", "ip", "json"], "ex": ["x", "full", "su", "ext", "Ex", "ception", "error", "rupt", "aux", "nex", "rex", "event", "str", "Exc", "hex", "log", "class", "status", "base", " exc", "throw", "sex", "export", "err", "ax", "exc", "e", "temp", "acer", "pex", "lex", "example", "exec", "exit", "cl", "except", "fail", "con", "res", "Exception", "def", "exp", "none", "re", "ace", "tx", "obj", "EX"], "config": ["connection", "app", "cb", "ext", "Conf", "options", "settings", "proc", "rc", "log", "base", "text", "conf", "cmd", "bug", "etc", "client", "address", "console", "service", "cfg", "Configuration", "file", "Config", "json"], "prob": ["pebe", "peb", "Probe", "pebs", "Proj", "Probs", " probs", "probe", "proj", "Prob", "probs", " probe", " proj", "pej"], "dataSB": ["dataBL", "uiEl", "execBB", "offLB", "pSB", "innerLB", "DataFB", "errorBB", "contentsb", "nosb", "codeEB", "uiSB", "noSB", "workBB", "eventSB", "strLB", " dataEB", "controlBL", "dataRB", "datasb", "ifsb", "postLB", "ifSL", "postSB", "fileSB", "fullLB", " dataLB", "DataBL", "innersb", "cachesb", "filesb", " dataFB", "errorEB", "datLB", "DataBB", "contentLB", "cacheSB", "datSB", "codeSB", " dataBB", "execBL", "errorPB", "responseLB", "errorSL", "responseSB", "ifLB", "codeLB", "DataLB", "cacheLB", "controlsb", " dataBL", "eventSL", "execLB", "dataBs", "offsb", "fullBB", "DataSL", "DataHL", "DataOB", "loadBB", "datBB", "noSL", "codeRB", "fullBL", "loadSB", "Datasb", "dataOB", "loadsb", "defaultBB", "dataFB", "offSB", "dataEB", "datOB", "responseBL", "offBB", "uiLB", "eventLB", "defaultSB", "codeMB", "dataBB", "eventBB", "workSB", "loadLB", "codeHL", "contentOB", "codeBB", "postsb", "workPB", "innerSB", " dataPB", "fileLB", "DataRB", "errorOB", "strsb", "controlLB", "postSL", "dataSL", "DataSB", "defaultLB", "errorLB", "errorsb", "execsb", "pLB", " dataBs", " dataEl", " dataRB", " dataOB", "dataHL", "innerSL", "offSL", "DataMB", "noLB", "defaultsb", "dataLB", "controlBB", "ifSB", "fileSL", "errorSB", "pBs", " dataMB", "dataEl", "contentSB", "codesb", "codeBs", "codeFB", "codeEl", "strSB", " datasb", "controlSB", "responseBB", " dataHL", "execSB", "psb", " dataSL", "cacheBL", "dataPB", "workSL", "strSL", "dataMB", "fullSB"], "trace": ["trip", "profile", "data", "tri", "scale", "error", "type", "ctr", "span", "string", "array", "stack", "info", "xml", "log", "ptr", "cache", "r", "bug", "trans", "err", "e", "flow", "bean", "address", "temp", "race", "track", "buffer", "test", "atter", "t", " debug", " tracing", "details", "shadow", " traced", "message", "debug", "tr", "result", "out", "cover", "fake", "report", "ace", "tx", " traces", "strip", "runner", "ray"]}}
{"id1": "9872346", "id2": "20210699", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["readLocaldocument", "readLocalDocuments", "readExternalDocument", "loadRemoteDocument", "readServerDocuments", "readServerDocument", "loadLocalDocuments", "loadRemoteDocuments", "readRemoteDocuments", "readLocalDocument", "loadLocalDocument", "loadLocaldocument", "readServerdocument", "readExternaldocument", "readExternalDocuments", "readRemotedocument", "loadRemotedocument"], "url": ["link", "image", "lc", "URL", "base", "service", "email", "feed", "resource", "www", "config", "download", "Url", "entry", "channel", "version", "http", "load", "filename", "remote", "l", "page", "string", " URL", "position", "store", "path", "org", "uri", "layer", "client", "xml", "ur", "socket", "ssl", "location", "name", "server", "host", "file", "ll", "user", "username", "sl", "rl", "loc", "source", "f", "address"], "validate": ["verated", "validated", "validation", " validating", " validated", "verating", "Valated", "Valating", "verate", "validating", "veration", "Valate", "Valation", " validation"], "document": ["image", "video", "index", "model", "graph", "resource", "service", "system", "office", "ocument", "view", "content", "metadata", "project", "function", "text", "message", "output", "media", "object", "page", "application", "null", " documentation", "degree", "collection", "session", "node", "doc", "record", "result", "container", "df", "response", "design", "xml", "Document", "expression", "location", "word", "request", "material", "language", "data", "valid", "port", "value", "database", "source", "parent", "f", "dict"], "factory": ["Factory", "folver", "infiller", "infuture", "FFactory", "fixture", "bactory", "hactory", "infactory", "dactory", " filler", "fade", "sfault", "dade", "affluent", "fsiller", "affactory", "future", " fFactory", "fault", "pactory", "efluent", "fsolver", "efixture", "pixture", "bluent", "hiller", "efactory", "fsactory", "sfixture", "fFactory", " folver", "duture", "sfluent", "biller", "infade", "efiller", "piller", "diller", "pault", "Folver", "affault", "pluent", "filler", "hade", "fluent", "huture", "bixture", "sfactory", "Filler", "fsFactory", "affixture"], "connection": ["image", "link", "index", "service", "resource", "system", "section", "default", "current", "common", "function", "open", "channel", "version", "Connection", "http", "cache", "use", "password", "writer", "conn", "info", "application", "builder", "driver", "c", "position", "condition", "session", "creator", "collection", "relation", "handler", "translation", "io", "container", "uri", "out", "response", "client", "character", "context", "socket", "communication", "proxy", "con", "wrapper", "server", "union", "user", "port", "connect", "error", "database", "reader", "connected", "config"], "stream": ["body", "image", "video", "model", "resource", "system", "raw", "feed", "cont", "view", "coll", "form", "transform", "input", "trans", "entry", "channel", "version", "load", "stack", "output", "media", "writer", "object", "string", "path", "handler", "sc", "translation", "upload", "result", "io", "container", "v", "out", "response", "row", "client", "context", "loader", "server", "data", "file", "sl", "reader", "per", "sw", "Stream", "or", "source", "f"]}}
{"id1": "22410173", "id2": "19006212", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "source": ["image", "size", "ie", "stream", "src", "use", "input", "slice", "internal", "copy", "parent", "route", "id", "sin", "from", "target", "connection", "inner", "path", "resource", "file", "Source", "start", "down", "iter", "url", "unit", "base", "SOURCE", "ins", "name", "site", "reader", "ource", "up", "ources"], "dest": ["de", "src", "output", "delete", "transfer", "comb", "tmp", "thin", "home", "Dest", "target", "connection", "desc", "path", "orig", "exit", "later", "img", "file", "dist", "down", "die", "this", "wb", "temp", "flat", "done", "test", "name", "bin", " destination", "true", "project", "folder", "destroy"], "in": ["r", "image", "client", "m", "pin", "n", "inn", "ie", "gin", "src", "i", "socket", "s", "init", "cin", "input", "id", "din", "conn", "info", "a", "inner", "resource", "pull", "nin", "con", "ini", "work", "file", "start", "inside", "min", "f", "url", "this", "login", "data", "err", "b", "ins", "name", "bin", "In", "by", "plugin", "reader", "IN", "again", "as", "lock", "re", "win", "up", "c", "inc"], "out": ["Out", "plain", "timeout", "client", "writer", "self", "obj", "sync", "off", "n", "up", "i", "output", "socket", "init", "ou", "write", "parent", "cat", "id", "ex", "option", "conn", "to", "connection", "exp", "not", "index", "ext", "io", "our", "inner", "pool", "img", "at", "file", "url", "o", "channel", "exec", "no", "this", "lib", "data", "with", "err", "temp", "log", "vert", "w", "net", "call", "name", "bin", "password", "again", "outs", "extra", "outer", "OUT", "c", "inc"]}}
{"id1": "8132219", "id2": "19335986", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "inFile": ["inputPlace", " inSourceFile", "InSourceFile", "INfile", "binfile", "outPlace", "inputfile", "outfile", " infile", "infile", "inputFile", "outFiles", "InFilename", " inFilename", "Infile", "inFiles", "inPlace", "inputFiles", "binFiles", "binFile", "INFile", "binPlace", "InFile", "INSourceFile", "inFilename", "inSourceFile", "INFilename"], "outFile": ["againFilename", "outputFilename", "outputfile", "againFile", " outfile", "outPlace", "outfile", "infile", "outFiles", "outputPlace", " outFilename", "inFiles", "againfile", " outFiles", "outputFiles", "againPlace", "outFilename", "inFilename", "outputFile", " outPlace"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "n", "ini", "ic", "c", "inner", "as", "ins", "bin", "is", "part", "like", "reader", "source", "connection", "inc", "work", "data", "file", "config", "rin", "x", "name", "again", "m", "image", "io", "In", "a", "url", "inn", "f", "din"], "out": ["string", "buffer", "ex", "output", "n", "copy", "resource", "user", "Output", "plain", "c", "OUT", "version", "o", "outs", "write", "line", "bin", "client", "part", "cache", "dot", "default", "w", "data", "file", "x", "p", "log", "null", "conn", "name", "exec", "Out", "io", "image", "writer", "to", "call", "prefix", "ext", "v", "b", "obj", "external"], "inChannel": ["sinSocket", "INSocket", "inSocket", "inputChannel", "INchannel", "iniChannel", "inStream", " inFlow", " inchannel", "inputchannel", "inchannel", "INFlow", "sinChannel", "inLanguage", "sinChan", "iniLanguage", "winLanguage", "inputChan", "iniStream", "INChan", "outStream", "outchannel", "outChan", "inChan", "inputStream", "inichannel", "outConnection", "INStream", "winChannel", "winchannel", " inConnection", "INChannel", "inConnection", " inChan", "winStream", "sinFlow", " inSocket", "inFlow", "INConnection", "outLanguage"], "outChannel": [" outContext", "OutStream", "againChannel", "OutConnection", "OutChannel", "inchannel", "outContext", " outConnection", "againPath", "againChan", "OutChan", "outStream", "outchannel", "inPath", "outChan", "inChan", "outPath", "OutContext", "outputchannel", "outputChannel", " outPath", "outConnection", "newStream", "Outchannel", "newChan", "againchannel", "outputChan", "inConnection", " outStream", "newContext", "newChannel", " outchannel", " outChan"]}}
{"id1": "8087001", "id2": "12242903", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "label": 1, "substitutes": {"generateStackHashKey": ["generateStackHeaderKey", "generateStackHeaderkey", "generatestackhashkey", "generatestackhashString", "generatestackHashString", "generateStackHashkey", "generateStackhashkey", "generateStackHashKeys", "generateStackHeaderKeys", "generateStackHashString", "generateStackhashKey", "generatestackhashKey", "generateStackHeaderString", "generatestackHashkey", "generateStackhashKeys", "generatestackHashKey", "generatestackhashKeys", "generateStackhashString", "generatestackHashKeys"], "e": ["p", "x", "est", "me", "se", "ace", "c", "f", "this", "event", "ex", "ie", "enter", "exc", "ele", "et", "oe", "ed", "E", "m", "ze", "ec", "n", "a", "b", "pe", "esi", "exec", "fe", "body", "ef", "h", "he", "ception", "element", "ee", "el", "ae", "en", "es", "ev", "t", "r", "err", "er", "o", "Exception", "error", "d", "ea"], "digest": [" digator", " digenge", "decature", "mdate", "Digusher", "Signate", "Digester", "mder", "mdested", " digher", "Signature", "Signester", "Signest", "logest", "Digenge", " Digator", " digusher", "digested", "digusher", "digge", "mdester", "digenge", "digate", "Diger", " Digest", "logher", "decest", "logester", " Digested", " Digester", "digature", "Digator", " digge", "diger", "mdenge", " diger", "Digge", "Digest", "decester", "mdature", "digator", " digested", "Digested", "decate", "mdest", "logge", "digester", " digester", "digher", "mdusher", "Digher"], "hash": ["dot", "text", "message", "history", "bh", "hed", "result", "ashes", "ash", "f", "dig", "image", "build", "kh", "data", "ph", "total", "mac", "base", "v", "array", "b", "Hash", "code", "sha", "hex", "body", "h", "string", "header", "sum", "sh", "ha", "value", "key", "her", "rh"], "rtn": ["RTnin", "RTb", "vrns", "ntc", "ortne", "txc", "ntn", "rtne", "txn", "retns", "RTns", "ntnin", "latne", "RTpn", "RTn", "retn", "rdn", "gtN", "rdns", "rtN", "rtnn", "rdN", "retN", "ntpn", "RTN", "gtn", "txN", "txnin", "rtb", "ntN", "latn", "ortN", "rdb", "RTne", "ntb", "latN", "gtpn", "RTc", "rtc", "gtb", "rtpn", "vrne", "ortnn", "vrnn", "retb", "RTnn", "ortn", "vrN", "rtns", "rtnin", "latns", "vrn"]}}
{"id1": "7764011", "id2": "16798376", "code1": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"readScalarpvviewerDocument": ["readScalarpvviewedocument", "readScalarpvviewerdocument", "readScalarpvvieweString", "readScalarpvViewersDocument", "readScalarpvviewerData", "readScalarpvviewedDocument", "readScalarpvViewerData", "readScalarpvvieweData", "readScalarpvvieweDocument", "readScalarpvViewersData", "readScalarpvviewersData", "readScalarpvViewerdocument", "readScalarpvViewerDocument", "readScalarpvViewersdocument", "readScalarpvviewerString", "readScalarpvviewersdocument", "readScalarpvViewerString", "readScalarpvviewedData", "readScalarpvViewersString", "readScalarpvviewedString", "readScalarpvvieweddocument", "readScalarpvviewersDocument", "readScalarpvviewersString"], "url": ["image", "link", "URL", "base", "resource", "service", "stream", "input", "Url", "entry", "http", "filename", "remote", "l", "href", "object", "page", "string", "bel", "buffer", "path", "job", "io", "uri", "xml", "name", "location", "ssl", "server", "data", "file", "user", "host", "sl", "reader", "connection", "config", "source", "address"], "xmlData": ["phpDATA", "wsString", " xmlPart", "phpData", "parseData", "rssString", "rssDATA", "mldata", "phpPart", "xmlText", "mlDATA", " xmlContent", "parseCode", "rssdata", "xmlDATA", " xmlCode", "textPart", "mlData", "xmlPart", " xmlDATA", "mlText", "mlContent", "phpContent", "xfData", " xmlString", "parseText", "wsdata", "xmlCode", "textData", " xmlText", "textContent", " xmldata", "xfContent", "rssData", "xmlString", "wsData", "xfDATA", "mlCode", "textDATA", "wsDATA", "parsedata", "xmlContent", "xmldata", "xfText"], "in": ["ini", "kin", "login", "serv", "this", "stream", "inner", "inn", "input", "In", "inc", "rec", "l", "b", "bin", "c", "r", "IN", "buffer", "again", "doc", "source", "nin", "min", "out", "ins", "socket", "ssl", "a", "h", "con", "data", "file", "reader", "i", "win", "connection", "m", "din", "f", "lin", "s"], "line": ["unit", "page", "c", "strip", "job", "single", "block", "chain", "name", "file", "el", "str", "comment", "value", "lin", "lc", "log", "point", "content", "cl", "write", "inline", "sync", "auto", "string", "code", "pass", "phrase", "le", "ip", "character", "user", "error", "no", "non", "plugin", "base", "lf", "none", "lines", "entry", "parse", "text", "l", "object", "row", "data", "on", "one", "rule", "link", "letter", "section", "end", "nl", "LINE", "message", "Line", "ine", "pe", "item", "split", "part", "edge", "word", "range", "cell", "e", "sl"], "cont": ["com", "err", "lc", "ident", "expl", "sect", "circ", "feed", "det", "continue", "coll", "content", "form", " continuous", "match", "feat", "text", "count", "full", "ctr", "ent", " cond", "comb", "contract", "left", " Cont", "ct", "resp", "contin", "tr", "ci", "result", " cur", "multi", "CONT", "progress", " CONT", "dest", "cor", "Cont", "out", "rest", "prev", "comp", "cart", "ont", "collect", "close", "clean", "ext", "mult", "keep", "const", "char", "cell", "cond", "str", "complete", "acc", "parent"], "readAdp": [" readAbr", " readAblp", "readAxc", "readAdps", "readAxs", "readEllpi", "readadpi", "loadAdp", " readAds", "readAbb", "readADb", " readadP", "readEdps", "loadAdlp", "loadADlp", "loadADp", "readadp", "ReadAxpi", " readads", "ReadAdps", "loadAdb", "readads", "readADs", "readAxps", "readEllp", " readAdr", "readElllp", "readADp", "readPromlp", " readAdpi", "loadADpi", "readEllr", "readADr", "readAdb", "readAdlp", "readAdr", "readadc", " readAdlp", "readAds", "readEdc", "readAdpi", "loadAdpi", "readADlp", "readAdP", "readAxP", "readadP", " readadpi", "readPromp", "readPrompi", "ReadAxc", "readEdpi", " readAbpi", "readAbp", " readadp", "readadps", "ReadAdpi", "readAxpi", "readEdp", " readAbp", "readADP", "ReadAxp", "ReadAxps", "readAbr", "readPromb", "readAxp", "ReadAdp", "readAblp", "ReadAdc", "readAdc", " readAdP", "readADpi", "readAbpi", "loadADb"], "scalarpvviewerData_Adaptor": ["scalarpvviewerDataerAdaptutor", "scalarpvviewerData_Collectractor", "scalarpvviewerData_Connector", "scalarpvviewerDataerAdaptor", "scalarpvviewerDataeradaptutor", "scalarpvviewerData_Uploadator", "scalarpvviewerDataLocalAdaptor", "scalarpvviewerData_Collectutor", "scalarpvviewerData_Adapter", "scalarpvviewerData_Creater", "scalarpvviewerData_Uploadive", "scalarpvviewerData_Selector", "scalarpvviewerData_Adaptive", "scalarpvviewerData_Selecter", "scalarpvviewerData_adaptator", "scalarpvviewerDataeradaptator", "scalarpvviewerDataLocaladaptor", "scalarpvviewerData_Collectator", "scalarpvviewerDataLocalAdaptors", "scalarpvviewerData_adaptutor", "scalarpvviewerDataerAdapter", "scalarpvviewerData_adaptors", "scalarpvviewerDataeradapter", "scalarpvviewerData_adaptractor", "scalarpvviewerData_Creatator", "scalarpvviewerData_Adaptator", "scalarpvviewerData_Connecter", "scalarpvviewerDataerAdaptator", "scalarpvviewerData_Connectors", "scalarpvviewerData_AdaptOR", "scalarpvviewerData_Creator", "scalarpvviewerData_Connectator", "scalarpvviewerDataLocalAdaptator", "scalarpvviewerData_Uploador", "scalarpvviewerData_Connectutor", "scalarpvviewerData_Adaptutor", "scalarpvviewerData_adaptive", "scalarpvviewerData_Creators", "scalarpvviewerDataeradaptors", "scalarpvviewerData_CollectOR", "scalarpvviewerData_Adaptors", "scalarpvviewerData_adapter", "scalarpvviewerData_adaptOR", "scalarpvviewerDataeradaptor", "scalarpvviewerDataerAdaptors", "scalarpvviewerData_Collector", "scalarpvviewerData_Adaptractor", "scalarpvviewerData_Creatutor", "scalarpvviewerDataLocaladaptator", "scalarpvviewerData_Selectator", "scalarpvviewerDataLocaladaptors", "scalarpvviewerData_Selectors", "scalarpvviewerDataerAdaptractor", "scalarpvviewerData_Collectors", "scalarpvviewerData_ConnectOR", "scalarpvviewerData_Uploadors", "scalarpvviewerData_adaptor", "scalarpvviewerDataLocaladaptOR", "scalarpvviewerDataeradaptractor", "scalarpvviewerData_Creative", "scalarpvviewerDataLocalAdaptOR"], "params_font": ["paramsinglarge", "params_shadow", "ams_chart", "ams_font", "params_text", " params_Font", "pins_password", "params_theme", "ams_large", "pins_text", "params_Font", "paramsingpen", "params_large", "ams_pen", "ams_fat", "ams_theme", "params_fat", "params_layout", "pins_fat", "paramsingfont", " params_layout", "paramsingfat", "params_password", "params_pen", "pins_font", " params_shadow", "params_chart"], "font_size": ["font_scale", "font_align", "font_handle", "fontBlocksize", " font_handle", " font_scale", "font_type", "font\u00b7handle", "text_size", "font\u00b7number", "text_Size", "font_number", " font_Size", "font_Size", "text_align", "fontBlocktype", "font\u00b7size", " font_number", "fontBlockalign", "text_type", "fontBlockSize"], "style": [" size", "force", "letter", "shape", "height", "depth", "offset", "format", "grade", "order", "pattern", "count", "styles", "pad", "scale", "class", "font", "position", "family", "padding", "type", "width", "css", "length", "color", "size", "Style", "estyle", "name", "thin", "margin", "shadow", "layout", "weight", "level", "theme", " Style", "profile"], "font_Family": ["font_family", "fontNameStyle", "fontNamefamily", "style_family", "fontNameFamily", "style_Style", " font_fam", "fontingStyle", "font_fam", "fontingFamily", "font_Format", " font_Format", "fontingfamily", " font_family", "style_Family", "font_Style"], "globalFont": ["generalText", "GlobalText", "globalfont", "Globalfont", "parentFont", "generalFontSize", "localFontSize", "parentFontSize", " globalfont", "GlobalFont", " globalText", "parentfont", " globalFontSize", "generalFont", "parentText", "globalText", "localText", "localFont", "GlobalFontSize", "globalFontSize"], "params_pts": ["params_cts", "params_ptss", "params_epts", "params_ptn", "params__ctm", "params_PTp", "params_ptm", "params_PTn", "params__ctn", "params_PTs", "params_rtm", "params_eptp", "params_PTss", "params_tda", "params_ptp", "params_fontn", "params_tde", "params_PTa", "params_tds", "params_fontp", "params_pta", "params_PTm", "params__ptm", "params__pts", "params_rtn", "params_fontss", "params__ptn", "params_pte", "params_ctm", "params_erts", "params_fonts", "params_ctn", "params__cts", "params_PTe", "params_erte", "params_rts", "params_eptn", "params_eptss", "params_erta"], "params_data": ["param\n", "Parametersname", "params\n", " paramsname", "Parameters\n", "paramsname", " params\n", "paramname"]}}
{"id1": "13122204", "id2": "3024992", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnzipModel", "unzipmodel", "unarchiveProject", "Unzipmodel", "unpatchmodel", "unarchivemodel", "unarchiveModel", "UnarchiveFile", "UnarchiveProject", "unpatchFile", "UnzipFile", "unpatchProject", "unzipFile", "unarchiveFile", "UnzipProject", "unzipProject", "unpackmodel", "UnarchiveModel", "unpackProject", "unpackModel", "unpackFile", "unpatchModel", "Unarchivemodel"], "filename": ["fp", "url", "FILE", "title", "fil", "kl", "model", "path", "folder", "utf", "nil", "location", "string", "name", "database", "files", "jet", "username", "SourceFile", "File", "directory", "loc", "fits", "uri", "fd", "l", "source", "fn", "file", "download", "src", "bf", "txt", "Filename", "f", "il", "module"], "tempdir": ["tmpdirectory", "Tempdirectory", " tempfolder", "tmpDir", " tempDir", "temdir", "TempDir", "temfolder", "tempDir", "temppath", "tmpfolder", "tempfolder", "temDir", "Tempdir", "tmpDIR", " tempdirectory", "TempDIR", "tmppath", " temppath", "Tempfolder", "tempDIR", "temdirectory", "tempdirectory", " tempDIR", "tmpdir", "tempath"], "dest": ["rest", "test", "result", "de", "cont", "st", "sup", "prop", "gen", "delete", "builder", "output", "transfer", "tmp", "zip", "exit", "comb", "proc", "folder", "log", "walk", "default", "export", "target", "flat", "session", "ui", "obj", "inner", "tar", "std", "Dest", "transform", "dat", "desc", "cdn", "handler", "loc", "walker", "nt", "sync", "wb", "done", "dc", "store", "di", "source", "file", "usr", "dist", "dir", "src", "die", "later", "home", "trans", "opt", "txt", " Dest", "temp"], "fis": ["filebis", " fiss", "flisa", "fid", "flis", "liss", "fliss", "fileisa", "fsisa", "fsbis", " fi", "fileis", "li", "lid", "fileid", "fsiss", " fid", "fsis", "filei", "lis", "fbis", "fiss", "fileiss", "fi", "flbis", "fisa"], "BUFFER": ["UPFF", " BUVER", "SAPER", "BUUCK", "BUFER", "BUFF", "CUVER", "TAPER", "BOFFER", "BOPER", "CUUCK", "SAUCK", "CUFFER", "TAVER", "UPFFER", " BUFER", " BUVEN", "CUVEN", "CUPER", " BUFIX", "BOFIX", "CUFF", "SAFFER", "TAFFER", "MAFIX", " BUFF", "MAPER", "BUPER", " BUUCK", "BUFIX", "UPVEN", "BUVEN", "MAFER", "MAFFER", "BOFER", "SAVER", " BUPER", "UPVER", "BUVER", "TAUCK"], "zis": ["zipis", " zists", " zbis", "zipisa", " zisa", "xiss", "diss", " zii", "zins", "Zas", "xis", " zos", "zin", "zii", "xi", "Zisa", " ziss", "zas", " zIS", "yis", "zipIS", "zipas", "zos", "zists", "Zins", "xii", "yin", " zin", "jos", "yIS", "jists", "zi", "Zis", "xos", "jis", "zipins", "dis", "zIS", "yisa", "xists", "zbis", "dbis", "zisa", " zas", "xbis", "dii", " zins", "ji", "zipin", " zi", "ziss"], "entry": ["de", "result", "lc", "reader", "enter", "e", "id", "zip", "feed", "inc", "ace", "ou", "valid", "cel", "je", "ge", "row", "name", "end", "li", "inner", "archive", "image", "next", "spec", "si", "or", "element", "ie", "info", "way", "pe", "ent", "connection", "Entry", "nt", "porter", "her", "pack", "la", "iterator", "jo", "rc", "line", "file", "ry", "se", "match", "source", "server", "ident", "ries", "cat", "part", "record", "ce", "module"], "count": ["base", "cache", "allow", "e", "use", "id", "feed", "current", "_", "Count", "log", "val", "index", "start", "length", "name", "max", "time", "end", "core", "ind", "c", "write", "len", "next", "code", "read", "type", "writer", "i", "counter", "b", "number", "list", "weight", "cond", "buffer", "iter", "add", "key", "line", "in", "file", "last", "low", "pos", "limit", "coll", "part", "sum", "size", "f"], "data": ["result", "base", "reader", "str", "id", "feed", "load", "raw", "DATA", "index", "input", "start", "length", "name", "image", "next", "write", "size", "len", "read", "format", "a", "info", "batch", "dat", "number", "body", "block", "message", "pack", "buffer", "media", "array", "bytes", "alpha", "content", "la", "shift", "pos", "d", "value", "record", "zero"], "fos": ["foes", "dfoes", "fOS", "dfoos", "afos", " foos", "xoes", "afOS", "bis", "xoos", "bOS", " fOS", "dfos", " fops", "afis", "bos", "dfops", "bops", "xos", "fops", " foes", "xops", "afops", "foos"]}}
{"id1": "11484416", "id2": "6470716", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"moveFile": ["moveDirectory", "moveFiles", " movedFile", " movePath", "movePath", " moveDirectory", " movedPath", "MovePath", "MoveFile", "MoveDirectory", " movedFiles", "MoveFiles", " movedDirectory", " moveFiles"], "orig": ["folder", "temp", "ctr", "exe", "raid", "proxy", "bin", "imag", "Orig", "old", "copy", "raf", "transform", "prev", "org", "buf", "dest", "impl", "coord", "original", "archive", "loc", "build", "comb", "frame", "init", "base", "tmp", "coll", "array", "f", "iter", "bas", "real", "ori", "home", "internal", "image", "remote", "ext", "img", "obj", "id", "info", "source", "src", "rb", "file", "origin"], "target": ["resource", "temp", " Target", "external", "project", "join", "current", "copy", "path", "manager", "platform", "match", "force", "this", "dest", "arget", "compatible", "object", "original", "ret", "archive", "template", "build", "it", "base", "replace", "tmp", "f", "eth", "auto", "format", "Target", "to", "remote", "result", "nt", "next", "reference", "t", "prot", "parent", "source", "master", "origin"], "buffer": ["resource", "position", "cache", "request", "uffer", "padding", "bin", "input", "copy", "layer", "wave", "feed", "sequence", "buf", "queue", "slice", "length", "content", "repeat", "address", "header", "batch", "frame", "base", "url", "read", "Buffer", "iter", "code", "bytes", "transfer", "result", "bb", "data", "write", "raw", "null", "b", "stack", "buff", "message", "source", "binary", "block", "file", "reference"], "bread": ["fe", "robe", "fee", "raft", "brew", "zip", "zero", "bat", "piece", "wen", "broken", "str", "buck", "abi", "beat", "bare", "feed", "key", "fle", "die", "bn", "design", "num", "cook", "div", "length", "inn", "bee", "eb", "good", "batch", "grain", "fine", "hello", "choice", "rib", "ffe", "wake", "circ", "fred", "bc", "fed", "fen", "four", "meal", "bb", "rub", "ble", "food", "fall", "fif", "web", "knife", "loop", "sleep", "cake", "width", "rows"], "fis": ["afIs", "lfis", "qos", "fxisa", "afis", "fxis", "his", "lfos", "qiss", "fils", " fIs", "qis", "fIs", " fiss", "ufos", "lfIs", "ufiss", "afiss", "ufis", "hIs", "fisa", "lfiss", " fils", "qils", "hisa", "afos", "fxIs", "fiss", " fisa", "hos", "ufils", "fxos"], "fos": ["Fros", "Foses", "flens", "flos", "fose", "gos", " foses", "infos", " fose", "gis", "infois", "goss", "faos", "Fors", "flors", "fros", "floses", "flose", "fens", "flois", "infors", "Fose", "flaos", "Fis", "Fois", "infaos", "foses", "Fos", "fois", "Foss", "Faos", " fros", " foss", "fors", "foss", " fens", "gros", "Fens"]}}
{"id1": "19849797", "id2": "5299276", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "copyfile", " copyfile", "transferfile", " copySource", "copyFiles", "clonefile", "copySource", "transferSource", "cloneFiles", "cloneFile", "cloneSource", "transferFiles", "transferFile"], "sourceFile": ["SourceFile", " sourceDir", "ourceFile", "SourceUrl", "ourceDirectory", "sourceDirectory", "sourceFolder", "srcDir", "Sourcefile", "srcfile", " sourceFolder", "ourceUrl", "sourcefile", "ourcefile", "destUrl", "destDirectory", "SourceFolder", "sourceUrl", "srcFolder", " sourcefile", "destfile", "SourceDirectory", "srcFile", "SourceDir", "sourceDir"], "destFile": [" destPoint", "DestPoint", "foreignFiles", "foreignFile", "resultLine", "sourcePoint", "destFiles", "DestDirectory", "targetPath", "targetDir", "destPoint", "srcDirectory", "srcDir", "srcFiles", "foreignPath", "srcLine", "destPath", "resultDir", "srcfile", "targetLine", "resultFile", "targetFiles", "resultfile", "DestFile", "destDir", "Destfile", " destDirectory", " destfile", "DestPath", "DestDir", "targetfile", "targetFile", " destFiles", "destDirectory", "sourceFiles", "foreignfile", "destfile", "srcFile", " destDir", "DestFiles", "destLine", "sourceDir"], "source": ["proxy", "component", "url", "uri", "unit", "resource", "image", "core", "server", "parent", "dest", "null", "scope", "view", "connection", "remote", "ce", "this", "si", "session", "ie", "channel", "output", "status", "Source", "result", "input", "site", "route", "storage", "index", "sin", "iter", "api", "src", "reader", "size", "client", "config", "stream", "target", "slave", "seed", "inner", "slice", "table", "object", "id", "cache", "ource", "file", "start", "service", "reference", "root", "SOURCE", "context", "get", "wrapper", "current", "secure", "scene", "manager", "use", "from"], "destination": ["domation", "distination", "generruction", "Destribution", "constination", "domination", "participinate", "identinated", "distion", "destinate", "Destation", "generinator", "constribution", "distruction", "destation", "destruction", "distinator", "Destinator", "distinated", "Destinate", "participinated", "generinated", "Destion", " destinated", "destion", "participinator", " destribution", "destribution", "identination", " destinator", "destinated", "Destination", " destation", "construction", "identinate", " destruction", "destinator", "Destinated", "Destruction", "dominator", "dominated", "generination", "constinator", " destion", "participination", "identinator"]}}
{"id1": "23273706", "id2": "536614", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectPageMeta", "getProjectPageDATA", "getProjecttreeMeta", "getProjectTreeInfo", "getProjecttreeInfo", "getprojecttreeMeta", "getProjectPageData", "getProjectDocumentDATA", "getprojectTreeDATA", "getProjectDocumentMeta", "getProjectDocumentInfo", "getProjectTreeMeta", "getProjecttreeData", "getProjectDocumentData", "getProjecttreeDATA", "getprojecttreeDATA", "getprojectTreeInfo", "getProjectTreeDATA", "getprojecttreeInfo", "getprojectTreeData", "getProjectPageInfo", "getprojectTreeMeta", "getprojecttreeData"], "treeData": [" treeDec", " treeDat", "bodyData", "reeArray", "bodyDat", " treeInfo", "treeText", "reeInfo", "treeInfo", "TreeList", "bodyString", "monkeyDat", "bodyList", "contentDat", "treeString", "TreeData", " treeString", "reeData", "contentInfo", "reeText", "storyDec", "storyDat", "reeList", "reeString", " treeList", "treeList", "reeDat", "storyArray", "monkeyDec", "TreeString", "TreeArray", "monkeyArray", "monkeyData", "storyData", " treeText", "contentData", "treeDec", " treeArray", "treeArray", "TreeInfo", "contentText", "treeDat"], "filename": ["fd", "SourceFile", "prefix", "fn", "ppa", "jpg", "url", "uri", "FILE", "txt", "sheet", "data", "username", "kj", "journal", "title", "folder", "figure", "password", "nil", "kn", "framework", "xml", "dll", "metadata", "directory", "tmp", "fil", "files", "wav", "Filename", "kl", "string", "file", "upload", "name", "dylib", "location", "path", "ername", "whatever", "fp", "database"], "urlString": ["urlStr", "URLURL", " urlstring", "urlUrl", "locationUrl", " urlUrl", "addressURL", "URLStr", "URLString", "locationStr", "urlstring", "locationString", "addressStr", "addressString", " urlURL", "locationstring", "addressstring", "URLstring", "URLUrl", " urlStr", "urlURL"], "urldata": ["urlfata", "urLDdata", "urlfat", "urLDta", " urlddata", "urlddata", "URldata", "urlleddata", "urledATA", "urlledta", "urLDat", "urldat", "urleddata", "URlfata", "URldat", "urledta", " urLDdata", "urlfATA", "urlledata", " urLDta", "urldta", "URlddata", "URlfdata", "urlldata", "urlledATA", "urllATA", "urlfdata", " urldta", " urLDATA", "urLData", "urllat", " urldATA", "urldATA", "urledata", " urLData", "URldATA", "urllata", "urLDATA", "URlfATA", "URlfat"], "factory": ["fFactory", "cflier", "lactory", "conflier", "confiller", "filler", "luild", "lictionary", "confFactory", " filler", " flier", "cFactory", "pFactory", "cactory", "pault", "cfFactory", " fuild", "pactory", "cault", "confactory", "piller", "fuild", "liller", " fault", " fFactory", "ciller", "fault", "cfactory", "flier", "ufictionary", " fictionary", "ufuild", "ufactory", "cfiller", "fictionary", "ufiller"], "parser": ["writer", "lp", "uri", "se", "parent", "b", "manager", "ph", "monkey", "jack", "s", "xml", "instance", "builder", "plugin", "parse", "reader", "library", "driver", "raf", "api", "l", "er", "pdf", "ger", "util", "r", "string", "handler", "loader", "Parser", "up", "t", "fruit", "root", "auto", "json", "utils", "http", "p", "arser"], "u": ["ur", "nu", "uf", "url", "uri", "lu", "b", "ru", "uu", "ul", "io", "universal", "uv", "o", "su", "us", "d", "iu", "s", "uni", "cu", "l", "eu", " ur", "util", "c", "tu", "yu", "U", "ou", "hu", "plug", "ui", "http", "p"], "is": ["p", "gets", "uri", "isl", "lis", "obs", "io", "info", "mis", "ori", "init", "iso", "ie", "in", "it", "es", "bis", "IS", "us", "fs", "s", "iris", "ios", "api", "ar", "ip", "pi", "are", "ib", "iss", "ir", "ais", "ris", "has", "Is", "ob", "ops", "ai", "as", "ui", "or", "isa", "abs", "http", "serv", "ri", "isu", "its"], "os": ["ros", "oa", "dos", "gets", "fits", "obs", "io", "ps", "sys", "osi", "iso", "oss", "aos", "cos", "ose", "pos", "es", "bs", "so", "bis", "o", "bos", "us", "oses", "ms", "fs", "s", "ens", "ios", "Os", "oos", "oes", "ils", "los", "ob", "ops", "ol", "as", "or", "opens", "http", "OS"], "iBufSize": ["iBuffLength", "iBytebufLen", "iBlfLength", "iBlfSize", "iByteufSize", "iBytebufLength", "iByteufsize", "iBufSt", "iLufLength", "iLufSt", "iBufferLength", "iByteufLen", "iByteufLength", "iBytebufSize", "iBuffsize", "iBbufsize", "iBytebufsize", "iLlfSize", "iBuffersize", "iLlfsize", "iBufferSt", "iLlfSt", "iBbufLength", "iBuffSize", "iBbufLen", "iBlfsize", "iBlfSt", "iBbufSize", "iBlfLen", "iBufLen", "iBuffLen", "iBuffSt", "iLufSize", "iLlfLength", "iBufLength", "iLufsize", "iBufferSize", "iBufsize"], "inBuf": ["inBunk", "inBlunk", "inDuff", "inDbuf", "inBaf", "inDaf", "outBbuf", "inBuff", "outBuffbuf", "inBlub", "outBuffub", "inFuff", "inBuffump", "inBump", " inBump", " inBuff", " inFbuf", "outBub", "inFbuf", "inbuf", "inCuff", "outBuf", "outBuffump", "inbub", "inBuffuf", "inPluf", " inCump", " inFaf", " inCunk", " inCbuf", " inFuff", " inCuf", "inbump", "inFuf", " inBbuf", "inBlbuf", "inCaf", "inBuffbuf", "inBbuf", "inBluf", " inFuf", "inBuffub", "inFaf", "inPlump", "inCuf", "outBump", " inBunk", "outBuffuf", "inBub", "inCump", "inDuf", "inBlump", "inPlunk", "inPlbuf", "inCbuf", "inbbuf", "inCunk", " inBaf"], "iNumRead": ["iNumberWritten", "qiNumBuild", "qiValread", "iChanRead", "iValBuild", "iNumread", "pNumWritten", "pNumWrite", "qiValBuild", "inumWritten", "iChanread", "iNumberREAD", "iChanBuild", "iValREAD", " iNumWrite", "iNumberread", " iFatWrite", "iChanREAD", "iValRead", "qiNumread", "qiValREAD", " iFatWritten", "iNumWrite", "inumread", "iNumberWrite", "iLenRead", "inumWrite", "pNumberread", "iNumREAD", "iFatRead", "iNumberRead", "iValread", " iNumWritten", "iNumBuild", "pNumRead", "inumRead", "qiValRead", "iFatWritten", "qiNumREAD", "pNumberWrite", "iNumWritten", "pNumberRead", "iFatWrite", "pNumread", "iLenWritten", " iFatRead", "iLenWrite", "qiNumRead", "iNumberBuild", "pNumberWritten"], "f": ["fd", "m", "fn", "uf", "fr", "e", "j", "sf", "b", "g", "n", "fi", "io", "fa", "o", "d", "feed", "h", "fs", "s", "rf", "l", "ff", "r", "v", "handler", "c", "file", "fc", "t", "full", "F", "fe", "fp", "p", "df"], "inputstream": ["Inputsw", "outputStream", "contentStream", "outputstream", "inputsw", " inputchannel", "contentsystem", "contentstream", "inputchannel", "Inputchannel", "Inputstream", "inputStream", "contentsw", " inputStream", "inputsystem", " inputsw", " inputsystem", "Inputsystem", "InputStream", "outputchannel"], "document": ["m", "page", "doc", "e", "html", "null", "parent", "n", "DOM", "info", "data", "project", "output", "d", "container", "docs", " documents", "xml", "source", "Document", "record", "directory", "media", "l", "tree", "Documents", "node", "object", " documentation", "language", "file", "window", "list", "t", "ocument", "context", "response", "content", "office", "dom", "collection", "director", "p"], "nodelist": ["nozesh", "Nodesh", "anodedelist", "nodsette", "nozename", "nondestate", "nodedette", "nodata", "nonedels", "nodedeme", "nodedemark", "nODlist", "nodedeline", "anodedata", " nodesette", "nonedelist", "nodette", "nodselist", "nonedename", "nondata", "nODestyle", "nodedata", "nozette", "Nodestyle", "nodeestate", "nodeelist", "nodesette", "snodseline", "nODette", "nodedelist", "Nodelist", "snodelist", "nodename", " nodesels", " nodename", "nodeme", "nodestyle", "nondeme", "snodlist", "nodeline", "nodeselist", "NODemark", "nozemark", "snodette", "anodedestate", "nodeeme", "anodedeme", "nonedette", "nODeline", "nodedestyle", "nODesh", "nodedestate", "NODestyle", "NODelist", "nODemark", "snodsette", "nondelist", "nozels", "anodeme", "nodemark", "anodestate", "nodeata", "nodedlist", "Nodemark", "anodelist", "nodlist", " nodels", "nozestyle", "nozelist", "nODelist", "NODesh", " nodeselist", "snodeline", "nodedesh", "nodels", "nodseline", " nodesename", "nodesh", "nodestate", "anodata", "snodselist", "nodesename", " nodette", "nodslist", "snodslist", "nodesels"], "num": ["mon", "norm", "span", "m", "nu", "np", "uri", "unit", "col", "nom", "count", "n", "loc", "init", "nr", "ul", "en", "um", "inc", "part", "pos", "index", "NUM", "sum", "comb", "Num", "uni", "temp", "total", "multi", "max", "len", "tri", "number", "node", "div", "mult", "con", "lim", "dim", "net", "umi", "nam", "mu", "zero", "nb", "dom", "om"], "i": ["m", "uri", "col", "j", "isi", "g", "b", "fi", "ori", "io", "info", "si", "ie", "part", "in", "it", "iv", "o", "index", "d", "ci", "iu", "oi", "ji", "multi", "y", "li", "di", "cli", "mi", "ip", "pi", "hi", "xi", "eni", "l", "slice", "yi", "id", "a", "ti", "v", "gi", "c", "start", "ri", "I", "ai", "phi", "ix", "chi", "ii", "ui", "qi", "mu", "ini", "bi", "x", "p", "ik"]}}
{"id1": "13757855", "id2": "18731843", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "label": 1, "substitutes": {"process": ["Process", "path", "resource", "output", "project", "run", "construct", "load", "proc", "build", "request", "cess", "submit", "processing", "exec", "call", "evaluate", "update", "processor", "parse", "create", "handle", "transform", "code", "view"], "tpl": ["tipl", "templ", "atpl", "fml", "tbl", "lcl", "qtpl", " tple", "Tpp", "tml", "Tbl", "stPL", " tipl", " tplate", "lplate", "latyl", "qtfc", "lpl", "tmpl", " tcl", "latcp", "tcp", "Tplate", " ttemplate", "pipl", "tplate", "Tpl", "temPL", "fplate", "qtple", "lPL", "latpl", "lple", "qtyl", "tmcp", "tmyl", "qtcp", "pcl", "psl", " tplug", "tsl", " tfc", "TPL", " tbl", " tper", "tmple", "tyl", "Tcl", "tpp", "templates", "Tper", "ppl", "tplug", "lml", "itPL", "Tipl", "lper", "Ttemplate", "temtemplate", "qtbl", "atplug", "tplates", " tsl", "pPL", "ttemplate", "itplates", "tfc", "Tple", "Tsl", "Tplates", " tplates", "tcl", "Tml", " tml", "stpl", "itplate", "fpl", "fplug", "atml", "tPL", " tpp", "stpp", "tple", "atplate", "stplate", "Tfc", " tPL", "latple", "itpl", "tper"], "model": ["where", "node", "copy", "json", "message", "document", "project", "result", "location", "params", "doc", "media", "config", "data", "body", "models", "language", "log", "Model", "m", "graph", "conf", "command", "xml", "module", "param"], "packageName": ["PackageName", "Packagename", "contextInfo", "packageInfo", "modulename", "groupUrl", "groupname", "contextname", "packageUrl", " packageNames", "packageNames", "groupName", "projectKey", "moduleUrl", "projectname", "PackageInfo", "moduleKey", "projectName", "moduleName", " packageInfo", "PackageNames", "contextNames", "packagename", "groupKey", "packageKey", " packagename", "projectUrl", "contextName"], "outFileName": ["outFilenameHalf", "outFullTime", "outFullLine", "inDirCopy", "OUTFileHalf", "OutFileName", "outfileOnce", "outfileNames", "outDirName", "outFullname", "difffileTime", "difffileName", "outFilenameNames", "diffFileTime", "OutFilename", "outDirname", "OutDirNames", "outFullNames", "outFileCopy", " outFileInfo", "OUTBufferName", "difffileOnce", "diffFileName", "OutFileLine", "outFilesLine", "outLineInfo", "OUTFileMode", "outLineNames", "outfileName", "inFileName", "outDirInfo", "outfileEnd", "inDirPath", " outFullInfo", " outFileLine", " outDirName", " outFilePath", "outfilePath", "outLinename", "outFileLine", "outFilenameMode", "outFilePath", "outFilenameEnd", "outFullPath", "outFilenamePath", "outLineTime", "outFileInfo", "outfileCopy", "outDirLine", "outfileMode", "outStreamName", "outDirPath", " outDirTime", "OUTBufferMode", "outRuleInfo", "OUTBufferHalf", "outRuleType", "outFilename", "outFilenameCopy", "outDirCopy", "difffileInfo", " outFileTime", "outFileHalf", "outBufferMode", " outDirLine", "outDirNames", "diffFileOnce", "OutDirLine", "outfileInfo", "inFilePath", "OutDirName", "outDirEnd", "outFileEnd", " outFullName", "outFullInfo", "OUTFileNames", "diffFileInfo", "outfileHalf", "outBufferNames", "OutFileNames", " outFileType", "outfileTime", "outDirOnce", "inDirEnd", "inFileEnd", "outStreamInfo", "outFileTime", "outFileMode", "outFileOnce", "outLineOnce", "outFilesPath", "OUTFileName", "outFileNames", "outDirTime", "OUTBufferNames", "outFullType", "outLineName", "outRuleName", " outDirPath", "outFilenameName", "outLineLine", "outBufferName", "outFileType", "outFilesTime", "outFilesName", " outFullType", "inDirName", "inFileCopy", "outStreamType", "OutDirname", "outBufferHalf", "outFullName"], "xsltParam": ["xldparam", "xsldParam", "xsltVal", "xslicVal", "xltMode", "xslpVal", "xslpParam", "xslpMode", "xsldparam", "xltVal", "xslicMode", "xldParam", "xldVal", "xltparam", "xslicParam", "xslicparam", "xslpparam", "xsltparam", "xsldVal", "xltParam", "xsldMode", "xsltMode", "xldMode"], "artifact": ["ARTifest", " artifacts", " artribution", "ARTifact", "Artifact", "adverturation", "aratifest", "ARTfact", "advertifacts", "arturation", "ARTifacts", "advertribution", "aratifacts", "aratifact", "Arturation", " arturation", "Artifest", "aratfact", "Artifacts", "artifest", "artifacts", "artribution", "Artribution", "Artfact", "advertifact", "artfact"], "destinationPath": ["destinatorLocation", "destinationWidth", "restinationHalf", "destinatedpath", "combinatorpath", "restificationPath", "datinationTime", "destinationHalf", "distinatorPath", "destinateHandler", "destinatorHalf", "DestinationName", "destinationCry", "destinatorStep", "distributionPath", "destiationPath", "destiningName", "constinationsName", "DestinationPart", "destiningPoint", "destinationHandler", "destinatedDir", "destinateName", "restinationPoint", "destiationAuth", "destinationUrl", "distinationName", "restificationpath", "restificationPoint", "destinatorWidth", "destificationPath", "constinationContext", "destinatedStep", "destinatingName", "destinatorPath", "destinatorHandler", "restinatorPoint", "destinatorFile", "distributionpath", "destinatingLocation", "desturationHandler", "destinatorKey", "constinatorUrl", "destinationTime", "destplingDir", "distinationCry", "datinatepath", "destinatorString", "distinatorFile", "destinerContext", "destinatedString", "destributionCase", "desticationPart", "distinatorName", "destiationDir", "destationpath", "tempinatedHalf", "DestinatingPoint", "destcreationPath", "destignmentCry", "destiningpath", "datinationpath", "destinationpath", "destinatorPoint", "combinationpath", "destinatedPoint", "destplingUrl", "distinationpath", "destinatorCase", " destificationLog", "constinatorWidth", "destiationLog", "destinatePath", "tempinationDir", "DestificationPart", "destplingWidth", "destinationString", "destinatingPoint", "constinationDir", "destinatedPath", "destinationAuth", "destributionpath", "destinationKey", "destinerPath", "destinatedFile", "destensionText", "restinatorHalf", "destinationsPath", "constinatorDir", "destplingLog", "DestificationPath", "datinatePath", "destinationDir", "constinationUrl", "destinatorTime", "destinationsName", "distinationFile", "restinationpath", "destplingAuth", "destributionPath", "distinationKey", "constinatorContext", "destinationText", "restinationPath", "tempinatedPath", "destinationName", "restinatorString", "destinationPart", "constinationsPath", "destinateString", "distinatorStep", "destinatePoint", "distinationCase", "destributionDir", "desticationFile", "restinationString", "destificationDir", "destinationFile", "combinatorPath", "constinatorPath", "desticationPath", "destinateText", "destensionPoint", " destinationLog", "destiningContext", "destinatingpath", "destplingPath", "desturationpath", "destificationpath", "destignmentName", "restinationLocation", "destificationPoint", "datinateTime", "destributionCry", "datinationLocation", "restinatorPath", "destinatingPath", "destinateLocation", "destinatedHalf", "destinatorCry", " destinationAuth", "DestinatingPath", "destinerDir", " destinationDir", "destcreationUrl", "constinationspath", "constinationWidth", "destributionName", "destinatorpath", "destinationStep", "tempinationPath", "destationPath", "destensionPath", "combinationHandler", "tempinationHalf", "datinationPath", " destificationAuth", "destiningDir", "destinatorUrl", "distributionDir", "destiningPath", "distinatorCase", "destinatedCase", "DestinationText", "distinationStep", "distributionCase", "destinatingText", "destationTime", "destinatorDir", "desturationPath", "DestinatingText", "destificationName", "destinateDir", "tempinationpath", "datinateLocation", "distinationDir", " destificationPath", "destinationCase", "distinationPath", "destationLocation", "destificationPart", "combinationName", "distinatorCry", "desticationKey", "combinatorHandler", "destinateHalf", "destificationAuth", "destinationLog", "destinatedKey", "desticationStep", "tempinatedDir", "destificationLocation", "desturationName", "constinationpath", "destinatepath", "destinationLocation", "constinationPoint", "destinationContext", "destensionName", "constinationName", "destinateTime", "constinationsPoint", "combinatorName", "destignmentCase", "destinationspath", "DestificationName", "DestinationPoint", "destinatorContext", "constinationPath", "DestinatingName", "restificationLocation", "destcreationWidth", "destignmentPath", "distinatorKey", "desticationName", " destificationDir", "destinationsPoint", "constinatorpath", "DestinationPath", "destinationPoint", "tempinatedpath", "destinatePart", "destinatorName", "destinerpath", "destificationLog", "combinationPath"], "in": ["IN", "i", "input", "ex", "n", "con", "c", "ins", "bin", "source", "reader", "d", "doc", "cache", "connection", "min", "r", "inc", "config", "data", "x", "name", "image", "t", "In", "din"], "out": ["index", "string", "path", "temp", "outer", "output", "ex", "sys", "server", "user", "lock", "copy", "Output", "version", "OUT", "result", "outs", "o", "pool", "all", "write", "line", "manager", "bin", "key", "post", "client", "part", "session", "source", "doc", "cache", "lib", "up", "connection", "str", "group", "store", "parent", "w", "file", "page", "log", "gen", "conn", "msg", "ne", "again", "name", "exec", "Out", "io", "writer", "dump", "prefix", "full", "free", "comment", "err", "obj", "with", "state", "cli", "error", "list", "point"], "root": ["index", "path", "node", "loader", "id", "results", "resources", "json", "instance", "modules", "meta", "query", "pattern", "params", " result", "cache", "r", "cat", "collection", "parent", "roots", "Root", "options", "format", "tree", "graph", "values", "url", "_", "include", " roots", "history", "xml", "module", "transform"]}}
{"id1": "4686922", "id2": "20619879", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourcesAsfile", "extractResourceInResource", "extractResourceInFile", "extractResourceToResource", "extractResourceInfile", "extractResourceToFiles", "extractResourceInFiles", "extractResourcesToFiles", "extractResourceAsResource", "extractResourcesToResource", "extractResourcesAsFile", "extractResourceAndResource", "extractResourceAsFiles", "extractResourceAsFile", "extractResourcesAsResource", "extractResourcesAsFiles", "extractResourceAndfile", "extractResourceAndFiles", "extractResourceAsfile", "extractResourcesToFile", "extractResourcesTofile", "extractResourceTofile", "extractResourceAndFile"], "resourcePath": ["servicepath", "sourceUrl", "ResourceId", " resourceId", "serviceFolder", "resourceFolder", "resourcepath", " resourcepath", "sourceId", " resourceUrl", "sourcePath", "stringpath", "servicePath", "ResourcePath", "resourceUrl", "stringPath", "sourcepath", "stringFolder", "Resourcepath", " resourceFolder", "resourceId", "ResourceUrl"], "dest": ["sac", "result", "de", "img", "prop", "sup", "project", "output", "tmp", "comb", "transfer", "path", "folder", "default", "target", "filename", "flat", "resources", "Dest", "class", "route", "desc", "const", "config", "wb", "done", "resource", "content", "store", "data", "destroy", "file", "source", "dist", " destination", "src", "contract", "die", "later", "home", "trans", "txt", " Dest", "temp"], "in": ["url", "gin", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "ini", "input", "In", "conn", "inner", "image", "c", "this", "like", "i", "r", "connection", "b", "n", "again", "sin", "rec", "socket", "nin", "win", "resource", "inn", "plus", "is", "arin", "cin", "source", "lin", "up", "file", "init", "inside", "kin", "rin", "pass", "con", "as", "f"], "out": ["net", "exec", "ins", "OUT", "client", "outs", "cache", "w", "output", "bin", "app", "io", "inc", "one", "boot", "outside", "auto", "conn", "s", "In", "ext", "obj", "image", "err", "this", "off", "Out", "ax", "lib", "norm", "all", "at", "writer", "i", "a", "user", "b", "ex", "n", "null", "again", "o", "co", "parent", "sync", "socket", "outer", "copy", "cookie", "cos", "source", "file", "up", "server", "f", "temp"]}}
{"id1": "12579075", "id2": "8747840", "code1": "    public static XMLConfigurator loadFromSystemProperty(String propertyName) throws IOException {\n        String urlStr = System.getProperty(propertyName);\n        if (urlStr == null || urlStr.length() == 0) {\n            return null;\n        }\n        InputStream in = null;\n        DOMRetriever xmlDoc = null;\n        try {\n            URL url = new URL(urlStr);\n            xmlDoc = new DOMRetriever(in = url.openStream());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (in != null) in.close();\n        }\n        return newInstance(xmlDoc);\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 0, "substitutes": {"loadFromSystemProperty": ["loadFormsystemperties", "loadFormsystemproperty", "loadFromLocalString", "loadFormSystemproperty", "loadFromLocalProperty", "loadFromsystemperties", "loadFromSysperties", "loadFromSysproperty", "loadFormsystemString", "loadFromsystemProperty", "loadFromLocalproperty", "loadFromSystemproperty", "loadFromSysString", "loadFormSystemperties", "loadFormsystemProperty", "loadFromSysProperty", "loadFromsystemString", "loadFormSystemString", "loadFromsystemproperty", "loadFromSystemperties", "loadFromSystemString", "loadFromLocalperties", "loadFormSystemProperty"], "propertyName": ["propStr", "propertyNames", " propertyStr", "propPath", "filePart", "propertyPart", "PropertyStr", "propertyPath", "PropertyName", " propertyString", "propName", "propertyStr", "fileNames", " propertyNames", "fileName", "propPart", "fileString", "propertyValue", "propString", "PropertyPath", "propValue", " propertyValue", "propertyString", "PropertyValue", "propNames", " propertyPart", " propertyPath"], "urlStr": ["UrlName", "urlText", "urlName", "URLWr", "uristr", "Urlstr", "URLString", " urlText", "UrlWr", "URLstr", "uriStr", "uriWr", "UrlText", "httpStr", "urlstr", "urlSt", "httpstr", "httpText", " urlSt", "URLSt", "URLStr", "resourceString", "uriName", "resourceStr", " urlString", " urlWr", " urlstr", "urlWr", " urlName", "URLName", "urlString", "resourceSt", "UrlStr", "UrlString", "httpName", "UrlSt"], "in": ["p", "source", "as", "init", "inn", "gin", "out", "client", "cf", "session", "inner", "c", "ac", "f", "i", "input", "l", "socket", "serv", "conn", "image", "src", "IN", "data", "m", "con", "ini", "resource", "n", "isin", "bin", "a", "din", "fac", "is", "nin", "min", "ins", "cin", "stream", "In", "again", "file", "part", "r", "err", "login", "ssl", "id", "reader", "inc", "ic", "doc"], "xmlDoc": [" xmlStr", " xmlConfig", " xmlDom", "jsonDocument", "jsonStr", "mlDocument", "xmlDom", "domUrl", "externalDocument", "mlConfig", "officeDocument", "domDoc", "jsonDoc", "officeDom", "officeStr", "xmlUrl", "mlUrl", "mlDoc", "domDocument", "mlStr", " xmlDocument", "jsonDom", "webDoc", "officeDoc", "externalStr", "xmlConfig", "webUrl", "webDocument", "xmlDocument", "externalDoc", "externalConfig", "domStr", "xmlStr", "webStr"], "url": ["ls", "source", "gl", "buffer", "uri", "str", "browser", "client", "Url", "instance", "download", "config", "f", "input", "l", "src", "socket", "inst", "image", "data", "web", "resource", "open", "www", "io", "base", "inf", "bel", "b", "server", "URL", "sl", "string", "connection", "fr", "stream", "el", "ll", "file", "ssl", "feed", "id", "reader", "user", "http"]}}
{"id1": "494226", "id2": "4593012", "code1": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"linesep": ["lineeps", "ineseps", "nseper", "linerseter", "linersew", "linpace", "linseter", "lineearch", "linersearch", " linesupp", "ringspec", "linerseng", "lineseper", "gesyp", "gesep", "linepace", "inesep", "lineps", "linespace", "geseps", "linedep", "linepec", "linspec", "linep", "lineseng", "lineseps", " lineseps", "linsep", "linersep", "linesew", "timesep", " linesaper", " lineseter", "lineseter", "ringspace", "lineep", "linyp", " linesew", "linspace", "nseps", " linesearch", "nsep", "linesyp", "linesaper", "timesyp", "linedew", "inesaper", "lineupp", "linespec", "linseps", "ineseper", "nsaper", "linsew", "codeseps", "gespe", "linseng", "linerseps", "timespe", "linesupp", "ringsep", "timeseps", "linesip", "linpec", "linesearch", "linedip", " linespec", "linersip", " lineseper", " lineseng", "linpe", "codesew", "ringsupp", " linespace", "linedeps", "codesip", "linespe", "linerspec", "codesep"], "fos": ["coes", "FOs", "cos", "infops", "foses", "FOS", "focks", " fOS", "fes", "infotes", "loadOs", "foros", " foses", "loadoS", "Fios", "go", "fotes", "cols", "eol", "poes", "fats", "Fats", " fats", "loados", "infoses", "fo", "Foser", " fops", "Foses", "fingocks", "infes", "coos", "Foes", "foes", "Focks", "foS", "Fis", "fops", "fOs", "poos", "fullis", "pols", "infols", "Fes", "Fos", "forOS", "foser", " fo", "zotes", "zo", "loadops", "zol", " fOs", "fingos", "infios", "eos", "info", "gocks", "Fops", "gos", "fingoss", "infoos", "eotes", "infoes", "infos", " foser", "eo", "fulloser", "fios", "pos", "foos", " fios", "fulloes", " fes", "Fo", "fol", "forats", "fis", " foes", " fis", "fOS", "fullos", "FoS", "foroses", "goss", "Foss", "foss", " foS", "infol", "fols", "zos", "fingo", "infis"], "files": ["ids", "pages", "scenes", "f", "images", "blocks", "thumbnails", "data", "rows", "bs", "groups", "services", "balls", "results", "ins", "events", "lets", "Files", "ls", "items", "models", "members", "obs", "features", "apps", "l", "workers", "tools", "lines", "strings", "facts", "archives", "iles", "objects", "books", "classes", "names", "boxes", "http", "keys", "file", "jobs", "ports", "locks", "states", "users", "projects", "tests", "headers", "bugs", "rules", "plugins", "resources", "docs", "fs"], "i": ["ji", "f", "current", "y", "si", "it", "start", "ti", "ri", "type", "slice", "m", "p", "j", "info", "pi", "ie", "ix", "hi", "I", "di", "u", "b", "multi", "inner", "qi", "fi", "e", "ini", "d", "count", "ci", "z", "t", "xi", "v", "oi", "ui", "yi", "li", "uri", "ii", "io", "c", "id", "index", "iu", "eni", "ai", "gi", "phi", "col", "ip"], "metaprops": ["metoprops", "metoppropes", "metapropps", "metaprpps", "metaparps", "metaprope", "metopprop", "metoprope", "metapPropps", "metepropps", "metaprobpe", "metapprope", "metopropp", "metaprobps", "meteprope", "metaporeps", "metaporepps", "metapproperties", "metaporepe", "meteppropes", "metaprop", "metopprops", "metaproperties", "metopropps", "metaporepes", "metaprobpps", "metaprobp", "metaprobpes", "metappropes", "metapprop", "metaprospes", "metaparpps", "metoppropps", "metopprope", "metopproperties", "metaprosps", "metappropp", "metapropp", "metappropps", "meteppropps", "metopropes", "metepprope", "metoproperties", "metaprpes", "metaparpp", "metapropes", "metaprospps", "metaprobpp", "metaprps", "metapProps", "metapprops", "metoprop", "meteprops", "metepprops", "metaprpe", "metaprosperties", "metaprobperties", "metapPrope", "metoppropp", "metapPropes", "metaparp", "metepropes"], "itsect": ["Itect", "itssection", "itersect", "litrupt", "Itsector", "itrupt", " itsector", "iterrupt", "itsector", " itsection", "litna", " itect", "Itna", " itconnect", "itsection", "itssect", "litect", "itconnect", "Itrupt", "Itsection", "itect", " itrupt", "Itconnect", "Itsect", "itna", "litsect", "iterect", "itssector", "iterconnect", " itna"], "section": ["job", " Section", "division", "loc", "name", "version", "sect", "sections", "array", "j", "sector", "set", "ie", "rc", "description", "page", "part", "text", "protection", "year", "line", "account", "key", "vision", "esc", "mission", "service", "step", "entry", "sub", "closure", "child", " sections", "sec", "ion", "environment", "second", "config", "route", "Section", "function", " subsection", "script", "search", "edition", "header", "ect", "ection", "area", "string", "element"]}}
{"id1": "4629990", "id2": "11952735", "code1": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 0, "substitutes": {"logonToServer": ["logonToGuest", "logOnFromRemote", "logOnFromClient", "logOnToRemote", "logOnToServer", "logOnFromServer", "logonTOClient", "logonFromServer", "logonTOGuest", "logOnToClient", "logonFromGuest", "logOnToGuest", "logonFromClient", "logonFromRemote", "logontoRemote", "logonTOServer", "logonTORemote", "logontoClient", "logOnFromGuest", "logonToRemote", "logontoServer", "logonToClient", "logontoGuest"], "ftpClient": ["ftcpAPI", "ftpaClient", "ctpPort", "ftbclient", "ftbConn", "ftcpPort", "ctcpConn", "ctcpConnect", "ctcpServer", "ftapclient", " ftpCloud", "ftpConnect", "ftpaCloud", "ftpaConn", "ftpcClient", "ftcpCenter", "ftprClient", " ftpclient", "ftpaServer", "ftpclient", " ftpaServer", " ftpaClient", "ftcpContext", "ftpiServer", "ftpcConnect", "ftpConn", "ftprPort", "ftpiClient", "ftpcServer", "ftpcPort", "ftcServer", " ftbCloud", "ftpcContext", " ftpPort", " ftpcServer", " ftpcClient", "ftpiAddress", "ftsPort", "ftcpClient", "ftcConnection", "ctpAPI", "ctpServer", "ftcClient", "ftcpConn", " ftpcContext", "ftpcAddress", "ftpaPort", "ftsClient", " ftpConn", "ftcpConnection", "ftpaCenter", "ftcpServer", "ctpConnect", "ftbPort", " ftpaclient", " ftpServer", "ftsServer", "ctcpAddress", "ctcpAPI", " ftpConnection", "ctpAddress", "ftpConnection", "ftpcclient", "ftpcConn", "ftbCloud", "ftnAddress", " ftpcConnection", "ctcpClient", "ftapCenter", "ftcContext", " ftpCenter", " ftpaCenter", "ftnServer", "ctcpPort", "ftpCloud", "ftbClient", "ftpContext", "ftpAPI", "ftcpConnect", "ftnClient", "ftapClient", "ftpcCloud", "ftsConnect", "ftnAPI", " ftpaPort", "ftapServer", "ctpConn", "ctpClient", "ftpServer", "ftpiAPI", "ftcpAddress", "ftcpclient", "ftprclient", "ftpcConnection", "ftpaAddress", " ftpContext", "ftpaclient", "ftpPort", " ftbConn", "ftpCenter", " ftbClient", " ftbclient"], "ftpAddress": ["ctpPort", "ftcpURL", "ftcpPort", " ftpaddress", "ftfAdd", "ftoAddress", "ftapPort", "ctoPort", "ftfEntry", " ftcpaddress", "ctpAdd", "ftoaddress", "ftfPort", "ftapAlias", "ctcpURL", "ftlAddress", "ftcpInterface", " ftcpAddress", "ftrInterface", "ftwpAddress", " ftcpPort", "ftportaddress", "ftnpAddress", " ftpPort", "ctcpaddress", "ctcpInterface", "ftlPort", "ctpaddress", "ftnpPort", "ftwpaddress", " ftcpAlias", "ctoAddress", "ftportPort", "ftfInterface", "ftportAlias", "fttpPort", "ctcpAdd", "ctcpAddress", "ctpInterface", "ftapaddress", "ftnpURL", "ctpAddress", "ctoaddress", "ftcpaddress", "ftpInterface", "ctpEntry", "ftpURL", "ftrPort", "ftrAdd", "ftpAdd", "ftladdress", "ctcpEntry", "ctcpPort", "ftcpAlias", "fttpURL", "ftfAddress", "ftpAlias", "ftwpPort", "ftpEntry", "ftapAddress", "ctpURL", "ftcpAddress", "ftnpaddress", "fttpEntry", "fttpaddress", "ftrAddress", "ftfaddress", "ftcpEntry", "ftcpAdd", "ftportAddress", "ftpPort", "ftpaddress", "fttpAddress", "ftoPort", " ftpAlias"], "noRetries": ["noretrying", "noEntrying", " noPatriers", " noRetrys", " noPatries", "noPatrys", "noTry", "noTrying", "noPatry", "noPatriers", "noTrys", "noExtrys", "noExtrying", "noretries", "noExtries", " noPatry", "noRetrying", "noEntries", "noTries", " noPatrying", " noRetriers", "noRetriers", "noPatries", " noPatrys", " noRetry", "noretrys", "noRetrys", "noRetry", "noretriers", "noEntrys", "noEntriers", " noRetrying", "noExtry", "noPatrying"], "remoteHomeDir": ["remoteHomePath", "RemoteRootPath", " remoteHomeFolder", "remoteHostPath", "RemoteHomeFile", "remoteWorkingPath", "remoteRootDir", " remotehomeFolder", "remoteHomeFolder", " remotehomeFile", "remotehomePath", "remoteHostDirectory", "remoteRootPath", "remotehomeFolder", "remoteRootDirectory", "remoteHostDir", "RemoteRootFile", "remoteHostFolder", " remoteHomeDirectory", "RemoteRootDirectory", "remoteRootFile", "remoteWorkingDir", " remotehomeDir", "RemoteHomeDirectory", "remoteHomeDirectory", "remotehomeFile", "remoteRootFolder", "RemoteRootDir", "RemoteHomeDir", "remotehomeDirectory", "remoteWorkingDirectory", "remoteHostFile", "RemoteHomePath", " remoteHomeFile", "remotehomeDir", " remotehomeDirectory", "remoteHomeFile", "remoteWorkingFile"], "noRetriesSoFar": ["noRetryingsoMuch", "noRetriesSOFurther", "noRetriesStillFurther", "noRetriesSofar", "noRetriessoFar", "noRetrySoFar", "noRetriesTooMuch", "noRetriesSoFurther", "noRetrySOfar", "noRetrysSOFar", "noRetrysSoFar", "noRetriesStillFar", "noRetrysSOfar", "noRetryingSoMuch", "noRetriessoMuch", "noRetriessofar", "noRetriessoFurther", "noRetryingsofar", "noRetrysSofar", "noRetrySOFar", "noRetriesSoMuch", "noRetrysSoFurther", "noRetriesSOMuch", "noRetriesSincefar", "noRetrySofar", "noRetriesTooFar", "noRetriesSOfar", "noRetrysSOFurther", "noRetryingSoFar", "noRetryingsoFar", "noRetryingSofar", "noRetriesSOFar", "noRetriesSinceFar", "noRetriesToofar", "noRetriesStillfar"], "reply": ["address", "result", "base", "error", "lie", "ping", "send", "status", "call", "answer", "comment", "feed", "request", "py", "state", "ret", "queue", "prefix", "link", "len", "bot", "next", "write", "code", "respond", "reason", "repl", "connection", "count", "info", "user", "report", "Reply", "sync", "ply", "message", "post", "service", "ix", "from", "rc", "dy", "resp", "server", " replies", " replied", "response"]}}
{"id1": "6371589", "id2": "17029388", "code1": "    public void insertUser(final List<NewUser> newUsers) {\n        try {\n            connection.setAutoCommit(false);\n            final Map<String, PasswordAndSalt> pass = new HashMap<String, PasswordAndSalt>();\n            final Map<String, List<RealmWithEncryptedPass>> realmPass = new HashMap<String, List<RealmWithEncryptedPass>>();\n            final List<String> userDirs = new ArrayList<String>();\n            Iterator<NewUser> iter = newUsers.iterator();\n            NewUser user;\n            Realm realm;\n            String username;\n            PasswordHasher ph;\n            while (iter.hasNext()) {\n                user = iter.next();\n                username = user.username.toLowerCase(locale);\n                ph = PasswordFactory.getInstance().getPasswordHasher();\n                pass.put(user.username, new PasswordAndSalt(ph.hashPassword(user.password), ph.getSalt()));\n                realmPass.put(user.username, new ArrayList<RealmWithEncryptedPass>());\n                realmPass.get(user.username).add(new RealmWithEncryptedPass(cm.getRealm(\"null\"), PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, \"\", user.password)));\n                if (user.realms != null) {\n                    for (String realmName : user.realms) {\n                        realm = cm.getRealm(realmName);\n                        realmPass.get(user.username).add(new RealmWithEncryptedPass(realm, PasswordFactory.getInstance().getPasswordHasher().hashRealmPassword(username, realm.getFullRealmName(), user.password)));\n                    }\n                    user.realms = null;\n                }\n            }\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"user.add\"), Statement.RETURN_GENERATED_KEYS);\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    DomainDb domain = null;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        psImpl.setString(1, user.username);\n                        psImpl.setString(2, user.username.toLowerCase(locale));\n                        if (domain == null || (domain.getDomainId() != user.domainId)) {\n                            domain = (DomainDb) cmDB.getDomain(user.domainId);\n                        }\n                        userDirs.add(user.username + '@' + domain.getDomainName());\n                        psImpl.setInt(3, user.domainId);\n                        psImpl.setString(4, pass.get(user.username).password);\n                        psImpl.setString(5, pass.get(user.username).salt);\n                        psImpl.executeUpdate();\n                        rsImpl = psImpl.getGeneratedKeys();\n                        if (rsImpl.next()) {\n                            user.userId = rsImpl.getInt(1);\n                            rsImpl.close();\n                        } else {\n                            throw new SQLException(\"Need to have a user id generated.\");\n                        }\n                    }\n                }\n            });\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.addUser\"));\n                    Iterator<NewUser> iter = newUsers.iterator();\n                    NewUser user;\n                    List<RealmWithEncryptedPass> list;\n                    RealmWithEncryptedPass rwep;\n                    RealmDb realm;\n                    while (iter.hasNext()) {\n                        user = iter.next();\n                        list = realmPass.get(user.username);\n                        if (list != null) {\n                            Iterator<RealmWithEncryptedPass> iter1 = list.iterator();\n                            while (iter1.hasNext()) {\n                                rwep = iter1.next();\n                                realm = (RealmDb) rwep.realm;\n                                psImpl.setInt(1, realm.getRealmId());\n                                psImpl.setInt(2, user.userId);\n                                psImpl.setInt(3, user.domainId);\n                                psImpl.setString(4, rwep.password);\n                                psImpl.executeUpdate();\n                            }\n                        }\n                    }\n                }\n            });\n            connection.commit();\n            Iterator<String> iterator = userDirs.iterator();\n            while (iterator.hasNext()) {\n                cm.requestDirCreation(new File(cm.getUsersDirectory(), iterator.next()).getPath());\n            }\n            cm.createDirectories();\n        } catch (GeneralSecurityException e) {\n            log.error(e);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n            throw new RuntimeException(\"Error updating Realms. Unable to continue Operation.\");\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"insertUser": ["insertPassword", "InsertPassword", "createUsers", "createPerson", "insertPerson", " insertPassword", "insertUsers", "InsertUsers", " insertUsers", " insertPerson", "createUser", "InsertUser", "createPassword", "InsertPerson"], "newUsers": ["oldUser", "oldPeople", "NEWusers", "newUser", "path", "NewUser", "s", " newUser", "this", "New", "oldUsers", "NewPeople", "newusers", "oldusers", "Newusers", "NewMembers", "All", "newMembers", "NEWPeople", " newMembers", "Get", "_", " newusers", " newPeople", "NewUsers", "NEWMembers", "newPeople", "NEWUsers"], "pass": ["secret", "access", "sw", "ss", "port", "parse", "oss", "push", "session", "clean", "wd", "skip", "pos", "gram", "PASS", "act", "mess", "pa", "log", "col", "asses", "gen", "pool", "post", "cr", "conf", "sl", "Pass", "fr", "fail", "pas", "en", "ass", "def", "ress", "row", "pack", "pp", "mail"], "realmPass": ["almFail", "realfSecret", "realamPassword", "perMPass", "permLink", "realarmPASS", "perfPASS", "realnmAuth", "realarmAuth", "realmTrans", "realfPASS", "realmAuth", "realnmSecret", "almsFail", "realmPack", "realsmLink", "realmsFail", "realarmpass", "realamPass", "realmsPack", "palMPass", "palmpass", "realmeConf", "almsPass", "permAuth", "realnmPass", "realMpass", "realampass", "realmLink", "realfAuth", "almConf", "perfPass", "reallFail", "almPass", "realmConf", "realMPass", "permPack", "perMLink", "reallConf", "perMPassword", "realarmFail", "realmsConf", "perMPack", "realmsPassword", "realmFail", "realarmPass", "almsConf", "permPassword", "realsmPack", "permPASS", "realMFail", "perfAuth", "palMpass", "realarmSecret", "almsTrans", "perfSecret", "realmePass", "realMPack", "palmPassword", "reallTrans", "realMLink", "realmSecret", "almTrans", "realmsPass", "realmsTrans", "realmsLink", "palmPass", "realnmPASS", "permSecret", "realmeTrans", "palmFail", "realsmPass", "realmPassword", "realarmPassword", "realfPass", "realsmPassword", "palMPassword", "realMPassword", "realmeFail", "realmPASS", "reallPass", "permPass", "palMFail", "realamFail", "realmpass"], "userDirs": ["userDir", "UserIdir", "userDict", "UserDict", "userIdict", "userEdirs", "UserDir", "UserIdirection", "userDirirection", "userIdir", "userIdirs", "userDirection", "userIdirection", "UserDirs", "userDirirs", "userDirict", "UserDirection", "userEdirection", "UserIdirs", "UserIdict", "userEdict", "userDirir", "userEdir"], "iter": ["inse", "itter", "parse", "inner", "finder", "f", "ite", "ter", "its", "master", "cher", "driver", "ler", "ie", "i", "keep", "enter", "upper", "gener", "loader", "ner", "walker", "liter", "ir", "itor", "n", "Iterator", "iv", "it", "outer", "ipper", "izer", "Iter", "sel", "zip", "oper", "ator", "sl", "li", "vis", "imp", "former", "chain", "handler", "coll", "ul", "exit", "loop", "err", "er", "feed", "icer", "end", "reader", "inter", "keeper", "inc", "slice", "http"], "user": ["source", "message", "who", "current", "session", "to", "project", "image", "comment", "url", "name", "log", "u", "post", "rule", "profile", "replace", "creator", " result", "group", "result", "ver", "model", "use", "word", "usa", "or", "by", "data", "module", "object", "other", "force", "self", "up", "job", "using", "plugin", "used", "users", "site", "parent", "member", "order", "account", "me", "match", "update", "not", "e", "line", "USER", "resource", "from", "valid", "character", "theme", "string", "option", "fill", "User", "human", "author", "date", "page", "person", "per", "manager", "blog", "record", "service", "open", "ru", "server", "change", "lock", "usr", "full", "file", "request", "route", "row", "custom", "er"], "realm": ["realf", "palms", "realM", "palme", "palM", "realma", "alme", "Realms", " realf", " realp", "palp", "alm", " realma", "Realme", "alf", "elema", "Realm", "elef", "eleme", "RealM", " realM", "palm", "alma", "realme", "realp", "elem", "Realp", " realme"], "username": ["attr", "source", "su", "property", "ug", "current", "session", "config", "alias", "slave", "nick", "auth", "directory", "url", "name", "sword", "null", "picture", " nickname", "time", "direction", "true", "profile", "uu", "mobile", "token", "uri", "hello", "ame", "home", "component", "phrase", "ghost", "consumer", "email", "sudo", "gender", "password", "verb", "plugin", "nil", "account", "me", "method", "whatever", "role", "language", "ername", "purpose", "driver", "mother", "resource", "description", "character", "subject", " password", "string", "prefix", " slug", "attribute", "href", "login", "month", "uid", "human", "filename", "phone", "length", "title", "person", "family", "ident", "nom", "manager", " hashtag", "localhost", "duration", "database", "host", "address", "begin", "usr", "ruby", "Password", "route", "rights"], "ph": ["p", "ht", "th", "aph", "bh", " che", " guide", " exp", "phil", "mm", " p", "pl", "phrase", "per", " poly", "pal", "uth", "hw", "kh", " arch", "rah", " auth", "auth", "prof", "prot", "gh", "pa", "Ph", "fo", " sh", "iph", "pe", "password", "conf", "sl", "ch", "li", "wh", "h", "pha", "hi", "arch", "cl", "hp", "ap", "sh", "php", " mg", "PH", "eth", "oph", "eph", "her", "fam", "pkg", "rh", " ssh", "mph", "phi"], "realms": ["palns", "palms", " realmes", "Realfaces", "almes", "alns", "palfaces", "Realms", "alm", "Realmes", "realfaces", " realfaces", "Realm", "palm", "alms", "realmes", "realns", "Realns", "palmes"], "realmName": ["realmPart", "agmString", "realmPath", "agmPath", "realnString", "workmsN", "agmName", "workmsPart", "realcmName", "realmsCode", "realmeNames", "realmsNames", "workmN", "agmsName", "realnName", "realmeName", "workmsCode", "realmeString", "realrmN", "realcmCode", "realmsName", "realmN", "agmNames", "realmCode", "realnNames", "realrmName", "realmsN", "agmsString", "realmsPath", "workmCode", "realmsPart", "realmsString", "realmString", "realrmPart", "realmePath", "workmName", "realrmCode", "agmsPath", "realmNames", "realcmN", "realcmPart", "realnPath", "workmsName", "workmPart", "agmsNames"], "psImpl": ["psFactory", "ptyImpl", "sqlimpl", "ptyFactory", " connimpl", "psBuilder", "sqlBuilder", "sqlImpl", " connFactory", "ptyimpl", " connBuilder", "psimpl", " connImpl", "ptyBuilder", "sqlFactory"], "iterator": ["sequence", "forward", "inner", "instance", "ter", "enter", "gener", "loader", "walker", "Iterator", "choice", "it", "random", "outer", "ui", "ator", "append", "li", "size", "former", "stream", "creator", "collection", "entry", "inter", "adder"]}}
{"id1": "20886320", "id2": "14619453", "code1": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"search": ["replace", "filter", "report", "build", "scan", "form", "all", "result", "index", "run", "sort", "results", "create", "parse", "suggest", "send", "show", "submit", "start", "find", "list", "select", "Search", "get", "request"], "query": ["filter", "text", "description", "uri", "resource", "image", "general", "view", "term", "data", "depth", "Query", "sql", "range", "qu", "series", "result", "answer", "str", "quer", "password", "sort", "error", "timeout", "xml", "results", "comment", "source", "media", "expression", "qs", "command", "feature", "queue", "cache", "string", "question", "params", "name", "words", "json", "clean", "value", "q", "request", "database"], "order": ["asc", "ort", "page", "direction", "der", "e", "server", "ordering", "ard", "method", "random", "ORD", "part", "group", "result", "rule", "editor", "effect", "sort", "key", "type", "row", "class", "record", "dir", "orter", "hop", "er", "user", "r", "orders", "position", "address", "string", "desc", "err", "name", "by", "Order", "state", "request", "ordered"], "maxResults": ["Maxresults", "minPages", "MaxResult", "maxPages", " maxResult", "minresults", "maxresults", "MaxResults", "minResults", " maxresults", "minResult", "MaxPages", " maxPages", "maxResult"], "encodedQuery": ["encoredExp", "encodedRequest", "deccodedRequest", "incodedQuery", "Encryptedquery", "encoredRequest", "encodingQuery", "deccodedBody", "decodedBody", "EncodedQ", "encodedExp", "encachedExp", "incodedExp", "decodedQuery", "encoredUrl", "encryptedQuery", "encodingBody", "encodedQ", "incodedUrl", "EncryptedQuery", "encapedquery", "EncryptedPage", "encodingRequest", "enccodedQ", "encachedPage", "encryptedQ", "encapedQ", "encodingQ", "incoredUrl", "incoredExp", "encryptedBody", "encryptedRequest", "enccodedUrl", "encachedQ", "incodedRequest", "decodedRequest", "encachedRequest", "encryptedquery", "encoredQuery", "EncodedQuery", "enccodedQuery", "EncryptedQ", "encodedUrl", "EncodedPage", "encryptedPage", "encapedPage", "encodedquery", "incoredRequest", "encachedUrl", "encodedBody", "encachedQuery", "deccodedQ", "enccodedBody", "encachedquery", "decodedQ", "enccodedExp", "encapedQuery", "Encodedquery", "encodedPage", "enccodedRequest", "incoredQuery", "deccodedQuery"], "startAt": ["startAfter", "startOr", "endOr", "endAfter", " startNum", "StartNum", "Startat", "stopAt", " startAfter", "endFrom", "startFrom", "stopat", "endAt", "stopFrom", "StartFrom", "StartOr", "endNum", "startat", "StartAt", "StartAfter", "stopOr", " startFrom", "startNum", "endat"], "pageNr": [" pageNn", "pageNumrs", "pageSn", "pageSrc", "pageNumn", "pageLenr", " pageNrc", "pageNrc", "pageNnr", " pageNrs", "pageLenn", "pageNumnr", "pageLenrc", "pageNn", "pageSr", "pageNrs", "pageSrs", "pageNumr", " pageNnr", "pageLenrs"], "url": ["page", "uri", "ssl", "resource", "image", "server", "connection", "data", "version", "link", "channel", "output", "entry", "route", "str", "URL", "www", "href", "download", "xml", "source", "base", "r", "id", "address", "string", "name", "sl", "host", "path", "Url", " URL", "json", "format", "location", "q", "http", "feed", "request"], "httpparams": ["httmpareas", "httppparums", "httpparaums", "httpparsums", "httPPARms", "httPPARAMS", "httpparaases", "httmparas", "httpparamams", "httupparums", "httPParms", "httPPARas", "httupparAMS", "httppARays", "httpparsams", "httpparatams", "httppparays", "httpparatAMS", "httppareums", "httPParams", "httpparas", "httpparsases", "httppparams", "httupparams", "httppParparams", "httupparatAMS", "httppARAMS", "httpparsms", "httupparatays", "httmparams", "httpparamparams", "httpparparams", "httpparamam", "httpsarsparams", "httppARams", "httppParam", "httpsaram", "httppARums", "httmpareases", "httpsarparams", "httpparamms", "httpparaams", "httppareas", "httpparases", "httpsarsams", "httPPARams", "httmpareums", "httpparums", "httpparays", "httppParams", "httpparsam", "httpparaas", "httPParAMS", "httPParas", "httpsarases", "httpparam", "httpparamAMS", "httmparases", "httpparatums", "httppARms", "httupparays", "httupparatums", "httppareases", "httpsarams", "httpsarsam", "httpparamases", "httpparsas", "httpparms", "httpparsparams", "httppparAMS", "httpparatays", "httupparatams", "httppareams", "httpparAMS", "httpsarsases", "httppARas", "httmparums", "httpparsAMS", "httpparamas", "httmpareams", "httppParases"], "httpclient": ["httpsconn", "httpmethod", "webserver", "httpsclient", "htmlclient", " httpmethod", "webClient", "httpClient", " httprequest", "httpcall", "webclient", "httpconnection", "phprequest", "webconnection", "httpscall", "httprequest", " httpserver", " httpcall", "phpserver", "htmlserver", "httpsClient", "phpclient", "webconn", "htmlconn", "httpsserver", " httpClient", "phpcall", "phpconnection", "httpserver", "htmlClient", "webmethod", "httpconn", "phpClient", " httpconnection", "phpmethod", "httpsrequest"], "httpget": ["httpsput", " httpGet", "phpGet", "phpput", " httpsend", "persend", "httpGet", "httpsend", "phpget", "httpset", "Httpsend", "phppost", " httpset", "httpspost", "httpsget", "perget", "Httpget", "Httpset", "httppost", "httpput", "perset", " httppost", "httpsGet", " httpput"], "response": ["resp", "page", "res", "respond", "resource", "message", "server", "Response", "body", "connection", "method", "data", "successful", "version", "session", "output", "application", "status", "entry", "result", "document", "reply", "seeking", "api", "client", "stream", "user", "object", "success", "full", "get", "json", "collection", "http", "feed", "request", "onse", "received"], "instream": ["outchannel", "innerchannel", "inview", " inStream", "rinStream", "infile", " inchannel", "inStream", "innerfile", "inputview", "inchannel", "inputchannel", "rinchannel", "inputform", " inversion", "outview", "intfile", "rinview", "outStream", "inputStream", "inform", "outform", "inputresource", " inform", "intversion", "inresource", "outstream", "intchannel", "inversion", "rinstream", " inresource", "outresource", "innerstream", "inputstream", "intstream", "innerversion", " infile"], "html": ["css", "page", "text", "js", "message", "plain", "view", "body", "info", "data", "version", "raw", "title", "output", "result", "hash", "str", "template", "h", "live", "xml", "source", "article", "header", "web", "db", "base", "object", "HTML", "string", "hot", "ml", "tml", "json", "content", "format", "http", "doc", "img", "browser"]}}
{"id1": "14053882", "id2": "8917658", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static void copyAll(URL url, Writer out) {\n        Reader in = null;\n        try {\n            in = new InputStreamReader(new BufferedInputStream(url.openStream()));\n            copyAll(in, out);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            close(in);\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["enccode", " encryptcode", "decrypt", " encryptrypt", "decryption", " enipher", " encryptryption", "deccode", "decipher", "encipher", " enrypt", " enryption", "encryption", " encode", " encryptipher"], "plaintext": ["plainsource", " plaincontent", "encryptedstruct", "givenfont", " plainText", "protectedText", "plainstring", "batsource", "plainfont", "givenstring", "encryptedtext", " plainstring", "plainstruct", "batfont", "protectedstruct", "givensource", " plainfont", "protectedtext", "plaincontent", "plainText", " plainsource", "battext", "batstring", "encryptedText", "protectedcontent", "giventext", " plainstruct", "encryptedcontent"], "md": ["mand", "hm", "alg", "mm", "mp", "mod", "amd", "Cmd", "wd", "dig", "cmd", "dm", "po", "mb", "meta", "material", "mg", "data", "m", "ph", "da", "pg", "mage", "metadata", "ad", "mad", "mac", "nm", "sm", "ms", "code", "kg", "pd", "sha", "dr", " MD", "od", "dd", "cm", "mo", "mt", "hd", "cd", "am", "MD", "dh", "mc", "ma", "df", "mu", "pkg", "mag", "pm", "cb", "d", "bd", "dc"], "raw": ["text", "buffer", "json", "dec", "clean", "empty", "load", "instance", "rew", " RAW", "buf", "unsigned", "input", "image", "shared", "Raw", "data", "unknown", "auth", "binary", "original", "array", "null", "initial", "sha", "hex", "ack", "rc", "string", "stream", "enc", "wrapper", "full", "block", "serial", "pure", "row", "wave", "pack", "response", "feed", "partial", "RAW"], "hash": ["secret", "message", "buffer", "cache", "ashes", "length", "ash", "image", "kh", "data", "auth", "mac", "url", "base", "log", "array", "Hash", "password", "sha", "hex", "index", "h", "header", "sum", "sh", "block", "ha", "html", "version", "key", "response", "href", "her", "id", "rh"]}}
{"id1": "7396682", "id2": "8932510", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["link", "create", "change", "clone", "share", "download", "write", "paste", "cop", "load", "sync", "remote", "replace", "cat", "update", "url", "clip", "path", "drop", "split", "opy", "dump", "archive", "Copy", "file", "transfer", "rm", "move", "delete", "get", "cp", "source", " cp", "save"], "srcFS": ["sbFs", " srcTS", "rcfs", "srcfs", "srcFC", " srcfs", "srcFP", "rcFS", "rubyFS", " srcFC", "srcTS", "sourceFs", "srcFs", "sbFP", "rcTS", "rubyFs", " srcFP", "rubyfs", "sbfs", "rcFC", "sourceFC", " srcFs", " srcFB", "sourceFS", "rubyFB", "sbFS", "sourcefs", "rcFs", "srcFB", "sourceFB", "sourceTS", "rcFP"], "src": ["resource", "sub", "config", "view", "stream", "Source", "inf", "share", "RC", "target", "obj", "feat", "req", "sec", "http", "filename", "slice", "sync", "href", "cb", "sup", "url", "code", "gb", "dist", "spec", "rc", "core", "sn", "path", "st", "sc", "cmp", "ource", "upload", "uri", "sb", "sin", "dest", "SourceFile", "attr", "img", "rest", "fp", "sit", "secure", "name", "ssl", "sr", "sel", "sys", "host", "file", "inst", "username", "sth", "sl", "rb", "ctx", "bh", "loc", "source", "project", "rss", "supp"], "dst": [" drest", "lst", "drc", "pdrc", "pdsc", "Dst", "ddst", "dsts", "idrest", "ddest", "drest", "lsts", "lST", "pdst", "cdrc", "cdst", "Drc", "cddest", "Ddest", " dsts", "ldest", " drc", "dsc", "ddrc", "pdST", "idst", "cdST", "ddST", " dsc", "dST", " ddest", "Dsts", "Drest", "iddest", " dST", "ddsc", "DST", "idsts"], "deleteSource": ["deleteMode", " deleteTarget", " deleteOrigin", "delSources", "deleteOrigin", "delOrigin", "DeleteSources", "destroySource", "DeleteType", "copyMode", "DeleteOrigin", "delTarget", "copySource", "deleteTarget", "destroyOrigin", "delType", " deleteType", "deleteType", "deleteSources", " deleteMode", " deleteSources", "destroyTarget", "destroyMode", "delSource", "delMode", "DeleteTarget", "copyOrigin", "DeleteSource", "DeleteMode", "copyTarget"], "conf": ["lc", "conv", "Conf", "cli", "cl", "param", " Conf", "fi", "ref", "cache", "ca", "ch", "conn", "cb", "info", "raf", "cd", "cfg", "def", "cf", "c", "confirmed", "ci", "sc", "cmp", "cor", "cs", "prop", "client", "cc", "bug", "context", "cm", "con", "cn", "const", "comment", "ctx", "bc", "uc", "config", "cr", "f"], "contents": ["contentENTS", "stacts", "Content", "Contils", "Contains", "locents", "CONTains", "content", "contENTS", "CONTacts", "contils", "locContents", "locains", "contentients", "contains", "contentent", "contients", "CONTients", "contContents", "containers", "stences", "latacts", " content", "contentents", "contences", "Contents", "Contacts", "stENTS", "latent", "ContContents", "contacts", "latils", "CONTContents", "locainers", "CONTents", "Containers", "CONTainers", "latents", "stents", "ContENTS", "CONTences", " contients", "CONTent", "CONTils", " contENTS", "CONTENTS", "Contences"], "i": ["ini", "index", "j", "o", "oi", "hi", "inner", "phi", "ii", "fi", "ix", "count", "slice", "key", "mu", "b", "ui", "iv", "ri", "pi", "c", "gi", "abi", "d", "li", "k", "ci", "p", "ie", "type", "multi", "si", "io", "xi", "uri", "uni", "v", "x", "ai", "diff", "ji", "y", "ip", "start", "name", "init", "ori", "ti", "h", "id", "data", "qi", "e", "iu", "u", "f", "n", "di", "m", "I"], "in": ["ini", "kin", "login", "serv", "gin", "inn", "input", "din", "In", "l", "bin", "b", "conn", "c", "r", "IN", "pass", "doc", "source", "nin", "part", "min", "out", "ins", "is", "as", "inas", "a", "ac", "thin", "con", "data", "file", "rin", "ax", "id", "win", "connection", "sin", "f", "socket", "inc"]}}
{"id1": "10504714", "id2": "23152865", "code1": "    private MediaWikiResult getFromUri(String url) throws OntologyServiceException {\n        try {\n            logger.info(\"getting \" + url);\n            HttpURLConnection connection = (java.net.HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"OntoCat-\" + Math.random());\n            BufferedInputStream bin = new BufferedInputStream(connection.getInputStream());\n            JAXBContext jaxbContext = JAXBContext.newInstance(\"uk.ac.ebi.ontocat.mediawiki.jaxb\");\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            return (MediaWikiResult) unmarshaller.unmarshal(bin);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new OntologyServiceException(e);\n        }\n    }\n", "code2": "    protected JavaFileObject open(String className) throws IOException {\n        JavaFileObject fo = getClassFileObject(className);\n        if (fo != null) return fo;\n        String cn = className;\n        int lastDot;\n        while ((lastDot = cn.lastIndexOf(\".\")) != -1) {\n            cn = cn.substring(0, lastDot) + \"$\" + cn.substring(lastDot + 1);\n            fo = getClassFileObject(cn);\n            if (fo != null) return fo;\n        }\n        if (!className.endsWith(\".class\")) return null;\n        if (fileManager instanceof StandardJavaFileManager) {\n            StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;\n            fo = sfm.getJavaFileObjects(className).iterator().next();\n            if (fo != null && fo.getLastModified() != 0) {\n                return fo;\n            }\n        }\n        if (className.matches(\"^[A-Za-z]+:.*\")) {\n            try {\n                final URI uri = new URI(className);\n                final URL url = uri.toURL();\n                final URLConnection conn = url.openConnection();\n                return new JavaFileObject() {\n\n                    public Kind getKind() {\n                        return JavaFileObject.Kind.CLASS;\n                    }\n\n                    public boolean isNameCompatible(String simpleName, Kind kind) {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public NestingKind getNestingKind() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Modifier getAccessLevel() {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public URI toUri() {\n                        return uri;\n                    }\n\n                    public String getName() {\n                        return url.toString();\n                    }\n\n                    public InputStream openInputStream() throws IOException {\n                        return conn.getInputStream();\n                    }\n\n                    public OutputStream openOutputStream() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public Writer openWriter() throws IOException {\n                        throw new UnsupportedOperationException();\n                    }\n\n                    public long getLastModified() {\n                        return conn.getLastModified();\n                    }\n\n                    public boolean delete() {\n                        throw new UnsupportedOperationException();\n                    }\n                };\n            } catch (URISyntaxException ignore) {\n            } catch (IOException ignore) {\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getFromUri": ["getfromPUUrl", "getfromUri", "getFromURuri", "getFromRuri", "getfromUUrl", "getFromRuuri", "getFromURI", "getFromPUri", "getFromURri", "getFromPUUrl", "getfromUuri", "getfromPUuri", "getFromPURI", "getFromRuUrl", "getFromRuRI", "getFromURUrl", "getfromURI", "getFromUuri", "getFromUUrl", "getFromURRI", "getfromPURI", "getfromPUri", "getFromPUuri"], "url": ["full", "sl", "loc", "data", "name", "ri", "email", "type", "ur", "language", "layer", "info", "download", "str", "base", "ll", "rule", "ls", "ssl", "page", "href", "l", "address", "Url", "buffer", "URL", "i", "source", "image", "feed", "build", "proxy", "request", "path", "filename", "lr", "server", "uri", "route", "http", "file", "id", "src", "result", "resource", "www", "host", "location", "string", "username"], "connection": ["channel", "socket", "handler", "database", "j", "application", "position", "conn", "b", "part", "section", " Connection", "writer", "collection", "translation", "password", "client", "proxy", "service", "i", "connected", "image", "db", "connect", "condition", "which", "response", "object", "ion", "character", "context", "config", "number", "relation", "uri", "server", "io", "http", "c", "in", "function", "index", "con", "directory", "network", "Connection", "communication", "use", "bc"], "bin": ["border", "login", "sin", "data", "channel", "socket", "container", "database", "pin", "body", "brain", "bn", "bot", "binary", "base", "plugin", "bb", "bi", "conn", "b", "inner", "output", "win", "din", "ruby", "ran", "bean", "bc", "abi", "buffer", "lib", "spin", "bon", "ban", "bis", "inn", "in", "file", "src", "input", "bit"], "jaxbContext": ["jaxaContext", "japaText", "jjbContext", "japaSupport", "jjbChannel", "jaxfbContext", "jaxeSupport", "jaxfText", "japbSupport", "jaxfbcontext", "jjfcontext", "jjfText", "jaxbText", "jaxfbChannel", "jaxfContext", "jaxaSupport", "jjfChannel", "jaxpContext", "jaxfChannel", "jjbText", "jaxfbText", "jaxecontext", "jaxaText", "jaxbcontext", "japaContext", "japbText", "jaxeText", "japacontext", "japbcontext", "jjfContext", "japbContext", "jaxeContext", "jjbcontext", "jaxbChannel", "jaxpcontext", "jaxpText", "jaxpChannel", "jaxfSupport", "jaxbSupport", "jaxfcontext", "jaxacontext"], "unmarshaller": ["unmarshalers", "unmarshallingender", "unmarshallsers", "unmarshallsiner", "unmarshaler", "unmarshallER", "unmarshdaler", "unmarshulletter", "unmarshalliner", "unmarshdalender", "unmarshuller", "unmarshalleder", "unmarshALLers", "unmarshallers", "unmarshdaletter", "unmarshullender", "unmarshaliner", "unmarshALLER", "unmarshalletter", "unmarshulleder", "unmarshallingeder", "unmarshALLer", "unmarshalER", "unmarshallinger", "unmarshALLiner", "unmarshallingetter", "unmarshdaleder", "unmarshallser", "unmarshallsER", "unmarshallender"]}}
{"id1": "14783950", "id2": "5035872", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressUsingJar", "compressUsingZip", "compressInZip", "compresswithZip", "compresswithSax", "compressedWithJar", "compressInSax", "compressedWithZip", "compressWithJar", "compressUsingSax", "compresswithJar", "compressInJar", "compressedWithSax", "compressedUsingJar", "compressedUsingZip", "compressedUsingSax", "compressWithSax"], "fileList": [" fileChain", "wordString", "FileStream", "zipSet", "FileString", "fileStream", "modelCollection", "wordName", "inputEx", "modelEx", "fileCollection", "FileSet", "fileString", "modelList", "wordStream", "modelStream", "FileList", "inputCollection", "fileEx", "FileChain", "filelist", " fileSet", "zipList", "inputList", "inputStream", "wordList", "ziplist", "fileChain", "stringName", " fileEx", "stringlist", " fileStream", "Filelist", " fileCollection", " fileString", "FileName", "stringList", "stringChain", "zipName", "fileSet", " filelist"], "zipFileName": ["folderGlobalPath", "archiveDirDir", "zipFullname", "zipDirname", "zipFileDir", "archiveDirPath", "zipGlobalNames", "zipFullPath", "folderGlobalname", "zipFilename", "archiveFileName", "archiveFilePath", "zipDirDir", "zipPackagePath", "zipFullName", "zipFileNames", "archiveDirName", "folderFileNames", "zipGlobalPath", "folderFileName", "zipFullDir", "zipPackageName", "zipPackageDir", "folderGlobalName", "zipDirNames", "zipDirName", "archiveFileDir", "zipFullNames", "zipGlobalName", "zipDirPath", "zipFilePath", "folderFilename", "folderFilePath", "zipGlobalname", "folderGlobalNames"], "fos": ["Fosh", "infoS", "Fos", "flos", "faos", "infos", "fosh", "infaos", "afoS", "foS", "flis", "Faos", "FoS", " fosh", "afaos", "infis", "flosh", "afis", "afos", "Fis"], "zos": ["css", "zz", "ros", "dos", "closure", "z", "fits", "kos", "tz", "fi", "ZA", "os", "jas", "jobs", "ozo", "osi", "uz", "iframe", "nz", "cos", "loop", "zip", "es", "bis", "bos", "lins", "bag", "chini", "zes", "oses", "zzy", "seconds", "abi", "zik", "lol", "bes", "zar", "zag", "zo", "zers", "zen", "LOS", "outs", "zl", "rez", "ses", "onz", "zb", "ZI", "packs", "gz", "zx", "zer", "zy", "webkit", "obb", "zi", "phi", "zon", "zan", "spin", "budget", "inos"], "iter": ["enter", "inse", "fr", "e", "itter", "ser", "loc", "outer", "oper", "ner", "inc", "ie", "it", "f", "set", "index", "upper", "finder", "sort", "coll", "end", "test", "ener", "el", "gener", "i", "is", "parse", "keep", "ter", "er", "ip", "inner", "Iterator", "former", "walker", "slice", "ir", "file", "err", "fer", "list", "Iter", "inter", "ator", "izer", "next", "ite", "order", "cher", "liter", "iner", "chain", "iterator", "iz", "http"], "fileName": ["filenamename", "pageString", "FileString", " filePart", "FileUrl", "fName", "filePath", " filePath", "localname", "fileOpen", "filenameName", "currentname", "fileData", " fileLine", " fileType", " fileData", "FileFull", "fullOpen", "fileString", " fileFull", "fileType", "FilePart", "simplePath", "filenameInfo", "fileUrl", "currentData", "pageType", "currentName", " fileUrl", "FileLine", "pagename", "localPart", "fileInfo", "filename", "localName", "currentUrl", "simpleOpen", " fileInfo", "Filename", "FileInfo", "FilePath", " filename", "fPart", "fileFull", " fileString", "FileName", "fullPath", "localPath", "filePart", "FileData", "fullName", "fLine", "pageName", "FileType", " fileOpen", "fileLine", "simpleName", "filenameFull", "fname"], "ind": ["bind", "fr", "z", "vert", "nd", "j", "length", "count", "loc", "mid", "ded", "inc", "pos", "in", "cond", "pt", "index", "inn", "d", "ci", "val", "end", "eff", "i", "pull", "dir", "rib", "len", "ad", "id", "div", "ord", "IND", "start", "ld", "ix", "mind", "ii", "x", "Ind", "wind", "pend"], "shortName": ["Shortname", "ShortPath", " shortString", "longName", "smallname", "shortPart", "ShortString", "shortname", "ShortPart", "smallPart", "shortPath", "shortString", "ShortName", "longPart", "shortLine", "smallPath", "fullname", " shortPath", "longLine", "fullString", " shortname", "smallName", "longPath", "longname", "fullPath", "fullName", "fullLine", " shortLine"], "fis": [" fiss", "pisa", "fisa", "Fos", "fris", "cfis", "Fiss", "gisa", " fris", "cfs", " fisa", "gis", "fs", "pis", "fios", "Fs", "gios", "pris", "fiss", "pios", "cfiss", "gris", "afiss", "cfris", "cfos", " fs", "afris", "afis", " fios", "afos", "Fis"], "buf": ["fd", "cv", "uf", "bu", "uc", "b", "loc", "rc", "fb", "data", "bh", "bp", "lb", "feat", "bc", "pb", "bag", "rb", "batch", "done", "bytes", "cb", "Buff", "cur", "bf", "bd", "grab", "tmp", "buff", "ff", "queue", "ba", "br", "v", "lim", "bin", "la", "vec", "wb", "bl", "buffer", "seq", "box", "bb"], "bytesRead": [" bytesLength", "flowsWrite", "tesRead", "flowsRead", "bitsSkip", " bytesWrite", "bitsLength", "bitsRead", " bytesNeed", " bytesLoad", "bytesNeed", "bitsWrite", "tesWrite", "tesSkip", "bitsUse", "secondsRead", "wordsWrite", "bytesUse", "wordsUse", "bitsLoad", "secondsWrite", "bytesSkip", "tesLoad", "wordsRead", "bytesLoad", "bytesLength", "secondsLength", "bytesWrite", "flowsNeed", "secondsNeed", "flowsLength", " bytesUse", "wordsLength", " bytesSkip"]}}
{"id1": "10281203", "id2": "20685385", "code1": "    public void makeRead(String user, long databaseID, long time) throws SQLException {\n        String query = \"replace into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            int count = statement.executeUpdate();\n            if (0 == count) throw new SQLException(\"Nothing updated.\");\n            m_connection.commit();\n        } catch (SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    private Long getNextPkValueForEntityIncreaseBy(String entityName, int count, int increasePkBy) {\n        if (increasePkBy < 1) increasePkBy = 1;\n        String where = \"where eoentity_name = '\" + entityName + \"'\";\n        if (false) {\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.lock();\n            try {\n                EODatabaseContext dbc = ERXEOAccessUtilities.databaseContextForEntityNamed((EOObjectStoreCoordinator) ec.rootObjectStore(), entityName);\n                dbc.lock();\n                try {\n                    EOEntity entity = ERXEOAccessUtilities.entityNamed(ec, entityName);\n                    EOAdaptorChannel channel = (EOAdaptorChannel) dbc.adaptorContext().channels().lastObject();\n                    NSArray result = channel.primaryKeysForNewRowsWithEntity(increasePkBy, entity);\n                    return (Long) ((NSDictionary) result.lastObject()).allValues().lastObject();\n                } finally {\n                    dbc.unlock();\n                }\n            } finally {\n                ec.unlock();\n            }\n        } else {\n            ERXJDBCConnectionBroker broker = ERXJDBCConnectionBroker.connectionBrokerForEntityNamed(entityName);\n            Connection con = broker.getConnection();\n            try {\n                try {\n                    con.setAutoCommit(false);\n                    con.setReadOnly(false);\n                } catch (SQLException e) {\n                    log.error(e, e);\n                }\n                for (int tries = 0; tries < count; tries++) {\n                    try {\n                        ResultSet resultSet = con.createStatement().executeQuery(\"select pk_value from pk_table \" + where);\n                        con.commit();\n                        boolean hasNext = resultSet.next();\n                        long pk = 1;\n                        if (hasNext) {\n                            pk = resultSet.getLong(\"pk_value\");\n                            con.createStatement().executeUpdate(\"update pk_table set pk_value = \" + (pk + increasePkBy) + \" \" + where);\n                        } else {\n                            pk = maxIdFromTable(entityName);\n                            con.createStatement().executeUpdate(\"insert into pk_table (eoentity_name, pk_value) values ('\" + entityName + \"', \" + (pk + increasePkBy) + \")\");\n                        }\n                        con.commit();\n                        return new Long(pk);\n                    } catch (SQLException ex) {\n                        String s = ex.getMessage().toLowerCase();\n                        boolean creationError = (s.indexOf(\"error code 116\") != -1);\n                        creationError |= (s.indexOf(\"pk_table\") != -1 && s.indexOf(\"does not exist\") != -1);\n                        creationError |= s.indexOf(\"ora-00942\") != -1;\n                        if (creationError) {\n                            try {\n                                con.rollback();\n                                log.info(\"creating pk table\");\n                                con.createStatement().executeUpdate(\"create table pk_table (eoentity_name varchar(100) not null, pk_value integer)\");\n                                con.createStatement().executeUpdate(\"alter table pk_table add primary key (eoentity_name)\");\n                                con.commit();\n                            } catch (SQLException ee) {\n                                throw new NSForwardException(ee, \"could not create pk table\");\n                            }\n                        } else {\n                            throw new NSForwardException(ex, \"Error fetching PK\");\n                        }\n                    }\n                }\n            } finally {\n                broker.freeConnection(con);\n            }\n        }\n        throw new IllegalStateException(\"Couldn't get PK\");\n    }\n", "label": 1, "substitutes": {"makeRead": [" makeREAD", " executeWrite", "doREAD", "doRead", " makeWrite", " manageSet", " executeSet", "doWrite", " manageWrite", " executeREAD", " executeRead", "doSet", " makeSet", " manageRead", " manageREAD"], "user": ["row", "use", "username", "owner", "blog", "string", "host", "site", "word", "comment", "pid", "uid", "log", "post", "custom", "creator", "bug", "USER", "month", "install", "nick", "server", "url", "usr", "date", "field", "admin", "password", "User", "home", "record", "author", "write", "pod", "human", "job", "users", "alias", "name"], "databaseID": ["databaseIDS", "connectionIDs", " databaseName", "connectionName", "dbName", " databaseIDs", "collectionId", "DatabaseName", "collectionName", " databaseIDS", "collectionID", "connectionID", "DatabaseID", "databaseName", "collectionIDS", "DatabaseIDS", "dbIDs", "DatabaseId", " databaseId", "dbID", "databaseIDs", "databaseId"], "time": ["timeout", "etime", "ip", "times", "string", "host", "table", "comment", "money", "delay", "year", "key", "post", "length", "Time", "mode", "tz", "month", "rate", "port", "clock", "size", "read", "date", "TIME", "value", "set", "home", "start", "tim", "counter", "ime", "type", "duration", "id", "timer", "sleep", "name", "end"], "query": ["function", "scan", "string", "join", "execute", "request", "call", "Query", "select", "script", "comment", "condition", "report", "answer", "params", "search", "post", "database", "json", "sql", "conn", "command", "rule", "connection", "cmd", "work", "commit", "code", "q", "result", "error", "question", "ql", "eries", "message", "general", "update", "uri", "name", "sq"], "statement": ["slave", "status", "si", "media", "study", "section", "function", "use", "join", "note", "instance", "execute", "volume", "table", "expression", "str", "comment", "script", "language", "state", "condition", "response", "inst", "di", "jo", "database", "relation", "sql", "conn", "unit", "command", "rule", "connection", "document", "s", "part", "agent", "storage", "server", "commit", "ma", "session", "usage", "i", "password", "start", "stat", "result", "joined", "st", "Statement", "style", "parser", "message", "general", "mt", "alias", "db"], "count": ["c", "cache", "table", "depth", "limit", "total", "state", "sum", "Count", "key", "force", "number", "list", "process", "length", "child", "age", "err", "batch", "part", "base", "cond", "expected", "find", "get", "size", "index", "code", "i", "set", "by", "start", "handle", "diff", "error", "type", "found", "id", "inc", "offset"]}}
{"id1": "10759917", "id2": "17116123", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 1, "substitutes": {"delete": ["remove", "execute", "id", "drop", "register", " deleting", "destroy", "write", "save", "database", "post", "sync", "load", "connection", "de", "Delete", "get", "exec", " deletion", "del", "dump", "link", "flush", "update", "create", " Delete", " destroy"], "name": ["NAME", "string", "path", "info", "class", "address", "space", "id", "n", "resource", "base", "on", "now", "filename", "version", "table", "ame", "pass", "time", "database", "active", "key", "client", "part", "like", "type", "no", "true", "one", "value", "old", "model", "default", "alias", "parent", "names", "data", "none", "object", "size", "null", "style", "Name", "e", "action", "label", "word", "link", "prefix", "false", "url", "comment", "create", "missing", "named", "definition", "code"], "CannotDeleteSystemLinkException": ["CannotDeleteSystemLinksException", "CannotDeleteSystemReferenceError", "CannotDeleteSystemLinkEx", "CannotDeleteClassLinkException", "CannotDeleteSystemLinkError", "CannotDeleteClassLinkApplication", "CannotDeleteSystemRelException", "CannotDeleteSystemReferenceEx", "CannotDeleteSysLinkException", "CannotDeleteSystemReferenceception", "CannotDeleteSystemlinkException", "CannotDeleteSystemLinksInformation", "CannotDeleteSystemLinksception", "CannotDeleteSystemRelception", "CannotDeleteSystemReferenceException", "CannotDeleteSystemLinkApplication", "CannotDeleteClassLinkception", "CannotDeleteSysLinkError", "CannotDeleteSystemRelError", "CannotDeleteSystemLinkInformation", "CannotDeleteSystemRelEx", "CannotDeleteSysLinkception", "CannotDeleteClassLinkInformation", "CannotDeleteSysLinkEx", "CannotDeleteSystemLinksApplication", "CannotDeleteSystemlinkception", "CannotDeleteSystemlinkInformation", "CannotDeleteSystemlinkApplication", "CannotDeleteSystemLinkception"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotfoundError", "ClassLinkTypeNotSourceError", "ClassLinkTypeNotfoundRequest", "ClassLinkTypeNotfoundException", "ClassLinkTypeNotFoundRequest", "ClassLinkTypeNotFoundError", "ClassLinkTypeNotSourceRequest", "ClassLinkTypeNotSourceException"], "conn": ["Connection", "close", "ssl", "ou", "core", "Conn", "cc", "server", "n", "serv", "enc", "lock", "ns", "con", "c", "act", "pub", "cb", "co", "rt", "query", "dc", "util", "nc", "ec", "client", "sync", "nt", "cm", "session", "cp", "cache", "pr", "cond", "uc", "ct", "connection", "lc", "ch", "cat", "ob", "config", "open", "ca", "h", "bb", "p", "po", "coll", "ci", "exec", "oss", "dn", "ann", "oci", "db", "pc", "mc", "ctx", "ver", "orp", "conf", "connect", "cn", "ac", "cli", "error", "cur", "pg", "org", "loc"], "stmt": ["ctm", "strlt", "istnt", "strm", "Stmn", "strmp", " stnt", "Stmm", " stmb", "STsql", "Stob", "strnt", "sthdb", " stm", "Stdb", "stdd", "estdd", " stmp", "istmt", " stdd", " stsql", "stlt", " stmm", "strmt", "stsql", "strob", "strdd", " stob", "rdsql", " stmd", "stmp", "STdd", "rdmd", "istmd", "stm", "istdt", "strmd", "stob", "Stdt", "STmt", "strsql", "Stmp", "ctmd", "estsql", "estmt", "playdt", "rddd", "Stnt", "ctmb", "estlt", "Stmd", "ctmt", "sthmn", "STlt", "playmd", " stdb", "strmb", "Stm", "Stmb", "stmm", "strmm", "rdmt", "playmt", " stmn", "stmb", "sthmt", "stmn", "sthmd", "stdb", "Stmt", "stdt", "playnt", "stmd", "stnt"], "prepTable": ["PrepTable", "inittable", " prepCol", "initCol", "supType", "prepCol", "Preptable", "prepable", "parTable", " preptable", "supTable", "PrepType", "initTable", " prepType", "Prepable", "preptable", "supable", "initType", "parCol", "prepType", "partable", "parType", " prepable", "suptable"], "objectLinkTable": ["objectTypeTab", "objectLinkSource", "ObjectLinkSource", "objectLinkType", "objectSyncChain", "objectTypeSource", "objectRelChain", "objectlinkChain", "objectSyncStore", "ObjectLinkTable", "objectSyncType", "objectLinkStore", "objectRelTable", "objectLineTab", "ObjectLineSource", "objLinkTable", "objLinkChain", "objectLinkFile", "objLinkStore", "ObjectLineFile", "objectlinkTable", "objectlinkType", "objLinkType", "objectSyncTable", "objectRelType", "ObjectLinkTab", "ObjectLineTab", "objectlinkFile", "objectLineSource", "objectRelStore", "ObjectLineTable", "objlinkTable", "objectLineFile", "objectlinkStore", "objlinkStore", "objectLinkChain", "objlinkType", "objectTypeFile", "ObjectLinkFile", "objectlinkTab", "objlinkChain", "objectTypeTable", "objectlinkSource", "objectLineTable", "objectLinkTab"], "sql": ["zip", "string", "ssl", "sf", "id", "spec", "sg", "description", "result", "join", " SQL", "s", "shell", "query", "su", "csv", "dl", "params", "select", "expression", "pr", "sb", "str", "sv", "ql", "log", "sq", "insert", "ls", "function", "db", "sl", "url", "update", "comment", "SQL", "summary", "general", "statement", "cmd", "term"]}}
{"id1": "8430178", "id2": "14502142", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyPath", " copyfile", "CopyFile", "copyfile", "transferfile", "transferFiles", "transferPath", " copyFiles", "CopyPath", "Copyfile", "copyPath", "CopyFiles", "copyFiles", "transferFile"], "source_name": ["src_file", "source_type", "Source_file", "sourceNalias", "src_type", "sourceCname", "src_size", "source_data", "source_uri", " source_path", "sourceNtype", "sourceCalias", "source_size", " source_Name", "source_Name", "source_key", " source_key", "src_uri", " source_names", "source_names", "sourceCtype", "sourceCfile", "source_alias", "source_path", "sourceNfile", "src_name", "sourceNname", "Source_data", "src_alias", "Source_name"], "dest_name": ["destFpath", "destappnames", "destFilefile", " destination_name", "destPmodel", "Dest_name", " destinationFpath", "dest_model", "destappmodel", "destPName", " destinationFname", "target_type", "destFname", "destPpath", "Dest_id", "destRname", "dest_path", "dest_named", "dest_none", " dest_none", "destapptype", "dest_id", " destination_path", "dest_resource", "destPtype", " dest_names", "destJName", "dest_info", "destappname", "destFilelabel", " dest_Name", " dest_type", "dest_Name", "destFresource", "Dest_path", "dest_names", "destRName", "destRpath", "source_Name", "target_names", "dest_word", "destRdefinition", "destFilenamed", " destination_info", "destPnames", "dest_type", "destJword", "source_names", "source_path", " dest_word", "destffile", " destinationFresource", "destfname", " dest_definition", " dest_path", "destFilename", "destFinfo", "destPname", " destination_resource", "destfnamed", "target_name", "dest_file", "destPword", " dest_label", "destJnames", "dest_definition", "Dest_Name", "target_model", " destinationFinfo", "destJname", " dest_named", "dest_label", "destflabel", " dest_file"], "source_file": ["src_file", "source_File", " source_class", "src_stream", "source__file", "ource_file", " source_base", "ource_line", "ource_files", " source_url", "source_base", "sourceffile", "ource_name", "sourcefname", "source__class", "source_cache", " source_cache", " source_File", "source__name", "source_class", "src_files", " source_files", "source_files", "sourcefFile", "sourcefurl", "src_name", "source__base", "source_url", "source_line", "source_stream"], "destination_file": ["destation_folder", "destination4path", "destination_base", "destinationablefiles", "destinate_page", "destination2path", "destination_path", "destination_function", "destination2file", "destination2source", "destention4name", "destation_file", "destention_name", "destination_folder", "destinationablepage", "destention_path", "destention4path", "destation_name", "destination2name", "destination4name", "destination4file", "destination_files", "destinate_file", "destention4file", "destention_source", "destention_file", "destation_files", "destinationablebase", "destination_source", "destinationablefile", "destention4source", "destinate_base", "destination4source", "destation_function", "destination_name", "destination_page", "destinate_files"], "source": ["ite", "index", "remote", "class", "core", "input", "server", "resource", "uri", "copy", "output", "Source", "spec", "master", "resources", "site", "slave", "current", "inner", "result", "dest", "slice", "ources", "via", "SOURCE", "client", "reader", "cache", "load", "proxy", "connection", "target", "diff", "scope", "open", "parent", "config", "file", "src", "local", "object", "get", "search", "view", "name", "start", "image", "secure", "stream", "unit", "ize", "reference", "ource", "service", "from", "single", "storage"], "destination": ["Destina", "testribution", "dependination", "coordension", "coordination", "descinated", "targetinator", "identribution", " destribution", "descination", " destining", "testination", "testinated", "dependinator", "constination", "Destension", "destining", "destension", "coordinated", "variinated", "constribution", "validinated", "identination", "targetinated", " destinated", "constinator", "destinated", "variinate", " destinator", "Destribution", "Destination", "Destinated", " destina", "foreigninator", "testinator", "descinator", "Destinator", "destina", "identina", "variinator", "validination", "dependinated", "validinate", "destinate", "destinator", "foreigninate", "destribution", "Destining", "descension", "targetination", "foreigninated", "coordinator", "identinated", "constining", "foreignination", "variination", "targetinate", "validinator", "dependinate"], "buffer": ["temp", "Buffer", "input", "uffer", "timeout", "sequence", "limit", "window", "pool", "memory", "bin", "queue", "iter", "reader", "cache", "binary", "buff", "buf", "channel", "text", "header", "image", "writer", "flush", "padding", "block", "transfer", "batch"], "bytes_read": ["bytesUnRead", "bytes_Read", "bytesUnset", "Bytes_read", "bytesUnfound", "Bytes_set", "bytesUnread", "Bytes_found", "bytes_set", "Bytes_Read", "bytes_found"], "in": ["IN", "val", "path", "ssl", "input", "fe", "n", "serv", "temp", "resource", "id", "ini", "lock", "token", "con", "inner", "as", "current", "l", "s", "ins", "line", "bin", "is", "read", "session", "reader", "doc", "connection", "login", "min", "r", "inc", "data", "file", "out", "h", "request", "p", "log", "get", "rec", "or", "again", "image", "re", "In", "nin", "a", "url", "stream", "b", "container", "inn", "f", "din"], "response": ["reason", "string", "respons", "server", "output", "uri", "resource", "feed", "reset", "res", "report", "message", "description", "json", "sequence", "onse", "version", "result", "answer", "location", "line", "su", "next", "true", "resp", "value", "model", "r", "application", "data", "text", "body", "object", "request", "offer", "reply", "example", "header", "dict", "status", "image", "success", "received", "update", "Response", "respond", "question", "error", "re", "api", "view"], "parentdir": ["parentdirectory", "parentdiff", "rootlib", "Parentdirectory", "hostdir", "parentlib", "homediff", "hostdirectory", "homefile", "homedir", "parentsfile", " parentDir", "parentsDir", "rootdir", " parentlib", " parentdict", "rootdirectory", "Parentdict", "hostdict", " parentdiff", "Parentdir", "rootfile", "parentfile", "parentDir", "parentsdiff", "homeDir", "partdirectory", "partlib", "parentdict", "parentsdir", "partdir", " parentfile", " parentdirectory", "partfile"]}}
{"id1": "4686922", "id2": "822452", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourcesAsfile", "extractResourceToFiles", "extractResourceInResource", "extractResourcesToFile", "extractResourcesAsFile", "extractResourceAsFile", "extractResourcesToFiles", "extractResourcesTofile", "extractResourceAndfile", "extractResourceInFiles", "extractResourceAndResource", "extractResourceToResource", "extractResourceAsfile", "extractResourceAndFile", "extractResourceTofile", "extractResourceAndFiles", "extractResourceAsFiles", "extractResourceInfile", "extractResourceInFile", "extractResourcesAsResource", "extractResourcesAsFiles", "extractResourceAsResource", "extractResourcesToResource"], "resourcePath": ["sourcepath", " resourceId", "Resourcepath", " resourceFolder", " resourcepath", "stringFolder", "stringpath", "resourceId", "resourcepath", " resourceUrl", "ResourcePath", "ResourceUrl", "stringPath", "resourceFolder", "servicepath", "servicePath", "resourceUrl", "sourceUrl", "sourceId", "sourcePath", "ResourceId", "serviceFolder"], "dest": ["prop", " Dest", "txt", "default", "resource", "const", "Dest", "destroy", "flat", "die", "data", "store", "project", "later", "output", "folder", "result", "route", "comb", "done", " destination", "home", "temp", "source", "class", "src", "config", "tmp", "filename", "target", "resources", "de", "trans", "desc", "file", "dist", "sup", "sac", "wb", "path", "transfer", "content", "contract", "img"], "in": ["rec", "ins", "url", "resource", "image", "In", "b", "n", "connection", "init", "thin", "like", "this", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "lin", "conn", "pass", "cin", "i", "is", "win", "source", "reader", "rin", "kin", "inside", "nin", "sin", "login", "inner", "r", "id", "bin", "c", "con", "file", "re", "up", "ini", "as", "plus", "arin", "again", "isin"], "out": ["at", "norm", "ex", "writer", "ins", "one", "image", "server", "copy", "null", "b", "n", "In", "ax", "parent", "io", "outer", "off", "this", "sync", "outside", "inc", "socket", "cos", "output", "cookie", "f", "all", "o", "Out", "s", "conn", "temp", "i", "source", "client", "a", "co", "outs", "user", "cache", "exec", "bin", "file", "err", "obj", "app", "up", "w", "net", "OUT", "lib", "auto", "again", "boot", "ext"]}}
{"id1": "7044153", "id2": "19006212", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendExceptionAsHost", "sendExceptionWithService", "sendExceptiontoserver", "sendExceptiontoService", "sendExceptionWithServer", "sendErrortoHost", "sendExceptionAsServer", "sendErrorToserver", "sendExceptionWithHost", "sendExceptionToserver", "sendErrortoServer", "sendExceptionToHost", "sendExceptiontoServer", "sendErrorToServer", "sendErrortoserver", "sendErrorToService", "sendErrortoService", "sendExceptionAsserver", "sendExceptiontoHost", "sendExceptionWithserver", "sendExceptionToService", "sendErrorToHost", "sendExceptionAsService"], "server": ["ser", "test", "address", "base", "ip", "header", "client", "port", "proxy", "Server", "db", " host", "host", "domain", "prefix", "ssl", "root", "null", "service", "erver", "http", "addr", "email", "json", "serv", "conf"], "ex": ["exec", "su", "rex", "cl", "base", "error", "exc", "pex", "status", "re", "str", "lex", "aux", "throw", "e", "exp", "ace", "none", "Exception", "EX", "tx", "x", "log", "nex", "export", "res", "Ex", "ext", "obj", "Exc", "err", "hex", "ax", "event", "def", "class", "ception", "example", "except", "acer", " exc", "sex", "fail", "con", "full", "rupt", "exit", "temp"], "config": ["address", "base", "client", "console", "app", "Configuration", "proc", "log", "Config", "ext", "cmd", "bug", "cfg", "connection", "options", "text", "Conf", "etc", "service", "rc", "file", "json", "conf", "cb", "settings"], "prob": ["proj", "probs", " probs", "peb", "Proj", "Probs", "Prob", "Probe", " proj", "pebe", "probe", " probe", "pebs", "pej"], "dataSB": ["codeRB", "codeEB", "workPB", "errorSB", "eventSB", "DataHL", "controlSB", "DataLB", "workBB", "uiEl", " dataEl", "execLB", "fileLB", "cacheBL", "eventLB", "fileSB", "loadSB", " dataHL", "pBs", "dataSL", "codeLB", "fullLB", "offSB", " dataMB", "errorPB", "cacheSB", "ifSL", "execBL", "defaultLB", "pSB", " dataRB", "cachesb", "strSB", "postLB", "postSB", " dataBB", "dataHL", "defaultBB", "fullBB", "offSL", "contentOB", "nosb", "datasb", "errorOB", "cacheLB", "codeMB", "codeFB", "controlBL", "ifsb", "innersb", " dataLB", "ifLB", "fullBL", "responseBB", "codeHL", "errorEB", "defaultSB", "responseSB", "datLB", "offBB", "execsb", "dataMB", "psb", "postSL", "DataSB", "dataBL", "Datasb", "datOB", "dataEB", " dataBL", " dataSL", "DataBL", "ifSB", "offsb", " dataFB", "dataRB", "defaultsb", "DataMB", "contentLB", " datasb", "innerSL", "execBB", "dataLB", "filesb", "contentsb", "noLB", "errorBB", "uiSB", "innerSB", "fullSB", "dataPB", "strSL", "workSB", "noSB", "responseLB", "innerLB", " dataEB", "codeBs", "workSL", "dataFB", "fileSL", "dataOB", "DataRB", "loadLB", "strsb", "codeBB", "errorSL", "loadsb", "dataEl", "errorsb", "postsb", "uiLB", "offLB", "dataBB", " dataOB", "eventSL", " dataPB", "controlsb", "DataOB", "datSB", "codesb", "controlBB", "datBB", "contentSB", "noSL", "DataSL", "DataBB", "dataBs", "execSB", "loadBB", "pLB", "codeEl", "controlLB", "errorLB", " dataBs", "codeSB", "DataFB", "strLB", "eventBB", "responseBL"], "trace": ["race", "shadow", " debug", "test", "atter", "result", "flow", "address", "error", " traced", "cache", "bean", "e", " traces", "ace", "cover", "xml", "log", "tx", "string", "out", "profile", "bug", "err", "ray", "t", "ptr", "type", "info", "report", "r", "ctr", "span", " tracing", "tr", "strip", "message", "debug", "buffer", "array", "scale", "track", "stack", "data", "tri", "trip", "details", "runner", "trans", "fake", "temp"]}}
{"id1": "21531069", "id2": "10158738", "code1": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 1, "substitutes": {"updateuser": [" updateusers", "updateusers", "editUser", "UPDATEuser", " updateperson", "updateUser", "UPDATEperson", " updateUser", "editperson", "updateperson", "editusers", "edituser", "UPDATEusers", "UPDATEUser"], "u": ["eu", "iu", "us", "uu", "username", "n", "c", "m", "ru", "o", "uid", "U", "ur", "ue", "util", "ui", "cu", "user", " su", "p", "gu", "up", "l", "w", "du", "ut", "f", "cli", "fu", "e", "su", "ul", "h", "hu", "v", "ou", "tu", "b", "t", "users", "nu", "uri", "client", "mu", "lu", "un"], "i": ["iu", "hi", "si", "qi", "ip", "n", "ii", "c", "m", "pi", "ini", "o", "limit", "d", "ci", "di", "api", "ui", "ri", "bi", "count", "p", "it", "l", "phi", "j", "I", "fi", "f", "cli", "e", "oi", "li", "ori", "ni", "gi", "ti", "mi", "ai", "b", "xi", "t", "id", "info"], "conn": ["dc", "ch", "pc", "pn", "cat", "serv", "cm", "n", "c", "Connection", "pr", "pg", "ca", "act", "col", "Conn", "ann", "ci", "ctx", "con", "api", "pt", "co", "rt", "sync", "Connect", "ct", "oci", "ht", "client", "sql", "loc", "p", "cc", "cl", "connection", "mc", "cn", "rc", "cp", "Exec", "exec", "coll", "server", "cmd", "config", "Sync", "pool", "enc", "cli", "session", "Pool", "Con", "h", "close", "fp", "nt", "jp", "po", "mm", "nc", "lock", "connect", "db", "core", "lc", "MC"], "pm": ["mp", "pc", "LM", "ml", "pd", "vim", "cm", "rm", "m", "em", "pi", "PM", "pb", "pr", "py", "pg", "gp", " PM", "prem", "pl", "hm", "con", "mor", "pt", "px", "param", "pp", "mr", "om", "p", "vm", "wp", "mc", "cn", "pa", "mn", "pool", "cli", "lp", "fm", "am", "sem", "arm", "gm", "dm", "fp", "nm", "mi", "rpm", "mon", "jp", "prom", "module", "mm", "po", "wm", "bm", "db", "lc"]}}
{"id1": "19113613", "id2": "12306305", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["create", "change", "clone", "share", "download", "write", "paste", "zip", "cop", "load", "process", "sync", "replace", "Cop", "cat", "update", "clip", "split", "p", "type", "upload", "ssh", "opy", "archive", "Copy", "transfer", "rm", "put", "move", "delete", "get", "cp", " cp", "save"], "in": ["ini", "image", "kin", "plugin", "base", "login", "index", "this", "inner", "inn", "input", "din", "In", "bin", "update", "c", "pin", "IN", "again", "token", "ic", "work", "part", "cin", "sin", "min", "diff", "client", "ins", "lin", "as", "name", "init", "inside", "a", "thin", "id", "data", "on", "i", "reader", "old", "n", "win", "get", "connection", "config", "project", "f", "url", "inc"], "out": ["err", "image", "base", "o", "outer", "other", "resource", "point", "self", "root", "this", "outside", "project", "input", "with", "net", "at", "version", "up", "group", "cache", "output", "OUT", "remote", "bin", "conn", "b", "object", "page", "null", "option", "c", "external", "again", "outs", "path", "work", "goal", "p", "part", "line", "io", "v", "x", "Out", "client", "block", "off", "app", "init", "name", "ext", "user", "vert", "parent", "call", "ex", "no", "dot", "n", "one", "connection", "inc", "exec", "obj"], "source": ["origin", "force", "unit", "base", "service", "resource", "SOURCE", "site", "prefix", "view", "Source", "direction", "format", "src", "use", "scope", "status", "class", "pe", "from", "position", "subject", "route", "family", "type", "ource", "attribute", "uri", "sin", "dest", "ce", "secret", "secure", "size", "missing", "name", "internal", "proxy", "component", "id", "reference", "alt", "parent", "username", "feature", "iter", "project", "url"], "target": ["origin", "force", "base", "service", "resource", "site", "detail", "config", "prefix", "root", "current", "point", "alias", "direction", "format", "wrong", "pattern", "Target", "top", "master", "src", "output", "cat", "home", "null", "about", "tail", "route", "token", "path", "next", "goal", "dest", "name", "host", "component", "reference", "alt", "parent", "value", "arget", "template", "project", "url", "address"], "files": ["resources", "ports", "objects", "keys", "flows", "lines", "ls", "plugins", "links", "children", "sections", "filename", "blocks", "tools", "iles", "apps", "groups", "obs", "images", "Files", "ions", "cells", "jobs", "items", "fs", "ins", "users", "models", "features", "docs", "pages", "data", "classes", "names", "assets", "results", "f", "s"], "file": ["File", "folder", "letter", "unit", "base", "resource", "child", "feed", "current", "function", "ile", "entry", "fe", "load", "local", "filename", "l", "b", "object", "page", "url", "string", "future", "item", "path", "single", "line", "part", "uri", " File", "it", "entity", "fp", "layer", "dir", "FILE", "le", "name", "live", "data", "id", "binary", "e", "el", "per", "lib", "parent", "f", "directory"], "inCh": ["InCh", "inch", "inChan", "InChan", " inChannel", " inch", "outCH", " inChan", "INCh", "outChan", "outChannel", " inCH", "INChan", "inChannel", "Inch", "INCH", "InChannel", "INChannel", "InCH", "inCH", "outch"], "outCh": ["inch", "inChan", " outChannel", "OutCH", "outputChan", "outCH", " outch", "outChan", "outputch", "Outch", "outChannel", "OutChannel", " outCH", "inChannel", "OutCh", "outputCH", "inCH", "OutChan", "outputCh", "outch"]}}
{"id1": "16673769", "id2": "2398448", "code1": "    @Override\n    public void Start() {\n        try {\n            Enumeration<URL> resources = Configurator.class.getClassLoader().getResources(IOCContainer.GetApplicationName() + \".config\");\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                if (Logger.logger.isDebugEnabled()) {\n                    Logger.logger.debug(\"Loading '\" + url + \"'\");\n                }\n                JSONValue configFileContents = JSONValue.Decode(url.openStream(), url.toString());\n                if (configFileContents instanceof JSONObjectValue) {\n                    for (Configurable configurable : IOCContainer.LookupAll(Configurable.class)) {\n                        JSONValue jsonData = ((JSONObjectValue) configFileContents).GetProperty(configurable.GetConfigSectionName());\n                        if (jsonData != null) {\n                            if (Logger.logger.isDebugEnabled()) {\n                                Logger.logger.debug(\"Configurging \" + configurable.getClass() + \" with '\" + jsonData.Encode());\n                            }\n                            try {\n                                configurable.Configure(jsonData);\n                            } catch (Throwable th1) {\n                                Logger.logger.error(\"Caught throwable while configuring \" + configurable.getClass() + \":\" + th1.getMessage() + \". IGNORED.\", th1);\n                                Logger.logger.error(\"[Continued]. Config Data was:\" + jsonData.Encode());\n                            }\n                        }\n                    }\n                } else {\n                    Logger.logger.error(\"'\" + url + \"' does not contain a json object. Skipping and looking for other applciation.config files in classpath ...\");\n                }\n            }\n        } catch (Throwable th) {\n            throw new RuntimeException(\"Exception while attempting to load application.config:'\" + th.getMessage() + \"'\", th);\n        }\n    }\n", "code2": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "label": 0, "substitutes": {"Start": ["Stop", "create", "init", "Test", " stop", "Run", " Startup", "process", "Begin", "Do", "Load", "End", "Boot", " Run", "stop", "Init", "ize", "Process", "Main", "Service", "register", "end", "Exception", "Starting", "get", "start", " start", "run"], "resources": ["relations", "types", "rules", "lines", "styles", "bytes", "groups", "ids", "ources", "services", "issues", "projects", "errors", "parents", "resource", "opens", "archives", "works", "objects", "thumbnails", "files", "features", "reports", "stores", "states", "models", "rows", "pages", "uploads", "fires", "vers", "settings", "plugins", "users", "includes", "results", "Resources", "maps", "classes", "ions", "events", "packages", "stars", "roots", "http"], "url": ["ls", "source", "text", "filename", "buffer", "gl", "uri", "json", "str", " URL", "path", "Url", "download", "config", "f", "page", "l", "socket", "image", "loc", "data", "service", "resource", "location", "email", "io", "base", "name", "server", "host", "URL", "rl", "sl", "api", "address", "string", "connection", "channel", "stream", "element", "layer", "lr", "ll", "coll", "ul", "html", "file", "mount", "route", "r", "href", "ssl", "feed", "response", "key", "xml", "http"], "configFileContents": ["configContentContents", "configFileIncludes", "jsonFileContent", "configContentIncludes", "jsonFileValues", "configfileLocation", "jsonfileContents", "configFileParameters", "logFileLocation", "configfileIncludes", "configResourceIncludes", "configContentParameters", "jsonFileTextures", "configContentContent", "jsonfileStream", "configFileContent", "configfileStream", "configFILEContent", "configDirectoryTextures", "configUrlParameters", "jsonfileContent", "configFileValues", "configfileTextures", "configDirectoryContent", "jsonFileStream", "logfileParameters", "logfileContent", "configFileLocation", "configFileTextures", "configUrlContents", "configfileContents", "logFileContent", "logfileContents", "jsonfileIncludes", "logfileLocation", "logFileParameters", "configFILEContents", "configUrlContent", "jsonfileValues", "configDirectoryContents", "configResourceContents", "logFileContents", "configfileValues", "configfileContent", "jsonfileTextures", "configContentLocation", "configResourceContent", "configDirectoryStream", "jsonFileContents", "configFileStream", "configContentValues", "configfileParameters", "configUrlLocation", "configResourceValues", "configFILEStream", "configFILETextures", "jsonFileIncludes"], "configurable": ["configure", "Configure", "structuration", "Configuration", "structural", "configuring", " configure", "confuring", "Configurer", "Configur", "structur", "figur", "structurable", "figurable", "configur", "confural", "confur", "configuration", "confuration", " configurer", "configural", "configurer", "Configuring", "confurer", "figural", "confure", "structure", "structuring", "Configurable", "Configural", "confurable", " configur", "structurer", " configuration", "figurer", " configural"], "jsonData": ["ajInfo", "JSONArray", " jsonParser", "xmlDATA", "jsArray", " jsonReader", "JSONData", "JSONDATA", "jsonVar", "sonDiv", "jsonParser", " jsonVar", "sslValue", "xmlCode", " jsonDiv", " jsonCode", "sonData", "JSONValue", "journalDiv", "sonDATA", "jsonDiv", "jsonDATA", "jsString", "JSONInfo", "sonParser", "jsonValue", "jsonArray", " jsonDATA", "ajDat", "JSONDat", "rssData", "sslInfo", "xmlData", "jsonCode", "journalData", "xmlReader", "xmlInfo", "xmlString", "sslData", "sonCode", "jsDATA", "rssDATA", "sslDat", "jsonDat", "jsonString", "JSONReader", "jsonReader", "JSONCode", "jsonInfo", "rssParser", "rssVar", "ajValue", "JSONString", " jsonInfo", "xmlArray", "sonVar", "ajData", "journalCode", "jsData"]}}
{"id1": "14688886", "id2": "20073619", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "label": 1, "substitutes": {"populateResources": ["populateResource", "poputeResources", "populateRelations", "popureFiles", "compureResources", "poputeRelations", "compulateRelations", "compureResource", "popractResources", "compureFiles", "popureResources", "popractFiles", "poputeFiles", "compulateResource", "compulateFiles", "popractResource", "compulateResources", "compureRelations", "popureResource", "poputeResource", "popractRelations", "populateFiles", "popureRelations"], "templates": ["temps", "prometers", "tempplate", "templateples", "tomplate", "templatepl", "temures", "templateps", "filens", "filpl", " temens", "Temens", " temures", " templ", "Temeters", "prompl", "typlate", "Template", "temeters", "filures", "Temps", "typl", "stemples", "promplate", "temens", "tomplates", "Templ", "Temples", "Templates", "templateplates", "tempps", "promplates", "temppl", "typlates", "stempl", "templ", "tometers", "tompl", "stemps", "Temures", "tempplates", "filplates", "temples", "stemplates", "template", "typs"], "url": ["image", "link", "html", "URL", "base", "resource", "service", "email", "feed", "config", "download", "Url", "pattern", "entry", "channel", "http", "filename", "l", "href", "object", "page", "string", " URL", "r", "route", "buffer", "path", "pl", "job", "fl", "uri", "il", "xml", "name", "ssl", "location", "server", "data", "file", "ob", "host", "e", "sl", "el", "connection", "template", "source", "f", "address"], "fileName": ["fileSync", "FileString", "fDir", "fileType", "filePath", "foldername", "filename", " filePart", "objectName", "stringDirectory", "FileDir", "fKey", "Filename", " filename", "FILESystem", "fileString", "resourceName", "FileFull", "FileKey", "filenameString", "fileKey", "folderPath", "FileDirectory", "fileTime", "folderName", " fileDirectory", "modelname", "modelName", "sourceInfo", "FileName", " fileType", " fileLocation", "FILEname", " fileKey", " fileInfo", "objectSync", "fileInfo", "stringName", "objectTime", "resourcename", "FILELocation", "fName", "stringType", " filePath", "fileSystem", " fileTime", "FILETime", "FileInfo", "filePart", "FILESync", "sourceName", "filenameFull", "fileLength", " fileSystem", "folderPart", "fileDir", " fileString", "filenameLength", "filenameName", "fname", "sourceString", "FILEName", "filenameType", "resourcePath", " fileSync", "resourcePart", " fileLength", "fileLocation", "sourceLength", "fileDirectory", "filenamename", "objectname", "FileType", " fileFull", "sourcename", "modelLocation", "modelSystem", "fileFull", " fileDir"], "templateResource": ["tempFile", "templateresource", "copyUrl", "tempResource", "layoutContent", "plateContainer", "templateReader", " templateType", "eventResource", "layoutContainer", "privateUrl", "layoutResource", " templateRole", "eventUrl", "eventresource", "translationContainer", " templateFile", "tempRole", "plateRing", "copyresource", "privateReader", "translationRing", "translationContent", "privateresource", "privateResource", "xmlFile", "xmlResource", "eventReader", "templateContainer", "xmlType", "templateRing", "templateContent", "copyResource", "plateContent", "templateRole", "layoutRing", "templateFile", "translationResource", "copyReader", "xmlRole", "templateUrl", "tempType", "plateResource", "templateType"], "is": ["ib", "its", "in", "serv", "isi", "abs", "src", "nis", "ir", "lis", "cms", "has", "api", "IS", "ri", "r", "irc", "was", "ris", "io", "os", "uri", "isl", "it", "isa", "out", "ip", "iss", "as", "iso", "app", "bis", "ori", "isc", "ios", "Is", "im", "ais", "rss", "ar", "iris", "s"], "strBuff": ["strBuffer", "brFlow", " strGrab", "StrBuffer", " strText", "stringBuffer", "brBuffer", "arrTab", "arrBuffer", "StrTab", "stringGrab", "StrBuff", "strGrab", "StrText", "Strbuff", "StrPref", "strFlow", "brGrab", "rBuff", "strText", "strbuff", "stringFlow", " strbuff", "rText", "brBuff", "strPref", "strTab", " strBuffer", "stringBuff", " strTab", "arrBuff", "rBuffer", "arrPref", " strPref", "rbuff", " strFlow"], "br": ["err", "dr", "fr", " reader", "stream", "bl", "arr", "text", "yr", "b", "ctr", "cb", "buf", "sp", "r", "ber", "gr", "tr", "bro", "er", "div", "io", "result", "Br", "BR", "nr", "mr", "orb", "hr", "bar", "ori", "sr", "data", "brush", "browser", "Reader", "reader", "rb", "res", "bc", "cr"], "str": ["enc", "err", "lc", "dr", "fr", "strike", "kr", "coll", "arr", "cl", "cur", "oct", "text", "sec", "key", "STR", "pr", "style", "string", "sp", "r", "spec", "t", "tr", "wr", "st", "er", "stri", "p", "line", "type", "div", "sc", "name", "hr", "sr", "data", "star", "char", "Str", "sl", "iter", "or", "cr", "f"], "images": ["image", "resources", "boxes", "versions", "objects", "types", "holes", "shows", "flows", "dates", "plugins", "picture", "services", "thumbnails", "frames", "rooms", "media", "events", "styles", "views", "files", "tests", "apps", "xs", "groups", "games", "videos", "quarters", "bands", "photos", "ions", "icons", "jobs", "gif", "tags", "people", "opens", "ins", "users", "models", "ups", "agents", "Images", "features", "gallery", "lights", "letters", "pages", "ips", "stars", "sites", "png", "classes", "assets", "inches", "ages", "words", "ims", "scripts", "pieces"], "i": ["z", "format", "fi", "ui", "ci", "p", "multi", "it", "v", "ji", "xml", "u", "f", "s", "lc", "j", "html", "in", "this", "cli", "add", "slice", "mu", "b", "info", "pi", "gi", "d", "uni", "ni", "io", "ip", "app", "ti", "id", "iu", "ini", "_", "mi", "yi", "hi", "phi", "ii", "ind", "ie", "si", "xi", "eni", "diff", "x", "gu", "ij", "di", "image", "index", "chi", "Url", "http", "key", "li", "bi", "uri", "ai", "y", "qi", "e", "n", "config", "I"], "img": ["image", "config", "fig", "bl", "input", "arr", "ff", "jpg", "aff", "exp", "src", "fw", "ch", "info", "cb", "att", "tif", "norm", "fb", "li", "ie", "p", "ani", "v", "aut", "gif", "small", "gd", "icon", "tmp", "app", "hr", "map", "ext", "gallery", "iframe", "data", "file", "inst", "sl", "png", "ng", "im", "bg", "lib", "abc", "m", "imp", "f"], "imgProperty": ["bgImage", "cacheProp", "imgImage", "bgProp", " imgPro", "cacheProperty", " imgProp", "bgProperty", "imgPro", "imgProp", "bgPro", "cacheImage", "cachePro", " imgImage"]}}
{"id1": "21182766", "id2": "3801655", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 0, "substitutes": {"load": ["resources", "setup", "resource", "create", "check", "write", "download", "find", "parse", "add", "process", "use", "info", "update", "read", "set", "loaded", "class", "LOAD", "store", "path", "loading", "proc", "build", "start", "loader", "init", "pack", "construct", "dump", "include", "call", "Load", "loads", "get", "delete", "config", "install", "copy", "save"], "propsName": ["comppsPath", "proPSNames", "comppertiesname", "propertiesPath", "propertiesName", "proPSPath", "comppertiesName", "comppertiesPath", "proPSName", "profsname", "pepertiesPath", "pepsname", "profsPath", "comppsDesc", "propsDesc", "comppsName", "pepsNames", "pepertiesNames", "propertiesDesc", "pepsPath", "proPSDesc", "profsName", "pepsName", "propertiesname", "profsDesc", "propsname", "profsNames", "pepertiesName", "propertiesNames", "comppsname", "pepertiesname", "proPSname", "propsPath", "propsNames", "comppertiesDesc"], "props": ["crops", "croperties", "propos", "compbs", "prps", "perpos", "perbs", "prots", "prids", "prpps", "pecs", "prips", "perps", "cropps", "Procs", "properties", "comppos", "procs", "compps", "Props", "pebs", "prperties", "prpr", "Prots", "pribs", "prebs", "propps", "prets", "protps", "cropr", "probs", "protpps", "propr", "protperties", "Probs", "protpr", "pripos", "peps", "prods", "compds", "preps", "precs", "pets", "perds"], "url": ["URL", "base", "resource", "service", "feed", "config", "stream", "event", "cl", "Url", "channel", "ref", "src", "http", "l", "b", "api", "page", "r", "bel", "buffer", "path", "not", "fl", "uri", "xml", "loader", "name", "location", "ssl", "server", "data", "file", "user", "gl", "e", "id", "ob", "browser", "sl", "i", "jar", "source", "f"]}}
{"id1": "807346", "id2": "20851065", "code1": "    String runScript(String scriptName) {\n        String data = \"\";\n        try {\n            URL url = new URL(getCodeBase().toString() + scriptName);\n            InputStream in = url.openStream();\n            BufferedInputStream buffIn = new BufferedInputStream(in);\n            do {\n                int temp = buffIn.read();\n                if (temp == -1) break;\n                data = data + (char) temp;\n            } while (true);\n        } catch (Exception e) {\n            data = \"error!\";\n        }\n        return data;\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"runScript": ["execCode", "RunCode", " runscript", "execscript", "runscript", "RunScript", "execJS", "execScript", " runJS", "RunJS", "runJS", "runCode", " runCode", "Runscript"], "scriptName": ["scriptNames", " scriptFile", "fileUrl", " scriptPath", "codename", "Scriptname", "scriptUrl", "scriptPath", "filePath", "codePath", "fileName", " scriptNames", "scriptname", " scriptUrl", "codeName", "ScriptName", " scriptname", "ScriptPath", "ScriptFile", "codeNames", "ScriptNames", "ScriptUrl", "scriptFile", "fileFile"], "data": ["index", "string", "info", "base", "buffer", "input", "i", "output", "response", "feed", "results", "message", "json", "result", "number", "html", "api", "write", "layout", "key", "alpha", "content", "split", "raw", "next", "part", "type", "source", "no", "one", "value", "media", "str", "DATA", "div", "batch", "text", "body", "out", "empty", "append", "complete", "format", "start", "name", "template", "action", "ata", "function", "a", "partial", "missing", "script", "dat", "error", "this", "code", "valid"], "url": ["impl", "zip", "path", "base", "buffer", "ssl", "i", "server", "uri", "resource", "id", "feed", "user", "http", "l", "host", "URL", "source", "up", "browser", "connection", "open", "file", "web", "page", "bb", "ll", "log", "bel", "ls", "ball", "image", "sl", "rl", "Url", "www", "stream", "b", "f", "service"], "in": ["IN", "ssl", "buffer", "i", "input", "id", "resource", "serv", "ini", "gin", "socket", "as", "inner", "ins", "s", "bin", "pass", "is", "client", "cms", "reader", "source", "login", "r", "inc", "file", "out", "conn", "In", "fd", "a", "stream", "b", "err", "ac", "with", "inn", "f", "win", "din"], "buffIn": ["BuffIn", "buffIns", "bufIn", "buffOut", "buffedIn", "bufin", "bufIns", "bbIns", "ufIn", "bufferin", "BuffedIn", "bbIn", "bufferIn", "bufOut", "bufferIns", "ufIns", "bbOut", "bufferedIn", "ufin", "BuffIns", "bbin", "BuffOut", "Buffin", "ufedIn", "buffin"], "temp": ["index", "zip", "total", "base", "buffer", "tc", "input", "num", "i", "output", "enc", "c", "current", "tem", "number", "dest", "length", "Temp", "flow", "read", "extra", "char", "iter", "offset", "content", "raw", "type", "source", "cut", "len", " Temp", "div", "tmp", "fake", "empty", "size", "ptr", "test", "cel", "start", "stable", "pointer", "unit", "partial", "wait", "count", "f", "pt", "emp"]}}
{"id1": "15445861", "id2": "23467091", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public void listen() {\n        String url = \"http://\" + host + \":\" + LISTEN_PORT;\n        HttpURLConnection conn = null;\n        while (true) {\n            try {\n                conn = (HttpURLConnection) (new URL(url).openConnection());\n            } catch (Exception e) {\n                error(\"Could not connect to \" + url + \".\", e);\n                return;\n            }\n            BufferedInputStream in = null;\n            try {\n                conn.connect();\n                in = new BufferedInputStream(conn.getInputStream(), LISTEN_BUFFER);\n                event(\"Connected to stream at \" + url + \".\");\n            } catch (Exception e) {\n                error(\"Could not get stream from \" + url + \".\", e);\n                return;\n            }\n            try {\n                byte[] data = new byte[LISTEN_BUFFER];\n                for (int i = 0; i < delay; i++) {\n                    in.read(data);\n                }\n            } catch (Exception e) {\n                error(\"Stream unexpectedly quit from \" + url + \".\", e);\n                return;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", " copyDirectory", "transferFile", "transferDirectory", "CopyFile", " copyfile", "Copyfile", "copyfile", "CopyDirectory", "copyFiles", "copyDirectory", "CopyFiles"], "srcFile": ["sourceDirectory", " srcPath", "srcDir", "rcFiles", "rcFile", "sourceDir", "destTime", "srcFiles", "srcDirectory", "srcStream", "rcTime", "rcPath", "ourceTime", "destDirectory", "sourcePath", "destDir", " srcFiles", "rcDir", "supfile", " srcDir", " srcStream", "sourceFile", " srcfile", "srcPath", "sourcefile", "srcTime", "rcDirectory", " srcDirectory", "srcPlace", "supStream", "supFile", "srcfile", "ourcePlace", "rcPlace", "rcfile", " srcTime", "ourcePath", "rcStream", "supPath", "sourceFiles", " srcPlace", "ourceFile"], "destFile": ["sourceDirectory", " destTime", "tempFile", "DestFile", "vertFile", "targetPath", "tempfile", "endTime", "vertPath", "destFilename", "destTime", "targetFilename", "stdTime", "vertFiles", "stdFile", "endFile", "DestPath", "destDirectory", "destfile", " destFilename", " destFiles", "inationFiles", " destfile", "inationPath", "stdDirectory", "DestFiles", " destPath", "tempFiles", "sourceFile", "sourcefile", "targetFile", "targetTime", "tempPath", "destFiles", "endFilename", "inationFile", "vertFilename", "destPath", " destDirectory", "sourceTime", "inationFilename", "Destfile", "endPath", "DestFilename", "stdfile"], "in": ["ini", "image", "kin", "base", "login", "serv", "inner", "inn", "gin", "input", "In", "up", "bin", "b", "url", "read", "pin", "r", "IN", "again", "source", "nin", "io", "cin", "min", "pull", "ins", "is", "as", "init", "a", "inside", "ac", "h", "con", "id", "isin", "rin", "ex", "i", "win", "reader", "get", "or", "m", "din", "f", "socket", "inc"], "out": ["err", "base", "o", "other", "inner", "gin", "to", "w", "net", "obj", "up", "exp", "cache", "sync", "output", "OUT", "writer", "conn", "bin", "again", "pass", "outs", "work", "line", "io", "by", "Out", "client", "off", "ext", "user", "file", "parent", "ex", "one", "n", "inc", "exec", "socket"], "buffer": ["base", "wave", "feed", "offset", "flush", "input", "channel", "slice", "queue", "b", "bytes", "read", "null", "buf", "position", "buff", "border", "padding", "uffer", "phrase", "result", "layer", "block", "length", "size", "memory", "pause", "server", "data", "variable", "binary", "document", "transfer", "limit", "reference", "reader", "iter", "batch", "source", "Buffer", "url", "header", "address"], "no": ["num", "index", "o", "nor", "nt", "to", "po", " mo", " number", "none", "which", "nothing", "mo", " lo", "info", "auto", "pos", "so", "from", "wa", "was", "maybe", "type", " NO", "io", "nos", "os", "No", "x", "number", "nr", "yes", "na", "off", "only", "size", "ino", "ko", "co", "data", "id", "lo", "error", "zero", "i", "go", "eno", "NO", " none"]}}
{"id1": "20275821", "id2": "8452134", "code1": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "label": 0, "substitutes": {"getAttribute": ["createattribute", "setAtt", "GetFeature", "setAttributes", "createFile", " getAttributes", "createAtt", " getAtt", " getFile", "GetAttribute", "Getattribute", "getattribute", " getFeature", "getAtt", "getFeature", "createFeature", "setattribute", "getFile", "createAttribute", "setAttribute", "GetFile", "getAttributes", " getattribute", "createAttributes"], "url": ["request", "image", "client", "email", "sl", "rl", "host", "class", "socket", "object", "el", "proxy", "context", "user", "bug", "version", "il", "route", "page", "lc", "server", "cache", "address", "conn", "loc", "connection", "http", "path", "resource", "URL", "ssl", "file", "link", "f", "Url", "api", "base", "log", "name", "l", "string", "ur", "uri", "source", "config", "c"], "con": ["plain", "db", "client", "ca", "connect", "fa", "rc", "cn", "cc", "socket", "fl", "user", "version", "ln", "cons", "cr", "on", "CON", "lc", "cf", "com", "ex", "cache", "coll", "run", "per", "conn", "open", "ran", "ver", "connection", "http", "bc", "cur", "ob", "cm", "ssl", "conf", "fc", "uc", "fn", "Con", "fun", "cover", "ctrl", "en", "file", "close", "rev", "f", "exec", "ch", "conv", "login", "can", "log", "cl", "pc", "co", "un", "ocon", "non", "re", "sub", "func", "c", "ec"], "response": ["request", "next", "image", "error", "success", "size", "received", "output", "reply", "respons", "version", "route", "server", "json", "answer", "result", "connection", "code", "http", "resource", "index", "reason", "successful", "message", "Response", "value", "function", "resp", "ception", "onse", "xx", "status", "number", "site", "body", "respond", "uri", "length"], "redirect": ["reriff", "undred", "rediff", "radirection", "undirection", "Redirection", "redocol", "redred", "Redication", "undiff", "redirection", "Redocol", " redirection", "undirect", "Redirect", " redred", "radirect", "rdirection", "radocol", "rerirection", "rdirect", "rdication", "redication", "rerirect", " rediff", "radication", "rdocol", "rerred"], "location": ["position", "error", "localhost", "object", "layout", "reference", "route", "directory", "address", "origin", "loc", "connection", "format", "region", "resource", "path", "content", "message", "direction", "description", "file", "link", "Location", "area", "feature", "null", "data", "type", "LOC", "local", "collection", "language", "document", "remote", "href", "string", "uri", "layer", "filename", "length"]}}
{"id1": "293167", "id2": "14038176", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"doVersionCheck": [" doVersioncheck", "doVersionScan", "doFeatureScan", " doVersionScan", "doVersionUpdate", "doFeaturecheck", "doFeatureCheck", "doVersioncheck", "doChangeCheck", "doFeatureUpdate", "doversioncheck", " doversionCheck", " doversioncheck", "doversionScan", " doversionUpdate", "doChangeUpdate", " doVersionUpdate", "doChangecheck", "doversionCheck", "doChangeScan", " doversionScan", "doversionUpdate"], "view": ["video", "cache", "out", "session", "config", "head", "event", "vol", "image", "comment", "base", "display", "pool", "see", "div", "views", "fail", "can", "http", "group", "form", "im", "client", "check", "ve", "this", "model", "use", "show", "by", "object", "self", "up", "ou", "user", "edit", "style", "update", "View", "link", "e", "input", "screen", "box", "VIEW", "sel", "container", "gu", "block", "html", "value", "widget", "port", "cell", "page", "manager", "review", "window", "server", "change", "ui", "query", "body", "index", "vis", "list", "lock", "el", "full", "row", "layout", "v"], "url": ["ls", "source", "gl", "buffer", "uri", "browser", "length", "path", "Url", "download", "f", "bb", "link", "l", "socket", "image", "blog", "loader", "loc", "web", "resource", "open", "hub", "builder", "location", "email", "www", "base", "log", "name", "b", "null", "server", "host", "URL", "zip", "sl", "address", "string", "fr", "stream", "ul", "ll", "impl", "file", "bug", "ssl", "ob", "id", "rel", "http"], "in": ["source", "as", "init", "buffer", "inn", "out", "pin", "inner", "ac", "s", "input", "socket", "sin", "IN", "data", "m", "ini", "win", "con", "resource", "binary", "isin", "b", "is", "nin", "ins", "cin", "stream", "lin", "In", "inc", "again", "rin", "file", "err", "login", "reader", "bis", "din", "doc"], "bin": ["init", "buffer", "gin", "inn", "out", "browser", "pin", "inner", "bb", "input", "socket", "border", "sin", "ban", "IN", "abi", "loader", "ini", "win", "record", "con", "binary", "bot", "bi", "arin", "b", "vin", "bn", "fin", "nb", "is", "body", "lock", "cin", "lin", "spin", "ruby", "file", "lib", "oin", "login", "reader", "din", "run"], "line": ["text", "lf", "look", "Line", "lines", "str", "out", "parse", "pin", "cell", "page", "link", "e", "one", "word", "l", "val", "inline", "data", "definition", "nl", "object", "comment", "ip", "up", "base", "name", "log", "b", "lc", "job", "pe", "code", "ge", "zip", "letter", "sl", "string", "LINE", "el", "lin", "range", "cl", "ine", "block", "write", "file", "part", "row", "key", "entry", "end", "le", "unit", "type", "id", "user", "jo"], "version": ["secret", "python", "video", "position", "license", "cover", "feature", "update", "download", "date", "ver", "author", "model", "versions", "VERSION", "driver", "project", "image", "install", "release", "format", "latest", "vert", "name", "device", "null", "server", "host", "code", "beta", "string", "Version", "patch", "dev", "option", "plugin", "value", "bug", "pull", "support", "id", "unit", "type", "v", "section", "vision", "user"], "build": ["work", "make", "style", "clean", "load", "update", "home", "ver", "built", "info", "use", "lease", "link", "show", "how", "image", "install", "follow", "release", "Build", "builder", "help", "print", "valid", "job", "log", "add", "building", "uild", "hold", "post", "tag", "patch", "lock", "block", "mount", "bug", "pull", "row", "feed", "boot", "unit", "get", "run", "rel", "http"]}}
{"id1": "21125261", "id2": "8667872", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"test": [" tests", "run", " example", "execute", " evaluate", " solve", " sample", "Train", " verify", " testing", " run", " eval", "tests", "Main", " validate", " train", "evaluate", " analyse", "Test", "train", " simulate", " deploy", " process", " check"], "is": ["ics", "si", "isa", "ses", "ios", "serv", "ir", "opens", "iris", "has", "as", "gets", "ais", "os", "IS", "in", "ins", "does", "fs", "s", "Is", "out", "ls", "iss", "iso", "its", "ws", "isi", "i", "res", "mis", "bis", "lis", "ai", "ps", "ists", "es", "info", "id", "stream", "src", "ris"], "byteArrayOutputStream": ["byteStringOutputContext", "byteArrayFileSteam", "byteArrayInputPath", "byteArrayOutputString", "byteArrayInputFile", "byteArrayFileFile", "byteArrayoutputSteam", "byteStringInputStream", "byteStringInputFile", "byteArrayInputString", "byteStringOutputSteam", "byteArrayIOStream", "byteArrayInputStream", "byteArrayByteString", "byteArrayFileStream", "byteArrayIOFile", "byteArrayOutputSteam", "byteStringOutputFile", "byteArrayByteSteam", "byteArrayIOSteam", "byteArrayIOString", "byteArrayoutputStream", "byteArrayByteFile", "byteArrayByteStream", "byteArrayInputSteam", "byteStringInputSteam", "byteArrayoutputPath", "byteStringOutputStream", "byteStringInputString", "byteStringOutputString", "byteStringInputContext", "byteArrayFileString", "byteArrayOutputPath", "byteArrayInputContext", "byteStringInputPath", "byteStringOutputPath", "byteArrayFileContext", "byteArrayoutputContext", "byteArrayOutputContext", "byteArrayOutputFile", "byteArrayFilePath"], "def": ["df", "entry", "class", "DE", "defined", "spec", "d", "dist", "da", "report", "di", "pro", "desc", "this", "dev", "dir", "frame", "default", "init", "base", "DEF", "Def", "decl", "define", "definition", "config", "f", "e", "des", "der", "data", "dem", "obj", "md", "parse", "de", "bus", "conf", "id", "info", "re", "file", "ref"], "se": ["fe", "entry", "si", "ane", "sh", "ses", "so", "zip", "est", "ase", "see", "te", "ine", "pse", "service", "le", "ge", "be", "sle", "lex", "ve", "sc", "ke", "ce", "ste", "ie", "spe", "inse", "s", "pe", "ade", "sea", "sp", "sec", "sl", "per", "e", "su", "sem", "sche", "cle", "ze", "sed", "ne", "ser", "parse", "sk", "de", "es", "sel", "me", "site", "ss", "SE"], "linkId": ["linkLength", "Linkid", " linkInfo", "lineById", "feedInfo", "lockInfo", "LinkId", "LinkLength", " linkid", " linkById", "feedId", "lineId", "linkById", "linkid", "lockId", "feedid", " linkLength", "LinkInfo", "linkInfo", "feedLength", "lockById", "lineInfo"], "segmentId": ["sementID", " segmentType", "sementNumber", "sementInfo", "selementID", "negementCount", "selementId", "segementCount", " segmentsType", "segmentsType", "segmentID", " segmentID", "negmentNumber", " segmentCount", "segmentNumber", "negementInfo", "sementCount", "selementType", "segmentInfo", "negmentInfo", "segmentsID", " segmentsID", "negmentCount", "negmentId", "sementId", "segmentsNumber", "segmentsInfo", "selementCount", "segmentType", "segmentsId", "segmentsCount", "segmentCount", "segementInfo", " segmentsCount", "segementNumber", "negementNumber", "negementId", "sementType", " segmentsId", "segementId"], "linkSegments": ["linkEnggments", "linkConnectgments", "lineFragines", "linkEngments", "lineFraggments", " linkEngments", "linkFragures", "lineFragment", "linkFragments", "linkIncrements", "linkSegment", "linkIncreles", "linkIncreines", "lineSegments", "linkSegures", "linkFragles", " linkSegment", " linkEngures", "linkConnectures", "linkIncregments", " linkSegures", "lineSegment", "linkConnectments", "linkFraggments", "lineFragles", "linkSeggments", "linkSegines", "linkConnectment", " linkSeggments", "linkEngment", "lineSegines", "lineSegles", "lineFragments", "linkFragines", "linkIncrement", "lineSeggments", "linkEngures", "linkEngles", " linkEnggments", "linkFragment", "linkSegles", " linkEngment", "linkEngines"], "segments": ["segements", "segs", "sements", "gegs", "begment", "pegments", "schegments", "Seggements", "begments", "Seggments", "pegment", "segment", "pegements", "gements", "scheplings", "Seggment", "bements", "Segments", "geplings", "peplings", "gegments", "pements", "pegs", "schements", "begs", "seplings", "schegment", "gegment", "gegements"], "frameProperties": [" frameproeters", "frameproblems", " frameProproperties", " frameproproperties", "framePromperties", "frameProblems", "framePropps", " frameproblems", "frameProps", " frameprops", "frameproproperties", "framePropproperties", "frameproperties", "frameprops", " frameProeters", "framePropeters", "framePrometers", "framePromps", "framePropblems", "frameProproperties", "frameProeters", " frameProps", "framePromproperties", " frameProblems", " frameproperties", "frameproeters", "framePropperties"], "time": ["timeout", "vel", "live", "etime", "speed", "times", "c", "step", "depth", "money", "delay", "activity", "cost", "length", "count", "age", "weight", "play", "video", "rate", "event", "port", "work", "x", "clock", "size", "name", "now", "f", "date", "TIME", "e", "value", "image", "start", "h", "tim", "v", "change", "ice", "ime", "data", "type", "t", "id", "timer", "duration", "end", "loop", "sleep", "Time", "file", "once"], "vehicle": [" vehology", " vehicles", "driocity", "vehicles", "driical", "verticles", " vehline", "Vehline", "Vehicle", "driicle", "venometry", "bridocity", " mobicle", "vehology", "Vehicular", "vehometry", "venocity", "vertology", "bridometry", " mobicles", "bridicle", "bridical", " vehicular", "Vehicles", "verticular", "driometry", "Vehish", "Vehology", "venicle", " vehish", "venical", "vehline", "vehical", " mobish", "vehicular", " mobline", "vehish", "vehocity", "verticle"]}}
{"id1": "804637", "id2": "9846843", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRebwrite", "readAndRebrap", "readAndRewwrite", "readAndSwrap", "readAndrewwrite", "readAndRebrite", "readandRewrap", "readandRewrites", "readAndSwwrite", "readandrewrap", "readAndRewrap", "readAndSwrite", "readandrewrites", "readandrewwrite", "readAndRebrites", "readAndRewrites", "readAndrewrite", "readAndSwrites", "readandrewrite", "readAndrewrites", "readAndrewrap", "readandRewwrite", "readandRewrite"], "inFile": [" inSourceFile", "InSourceFile", "oldfile", "outSourceFile", "inputfile", "outfile", " inFiles", "inputFilename", "InFiles", " infile", "infile", "inputFile", "outFiles", "oldFile", "loginFile", " inFilename", "Infile", "inFiles", "inputFiles", "oldFiles", "loginFilename", "loginfile", "loginFiles", "InFile", "oldFilename", "outFilename", "inFilename", "inSourceFile"], "outFile": ["newfile", "outDir", "OutStream", "processFile", "outputFilename", "exFilename", "outputfile", " outfile", "outPlace", "outFILE", "outputFILE", "outfile", "processFilename", "offFILE", "outputPlace", "thisFilename", "outStream", "thisFile", "processPlace", "exfile", "thisFILE", "newDir", "exFILE", "OutDir", "exFile", "processFILE", "newStream", "offPlace", "OutFile", " outStream", "outFilename", "offFilename", "Outfile", " outDir", "outputFile", "newFile", "thisfile", "offFile"], "iis": ["iIS", "Iais", "iIs", "iiris", "iniIs", "iiiss", "iais", "Iis", "ciis", "iiis", " iIs", " iIS", " iais", "ciiss", "Iiss", "ciais", " iiss", "iiss", "iiIS", "iniiss", " iris", "iniis", "ciris", "iniIS", "iniris", "IIS", "iris", "iiIs", "ciIS", "ciIs"], "dcmParser": ["dbmPolicy", "dbmParser", "dmmLoader", "dmissionParser", "dcmInstallation", "dmoduleJar", "dpmLoader", "dmoduleparser", "dhemReader", "dkmParser", "dmissionLanguage", "dCMPlugin", " dpmparser", " dcrParser", "fpmparser", "dhemJar", " dpmPolicy", "dkmPolicy", "dpmParser", "dcmPolicy", "dmissionPlugin", " dcmarser", "dmmPlugin", " dcrPlugin", "DcmInstallation", " dcmLanguage", "dpmHandler", "dmcJar", "dkmPlugin", " dpmParser", "dmoduleReader", " dcrLoader", "fcmReader", "dmissionReader", "dcrParser", "dmcarser", "dbmHelper", "dmLoader", "fpmHandler", "dcrarser", "dhemInstallation", "dmcParser", "dmmparser", "dpmLanguage", "dmodulePlugin", " dcmPolicy", "dpmarser", "dpmReader", "dcmPar", "dpmPar", "dmReader", "dcmparser", "dcrLoader", "dmParser", " dcmLoader", " dcmReader", "fcmparser", "dpmPolicy", "dcrJar", "dcmPlugin", "dpmparser", "fpmReader", "dcmarser", " dpmPlugin", "dbmPlugin", "dpmPlugin", " dpmHelper", "dCMLoader", " dpmLoader", " dpmJar", "dmoduleParser", " dcrReader", "dcmLoader", "fcmParser", "dpmHelper", "dcmReader", " dpmPar", "dCMHandler", "dmPlugin", "dcmJar", "dcrPlugin", "dpmJar", " dcmJar", "fcmHandler", " dcmHelper", "dCMparser", "dcrPar", "DcmParser", " dcmPar", "dcrReader", "fpmParser", " dpmReader", " dcmparser", "dmcPar", " dpmLanguage", "dcmHelper", "dpmInstallation", "dcmHandler", "dCMParser", "dcmLanguage", "dmmParser", "DcmReader", "dCMReader", "dkmHelper", " dcmPlugin", "DcmJar", "dhemParser", " dpmarser"], "ds": ["services", "ys", "uds", "ays", "DS", "iss", "gd", "sys", "Os", "df", "ants", "ns", "tes", "ks", "drivers", "qs", "bs", "s", "ins", "dr", "is", "dc", "rs", "ld", "dt", "parts", "cdn", "sync", "session", "ws", "d", "ros", "eps", "points", "icks", "ads", "data", "gs", "src", "xs", "utils", "vals", "ras", "Ds", "des", "ts", "conn", "vs", "ls", "js", "ss", "db", "ils", "di", "nas", "details", "amps", "Db", "da", "asi", "cs", "dds", "ps", "os", "dat", "pd", "dd", "tx"], "pdReader": ["hdRunner", "pbRunner", "pcReader", "pdRunner", "xdreader", "dsReader", "dsreader", "pbLoader", "hdReader", "hdreader", "dsLoader", "pcLoader", "pbStream", "hdStream", "ddStream", "pcRead", "xdWriter", "ddLoader", "pdLoader", "pdStream", "ddRunner", "pbReader", "hdWriter", "dsRead", "dsWriter", "xdRead", "pcWriter", "xdReader", "hdRead", "hdLoader", "ddReader", "pdreader", "pdRead"], "out": ["ssl", "base", "temp", "output", "net", "as", "s", "in", "at", "lib", "model", "default", "file", "gen", "conn", "Out", "url", "obj", "with", "external", "point", " in", "outer", "ex", "sys", "lock", "builder", "result", "later", "sync", "part", "cache", "up", "oder", "connection", "w", "parent", "store", "page", "object", "device", "again", "name", "exec", "exp", "array", "full", "over", "list", "order", "inner", "outs", "o", "line", "flow", "co", "write", "password", "session", "doc", "diff", "group", "director", "null", "dev", "io", "writer", "image", "to", "word", "cli", "term", "auto", "her", "copy", "user", "OUT", "child", "manager", "pass", "key", "client", "dot", "login", "inc", "down", "data", "db", "layer", "ext", "err", "code", "img"], "dcmEncParam": ["dcmEnParam", "dcmEstParam", "dcmDecParam", "dcmEnParameter", "dcmSecPart", "dcmDecType", "dcmDecPar", "dcmEncType", "dcmEncParameter", "dcmArchParam", "dcmEncPart", "dcmElParameter", "dcmEnPar", "dcmEnPart", "dcmDecArg", "dcmArchArg", "dcmArchParameter", "dcmSecPar", "dcmEnArg", "dcmDecParameter", "dcmDecPart", "dcmSecType", "dcmElParam", "dcmEstPar", "dcmEncPar", "dcmSecParam", "dcmElPar", "dcmEncArg", "dcmElType", "dcmEnType", "dcmEstType", "dcmEstParameter"], "pdWriter": ["dpWrite", "pdOutput", "ddWrite", "pdWriting", "htWriter", "dpReader", "dsReader", "hdReader", "pdWrite", "htWriting", "dpWriting", "PDWrite", "dpWriter", "hdWriter", "dsOutput", "dsWriter", "hdWrite", "htWrite", "PDWriter", "dsWrite", "ddOutput", "PDReader", "ddReader", "htReader", "PDWriting", "ddWriter", "hdOutput"]}}
{"id1": "14188043", "id2": "3375718", "code1": "    public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException {\n        AQUtility.debug(\"net\", urlPath);\n        URL url = new URL(urlPath);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setConnectTimeout(NET_TIMEOUT);\n        int code = connection.getResponseCode();\n        if (code == 307 && retry) {\n            String redirect = connection.getHeaderField(\"Location\");\n            return openHttpResult(redirect, false);\n        }\n        if (code == -1 && retry) {\n            return openHttpResult(urlPath, false);\n        }\n        AQUtility.debug(\"response\", code);\n        if (code == -1 || code < 200 || code >= 300) {\n            throw new IOException();\n        }\n        byte[] result = AQUtility.toBytes(connection.getInputStream());\n        return result;\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 0, "substitutes": {"openHttpResult": ["openRouteResult", "openNetworkresult", "closeHttpresult", "openSocketRequest", "openNetworkRequest", "openHTTPresult", "closeHTTPSource", "openHttpResponse", "openUrlresult", "openNetworkResult", "getHttpResult", "openSocketResponse", "getHttpRequest", "openttpResult", "getHTTPResponse", "closeHTTPresult", "openhttpRequest", "openHttpRequest", "openSocketSource", "openhttpResult", "closeHTTPRequest", "openHTTPResponse", "closeHTTPResult", "openRouteRequest", "closeHttpMessage", "openUrlResponse", "openttpMessage", "closeHttpSource", "getHTTPresult", "getHTTPResult", "openSocketResult", "closeHTTPResponse", "openttpresult", "openhttpresult", "openNetworkResponse", "openHttpSource", "openHTTPRequest", "openHttpMessage", "openRouteSource", "openhttpResponse", "closeHTTPMessage", "getHTTPRequest", "closeHttpResult", "closeHttpRequest", "openUrlResult", "openttpResponse", "openHTTPSource", "openRouteResponse", "closeHttpResponse", "openHttpresult", "openUrlMessage", "getHttpResponse", "openHTTPResult", "getHttpresult", "openHTTPMessage"], "urlPath": ["urlText", "httpPath", "UrlHome", "resourceFile", "httpHome", "uriFile", "UrlText", "UrlPath", "resourcepath", "uriPath", "lPath", "runInfo", "urlCase", "urlFile", "urlHome", "urlpath", "uriName", "lpath", " urlpath", "URLText", "urlName", " urlPoint", "uripath", "httpCase", " urlCase", " urlHome", "urlInfo", "filepath", "resourcePath", " urlInfo", "Urlpath", "fileFile", "filePath", "URLpath", "runpath", "URLPoint", "UrlPoint", "runPath", "resourceName", "URLPath", "urlPoint", "UrlCase", "fileName", "httppath", " urlText", "lInfo"], "retry": ["detry", "detrying", "refrying", "pretried", "Retried", "detri", "retone", "retrying", "refried", " retone", "retrow", "Retry", "pretri", "reltry", "refri", "retri", " retried", "pretry", "relry", "relrying", " retrow", "rtri", "rerying", "pretrow", "Retri", "relone", " retri", "rtry", "reone", " retrying", "rettry", "Retrying", "rtrow", "retried", "detried", "refry", "rtried", "rery", " rettry"], "url": ["lc", "base", "client", "util", "URL", "proxy", "path", "log", "sl", "Url", "connect", "conn", "string", "li", "image", "c", "link", "org", "ssl", "user", "www", "config", "loc", "uri", "service", "resource", "http", "l", "page", "entry", "file", "server", "channel", "source", "con", "web", "f", "relation"], "connection": ["lc", "error", "client", "cache", "connected", "union", "use", "io", "proxy", "function", "creator", "index", "connect", "session", "conn", "context", "driver", "section", "image", "c", "link", "nn", "database", "character", "event", "communication", "component", "info", "user", "Connection", "b", "application", "object", "text", "number", "body", "handler", "config", "loc", "socket", "co", " Connection", "uri", "resource", "wrapper", "close", "condition", "http", "ion", "l", "cli", "channel", "server", "con", "nc", "f", "response", "relation"], "code": ["score", "complete", "cm", "test", "error", "dec", "level", "grade", "status", "cod", "change", "call", "pri", "cycle", "id", "zip", "force", "e", "sec", "Code", "check", "one", "x", "index", "state", "bug", "success", "order", "c", "xx", "fe", "cc", "zone", "reason", "type", "ie", "mode", "count", "go", "ce", "desc", "charge", "ception", "orig", "see", "co", "message", "done", "version", "close", "key", "content", "coded", "age", "rc", "line", "last", "se", "sc", "cause", "stage", "create", "coord", "nc", "ode", "expected", "size", "codes", "response"], "redirect": ["Redirect", "codedef", "refirection", "redirection", " redirection", "redanch", " redition", "transition", "transirection", "refanch", "refrict", " redef", "codedirect", "Redanch", "Redrict", "transef", "Redirection", "codedition", "redrict", "redition", "refirect", " redrict", "transirect", "redef", "codedirection", " redanch"], "result": ["error", "cache", "grade", "status", "str", "output", "answer", "comment", "dict", "load", "Result", "request", "default", "df", "string", "ret", "image", "err", "success", "results", "report", "r", "object", "diff", "buffer", "array", "message", "resource", "content", "rc", "page", "continue", "match", "source", "work", "data", "entry", "up", "instance", "value", "record", "response"]}}
{"id1": "22441244", "id2": "16378239", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "label": 1, "substitutes": {"send": ["text", "message", "create", "set", "parse", "build", "from", "reply", "open", "export", "execute", "add", "sent", "transfer", "post", "exec", "address", "append", "Send", "write", "submit", "end", "get", "start", "delete", "mail"], "hsession": ["hession", "hesess", "openssession", "hsess", "hsSession", "hhessions", "hhort", "HSsession", "hSession", "hesort", "hsort", "hmSession", "hesession", "hsessions", "opensess", "hmsession", "hhess", "HSessions", "hmessions", "hessession", "opensession", "opensort", "opensessions", "hessions", "hmession", "opensSession", "HSSession", "hssession", "hhsession", "hhSession", "hhession", "HSession"], "session": ["message", "cache", "client", "port", "essions", "ession", "state", "event", "manager", "project", "proxy", "resource", "chat", "document", "class", "mail", "security", "server", "host", "sl", "connection", "parent", "response", "site", "Session", "context", "application"], "repositoryName": ["reposicationName", "reposositoryEmail", "reposessionEmail", "repositoryEmail", "reposicationFamily", "repoositoryNAME", "repositiveEmail", "repositoryPath", "repositoryNAME", "repoitoryEmail", "reposicationAddress", "repoositoryEmail", "repoitoryNAME", "repositiveName", "repoitoryPath", "reposositoryAddress", "reposicleName", "repositoryFamily", "repositiveNAME", "reposositoryFamily", "repoitoryFamily", "reposositoryName", "reposicleFamily", "reposessionNAME", "reposessionName", "repositivePath", "repoositoryFamily", "repoositoryName", "repoositoryAddress", "reposicleAddress", "reposositoryPath", "repoositoryPath", "reposicationEmail", "repositoryAddress", "repoitoryAddress", "repoitoryName", "reposicleEmail", "reposositoryNAME", "reposessionPath"], "ideIdint": ["ideInn", "ideidInt", "ideInints", "ideAuthints", "ideInfoint", "ideNameout", "ideTimeInt", "ideInInt", "IDEidint", "IDENamenumber", "ideAuthInt", "IDEIdints", "ideidint", "IDENameInt", "ideIdn", "IDEIdn", "IDEIdInt", "IDEidInt", "ideidn", "ideIdout", "ideNameint", "ideTimenumber", "ideInfonumber", "IDEidints", "ideAuthint", "ideInfoInt", "ideNameInt", "IDENameout", "ideIdints", "ideTimeint", "ideInint", "IDENameint", "ideNamenumber", "IDEIdnumber", "ideIdInt", "IDEidn", "IDEIdint", "ideIdnumber", "IDEIdout", "ideidints", "ideAuthn", "ideInfoout", "ideTimeout"], "to": ["account", "source", "contact", "message", "top", "about", "summary", "token", "TO", "client", "phone", "uri", "with", "company", "title", "options", "po", "by", "from", "location", "name", "mail", "sub", "address", "target", "prefix", "tel", "To", "settings", "office", "response", "template", "site", "mobile", "reply"], "cc": ["account", "contact", "cs", "phone", "client", "uc", "cf", "ac", "c", "company", "tc", "card", "ca", "ci", "from", "ce", "comment", "ec", "lc", "CC", "cr", "code", "sc", "password", "address", "cus", "rc", "nc", "cl", "cca", "cn", "ct", "ck", "cb", "dc"], "bcc": ["pce", "bbrc", " bck", "abcc", "brc", "abce", "fck", "bbck", "bc", "pc", " bc", "pck", "abck", " bce", "fc", "bbcc", "bce", " brc", "pcc", "frc", "bck", "bbc", "fcc", "abc"], "subject": ["message", "method", "filename", "uri", "phone", "username", "author", "head", "title", "state", "object", "format", "reply", "comment", "description", "reason", "host", "sub", "header", "prefix", "ject", "Subject", "request", "template", "response", "content", "mail"], "body": ["text", "source", "secret", "message", "normal", "style", "summary", "media", "pod", "length", "Body", "empty", "inner", "view", "pass", "how", "tree", "line", "data", "left", "resource", "money", "object", "comment", "description", "shell", "url", "base", "name", "reason", "code", "bound", "password", "function", "zip", "header", "string", "connection", "lock", "plain", "wrapper", "html", "part", "template", "response", "foot", "content"], "attachments": ["Attachments", "messings", "messents", "embedment", "embedments", "messment", "messments", "attachings", "Attachents", "embedents", "embedings", "attachents", "Attachings", "Attachment"], "isHtml": [" isChtml", "isChhtml", "isWhtml", "isHive", "isChive", "isWhive", "isHahtml", "isChtml", " isHttp", "isPhttp", "isPhtml", " isWhail", "isChttp", " isChttp", "isHttp", " isHive", "isHaail", " isWhive", " isWhhtml", " isChhtml", "isCail", " isChail", "isChail", "isWhhtml", "isHhtml", " isHail", " isWhtml", "isHatml", "isHattp", "isWhail", "isCive", "isPhail", "isCtml", "isPhhtml", " isHhtml", "isHail"], "charset": ["chARSete", "charsET", "charsetting", "chasesET", "chearsetting", "CharsET", "Charset", "charseting", "Charsetting", "chansetter", "chasesetting", "chacksET", "charsets", "cheansET", "chackset", "cheansete", "chanspace", "chasetter", "chearspace", "chashesET", "chasET", "chasheset", "chearset", "chaseting", "Charsets", "charsete", "chaspace", "chARSetting", "chaseseting", "chARSet", "chasetting", "chanset", "chansetting", "chearsetter", "charspace", "chasets", "Charseting", "chansET", "chansete", "chARSets", "cheanspace", "chearsete", "chaset", "chacksetting", "chaseset", "cheansetter", "chashespace", "cheanset", "cheansetting", "chARSeting", "chearsET", "chARSET", "charsetter", "chacksete", "chashesetter"], "headers": ["types", " recipients", "writers", "lines", " emails", "ers", "content", "options", "groups", "errors", "names", "strings", "metadata", "authors", "params", " messages", "files", "header", " cookies", "settings", "mails", "users", "properties", "classes", "comments", "status"], "priority": ["secret", " recipients", "mode", "phone", "length", "language", "author", "date", "title", "state", "level", " title", "comment", "class", "security", "reason", "code", "theme", "lang", "quote", "prefix", "queue", "template", "comments", " severity", "status", "reply"], "email": ["account", "text", "contact", "message", "create", "result", "business", "output", "international", "generic", "username", "update", "info", "lex", "model", "event", "view", "e", "note", "enter", "line", "oe", "default", "install", "data", "example", "service", "object", "print", "export", "online", "document", "url", "em", "name", "base", "core", "server", "article", "ext", "password", "zip", "entity", "address", "letter", "external", "element", "el", "Email", "engine", "fax", "auto", "en", "html", "test", "office", "ssl", "template", "response", "liner", "gmail", "ilo", "pm", "xml", "mail"], "user": ["account", "me", "uid", "role", "token", "client", "username", "author", "info", "model", "use", "person", "e", "friend", "USER", "unknown", "data", "object", "resource", "consumer", "ip", "character", "name", "string", "connection", "profile", "plugin", "creator", "users", "er", "member", "id", "type", "people", "mobile", "User"], "identity": ["authentization", "publicITY", "authoronymous", "authentifier", "identITY", "ethnicication", "publicity", "idication", "IdentITY", "authentity", "electricentity", "IDENTities", "personentity", "publiciciary", "identonymous", "authorities", "authentITY", "personifier", "ethnicentity", "identifier", "personITY", "ethnicifier", "electriconymous", "idity", "idization", "installity", "authority", "entityization", "electricity", "authorifier", "IDENTentity", "ethnicITY", "electricITY", "authorentity", "Idententity", "identities", "idententity", "IDENTity", "idifier", "entityonymous", "personity", "identication", "identiciary", "installonymous", "installITY", "authentication", "Identities", "authorication", "ethniciciary", "identization", "authorITY", "publicentity", "authoriciary", "ethnicity", "idonymous", "authentonymous", "IDENTITY", "Identity", "entityifier", "entityity", "installentity", "idITY"], "_returnPath": ["_returnHalf", " _returnHalf", "_relationId", "_resultHalf", "_backPart", "_returnpath", "_inputNode", "_correctId", " _backPath", "_correctDirectory", "_backName", "_relationPath", "_correctPath", " _backPart", "_returnId", "_returnText", "_backHalf", "_responsepath", "_returnUrl", "_replyPart", " _returnUrl", "_returnType", "_returnMid", "_replyPath", " _returnName", "_successId", "_backPath", "_displayNode", "_replyUrl", "_displayMid", "_successDirectory", "_responseType", "_returnPart", "_responsePath", "_returnDirectory", "_inputMid", "_resultTo", "_relationText", "_backTo", "_replyNode", "_backpath", "_relationDirectory", "_replyMid", "_returnTo", "_addType", "_addPath", " _backTo", "_resultName", "_returnNode", "_returnName", " _backName", "_successText", "_displayPart", " _backUrl", " _returnPart", " _backHalf", "_resultPath", "_backUrl", "_displayPath", "_addpath", "_inputUrl", "_backType", "_correctText", " _returnTo", "_inputPath", "_displayUrl", "_successPath"], "_from": ["placefor", " _owner", "_for", " _source", "blockto", "_who", "_with", "workto", "_From", "blockfrom", "placeowner", " _error", " _for", "_source", "existingowner", " _with", "blockerror", "_owner", "blockFrom", "workfrom", "placeto", "existingto", "_error", "workwho", " _From", "existingfor", "placefrom", "worksource", "existingfrom", " _who"], "_replyTo": ["_returnFrom", "_replyOf", "_commentTO", "_commentOf", "_commentFrom", "_addTo", "_reasonFrom", "_addPoint", "_respondAddress", "_respondTO", " _replyTO", "_commentTo", "_closeTo", "_respondTo", "_replyTO", "_closeFrom", "_reasonTO", "_replyAddress", " _replyFrom", "_addAddress", "_returnAddress", "_respondPoint", " _returnTO", "_returnTo", "_returnOf", "_closeOf", " _returnFrom", "_addFrom", "_reasonTo", "_returnTO", "_respondFrom", "_replyFrom", "_returnPoint", "_replyUrl", " _returnTo", "_replyPoint", "_returnUrl", "_respondUrl", " _replyUrl", "_closeTO", "_reasonUrl", " _returnUrl"], "_to": ["_about", "Jfrom", "Jtarget", " _about", "_target", "Jabout", " _target", "Jto"], "_cc": ["_cf", " _cd", " _ce", "_cd", "_ce", " _cf"], "_bcc": ["_sbcc", "_bcs", " _abcc", "_rbcs", " _bce", "_bce", " _bc", "_abce", "_rbc", "_sbc", " _abc", "_sbce", "_bc", "_abcs", "_abcc", "_sbcs", "_abc", "_rbce", "_rbcc", " _abce", " _bcs", " _abcs"]}}
{"id1": "6341264", "id2": "18097962", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getJarFile", "getFolderInfo", "GetJarSource", "loadJarentry", "loadJarEntry", "getZipentry", "loadZipentry", "getjarEntry", "getJarentry", "getZipInfo", "getEntryEntry", "loadZipEnt", "getEntryentry", "getZipSource", "getEntryFile", "getZipEntry", "getJarSource", "getFolderSource", "getJarEnt", "loadJarFile", "GetZipEntry", "loadJarEnt", "GetJarEntry", "getEntryEnt", "loadZipFile", "getjarEnt", "getjarentry", "getJarInfo", "getZipEnt", "loadZipEntry", "GetJarFile", "GetZipFile", "GetZipInfo", "getFolderEntry", "getFolderFile", "GetZipSource", "GetJarInfo", "getjarFile", "getZipFile"], "jarName": ["jarPath", "JarName", "browserId", "jarUrl", " jarID", "JarID", "javaUrl", "browserUrl", "jarAlias", "browserName", "browserAlias", " jarPath", "javaPath", "JarPath", "javaID", "javaName", "javaAlias", "jarId", " jarId", "JarAlias", "javaId", " jarUrl", "jarID", " jarAlias"], "entry": ["image", "service", "query", "ie", "element", "key", "host", "feed", "enter", "id", "ry", "route", "archive", "server", "address", "connection", "ident", "path", "resource", "description", "file", "str", "start", "zip", "data", "type", "ticket", "offset", "secret", "name", "Entry", "plugin", "string", "uri", "jar", "source", "filename"], "port": ["position", "ip", "timeout", "service", "pos", "host", "Port", "key", "ort", "version", "delay", "patch", "limit", "server", "address", "target", "time", "path", "direction", "count", "file", "type", "offset", "name", "password", "project", "string", "ports", "point", "uri", "PORT", "pid", "length"], "b": ["r", "db", "abb", "bp", "buffer", "bytes", "p", "bf", "br", "i", "ab", "lb", "bs", "s", "zb", "emb", "ib", "bb", "e", "sb", "boot", "a", "fb", "beta", "mb", "ob", "library", "buff", "pb", "B", "bd", "reb", "f", "eb", "binary", "wb", "base", "buf", "bar", "v", "l", "xb", "obb", "d", "nb", "orb", "cb", "c", "erb"], "codebase": ["broadbase", "queBase", "quebas", "corebar", "codeBase", "corebase", "workb", "CodeBase", "broadb", "workBase", " codefull", " codeBase", " codeb", "codebar", "Codebar", "queb", "broadBase", " codebar", " codebas", "workbase", "Codebas", "quebase", "coreBase", "workfull", "codefull", "codebas", "codeb", "corebas", "broadfull", "Codeb", "Codebase"], "protocol": ["Protocol", "ocolocol", "predocol", "protost", "Protport", "verbost", "propport", " protost", " protology", "predology", "predurl", " proturl", "propurl", "protore", "predore", "propocol", "verburl", "Protost", "verbocol", "verbology", "proport", "proology", "ocolore", "protport", "proturl", "Proturl", "Protology", "Protore", "ocolurl", "propology", "prourl", "protology", "proocol", "ocolology"], "x": ["xes", "m", "h", "max", "p", "xt", "tx", "ctx", "pos", "xp", "xxxxxxxx", "ix", "xs", "rx", "id", "ex", "X", "xf", "es", "dx", "check", "val", "ax", "exp", "index", "z", "work", "ww", "xc", "lex", "en", "f", "xi", "xxx", "pe", "xxxx", "y", "v", "xx", "xd", "w", "fx", "d", "wx", "xa", "cross"], "s2": ["e2", "string2", "s62", "e1", "stringtwo", "ptwo", "stwo", "p1", "sls", "satter", "xls", "e62", "o62", "qsii", "v1", "o1", "ssecond", "v2", "patter", " sls", "qsls", "osecond", "esecond", " s1", "s1", "qs2", "vtwo", " ssecond", "qs1", "x1", "stringatter", "vatter", "sii", "string1", "xii", "p2", " s62", " sii", "o2"], "x2": ["x0", " x6", "ix1", "tx2", "index0", "tx52", "ix6", "ix2", " x52", "X2", "xSecond", "txSecond", "X1", " x0", "X52", "index1", "XSecond", "ix0", " xSecond", "index6", "x1", "x6", " x1", "index2", "x52", "tx1"], "downloadHost": ["transferHost", "transferPath", " downloadAddress", "transferRoot", "DownloadPath", "updateRoot", "urlDomain", "writePort", "transferhost", "downloadDomain", " downloadRoot", "updateAddress", " downloadPath", "transferPort", "transferAddress", "downloadRoot", "downloadPort", "writeDomain", "updatehost", "urlHost", "urlhost", " downloadhost", "downloadhost", "downloadAddress", "Downloadhost", " downloadPort", " downloadDomain", "writehost", "urlPort", "downloadPath", "DownloadHost", "updateHost", "writeHost", "DownloadAddress"], "url": ["ball", "image", "j", "service", "sl", "ul", "obj", "rl", "el", "fl", "user", "ls", "bb", "il", "server", "coll", "loc", "connection", "http", "URL", "li", "resource", "ob", "ssl", "file", "build", "link", "util", "f", "Url", "base", "zip", "control", "gl", "contact", "log", "rel", "org", "ll", "l", "web", "ur", "uri", "lock", "jar", "orb", "source", "www"], "jurl": ["juri", "gurl", "Jurl", "jeturi", " jcoll", "ajURL", "jjURL", " jfile", "jjurl", "jURL", "JUrl", "jjob", "jpurl", "jetfile", "Jcoll", "Juri", "jhttp", "jcoll", "nconnection", "Jjob", " jjob", " jURL", "gURL", "ajurl", "nurl", " jhttp", "jeturl", "jphttp", "jfile", "jUrl", "jconnection", "JURL", "jpjob", "jpURL", "nURL", "gconnection", "Jhttp", "jjcoll", "Jfile", "gUrl", "nUrl", "jjfile", "jetURL", "Jconnection", "ajfile", "ajuri"], "je": ["ne", "su", "fr", "la", "j", "obj", "oe", "ie", "java", "jen", "e", "ee", "ze", "py", "jj", "Obj", "ja", "li", "se", "jl", "esi", " ze", "zip", "jp", "ni", "ju", "ji", "Je", "kee", "oi", "pse", "elt", "js", "si", "jar", "opy", "jo"], "is": ["lis", "os", "ai", "in", "mis", "Is", "obj", "ie", "iso", "isl", "isin", "isa", "oss", "i", "src", "bs", "s", "ois", "its", "ib", "bb", "il", "ses", "sin", "isi", "es", "address", "ris", "IS", "info", "ui", "state", "iss", "http", "ios", "ori", "li", "nis", "ii", "ob", "cos", "ir", "iris", "ais", "api", "zip", "ri", "are", "so", "vs", "as", "js", "si", "uri", "jar", "self"], "bis": ["lis", "os", "mis", "Is", "obj", "connection", "oss", "isin", "oris", "i", "bus", "bs", "s", "proxy", "ois", "slice", "bb", "ls", "usb", "abi", "ses", "sin", "sb", "ris", "IS", "boot", "iss", "obs", "cos", "ios", "bps", "ubis", "nis", "fb", "bes", "ori", "http", "ob", "ignore", "iris", "inner", "bi", "abs", "pi", "bits", "binary", "serv", "base", "zip", "ri", "download", "di", "bin", "bos", "obb", "uri", "afi", "lock", "cb", "uds"], "size": ["large", "rate", "shape", "sync", "ize", "capacity", "sec", "cel", "term", "form", "rc", "use", "init", "eng", "sized", "cr", "sn", "ci", "core", "address", "loc", "sum", "content", "grade", "time", "cm", "se", "send", "now", "esc", "len", "en", "area", "close", "enc", "unit", "iz", "scale", "mode", "Size", "err", "range", "cl", "width", "co", "name", "small", "body", "si", "speed", "act", "hh", "SIZE", "length"], "rb": ["lr", "r", "abb", "bf", "rd", "rl", "src", "rc", "lb", "zb", "bb", "cr", "rx", "sb", "loc", "ru", "fb", "adr", "rab", "io", "ob", "rh", "gb", "rr", "ra", "pb", "nr", "rar", " rc", "sr", "reb", "rf", "buf", "eb", "wb", "area", "ri", "range", "rt", "RB", "rub", "vr", "xb", "rg", "obb", "nb", "orb", "ruby", "cb", "rob", "erb"], "chunk": ["chunky", " Chunk", "clunks", "boy", " chack", "bink", "pask", "clone", "shink", "cheunk", "shunk", "Chunk", "quunk", "bone", "punky", "chrow", " chunks", "cheink", "CHunc", "schunk", "chone", "Chunks", "shoy", "chunks", "CHunk", "clunc", "chink", "qurow", "quunky", "shone", "schrow", "schask", "clunk", "cheunks", " Chack", " Chunks", "chunc", "choy", "schunky", "cheunc", "CHunks", "chack", "Chack", "punk", "chask", "CHink", "cloy", "bunk", "prow", "clink", "quask"]}}
{"id1": "15799935", "id2": "536614", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveAttachmentPart", "saveAttPartbody", "saveAttachedBody", "saveAppachmentBody", "saveAppensionPart", "saveAppachmentFile", "saveAttensionbody", "saveAttachmentFile", "saveAttPartPart", "saveAttachedbody", "saveAttensionPart", "saveAppachmentPart", "saveAppensionBody", "saveAttachedPart", "saveAppensionbody", "saveAppensionFile", "saveAttPartFile", "saveAttPartBody", "saveAttachmentbody", "saveAppachmentbody", "saveAttensionBody", "saveAttensionFile"], "context": ["text", "contact", "message", "concept", "media", "cache", "current", "client", "cf", "translation", "c", "config", "front", "system", "environment", "kernel", "state", "component", "event", "view", "driver", "processor", "content", "input", "ca", "manager", "project", "Context", "present", "definition", "service", "resource", "ce", "document", "subject", "host", "center", "container", "connection", "channel", "queue", "coll", "cca", "collection", "mc", "request", "version", "template", "community", "support", "reader", "ctx", "parent", "network", "cms"], "part": ["p", "pre", "source", "message", "parts", " Part", "app", "position", "media", "pod", "translation", "point", "component", "place", "state", "event", "per", " parts", "po", "area", "to", "image", "or", "PART", "object", "from", "service", "comment", "base", "name", "phase", "chapter", "body", "upload", "connection", "patch", "channel", "section", "mission", "plan", "block", "html", "Part", "file", "Parts", "partial", "art", "type", "parent", "start"], "localAttachment": [" localAttachachment", "LocalAttention", " localAttment", "localAddachment", "localExtacher", "localAttachacement", " localAttacement", " localExtacement", " localExtacher", " localAttrollment", "localAssachment", "localInstension", "localAttension", " localPartention", " localAttension", "LocalAttachment", "localAssail", "LocalAttail", "LocalAssachment", "localattment", "localattention", "localAvachment", "localArtail", "localAddail", "localPartachment", " localPartension", " localAttribution", "localAvention", "localAddention", "localAvacher", "localattrollment", "localArtment", "localAttment", "localAttachachment", "localInstachment", "localAttacher", " localExtachment", "localAttachension", "localAddment", " localPartachment", "localAttachribution", " localAttachrollment", "LocalAssment", "localPartention", "localAssment", "localInstention", "localPartension", " localAttacher", " localPartribution", "localAttribution", "localAttacement", "localArtention", "localAvacement", "localInstribution", "localAttention", "localAttachention", "LocalAssail", "localAddrollment", "LocalAssention", "localattachment", "localAttachrollment", "localAssention", "localAttachacher", "localAttrollment", " localExtention", "localExtention", "localPartribution", " localAttention", "localAttail", "LocalAttment", "localExtachment", " localAttachention", "localArtachment", "localExtacement"], "accountId": ["jobid", "AccountID", " accountName", "appID", " accountid", "accId", "appId", "jobId", " accountInfo", "accInfo", "contactid", "accountInfo", " accountID", "accid", "AccountId", "feedid", "contractName", "Accountid", "accID", "appid", "appInfo", "AccountName", "contractid", "contactName", "feedID", "accountName", "accountID", "contractId", "feedName", "feedId", "jobID", "jobName", "contactId", "accountid"], "attachmentId": ["attociationReference", "atociationID", "extachmentID", "adentionID", "attentionSource", "attachmentReference", "attachedId", "attmentReference", "addentionID", "addentionUrl", "attachmentIndex", "attociationId", "atachmentReference", "adachmentID", "attachmentName", "extensionSource", "atachmentId", "attmentID", "attentionIndex", "attensionSource", "attachedUrl", "extensionid", "attociationID", "attentionUrl", "attentionId", "adachmentIndex", "attptionIndex", "attentionid", "addachmentId", "atachmentID", "attlementId", "attlementReference", "attmissionId", "atociationId", "attmissionID", "extachmentSource", "addachmentType", "attentionInfo", "addentionId", "attptionInfo", "attociationUrl", "attlementID", "attmissionSource", "attptionId", "addentionType", "attlementName", "attociationType", "attachmentUrl", "extensionId", "attensionID", "attptionID", "attentionID", "attmentId", "attensionid", "attmentName", "adachmentId", "adentionIndex", "attentionType", "adentionId", "attachmentInfo", "attagramIndex", "addachmentID", "extensionID", "attachmentSource", "attachmentid", "extachmentId", "extachmentid", "attensionId", "attagramInfo", "adentionInfo", "atachmentName", "attmissionid", "atociationReference", "attachmentID", "atociationName", "attagramId", "attachmentType", "adachmentInfo", "attachedType", "attociationName", "addachmentUrl", "attachedID", "attagramID"], "in": ["p", "source", "as", "init", "copy", "gin", "inn", "pin", "inner", "ac", "load", "f", "info", "plus", "pass", "i", "input", "socket", "inside", "image", "conn", "or", "IN", "data", "ini", "con", "up", "a", "url", "din", "it", "is", "nin", "ins", "cin", "In", "inc", "again", "file", "pull", "err", "login", "slice", "id", "reader", "bin"], "saveIn": ["SaveAs", "savOut", "writeOut", " saveOut", "aveAs", "stageIns", "saveIN", "aveOut", "stageOut", "SaveIns", "savein", "SaveOut", "savIn", "writeIn", " saveIN", "saveOut", "savin", "avein", "stageIn", "saveIns", "aveIn", "writein", " saveIns", " savein", "stageAs", "savAs", "writeIN", "aveIN", "SaveIn"], "saveAs": ["SaveAs", "openAS", "saveAS", "writeOut", " saveOut", "copyas", "copyAS", "saveFile", "writeAs", "writeAS", "createFile", "SaveAS", "saveas", " saveAS", "SaveOut", "copyIn", "writeIn", "openAt", "openFile", "createAs", "saveOut", "saveAt", " saveFile", "createAt", "openAs", " saveas", " saveAt", "Saveas", "createAS", "copyAs", "SaveIn"], "out": ["flow", "source", "as", "init", "copy", "cache", "output", "client", "sync", "path", "inner", "c", "at", "s", "this", "page", "plus", "ex", "to", "OUT", "conn", "line", "image", "default", "data", "writer", "other", "up", "io", "a", "name", "null", "outer", "ext", "exec", "string", "Out", "outs", "inc", "again", "off", "file", "temp", "err", "o", "v", "bin"], "copySize": ["copyAddress", "lesize", "copyTime", "CopyTime", "openSize", "leLength", "bytesize", "saveSize", "opensize", "byteTime", "leSize", " copyLength", "openSIZE", " copyAddress", "leSIZE", "byteSize", "saveAddress", "copysize", "copySIZE", "Copysize", "saveLength", "byteLength", "byteAddress", " copysize", "openLength", " copyTime", "savesize", "copyLength", "CopyLength", " copySIZE", "CopySize"], "contentUriString": ["contentIrisStr", "contentUiniByte", "contentUrisStr", "contentUrisstring", "contentIriByte", "contentUriByte", "contentUpiInt", "contentUiNumber", "contentIrisstring", "contentUuriString", "contentUristring", "contentUrisString", "contentUioStr", "contentUrisInt", "contentUioString", "contentIriString", "contentUridStr", "contentUioInt", "contentIrisInt", "contentIriNumber", "contentIrisUnit", "contentIiByte", "contentIristring", "contentUridString", "contentUriNumber", "contentUriStr", "contentUpiStr", "contentIriInt", "contentUuriByte", "contentUuriNumber", "contentIiString", "contentUrisUnit", "contentUriUnit", "contentIrisString", "contentUuriStr", "contentIriUnit", "contentUriInt", "contentUiniString", "contentIiNumber", "contentIriStr", "contentIiStr", "contentUiStr", "contentUiByte", "contentUpiString", "contentUiniNumber", "contentUridUnit", "contentUiniStr", "contentUiostring", "contentUiUnit", "contentUpistring", "contentUiString"], "mSize": ["cCount", "cName", "pCount", "iLength", "iName", "iSize", "pSize", "mCount", "mLength", "mName", "pLength", "cLength", "iCount", "cSize", "pName"], "mContentUri": ["mContentUric", "mContentOUri", "mContentIric", "mResourceUri", "mResourceUris", "mContentUrric", "mContentIci", "mResourceIris", "mContentUrris", "mContentUris", "mContentOUci", "mResourceIci", "mContentIri", "mContentIris", "mResourceIric", "mResourceIri", "mContentUrri", "mContentUci", "mResourceUci", "mContentOUris", "mContentOUric", "mContentUrci", "mResourceUric"], "cv": ["uv", "cs", "xc", "fp", "uc", "cf", "ctrl", "nv", "cover", "csv", "c", "buf", "CV", "ov", "vr", "pb", "ca", "keep", "loc", "vp", "iq", "vs", "GV", "core", "bc", "av", "conv", "lc", "vm", "iv", "um", "cr", "sc", "rc", "cc", "nc", "VC", "cp", "enc", "cm", "coll", "auc", "fc", "cd", "cu", "lv", "vc", "mc", "cap", "que", "vv", "sv", "ctx", "v", "cb", "co", "content"], "uri": ["uni", "uid", "path", "username", "point", " ur", "environment", "i", " URI", "ci", "data", "resource", "proxy", "format", "location", "metadata", "storage", "url", "base", " url", "iv", "ui", "query", "address", "api", "pi", "iri", " Uri", " scheme", "string", "gb", "mi", "prefix", "oid", "qi", "range", "universal", "attribute", "route", "cli", "href", "URI", "id", "ri", "http"]}}
{"id1": "13757855", "id2": "6966398", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"process": ["request", "cess", "output", "view", "load", "construct", "parse", "run", "evaluate", "handle", "code", "path", "resource", "submit", "proc", "build", "exec", "update", "transform", "processing", "call", "processor", "project", "create", "Process"], "tpl": ["stPL", "lple", " tcl", "tplate", "tmyl", "temPL", "tml", "ttemplate", "tplug", "stpl", "Tplates", "Tper", "lcl", "fpl", "Tsl", "tpp", " tplates", "tmple", "fplate", "tple", "latpl", "tcl", "temtemplate", "qtple", "templates", "tipl", "latple", "Tpl", "stplate", "tmcp", " tml", "Tml", "itPL", "lPL", "fplug", "pipl", "templ", "stpp", "lplate", " ttemplate", " tplug", "latyl", "itpl", "lper", "tmpl", "tcp", "atml", " tplate", "Tfc", "qtpl", "atplate", "fml", "Tbl", "qtfc", " tper", "itplates", "ppl", "tbl", "tPL", " tsl", "atplug", "pPL", "qtbl", "qtcp", "Tipl", "Tpp", " tbl", "psl", " tple", "latcp", "itplate", "lpl", " tpp", " tfc", "tper", "qtyl", "Tcl", " tipl", "atpl", "Tple", "lml", "tplates", "Ttemplate", "Tplate", "pcl", "TPL", " tPL", "tsl", "tfc", "tyl"], "model": ["where", "m", "models", "copy", "Model", "json", "module", "result", "media", "location", "graph", "message", "param", "params", "xml", "conf", "doc", "data", "log", "language", "document", "node", "project", "body", "command", "config"], "packageName": ["projectName", "projectKey", "packagename", "groupKey", "groupname", "packageInfo", "moduleUrl", "moduleKey", "contextname", "Packagename", " packageInfo", "projectname", "contextNames", "groupName", "PackageName", "moduleName", "packageUrl", " packagename", "PackageInfo", "modulename", "packageKey", "packageNames", " packageNames", "PackageNames", "groupUrl", "contextName", "projectUrl", "contextInfo"], "outFileName": ["outRuleInfo", "outRuleType", "outLineNames", "outfileNames", "outDirEnd", "OUTBufferName", "inFilePath", "diffFileName", "outDirCopy", "outfileName", "outFullTime", "outfileCopy", "outDirPath", "outFileTime", "inDirCopy", "outDirInfo", "outStreamName", "OUTFileName", " outFileLine", "outfileOnce", "OUTBufferMode", "outDirOnce", "outBufferMode", "outFileOnce", "outFileEnd", "outFilesPath", "outStreamType", "outFilenameName", "outfileInfo", "outFilesTime", "OutDirLine", "outFilename", "outfileHalf", "outBufferHalf", "outFileLine", "inDirName", "OutDirNames", "outFilesName", "outBufferNames", "outFileType", "outFullname", "outFileHalf", "difffileInfo", "outFilenameNames", "outFileCopy", "outFilenameCopy", "outLineInfo", "OutFileNames", " outFileInfo", "diffFileOnce", "outFullName", "inDirPath", "outFullInfo", "inFileName", "diffFileInfo", "outLineName", "diffFileTime", "difffileTime", "outFilenameEnd", "outFullType", "outFilenameMode", " outDirTime", " outFullType", "outFilenameHalf", "outfileTime", "outLineTime", "outFullPath", "outLineLine", "inFileCopy", " outDirLine", "OutDirname", "outFilesLine", " outFileType", "OutFilename", " outFilePath", "OUTFileNames", " outDirName", "outFileNames", "outLineOnce", "outBufferName", "outfileMode", "outDirTime", "inFileEnd", "outFullLine", "difffileOnce", "inDirEnd", "OUTBufferNames", " outFullName", "outStreamInfo", "outDirLine", "outLinename", "outfileEnd", "OutFileLine", " outDirPath", "outFullNames", "outFilenamePath", "OUTBufferHalf", "outFileInfo", "difffileName", "outDirname", "OutFileName", "outfilePath", "outFileMode", "outDirNames", "OUTFileHalf", " outFullInfo", "outDirName", " outFileTime", "OUTFileMode", "OutDirName", "outFilePath", "outRuleName"], "xsltParam": ["xslicparam", "xslpMode", "xslicMode", "xsldVal", "xslicParam", "xsltMode", "xslpparam", "xslpParam", "xltVal", "xsltVal", "xsldparam", "xsldParam", "xldMode", "xldparam", "xldVal", "xsltparam", "xltParam", "xltMode", "xslicVal", "xltparam", "xslpVal", "xldParam", "xsldMode"], "artifact": ["artfact", "Artfact", "Arturation", " artribution", "Artifacts", "advertribution", "Artifest", " arturation", "advertifacts", "adverturation", "artifest", " artifacts", "ARTifest", "arturation", "ARTifact", "ARTfact", "ARTifacts", "artifacts", "aratifacts", "Artifact", "advertifact", "aratifest", "aratifact", "aratfact", "artribution", "Artribution"], "destinationPath": ["destinatedPoint", "destinationFile", "constinationContext", "destinatorUrl", "datinationPath", "destificationPath", "destinatorFile", "tempinationPath", "restinatorPath", "tempinationpath", "destensionPoint", "destplingPath", "destinatorPath", "destinatorString", "distinatorStep", "constinatorpath", "destensionName", "destinatePath", "desticationKey", "destinatedHalf", "destinatorStep", "destinationsName", "destinateHandler", "destinerPath", "constinatorUrl", "destignmentCase", "destiationDir", "destinatedDir", "desticationPart", "distinationCase", "destinatingPath", "combinationName", "destinateText", "destinationspath", "constinationWidth", "destinationsPath", "restinationString", "tempinatedDir", "destinatepath", "destificationAuth", "destinatePart", "destinateName", "datinationpath", "destinationName", "destiationPath", "destinatedCase", "tempinatedpath", "destributionName", "datinateTime", "desturationName", "constinationName", "desticationPath", "DestinatingName", "destinationUrl", " destificationLog", "datinationTime", "destplingDir", "destplingAuth", "restinationLocation", "restinationpath", "destinatedFile", "destinateDir", " destinationLog", "destiationAuth", "destificationLog", "distinationStep", "desticationFile", "destributionCry", "destinationText", "DestinationPart", "destinateString", "combinationPath", "restinatorPoint", "destinationHandler", "destinationContext", "destinatedString", "constinationsPoint", "distinatorKey", "destplingWidth", "restinationPoint", "destificationLocation", "destationpath", "tempinationHalf", "restificationPath", "desturationPath", "destinationAuth", "distributionCase", "destiningDir", "restificationPoint", "destinatorName", "destinatorPoint", "constinationUrl", "destributionCase", "DestificationPath", "constinatorPath", "destinatedpath", "destinateLocation", "destinationpath", "destensionPath", "destcreationPath", "destinatingpath", "desturationpath", " destinationDir", "destificationpath", "destinatorpath", "destiationLog", "destignmentPath", "destationPath", "destificationName", "destinatorCase", "destplingLog", "destinationCase", "destinationWidth", "combinatorName", "combinatorPath", "destinationsPoint", "restinationHalf", "constinationPath", "constinatorContext", "destinatingName", "destributionDir", "destinerDir", "destinationTime", "restinatorHalf", "destiningContext", " destinationAuth", "DestinatingPath", "destinatorDir", "tempinatedPath", " destificationAuth", "distinationpath", "destinatedPath", "distinationCry", "combinatorHandler", "distributionpath", "distinatorName", " destificationDir", "datinationLocation", "constinatorWidth", "destinateTime", "DestificationPart", "restinatorString", "distinatorCase", "destinationLocation", "distinationDir", "destinationDir", "DestificationName", "destinatePoint", "destinatorHandler", "destinatorHalf", "destplingUrl", "destributionPath", "destinatingLocation", "destcreationUrl", "DestinationPath", "desticationStep", "destinerContext", "desticationName", "distinatorCry", "destinationKey", " destificationPath", "destinatedKey", "destationTime", "DestinationText", "constinatorDir", "combinatorpath", "constinationDir", "destinatingText", "distinationName", "constinationpath", "destiningName", "constinationsPath", "restinationPath", "destiningPath", "combinationHandler", "destributionpath", "distinatorPath", "constinationsName", "restificationpath", "destensionText", "destinationStep", "destinationPart", "destinatorWidth", "destificationPart", "desturationHandler", "destinateHalf", "destinatorTime", "constinationPoint", "distinationKey", "DestinatingText", "DestinationName", "destiningPoint", "destinatorLocation", "destinationLog", "distinationFile", "destationLocation", "destificationPoint", "datinatePath", "DestinationPoint", "distributionPath", "destinerpath", "distinationPath", "constinationspath", "destinationPoint", "destinatorKey", "destignmentName", "destinatingPoint", "destinationString", "combinationpath", "DestinatingPoint", "destiningpath", "destificationDir", "tempinationDir", "destinatedStep", "distributionDir", "distinatorFile", "destcreationWidth", "destinationHalf", "destinatorContext", "tempinatedHalf", "destinatorCry", "destignmentCry", "destinationCry", "datinateLocation", "restificationLocation", "datinatepath"], "in": ["r", "image", "n", "i", "input", "ex", "din", "t", "cache", "connection", "con", "x", "min", "doc", "data", "ins", "name", "bin", "In", "reader", "IN", "d", "source", "config", "c", "inc"], "out": ["Out", "error", "ne", "client", "writer", "obj", "msg", "full", "all", "up", "key", "output", "comment", "user", "version", "free", "write", "parent", "copy", "cli", "page", "ex", "cache", "server", "conn", "group", "state", "result", "connection", "path", "index", "io", "pool", "line", "manager", "file", "str", "post", "part", "store", "prefix", "lib", "o", "exec", "doc", "Output", "session", "err", "with", "temp", "log", "w", "name", "bin", "again", "string", "list", "point", "sys", "outer", "outs", "gen", "lock", "dump", "source", "OUT"], "root": ["r", "query", "tree", "pattern", "instance", "cat", "parent", "id", "include", "json", "cache", "history", "module", "format", " result", "index", "graph", "path", "params", "modules", "resources", "results", " roots", "roots", "_", "xml", "options", "url", "loader", "values", "collection", "transform", "node", "Root", "meta"]}}
{"id1": "22235113", "id2": "947406", "code1": "    protected Object unmarshallXml(final Unmarshaller unmarshaller, final String accessUrl, final String nameSpace, final String replace, final String with) throws Exception {\n        final URL url = new URL(accessUrl);\n        final BufferedReader inputStream = new BufferedReader(new InputStreamReader(url.openStream()));\n        String xmlContent = readWithStringBuffer(inputStream);\n        if (replace != null) {\n            xmlContent = xmlContent.replace(replace, with);\n        }\n        LOGGER.info(\"Calls \" + accessUrl);\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"\\nXml:\" + accessUrl + \"\\n\" + xmlContent);\n        }\n        if (LOGGER.isDebugEnabled()) {\n            final BufferedWriter out = new BufferedWriter(new FileWriter(\"target/XmlAgentLog\" + xmlRequestNumber++ + \".txt\"));\n            out.write(xmlContent);\n            out.close();\n        }\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(xmlContent.getBytes());\n        Source source;\n        if (nameSpace != null) {\n            source = setNameSpaceOnXmlStream(byteArrayInputStream, nameSpace);\n        } else {\n            source = new StreamSource(byteArrayInputStream);\n        }\n        return unmarshaller.unmarshal(source);\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"unmarshallXml": ["unmarshallExml", "unmarshallXil", "unmarshallYML", "unmarshalXML", "unmarshalXml", "unmarshallExson", "unmarshallExil", "unmarshalExson", "unmarshallxml", "unmarshalExML", "unmarshallxson", "unmarshallExML", "unmarshallYson", "unmarshallXson", "unmarshalXson", "unmarshallYil", "unmarshallYml", "unmarshalExil", "unmarshallxil", "unmarshallxML", "unmarshalXil", "unmarshallXML", "unmarshalExml"], "unmarshaller": ["unmashalledable", "unmarshalling", "unmarshalor", "unmashaller", "unmockallinging", "unmarshillers", "unmarshillable", "unmashallor", "unmarshallinging", "unmarshallinger", "unmarshalinging", "unmashallable", "unmarshillor", "unmarshalledor", "unmarshalable", "unmockallingers", "unmashalleder", "unmockalling", "unmockallinger", "unmarshalleders", "unmashalledor", "unmockallers", "unmashallers", "unmarshallingers", "unmarshallers", "unmarshalleder", "unmarshaler", "unmarshallable", "unmarshiller", "unmarshalingers", "unmarshalledable", "unmarshallor", "unmarshalinger", "unmarshaling", "unmarshalers", "unmashalleders", "unmockaller"], "accessUrl": ["AccessUrl", "accessStream", "accessUr", " accessPath", "execFile", "requestLog", "AccessLog", "requestLink", "requestLine", "AccessLine", "serviceUr", "AccessURL", " accessURL", "inputUrl", " accessFile", "accessLink", "AccessPath", " accessUr", "inputLink", "serviceLink", "accessFile", "requestFile", "AccessStream", "requestUrl", "accessPath", "requestURL", "inputURL", "execUrl", " accessLog", "serviceURL", "accessLine", "requestUr", "execURL", "requestPath", " accessLine", "accessURL", "inputUr", "accessLog", "requestStream", " accessStream", "execUr", "serviceUrl"], "nameSpace": ["namespace", "nameSp", "namesSpace", "nameName", "NameSpace", "NameString", "namesspace", "resourceSp", "namesSp", " nameString", "NameName", "resourcespace", "NameSp", "nameFrame", "namesName", " namePath", "resourcePath", "namePath", " nameFrame", "Namespace", " nameSp", "resourceFrame", " namespace", "NamePath", "NameFrame", "nameString", "resourceSpace", "resourceString", " nameName"], "replace": ["group", "escape", "align", "use", "section", "string", "join", "over", "append", "see", "fill", "reply", "comment", "cover", "remove", "be", "same", "search", "protect", "match", "patch", "add", "force", "operation", "place", "pair", "repeat", "address", "store", "insert", "br", "flash", "tag", "fix", "prefix", "find", "placed", "get", "where", "settings", "complete", "like", "space", "strip", "format", "repl", "apply", "change", "quote", "save", "places", "parse", "write", "r", "sub", "update", "alias", "re", "name"], "with": ["resource", "at", "and", "include", "join", "host", "context", "xml", "spec", "partial", "search", "then", "params", "none", "from", "add", "place", " With", "properties", "flash", "document", "tag", "layout", "prefix", "get", "work", "x", "settings", "other", "before", "without", "by", "some", "format", "apply", "claim", " without", "plugin", "style", "id", "around", "message", "With", "name"], "url": ["resource", "window", "stream", "zip", "string", "channel", "host", "blog", "xml", "http", "service", "URL", "log", "ll", "path", "api", "feed", "Url", "rl", "client", "user", "conn", "address", "browser", "l", "connection", "base", "server", "sl", "image", "socket", "page", "ssl", "fl", "uri", "buffer", "file"], "inputStream": ["InputReader", " inputSteam", "inputContent", " inputReader", " inputContent", "xmlSteam", "inputstream", " inputstream", "outputStream", "InputSteam", "outputBuffer", "inputBuffer", "xmlStream", "Inputstream", " inputBuffer", "xmlReader", "InputBuffer", "inputReader", "outputReader", "InputStream", "outputstream", "inputSteam", "InputContent"], "xmlContent": ["xmlString", "xmlAddress", "phpContent", "phpString", "broadMessage", "jsonContent", "xmlMessage", " xmlHeader", "eventContents", "txtContent", " xmlMessage", "xmlContents", "mlString", " xmlContents", "txtContents", " xmlFile", "jsonReader", "eventContent", "xmlFile", "mlFile", "fileString", "mlMessage", "mlDocument", "broadText", "txtAddress", "mlData", "txtFile", " xmlText", " xmlReader", "jsonHeader", "mlHeader", "eventAddress", " xmlData", " xmlDocument", "mlText", "mlReader", "fileContent", "phpData", "mlContent", " xmlString", "xmlReader", "xmlData", "xmlText", "broadContent", "phpFile", "xmlDocument", "jsonMessage", "xmlHeader", "fileDocument", "fileMessage", "eventFile", " xmlAddress", "broadDocument"], "out": ["temp", "group", "window", "again", "project", "full", "cache", "word", "exp", "ex", "Out", "response", "copy", "log", "report", "path", "io", "outer", "outs", "key", "sync", "in", "doc", "object", "user", "err", "up", "w", "prefix", "array", "f", "password", "writer", "plain", "page", "result", "ext", "output", "gen", "data", "write", "OUT", "b", "flush", "stream", "name", "builder", "file", "extra"], "xmlRequestNumber": ["xmlVersionNum", "xmlFilenumber", "xmlRequestnumber", "xmlVersionCounter", "xmlRequestNum", "httpResponseNum", "xmlFileNumber", "xmlFileCounter", "httpResponsenumber", "httpRequestCounter", "httpRequestnumber", "xmlResponseNumber", "httpRequestNum", "xmlFileNum", "httpResponseNumber", "xmlResponseCounter", "xmlVersionnumber", "xmlResponseNum", "httpResponseCounter", "httpRequestNumber", "xmlVersionNumber", "xmlResponsenumber", "xmlRequestCounter"], "byteArrayInputStream": ["byteArrayOutputStyle", "byteStringOutputstream", "byteStreamInputstream", "byteArrayInputFile", "byteArrayBytestream", "byteStringInputStream", "byteStreamInputArray", "byteStringOutputSteam", "byteArrayInputstream", "byteArrayByteStyle", "byteArrayReadFile", "byteArrayOutputSteam", "byteStreamInputStream", "byteArrayReadSteam", "byteArrayReadstream", "byteArrayByteSteam", "byteStreamInputSteam", "byteArrayOutputArray", "byteStreamOutputSteam", "byteStreamInputFile", "byteArrayTextArray", "byteArrayByteStream", "byteArrayInputStyle", "byteStreamOutputStyle", "byteArrayInputSteam", "byteStreamOutputFile", "byteStringInputSteam", "byteArrayReadArray", "byteStreamOutputStream", "byteStreamOutputArray", "byteStringOutputStream", "byteArrayTextStream", "byteArrayReadStream", "byteStringInputstream", "byteArrayTextstream", "byteStreamOutputstream", "byteArrayOutputStream", "byteStreamInputStyle", "byteArrayOutputstream", "byteArrayOutputFile", "byteArrayInputArray", "byteArrayTextFile"], "source": ["resource", "slave", "scene", "plus", "class", "use", "stream", "position", "g", "string", "speed", "zip", "Source", "view", "spec", "str", "proxy", "inner", "scope", "service", "input", "copy", "ource", "node", "ge", "slice", "ce", "content", "object", "unit", "kin", "rule", "connection", "rate", "model", "event", "component", "sp", "config", "size", "get", "sl", "iter", "session", "wrapper", "SOURCE", "result", "secure", "reader", "data", "type", "style", "target", "null", "id", "info", "uri", "text", "src", "core"]}}
{"id1": "18339787", "id2": "8932510", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 0, "substitutes": {"reload": ["overresh", "overloading", "refresh", "prefill", "overload", "preload", "reresh", "reloading", "reffill", "refloading", "preresh", "preloading", "refill", "overfill", "refload"], "currentDate": ["CurrentTime", "reportedDate", "currentUpdate", "CurrentKey", "reportedTime", "currentDay", "CurrentName", "newKey", "newDate", "reportedName", "reportedDay", "currentTime", "CurrentUpdate", "currentName", " currentDay", " currentName", "newUpdate", "currentKey", " currentUpdate", " currentKey", "CurrentDay", "newDay", " currentTime", "CurrentDate"], "xpath": ["xPath", "xparent", "exPath", " xprop", " xPath", "Xath", "exp", "xp", "Xpath", "expath", "XPath", "Xstream", "lexparent", "exprop", "exstream", "lexpath", "xstream", "axPath", "exparent", "xath", "xprop", " xp", " xstream", "xcase", "exath", "axcase", "txstream", "axath", " xparent", "lexstream", "axpath", " xcase", "Xprop", " xath", "Xcase", "lexPath", "Xp", "txpath", "txPath"], "docBuilderFactory": ["docBuildFactor", "projectBuilderFactory", "projectbuilderInterface", "docManagerFactor", "docBuilderF", "docbuilder2", "docManager2", "projectBuilderInterface", "docbuilderService", "documentBuilderFactory", "docBuilderService", "documentBuilderService", "docBuilder2", "projectbuilderFactor", "docBuilderInterface", "docBuildService", "docBuildFactory", "docbuilderFactor", "docBuild2", "projectBuilderFactor", "documentBuilderF", "docBuilderFactor", "documentBuildF", "docBuildF", "documentBuildService", "docBuildInterface", "docbuilderF", "projectBuilder2", "docManagerFactory", "docManagerInterface", "docbuilderInterface", "documentBuildFactory", "projectbuilderFactory", "docbuilderFactory", "projectbuilder2"], "docBuilder": ["documentBuilder", "fileBook", "documentFactory", "DocParser", "xmlBuilder", "fileFactory", "docBook", "fileBuilder", "xmlBuild", "docParser", "documentBuild", "docbuilder", "documentBook", "Docbuilder", "documentbuilder", "xmlParser", " docBuild", "xmlbuilder", "docBuild", " docFactory", "DocBuild", "fileBuild", " docBook", "docFactory", "documentParser", "DocBuilder"], "conn": ["exec", "cm", "lc", "client", "uc", "ann", "URL", "cb", "db", "path", "log", "connect", "Url", "session", "out", "conv", "cp", "cmd", "lock", "c", "ci", "ct", "ssl", "connection", "Connection", "body", "config", "loc", "enc", "nt", "loader", "socket", "api", "http", "l", "cli", "channel", "server", "ch", "cn", "coll", "con", "nc", "Conn", "serv", "conf", "ctx"], "url": ["base", "client", "str", "ob", "feed", "URL", "db", "path", "log", "sl", "Url", "host", "string", "ls", "gl", "image", "err", "build", "org", "ssl", "connection", "ll", "www", "config", "loader", "fr", "uri", "resource", "bel", "http", "l", "data", "file", "channel", "server", "download", "coll", "impl", "serv", "web", "blog", "f"], "xml": ["wt", "address", "reader", "parse", "el", "php", "feed", "zip", "arr", "model", "wl", "path", "x", "log", "request", "children", "input", "node", "context", "response", "stream", "image", "doc", "event", "element", "writer", "html", "root", "example", "config", "layout", "apache", "graph", "update", "events", "office", "date", "tree", "dom", "content", "document", "http", "page", "data", "file", "email", "rss", "json", "atom", "txt", "ml", "temp"], "exchangeRateDate": ["exchangePriceFormat", "expireRateDate", "exchangeWeightKey", "exchangeRateTime", "exchangePricePrice", "exchangeRatePrice", "exchangeTimeDuration", "expirePriceKey", "excurrencyTimeTime", "excurrencyRateFile", "exchangeTimeFile", "exchangeTimeDate", "expirePriceFormat", "exchangeRateDuration", "exchangeRateFile", "exchangeFactorFile", "excurrencyTimeDuration", "excurrencyTimeFile", "exchangeWeightDate", "exchangeRatingKey", "exchangePriceDate", "exchangeRatingDate", "exchangeRateFormat", "exchangeFactorDuration", "exchangeRatingFormat", "expirePriceDate", "expirePricePrice", "expireRateKey", "excurrencyRateDate", "excurrencyRateTime", "excurrencyTimeDate", "exchangeWeightFormat", "exchangeWeightPrice", "exchangeRatingPrice", "exchangePriceKey", "expireRateFormat", "exchangeFactorTime", "expireRatePrice", "exchangeFactorDate", "exchangeTimeTime", "exchangeRateKey", "excurrencyRateDuration"], "currenciesNode": ["corenciesnode", "contractrenciesDocument", "comportsElement", "courrenciesNode", "curportsPath", "curcurrencyPath", "curportsBlock", "contractrenciesRoot", "curitiesContainer", "curratesBlock", "curportsElement", "comrenciesNode", "curlationsElement", "curcurrencyBlock", "currenciesRoot", "cururrenciesArray", "currenciesPath", "courrenciesnode", "comportsPath", "curriesNode", "curratesDocument", "courrenciesArray", "curriesRoot", "comrenciesPath", "cururrenciesNode", "currenciesnode", "cururrenciesRoot", "courrenciesContainer", "curlationsBlock", "currenciesDocument", "curatorsArray", "curlationsNode", "contractrenciesNode", "curcurrencyNode", "comrenciesBlock", "comportsNode", "contractrenciesBlock", "cururrenciesBlock", "curatorsNode", "currenciesBlock", "curportsNode", "currenciesContainer", "comportsBlock", "currenciesArray", "contracturrenciesDocument", "corenciesContainer", "curcurrencyElement", "contracturrenciesBlock", "corenciesNode", "contracturrenciesNode", "curatorsContainer", "curriesBlock", "curratesNode", "contracturrenciesRoot", "comrenciesElement", "curlationsPath", "cururrenciesDocument", "cururrenciesnode", "curitiesNode", "corenciesArray", "curratesRoot", "cururrenciesContainer", "curitiesArray", "curatorsnode", "curriesDocument", "curitiesnode", "currenciesElement"], "currencies": [" cururrencies", "carurrency", "loccoins", "curales", "urrencies", " curacters", "chales", "charries", "locrencies", "curacters", "charrency", "peracters", " curums", "chrencies", "chcoins", "curcoins", "curversions", "perums", "scheries", "charrencies", "curries", "locales", "cururrencies", "perrencies", "charurrencies", "locurrency", "scherencies", "urums", " curversions", "churrency", "urversions", "carrencies", "cururrency", "curums", "carales", "carcoins", "perversions", "uracters", "scherency", " curries", "scheurrencies", "currency", " currency"], "i": ["qi", "v", "z", "lc", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "index", "eni", "q", "start", "end", "u", "ui", "li", "hi", "multi", "c", "ci", "si", "phi", "ii", "y", "m", "t", "j", "r", "info", "g", "b", "n", "o", "bi", "slice", "ri", "uri", "p", "gi", "it", "fi", "abi", "in", "di", "oi", "l", "chi", "yi", "ji", "mu", "f", "pi"]}}
{"id1": "12869602", "id2": "11154758", "code1": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "code2": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        FileOutputStream fos = null;\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String filename = \"i.exe\";\n            fos = new FileOutputStream(filename);\n            client.retrieveFile(\"/\" + filename, fos);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.close();\n                }\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"test_validate_tag_getTopAlbums": ["test_validate_tag_getTopArtbums", "test_validate_tag_getTopArtbumls", "test_validate_tag_getTopAlgges", "test_validate_tag_getTopArtalbums", "test_validate_tag_getTopAlangls", "test_validate_tag_getTopAlalbums", "test_validate_tag_getTopAlanges", "test_validate_tag_getTopAlango", "test_validate_tag_getTopArtalbumo", "test_validate_tag_getTopAlangs", "test_validate_tag_getTopArtalbumes", "test_validate_tag_getTopAlbumes", "test_validate_tag_getTopAlalbumo", "test_validate_tag_getTopArtbumes", "test_validate_tag_getTopArtbumo", "test_validate_tag_getTopAlbumls", "test_validate_tag_getTopAlggs", "test_validate_tag_getTopArtalbumls", "test_validate_tag_getTopAlbumo", "test_validate_tag_getTopAlalbumls", "test_validate_tag_getTopAlggls", "test_validate_tag_getTopAlggo", "test_validate_tag_getTopAlalbumes"], "factory": ["pault", "dinder", "ifault", "finder", "dictionary", "facault", "affuild", "newictionary", "dactory", "pictionary", "ifuild", "facactory", "newinder", "ifuture", "affactory", "fuild", "fault", "newactory", "dault", "ifactory", "future", "facuture", "pactory", "pinder", "fictionary", "affuture", "facuild", "affault", "newault"], "schemaLocation": ["specmaPath", "schemeLocation", "symalocation", "specbaseFile", "schemlLocation", "schemaPath", "specbaseLocation", "schemasLocation", "symlFile", "schemaslocation", "schebasePosition", "symllocation", "symaFile", "schebaselocation", "specmaLocation", "schemasPosition", "schebaseLocation", "specmaFile", "symaLocation", "schemllocation", "symlLocation", "schemalocation", "schemeFile", "specbasePath", "specmaPosition", "schemasFile", "schebaseFile", "schebasePath", "schemaPosition", "schemasPath", "schemePath", "schemePosition", "schemaFile", "specbasePosition", "schemlFile"], "schema": ["defml", "verme", "mama", "verml", "mamas", "mage", "scheme", "schege", "cheme", "defma", "masge", "masma", "defme", "verma", "chemas", "schemma", "vermas", "cheml", "mamma", "scheml", "masmas", "schemas", "chemma", "chege", "defmas", "chema", "masmma"], "validator": ["Validater", "validoder", "valation", "validater", " validater", " invalidner", "valater", " invalidater", "Validator", "Validation", "validner", " invalidator", " invalider", " validoder", " validner", "valator", "Validoder", "Validner", "validation", " valider", " validation", "Valider", "valider", "valoder"], "url": ["address", "feed", "URL", "path", "xml", "sl", "Url", "host", "location", "stream", "image", "ssl", "connection", "method", "user", "b", "browser", "text", "www", "config", "loc", "buffer", "uri", "date", "resource", "api", "http", "l", "file", "server", "channel", "download", "email", "coll", "web", "f"], "inputStream": [" inputFile", "downStream", "inputSteam", "downSteam", "InputSource", "inputFile", "downSource", "InputPath", " inputPath", " inputSteam", "inputSource", "InputFile", " inputSource", "inputPath", "downForm", "responsePath", "responseStream", "inputForm", "responseFile", "responseSource", "InputSteam", " inputForm", "InputForm", "InputStream"], "source": ["ource", "slave", "result", "reader", "level", "view", "proxy", "model", "scene", "path", "input", "target", "session", "string", "out", "context", "s", "stream", "image", "Source", "format", "connection", "method", "class", "text", "object", "handler", "slice", "ources", "parser", "uri", "service", "resource", "document", "from", "data", "file", "channel", "src", "instance", "SOURCE"]}}
{"id1": "22401746", "id2": "7296597", "code1": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "code2": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"sendRequest": ["processResponse", "submitRequest", " sendrequest", "processObject", "sendrequest", "processrequest", "submitResponse", " sendResponse", " sendObject", "sendResponse", "processRequest", "submitrequest", "submitObject", "sendObject"], "servletName": ["servletsNames", "servlename", "servLETNames", "servleNames", " servleNames", "servLETUrl", "servletsVersion", " servletname", "servlePath", "servletPath", "servletNames", " servletVersion", "servLETPath", "servLETname", " servleUrl", "servletonName", "servletsname", "servletonNames", "servletonVersion", " servletUrl", "servleVersion", " servletNames", "servletsName", "servletsPath", "servletonPath", " servleName", "servletUrl", "servletVersion", "servLETVersion", "servLETName", "servleUrl", " servleVersion", "servletname", " servletPath", " servlePath", " servlename", "servleName", "servletsUrl"], "request": ["text", "python", "message", "method", "create", "buffer", "result", "uri", "json", "path", "hello", "frame", "config", "info", "input", "complete", "req", "data", "q", "object", "resource", "document", "name", "server", "query", "address", "string", "header", "queue", "response", "type", "xml", "Request", "report", "content", "application"], "reqxml": ["reqdocument", " reqdoc", "requestdocument", "Requestxml", "Requestdocument", "requestdoc", "Requestdoc", "requestxml", "reqdoc", " reqdocument"], "retdoc": [" resultdata", "retconf", " resultxml", " resultdoc", "retdata", " retxml", "retxml", " backdoc", " retdata", " backconf", " retconf", " backdata", " resultconf", " backxml"], "myurl": ["yourUrl", "MyUrl", "yourhost", " myURL", "myaddress", "serveraddress", "serverhost", "myURL", "myhost", "serverurl", " myhost", "yourURL", "Myhost", "Myurl", "myUrl", "MyURL", "Myaddress", " myaddress", " myUrl", "yoururl", "youraddress"], "myport": ["yourPort", "someort", "somehost", "myPort", "yourphone", " myphone", "Myport", "MyPORT", "memberurl", " myPORT", "somePort", "yourport", "Myort", "MYport", "serverphone", "myphone", "MYurl", "myhost", "serverurl", " myhost", "myort", "Myhost", "myip", "MYPort", "memberip", "memberPort", "Myurl", "someport", "someurl", " myPort", "serverport", "MYPORT", "serverPort", "MYhost", " myort", "MyPort", "somePORT", "memberport", "someip", "yoururl", "myPORT", "yourip"], "codebase": [" codebas", "CodeBase", "codBase", "codeurl", "codeb", "foreBase", " codeurl", "Codebase", "Codebas", "codebas", "foreurl", "foreb", "codb", "Codeb", "Codeurl", "codeBase", "forebase", "forebas", " codeb", "codbase", " codeBase"], "serverURL": ["remoteURI", "serverBUG", " serverJSON", "localhostURL", "slaveFolder", "localhostUrl", "serverAddress", "localhostDirectory", " serverURI", "siteurl", "erverLevel", " serverID", "myURL", "siteFolder", "serverurl", "myUrl", "erverURL", "remoteURL", "slaveUrl", "serverPage", "erverUrl", "serverLocation", "siteLocation", "testurl", "hostURL", "erverFolder", "testLocation", " serverBUG", "erverurl", "sitePage", "erverDirectory", "siteURI", "databaseURL", "siteID", "remoteUrl", "serverUrl", " serverLocation", "remoteurl", " serverurl", " serverLevel", "erverJSON", "testUrl", "serverLevel", "serverID", "erverPage", "myURI", " serverUrl", "serverDirectory", "hosturl", "siteUrl", "siteDirectory", "testURI", "erverAddress", "databaseURI", "myJSON", "serverURI", "serverFolder", "myID", "slaveURL", "databaseUrl", "hostUrl", "siteURL", "myLevel", "serverJSON", "slaveAddress", "remoteBUG", "testURL", "siteAddress", "localhostPage", "hostURI", "erverBUG"], "ipdig": ["IPdone", " ipgen", "IPplug", "ipcr", "ipcomb", "ipgen", "ppplug", "opcomb", " ipdone", "ppDig", "IPgen", "ppcr", " ipcomb", "ipsdb", " ipdb", " ipDig", "IPdig", "IPcomb", "iddone", " ipdiff", "ipdone", "idDig", "ipsDig", "opdig", "ipsdig", "ppdig", "idplug", "IPdiff", "ipdb", "ipplug", "ipsgen", "opDig", "IPcr", "iddig", " ipplug", "ipdiff", "IPdb", "opdiff", "ipDig", " ipcr", "IPDig"], "url": ["ls", "org", "util", "gl", "uri", "str", "client", "browser", "path", "Url", "update", "config", "f", "page", "event", "l", "conn", "req", "web", "object", "resource", " http", "www", " curl", "class", "name", "log", "server", "host", "URL", "fl", "sl", "connection", "cl", "coll", "ll", "file", "pull", "ssl", "key", "twitter", "user", "rel", "http"], "urlconn": ["httpconn", "flConn", "slclient", " urlclient", "httpconnection", "sslcon", "flconnection", "sslconn", " urlconnection", "webconn", " urlcon", "sslConn", "webcon", " urlconv", "slcon", "flcn", "webclient", "urlConn", "urlconf", "httpconf", "urlcon", "httpcn", "flcon", "urlclient", "llconnection", " urlconf", "httpcon", "llconn", "sslconf", "llcon", " urlcn", "flconn", "httpConn", "webconv", "llConn", "urlconv", "urlcn", "urlconnection", "slconn", " urlConn", "slconv"], "os": ["ls", "OS", "as", "ps", "ot", "so", "oss", "us", "ips", "ds", "pos", "or", "rs", "vs", "io", "ms", "is", "fs", "obj", "bs", "res", "ns", "es", "op", "Os", "o", "ops"], "req1xml": ["req_txt", "req_x", "req_xml", "request2xml", "req2xml", "request2request", "req1txt", "request1txt", "req2request", "request2txt", "req0request", "req2txt", "req2x", "req1request", "req_request", "req1x", "request1request", "req0txt", "request2x", "req0x", "request1x", "req0xml", "request1xml"], "cos": [" bytes", " pos", " cs", "cs", " compress", " socks", " enc", " temp", " iss", " ss", " downloads", " cc", " contents", " dd", "pos", " zipper", "is", " fo", " rc", " tar", " ro", "outs", " outs", " po", " compression", " bos", " repo", " ze"]}}
{"id1": "810342", "id2": "16623181", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionUpdate", " doVersionUpdate", " doversionCheck", "doversionScan", "doversionCheck", "doChangeCheck", "doChangecheck", " doversioncheck", "doChangeUpdate", "doversioncheck", "doVersioncheck", "doFeaturecheck", " doVersionScan", " doversionUpdate", "doversionUpdate", "doFeatureScan", "doVersionScan", "doFeatureCheck", " doversionScan", "doChangeScan", "doFeatureUpdate", " doVersioncheck"], "view": ["v", "cache", "vol", "window", "e", "port", "model", "div", "row", "session", "link", "sel", "box", "show", "query", "display", "form", "server", "fail", "value", "full", "group", "gu", "client", "use", "VIEW", "check", "input", "View", "lock", "event", "user", "object", "video", "block", "views", "vis", "by", "http", "page", "review", "pool", "comment", "can", "cell", "im", "base", "change", "el", "ou", "container", "screen", "body", "head", "config", "list", "index", "out", "ui", "image", "this", "widget", "self", "html", "see", "edit", "layout", "update", "ve", "up", "style", "manager"], "url": ["address", "base", "builder", "rel", "bb", "ob", "id", "zip", "URL", "path", "log", "sl", "Url", "host", "location", "string", "name", "ls", "gl", "stream", "bug", "length", "image", "hub", "link", "ssl", "b", "browser", "null", "ll", "www", "loc", "socket", "loader", "fr", "buffer", "uri", "ul", "resource", "http", "l", "source", "file", "server", "download", "email", "impl", "open", "web", "blog", "f"], "in": ["ins", "reader", "din", "IN", "login", "isin", "inc", "bis", "ini", "input", "out", "In", "binary", "s", "inner", "stream", "err", "doc", "m", "b", "again", "sin", "socket", "nin", "win", "buffer", "resource", "inn", "pin", "is", "cin", "lin", "data", "file", "source", "init", "rin", "con", "ac", "as"], "bin": ["bn", "gin", "reader", "din", "IN", "login", "bb", "nb", "vin", "spin", "ini", "input", "border", "out", "binary", "fin", "inner", "lock", "bot", "ruby", "lib", "oin", "ban", "b", "browser", "body", "sin", "socket", "loader", "win", "buffer", "inn", "pin", "abi", "arin", "cin", "lin", "is", "file", "init", "con", "record", "bi", "run"], "line": ["lc", "cl", "base", "ip", "job", "str", "parse", "el", "e", "id", "zip", "one", "log", "le", "val", "ge", "row", "nl", "sl", "string", "name", "end", "Line", "out", "lines", "range", "word", "write", "link", "code", "LINE", "look", "type", "pe", "definition", "b", "user", "text", "object", "block", "pin", "key", "jo", "lf", "lin", "data", "file", "page", "l", "entry", "inline", "up", "letter", "unit", "ine", "part", "comment", "cell"], "version": ["feature", "position", "v", "ver", "project", "beta", "id", "cover", "model", "plugin", "python", "patch", "host", "string", "name", "bug", "driver", "section", "image", "code", "format", "vision", "type", "release", "user", "Version", "null", "video", "latest", "pull", "install", "update", "support", "license", "date", "option", "vert", "versions", "server", "download", "VERSION", "secret", "device", "value", "dev", "unit", "author"], "build": ["uild", "ver", "job", "builder", "rel", "follow", "clean", "use", "feed", "load", "valid", "log", "boot", "make", "row", "patch", "hold", "Build", "bug", "lock", "image", "link", "lease", "info", "print", "release", "show", "tag", "built", "pull", "block", "install", "building", "update", "post", "mount", "how", "add", "get", "http", "work", "style", "help", "home", "unit", "run"]}}
{"id1": "17996547", "id2": "11334468", "code1": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", " copyfile", "copySourceFile", "opyfile", "copFiles", "opyFile", " copySourceFile", "copyFiles", "copyfile", "copfile", "copFile", "opySourceFile", "opyFiles", "copSourceFile"], "fileToCopy": ["fileWillCreate", "FileToCopy", "FileWillCreate", "filePleaseCopy", "fileToCop", "FiletoCreate", "FiletoCopy", "fileWillSample", "FileWillDelete", "filetoCreate", "FileToWrite", "filetoCopy", "fileToWrite", "fileSyncCreate", "FileWillCopy", "filetoSample", "FiletoWrite", "fileSyncCop", "fileToDelete", "filePleaseCreate", "FiletoCop", "fileToCreate", "filetoCop", "FileToSample", "fileSyncCopy", "FileToCop", "filetoWrite", "FileToDelete", "fileTOWrite", "FileToCreate", "fileWillDelete", "filetoDelete", "fileTOCop", "fileSyncWrite", "FileWillSample", "fileToSample", "filePleaseDelete", "filePleaseSample", "fileTOCreate", "fileWillCopy", "fileTOCopy"], "copiedFile": ["coppedPage", "copyingDirectory", "coiedFile", "copiedFolder", "copyingFile", "copiedHeader", "CopiedFiles", "CopcedFile", "copppedUrl", "CopedFiles", "copieFile", " copiedfile", "CopiedDir", "coppedFrame", "copcedF", "coiedFrame", "copiedUnit", "copcedDirectory", "copieF", "copppedFrame", " copieFile", "coippedDir", " copieF", "copotedDirectory", "copodedfile", "copedFiles", "CopcedPage", " copiefile", "copixedUrl", "copippedFile", "copedPage", "coippedDirectory", "copppedFile", "copiedDirectory", " copieFolder", "coippedFile", "coppedUnit", "copcedfile", "copiedDir", "copicedHeader", "copixedFrame", "copotedDir", "copcedFolder", "copcedPage", "copiedFrame", "coiedUnit", "copicedFile", "copixedUnit", "CopedDir", "copippedPlace", "copippedDirectory", "coippedPlace", "copriedFrame", "coiedDirectory", "coiedUrl", "CopiedHeader", "copippedFiles", "copotedFile", "copriedUnit", "copiedUrl", "copotedPlace", "copppedUnit", "copicedDirectory", "copippedPage", "CopiedFile", "CopedFile", "copodedFile", "coiedPlace", "copyingHeader", "coiedDir", "copedDirectory", "copicedPage", "copippedDir", "copedDir", "coppedUrl", "copriedUrl", "copiedfile", "copiedPage", "CopiedPage", "copieFolder", "copiedPlace", "CopcedHeader", "copyingPage", "CopedPage", "copedFile", "coppedFiles", "copiedFiles", "CopiedDirectory", " copiedFolder", "copedPlace", " copiedF", "copodedFolder", "copriedFile", "copiefile", "copcedHeader", "copiedF", "coppedFile", "copodedF", "copcedFile", "CopcedDirectory", "coppedDir", "copixedFile"], "in": ["r", "image", "m", "pin", "inn", "fa", "gin", "isin", "i", "zin", "socket", "s", "init", "cin", "impl", "input", "e", "copy", "din", "conn", "lin", "connection", "cgi", "a", "inner", "vin", "nin", "ssl", "out", "con", "ini", "into", "inside", "url", "login", "ac", "err", "b", "oin", "it", "ins", "pc", "bin", "In", "reader", "IN", "as", "again", "lock", "win", "source", "inc"], "outWriter": ["OutWs", " outBuffer", "outWs", "newWrite", "outStream", "outReader", "outWalker", "newWriter", "inWrite", "againBuffer", "outputStream", "newReader", " outWrite", "outWrite", "inWriter", "againStream", "againFile", "outputWrite", "outputReader", "outputWriter", "inReader", " outStream", "outputWs", " outWs", " outFile", "againWrite", "newStream", "OutFile", "againWriter", "OutWalker", " outReader", "OutWrite", "outputWalker", "OutBuffer", "outFile", "outBuffer", "againWalker", "OutReader", " outWalker", "OutStream", "OutWriter", "inStream"], "c": ["r", "C", "sc", "m", "p", "n", "cp", "i", "ce", "rc", "cc", "cell", "character", "dec", "e", "cr", "cy", "ci", "lc", "cf", "t", "cu", "code", "bc", "pointer", "dc", "oc", "cm", "xc", "esc", "x", "f", "col", "ch", "o", "enc", "k", "ac", "u", "b", "arc", "char", "cl", "ct", "pc", "l", "d", "ec"]}}
{"id1": "6271502", "id2": "18570190", "code1": "    @Override\n    public InputStream getResourceByClassName(String className) {\n        URL url = resourceFetcher.getResource(\"/fisce_scripts/\" + className + \".class\");\n        if (url == null) {\n            return null;\n        } else {\n            try {\n                return url.openStream();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"getResourceByClassName": ["getResourceForclassname", "getResourceByFileName", "getResourceForclassString", "getResourceByclassString", "getResourceByFilename", "getResourceByFileString", "getResourceByclassname", "getResourceForClassString", "getResourceByClassname", "getResourceByClassString", "getResourceForClassname", "getResourceByclassName", "getResourceForClassName", "getResourceForclassName"], "className": ["ClassType", "ClassPath", "scriptName", "classname", "scriptPath", "scriptType", "shortname", " classType", " classname", "classPath", "shortName", "scriptname", "shortTitle", "classTitle", " classTitle", "ClassName", "classType", " classPath", "Classname", "shortPath", "ClassTitle"], "url": ["address", "base", "job", "rel", "str", "ob", "window", "e", "el", "zip", "feed", "URL", "path", "xml", "log", "sl", "Url", "location", "string", "name", "ls", "image", "orb", "resources", "org", "event", "ssl", "element", "class", "b", "object", "www", "loader", "buffer", "lr", "service", "resource", "api", "bel", "uri", "http", "plug", "l", "page", "source", "file", "server", "data", "ref", "instance", "coll", "impl", "web", "rl", "f"]}}
{"id1": "5148212", "id2": "23088292", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "code2": "    private void Submit2URL(URL url) throws Exception {\n        HttpURLConnection urlc = null;\n        try {\n            urlc = (HttpURLConnection) url.openConnection();\n            urlc.setRequestMethod(\"GET\");\n            urlc.setDoOutput(true);\n            urlc.setDoInput(true);\n            urlc.setUseCaches(false);\n            urlc.setAllowUserInteraction(false);\n            if (urlc.getResponseCode() != 200) {\n                InputStream in = null;\n                Reader reader = null;\n                try {\n                    in = urlc.getInputStream();\n                    reader = new InputStreamReader(in, \"UTF-8\");\n                    int read = 0;\n                    char[] buf = new char[1024];\n                    String error = null;\n                    while ((read = reader.read(buf)) >= 0) {\n                        if (error == null) error = new String(buf, 0, read); else error += new String(buf, 0, read);\n                    }\n                    throw new NpsException(error, ErrorHelper.SYS_UNKOWN);\n                } finally {\n                    if (reader != null) try {\n                        reader.close();\n                    } catch (Exception e1) {\n                    }\n                    if (in != null) try {\n                        in.close();\n                    } catch (Exception e1) {\n                    }\n                }\n            }\n        } finally {\n            if (urlc != null) try {\n                urlc.disconnect();\n            } catch (Exception e1) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "createfile", " copyFiles", "transferFile", "createFiles", "copyfile", "createFile", "transferFiles", "copyFiles", "transferDir", " copyDir", "copyDir", "createDir", "transferfile"], "src": ["resource", "cdn", "project", "href", "view", "http", "dist", "proxy", "input", "ource", "path", "sc", "slice", "download", "impl", "archive", "loc", "ie", "l", "gb", "s", "rc", "upload", "url", "config", "loader", "name", "sl", "sb", "gz", "filename", "image", "fp", "remote", "RC", "img", "obj", "req", "r", "source", "stream", "uri", "rb", "file", "ref"], "dest": ["dc", "folder", "cdn", "temp", "done", "txt", "route", "project", "front", "zip", "rest", "dat", "opt", "exp", "dist", "d", "master", "destroy", "dep", " Dest", "desc", "di", "path", "slice", "this", "doc", "wd", "dir", "archive", "loc", "p", "comb", "trans", "orig", "tmp", "url", "delete", "du", "config", "flat", "home", "filename", "Dest", "v", "img", "output", "data", "obj", "style", "target", "b", " destination", "de", "null", "id", "parent", "source", "wb", "name", "later", "file", "origin"], "bufSize": ["buffsize", " bufCount", "buffSize", " bufLen", "bufferSize", "buffName", "bufLen", "buffLen", "bufName", "ufName", "bufferLen", "ufCount", "bufCount", "ufLen", "buffersize", "bufferCount", " bufsize", "bufsize", "buffCount", "ufsize", "ufSize", "bufferName"], "force": ["pull", "route", "cop", "keep", "use", "enable", "send", "effect", "act", "front", "cache", "want", "false", "dirty", "push", "orce", "service", "forces", "delay", "only", "die", "sync", "ignore", "child", "count", "play", "store", "err", "fix", "replace", "load", "like", "forcing", "allow", "auto", "close", "ride", "remote", "apply", "secure", "write", "require", "forced", "style", "flush", "hard", "parent", "deep", "Force", "reason", "file", "kill"], "f": ["folder", "df", "fe", "F", "fc", "u", "n", "c", "cache", "m", "g", "o", "d", "fx", "self", "path", "fd", "feed", "dir", "fn", "p", "fs", "l", "ff", "w", "s", "base", "j", "e", "fm", "i", "uf", "h", "fp", "v", "r", "b", "fb", "t", "bf", "file", "rf"], "buffer": ["resource", "seed", "position", "cache", "uffer", "limit", "bin", "input", "wave", "sequence", "feed", "buf", "queue", "slice", "number", "pad", "length", "batch", "base", "url", "size", "Buffer", "iter", "value", "bytes", "transfer", "page", "result", "bb", "reader", "border", "data", "write", "raw", "null", "b", "buff", "flush", "message", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", " Read", "use", "ip", "send", "n", "k", " write", "c", "reading", "fill", "view", "select", "sleep", "input", "copy", "READ", "lex", "io", "open", "feed", "add", "key", "text", "sync", "skip", "length", "count", "build", "play", "Read", "ad", "seek", "show", "rate", "exec", "find", "get", "load", "x", "wait", "size", "index", "max", "iter", "len", "i", "ink", "ok", "ind", "set", "start", "check", "reader", "se", "data", "write", "raw", "parse", "r", "inc", "id", "connect", "block", "end"], "in": ["In", "pull", "pass", "or", "token", "again", "ini", "c", "n", "IN", "m", "cin", "ex", "request", "inner", "din", "bin", "input", "as", "con", "pin", "ins", "ac", "on", "conn", "child", "inn", "download", "impl", "p", "err", "kin", "up", "l", "connection", "init", "s", "win", "rin", "lin", "url", "gin", "thin", "i", "nin", "a", "socket", "login", "reader", "ax", "r", "b", "inc", "id", "source", "client", "re"], "out": ["pass", "plus", "line", "again", "n", "c", "cache", "o", "exp", "ex", "inner", "bin", "Out", "sum", "log", "outer", "io", "outs", "co", "sync", "conn", "object", "user", "cookie", "err", "up", "connection", "net", "w", "init", "exec", "server", "gin", "name", "other", "off", "nin", "image", "lib", "socket", "writer", "to", "plain", "ne", "v", "ext", "output", "data", "write", "obj", "OUT", "null", "b", "error", "inc", "id", "parent", "client", "one"]}}
{"id1": "4223002", "id2": "21152728", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getpasswordSHA1", "getPasswordMD1", "getpasswordMD512", "getPasswordMD256", "getPasswordMAC256", "getPasswordMAC5", "getpasswordMD1", "getPasswordMac256", "getPasswordMac1", "getPasswordSHA5", "getPasswordSHA512", "getPasswordMAC1", "getpasswordMD256", "getPasswordMAC512", "getPasswordMac5", "getPasswordMac512", "getpasswordMD5", "getPasswordSHA256", "getpasswordSHA5", "getpasswordSHA512", "getpasswordSHA256", "getPasswordMD512", "getPasswordSHA1"], "algorithm": ["aggorithm", "geest", "gem", " alm", "alrator", "algo", "Alignment", " alger", " alignment", " algo", " alrator", "alest", "alger", "calgorith", "Alm", "calgo", "Alrator", "calgebra", "algebra", "Alest", " alest", "gegorithm", "Alphabet", "Algorith", "alphabet", "agrator", "Alger", "Algorithm", "fgo", "fgebra", "omalgorith", "omalgo", "aggo", "alignment", "calgorithm", "omalgorithm", "algorith", "geger", "Algo", "agignment", "omalphabet", "alm", " algorith", " alphabet", "fgorithm", "fgorith", "Algebra"], "messageDigest": ["messageModester", "MessageDigEST", "MessageDigest", "phrasedigester", "phrasedigest", "phraseDigEST", "messageMDester", "messageDigested", "messageModEST", "messagedigest", " messagedigEST", " messagedigString", "messageMDest", "messageDest", "messagedigester", "messagedigString", "messageDEST", " messageDigString", "messageMDString", "messagedigested", " messageDigester", "messageModest", "messageDigString", "MessageModester", "messageModested", "phraseDigester", "MessageModest", " messageDigEST", "messageModString", "messagedigEST", "MessageModested", "messageDested", " messagedigest", "phraseDigest", "phrasedigested", "phraseDigested", " messagedigester", "MessageDigester", "phrasedigEST", "messageDigEST", "MessageDigested", "messageDester", "MessageModEST", "messageMDEST", "messageDigester"], "hexString": [" hexFunction", "hexLine", "textStream", "hashStr", " hexstring", "hexBuffer", "textString", "textstring", "hexstring", "byteLine", " hexStr", "shortArray", "textLine", "shortString", "hexArray", "hexStr", "hashString", "checkFunction", "hexStream", " hexArray", "shortstring", "textArray", "shortBuffer", "byteStream", "hashBuffer", "hexFunction", "checkStr", " hexStream", "byteString", "checkString", "checkBuffer", "textBuffer", "hashFunction", " hexBuffer", " hexLine", "byteArray"], "i": ["m", "u", "uri", "e", "j", "b", "volume", "n", "fi", "io", "info", "ix", "si", "in", "f", "o", "index", "d", "end", "key", "h", "type", "s", "ci", "oi", "abi", "multi", "li", "a", "l", "di", "hi", "pi", "xi", "mi", "slice", "r", "id", "ti", "v", "gi", "c", "t", "ri", "I", "ai", "phi", "zi", "ii", "ui", "x", "bi", "chi", "mu", "p"]}}
{"id1": "20991673", "id2": "15904772", "code1": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 1, "substitutes": {"generateTopicId": ["generateTopicID", "generatetopicId", "generateTopicInfo", "generatedTopicID", "generatedtopicName", "generateTopicName", "generateTopicsId", "generateTopicsInfo", "generatedtopicInfo", "generatetopicID", "generatetopicInfo", "generatedTopicName", "generatedTopicInfo", "generateTopicsName", "generatedtopicID", "generatetopicName", "generatedTopicId", "generatedtopicId", "generateTopicsID"], "topicName": ["TopicKey", "subjectId", " topicId", "TopicName", "channelKey", "TopicInfo", "topicType", " topicPath", " topicKey", "Topicname", "topicKey", "topicId", "topId", "topName", " topicNames", "TopicNames", "channelId", "TopicId", "topicname", "channelType", "channelName", "subjectName", "subjectType", " topicname", "channelPath", " topicType", " topicInfo", "topname", "topNames", "subjectPath", "topicNames", "topicInfo", "topicPath", "channelInfo"], "md": ["dd", "sha", "cmd", "dr", "meta", "ud", "dc", "am", "dig", "metadata", "ma", "amd", " MD", "po", "hd", "mm", "mo", "ms", "ld", "mp", "vd", "km", "hash", "d", "mand", "bd", "ad", "pm", "df", "sm", "mg", "mac", "mt", "gd", "od", "editor", "cm", "MD", "Cmd", "id", "dh", "pd", "mag", "rm", "dm", "mc", "pkg", "mb", "m"], "digest": ["dighed", "mdested", "dhed", "Diggest", "diggest", "DigEST", "mdest", " diggest", " dighed", "signEST", "digester", "Digests", "cdEST", "dester", "decest", "mdhed", "signests", "Digester", "decEST", "dest", "digests", "mdester", "signest", "cdgest", "digested", "digEST", " digEST", "dested", " digested", "decests", "cdest", "Digest", "cdester", " digester"], "newId": ["nextid", "NewId", " newID", "Newid", "nextId", " newid", "NewInfo", " newInfo", "newInfo", "nextID", "newID", "NewID", "nextInfo", "newid"]}}
{"id1": "10728243", "id2": "20100809", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"scramble411": ["scramprint411", "screamprint411", "screamble123", "screamprint41", "screamble5", "screamprint123", "screamprint5", "scramble5", "scramble41", "scramcy41", "scramprint5", "scramprint123", "screamble411", "scrambe5", "scramcy123", "scramble123", "scrambe41", "scramcy5", "scrambe123", "screamble41", "scrambe411", "scramprint41", "scramcy411"], "password": ["wallet", "name", "channel", "email", "wd", "sudo", "words", "user", "Password", "mac", "account", "key", "address", "secret", "crypt", "padding", "sword", "project", "phrase", "PASS", "hash", "path", "filename", "attribute", "sum", "config", "number", "pass", "dh", "word", "prefix", "token", "input", "pad", "security", "auth", "string", "username"], "seed": ["offset", "volume", "Salt", "finger", "name", "machine", "slice", "pair", "state", "mode", "sudo", "text", "size", "zip", "alias", "key", "random", "address", "secret", "crypt", "padding", "source", "template", "driver", "phrase", "hash", "pattern", "prime", "sum", "pass", "shadow", "id", "prefix", "eed", "token", "pad", "length", "string", "device", "username"], "md": [" Md", "bm", "meta", "df", "bd", "vd", "doc", "mag", "mg", "cd", "addr", "rm", "wd", "ds", "grad", "mad", "dd", "m", "ma", " MD", "mt", "mode", "ind", "ld", "kg", "dig", "di", "mid", "om", "mb", "ht", "am", "part", "mac", "hm", "cmd", "dm", "mn", "sm", "d", "dc", "MD", "km", "gd", "mo", "diff", "amd", "mi", "mp", "metadata", "mm", "pm", "dh", "sha", "po", "cm", "mem", "mc", "nd", "ms", "pd", "mand", "ad", "od", "hd", "nm", "Cmd", "pkg"], "passwordHashStage1": ["passwordSumStage1", "passwordSumPhase1", "passwordHashPhaseOne", "passwordSumStage0", "passwordHashstage3", "passwordHashstage4", "passwordHashstage0", "passwordSumStage4", "passwordSumPhase2", "passwordSumPhase4", "passwordHashPhase0", "passwordHashPhase4", "passwordHashStageOne", "passwordSumStage3", "passwordHashStep3", "passwordHashStep1", "passwordHashStep2", "passwordSumPhase3", "passwordHashstage2", "passwordSumStage2", "passwordHashstage1", "passwordSumPhaseOne", "passwordSumPhase0", "passwordHashPhase1", "passwordHashPhase2", "passwordHashPhase3", "passwordHashStage4", "passwordHashstageOne", "passwordSumStageOne", "passwordHashStage3", "passwordHashStage0"], "passwordHashStage2": ["passwordHashStage02", "passwordSumStage1", "passwordSumPhase1", "passwordSumStageTwo", "passwordHashStage8", "passwordBlockStage1", "passwordBlockStage4", "passwordBlockstage4", "passwordHashstage8", "passwordBlockstage2", "passwordHashstage4", "passwordBlockStage8", "passwordHashStep4", "passwordSumPhase2", "passwordSumStage02", "passwordHashPhase8", "passwordHashStageTwo", "passwordHashPhase02", "passwordHashPhase4", "passwordBlockStage2", "passwordHashstage02", "passwordHashstageTwo", "passwordHashStep1", "passwordHashStep2", "passwordHashstage2", "passwordSumStage2", "passwordHashstage1", "passwordHashPhaseTwo", "passwordBlockstage1", "passwordHashPhase1", "passwordHashStep8", "passwordSumPhaseTwo", "passwordHashPhase2", "passwordBlockstage8", "passwordHashStage4", "passwordSumPhase02"], "toBeXord": ["tobeXorder", "toBeCrossor", "toBeZorder", "toBeWorkors", "tobeYors", "toBeXords", "toBEYord", "toBeXor", "toBeXors", "toBeZors", "toBEYORD", "toBeCrossords", "toBeZor", "toBEXords", "toBeYorder", "tobeXords", "tobeYorder", "toBeWorkord", "toBEXORD", "toBEYor", "toBeXorder", "toBeCrossord", "toBeYord", "tobeYord", "tobeXors", "tobeXord", "tobeCrossords", "toBEXord", "tobeCrossor", "toBeWorkords", "toBeXORD", "toBeYors", "toBeWorkORD", "toBeCrossors", "tobeCrossord", "tobeYor", "toBeZORD", "toBeWorkorder", "toBeYor", "toBeYords", "toBeCrossORD", "toBEYords", "toBeWorkor", "toBeZords", "toBEXor", "tobeXor", "tobeCrossors", "toBeZord", "toBeYORD"], "numToXor": ["numToXors", "numToXOr", "numToCrossOr", "num2XOr", "numToxOR", "numToWorkOR", "numToAbsorer", "numtoXors", "numtoxorer", "numToXOR", "num2Xorer", "numToAbsor", "numtoxor", "numToxors", "numToAnyOR", "numtoxOR", "numToAbsOR", "num2AbsOr", "num2XOR", "numtoxors", "numToAnyorer", "numToWorkors", "numToXorer", "numToWorkor", "num2AbsOR", "numToWorkorer", "numToCrossor", "numToCrossors", "numtoXorer", "numtoXOR", "numToxor", "numToAnyOr", "numToCrossorer", "num2Xor", "numToxorer", "numToAbsOr", "num2Absorer", "numToAnyor", "num2Absor", "numtoXor", "numToCrossOR"], "i": ["x", "f", "y", "si", "it", "ti", "ri", "slice", "m", "p", "j", "info", "pi", "k", "ix", "hi", "I", "di", "u", "b", "part", "multi", "bi", "qi", "l", "r", "e", "o", "key", "off", "abi", "d", "ci", "z", "t", "h", "xi", "v", "oi", "ui", "li", "uri", "n", "ii", "io", "c", "in", "id", "index", "chi", "a", "ai", "gi", "ip"]}}
{"id1": "949327", "id2": "8079516", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"f": ["fa", "df", "folder", "fe", "ref", "fr", "F", "fc", "function", "of", "g", "c", "n", "m", "sf", "d", "fo", "fun", "fx", "self", "path", "fd", "io", "feed", "this", "cf", "fold", "fn", "p", "fs", "l", "ff", "tf", "s", "w", "j", "x", "fi", "flat", "e", "fm", "filename", "a", "h", "fp", "inf", "v", "fen", "r", "b", "bf", "t", "lf", "form", "name", "file", "rf"], "in": ["fe", "again", "serv", "g", "ini", "m", "cin", "ex", "with", "con", "inn", "p", "l", "isin", "w", "rin", "nin", "image", "socket", "v", "ssl", "gen", "t", "fa", "In", "or", "c", "rec", "d", "str", "bin", "ic", "pin", "connection", "init", "win", "login", "data", "n", "IN", "din", "ins", "ac", "min", "part", "lin", "get", "thin", "reader", "diff", "r", "lock", "pass", "token", "is", "inner", "input", "err", "it", "up", "exec", "gin", "config", "session", "a", "vin", "b", "inc", "source"], "cbuf": ["fbuff", "ebuf", "cfur", "zbuu", "rbull", "cbur", "cfuf", "cbuff", "bbuff", "bcuf", "rbuc", "cbutf", "fbbuf", "cfuff", "fbuc", "bcull", "fbuf", "bbull", "cbuc", "cburs", "cbault", "cfuc", "cbbuf", "cfbuf", "bcul", "rbuu", "rbul", "buf", "cbul", "bburs", "CBuc", "CBuff", "cbull", "bcuc", "CBul", "CBuf", "dbuf", "rbutf", "zbuf", "cbuu", "bcur", "bault", "rburs", "rbux", "ebuff", "ebutf", "zbutf", "rbuf", "zbuff", "cbux", "rbault", "rbbuf", "bbuf", "bcux", "ebuu", "dbuc", "dbur", "bux", "buff", "bcault", "dbuff", "rbuff", "bcurs", "bcuff"], "read": ["each", " Read", "use", "draw", "full", "g", "want", "call", "view", "log", "ak", "count", "build", "valid", "oct", "w", "orig", "ink", "q", "start", "check", "socket", "val", "error", "write", "sleep", "text", "y", "select", "d", "report", "lex", "io", " reading", "feed", "add", "only", "hex", "length", "repeat", "play", "pe", "find", "x", "wait", "iter", "allow", "used", "record", "last", "data", "en", "stream", "connect", "cel", "re", "end", "reads", "send", "know", "old", "open", "sync", "skip", "num", "ed", "seek", "ing", "er", "print", "insert", "rc", "get", "load", "work", "size", "index", "ok", "level", "reader", "type", "parse", "raw", "r", "id", "loop", "name", "ize", "pass", "run", "k", "readable", " write", "reading", "fill", "input", "READ", "key", "bit", " READ", "child", "ack", "Read", "it", "config", "ind", "bind", "un", "close", "ride", "change", "se", "put", "inc", "buffer", "update", "create"], "totRead": ["totoRead", "totaRead", " totBuild", "TottRead", "tottLength", "TottLoad", "dotReader", "towWrite", " totWrite", "totClose", "tetRead", "dottWrite", "totoReading", "dotUse", "tobyUse", "tazonClose", "totLoad", " totalBuild", "TottWrite", "tottedRead", "tochWrite", "toyRead", "tcotRead", "TotaDraw", "tottDraw", "ntottReader", "toyLoad", "totiRead", "totalLink", "tottAccept", "nottWrite", "tottBuild", "dottReader", "tcotClose", "tollWrite", "totReader", "TottConnect", "totaBuild", "tochLoad", "totaDraw", "totoSearch", "ntottLoad", "tntLoad", "TotReading", "totConnect", "tochRead", "totReading", "totiLink", "intotRead", "tobyRead", "intotLoad", "TottGet", "tollReading", " totLink", "nottAccept", "tetLoad", "totSearch", "tollRead", "totingFollow", "tottedGet", "tottFollow", "totoWrite", "TottReader", "tobyLoad", "TottReading", "totaLoad", "tntReader", "tobyFind", "intottLoad", "totBuild", "tetWrite", "TotGet", "TotLoad", "toyWrite", "dottLoad", "totaWrite", "totalWrite", "totalBuild", "totoLength", "totWrite", "notRead", "tottReading", "tottSearch", "octotLength", "totingSearch", "totingGet", "towReading", "TotConnect", "totingRead", "intottClose", "tcotBuild", "TotaRead", "dotReading", "TotSearch", "totLength", "tottedFollow", "totaReading", "tottWrite", "notAccept", "totiWrite", "dottFind", "tottRead", "totUse", "totoLoad", "totaLink", "totoConnect", "tochReader", "tatRead", "intottBuild", "TotWrite", "tetReading", "tottLoad", "totaReader", "totoFind", "tazonLoad", "TotaWrite", "TotRead", "octotoWrite", "tottFind", "totiBuild", "octotReading", "tottClose", "dotLoad", "TotaLoad", "towLength", "tatReader", "ntotWrite", "dottRead", "ntotReader", "totGet", "octotoRead", "towAccept", "octotWrite", "toyDraw", "TotFollow", "tntRead", "tatLoad", "tottGet", "dotRead", "totFind", "totingWrite", "tottReader", "dotWrite", "TottSearch", "totingConnect", "nottRead", "totAccept", "intottRead", "TotDraw", "ntottWrite", "towLoad", "tottUse", "ntotRead", "tottedWrite", "TotReader", "dottUse", "octotoReading", "totDraw", "towRead", "totalRead", " totalRead", "intotClose", "intotBuild", "tazonBuild", "ntottRead", "dotFind", "tatWrite", "dottReading", "tntWrite", "totLink", "totalLoad", "TottFollow", "totoUse", "octotoLength", "octotRead", "tcotLoad", " totalLink", "tazonRead", "notLoad", "ntotLoad", "totalAccept", "tollLoad", "notWrite", " totalWrite", "totFollow", "tottConnect", "nottLoad"], "out": ["In", "plus", "again", "n", "c", "g", "o", "ex", "exp", "d", "bin", "Out", "outer", "io", "outs", "sync", "ac", "conn", "fn", "p", "err", "up", "l", "part", "w", "s", "net", "init", "connection", "exec", "x", "off", "a", "h", "writer", "socket", "v", "ext", "output", "obj", "OUT", "r", "b", "t", "inc", "conf", "parent", "client", "file"], "i": ["hi", "ini", "ii", "g", "m", "current", "ci", "z", "bi", "my", "p", "l", "phi", "eni", "q", "start", "gi", "v", "ai", "yi", "uri", "iu", "c", "y", "o", "d", "ic", "io", "slice", "ji", "length", "init", "fi", "x", "ori", "ni", "ti", "data", "mi", "ik", "one", "chi", "multi", "pi", "abi", "di", "ei", "ie", "j", "I", "index", "oi", "li", "h", "r", "zi", "xi", "id", "name", "si", "qi", "ip", "u", "k", "ix", "is", "input", "api", "key", "ui", "ri", "it", "e", "ind", "b", "info", "buffer", "source", "me"]}}
{"id1": "1421557", "id2": "8328527", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void insertJobLog(String userId, String[] checkId, String checkType, String objType) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preStm = null;\n        String sql = \"insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)\";\n        String cleanSql = \"delete from COFFICE_JOBLOG_CHECKAUTH where \" + \"user_id = '\" + userId + \"' and check_type = '\" + checkType + \"' and obj_type = '\" + objType + \"'\";\n        try {\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            preStm = connection.prepareStatement(cleanSql);\n            int dCount = preStm.executeUpdate();\n            String sHaveIns = \",\";\n            preStm = connection.prepareStatement(sql);\n            for (int j = 0; j < checkId.length; j++) {\n                if (sHaveIns.indexOf(\",\" + checkId[j] + \",\") < 0) {\n                    preStm.setInt(1, Integer.parseInt(userId));\n                    preStm.setInt(2, Integer.parseInt(checkId[j]));\n                    preStm.setInt(3, Integer.parseInt(checkType));\n                    preStm.setInt(4, Integer.parseInt(objType));\n                    preStm.executeUpdate();\n                    sHaveIns += checkId[j] + \",\";\n                }\n            }\n            connection.commit();\n        } catch (Exception ex) {\n            log.debug((new Date().toString()) + \" \ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\u0228\ufffd\ufffd\u02a7\ufffd\ufffd! \");\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                throw e;\n            }\n            throw ex;\n        } finally {\n            close(null, null, preStm, connection, dbo);\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeString2File", "encodeFileFromStream", "encodeFileFromString", "encodeStringToStream", "encodeString2Files", "encodeFiletoStream", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileFromFiles", "encodeFileFromFile", "encodeString2Stream", "encodeStringToString", "encodeFileToString", "encodeFile2String", "encodeString2String", "encodeFile2File", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFile2Files", "encodeFileToStream"], "infile": [" infilename", "infiles", "Infilename", "outFile", "inputfile", "outfiles", "inFile", "InFile", "inputfilename", " infiles", " infp", "inputFile", "outfilename", "outfp", "Infiles", "inputfiles", "infp", "inputfp", "infilename", "Infile"], "outfile": ["newfolder", "outname", "outFile", " outFile", "outputfp", "outputfilename", " outfilename", "Outname", "outfolder", "outputfolder", " outfp", "Outfolder", "newfile", "newname", " outfolder", "infolder", "newFile", "outfilename", "outfp", "outputfile", "OutFile", "infp", " outname", "infilename", "Outfile"], "in": ["re", "err", "ini", "image", "base", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "vin", "m", "din", "socket", "inc", "s"], "out": ["err", "ou", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "In", "obj", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "outs", "work", "job", "source", "line", "io", "Out", "client", "off", "name", "co", "on", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "count", "cache", "slice", "queue", "b", "bytes", "bb", "null", "buf", "buff", "border", "padding", "fb", "split", "uffer", "type", "result", "len", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "input", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "close", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "model", "method", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "respons", "open", "better", "message", "growth", "modified", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "693636", "id2": "12417893", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"createEmptyCart": ["createNewShipping", " createEmptySpot", " createEmptycart", "createEmptycart", "createNewCart", "createNewSpot", " createNewSpot", "createNewcart", "createCreatecart", "createCreateSpot", "createCreateCart", "createTempSpot", " createNewShipping", "createTempCart", "createTempcart", " createNewCart", "createEmptyShipping", " createNewcart", " createEmptyShipping", "createEmptySpot", "createCreateShipping", "createTempShipping"], "SHOPPING_ID": ["SHOPPIPIDIDS", "SHOPPIP_ID", "SHOPPIPIDid", "SHOPPINGPOIDs", "SHOPPINGIDIDs", "SHOPPING_IDS", "SHOPPING_IDs", "SHOPPIP_id", "SHOPPINGIDid", "SHOPPTING_id", "SHOPPINGPOId", "SHOPPINGPOID", "SHOPPIP_IDS", "SHOPPYING_ID", "SHOPPINGINGId", "SHOPPYING_IDS", "SHOPPINGIDId", "SHOPPIP_Id", "SHOPPINGINGid", "SHOPPYING_Id", "SHOPPTING_Id", "SHOPPIPIDId", "SHOPPIPIDIDs", "SHOPPTING_ID", "SHOPPINGPOIDS", "SHOPPING_id", "SHOPPIP_IDs", "SHOPPING_Id", "SHOPPYING_IDs", "SHOPPIPIDID", "SHOPPINGIDIDS", "SHOPPINGINGID", "SHOPPINGIDID"], "con": ["exec", "bc", "cm", "cf", "mc", "client", "ca", "uc", "ann", "can", "cache", "com", "un", "ran", "reg", "inc", "cur", "db", "wan", "log", "row", "connect", "session", "conn", "conv", "cr", "c", "ci", "cc", "fa", "en", "ec", "connection", "ex", "pen", "co", "fc", "loc", "Con", "win", "cond", "close", "cas", "CON", "rc", "commit", "col", "pool", "act", "cn", "coll", "pc", "ac", "Conn", "cons", "ctrl", "conf", "ctx", "fac"], "insert_cart": ["insert_pod", "insert_container", "install_container", "insert_center", "exec_Cart", "insertencycle", " insert_center", "insert_ox", "insertencart", "insert_payment", " insert_pod", "insertencat", "exec_payment", "insertencenter", " insert_cat", "exec_cart", "insert_conn", " insert_ox", "insert_part", " insert_conn", "install_part", "install_cart", " insert_cycle", "insert_cycle", "insert_cat", "insert_Cart"]}}
{"id1": "4599372", "id2": "8788371", "code1": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readFixString": ["readAdjustArray", "createFixedstring", "readfixContent", "readFixedString", "readfixstring", "readFixContent", "readFixedstring", "createFixArray", "createFixString", "createFixContent", "createFixedContent", "readfixString", "readFixedContent", "createFixstring", "readAdjustContent", "readAdjustString", "createFixedString", "readFixArray", "readAdjuststring", "readFixedArray", "createFixedArray", "readfixArray", "readFixstring"], "len": ["enc", "body", "lc", "base", "lit", "val", "lf", "count", "l", "list", "lp", "string", "code", "pos", "split", "li", "en", "line", "part", "Len", "le", "length", "size", "ln", "lt", "ll", "fn", "file", "e", "limit", "data", "str", "el", "i", "sl", "n", "loc", "f", "lin"], "sw": ["aw", "wb", "serv", "SW", "stream", "w", "sa", "WS", "fw", "zip", "wh", "writer", "ow", "bb", "ws", "null", "ew", "so", "sp", "wt", "wp", "wa", "sn", "wr", "wx", "iw", "sc", "fl", "io", "sb", "nw", "sh", "sv", "tw", "es", "ww", "sr", "lv", " SW", "wra", "sf", "Sw", "ss", "sl", "hw", "rw"]}}
{"id1": "12242903", "id2": "1097147", "code1": "    private String hashKey(String key) {\n        String hashed = \"\";\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(key.getBytes());\n            BigInteger hash = new BigInteger(1, md5.digest());\n            hashed = hash.toString(16);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            hashed = String.valueOf(key.hashCode());\n        }\n        return hashed;\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"hashKey": ["hashKEY", "buildKEY", "shaKEY", "buildkey", "HashKEY", "shakey", "buildKey", "shaSecret", "HashKey", "Hashkey", "shaKey", "HashSecret", "buildSecret", "hashkey", "hashSecret"], "key": ["base", "temp", "prefix", "this", "keys", "hex", "check", "mix", "input", "KEY", "text", "message", "cache", "pair", "sync", "cert", "password", "use", "connection", "object", "string", "code", "crypt", "token", "k", "type", "x", "number", "sign", "mac", "secret", "block", "chain", "name", "sum", "word", "data", "id", "user", "seed", "value", "Key", "source", "parent", "address"], "hashed": ["hsash", "Hhed", "hsasha", "shotted", "ahash", "hoded", "hhed", "bhashed", "Hashing", "ahhed", "shoded", " hhed", "shhed", "bhotted", "bhashing", "hsashing", "hhashing", "ahashing", "shash", "ahashed", "bhash", "hsashed", "hotted", "hhashed", "Hasha", " hoded", "hhash", "hasha", "Hash", "hhasha", "Hotted", "shashing", "Hoded", "Hashed", "hashing", "shashed"], "md5": ["mand5", "base5", "MD4", "MD512", "MD5", "mand4", "base62", "md512", "amddown", " md512", "md2", "md4", "mddown", "amd3", " md2", "MD50", "md62", "MDdown", "base2", "base4", " md3", " md50", "md50", " md4", "MD2", "MD3", " md62", "mand512", "amd2", "MD62", " mddown", "amd5", "md3", "mand50"], "hash": ["image", "num", "sha", "base", "her", "log", "html", "hex", "check", "json", "message", "count", "cache", "print", "string", "array", "code", "throw", "abi", "result", "v", "rh", "mac", "carry", "length", "ash", "size", "Hash", "sum", "hed", "h", "search", "shadow", "id", "value", "dot", "f", "url", "copy"]}}
{"id1": "12236729", "id2": "22338097", "code1": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"copy": ["replace", " transfer", "cp", "cmp", "io", "sync", "py", " copying", " copied", "zip", "paste", "split", "clone", "clip", "download", "cat", "Copy", "dump", " Copy", "upload", " dup", "diff", "get", "php", "transfer", "p", "cop"], "inputFile": ["outputFiles", " inputfile", "currentFile", " inputFiles", " inputDir", "currentDir", "sourceFile", "sourcefile", " inputPath", "outputPath", "inputDir", "outputDir", "currentFiles", "inputfile", "currentfile", "sourceFiles", "inputFiles", "sourcePath", "outputfile", "inputPath"], "outputFile": ["referenceFile", "tempFile", "OutputDirectory", " outputDirectory", " outputFilename", "referenceDir", " outputfile", "outputDirectory", "tempfile", "referencefile", "inputFilename", "inputDir", "tempDir", "outputDir", "OutputDir", "tempDirectory", "inputfile", "referenceFilename", "OutputFile", " outputDir", "outputFilename", "Outputfile", "outputfile"], "in": ["into", "ln", "ins", "e", "image", "In", "n", "connection", "lock", "init", "inc", "socket", "gin", "f", "input", "din", "IN", "lin", "inn", "read", "s", "conn", "cin", "i", "sin", "win", "kin", "reader", "source", "is", "inside", "nin", "l", "a", "login", "inner", "min", "r", "id", "pull", "bin", "con", "err", "file", "up", "pin", "get", "ini", "as", "again"], "out": ["at", "ex", "log", "writer", "one", "write", "plain", "parent", "b", "null", "n", "io", "outer", "off", "sync", "outside", "inc", "socket", "output", "o", "Out", "error", "conn", "temp", "i", "outs", "over", "cache", "exec", "bin", "file", "err", "v", "obj", "extra", "up", "w", "net", "OUT", "plus", "again", "line", "post"], "c": ["k", "m", "u", "ct", "esc", "e", "col", "uc", "C", "b", "count", "n", "rc", "ce", "ec", "f", "o", "d", "ch", "cl", "ci", "code", "cc", "i", "cu", "cm", "a", "l", "r", "xc", "id", "sc", "pc", "character", "v", "fc", "cf", "cd", "x", "cy", "pointer", "lc", "line", "cr", "p", "char"]}}
{"id1": "149935", "id2": "11933797", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"convert": ["CONverting", "subverting", "Conversion", "oconversion", "oconverting", "Converting", "CONversion", "unversion", "CONvert", "conversion", "CONception", "oconverted", " deconverted", "converting", "CONverted", "subvert", "oconvert", "Conception", "unvert", "converted", " deconverting", "subversion", "Converted", "unception", "unverted", "subverted", " deconversion", "conception", "Convert", " deconvert"], "src": ["impl", "string", "path", "sel", "ssl", "sin", "input", "sc", "uri", "resource", "sys", "spec", "rc", "Source", "video", "cmp", "username", "filename", "ref", "slice", "cb", "fp", "fn", "s", "prot", "code", "inst", "feat", "cpp", "req", "gb", "back", "source", "reader", "load", "proc", "sb", "rb", "sit", "buf", "component", "dist", "upload", "SourceFile", "config", "file", "tmp", "Dest", "supp", "attr", "img", "href", "storage", "name", "sth", "gz", "RC", "rl", "ctx", "secure", "url", "scene", "stream", "obj", "st", "stage", "sn", "ource", "download", "loc"], "dest": ["path", "class", "temp", " dst", "cont", "fn", "bin", "dc", "std", "txt", "source", "dir", "lib", "target", "dist", "tmp", "Dest", "null", "test", "home", "di", "obj", " destination", "dat", "disk", "orig", "img"], "in": ["IN", "val", "pin", "i", "input", "ex", "n", "inas", "ini", "as", "ins", "bin", "pass", "is", "reader", "d", "source", "doc", "up", "login", "r", "inc", "data", "file", "io", "t", "isin", "In", "a", "stream", "err", "inn", "ps", "f", "inf", "win", "din"], "p": ["P", "i", "pi", "op", "wp", "pre", "lp", "per", "py", "c", "j", "fp", "o", "l", "s", "pb", "cop", "part", "cp", "d", "pr", "pp", "pm", "r", "g", "parser", "h", "np", "po", "tp", "m", "e", "t", "pc", "jp", "pa", "bp", "pe", "b", "sp", "v", "ps", "f", "pd", "pg"], "ds": ["services", "uds", "ays", "docs", "ants", "dos", "s", "ins", "dp", " DS", "parts", "points", "gs", "els", " props", "des", "ts", "js", "utils", "ths", "ys", "gd", "sys", "df", "lp", "bs", "dc", " ps", "dt", "sync", "lines", "eps", "vs", "ges", "amps", "ipes", "pd", "dd", "sts", "DS", "cons", "ks", "ns", "qs", "ld", "hs", "d", "dist", "ans", "ads", "xs", "models", "plugins", "groups", "tests", "ss", "di", "os", "posts", "styles", "rs", "dl", "tools", "ded", "ups", "data", "vals", "scripts", "Ds", "ls", "obs", "dm", "db", "ils", "nas", "dates", "da", "cs", "words", "dds", "ps", "dat", "icks", " sd"], "format": ["letter", "string", "path", "class", "handler", "spec", "filename", "act", "version", "table", "fp", "fn", "host", "tag", "record", "layout", "feat", "magic", "Format", "pattern", "form", "filter", "at", "type", "source", "part", "model", "parser", "config", "data", "file", "sche", "struct", "ant", "language", "style", "plugin", "template", "name", "frame", "t", "function", "prefix", "fd", "nat", "url", "unit", "atter", "f", "scale", "api"], "hasPixelData": ["hasPixeldata", "showsPixelDATA", "hasPixelDATA", "hasPicturedata", "hasByteSize", "hasByteDATA", "hasByteData", "haspixelData", "hasPixelStyle", " hasPixelSize", "showsByteDATA", "hasPictureSize", " hasPixeldata", "haspixeldata", "showsBytedata", "hasPictureData", "haspixelSize", "showsByteData", "showsPixelData", "showsByteStyle", "hasPixelSize", "hasByteStyle", "showsPixelStyle", "hasBytedata", "showsPixeldata"], "inflate": ["inadequating", "insflode", "insvenating", "inffated", "Inflation", "InFlation", "inflating", "Inflated", "inflATE", "InFlace", "insvenate", "inadequode", "InFlated", "insflate", "infolATE", "infface", "invenode", "InFlate", "inffation", "inflated", "inFlation", "infolode", "infloace", "insvenATE", "infloate", "invenATE", "inFlate", "inadequATE", "insflATE", "infloation", "invenating", "inffate", "insvenode", "inadequate", "Inflace", "inflation", "inflode", "inFlated", "Inflate", "infolate", "inFlace", "infloated", "invenate", "infolating", "inflace", "insflating"], "pxlen": ["pxdata", "xpsize", "pxlin", "pngcount", "mxsize", "campos", "fxlen", "pxl", "pgLen", "axlen", "ppLen", "mxcount", "fxln", "pxlon", "pxln", "pcln", "pglen", "ppl", "pxlength", "ppden", "camln", "txln", "pngsize", "pxpos", "pclon", "camlen", "mxdata", "axln", "axlon", "mxlength", "mxpos", "mxlen", "xplen", "txlin", "pxden", "pxcount", "fxpos", "txlon", "pclin", "pxsize", "fxdata", "pxLen", "mxln", "xpcount", "pgl", "fxLen", "axlin", "pnglen", "xplength", "fxl", "pgden", "fxden", "pclen", "pnglength", "txlen", "pplen", "camdata"], "out": ["step", "server", "output", "copy", "sys", "user", "lock", "OUT", "inter", "outs", "line", "co", "query", "post", "session", "cache", "lib", "up", "group", "store", "parent", "work", "page", "log", "gen", "conn", "again", "Out", "io", "dump", "obj", "v", "err", "state", "pad", "cli", "error", "re", "list", "point"]}}
{"id1": "647224", "id2": "6501291", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"uploadFile": [" uploadfile", " uploadDir", "UploadFiles", "processFiles", "uploadDir", "UploadDir", "uploadFiles", "processDir", "UploadFile", "Uploadfile", " uploadFiles", "processfile", "processFile", "uploadfile"], "inputFile": [" inputFolder", "targetFolder", "InputType", " inputDir", "Inputfile", " inputPage", "sourcefile", " inputfile", " inputStream", "targetLog", "inputStream", "sourcePage", "initialFolder", "inputFiles", "InputFolder", "sourceLog", " inputType", " inputFiles", "inputFolder", " inputFilename", "initialFile", "targetFiles", "targetFilename", "initialFilename", "sourceFolder", "InputFile", "inputFilename", "sourceFile", " inputLog", "InputFiles", "inputLog", "targetPage", "inputDir", "inputfile", "sourceType", "inputPage", "initialStream", "inputType", "sourceStream", "InputStream", "targetfile", "targetDir", "targetStream", "InputDir"], "targetFile": ["externalName", " targetPath", " targetfile", " targetPlace", "TargetDir", "Targetfile", "targetPath", "sourcePlace", " targetLine", "outputPath", "externalFile", " targetFiles", "TargetLine", "targetFiles", "externalPath", "TargetFile", "targetPlace", " targetDir", "sourceFile", "targetName", "TargetPath", "inputPath", "sourcePath", "TargetName", "inputDir", "outputDir", " targetName", "sourceDir", "targetLine", "externalfile", "outputFiles", "TargetFiles", "inputPlace", "outputName", "outputLine", "targetfile", "targetDir"], "outputFile": ["outfile", "outFolder", " outputfile", "writePage", "outDirectory", "outputPlace", "outPlace", " outputPage", "inputDirectory", "targetPath", "inputStream", "OutputFile", " outputFolder", "inputUrl", " targetQueue", "Outputfile", "outputPage", "inputFiles", "writeFile", "currentfile", "OutputFolder", "targetQueue", " outputUrl", "currentFile", " outputFiles", "outputPath", "OutputDir", "outputFolder", " targetFiles", " outputDirectory", "outputStream", "inputFolder", " targetDirectory", " outputPlace", "targetFiles", "outPath", "outputDirectory", "inputPath", "writeUrl", " outputPath", " outputDir", "outputDir", "inputDir", "inputfile", " outputStream", "inputPage", "outputQueue", "outFile", "writeStream", "outputfile", "currentPlace", "currentFolder", "outputFiles", "outputUrl", "inputQueue", "targetfile", "targetDirectory"], "in": ["In", "pull", "pass", "issue", "again", "serv", "ini", "IN", "rec", "cin", "is", "din", "inner", "bin", "input", "con", "io", "pin", "ins", "ac", "inn", "err", "kin", "up", "isin", "init", "win", "s", "lin", "rin", "url", "read", "inside", "i", "nin", "login", "reader", "diff", "data", "r", "inc", "id", "sub", "source", "stream"], "out": ["ger", "again", "println", "n", "cache", "o", "table", "inter", "ex", "inner", "bin", "state", "Out", "copy", "report", "log", "outer", "io", "outs", "co", "this", "sys", "sync", "user", "conn", "err", "print", "up", "net", "s", "base", "cmd", "exec", "dump", "off", "by", "image", "writer", "to", "plain", "page", "ext", "output", "error", "data", "write", "OUT", "r", "point", "inc", "lock", "source", "client", "console", "one", "file"], "line": ["inline", "entry", "row", "pass", "string", "lines", "word", "LINE", "ine", "limit", "comment", "le", "Line", "log", "char", "sync", "header", "unit", "frame", "rule", "part", "base", "lin", "cell", "pe", "url", "link", "e", "code", "split", "page", "range", "error", "data", "type", "write", "lf", "job", "buffer", "lock", "block", "name", "file", "lc"], "bytes": ["pages", "reads", "Bytes", "classes", "words", "codes", "bs", "zip", "bps", " lines", "lines", "ones", "values", "eps", "bits", "outs", "os", "number", "files", "length", "groups", "seconds", "tes", "steps", "count", "s", "pos", "cycles", "ls", "size", "ines", "code", "len", "i", "blocks", " cycles", "units", "ips", "items", "comments", "es", "binary", "les", "odes", "rows"]}}
{"id1": "12349563", "id2": "5399593", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"resourceExists": [" fileexes", " fileexists", " resourceExits", " resourceexists", " resourceexits", " resourceExes", " resourceexistence", " resourceCompists", " resourceAbsistence", " fileExits", " resourceCompistence", " resourceAbses", " resourceAbsists", " fileExes", " resourceCompes", " fileexits", " fileExistence", " fileExists", " resourceexes", " resourceAbsits", " resourceExistence", " fileexistence", " resourceCompits"], "location": ["source", "local", "message", "filename", "position", "shape", "remote", "uri", "Location", "length", "path", "language", "point", "home", "info", "pointer", "area", "image", "localhost", "loc", "data", "folder", "object", "resource", "LOC", "directory", "description", "base", "name", "server", "host", "operation", "address", "connection", "string", "region", "layer", "provided", "reference", "file", "collection", "route", "href", "response", "layout", "type", "node", "target", "content"], "url": ["source", "uri", "path", "Url", "c", "f", "config", "page", "i", "l", "image", "build", "loc", "blog", "web", "resource", "open", "www", "io", "base", "b", "server", "host", "URL", "obj", "fl", "sl", "api", "address", "zip", "string", "connection", "ll", "impl", "file", "lib", "r", "ssl", "user", "http"], "cxn": ["crexg", "cexne", "Cxne", "cxxn", "cuxp", "Cxns", " cxp", "crexcon", " crexp", "cuxne", "cxxne", "crexp", "cdscon", "cuxns", "cexcon", " crexn", "cxg", "Cxp", "cxp", "cxcon", "cxns", "Cuxns", " crexg", "cdsp", "cdsn", "cxxp", "cxxns", "cuxn", "cexn", "cexp", " crexcon", "cexg", "cexns", "Cuxne", " cxcon", " cxg", "cxne", "Cuxn", "cdsg", "crexn", "Cxn", "Cuxp"], "is": ["x", "as", "ris", "app", "init", "internet", "uri", "IS", "out", "im", "us", "was", "isa", "oss", "ai", "info", "s", "its", "ori", "ens", "iss", "i", "Is", "src", "or", "iso", "web", "in", "close", "lis", "does", "ir", "ip", "ar", "next", "ms", "os", "cos", "it", "isc", "fs", "ui", "isl", "bs", "api", "isi", "stream", "ais", "ios", "es", "abs", "iris", "nis", "ob", "id", "bis", "get", "has", "js", "cms", "ois", "http"], "byteBuffer": ["bitBuff", "ByteArray", "ByteBuff", " byteBB", "byteBB", "bitBuffer", "ByteLength", " byteArray", "ByteBuffer", "byteArray", "bitLength", "ByteBB", "byteBuff", "byteLength", " byteBuff", " byteLength", "bitBB", "bitArray"]}}
{"id1": "22993368", "id2": "9347451", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFileAsStream", "decodeFileToFiles", "decodeFile2File", "decodeFileToString", "decodeStringToStream", "decodeStringToString", "decodeFileAsString", "decodeFileAsFile", "decodeString2File", "decodeFileFromFiles", "decodeFileFromFile", "decodeString2Stream", "decodeString2String", "decodeFileFromStream", "decodeStringToFiles", "decodeString2Files", "decodeFileToStream", "decodeFile2Stream", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2Files", "decodeFileFromString"], "infile": ["inputfilename", "outfilename", "infilename", " instream", "inputfile", "inputfiles", "minfile", "outfiles", "infp", "Instream", "inputfp", "Inbase", "outfp", "minstream", " infilename", " infp", " infiles", " inbase", " inFile", "instream", "infiles", "minFile", "inbase", "minbase", "InFile", "Infile", "inFile"], "outfile": ["inputFile", "outputfilename", "outfilename", "infilename", "inputfile", "outpath", "outputFile", "outFile", " outfilename", "inputdatabase", " outdatabase", "inputpath", " outpath", " outFile", "outputdatabase", "outdatabase", " outfolder", "outputfile", "infolder", "outputpath", "outputfolder", "outfolder", "inFile"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "lin", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "channel", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "log", "copy", "conn", "cache", "again", "output", "inner", "line", "writer", "work", "err", "off", "client", "o", "OUT", "lib", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "pass", "post", "io", "net", "file", "up", "co", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "bin", "reader", "border", "uffer", "iter", "data", "channel", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "queue", "input", "result", "length", "write", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "r", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "positive", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "17475530", "id2": "3024992", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkstoPicture", "testAddLinkOfImage", "testAddLinktoImage", "testAddLinkFromLink", "testAddLinkOfLink", "testAddLinkToPicture", "testAddLinktoFile", "testAddLinkFromPicture", "testAddLinktoPicture", "testAddLinkOfFile", "testAddLinkstoLink", "testAddLinktoLink", "testAddLinkOfPicture", "testAddLinkToFile", "testAddLinkFromImage", "testAddLinksToPicture", "testAddLinkstoImage", "testAddLinksToLink", "testAddLinkstoFile", "testAddLinksToFile", "testAddLinkToLink", "testAddLinkFromFile", "testAddLinksToImage"], "in": ["exec", "serv", "url", "gin", "ins", "din", "reader", "IN", "token", "login", "el", "bin", "id", "exp", "isin", "inc", "path", "xml", "ini", "index", "input", "val", "out", "In", "conn", "name", "stream", "image", "err", "doc", "ax", "m", "or", "ssl", "at", "i", "r", "connection", "ex", "n", "again", "with", "diff", "socket", "nin", "win", "uri", "resource", "inn", "version", "min", "pin", "get", "copy", "is", "cin", "data", "source", "file", "work", "rin", "pass", "con", "ac", "as", "f"]}}
{"id1": "13439950", "id2": "22479286", "code1": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "code2": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"readRemoteFile": ["loadremoteFile", "loadRemoteResponse", "readStaticFiles", "loadRemoteFiles", "loadRemoteFile", "readremotefile", "readRemoteFiles", "readLocalResponse", "loadremoteFiles", "readRemotefile", "readStaticfile", "readStaticFile", "readLocalFile", "readremoteFile", "readremoteResponse", "readStaticResponse", "loadremoteResponse", "loadremotefile", "readLocalfile", "readremoteFiles", "loadRemotefile", "readRemoteResponse", "readLocalFiles"], "response": ["message", "result", "output", "json", "ss", "out", "uri", "http", "e", "i", "offer", "line", "application", "resp", "data", "example", "service", "object", "resource", "description", "next", "array", "server", "Response", "res", "body", "api", "onse", "string", "respond", "ception", "respons", "value", "answer", "request", "results", "feed", "site", "error", "status", "content", "reply"], "url": ["ls", "org", "ref", "remote", "uri", "str", "browser", "Url", "plug", "f", "i", "l", "web", "resource", "open", "io", "base", "bel", "b", "server", "host", "URL", "rl", "zip", "sl", "fr", "ur", "stream", "impl", "file", "r", "ssl", "ob", "jar", "http"], "is": ["as", "ris", "uri", "IS", "out", "str", "was", "info", "its", "are", "iss", "i", "Is", "src", "or", "iso", "in", "ib", "close", "ir", "sr", "ip", "io", "ar", "os", "b", "it", "fs", "bs", "res", "api", "sp", "fr", "ais", "ios", "es", "r", "id", "bis", "has", "ri", "http"], "br": ["ab", "result", "bro", "bridge", "arr", "bed", "str", "browser", "bh", "bar", "bb", "fb", "buf", "mr", "i", "BR", "bl", "serv", "ib", "sr", "img", "io", "be", "ber", "b", "os", "hr", "obj", "cr", "res", "body", "sp", "rb", "dr", "ch", "gr", "fr", "stream", "orb", "iter", "rt", "tr", "r", "er", "err", "ob", "reader", "cb", "rel", "http"], "s": ["p", "ls", "source", "message", "result", "su", "sb", "ps", "lines", "str", "ss", "session", "c", "f", "sym", "bytes", "e", "i", "input", "l", "services", "single", "data", "m", "strings", "resource", "rs", "ws", "sr", "n", "shell", "g", "si", "ses", "v", "u", "b", "os", "null", "sl", "res", "string", "details", "raw", "sample", "ns", "es", "r", "t", "results", "o", "sv", "site", "S", "ssl", "sf", "js", "d", "status", "content"], "eof": ["eol", "oeoh", "geore", "eeol", "Eof", "eeoh", "yeof", "eif", "EOF", "Eef", "eoh", "oeol", "geif", "yeOF", "Eoh", "ueOF", "eeaf", "Eok", "oeof", " eOF", "Eif", "ueof", "ueaf", "Eaf", "Eol", " eef", " eom", "oeok", "Eore", " eol", "ueom", " eaf", "eOF", "eaf", "yeore", "yeif", "geof", "geOF", "eom", "eeof", "Eom", "eok", "eeok", "eore", "eeef", "eef"]}}
{"id1": "13596891", "id2": "1598693", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static String retrieveData(URL url) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"User-agent\", \"MZmine 2\");\n        InputStream is = connection.getInputStream();\n        if (is == null) {\n            throw new IOException(\"Could not establish a connection to \" + url);\n        }\n        StringBuffer buffer = new StringBuffer();\n        try {\n            InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n            char[] cb = new char[1024];\n            int amtRead = reader.read(cb);\n            while (amtRead > 0) {\n                buffer.append(cb, 0, amtRead);\n                amtRead = reader.read(cb);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        is.close();\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"doTransfer": ["handleImport", " doSend", "makeRequest", "doImport", "makeImport", " doRequest", "doRequest", "doSend", "handleSend", "makeTransfer", " doImport", "handleTransfer", "handleRequest", "makeSend"], "request": ["resource", "application", "requ", "subject", "position", "instance", "current", "context", "http", "Request", "xml", "condition", "input", "time", "report", "queue", "this", "post", "enter", "in", "form", "object", "user", "command", "connection", "model", "event", "server", "query", "config", "complete", "session", "q", "received", "record", "remote", "result", "reader", "data", "type", "req", "QUEST", "message", "com", "stream", "client", "re", "version", "create", "rf"], "response": ["Response", "resource", "application", "status", "serv", "full", "respond", "cache", "site", "reply", "http", "results", "view", "version", "cover", "service", "call", "report", "onse", "json", "warning", "content", "object", "header", "default", "resp", "connection", "document", "out", "event", "model", "server", " Response", "index", "session", "success", "image", "writer", "res", "remote", "result", "page", "next", "output", "error", "en", "message", "client", "body", "re"], "method": ["property", "resource", "pull", "status", "route", "class", "subject", "use", "send", "description", "position", "string", "call", "hod", "time", "path", "process", "json", "content", "mode", "verb", "command", "cmd", "prefix", "date", "session", "head", "callback", "format", "METHOD", "direction", "type", "term", "sign", "message", "text", "version", "reason", "sort", "Method"], "servletContext": ["servLETContext", "ServletConfig", "ServletController", "servleConfig", "ServletsConfig", "servlexConfig", "servlexcontext", " servletCurrent", "servLETCurrent", "servApplicationcontext", " servantCurrent", "servletConfig", "servantConfig", "Servletcontext", "Servletscontext", "ServletsController", "servApplicationConfig", "servantCurrent", " servletProvider", " servantConfig", "servletCurrent", "servletsContext", "servantProvider", " servletConfig", "servletProvider", "servLETConfig", "servantContext", " servantProvider", "ServletsContext", "servApplicationController", "servApplicationContext", "servletcontext", "servletsController", "ServletContext", "servletController", "servlexController", "servLETProvider", "servlexContext", "servleCurrent", "servleContext", " servantContext", "servleProvider", "servletscontext", "servletsConfig"], "wac": ["wsae", "wae", " wae", " Wacs", " WAC", "wsAC", " Wac", " wacs", "wacs", "wAC", "wsacs", " wAC", "wsac", " Wae"], "szUrl": ["asizUrl", "szenFolder", "sizFolder", "asizurl", "szUr", "szURL", "sizurl", "sizFrame", "asizUr", "szenurl", "sziurl", "szaURL", "szeurl", " sizURL", "szerURL", "sizPath", "sziUr", " szURL", "szerUr", "sznURL", "asizFrame", "asizURL", "aszURL", "szFrame", "sznUrl", "szaPath", "szerUrl", "szeFolder", "sziURL", "szeUrl", " szFolder", "szenURL", "sznPath", "szenUrl", "sziUrl", " szurl", "szPath", "sznUr", " sizUrl", "szaUrl", "aszUrl", "szerFrame", "szeUr", "szeFrame", " sizurl", "aszurl", "sizURL", "szeURL", " sizFolder", "sizUr", "asizPath", "szaUr", "sizUrl", "sznurl", "szFolder", "aszFrame", "szurl", "aszUr", "aszPath"], "url": ["resource", "il", "cloud", "stream", "string", "host", "context", "xml", "http", "service", "www", "URL", "log", "ll", "ur", "org", "gl", "key", "Url", "rl", "impl", "conn", "user", "loc", "rel", "lb", "l", "connection", "base", "event", "server", "location", "get", "config", "sl", "f", " URL", "li", "ul", "el", "socket", "page", "ssl", "fl", "obj", "web", "uri", "source", "client", "buffer", "re", "name", "file"], "is": ["ib", "il", "us", "ip", "isa", "serv", "im", "ios", "ii", "isl", "bs", "ir", "was", "oss", "isf", "ci", "as", "has", " isn", "io", "ais", "os", "IS", "cms", "ri", " are", "it", "Is", "rc", "iss", "iso", "x", "isi", "isc", "i", "bis", "lis", "ai", "isu", "ils", "web", "info", " bis", "uri", "rx", "src", "ris"], "sout": ["Sout", " sOUT", "souts", " sin", "Sdata", "Sin", "sdata", " sOut", " sdata", "Souts", "sOut", "SOut", " souts", "sin", "sOUT", "SOUT"], "con": ["fe", "ctrl", "pc", "status", "subject", "Connection", "m", "ca", "view", "http", "can", "ct", "l", "ren", "don", "ssl", "gen", "ec", "general", "ver", "const", "version", "lc", "fa", "c", "cache", "fun", "xc", "pin", "user", "Common", "single", "cc", "cl", "connection", "win", "cn", "cp", "ocon", "cur", "pre", "login", "en", "conf", "nc", "connect", "re", "conv", "ctx", "open", "co", "util", "cf", "min", "net", "rc", "coll", "query", "wan", "get", "cos", "Con", "uc", "author", "type", "web", "client", "com", "run", "fc", "cons", "Internal", "func", "java", "wa", "ran", "conn", "on", "C", "event", "exec", "server", "syn", "bc", "non", "crit", "CON", "internal", "un", "close", "remote", "inc", "pen", "san", "core", "common"], "hNames": ["HBlocks", "ihName", "hFiles", "hostNames", "hVs", "HVs", "hostTypes", "hrKeys", " hKeys", "HNames", " hFiles", " hNs", " hBlocks", "hrName", " hVs", "hKeys", "hrNs", "ihBlocks", "HTypes", "hrNames", "HName", "ihNames", "hNs", "hTypes", " hTypes", " hName", "ihVs", "HFiles", "hostKeys", "hrTypes", "hBlocks", "hrFiles", "hostNs", "hName"], "txt": ["struct", "xt", "lt", "wt", "section", "zip", "Text", "py", "str", "wx", "fx", "ctx", "inet", "key", "text", "in", "ct", "ht", "header", "xxx", "XT", "csv", "qt", "phrase", "dt", "gt", "lv", "value", "q", "gz", "tx", "cb", "fp", "v", "kt", "nt", "nm", "gi", "TEXT", "elt", "obj", "rr", "jp", "rx", " text", "t", "sv", "prot", "git", "htm", "tin", "bt", "utt", "et", "name", "binary", "vt"], "inBody": ["INReader", "inbody", "insReader", " inbody", "INFile", "INBody", "InReader", "outBody", "outbody", "Inbody", "INStream", "InBody", " inStream", "inReader", "inStream", "outStream", "insFile", "insStream", "InFile", "inFile", " inFile", "outFile", " inReader", "INbody", "InStream", "insBody"], "bufCh": ["queueCol", "bufferCh", "queuech", "bufferch", "bufferCH", "ufch", " bufCol", " bufChar", "queueCH", "bufC", "buffCh", "ufCol", "ufChar", "ufCH", "bufch", "bufChar", "buffch", "bufCH", " bufC", "ufC", " bufch", "ufCh", "buffC", "bufCol", " bufCH", "queueCh", "buffCH", "bufferChar"], "r": ["rg", "u", "k", "c", "R", "pr", "ru", "m", "rh", "g", "n", "d", "str", "ner", "sr", "rt", "rl", "ri", "nr", "er", "lr", "p", "br", "cr", "err", "w", "rc", "ar", " rg", "reg", "x", "f", "ror", "e", "rw", "i", "q", "res", "result", "v", "range", "reader", "hr", "rr", "b", "rs", "rd", "re", "rb", "fr", "rf"], "outReq": ["outSeck", " outReck", "outDeq", "outRece", " outRce", "outREque", " outSeque", " outReh", " outRq", "outRecce", " outRsque", "outSequest", " outEq", "outRck", " outRereq", "outEck", "outReck", "outRq", "outReh", "outSece", " outEreq", " outEque", " outSeck", "outRsq", "outREh", "outConh", "outConce", "outRecreq", "outEq", " outRequest", "outRsque", " outRsce", "outDeque", "outRreq", " outEck", " outSece", "outRquest", "outRereq", "outEque", " outRquest", " outRece", "outREce", "outRque", " outRque", "outRecck", "outRsce", "outConq", "outDequest", "outRecq", "outReque", "outRequest", " outRsh", "outSeq", " outReque", "outRce", "outREck", "outConque", "outEreq", "outRecque", "outRsh", " outRsq", " outSeq", "outSeque", "outREq", "outDece"], "buff": ["Ptr", "ch", " Buffer", "map", "lines", " chunk", "Pad", "buf", "num", "p", " buffers", "array", "Buffer", "f", " Buff", "Msg", "uf", "bb", "data", "Buff", "b", "Info", "info", "buffer", "file"]}}
{"id1": "19584877", "id2": "255765", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2File", "encodeFileFromStream", "encodeFileFromString", "encodeStringToStream", "encodeString2Files", "encodeFiletoStream", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileFromFiles", "encodeFileFromFile", "encodeString2Stream", "encodeStringToString", "encodeFileToString", "encodeFile2String", "encodeString2String", "encodeFile2File", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFile2Files", "encodeFileToStream"], "infile": [" infilename", "infiles", "Infilename", "outFile", "inputfile", "outfiles", "inFile", "InFile", "inputfilename", " infiles", " infp", "inputFile", "outfilename", "outfp", "Infiles", "inputfiles", "infp", "inputfp", "infilename", "Infile"], "outfile": ["newfolder", "outname", "outFile", " outFile", "outputfp", "outputfilename", " outfilename", "Outname", "outfolder", "outputfolder", " outfp", "Outfolder", "newfile", "newname", " outfolder", "infolder", "newFile", "outfilename", "outfp", "outputfile", "OutFile", "infp", " outname", "infilename", "Outfile"], "in": ["re", "err", "ini", "image", "base", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "vin", "m", "din", "socket", "inc", "s"], "out": ["err", "ou", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "In", "obj", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "outs", "work", "job", "source", "line", "io", "Out", "client", "off", "name", "co", "on", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "count", "cache", "slice", "queue", "b", "bytes", "bb", "null", "buf", "buff", "border", "padding", "fb", "split", "uffer", "type", "result", "len", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "input", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "close", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "model", "method", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "respons", "open", "better", "message", "growth", "modified", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "18370075", "id2": "17111859", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 1, "substitutes": {"createPasswordDigest": ["createPassworddigester", "createPasswordSignest", "createpasswordDigester", "createPassworddigifier", "createpasswordDigenge", "createPasswordSignester", "createpassworddigenge", "createPasswordModifier", "createPassworddigest", "createPasswordModester", "createPasswordSignenge", "createpasswordDigifier", "createpasswordDigest", "createpassworddigester", "createPasswordModest", "createPasswordDigester", "createPasswordDigenge", "createPassworddigenge", "createpassworddigifier", "createPasswordDigifier", "createpassworddigest", "createPasswordModenge", "createPasswordSignifier"], "password": ["pass", "token", "username", "words", "seed", "sword", "string", "word", "secret", "Password", "PASS", "wallet", "path", "key", "auth", "pad", "email", "wd", "database", "user", "address", "command", "p", "phrase", "security", "config", "filename", "hash", "login", "data", "account", "message", "Pass", "pattern", "crypt", "text", "source", "name", "padding"], "salt": [" ssecret", "SALT", "pass", "ssecret", "psecret", "sesalt", "palt", "sessecret", "ssALT", "sesass", "sALT", " sass", "ssalt", "pALT", "Sass", "Ssecret", " sALT", "Salt", "sesALT", "sssecret", "ssass", "sass"], "md": ["mb", "mail", "pd", "ms", "pm", "od", "mand", "clean", "mac", "zip", "m", " MD", "d", "sha", "di", "MD", "bd", "meta", "ad", "dd", "ph", "mc", "ld", "cd", "mod", "cmd", "mn", "ma", "mag", "nd", "code", "ind", "gd", "dm", "nm", "amd", "kg", "mm", "metadata", "bf", "po", "message", "mad", "mt", "me", "mo"], "digest": ["decests", "hashcode", "hashest", "dested", " digests", "Digester", "Digested", "signest", " digEST", "digested", "digester", "dest", "decest", "DigEST", " digester", " digested", "digress", "generest", "signester", "hashester", "signcode", "generester", "digEST", " digcode", "generress", "digcode", "signested", "dester", "digests", "dEST", "hashested", "Digest", "decress", "decester", " digress", "generests"]}}
{"id1": "17791385", "id2": "11377441", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyfile", "copyStream", "CopyFile", "copyFiles", "transferfile", "transferFile", " copyfile", " copyStream", "Copyfile", "CopyFiles", "CopyStream", "transferStream", " copyFiles"], "src": ["ls", "source", "filename", "sb", "uri", "st", "config", "s", "back", "txt", "input", "image", "sin", "inst", "loc", "resource", "img", "dest", "sup", "url", "inf", "b", "files", "obj", "sit", "sel", "sl", "sc", "dist", "rc", "rb", "ins", "upload", "stream", "file", "ipl", "http"], "dst": ["ddft", "fdfd", " dsts", "ddfd", "pdfd", " ddest", "pdsp", "Dst", "fdsp", "dsts", "dsp", "Dsts", "ddest", "Ddest", "stlt", "pdst", "pdft", "stdest", "fdst", "ddsp", "fdft", " dlt", "ststs", "ddst", "dlt", "dft", "Dlt", "stst", "dfd"], "in": ["as", "init", "ln", "gin", "inn", "pin", "inner", "f", "i", "input", "inside", "conn", "sin", "socket", "IN", "data", "m", "ini", "win", "con", "n", "url", "din", "is", "nin", "ins", "h", "cin", "lin", "In", "impl", "inc", "again", "rin", "kin", "file", "pull", "r", "err", "login", "oin", "id", "reader", "bin"], "out": ["x", "copy", "cache", "output", "sync", "client", "net", "at", "f", "s", "w", "ex", "i", "conn", "OUT", "line", "writer", "other", "self", "up", "io", "n", "bin", "null", "outer", "ext", "server", "exec", "post", "obj", "exp", "Out", "raw", "outs", "again", "off", "file", "temp", "parent", "part", "err", "o", "plain", "inc"], "buf": ["bh", "buffer", "uf", "seq", "uc", "length", "br", "bag", "c", "cat", "pad", "buff", "fb", "bb", "bytes", "cmd", "lim", "bl", "count", "ff", "val", "loc", "data", "bf", "bc", "base", "b", "fd", "fl", "rc", "rb", "cur", "queue", "raw", "batch", "off", "vec", "cap", "wb", "ctx", "v", "bin", "cb", "bd"], "len": ["lf", "ln", "length", "c", "f", "all", "lt", "ix", "nt", "i", "lim", "l", "pos", "count", "line", "val", "ind", "data", "n", "base", "name", "lc", "fd", "fin", "fl", "split", "sl", "li", "size", "cl", "el", "ll", "lin", "en", "Len", "cap", "part", "err", "end", "le", "rev", "bin", "no"]}}
{"id1": "14303294", "id2": "15202804", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getSessionHash", "getServerAddress", " getServerAddress", "getSecureSalt", "getServerSalt", "getserverAddress", " getSecureAddress", "getserverHash", "getSessionAddress", "getserverSHA", "getSecureSHA", "getSecureHash", "getSecureAddress", "getserverSalt", "getSessionSalt", "getSessionSHA", " getServerSHA", " getSecureSalt", " getSecureHash", "getServerSHA", " getServerSalt", " getSecureSHA"], "passwordHash": ["passwordhash", " PasswordHash", " passwordCode", "PasswordHash", "passwordPass", "PasswordPassword", " passwordhash", "PasswordPass", " passwordPass", "privatePassword", " PasswordPass", " PasswordCode", "privatehash", "passwordCode", "privateHash", " passwordSalt", "passwordSalt", "privateSalt", " passwordPassword", "Passwordhash", "PasswordCode", "passwordPassword"], "PasswordSalt": [" PasswordHash", "password256", " passwordSecret", "PasswordHash", "PasswordPassword", "passwordSecret", "PasswordSecret", "PASSSalt", "PASSPassword", "PASSHash", " Password256", " passwordSalt", "passwordSalt", "Password256", "PASS256", " passwordPassword", " PasswordPassword", " PasswordSecret", "passwordPassword"], "hash": ["row", "sh", "string", "cache", "mac", "Hash", "sha", "response", "sum", "copy", "log", "search", "hex", "number", "key", "auth", "content", "user", "address", "kh", "build", "crypt", "ha", "base", "url", "work", "ash", "size", "array", "pool", "code", "value", "password", "her", "image", "h", "check", "result", "change", "html", "error", "data", "dig", "message", "update", "buffer", "block"], "digest": ["hashener", "digener", " digall", "generall", "hashest", " diger", "digusher", "mdest", "Digener", " digher", "Digester", " digusher", "integested", "mdested", "signest", "Digested", "integest", " digger", "digested", "digester", "signer", "Digusher", " digester", " digested", "Digher", "generest", "mdusher", "signester", "hasher", "hashester", "signher", "generester", "Diger", "diger", "Digger", "integester", "generested", " digener", "integall", "digger", "mdester", "Digest", "digher", "digall", "signger"]}}
{"id1": "8046691", "id2": "5836744", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"retrieveFile": ["retrievingfile", "retriveFile", "retireFile", "RetrievingUrl", "Retrievingfile", "retrievingFile", "retrievefile", "Retrievefile", "retriveFiles", "retrievingUrl", "retrieveUrl", "RetrievingFile", "retirefile", "RetrieveFile", "RetrieveFiles", "retrivefile", "retireFiles", "retrievingFiles", "retireUrl", "retriveUrl", "retrieveFiles", "RetrievingFiles", "RetrieveUrl"], "url": ["image", "buffer", "service", "email", "sl", "html", "stream", "src", "host", "socket", "object", "proxy", "feed", "user", "page", "server", "address", "loc", "connection", "http", "location", "URL", "resource", "path", "io", "ssl", "file", "Url", "channel", "base", "download", "gl", "loader", "log", "contact", "org", "ll", "l", "string", "ur", "uri", "source", "config", "www"], "link": ["image", "error", "sync", "entry", "comment", "links", "address", "open", "info", "http", "build", "post", "config", "base", "linked", "name", "uri", "Link", "feed", "load", "user", "bug", "parse", "route", "cache", "check", "loc", "tail", "path", "li", "message", "pack", "file", "set", "local", "skip", "l", "plugin", "lock", "auto", "service", "ink", "object", "slice", "lc", "low", "ref", "pull", "line", "download", "log", "remote", "add", "source", "layer", "match", "block", "LI", "or", "connection", "code", "location", "model", "inline", "data", "type", "loader", "task", "call", "style", "light", "list", "machine", "self"], "httpConn": ["userConn", "workconn", "transConnection", "baseConn", "serverconn", " httpConnection", "httpCan", "HttpConn", " httpConfig", "HttpConnect", "httpCmd", " httpconn", "urlConnect", " httpCan", "webLoc", "httpConf", "serverMC", "HttpConnection", "webConnection", "phpConnection", " httpLoc", "HttpMC", "workConnection", "HttpLoc", "urlCon", "httpsCan", "userConf", "perCon", "transConnect", "workCon", "httpMC", "httpconn", " httpCon", "serverConnect", "pubConnection", "httpConfig", "userConnect", "httpCur", "urlConnection", "baseConnection", "buildConnection", "buildCmd", "HttpConfig", "pubConn", "buildConn", "perConnection", "httpsCon", "httpConnection", "workConn", "phpCon", "buildconn", "buildCon", "urlConn", "httpsConf", "perConf", "perconn", "perConn", "baseCan", "transConn", "httpsConnect", " httpConf", "transCon", "serverConn", "phpCur", "serverConnection", "baseConf", " httpCur", "httpLoc", "httpsConn", " httpMC", "httpConnect", "pubCmd", "phpConn", "HttpCur", " httpCmd", "webConfig", "phpConnect", " httpConnect", "webConnect", "httpsConnection", "webconn", "pubCon", "perConnect", "httpCon", "userConnection", "webConn"], "outs": ["Out", "locks", "in", "timeout", "ups", "bytes", "qs", "steps", "lets", "files", "output", "socket", "limits", "boxes", "bs", "strings", "its", "overs", "ls", "ns", "events", "INS", "css", "aos", "cache", "lines", "conn", "gets", "cos", "ios", "reports", "services", "io", "results", "out", " out", "states", "abs", "bits", "opens", "sets", "data", "blocks", "pins", "works", "groups", "errors", "ins", "ops", "fits", "utils", "again", "runs", "ports", "rules", "ws", "OUT", "flows", "plugins"], "bins": ["pannels", "pints", "cbas", "bains", "sbkins", "pin", "bkins", "Bannels", "Bains", "Bouts", "wbins", "cbains", "sbains", " bkins", "wbouts", "Bkins", " bints", "wbains", "wbas", "Bints", "cbins", "bas", " bas", "sbouts", " bin", "Bins", "cbouts", "sbins", "bints", "pins", " bannels", "bin", "Bin", "bannels", " bains"], "bouts": ["bborders", "dbuss", "wbgets", "Bout", "bout", "wbins", "Bouts", "Buss", " bgets", "wbouts", "bboxes", "dbout", "bgets", " borders", "Borders", " bboxes", " buss", " bout", "dbouts", "bbins", "buss", "Bins", "borders", "Bboxes", "bbgets", "bbout", "bbouts", "dbboxes", "wbout"], "postData": ["ostBody", "readData", "POSTBytes", "formDATA", "ostdata", "POSTDATA", " postBody", "postBody", "ostDATA", "PostData", "objectDATA", "objectBytes", "postBytes", "readUrl", "PostUrl", "postString", "objectData", " postDATA", "POSTData", "formBody", "readdata", "formData", "ostData", "objectBody", "PostString", "postUrl", "POSTUrl", "readString", "Postdata", "POSTBody", "postDATA", "postdata", " postBytes", "POSTdata", "formdata", "POSTString"], "mimePattern": ["mimesModel", "mimesPattern", "MimesPattern", "MIMEModel", "mileModel", "mIMEModel", "Mimepattern", "mimeFilter", "mimepattern", "mimesString", "milePattern", "mimeString", "mimeModel", "MIMEPattern", "Mimespattern", "mIMEFilter", "MimePattern", "mengepattern", "MIMEpattern", "mimespattern", "MimesFilter", "mengeFilter", "mengePattern", "MimeFilter", "MimeString", "MimeModel", "MimesString", "mimesFilter", "mIMEString", "mengeString", "mIMEpattern", "milepattern", "mIMEPattern"], "matcher": ["patches", "patmatch", "earchers", "earmatch", "matchers", "matmatch", "patchers", "mather", "Matcher", "matches", "earcher", "Matmatch", " mather", "patche", "pather", " matchers", "Matches", "Matchers", "Matche", "earches", " matches", " matche", "patcher", "matche", "Mather"], "byteBuffer": ["ByteArray", "bitBuffer", "dataLength", "bitArray", "byteLength", "ByteHandler", "dataBuffer", "bitBuff", " byteQueue", "ByteLayer", "byteArray", "doubleBuffer", " byteArray", "doubleBuff", "byteHandler", " byteLength", "ByteLength", "ByteBuffer", "ByteBuff", "dataLayer", " byteBuff", " byteHandler", "dataBuff", "bitHandler", "doubleQueue", " byteLayer", "byteLayer", "doubleArray", "byteBuff", "byteQueue", "ByteQueue"], "count": ["ind", "match", "level", "size", "max", "n", "Count", "cond", "label", "key", "i", "old", "all", "e", "parent", "id", "limit", "core", "coll", "cache", "val", "child", "more", "group", "length", "code", "sum", "found", "low", "index", "weight", "num", "path", "pool", "now", "file", "build", "part", "len", "start", "min", "f", "col", "depth", "ch", "base", "type", "b", "keep", "offset", "number", "allow", "call", "name", "string", "list", "current", "c"]}}
{"id1": "10383721", "id2": "3187685", "code1": "    @SuppressWarnings(\"unchecked\")\n    private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException {\n        String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag;\n        if (cache.containsKey(key)) {\n            return (ReaderFeed) cache.get(key);\n        }\n        List<Post> postList = new ArrayList<Post>();\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Cookie\", \"SID=\" + sid);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n        SAXBuilder builder = new SAXBuilder(false);\n        Document doc = builder.build(reader);\n        Element root = doc.getRootElement();\n        Namespace grNamespace = root.getNamespace(\"gr\");\n        Namespace namespace = root.getNamespace();\n        String newflag = root.getChildText(\"continuation\", grNamespace);\n        String title = root.getChildText(\"title\", namespace);\n        String subTitle = root.getChildText(\"subtitle\", namespace);\n        List<Element> entryList = root.getChildren(\"entry\", namespace);\n        DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n        for (Element e : entryList) {\n            Post post = new Post();\n            post.setTitle(e.getChildText(\"title\", namespace));\n            try {\n                post.setDate(sdf.parse(e.getChildText(\"published\", namespace)));\n            } catch (ParseException e1) {\n            }\n            post.setUrl(e.getChild(\"link\", namespace).getAttributeValue(\"href\"));\n            post.setSauthor(e.getChild(\"author\", namespace).getChildText(\"name\", namespace));\n            String content = e.getChildText(\"content\", namespace);\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"description\", namespace);\n            }\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"summary\", namespace);\n            }\n            post.setContent(content);\n            postList.add(post);\n        }\n        ReaderFeed readerFeed = new ReaderFeed();\n        readerFeed.setTitle(title);\n        readerFeed.setSubTitle(subTitle);\n        readerFeed.setFlag(newflag);\n        readerFeed.setPostList(postList);\n        cache.put(key, readerFeed);\n        return readerFeed;\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"processEntrys": ["processDistrys", "processENTrings", "processENTrys", "processEllrings", "runENTrings", "runEntrings", "runEntriers", "processEntris", "processEntrings", "processENTris", "processDistriers", "processENTriers", "processEllris", "runEntris", "runENTrys", "processEntriers", "processEllriers", "runENTris", "processEllrys", "runEntrys", "runENTriers", "processDistris", "processDistrings"], "urlStr": ["fileStr", "URLStr", "filestr", "httpStr", "UrlStr", "urlSTR", "resourceString", "Urlstr", "UrlSTR", "urlstr", " urlString", "uriStr", "URLString", "urlString", "httpSTR", " urlSt", "uriString", "resourcestr", "uriSt", "URLSt", "resourceStr", " urlstr", "urlSt", "uriSTR", "httpString", "resourceSTR", "fileSTR", "httpstr", " urlSTR", "URLSTR"], "currentFlag": ["CurrentText", " currentField", " currentBit", "CurrentTag", "currentField", "reportedText", "Currentflag", "reportedFlag", "CurrentFlag", "reportedBit", "activeflag", "currentFLAG", "reportedField", "activeFlag", "nextFlag", "activeTag", "currentTag", " currentText", "nextflag", "nextFLAG", "nextTag", "activeFLAG", "CurrentField", "currentText", "currentBit", "CurrentFLAG", "currentflag", "CurrentBit"], "key": ["hash", "k", "here", "base", "kid", "cache", "str", "scope", "id", "exp", "sign", "ace", "path", "check", "function", "KEY", "name", "string", "seed", "section", "lock", "prefix", "step", "or", "lease", "type", "ie", "method", "text", "parent", "rule", "empty", "query", "list", "message", "service", "search", "fee", "Key", "mac", "point", "entry", "data", "ry", "match", "secret", "keys", "field", "fix", "roy", "value", "full", "ey", "part", "msg"], "postList": ["PostList", "POSTList", "PostGroup", "POSTCollection", "postGroup", "POSTGroup", "postlist", " postlist", "POSTlist", " postCollection", " postGroup", "postCollection", "PostCollection", "Postlist"], "url": ["address", "base", "client", "cache", "feed", "URL", "proxy", "path", "log", "sl", "Url", "host", "location", "conn", "string", "image", "link", "build", "org", "ssl", "text", "www", "loc", "socket", "ur", "uri", "service", "resource", "http", "l", "page", "data", "server", "file", "entry", "channel", "director", "web"], "connection": ["position", "client", "connected", "io", "URL", "proxy", "function", "remote", "creator", "connect", "machine", "conn", "out", "to", "section", "c", "database", "character", "communication", "writer", "Connection", "b", "application", "object", "directory", "number", "body", "handler", "config", "socket", " Connection", "uri", "resource", "version", "wrapper", "condition", "document", "http", "l", "channel", "server", "password", "director", "con", "collection", "open", "response", "relation"], "reader": ["client", "feed", "io", "xml", "ler", "row", "er", "input", "stream", "driver", "editor", "read", "Reader", "writer", "r", "body", "handler", "oder", "per", "loader", "parser", "buffer", "iter", "resource", "document", "entry", "data", "file", "server", "channel", "reading", "f"], "builder": ["result", "base", "client", "bean", "db", "xml", "default", "row", "creator", "er", "bridge", "driver", "bug", "image", "builders", "database", "build", "editor", "keeper", "or", "writer", "info", "r", "b", "Builder", "config", "building", "loader", "parser", "buffer", "wrapper", "document", "http", "entry", "runner", "manager"], "doc": ["ger", "md", "base", "project", "gen", "str", "app", "git", "db", "xml", "docs", "df", "div", "node", "context", "bug", "build", "lib", "Doc", "writer", "info", "r", "html", "text", "body", "graph", "parser", "tree", "dc", "resource", "document", "doctor", "dr", "data", "file", "dir", "d", "coll", "open", "f"], "root": ["Root", "error", "leaf", "right", "path", "xml", "div", "name", "section", "writer", "box", "null", "front", "empty", "query", "document", "data", "article", "server", "author", "child", "db", "remote", "ree", "creator", "string", "bot", "component", "user", "rec", "back", "loader", "tree", "parser", "http", "page", "comment", "zero", "result", "project", "roots", "scope", "cover", "valid", "container", "top", "inner", "rt", "parent", "body", "head", "outer", "nav", "director", "rss", "home", "first", "sys", "master", "ver", "default", "owner", "node", "rew", "rup", "archive", "element", "r", "html", "n", "entry", "record", "manager"], "grNamespace": ["grMemberspaces", "grNamescape", "grNamespaces", "grNamespe", "grnamespe", "GrNamespe", "grnamespaces", "Grnamescape", "grnamescape", "grnamesche", "grMemberspaced", "GrNamescape", "Grnamespe", "GrNamesche", "GrNamespaces", "GrNamespace", "grNamespaced", "Grnamespaces", "grnamespace", "Grnamespace", "grnamespaced", "GrNamespaced", "grMembersche", "grMemberspace", "grNamesche"], "namespace": ["namesace", "membersace", "Namesception", " namesace", "xml", "namecape", "memberspace", "membersternal", " namesception", "Namesase", " Namespaced", " namespec", "kespaced", " namespaces", "Namesace", "namespect", " namescore", "namepaces", " namespect", "namespaced", "New", "feed", "kespace", "s", "Namespaces", "Namesternal", "Namespaced", "Namespace", "namesspace", "namescape", "http", " Namespace", " namespaced", "inasspace", "namescore", "memberscape", "inasternal", "nameternal", "kesase", "inasace", "_", "namesternal", "namespaces", "technspace", "memberscore", " namescape", "namepace", " Namespaces", "Namesspace", "inaspace", "namesception", " namesspace", "nameception", "namesase", "Namespect", " Namespec", "workspaces", " namesternal", "technpace", "Namescore", "this", "memberspaces", "workspect", " namesase", "Namescape", "membersspace", "add", "Namespec", "namespec", "worksception", "workspace"], "newflag": [" newFlag", "newstyle", "nextFlag", "lnflag", "newStatus", "nextflag", "lnFlag", " newStatus", "newFlag", "lnstyle", " newstyle", "nextstyle", "lnStatus", "nextStatus"], "title": ["template", "header", "description", "term", "filename", "name", "itles", "itle", "Title", "format", "type", "html", "text", "body", "message", "license", "resource", "version", "Content", "subject", "published", "summary", "details", "label", "author"], "subTitle": ["SubDescription", "ubtitle", "Subtitle", " subtitle", "subDescription", "SubName", " subName", "ubDescription", "subName", "SubTitle", " subDescription", "ubName", "ubTitle", "subtitle"], "entryList": ["ziplist", "elementChain", "entryChain", " entryQueue", "postL", "entrylist", "elementlist", " entryChain", "elementList", " entrylist", " entryLIST", "tryQueue", "entryLIST", "entryQueue", "zipList", "postLIST", " entryL", "entryL", "tryChain", "tryList", "elementQueue", "trylist", "postlist", "zipLIST", "zipL"], "sdf": ["ssfd", " scf", "psdf", "scf", "ascf", "sdd", "psde", "asde", "rsdd", "Sde", "ssdd", "Sfd", "ssde", "rsde", "ssdf", "rsdf", " sdd", " sde", "sde", "pscf", "Sdd", "asdd", "asdf", "sfd", "rsfd", "Sdf", "psdd"], "e": ["oe", "de", "esi", "ed", " event", "ele", "enter", "el", "edge", "pse", " pe", " ie", "Element", "one", "je", "ge", "er", "node", "ea", "te", "end", "ee", "event", "c", "E", " E", "entity", "y", "m", "t", "element", "ie", " me", "r", "en", "ec", "j", "ce", "n", "i", "eu", "o", "ae", "ente", "eb", "p", "ve", "me", "l", "entry", " element", " entity", "se", "line", "d", "ne", "ze", "f", "le", "be"], "post": ["posts", "result", "system", "project", "pod", "tax", "maybe", "feed", "pre", "valid", "child", "load", "check", "one", "default", "cross", "row", "index", "node", "patch", "archive", "set", "next", "upload", "link", "read", "user", "text", "head", "object", "edit", "list", "install", "ost", "the", "p", "add", "form", "copy", "get", "wp", "mod", "page", "entry", "article", "push", "op", "Post", "style", "server", "create", "record", "draw", "POST", "pass", "posted", "home", "part", "comment", "author"], "content": ["template", "header", "description", "status", "output", "path", "name", "language", "archive", "image", "code", "comments", "text", "body", "draft", "message", "media", "version", "resource", "Content", "page", "source", "data", "file", "summary", "value", "script", "size"]}}
{"id1": "16590954", "id2": "5148212", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"createJAR": ["createJPJar", "createJPAP", " createPHAP", "createPHAR", "createPHARS", "createAMARS", "createAMJar", "createPHJar", "createJPARS", " createJAP", "createJARS", " createJARS", "createJJar", " createPHJar", "createPHAP", "createJAP", " createPHARS", "createAMAP", "createJPAR", " createPHAR", "createAMAR", " createJJar"], "fileString": [" filestring", "modelString", "fileName", "loadString", "modelText", "filestring", "Filestring", "fileText", "loadstring", "lineName", " fileFile", " fileName", "fileStream", "FileStream", "FileStr", " fileArray", "basestring", "loadName", "loadText", "linestring", "resourceStream", " fileStr", "FileArray", "baseFile", "baseStr", "fileArray", "FileText", "FileString", "FileName", " fileText", "lineString", "modelStr", "resourceStr", "FileFile", "fileFile", "modelStream", "resourceText", "baseString", "fileStr", "lineArray", "resourceString"], "ext": ["txt", "xt", "class", "external", "Ext", "exe", "zip", "append", "ex", "exp", "version", "str", "dist", "EXT", "path", "desc", "content", " Ext", "app", "url", "x", "config", "enc", "code", "filename", "format", "extra", "v", "data", "type", "ax", "req", "prot", "info", "text", "dep", "name", "end"], "file": ["File", "resource", "folder", "fe", "local", "class", "ger", "use", "line", "full", "zip", "cache", "http", "le", "log", "path", "wave", "force", "queue", "place", "files", "doc", "let", "single", "unit", "build", "it", "up", "l", "part", "base", "pe", "model", "url", "get", "work", "f", "FILE", "per", "bar", "flat", "filename", "h", "socket", "fp", "page", "test", "output", "change", "module", "b", "jar", "parent", "buffer", "source", "ile", "binary", "name", "db"], "i": ["hi", "iu", "si", "qi", "ip", "multi", "ini", "ii", "c", "pi", "limit", "abi", "ci", "di", "key", "slice", "ui", "p", "it", "l", "phi", "j", "I", "eni", "x", "index", "f", "li", "ori", "ind", "ni", "v", "mini", "mi", "ai", "yi", "xi", "uri", "uni"], "dir": ["folder", "class", "zip", "string", "ir", "str", "area", "dist", "path", "manager", "doc", "div", "DIR", "loc", "rel", "base", "domain", "prefix", "tmp", "coll", "url", "cur", "config", "pkg", "Dir", "filename", " directory", "lib", "format", "directory", "output", "data", "direction", "type", "module", "jar", "id", "info", "uri", "src", "name", "db"], "jarFile": ["jarFiles", "archiveFolder", "jarLine", "archiveFiles", "sessionfile", "javaFiles", " jarFiles", "archiveDir", "jarSourceFile", " jarLine", " jarfile", "tarF", "javaSourceFile", " jarSourceFile", "tarSourceFile", "jarF", "tarFile", "javaDir", "archiveFile", "jarFolder", "reportF", "tarfile", "sessionSourceFile", "reportSourceFile", "reportfile", "reportFile", " jarDir", "jarfile", "sessionFile", "jarDir", "javaFile", "tarLine", "javaFolder", "sessionLine", " jarFolder", "javafile", "javaF"], "fstrm": ["Fsrmd", "fbrm", " fsrm", "fstM", "fbrM", "fgrcm", "Fsrcm", "fstum", "fstrmd", "fsrmd", " fsrum", " fsrM", "FsrM", "fstcm", " fstrM", "fstrum", "FstrM", "fstrcm", " fstrum", "fgrmd", "fbrcm", " fsrcm", "Fstrmd", "fstrM", "fgrm", " fstrcm", "fsrcm", "Fstrm", "fstmd", "fstm", "fsrM", "Fstrcm", "Fsrm", "fsrum", "fbrum", "fgrM", "fsrm"], "in": ["In", "pull", "or", "again", "n", "c", "IN", "m", "is", "din", "inner", "bin", "input", "io", "pin", "sync", "ins", "ac", "conn", "min", "inn", "into", "p", "up", "l", "part", "init", "s", "rin", "gin", "read", "f", "inside", "nin", "image", "socket", "to", "login", "reader", "r", "inc", "id", "binary", "stream"], "out": ["resource", "group", "plus", "line", "again", "outside", "c", "channel", "m", "exp", "call", "inner", "bin", "Out", "self", "outer", "io", "outs", "this", "sync", "doc", "conn", "user", "err", "up", "connection", "net", "init", "part", "all", "server", "pool", "off", "image", "to", "plain", "v", "writer", "output", "OUT", "null", "b", "inc", "source", "client", "flow"], "temp": ["folder", "pipe", "wrap", "or", "local", "full", "zip", "c", "cache", "clean", " temporary", "input", "path", "export", "api", "key", "dest", "doc", "archive", "unit", "single", "build", "p", "store", "it", "w", "base", " Temp", "storage", "tmp", "server", "get", "config", "tem", "fake", "f", "iter", "dump", "controller", "home", " tmp", "emp", "writer", "v", "test", "output", "Temp", "directory", "porary", "buffer", "source", "form", "db", "Output", "template"], "fstrm2": ["fhrms1", "fstrM2", "fstrm02", "fstrms2", "fhrms2", "fhrm002", "fstm2", "fstrm1", "fstrM1", "fstrms1", "fstrmr1", "fstrm0", "fhrm2", "fstrM02", "fstrp2", "fstrM0", "fstrmr02", "fhrms002", "fstM1", "fstm0", "fhrms02", "fstrmr002", "fstM2", "fstrmr2", "fstrms002", "fstrm002", "fstrp0", "fhrm1", "fstrms02", "fhrm02", "fstrM002", "fstm1", "fstrp1", "fstrms0", "fstM0"], "ostrm": ["otherrt", "ostmr", "odm", "otherrom", "obsrm", "othermr", "ooprm", "ophm", "ostrob", "oodrem", "obsrt", "istmr", "ostm", "ophmr", "ostrt", "oodrm", "oodrt", "otherrm", "ooprt", "oscrt", "obsrem", "obsrob", "oscmr", "oscm", "ooprom", "odmr", "ostrem", "ophrt", "obrt", "obrom", "ophrm", "oscrm", "obmr", "istrt", "oodrob", "ostrom", "odrt", "odrm", "istrm", "istrom", "oopmr", "obrm"], "docFile": [" docFiles", "docDir", "documentFiles", "DocFile", "docF", " docDir", "documentFile", "documentF", "DocF", "documentDir", "docFiles", "DocDir", "DocFiles", " docF"]}}
{"id1": "8801436", "id2": "11933797", "code1": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copy": ["save", "ize", "rm", "write", " transfer", " cp", "image", "cp", "attach", "ge", "link", "sync", " copying", "zip", "cross", "archive", "paste", "split", "clone", "clip", "type", "download", "process", "move", "cat", "ignore", "Copy", "create", "source", "open", "delete", " Copy", "change", "load", "share", "upload", "transfer", "Cop", "update", "opy", "cop"], "from_file": ["from67files", " from_folder", "from_files", " from_auto", " from_connection", "from_auto", " from_money", " from_File", "from2file", "from_parent", "from_File", " from_class", "from67file", " from_single", "from_folder", " from_files", "from67auto", "fromffiles", " from_function", "from_money", "fromfsingle", "fromingfile", " from_directory", "from_class", "source_cache", "to_files", "from_source", "from_connection", "to_File", "from_user", "from2File", "fromingclass", "from_function", "from2source", "to_source", "from_cache", "to_user", "from_single", "from67directory", "from2files", "fromffolder", "fromffile", "source_file", "from_directory", "fromingmoney", "source_parent"], "to_file": ["to_resource", "tothefile", "from_files", "to_image", "to_global", "tothesource", "To_mail", "to_name", " to_resource", "from_folder", "from_model", "To_resource", "to_folder", " to_directory", "to_get", " to_get", "from_name", "To_directory", "To_file", "to_directory", "to_files", "toPname", "to_mail", "to_model", " to_string", "to_string", "to_source", "toPfile", "from_image", "to_path", "tothefolder", "to_letter", " to_folder", " to_source", "totheglobal", " to_path", "toPfiles", " to_letter", "to_filename", "from_filename", " to_global"], "parent": ["ppa", "null", "term", "data", "part", "search", "pa", "directory", "div", "po", "ac", "cache", "patch", "file", "root", "page", "uri", "unit", "resource", "connection", "par", "Parent", "remote", "parser", "port", "inc", "old", "folder", "and", "test", "type", "key", "tree", "point", "handler", "layer", "path", "content", "ca", "partial", "url", "loc", "anc", "pt", "rule", "parents", "pr", "api", "memory", "section", "size", "any", "id", "function", "location", "pointer", "manager", "child", "session", "it", "pid", "container", "home", "source", "client", "ip", "address", "name", "host", "pool", "current", "fat", "p"], "dir": ["fd", "url", "nav", "build", "dr", "loc", "rel", "manager", "die", "data", "dec", "part", "folder", "group", "entry", "f", " directory", "block", "d", "coll", "dev", "container", "out", "wd", "home", "cur", "dict", "ver", "pkg", "iter", "config", "directory", "di", "keep", "db", "tree", "base", "user", "object", "id", "cache", "po", "div", "ir", "file", "name", "dc", "def", "root", "per", "dis", "path", "or", "Dir", "mod", "director", "doc"], "from": ["pe", "component", "un", "From", "url", "without", "one", "e", "se", "connection", "form", "ce", "io", "empty", "data", "this", "link", "on", "part", "in", "range", "flo", "so", "o", "ch", "hand", "bean", "out", "conn", "code", "source", "add", "parse", "with", "api", "client", "stream", "self", "base", "can", "address", "po", "who", "low", "file", "con", "start", "name", "find", "vol", "by", "up", "left", "per", "get", "auto", "normal", "or", "path", "clean", "query", "http", "cr"], "to": ["page", "too", "url", "one", "server", "b", "connection", "two", "io", "store", "tto", "session", "sync", "this", "socket", "not", "output", "via", "tom", "so", "tool", "flo", "o", "about", "key", "out", "type", "see", "temp", "ver", "source", "made", "TO", "top", "api", "size", "co", "with", "target", "pi", "db", "will", "cache", "po", "token", "file", "name", "be", "by", "t", "per", "thro", "op", "until", "auto", "or", "value", "office", "To", "fat", "http", "on"], "buffer": ["border", "buf", "available", "page", "padding", "default", "message", "resource", "server", "length", "null", "offset", "data", "duration", "Buffer", "channel", "shape", "document", "result", "batch", "read", "row", "texture", "total", "flush", "iter", "memory", "reader", "comment", "header", "buff", "seed", "capacity", "number", "base", "queue", "position", "slice", "variable", "address", "character", "device", "binary", "reference", "layer", "pool", "uffer", "value", "transfer", "block"], "bytes_read": ["bytes_load", "bytes0pass", "es_read", "bytes___found", "keys_found", "bytes___written", "bytes0read", "bytes___read", "bytes0received", "keys___found", "bytes_received", "keys___written", "bytes_write", "keys___read", " bytes_pass", "es_load", " bytes_received", "bytes0write", "es_used", "bytes_allow", "keys_read", "bytes_pass", "keys_written", "bytes_used", "bytes_written", "bytes_found", " bytes_write", "es_allow"]}}
{"id1": "22410173", "id2": "20920051", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "source": ["resource", "route", "use", "site", "Source", "inner", "input", "copy", "ource", "path", "down", "from", "slice", "ins", "unit", "ie", "up", "connection", "base", "url", "size", "iter", "SOURCE", "start", "internal", "sin", "image", "reader", "ources", "target", "id", "parent", "stream", "src", "name", "file"], "dest": ["folder", "temp", "done", "exit", "project", "dist", "bin", "destroy", "desc", "down", "path", "die", "this", "comb", "connection", "orig", "tmp", "delete", "thin", "flat", "home", "Dest", "transfer", "img", "output", "test", "true", "target", " destination", "de", "wb", "src", "name", "later", "file"], "in": ["resource", "In", "pull", "again", "n", "c", "ini", "IN", "m", "cin", "inner", "din", "bin", "src", "input", "as", "con", "this", "pin", "ins", "min", "conn", "inn", "ie", "err", "up", "init", "win", "s", "url", "work", "gin", "f", "inside", "i", "by", "nin", "a", "image", "socket", "start", "file", "login", "reader", "data", "r", "b", "plugin", "inc", "id", "info", "lock", "client", "re", "name"], "out": ["timeout", "temp", "not", "at", "again", "cat", "n", "c", "channel", "o", "option", "call", "ex", "exp", "inner", "bin", "with", "Out", "self", "log", "outer", "io", "outs", "this", "sync", "conn", "no", "our", "err", "up", "connection", "init", "net", "w", "exec", "url", "index", "pool", "off", "password", "i", "lib", "socket", "plain", "writer", "to", "ext", "img", "output", "ou", "write", "data", "obj", "OUT", "vert", "inc", "id", "parent", "client", "name", "file", "extra"]}}
{"id1": "12055086", "id2": "20375440", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copyDeleing", " copyDeleteting", " copydeleter", " copyDequeting", " copyDeleteging", " copyDeleteter", " copyDeletter", " copydeleting", " copyDequeing", " copyDequeter", " copyDeletting", " copydeletting", " copydeleging", " copyDeleter", " copydeletging", " copyDeleteing", " copyDequeging", " copyDeletging", " copydeletter", " copyDeleging", " copydeleing"], "source": ["resource", "route", "use", "cache", "Source", "view", "inner", "service", "input", "copy", "ource", "down", "path", "from", "archive", "ie", "connection", "base", "s", "storage", "config", "f", "iter", "e", "i", "image", "SOURCE", "sin", "remote", "reader", "ources", "target", "stream", "master", "src", "site", "file"], "dest": ["folder", "pipe", "temp", "done", "slave", "class", "exit", "opt", "dist", "bin", "master", "destroy", "desc", "path", "die", "slice", "content", "dir", "comb", "default", "trans", "orig", "destruct", "tmp", "thin", "flat", "home", "Dest", "result", "img", "target", " destination", "de", "null", "wb", "src", "later", "file"], "buf": ["txt", "bh", "vec", "append", "cv", "ctx", "bd", "feed", "queue", "pad", "length", "seq", "bp", "loc", "batch", "br", "bag", "ff", "base", "pos", "rc", "cp", "cmd", "port", "tmp", "config", "bc", "Buffer", "code", "len", "off", "uf", "uc", "bytes", "cb", "result", "img", "data", "raw", "feat", "b", "bf", "buff", "fb", "buffer", "src", "rb"], "in": ["In", "plus", "stream", "again", "n", "c", "ini", "IN", "is", "din", "inner", "bin", "input", "con", "io", "pin", "ins", "min", "conn", "inn", "p", "up", "isin", "init", "win", "rin", "exec", "url", "gin", "read", "thin", "f", "inside", "i", "nin", "image", "socket", "sin", "login", "file", "reader", "data", "b", "inc", "id", "tin", "src"], "out": ["again", "at", "n", "o", "ex", "exp", "inner", "bin", "Out", "outer", "down", "io", "outs", "sync", "conn", "err", "up", "app", "part", "w", "win", "exec", "f", "pool", "i", "image", "lib", "socket", "writer", "ext", "img", "output", "obj", "OUT", "b", "inc", "parent", "buffer", "client", "file"], "count": ["ch", "use", "n", "c", "cache", "current", "zip", "depth", "limit", "sum", "path", "feed", "Count", "number", "key", "num", "length", "child", "weight", "part", "base", "all", "cond", "coll", "max", "size", "read", "index", "f", "pool", "code", "len", "allow", "ind", "start", "close", "val", "handle", "type", "b", "id", "lock", "offset", "parent", "buffer", "name"]}}
{"id1": "1986417", "id2": "8047989", "code1": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"export": ["process", "output", " exports", "print", "write", "handler", " upload", "module", "io", "fp", "work", "function", "fn", "file", " reporter", " output", "f", " report", "exec", " transform", " fn", " writer"], "lib": ["db", "os", "ruby", "script", "ctx", "src", " libraries", "Lib", "lc", "server", " script", "val", "module", "ler", "editor", "io", "library", "fn", " library", "file", "LIB", "url", " Library", "Library", "data", "lang", "loader", " fn", "local", "log", "dl", "language", " module", " Lib", "l", "bin", "browser", "plugin", "reader", "ld", "loop", "ino", "config", "dll"]}}
{"id1": "18339787", "id2": "5998352", "code1": "    private void reload() {\n        if (xml != null) {\n            try {\n                String currentDate = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date());\n                if (currentDate.equalsIgnoreCase(exchangeRateDate)) {\n                    return;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        XPath xpath = null;\n        try {\n            DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            URLConnection conn = null;\n            URL url = new URL(\"http://www.ecb.int/stats/eurofxref/eurofxref-daily.xml\");\n            conn = url.openConnection();\n            xml = docBuilder.parse(conn.getInputStream());\n            xpath = XPathFactory.newInstance().newXPath();\n            exchangeRateDate = xpath.evaluate(\"/Envelope/Cube/Cube/@time\", xml);\n            xpath = XPathFactory.newInstance().newXPath();\n            NodeList currenciesNode = (NodeList) xpath.evaluate(\"/Envelope/Cube/Cube/Cube[@currency]\", xml, XPathConstants.NODESET);\n            currencies = new String[currenciesNode.getLength()];\n            for (int i = 0; i < currencies.length; i++) {\n                currencies[i] = currenciesNode.item(i).getAttributes().getNamedItem(\"currency\").getTextContent();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "label": 0, "substitutes": {"reload": ["overload", "reloading", "preload", "refload", "reffill", "preloading", "prefill", "overresh", "overloading", "refresh", "preresh", "refloading", "reresh", "overfill", "refill"], "currentDate": ["currentDay", " currentTime", "newUpdate", " currentDay", "reportedTime", "currentUpdate", "newDay", "CurrentTime", " currentName", "newDate", "currentName", " currentUpdate", "reportedDate", "currentKey", "newKey", "CurrentKey", "CurrentDate", "CurrentDay", "reportedName", "CurrentUpdate", " currentKey", "currentTime", "reportedDay", "CurrentName"], "xpath": ["exPath", " xparent", " xstream", "Xath", "lexstream", "expath", "axpath", " xPath", "XPath", " xcase", "Xp", "lexparent", "xPath", "lexpath", "xcase", "axath", "xstream", "exp", "Xstream", "txstream", " xath", "Xcase", "xp", "xparent", "xprop", "lexPath", "Xpath", "exstream", "txpath", " xp", "exparent", " xprop", "Xprop", "xath", "axPath", "exprop", "exath", "txPath", "axcase"], "docBuilderFactory": ["docbuilderFactor", "projectBuilder2", "projectBuilderInterface", "projectBuilderFactory", "docBuilderFactor", "docManagerInterface", "docBuildService", "documentBuildService", "docbuilderFactory", "docManagerFactory", "docBuilderF", "docBuilderInterface", "docBuilder2", "projectbuilder2", "docbuilderService", "projectbuilderInterface", "documentBuilderF", "projectbuilderFactor", "docBuild2", "docBuildFactory", "projectBuilderFactor", "documentBuilderService", "docManager2", "docBuildFactor", "docbuilder2", "docBuildF", "docBuilderService", "docbuilderInterface", "documentBuilderFactory", "projectbuilderFactory", "documentBuildF", "documentBuildFactory", "docManagerFactor", "docbuilderF", "docBuildInterface"], "docBuilder": ["docFactory", "documentFactory", "fileBook", "documentParser", "documentBuilder", "xmlParser", "documentBuild", "documentbuilder", "docParser", "Docbuilder", "documentBook", " docBuild", "docbuilder", "fileBuilder", " docBook", " docFactory", "DocParser", "xmlbuilder", "docBook", "fileFactory", "DocBuild", "xmlBuilder", "DocBuilder", "fileBuild", "docBuild", "xmlBuild"], "conn": ["conv", "log", "ssl", "ct", "cn", "server", "uc", "conf", "cp", "connection", "loc", "lock", "body", "cmd", "session", "socket", "channel", "Connection", "connect", "URL", "nt", "coll", "ch", "nc", "ci", "cb", "out", "Conn", "cm", "api", "config", "client", "cli", "l", "db", "ann", "exec", "con", "c", "loader", "ctx", "path", "Url", "lc", "enc", "http", "serv"], "url": ["ls", "log", "ssl", "uri", "ll", "resource", "server", "fr", "image", "build", "connection", "org", "data", "blog", "channel", "f", "impl", "www", "URL", "str", "coll", "bel", "download", "config", "client", "l", "web", "db", "base", "string", "gl", "file", "err", "loader", "ob", "sl", "host", "path", "Url", "http", "feed", "serv"], "xml": ["page", "doc", "rss", "log", "writer", "arr", "txt", "image", "wt", "html", "example", "event", "apache", "data", "model", "document", "zip", "input", "graph", "date", "children", "el", "element", "temp", "wl", "parse", "config", "reader", "atom", "stream", "tree", "node", "email", "layout", "address", "file", "ml", "root", "php", "context", "json", "path", "response", "x", "content", "office", "events", "update", "dom", "http", "feed", "request"], "exchangeRateDate": ["expirePricePrice", "exchangeRateFile", "excurrencyRateDuration", "exchangeRateTime", "exchangeRatingPrice", "exchangeWeightPrice", "exchangeFactorTime", "expireRateDate", "exchangeTimeFile", "excurrencyRateFile", "exchangePricePrice", "exchangePriceKey", "exchangePriceDate", "exchangeRateDuration", "exchangeWeightDate", "exchangeRatingFormat", "exchangeRatingDate", "expirePriceFormat", "exchangePriceFormat", "excurrencyRateTime", "exchangeTimeDate", "exchangeRatingKey", "exchangeTimeDuration", "expirePriceDate", "excurrencyTimeDate", "exchangeTimeTime", "excurrencyTimeDuration", "expireRateKey", "expirePriceKey", "exchangeRateKey", "exchangeWeightKey", "exchangeRateFormat", "excurrencyTimeFile", "excurrencyTimeTime", "expireRatePrice", "expireRateFormat", "exchangeWeightFormat", "exchangeFactorFile", "excurrencyRateDate", "exchangeFactorDate", "exchangeFactorDuration", "exchangeRatePrice"], "currenciesNode": ["curcurrencyPath", "currenciesBlock", "curcurrencyNode", "contractrenciesDocument", "curportsNode", "courrenciesnode", "curatorsNode", "comrenciesNode", "comrenciesPath", "currenciesPath", "cururrenciesnode", "currenciesRoot", "curatorsArray", "courrenciesContainer", "contracturrenciesBlock", "cururrenciesContainer", "comportsBlock", "curportsPath", "currenciesnode", "contracturrenciesRoot", "comportsPath", "contracturrenciesNode", "currenciesArray", "cururrenciesBlock", "corenciesNode", "curitiesnode", "curatorsnode", "currenciesContainer", "curlationsElement", "curriesRoot", "curlationsBlock", "contractrenciesNode", "contracturrenciesDocument", "curitiesArray", "curportsElement", "currenciesElement", "curportsBlock", "corenciesnode", "curitiesContainer", "courrenciesNode", "cururrenciesArray", "curcurrencyBlock", "curatorsContainer", "curitiesNode", "curlationsPath", "curratesRoot", "curriesNode", "curratesDocument", "currenciesDocument", "contractrenciesBlock", "comrenciesElement", "curriesDocument", "corenciesArray", "cururrenciesDocument", "cururrenciesRoot", "comportsElement", "comportsNode", "curriesBlock", "comrenciesBlock", "contractrenciesRoot", "curlationsNode", "corenciesContainer", "courrenciesArray", "curcurrencyElement", "curratesNode", "curratesBlock", "cururrenciesNode"], "currencies": ["locales", "chcoins", "curacters", "charrencies", "scherency", "urversions", "urums", "curums", " currency", " curversions", "churrency", "peracters", " curacters", " curums", "cururrency", "curversions", "scherencies", "curales", "curcoins", "locurrency", "cururrencies", "charrency", "perversions", "carrencies", "uracters", "carcoins", "perrencies", " curries", "chales", "chrencies", "scheurrencies", "perums", "loccoins", "carurrency", "scheries", "urrencies", " cururrencies", "charurrencies", "carales", "charries", "locrencies", "curries", "currency"], "i": ["m", "u", "z", "uri", "e", "j", "b", "g", "n", "fi", "io", "info", "si", "in", "f", "it", "o", "index", "ci", "iu", "oi", "ji", "end", "abi", "multi", "y", "li", "di", "l", "ip", "pi", "xi", "hi", "eni", "slice", "r", "yi", "id", "ti", "v", "gi", "c", "start", "t", "ri", "I", "ai", "phi", "chi", "ii", "ui", "x", "mu", "qi", "bi", "lc", "q", "p"]}}
{"id1": "22993368", "id2": "14691829", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "5760649", "id2": "18451704", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public boolean isValidPage(BookPage page) {\n        boolean isValid = false;\n        try {\n            if (page.getType() == BookPage.TYPE_RESOURCE) {\n                BookPagePreviewPanel panel = new BookPagePreviewPanel(dControl, true);\n                panel.setCurrentBookPage(page);\n                isValid = !page.getUri().equals(\"\") && panel.isValid();\n            } else if (page.getType() == BookPage.TYPE_URL) {\n                URL url = new URL(page.getUri());\n                url.openStream().close();\n                isValid = true;\n            } else if (page.getType() == BookPage.TYPE_IMAGE) {\n                if (page.getUri().length() > 0) isValid = true;\n            }\n        } catch (Exception e) {\n            isValid = false;\n        }\n        return isValid;\n    }\n", "label": 0, "substitutes": {"createFile": ["CreateResource", "saveFolder", "createContent", "CreateFolder", " createContent", "createResource", "saveFile", "CreateFile", "saveResource", " createFolder", "saveContent", "createFolder", " createResource", "CreateContent"], "src": ["SourceFile", "buf", "fn", "rss", "url", "txt", "uri", "resource", "rob", "ssl", "dest", "loc", "rc", "data", "username", "sb", "Source", "input", "rb", "href", "cb", "s", "source", "ruby", "stream", "files", "resources", "slice", "r", "sc", "sit", "string", "load", "file", "obj", "upload", "gb", "name", "sl", "sel", "proc", "path", "content", "secure", "fp", "img"], "filename": ["ame", "SourceFile", "prefix", "fn", "url", "uri", "txt", "FILE", "resource", "sf", "length", "acl", "username", "title", "output", "f", "route", "nil", "s", "dll", "source", "metadata", "directory", "rl", "l", "fil", "files", "which", "Filename", "string", "file", "ames", "name", "loader", "wb", "location", "path", "utf", "fp", "ename", "feat"], "fis": ["fais", " fiss", "cfais", "sfiss", "sfris", " fIS", "cfIS", "Fos", "cfbs", "Fris", "fbs", "fris", "sfos", "cfis", "Fiss", " fris", "Fais", "FIS", "fiss", "cfris", " fais", "fIS", "sfis", "cfos", "Fbs", " fbs", "Fis"], "fos": ["foros", "Fas", "foris", "fOS", "affos", "Fops", "Fos", "affbos", "affios", "sfos", "foras", "bis", "bbos", "fas", "Fbos", "bos", " fas", " fops", " fOS", "fios", "Fios", "affis", "fops", "sfis", "fbos", "forOS", "sfops", "FOS", " fios", "sfios", "bios", "Fis"]}}
{"id1": "19849797", "id2": "17773263", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 0, "substitutes": {"copyFile": ["clonefile", "copyFiles", "transferfile", "copySource", "cloneFiles", "transferSource", " copySource", "transferFiles", " copyfile", "cloneSource", "transferFile", "copyfile", "cloneFile", " copyFiles"], "sourceFile": [" sourceDir", "ourceDirectory", "sourceUrl", "ourceUrl", "srcDir", "srcFile", " sourceFolder", "sourceFolder", "ourceFile", "SourceUrl", "srcfile", " sourcefile", "destfile", "SourceDirectory", "SourceFile", "ourcefile", "sourcefile", "sourceDirectory", "srcFolder", "destUrl", "Sourcefile", "SourceFolder", "destDirectory", "sourceDir", "SourceDir"], "destFile": ["destFiles", "targetFiles", "sourceFiles", "resultDir", "destLine", "DestFiles", " destfile", "destDir", "destPoint", "DestDirectory", "resultfile", "Destfile", "srcFile", "srcDir", "targetDir", "targetFile", "foreignFile", "srcfile", "foreignPath", "DestFile", "destPath", "targetfile", "DestPoint", "destfile", "targetLine", " destFiles", "targetPath", "foreignFiles", "resultFile", "DestDir", " destPoint", "foreignfile", " destDir", "srcDirectory", " destDirectory", "DestPath", "resultLine", "sourcePoint", "destDirectory", "srcFiles", "sourceDir", "srcLine"], "source": ["ource", "slave", "url", "result", "client", "reader", "cache", "status", "scope", "output", "site", "use", "id", "view", "current", "proxy", "scene", "index", "input", "target", "session", "start", "context", "core", "seed", "remote", "stream", "inner", "secure", "image", "Source", "this", "si", "storage", "component", "reference", "connection", "ie", "root", "route", "null", "object", "parent", "sin", "dest", "config", "slice", "table", "uri", "service", "resource", "api", "wrapper", "iter", "get", "from", "channel", "file", "server", "src", "unit", "size", "manager", "ce", "SOURCE"], "destination": ["participinate", "destinator", "generination", "Destinated", "dominated", "constinator", "identination", "distination", "construction", "distion", "participinator", "Destination", "domination", " destribution", "constribution", "domation", "Destribution", "Destruction", "destribution", " destinator", "destation", "Destation", "generruction", "destion", "identinator", "destinate", " destruction", "participinated", " destinated", " destation", "destinated", "participination", "distruction", "destruction", "dominator", "distinated", "distinator", "Destion", " destion", "Destinate", "constination", "generinator", "identinate", "generinated", "Destinator", "identinated"]}}
{"id1": "21488518", "id2": "13783549", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"createNew": ["openResource", "createCopy", "openNew", "newNew", "openOpen", "createResource", "resourceCopy", "resourceResource", "newOpen", "newResource", "newCopy", "resourceNew", "openCopy", "resourceOpen", "createOpen"], "name": ["image", "client", "self", "large", "size", "one", "n", "full", "key", "class", "old", "label", "comment", "default", "common", "ix", "title", "parent", "e", "id", "office", "directory", "on", "address", "ame", "ui", "alias", "connection", "code", "content", "time", "path", "resource", "ext", "word", "value", "file", "part", "NAME", "end", "x", "url", "prefix", "no", "none", "base", "model", "data", "type", "missing", "Name", "number", "search", "names", "anc", "member", "style", "string", "ename", "named", "folder", "non", "current", "filename", "username"], "in": ["image", "buffer", "size", "src", "i", "init", "input", "slice", "thin", "id", "din", "plus", "diff", "connection", "inner", "resource", "ini", "raw", "file", "work", "con", "len", "pass", "exec", "login", "data", "ins", "record", "bin", "In", "reader", "IN", "read", "win", "source", "up", "inc"], "length": ["timeout", "buffer", "level", "size", "bytes", "load", "sequence", "ength", "id", "limit", "padding", "Length", "content", "path", "time", "line", "count", "len", "url", "type", "offset", "number", "width", "password", "body", "duration", "filename"], "contentType": ["ContentLength", "contentPath", "resourceLength", " contenttype", "resourceType", "contenttype", " contentLength", "ContentType", "resourcePath", "Contenttype", "contentLength", "resourcetype", " contentPath", "ContentPath"], "dest": ["de", "tx", "upload", "src", "output", "tmp", "comb", "opt", "parent", "thin", "route", "home", "Dest", "target", "result", "dc", "desc", "orig", "later", "img", "conf", "sup", "cdn", "dist", "store", "dir", "trip", "wb", "zip", "temp", "flat", "trans", "done", "transform", " destination", "d", "prop", "folder", "destroy", "gz", "cont", "tif", "source", "config", "txt"], "out": ["Out", "image", "client", "writer", "buffer", "obj", "sync", "up", "output", "socket", "object", "view", "copy", "parent", "ex", "page", "cache", "server", "conn", "result", "connection", "exp", "path", "resource", "ext", "io", "pool", "img", "line", "file", "f", "url", "o", "null", "this", "exec", "zip", "channel", "data", "temp", "err", "log", "bin", "password", "again", "outs", "lock", "cmd", "gz", "flush", "source", "OUT"], "request": ["get", "job", "client", "buffer", "rate", "access", "query", "upload", "rer", "transfer", "object", "use", "user", "input", "instance", "reference", "route", "directory", "complete", "open", "child", "ext", "report", "resource", "path", "response", "xml", "quest", "store", "url", "req", "forward", "base", "type", "pe", "wheel", "call", "Request", "friend", "remote", "project", "QUEST", "respect", "re", "external", "config", "claim"]}}
{"id1": "2521141", "id2": "4468255", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "image", "clone", "sync", "upload", "ize", "cp", "transfer", "delete", "Copy", "load", "write", "cat", "directory", "archive", " cp", "ame", "open", "source", "diff", "share", "rm", "clip", "cop", "ignore", "change", "file", "ge", "link", "update", "zip", "download", "create", "type", "pe", "paste", "attach", "dump", "opy", "config", "move"], "from_name": ["from_names", "from__name", " from_names", "from_memory", "to_path", "from_key", "fromFfilename", "fromFname", "source_filename", "fromMname", "source_memory", "from_filename", "to_filename", "source_name", " from_Name", "from__path", "fromFpath", "from__memory", "from_path", "fromMnames", "fromFmemory", "fromMfile", "source_path", " from_key", "from_Name", "from__filename"], "to_name": ["toamname", "toamhome", "to_home", "toampath", "to_path", " to_Name", "to_Name", " to_path", "from_path", "from_filename", "toamfile", "to_filename", " to_home"], "from_file": ["fromappfunction", "from_directory", " from__auto", "from__name", "from_brain", "from___filename", "from_resource", "from_source", "from___file", " from__filename", " from__file", " from_directory", "source_filename", "source_directory", "fromCfile", "remote_lane", "from__files", " from_filename", " from__name", "from__directory", "from__resource", "fromCname", "remote_function", "from_function", "from_filename", "from___name", "from_lane", "remote_log", "fromCbrain", "source_brain", " from_folder", "source_name", " from_auto", "source_files", "remote_file", " from_files", "fromapplane", "from_auto", "from_log", " from_source", "from_files", "fromCfilename", "fromappfile", "from__file", "from_folder", "fromapplog", "source_resource", "from__filename", "from__auto", "source_file", "from___auto"], "to_file": ["to64use", "to_model", "tojfile", "intojfile", "eto___remote", "intojfunction", "into_use", "to__dir", "eto_remote", "from_model", "to64name", "to_remote", "to_binary", "source_filename", "to_server", "to67load", "eto_file", "intojname", "intojuse", "to___remote", "tojuse", " to_class", "into_function", "to67dir", " to_queue", "to__name", "to_filename", "from_bar", "source_server", "to_queue", "to_dir", "to67name", "eto___name", "toJstream", "to__load", "to64file", " to_model", "to64function", "into_file", "toJfile", "to___name", "to_class", "tojfunction", "source_files", "eto_name", "from_dir", "to67file", " to_filename", "to_stream", "to___file", "from_files", "from_stream", "from_load", "to_function", "toJbar", "eto___file", " to_files", "to_files", "to_load", "to_use", "tojname", "into_name", "to_bar", "toJname", "from_binary", "to__file", "source_file"], "parent": ["size", "author", "old", "global", "complete", "address", "target", "content", "container", "Parent", "root", "api", "test", "search", "name", "string", "folder", "am", "uri", "ip", "client", "p", "full", "pa", "user", "page", "patch", "rule", "cache", "home", "loc", "path", "pool", "file", "part", "unit", "div", "any", "ac", "inc", "ppa", "tree", "host", "id", "directory", "port", "per", "child", "out", "manager", "function", "url", "null", "memory", "remote", "point", "source", "term", "mother", "par", "owner", "po", "handler", "server", "or", "connection", "fat", "location", "resource", "session", "type", "temp", "parents", "current"], "dir": ["r", "db", "in", "entry", "block", "def", "class", "object", "user", "global", "dict", "cat", "dec", "id", "directory", "coll", "cache", "home", "per", "md", " directory", "loc", "group", "module", "or", "dr", "ver", "dc", "container", "path", "dep", "cur", "io", "exp", "ir", "out", "manager", "wd", "file", "root", "director", "part", "build", "iter", "f", "url", "die", "doc", "data", "div", "rel", "keep", "Dir", "name", "di", "d", "folder", "tr", "lock", "dev", "nav", "dis"], "from": ["when", "get", "auto", "From", "fr", "client", "component", "flo", "left", "one", "entry", "stream", "form", "ce", "view", "feed", "context", "ou", "parse", "e", "cr", "cf", "cache", "server", "address", "per", "fe", "conn", "or", "connection", "http", "low", "io", "se", "cor", "cm", "ra", "con", "file", "find", "part", "who", "start", "link", "url", "ch", "this", "api", "base", "normal", "with", "pe", "range", "can", "so", "name", "bean", "by", "without", "two", "empty", "add", "source", "self", "vol"], "to": ["auto", "db", "su", "client", "that", "flo", "size", "too", "sync", "one", "output", "socket", "proxy", "write", "on", "po", "tto", "office", "To", "t", "server", "per", "conn", "thro", "target", "or", "connection", "fat", "http", "TO", "fb", "ver", "io", "top", "op", "see", "not", "out", "value", "dest", "file", "storage", "store", "pi", "o", "until", "api", "base", "will", "session", "type", "with", "token", "via", "so", "co", "by", "as", "two", "about"], "buffer": ["position", "writer", "shape", "batch", "block", "queue", "texture", "transfer", "default", "comment", "feed", "character", "slice", "reference", "bb", "page", "Buffer", "server", "address", "source", "padding", "message", "resource", "buff", "row", "uffer", "iter", "url", "buf", "binary", "channel", "null", "data", "b", "border", "number", "wave", "document", "total", "memory", "reader", "variable", "header", "seed", "duration", "window", "read", "flush", "layer", "length"], "bytes_read": ["gets___pass", "bytesXbefore", "gets___allow", "byte_current", "byte_load", " bytes_en", "bytes___reads", "bytes_en", "gets_allow", "byteslexread", " bytes_found", "bytes___allow", " bytes_write", "bytes_found", "bytesXload", "bytes_reads", "bytesXread", "byte_before", "bytes_allow", "bytes_pass", "bytes_load", "bytesXcurrent", "bytes_write", "bytes_before", "bytes___read", "gets___read", "gets_reads", "gets___reads", "bytes___pass", "gets_pass", "bytes_current", "byteslexload", "byte_read", "gets_read", "byteslexbefore", "byteslexcurrent"]}}
{"id1": "16557837", "id2": "19739421", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"copyFromTo": ["transferfromFile", "copyfromFile", "copyFileFrom", "copyFromFile", "copyFromFrom", "transferFromTo", "copyFromWith", "transferfromWith", "transferFromFrom", "copyDirTo", "copyDirFrom", "copyfromTo", "copyfromFrom", "copyDirFile", "copyFileWith", "copyFileFile", "copyDirWith", "transferFromWith", "transferfromTo", "transferFromFile", "transferfromFrom", "copyfromWith", "copyFileTo"], "srcFile": ["sourceDir", "srcfile", "destfile", "rcFiles", "sourceSourceFile", "rcFile", "srcPage", "destDir", "srcSourceFile", "rcDir", "srcPath", " srcPage", "rcfile", "sourcePath", " srcSourceFile", "srcClass", " srcClass", " srcDir", " srcFiles", "sourceClass", "srcFiles", "sourcefile", " srcfile", "rcSourceFile", " srcPath", "sourceFiles", "rcPage", "destClass", "rcPath", "destPage", "srcDir", "destSourceFile", "sourceFile", "destFiles"], "destFile": [" destinationFine", "destfile", " destFilename", "Destfile", " destinationPage", "wbFiles", "southFile", " destPath", " destDir", "destDir", "destPlace", "destFine", "destFilename", "destroyPage", "destroyFile", "DestDir", "defaultfile", "DestFiles", "defaultDir", "destPath", " destinationfile", " destPage", "targetDir", "targetFiles", "defaultFiles", " destFiles", "targetFile", "southPlace", "defaultFile", "destroyFilename", " destinationFile", "wbFilename", " destinationFilename", " destFine", "targetPath", "DestSourceFile", " destfile", "southFilename", "DestFile", "srcPlace", " destSourceFile", "destPage", " destinationFiles", "destroyFine", "srcDir", " destPlace", " destinationDir", "destSourceFile", "DestPath", "southDir", "srcFilename", "destFiles", "wbSourceFile", "DestFilename", "wbFile"], "in": ["p", "x", "source", "as", "init", "inn", "pin", "inner", "c", "ac", "f", "i", "input", "socket", "inside", "image", "ci", "IN", "con", "win", "ini", "io", "n", "bin", "isin", "url", "b", "is", "nin", "min", "index", "ins", "h", "connection", "channel", "cin", "Out", "lin", "In", "inc", "again", "like", "rin", "file", "part", "pull", "r", "err", "login", "o", "reader", "id", "din", "co"], "out": ["source", "cache", "json", "session", "extra", "to", "image", "down", "comment", "url", "base", "name", "log", "ext", "code", "post", "channel", "write", "In", "off", "key", "error", "pre", "group", "copy", "client", "sync", "this", "dump", "OUT", "conn", "IN", "writer", "win", "io", "up", "job", "ou", "obj", "term", "raw", "auto", "outs", "lib", "cli", "diff", "user", "parent", "bin", "call", "output", "point", "state", "note", "input", "socket", "line", "sys", "resource", "ger", "outer", "gen", "ico", "string", "prefix", "Out", "o", "inc", "doc", "no", "net", "inner", "c", "store", "page", "cmd", "ex", "window", "server", "exec", "query", "connection", "list", "lock", "again", "file", "part", "err", "co"], "fis": ["flios", "foss", "cfios", "cfris", "flis", "flos", "cfi", "gi", "pris", "his", " foss", "pos", "hos", "fris", "hios", "Fos", "lis", "pis", "Fis", "gos", " fais", "frris", "fais", " fIs", "los", "cfis", "Fris", " fi", "lais", "li", "fios", "hi", "fli", "gais", "cfoss", "fross", "fi", "fIs", "pIs", "fros", "FIs", "cfos", "gis", " fris"], "fos": ["infos", "foss", "Faos", "tis", "bos", "foes", "flos", "boes", "Fo", "Foes", "eis", "gose", "gout", "po", "pos", "faos", "Fos", "flose", "infoss", "lis", "fics", "pis", "Fis", "fout", "gos", "infis", "flo", " foes", "fo", " fout", "poes", "bics", "los", "fose", " fo", "toes", "infose", "eos", "tos", "loss", "flout", "eose", " faos", "tics", "paos", "bis", "eoss", "lose", " fose", " fics", "go"], "srcModified": ["srcMinIFIED", " srcModification", "srcModined", "srcMinified", "srcXined", " srcModressed", "srcModIFIED", "sourceModification", "srcXification", "sourceMinify", "sourceModify", "srcModification", "srcVerined", "srcModressed", "sourceMinIFIED", " srcModIFIED", "srcMetification", "sourceModified", "srcXed", "srcModed", "sourceModIFIED", "srcmodIFIED", "srcMetIFIED", "srcmodified", "sourceMinified", " srcModed", " srcModined", "srcMinification", "srcmodressed", "srcVerified", "srcMetified", "srcMetressed", "srcModify", "srcMinify", "srcVerification", "srcXified", "srcVered", "srcmodification", "srcmodify", "sourceMinification"]}}
{"id1": "701029", "id2": "20602651", "code1": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n", "code2": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "label": 1, "substitutes": {"loadSourceCode": ["getSourcecode", "loadSourcecode", "loadCodecode", "getSourceCode", "loadCodeCode", "loadSourceFile", "getSourceFile", "loadCodeFile", "loadsourceFile", "loadsourcecode", "loadsourceCode"], "length": ["position", "buffer", "size", "shape", "ph", "capacity", "block", "full", "key", "class", "load", "version", "delay", "page", "id", "limit", "address", "open", "th", "Length", "code", "content", "time", "path", "weight", "ext", "library", "value", "count", "work", "build", "angle", "len", "part", "end", "depth", "base", "zip", "data", "type", "L", "number", "text", "width", "total", "name", "l", "style", "string", "duration", "lock", "read", "filename"], "file": ["get", "image", "db", "buffer", "full", "files", "flow", "class", "object", "use", "feed", "il", "e", "page", "File", "check", "fe", "connection", "filename", "http", "path", "resource", "io", "fp", "FILE", "book", "f", "fs", "base", "data", "pe", "loader", "log", "b", "force", "name", "l", "folder", "play", "source", "self"], "buff": ["buffer", " background", "bb", " style", "Buffer", " Buffer", " text", " chunk", " buffer", " char", "Buff", " arr", "buf", " chars", "ch", " ch", "uf", "comp", "text", "utf", " rest", " buffers", " buf", "txt"], "is": ["get", "r", "os", "in", "ip", "fr", "Is", "p", "bis", "ie", "isl", "isa", "src", "i", "s", "ib", "il", "isi", "es", "address", "ris", "loc", "IS", "ui", "or", "iss", "http", "isc", "resource", "io", "ob", "ir", "out", "ais", "abs", "sr", "api", "serv", "ri", "err", "are", "it", "l", "res", "ar", "as", "web", "ur", "uri", "iv"], "isr": ["issri", "ISrc", "Isrs", "arsr", "isrr", "isri", "ISri", "Isrb", " isrb", "isrc", "asr", " isrc", "bsrt", "bsr", "isrb", "asrb", " isri", "isrt", " islr", "servrr", "servr", "servrt", "aslr", "bsrar", "issrb", "Islr", "asrs", "bsrr", "israr", "islr", " isrs", "arsrt", "ISrb", "Isr", "issrc", "isrs", "arsrar", "servrar", "arsrr", "issr", "ISr"], "cv": ["sc", "ctx", "cp", "rc", "view", "cc", "VC", "uv", "ctr", "nv", "gg", "lc", "cf", "lv", "vm", "cu", "bc", "cur", "cm", "vp", "vv", "fc", "tc", "hw", "ctrl", "CV", "conv", "vc", "vert", "b", "v", "cam", "cpp", "vr", "vs", "mc", "sv", "cb", "c"], "url": ["lr", "r", "image", "blog", "fr", "sl", "stream", "rl", "host", "view", "el", "feed", "fl", "il", "id", "page", "server", "address", "loc", "http", "location", "URL", "resource", "path", "ob", "ssl", "str", "link", "f", "Url", "api", "base", "err", "download", "loader", "log", "name", "l", "string", "web", "ur", "uri", "re", "source"], "reader": ["r", "in", "buffer", "writer", "ner", "cher", "worker", "Reader", "stream", "rer", "i", "rc", "roller", "ger", "rx", "ry", "handler", "server", "or", "ler", "http", "inner", "war", "resource", "editor", "io", "ir", "rr", " readers", "row", "reading", "rar", "iter", "re", "ri", "builder", "loader", "player", "er", "oder", "l", "parser", "ser", "read", "holder", "source", "bird"], "sourceCode": ["SourceScript", " sourceContent", " sourceFile", "ourcecode", "proxyCode", "parentText", "Sourcecode", "parentCode", " sourceText", "ourceContent", "SourceLine", " sourceScript", "ourceFile", "byteCode", "parentcode", "proxyFile", "SourceContent", "SourceCode", "sourceScript", "byteLine", "sourceLine", "sourceFile", "ourceScript", "sourcecode", "ourceCode", "proxycode", "sourceText", "ourceText", "bytecode", "sourceContent", " sourceLine", " sourcecode"], "line": ["next", "auto", "error", "ip", "in", "position", "sync", "one", "lf", "sl", "entry", "element", "key", "cell", "pre", "comment", "object", "character", "write", "on", "parse", "id", "page", "lc", "office", "lines", "Line", "lin", "code", "content", "li", "message", "day", "word", "hide", "row", "str", "end", "link", "part", "liner", "letter", "no", "none", "base", "unit", "inline", "model", "data", "LINE", "number", "text", "record", "l", "frame", "body", "string", "le", "source", "c", "non"]}}
{"id1": "21656668", "id2": "8079516", "code1": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"copyResourceToFile": ["copyResourceAsFile", "copyResourcesToResource", "copyResource2Files", "copyResourcesFromFile", "copyResourceAsFiles", "copyResourcesToFolder", "copyResource2Resource", "copyResourcesFromFiles", "copyResourcesToFiles", "copyResourcesFromResource", "copyResourceToFolder", "copyResourceToFiles", "copyResourceFromFile", "copyResourceAsFolder", "copyResourceToResource", "copyResourcesToFile", "copyResourceFromFolder", "copyResourceFromFiles", "copyResource2File", "copyResourceAsResource", "copyResourceFromResource", "copyResource2Folder", "copyResourcesFromFolder"], "resourceFilename": ["resourceFile", "Resourcefilename", " resourceFile", "resourcefilename", "sourceString", "sourceFilename", "requestPath", "requestString", "resourcePath", " resourceString", "sourceSourceFile", "ResourcePath", "sourceFile", "requestfilename", " resourcefilename", "resourceSourceFile", "ResourceSourceFile", " resourceSourceFile", "resourceString", "ResourceFilename", " resourcePath", "ResourceFile", "requestFilename", "ResourceString"], "destinationFilename": ["DestificationSourceFile", "destinationFile", "DestinationFile", "destarationFilename", "destationModule", "DestificationThumbnail", "destationSourceFile", "destificationSourceFile", "DestinationSourceFile", "destificationThumbnail", "destignmentThumbnail", "destarationFile", "DestinationThumbnail", "destationFile", "DestificationModule", "destinatorModule", "destificationFilename", "DestificationFilename", "destinatorFile", "destificationFile", "destinationThumbnail", "destinationSourceFile", "destinatorFilename", "destinatorSourceFile", "destignmentFile", "destignmentFilename", "destationFilename", "DestinationFilename", "DestinationModule", "destarationThumbnail", "destificationModule", "DestificationFile", "destinationModule"], "inStream": ["INSteam", " inStreamer", "binSteam", " inSt", "outFile", "ninSteam", "ninstream", "outSt", "inputstream", "ninStream", "inFile", "outCh", "inSteam", "inputStream", "INStreamer", "INStream", "inCh", "outstream", " instream", "binstream", "INFile", "binStreamer", " inFile", "binStream", " inSteam", "outStreamer", " inCh", "outSteam", "inputSteam", "ninStreamer", "inputStreamer", "inSt", "INstream", "instream", "inputSt", "inStreamer", "inputCh"], "outStream": ["workstream", "outputstream", " outPath", "OutPath", "OUTFile", "againDirectory", "Outstream", "outFile", "workSteam", " outFile", "OUTSteam", "inFile", "inSteam", "inputStream", "OUTStreamer", "OutStream", "outstream", "inPath", "OUTStream", "outputSteam", "oneStreamer", " outstream", "againstream", "outDirectory", "outStreamer", "againStreamer", "outSteam", "inputSteam", "againSteam", "oneDirectory", "inputStreamer", "oneStream", "instream", "OutSteam", "againStream", "outputStream", " outStreamer", "oneSteam", "outputStreamer", "outPath", "workStreamer", "inStreamer", " outSteam", "inputDirectory", "workStream"]}}
{"id1": "19335986", "id2": "12766394", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["CaughtException", "uncachedexc", "uncatchedexc", "uncaughtEvent", "CatchedEvent", "Catchedexc", "Caughtexc", "uncaughtexc", "uncachedEvent", "uncachedException", "uncatchedException", "unchandledException", "unchandledexc", "CatchedException", "uncatchedEvent", "CaughtEvent", "unchandledEvent"], "t": ["n", "c", "l", "s", "te", " T", "ty", "type", "d", "r", "g", "w", "out", "p", "ts", "let", "title", "m", "tree", "ing", "it", " td", "T", "tr", "ed", "f", "tx"], "e": ["event", "fe", "i", "ace", "ee", "be", "ie", "eb", "c", "ge", "j", "se", "o", "s", "el", "ception", "ele", "en", "ec", "er", "d", "ce", "diff", "r", "data", "de", "exc", "ep", "p", "es", "ae", "environment", "ne", "eu", "example", "m", "E", "ev", "ed", "pe", "me", "err", "f", "error", "oe", "Exception", "element", "code", "enter", "esi"], "display": ["play", "fe", "console", "panel", "report", "profile", "description", "window", "host", "layout", "content", "monitor", "scroll", "d", "hide", "show", "default", "config", "de", "body", "page", "object", "p", "style", "dis", "status", "image", "screen", "Display", "position", "app", "me", "summary", "design", "container", "process", "this", "view", "platform"], "shell": ["hell", "buffer", "console", "server", "copy", "lock", "mail", "system", "echo", "l", "child", "host", "el", "clone", "loop", "tools", "sb", "live", " Shell", "machine", "math", "body", "cl", "launch", "h", "environment", "log", "bash", "m", "exec", "image", "status", "Shell", "ml", "kernel", "sym", "app", "sh", "sound", "b", "poll", "container", "process", "xml", "help", "gui", "cli", "tool"], "message": ["event", " exception", "address", "buffer", "translation", "mess", "console", "server", "output", "copy", "response", "report", "mail", "document", "description", "result", "management", "queue", "content", "monitor", "email", "member", "value", "media", "model", "application", "data", "body", "page", "object", "request", "flash", "Message", "log", "msg", "header", "m", "meter", "status", "image", " messenger", "update", "summary", "xml", "essage", "error", "view"], "e1": [" e3", "e3", "exc2", "e8", " e2", "E1", "e2", "E3", "E2", " e8", "E8", "exc3", "exc8", "exc1"]}}
{"id1": "14168494", "id2": "12417893", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferClass", " copiedClass", "copyFiles", " copyfile", " copiedfile", "transferFile", "transferfile", " copyFiles", " copiedFile", "transferFiles", "copyClass", " copyClass", "copyfile", " copiedFiles"], "dest": ["data", "loc", "name", "sup", "true", "later", " destination", "st", "destroy", "comb", "class", "orig", "output", "txt", "done", "dist", "temp", "this", "d", "source", "path", " Dest", "transfer", "null", "file", "wb", "Dest", "resource", "target", "out", "dir", "desc", "obj", "tmp"], "src": ["bin", "sl", "sin", "cb", "loc", "sup", "master", "gb", "ds", "s", "sc", "slice", "stream", "st", "sync", "inst", "download", "rc", "ssl", "copy", "rob", "img", "dist", "rb", "sq", "source", "sub", "storage", "filename", "url", "config", "sit", "file", "split", "Dest", "upload", "sel", "sb", "target", "tmp"], "srcChannel": ["sourceChan", "rcConnection", " srcStream", " srcButton", "rcCh", "destConnection", "srcSection", " srcchannel", "rcButton", "distStream", "distChannel", "destChan", "sourceButton", "sourceChannel", "distChan", "rcChan", " srcConnection", "rcSection", "srcCh", "srcChan", "rcStream", "inputConnection", " srcCh", "srcStream", "rcchannel", "srcButton", "sourcechannel", "destChannel", "srcchannel", "inputChannel", "rcChannel", "inputchannel", "destchannel", " srcSection", "distCh", "inputSection", "srcConnection", " srcChan"], "dstChannel": [" dstchannel", "Dstchannel", "drcchannel", "drcContext", "dstsConnection", " dstChan", " drdContext", "dstConnection", "drcChannel", "dstchannel", "dDestChannel", " drdchannel", "ddestConnection", "dsrcVideo", "drdchannel", "dstVideo", "dDestchannel", "drcChan", " dstsStream", " drdChan", "drdChannel", "DstChannel", "ddestChannel", "dstsStream", "Ddestchannel", " dstschannel", "dstContext", "dDestConnection", "ddestContext", "ddestChan", " dstStream", "ddestchannel", " dstConnection", "DstVideo", "DdestChannel", "dstChan", " dstsChannel", "DdestVideo", " drdChannel", "dDestStream", "ddestStream", "dsrcChannel", "drdContext", "dstschannel", "dstsChannel", "dsrcchannel", " dstContext", "ddestVideo", " dstsConnection", "drdChan", "dstStream", "drcVideo"]}}
{"id1": "8921716", "id2": "4798332", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 1, "substitutes": {"MD5": ["MP512", "MD512", " MD512", "SHA5", "SHA4", "MD8", "MP5", "MP4", "SHA8", "MP8", "MD4", " MD8", "SHA512", " MD4"], "text": ["font", "prefix", "url", "txt", "message", "image", " Text", "length", "struct", "letter", "EXT", "data", "version", "this", "in", "output", "input", "str", "editor", "hex", "password", "template", "bytes", "key", "test", "code", "class", "source", "config", "number", "TEXT", "object", "token", "string", "name", "binary", "pattern", "path", "word", "content", "ext", "format", "buffer", "contract", "secret", "Text", " TEXT"], "UnsupportedEncodingException": ["UnsupportedencodingException", "UnsupportedEncodedATION", "UnsupportedEncagingception", "Unsupportedencodingception", "UnsupportedEncodingATION", "UnsupportedencodingATION", "UnsupportedEncodedception", "UnsupportedEncodingception", "UnsupportedEncodedException", "UnsupportedEncasingATION", "UnsupportedEncasingception", "UnsupportedencodedException", "UnsupportedEncasingException", "UnsupportedencodedATION", "UnsupportedEncagingException", "Unsupportedencodedception", "UnsupportedEncagingATION"], "md": ["m", "rm", "hd", " MD", "Cmd", "message", "mp", "body", "cmd", "sha", "pg", "method", "data", "mo", "dig", "dd", "rpm", "mode", "hash", "mc", "valid", "d", "mag", "vd", "od", "ms", "meta", "me", "mb", "code", "amd", "mg", "dm", "bd", "wd", "metadata", "cm", "bf", "pd", "MD", "docker", "di", "ad", "mac", "nm", "mand", "match", "mm", "ma", "ld", "pm", "mt", "cd", "mod", "manager", "df"], "md5hash": ["md25Hash", " md5sum", "md8hash", "md5version", " md5hex", "md4Hash", "mand53Hash", " md6hash", "md6Hash", "md4sum", "md6kh", "md53version", "mddownsum", "md5Hash", "mddownHash", "md2sum", "mddownkh", "md2html", "mand5version", "md5hex", "mand5hash", "md6hash", "md6hex", "md8hex", "md25version", "md8Hash", "mddownhash", "md2version", "md25html", "md4hash", "md8sum", "md53hash", " md6hex", " md6Hash", " md6sum", "md2hash", " md5kh", "md25hash", "mand5Hash", "md53Hash", "mand5html", "md5sum", "mand53version", "md2kh", "md4hex", " md5Hash", "mand53hash", "md6sum", " md6kh", "mand53html", "md5kh", "md53html", "md2Hash", "md5html"]}}
{"id1": "5274228", "id2": "15445861", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 0, "substitutes": {"put": ["string", "output", "resource", "replace", "add", "patch", "UT", "write", "post", "client", "cache", "operation", "build", "data", "file", "get", "submit", "format", "PUT", "Put", "pull", "update", "create", "parse", "st", "transfer", "transform"], "resourceID": ["Resourceid", "serviceIDs", "requestURL", "resourceURL", "objectIDs", "ResourceID", "responseKey", "serviceid", "resourceId", "requestId", "objectId", "responseId", "serviceId", "serviceID", "requestID", "resourceid", "ResourceURL", "resourceKey", "objectID", "responseURL", "responseID", "objectid", "resourceIDs", "requestKey", "ResourceKey", "ResourceId", "ResourceIDs"], "headersMap": ["ersList", "headersSet", "httpMap", "ersFile", "headerSet", "httpList", "httpArray", "ersArray", "ersMap", "headerFile", " headersSet", "httpSet", "headerList", "headerMap", "headerArray", "headersFile", " headersFile"], "httpClient": ["HttpCase", "ttpConnection", "HttpContext", "httpServer", " httpConnection", " httpCase", "httpContext", "HttpPut", "httpsConnection", "ttpBase", "ttpPut", "httpConnection", "HttpServer", "httpsContext", " httpCall", "phpPut", "httpsServer", "ttpClient", "phpCall", " httpContext", "httpsClient", "httpCall", "HttpClient", " httpBase", "httpCase", "phpCase", "httpsPut", "HttpCall", "httpBase", "httpsBase", " httpServer", "phpClient"], "httpPut": ["httpGet", "phpPush", "httpsDo", " httpDo", "HttpPut", "HttpPUT", "httpput", "httpAdd", "internalPush", "httpsput", "phpAdd", "internalWrite", "httpDo", "httpPush", "webPut", "httpSplit", " httpSplit", " httpAdd", "httpsSplit", "webPush", " httpWrite", "httpsPush", "phpWrite", "viewPush", "HttpPush", "viewPut", "viewPUT", "httpWrite", "Httpput", "phpPut", " httpGet", " httpPUT", "httpsPUT", "HttpDo", "httpsClient", "webGet", "phpSplit", "httpPUT", "httpsAdd", "HttpClient", "phpGet", "httpsPut", "httpsGet", "HttpGet", " httpPush", "internalGet", "webPUT", "internalPut", "viewput"], "headersList": ["ersList", "driversArray", " headersL", "headersSet", "driversL", "ersSet", "headersL", "headerSet", "driversList", "ersArray", "driversMap", "headerL", " headersSet", "ersL", "headerList", "headerMap", "headerArray"], "iterator": ["handler", "loader", "outer", "starter", "division", "entry", "vector", "ie", "sequence", "slice", "started", "oper", "inner", "inter", "end", "walker", "driver", "ter", "set", "later", "gener", "done", "instance", "iter", "next", "loop", "interstitial", "adder", "Iterator", "reader", "collection", "parser", "kick", "li", "append", "ator", "size", "Iter", "init", "creator", "basic", "start", "writer", "eni", "runner", "pointer", "ski", "operator", "stream", "processor", "random", "finder", "multi", "step", "former", "engine"], "headersArray": ["filesAr", "filesHash", "headersAr", "headsLength", "filesMap", "filesArray", "headersLength", "headsAr", "headersHash", "ersAr", " headersAr", "hersLength", "ersArray", "ersMap", "hersAr", " headersLength", "headsList", "hersArray", "hersList", "ersHash", " headersHash", "headsArray"], "fields": ["keys", "zip", "json", "comments", "errors", "pattern", "content", "params", "FIELD", "lines", "dir", "region", "Field", "data", "body", "format", "types", "rows", "details", "prefix", "files", "values", "dates", "properties", "field", "codes"], "occiHeaders": ["ocsiHeadlers", "ocsiBuffer", "occiBuffers", "occiBuilderers", "occiBufferers", "occiBuildlers", "occiHeadlers", "occiHosters", "occiHostlers", "occiBufflers", "ocsiHeaderers", "ocsiBufferers", "occiBuilder", "occiHosterers", "ocsiHeader", "occiHoster", "ocsiHeaders", "ocsiBuffers", "occiBuilders", "occiBuffer", "occiHeader", "occiHeaderers", "ocsiBufflers"], "H": ["R", "P", "OH", "U", "Head", "CH", "M", "HTTP", "D", "HR", "EH", "X", "S", "HH", "Index", "HM", "TH", "K", "HT", "Handler", "N", "HB", "MH", "rh", "HS", "W", "Length", "Q", "C", "DH", "Header", "J", "SH", "I", "G", "F", "HI", "T", "B", "HE", "ID", "HC", "V", "Hop", "L", "Y", "NH"], "header": ["string", "head", "info", "handler", "event", "her", "buffer", "outer", "response", "server", "ker", "token", "builder", "entry", "http", "holder", "message", "document", "per", "inner", "bridge", "result", "later", "driver", "ter", "dr", "manager", "detail", "extra", "key", "ler", "er", "back", "reader", "rule", "player", "cover", "value", "feature", "file", "liner", "request", "metadata", "row", "Header", "frame", "writer", "second", "layer", "cher", "service", "comment", "consumer", "block", " request", "f", "former", "definition"], "statusLine": ["StatusLine", "errorString", "statusText", "statusBody", " statusBody", "StatusBody", "StatusText", "errorCode", " statusFile", "responseCode", "responseFile", "errorBody", "StatusCode", "StatusString", " statusText", "statusFile", "responseText", " statusString", "errorLine", "responseLine", "StatusFile", "statusString"], "httpResponse": ["httpsResult", "HttpRequest", "HttpEnvironment", " httpEnvironment", "templateLine", "httpsBody", "HttpPage", "statusResponse", " httpLine", "ttpResp", "statusBody", "actualresponse", "HttpLine", "HttpResp", "HttpStatus", "ttpResponse", " httpresponse", "statusResult", " httpResp", "httpResp", "actualResponse", "templateResp", "httpsEnvironment", " httpBlock", "HttpBody", "ttpRequest", "actualLine", "actualRequest", "templateResponse", "HttpResult", "httpEnvironment", "httpsResponse", "statusBlock", "httpRequest", " httpRequest", "HttpBlock", "httpStatus", "httpsRequest", "templateStatus", "Httpresponse", "ttpResult", "HttpResponse", "httpPage", "httpLine", " httpResult", "httpResult", "httpBody", " httpStatus", " httpPage", " httpBody", "httpresponse", "httpBlock", "httpsPage"], "statusCode": ["resultCount", "StatusLine", "statusText", "StatusData", "statusCount", "resultcode", " StatusType", " statusType", "resultCode", "statusType", "statuscode", "errorCode", "StatusText", " StatusLine", "responseCode", "resultLine", " StatusCode", "StatusType", " StatusData", " statuscode", " statusData", "errorText", "StatusCode", "Statuscode", "StatusCount", "errorType", "statusData", "responseText", "errorLine", "responseLine", "responseType", " statusCount"]}}
{"id1": "21125261", "id2": "6188784", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"test": [" testing", " solve", " verify", " tests", " eval", " analyse", " validate", " simulate", " deploy", " process", "Test", " train", "train", "evaluate", " example", " evaluate", " run", " sample", "execute", "Train", "Main", " check", "tests", "run"], "is": ["serv", "ais", "ins", "ai", "does", "iso", "isa", "has", "id", "IS", "bis", "ws", "Is", "es", "res", "ir", "out", "s", "ls", "ris", "stream", "si", "iss", "ios", "os", "ses", "i", "info", "lis", "ps", "isi", "ics", "fs", "opens", "its", "gets", "iris", "in", "ists", "src", "as", "mis"], "byteArrayOutputStream": ["byteStringInputPath", "byteArrayoutputStream", "byteArrayByteStream", "byteStringInputContext", "byteArrayOutputPath", "byteArrayFileStream", "byteArrayOutputSteam", "byteStringInputString", "byteArrayByteFile", "byteArrayInputPath", "byteStringInputSteam", "byteArrayOutputContext", "byteArrayFileString", "byteArrayOutputString", "byteArrayFileSteam", "byteArrayOutputFile", "byteArrayByteSteam", "byteArrayoutputSteam", "byteArrayIOString", "byteArrayInputContext", "byteArrayInputFile", "byteStringOutputPath", "byteArrayIOSteam", "byteStringInputFile", "byteArrayInputStream", "byteArrayIOFile", "byteArrayInputString", "byteArrayIOStream", "byteArrayFileContext", "byteArrayByteString", "byteStringOutputFile", "byteArrayoutputContext", "byteStringOutputContext", "byteArrayInputSteam", "byteStringOutputSteam", "byteStringOutputString", "byteStringInputStream", "byteArrayFileFile", "byteArrayFilePath", "byteStringOutputStream", "byteArrayoutputPath"], "def": ["md", "defined", "de", "da", "base", "pro", "re", "der", "parse", "e", "id", "default", "df", "obj", "define", "decl", "spec", "this", "dem", "info", "des", "definition", "class", "bus", "report", "desc", "config", "Def", "di", "data", "entry", "file", "init", "dist", "ref", "d", "dir", "DE", "frame", "dev", "DEF", "conf", "f"], "se": ["ser", "su", "de", "parse", "lex", "pse", "sem", "zip", "site", "e", "sec", "ste", "sl", "es", "ge", "SE", "te", "s", "sea", "est", "si", "fe", "ses", "sel", "sle", "ase", "ie", "sk", "pe", "so", "see", "ane", "ine", "per", "sche", "cle", "inse", "sed", "service", "ve", "sh", "me", "entry", "ke", "sc", "ade", "ne", "spe", "sp", "ss", "ze", "ce", "le", "be"], "linkId": ["lockById", "lineById", "feedLength", "linkid", "LinkLength", " linkById", "LinkInfo", "feedid", "linkById", " linkid", " linkLength", "lockId", "lockInfo", "linkLength", "feedId", "lineId", "LinkId", "feedInfo", "linkInfo", "lineInfo", "Linkid", " linkInfo"], "segmentId": ["sementId", "segmentsType", "segmentInfo", "selementType", "sementType", "segmentsInfo", " segmentID", "selementId", " segmentsID", "sementID", "segmentsNumber", "negmentId", " segmentsId", "negementCount", "sementNumber", "negementInfo", " segmentType", "segmentCount", " segmentCount", "segmentsID", "segementNumber", "segmentType", "selementID", " segmentsType", "negementId", "negmentNumber", "negementNumber", "sementInfo", "segmentID", "sementCount", "segmentsId", "segementCount", "segementId", "negmentCount", "segmentNumber", "segmentsCount", "selementCount", "segementInfo", "negmentInfo", " segmentsCount"], "linkSegments": ["linkEngines", "linkConnectment", "linkFragments", "linkFraggments", "linkFragures", "lineSegines", "lineSeggments", "lineFragment", "linkIncrements", "linkEnggments", "linkConnectures", "linkEngures", "lineFragments", "linkSeggments", "linkIncrement", "linkSegines", " linkEnggments", "linkSegles", "linkFragines", "linkSegures", "linkEngles", "linkIncreles", "linkEngments", " linkEngures", " linkSegures", "linkConnectgments", " linkEngment", " linkSegment", "lineFragles", " linkSeggments", "linkSegment", "lineSegment", "lineFragines", "lineSegments", "lineSegles", "lineFraggments", "linkIncregments", "linkFragles", "linkConnectments", " linkEngments", "linkEngment", "linkFragment", "linkIncreines"], "segments": ["gegment", "Segments", "scheplings", "pegment", "Seggment", "gegs", "segs", "pegs", "schements", "geplings", "Seggements", "gements", "segment", "Seggments", "pegements", "pements", "seplings", "pegments", "segements", "gegements", "begs", "gegments", "begments", "schegment", "bements", "begment", "peplings", "sements", "schegments"], "frameProperties": ["framePropps", "frameProps", " frameproperties", "framePromperties", "frameproproperties", "frameproeters", " frameProblems", " frameProproperties", " frameproblems", "frameProproperties", "framePromproperties", " frameProps", "framePropblems", " frameProeters", "framePromps", "frameproblems", "framePropeters", "framePrometers", "framePropperties", " frameproproperties", "framePropproperties", " frameprops", "frameprops", "frameProblems", " frameproeters", "frameproperties", "frameProeters"], "time": ["v", "change", "now", "ime", "e", "id", "port", "times", "x", "money", "start", "length", "play", "Time", "tim", "name", "end", "image", "c", "TIME", "step", "rate", "t", "type", "duration", "live", "count", "event", "video", "ice", "speed", "weight", "date", "depth", "timeout", "delay", "h", "once", "age", "cost", "data", "work", "file", "clock", "sleep", "loop", "value", "vel", "f", "activity", "timer", "size", "etime"], "vehicle": ["vertology", "Vehicles", "Vehology", "venicle", " vehology", "bridical", "driicle", "Vehish", "venical", " vehish", "Vehicular", "verticles", " mobicle", "vehicular", " vehicles", "vehicles", "Vehicle", "driical", " vehicular", "bridometry", "verticular", " mobline", "driocity", " mobish", "vehocity", " vehline", "vehical", "venometry", "bridicle", "bridocity", "driometry", "vehline", "vehometry", "verticle", "Vehline", "venocity", " mobicles", "vehish", "vehology"]}}
{"id1": "160739", "id2": "14878593", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createInputReader", "createInputStream", " createInputFile", "createOutputSteam", " createIOReader", "createInputFile", " createByteReader", " createByteStream", " createIOStream", " createOutputFile", " createIOFile", "createInputSteam", " createInputSteam", " createByteFile", " createIOSteam", " createOutputSteam", " createOutputReader", " createInputStream", "createInputReader", "createOutputReader", " createByteSteam", "createOutputFile"], "inFile": ["incFiles", "inputfile", "inStream", "inputStream", "insFiles", "outFiles", "inputFiles", "sourceFile", "sourcefile", "inputFile", "outStream", "insfile", "incfile", "incFile", "outfile", "insStream", "incStream", "inFiles", "infile", "insFile", "sourceFiles", "sourceStream"], "outFile": ["workingStream", "workTime", " outStream", "inputfile", " outDirectory", "outTime", "workfile", "workingfile", "inputDir", " outfile", "outDir", "workFile", "workingFile", "targetStream", "inTime", "outDirectory", "workingDirectory", "inputFile", "targetfile", "targetFile", "workDir", "outStream", "inputTime", "outfile", "targetDirectory", "inDir", "infile"], "k_blockSize": ["k_lockLength", "k_bitCount", "k_blockCode", "k_byteCount", "k_byteLength", "k_lockCode", "k_lockLen", "k_blocksSize", "k_blockLen", "k_BlockSize", "k_bitSize", "k_bitInfo", "k_lineSize", "k_lockCount", "k_BlockLength", "k_lineCount", "k_BlockCount", "k_byteLen", "k_blocksLength", "k_byteSize", "k_BlockCode", "k_blockInfo", "k_byteInfo", "k_blockLength", "k_blocksCount", "k_blockCount", "k_lockSize", "k_lineInfo", "k_blocksLen", "k_byteCode"], "byteCount": [" byteSum", " byteLen", "flushSize", "ByteSize", "ByteSum", "blockCount", " bytecount", "byteLen", "characterSize", "flushcount", "Bytecount", "byteLength", "flushLength", "blockLength", " byteSize", "byteSize", "characterLength", "byteSum", "bytecount", " byteLength", "characterCount", "ByteLen", "characterLen", "blockSum", "flushCount", "ByteLength", "blockSize", "ByteCount"], "buf": ["base", "cmd", "feed", "vec", "config", "flush", "feat", "src", "queue", "bag", "uf", "bytes", "b", "cb", "bh", "cap", "background", "font", "buff", "border", "buffer", "rc", "fd", "fb", "bf", "result", "Buff", "len", "img", "cas", "tmp", "alloc", "ucc", "la", "brace", "loc", "data", "cv", "rb", "ctx", "seq", "batch", "Buffer", "exc", "append"], "ofp": ["fort", "afl", "OFp", "OFnp", "OFl", "Oftp", "forp", "Ofc", "afnp", "Ofp", "OFtp", "ofl", "Ofnp", "OFt", "oft", "ofnp", "forc", "oftp", "afp", "Oft", "fortp", "afc", "ofc", "Ofl", "OFc"], "zos": ["z", "iffs", "zes", "zx", "ls", "lins", "oda", "liquid", "webkit", "zon", "tz", "zy", "nox", "forge", "bes", "os", "zers", "zl", "iframe", "rez", "modules", "zen", "fits", "los", "rons", "za", "kos", "gz", "uz", "zar", "ops", "zig", "bos", "hz", "nz", "packs", "ZA", "zn", "inos", "obs", "core", "outs", "zag", "ros", "ossus", "obb", "bitcoin", "dylib", "zona", "oses", "soon", "budget", "zi", "lol", "zb", "utils", "osi", "zip", "zyk", "ws", "ZI", "ogl", "zo", "abi", "ozo", "zik", "robe", "zh", "enos", "zer", "js", "cfg", "zin", "css", "cos", "ses", "owicz", "oS", "bs", "jas"], "osw": ["lswo", "eshell", "osy", "ossow", "osssw", "isnow", "osow", "ossww", "essw", "osswd", "oshell", "bwo", "isd", "eswd", "esow", "osnow", " osow", "osws", "ossfw", "esnow", "osd", " osfw", "issw", "esfw", "esy", "isw", "lsx", "osshell", "ossnow", "osfw", "esww", "esd", "bsws", " osww", "osx", "ossw", "ishell", "oswo", "oswd", "bws", "bsx", "iswd", "osww", "lsw", "bsw", "ossy", "lsws", "esw", "isy", "bx", "bswo", "ossd"], "bw": ["bbw", "Bw", "lw", "Bew", "lbsw", "bbwh", " bws", "bwe", "fr", "owa", "fbW", "bbaw", "oaw", "Bws", "bz", "fbw", "Bwa", "bbew", "abwe", "baw", "lbz", "abw", "fsw", "ebwe", "lbw", "owu", "fw", "fbwe", "bbz", " bew", "ow", "lbws", "ebW", "fwh", "fwa", "lbwh", "lx", "abwd", "ebw", " bwu", "lwa", "bwu", " bwa", "bew", " baw", "fx", "bws", "bwh", "fbwd", "bW", "bbwa", " bz", "lsw", "bwa", "lbwa", "bbwu", "bsw", "bwd", "ebwd", "bbws", "bx", "abW", "lbr", " bwh", "lbx"], "zot": ["zerott", "aziot", "jit", "zita", "zeros", "azor", "zerot", "zerori", "zerit", "azot", " ziot", "azott", "Zot", "zott", "Zott", "Zit", "ziot", "jot", "Zita", "jori", "Zor", "Ziot", "zor", "zori", "jos", "azit", " zori", "zerita", " zor", "azita"], "ifp": ["IFi", "ipb", " iff", "ifi", "Ifi", "ifb", "Ifc", " ifi", " ifl", "IFb", "IFf", "ipl", "IFl", "ifc", " ifb", "Iff", "ipc", "iff", "ifl", "ipp", "IFp", "IFc", "Ifp", " ifc"], "zis": ["jis", "zisi", " zib", "jisi", "jit", " zIS", "xits", " zisi", "zib", "zip", "xais", "xisi", " zits", "zenais", "zeis", "xit", "zenis", "Zis", "zenIS", "jits", "zipits", "zipiss", "xIS", "zeip", "Zits", "Ziss", "Zip", "zeiss", "xis", "zIS", "zeits", "xib", " zais", "zenib", "ziss", "zais", "zits", "zipip", "zipis"], "isr": ["irrc", "rispr", "iscr", "risr", "risrb", "ISrc", "ispr", "ISr", "isscr", " isrs", "issrs", "ISpr", "irr", " issr", "isrs", "irrb", "IScr", "isssr", "isrc", "ISrs", "isrb", "issr", "risrc", "irpr", " iscr", "ISsr", "ISrb"], "br": ["body", "err", "bsp", "lr", "fr", "kr", "HR", "bl", "arr", "cro", "ocr", "yr", " fr", "b", "ch", "ctr", "bp", "sp", "r", "ber", "gr", "tr", " dr", "ibl", "bro", "obl", "div", "Br", "ibr", "BR", "mr", "img", "rs", "hr", " BR", "bar", "sr", "rib", "ob", "browser", "str", "rb", " Br", "bc", "bh", "obi", "shr"], "zit": ["zith", "zite", "xic", "zeita", "zic", "jit", "zita", "zipith", "zipite", "zip", "zipIT", "zenits", "zenit", " zip", "zeIT", "jic", "jita", "zenith", " zits", "zitter", "jip", "zeitter", "xit", "jIT", "zipit", "zipita", "xi", "jite", " zi", " zic", " zite", "jits", "ji", "zipits", "zIT", "zipitter", "zenitter", "zeith", "zeits", "zeit", "xith", " zith", "jith", "zits", "zipip", "zi"]}}
{"id1": "23310397", "id2": "13333160", "code1": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 0, "substitutes": {"onCreate": ["ONCreating", "onClick", "jobCre", "ONClick", " onCreated", "OnClick", " onClick", "ONCreate", "onCreating", "OnCreating", " onCreating", " onCre", "jobClick", "jobCreated", "ONCreated", "OnCreate", "jobCreate", "OnCreated", "onCreated", "onCre", "OnCre"], "savedInstanceState": ["savingInstStates", "savingInstanceInfo", "savedInstanceConfig", "savingInstInfo", "savedCaseStates", "savedinstanceInfo", "savedanceStates", "savedInstanceData", "savingInstData", "savingInstState", "savedanceInfo", "savedinstanceData", "savedinstanceStates", "savedinstanceConfig", "savingInstanceState", "savedCaseConfig", "savingInstanceConfig", "savedInstInfo", "savedanceState", "savedInstanceInfo", "savedInstData", "savedInstanceStates", "savedInstState", "savingInstanceStates", "savedinstanceState", "savingInstanceData", "savedCaseInfo", "savedInstConfig", "savedCaseState", "savedInstStates", "savedanceData", "savingInstConfig"], "mButton1": ["MButton1", "mActionOne", "mBorder01", "mChannel1", "mText1", "mAction2", "mText01", "MAction2", "MButtonFirst", "MAction1", "MActionOne", "mChannelOne", "mOption1", "mChannelFirst", "mOptionId", "mBorder1", "MActionId", "mAction1", "mBorderFirst", "mTextFirst", "mOption2", "mBorder2", "MChannelFirst", "mButtonFirst", "mText2", "mChannelId", "mButtonId", "mChannel01", "mButton01", "MButtonId", "MChannel2", "mButtonOne", "mChannel2", "MButtonOne", "MChannel1", "mActionId", "MButton01", "MChannel01", "mOptionOne", "MButton2"], "mButton2": ["mOptionTwo", "mText1", " mText1", " mText02", "mText02", "mAction2", "mLabel1", "mActionTwo", "mOption02", " mEditorTwo", "mOption1", "mEditorTwo", "mButton02", "mAction1", "mAction02", " mEditor1", " mButtonTwo", "mOption2", " mText2", " mTextTwo", "mLabel2", "mText2", "mTextTwo", "mEditor1", " mEditor2", "mEditor2", " mButton02", "mLabelTwo", "mButtonTwo"], "mTextView1": ["mTEXTview4", "mTextView0", "mTextVIEW5", "mTEXTview11", "mTextContainer11", "mTextVIEW1", "mTextVIEWp", "mTextContainer1", "mTextVIEW0", "mTextview4", "mTextDisplay1", "mContextView0", "mTEXTview8", "mTEXTViewOne", "mTextview11", "mTEXTview5", "mTextview0", "mTextContainer2", "mTextContainer8", "mTextStream2", "mTEXTView8", "mTextViewOne", "mTextviewp", "mContextView11", "mTEXTView1", "mTextDisplay5", "mTEXTView11", "mTextView2", "mTEXTview2", "mTextView4", "mContextview1", "mTextview1", "mContextview0", "mTextStream1", "mTextDisplay4", "mTextVIEW4", "mTextForm11", "mTextVIEWOne", "mTextDisplay2", "mTextForm8", "mTextStream11", "mTextStream0", "mContextview2", "mTextview2", "mTextField5", "mTextForm1", "mTextView5", "mTEXTview1", "mTEXTView5", "mContextView5", "mTextStreamp", "mContextViewp", "mTextview5", "mTEXTviewOne", "mTextView8", "mTextView11", "mContextView2", "mTextVIEW2", "mTextVIEW11", "mTEXTView4", "mTextForm2", "mContextview5", "mTextField1", "mContextView1", "mTextview8", "mTEXTView2", "mContextviewp", "mTextField2", "mTextviewOne", "mTextViewp", "mContextview11", "mTextDisplayOne"], "v": ["x", "f", "version", "g", "m", "V", "j", "p", "en", "vv", "model", "page", "video", "b", "w", "sv", "l", "val", "Ev", "e", "env", "i", "value", "t", "port", "h", "vs", "n", "view", "conv", "server", "c", "function", "Version", "Value", "ve"], "uriAPI": ["cliPython", "URISSL", "uiAPI", "uriCA", "uriPA", "riSSL", "uiapi", "uriAP", "urlAPI", "uriPython", "durationAPI", "cliapi", "uiPython", "urlPA", "uriapi", "durationAP", "URICA", "riAPI", "urlCA", "URIAP", "directoryapi", "idCA", "cliAPI", "idAPI", "URIapi", "directoryAPI", "idPA", "directorySSL", "URIPA", "riPython", "URIAPI", "durationPython", "riAP", "URIPython", "uriSSL", "riapi"], "httpRequest": ["HttpMessage", "httpsRequest", "ttpRequest", "htmlrequest", "HttpRequest", " httpClient", "httprequest", "buildRequest", " httpMessage", "htmlRequest", "buildrequest", "httpReturn", "httpsrequest", " httpReturn", "safeResponse", "externalrequest", "httpAsk", " httpAsk", "Httprequest", "externalResponse", "uriCause", "buildMessage", "htmlResponse", "ttpClient", "saferequest", "httpsReturn", "httpClient", "uriResponse", "httpCause", "safeRequest", "ttprequest", " httpCause", "httpMessage", "safeAsk", "uriRequest", "externalRequest", "HttpResponse", "ttpReturn", " httprequest", "externalAsk", "htmlCause", "httpsClient", "buildResponse", "urirequest"], "params": ["values", "data", "eps", "type", "options", "services", "array", "results", "body", "settings", "ams", "relations", "par", "param", "arms", "items", "parts", "Parameters", "apps", "query", "posts", "ras", "list", "pins", "i", "api", "request", "response", "url", "vs", "names", "config", "uri", "ps", "http", "details", "keys", "pos", "changes", "result", "properties", "rules", "resources", "json", "string", "ip"], "httpResponse": ["ttpServer", "Httpresponse", "ttpRequest", "HttpRequest", "externalResult", "htmlResult", "HttpReply", "ttpResult", "HTTPResponse", "HTTPRequest", "httpReply", "serverResult", " httpReply", "HttpServer", " httpResult", "externalResponse", "htmlresponse", "htmlResponse", "httpServer", "htmlResp", "ttpClient", "httpresponse", "HttpResult", "HttpClient", "httpResp", " httpresponse", "httpClient", "serverResponse", "serverRequest", "ttpReply", "externalRequest", "htmlReply", "HttpResp", "HttpResponse", " httpResp", "httpResult", "ttpResp", "htmlServer", "HTTPReply", "HTTPResp", "externalClient", "serverResp", "ttpResponse"], "strResult": ["stringResult", "strresult", "StrResults", "stringResponse", " strresult", " strResponse", " strResults", "strResults", "strResponse", "stringresult", "stringResults", "StrResult", "StrResponse", "Strresult"]}}
{"id1": "17683082", "id2": "21491791", "code1": "    HttpRepository(Path path) throws IOException {\n        super(path);\n        this.url = new URL(path.toURLString());\n        HttpURLConnection.setFollowRedirects(true);\n        this.connection = (HttpURLConnection) url.openConnection();\n        this.ns = Names.getNamespace(path);\n    }\n", "code2": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "label": 0, "substitutes": {"IOException": ["IOError", " IOError", "IPException", " URIError", "IPception", "IOception", " IOception", " URIception", " URIException", "IPError"], "url": ["page", "log", "uri", "ssl", "resource", "image", "server", "build", "manager", "loc", "this", "link", "socket", "channel", "impl", "URL", "ref", "job", "conn", "source", "config", "access", "client", "web", "l", "base", "user", "address", "cache", "file", "service", "sl", "host", "bug", "path", "location", "Url", "http", "feed"], "connection": ["uri", "resource", "server", "version", "link", "socket", "channel", "Connection", "application", "index", "reader", "config", "directory", "client", "position", "handler", "file", "loader", "relation", "service", "function", "location", "response", "context", "wrapper", "collection", "manager", "database"], "ns": ["ls", "prefix", "cn", "scope", "n", "ss", "os", "ps", "pos", "NS", "str", "lines", "nc", "ms", "fs", "conn", "ws", "db", "object", "names", "obj", "params", " namespace", "net", "domain", "cs", "space", "ds"]}}
{"id1": "19944975", "id2": "13783549", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["saveConfig", "saveReport", "WriteSection", " writeSection", "saveConfiguration", "writeReport", "WriteConfig", "writeSection", " writeReport", "WriteReport", " writeConfig", "writeConfig", "saveSection", "WriteConfiguration"], "out": ["IN", "path", "string", "base", "temp", "ex", "output", "resource", "list", "server", "user", "inas", "report", "res", "plain", "filename", "OUT", "c", "project", "inner", "outs", "o", "window", "pool", "write", "line", "key", "password", "client", "sync", "at", "reader", "lib", "connection", "scope", "w", "config", "parent", "file", "object", "conn", "init", "name", "again", "m", "Out", "io", "writer", "exp", "exec", "dump", "prefix", "flush", "ext", "obj", "err", "xml", "this", "external"], "url": ["path", "string", "base", "address", "ssl", "server", "resource", "uri", "feed", "http", "rel", "l", "location", "URL", "source", "connection", "r", "org", "ob", "open", "config", "data", "file", "channel", "page", "object", "ll", "web", "conn", "io", "image", "sl", "Url", "stream", "b", "xml", "f", "service", "api"], "in": ["IN", "pin", "ssl", "i", "input", "resource", "copy", "n", "id", "inas", "ini", "serv", "gin", "c", "inner", "as", "socket", "s", "ins", "bin", "is", "cms", "reader", "source", "login", "min", "inside", "r", "inc", "data", "rin", "file", "conn", "again", "isin", "In", "nin", "kin", "a", "stream", "lin", "b", "err", "ac", "cin", "xml", "inn", "f", "win", "din"]}}
{"id1": "13499897", "id2": "15768167", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"CopyFile": [" CopyFolder", "Createfile", " copyfile", " CopyDir", " Copyfile", "CreateFolder", " copyDir", "Copyfile", "CreateFile", " copyFolder", "CreateDir", " copyFile", "CopyFolder", "CopyDir"], "sourcefile": ["SourceFile", "Sourcef", "destFile", "sourcefilename", "sinfile", " sourceFile", " sourcefilename", "configstream", "Sourcefile", "sourcelog", "destf", "configlog", "Sourcefilename", "configfile", "sourceFile", "sinlog", "deststream", "sinstream", "destlog", "sinFile", "configFile", " sourcef", "sourcef", "sourcestream", "destfilename"], "destfile": ["destFile", "sourcefilename", "targetfilename", "srcfilename", "deststring", "destroystream", "sourcepath", "buildfile", " destFile", "Desturl", "destfp", "tempFile", "destroyfilename", " destfp", "tempfilename", "Destfilename", "tempstream", "newfile", "Destfp", "buildstring", "targetpath", "srcfile", " destfilename", "DestFile", "sourceFile", "newfilename", "Destfile", "srcpath", "buildFile", "newfp", "deststream", "Destpath", "tempfile", "sourcestring", "targetfile", "targeturl", "targetFile", "destroyfile", "newFile", " destpath", " deststring", " desturl", "srcFile", "destroypath", "buildfilename", "destfilename", "temppath", "srcstream", "desturl", "destpath"], "last": ["after", "ending", "recent", "nd", "core", "se", "count", "length", "offset", "style", "prev", "event", "empty", "depth", "later", "child", "old", "part", "range", "route", "end", "key", "cur", "code", "cat", "total", " Last", "max", "size", "Last", "base", "start", "ast", "left", "full", "next", "latest", "first", "path", "current", "value", "or", "real", "use", "from", "right"], "parent": ["ppa", "text", "partial", "shared", "url", "unit", "dest", "null", "loc", "Parent", "remote", "data", "child", "port", "part", "search", "anc", "parents", "exp", "pa", "valid", "and", "key", "test", "home", "temp", "source", "api", "section", "filename", "target", "ip", "base", "point", "mac", "id", "cache", "po", "string", "ac", "patch", "file", "name", "root", "next", "function", "path", "location", "ant", "current", "content", "pointer", "fat", "line", "p", "post"], "f": ["fd", "m", "lf", "e", "j", "sf", "b", "g", "flat", "fb", "folder", "fa", "o", "d", "ref", "feed", "h", "fs", "s", "inf", "i", "dir", "l", "self", "of", "base", "r", "found", "v", "file", "c", "fc", "t", "af", "full", "cf", "F", "fe", "fp", "p", "df"], "srcChannel": ["destChannel", "rcChan", "srcClient", "sourceChannel", "srcChan", "rcConnection", "destchannel", "rcClient", " srcchannel", "sourcechannel", "rcchannel", "destConnection", "srcConnection", "rcChannel", "srcchannel", "sourceChan", "sourceConnection", " srcClient", " srcConnection", " srcChan", "destChan", "destClient"], "dstChannel": ["destChannel", "idstChan", "idrcChan", "dstchannel", "idstChannel", "ddestBuffer", "dntContext", "dsrcChan", "ddestChannel", "DstBuffer", "ddestContext", "DestContext", "dstChan", "dstButton", "DstChan", "drcchannel", "idrcButton", "dstsChannel", "idrcchannel", "dstBuffer", "destchannel", "dstContext", "DestChan", "dstschannel", "drcButton", "idstButton", "DstChannel", "dntBuffer", "dsrcButton", "ddestChan", "dsrcChannel", "dntChannel", "idrcChannel", "drcChan", "dntChan", "dsrcchannel", "destBuffer", "drcChannel", "DestChannel", "Destchannel", "destButton", "DstContext", "DestBuffer", "destChan", "dstsChan", "Dstchannel", "idstchannel", "destContext"]}}
{"id1": "8430178", "id2": "19868933", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyPath", "Copyfile", "copyFiles", " copyfile", "transferFile", "transferfile", " copyFiles", " copyPath", "copyPath", "CopyFiles", "CopyFile", "transferFiles", "transferPath", "copyfile"], "source_name": [" source_key", "src_name", "src_uri", "source_key", "src_file", "src_size", "sourceCtype", "source_Name", "source_uri", " source_path", "sourceCfile", "sourceNalias", "sourceCname", "src_type", "source_size", "Source_file", " source_Name", "sourceNfile", "source_path", "Source_name", "Source_data", "sourceNname", "source_alias", "source_type", "sourceNtype", "source_data", "sourceCalias", "source_names", " source_names", "src_alias"], "dest_name": [" dest_label", " destination_info", "destPnames", " dest_named", "Dest_path", " destination_path", "destPName", "dest_model", " dest_Name", " dest_names", "dest_info", "destFilelabel", "dest_resource", "destflabel", "dest_word", "destappnames", " destinationFresource", " destinationFpath", " dest_word", "destfname", "destFname", "destJnames", "target_model", "destFpath", "source_Name", "destRName", " destination_name", " destinationFinfo", "destfnamed", "destffile", " destinationFname", "dest_Name", " dest_definition", "destFilename", "dest_file", "dest_named", "dest_type", "dest_path", "target_names", "dest_none", "dest_id", "destPmodel", "target_type", "Dest_Name", " dest_file", "destPtype", "source_path", "Dest_id", "destPpath", "destFilefile", "destapptype", "destFilenamed", "dest_label", "destRdefinition", "destJName", "Dest_name", "dest_names", "destappmodel", " dest_path", " destination_resource", "destJword", "destFresource", "destPname", "destJname", " dest_type", "destRname", "destPword", "destappname", "destRpath", "source_names", "target_name", " dest_none", "destFinfo", "dest_definition"], "source_file": [" source_url", "src_name", "source_base", "ource_files", "source_files", "source__file", " source_base", "source_stream", "sourcefurl", "ource_line", "src_file", "source_line", "source__base", "sourceffile", "source__name", "sourcefFile", "ource_file", "ource_name", " source_File", "source_url", "source_cache", " source_cache", "source__class", " source_class", "source_class", "src_files", "source_File", "sourcefname", "src_stream", " source_files"], "destination_file": ["destation_file", "destinationablefile", "destention_name", "destinate_base", "destination_base", "destination4source", "destination2name", "destention_file", "destination2path", "destination2file", "destinate_file", "destation_name", "destention4path", "destation_function", "destination_function", "destination_folder", "destination2source", "destinationablebase", "destinate_page", "destinationablefiles", "destention_source", "destention4name", "destination_name", "destination4file", "destinationablepage", "destination_source", "destination_files", "destation_folder", "destination4name", "destination4path", "destention_path", "destination_page", "destinate_files", "destention4file", "destention4source", "destination_path", "destation_files"], "source": ["reader", "connection", "open", "ources", "current", "name", "get", "master", "remote", "reference", "slice", "from", "stream", "secure", "load", "local", "class", "ource", "copy", "cache", "inner", "output", "ite", "single", "SOURCE", "client", "dest", "service", "proxy", "storage", "image", "spec", "parent", "object", "config", "view", "uri", "unit", "core", "server", "file", "scope", "index", "search", "src", "resource", "target", "result", "Source", "input", "ize", "diff", "via", "resources", "slave", "start", "site"], "destination": ["coordinator", "foreigninate", "destining", "descinator", "destension", "constinator", "identinated", "descination", "destinated", "variinator", "targetinated", "coordination", "destina", "targetinator", "identribution", "Destining", "Destension", "testinator", "foreigninator", " destina", "coordinated", " destinated", "testinated", "variination", "dependinated", "foreigninated", "Destination", "identination", "descension", "Destinator", "identina", "variinated", "foreignination", "dependination", "Destinated", " destining", "coordension", "validinated", "validinate", "testribution", "dependinator", "testination", "constribution", "variinate", "validination", "destinator", "destribution", "destinate", " destribution", "descinated", "targetination", "targetinate", "Destina", "Destribution", "constination", " destinator", "constining", "validinator", "dependinate"], "buffer": ["reader", "bin", "uffer", "iter", "sequence", "channel", "pool", "batch", "buff", "Buffer", "timeout", "binary", "cache", "text", "writer", "flush", "temp", "padding", "block", "image", "limit", "transfer", "memory", "header", "queue", "window", "input", "buf"], "bytes_read": ["Bytes_read", "bytesUnRead", "bytesUnfound", "bytes_set", "Bytes_Read", "Bytes_set", "Bytes_found", "bytesUnread", "bytes_Read", "bytesUnset", "bytes_found"], "in": ["reader", "bin", "connection", "lock", "login", "f", "data", "get", "current", "doc", "container", "session", "s", "ins", "stream", "p", "min", "In", "fe", "rec", "is", "log", "ssl", "b", "inner", "again", "r", "l", "val", "IN", "din", "line", "temp", "ini", "image", "inc", "or", "request", "path", "h", "nin", "url", "n", "read", "inn", "file", "as", "id", "a", "resource", "input", "out", "con", "token", "re", "serv"], "response": ["su", "answer", "data", "sequence", "true", "version", "question", "error", "reason", "respond", "body", "application", "received", "Response", "status", "model", "description", "text", "output", "success", "r", "line", "reply", "respons", "reset", "image", "feed", "api", "example", "request", "value", "object", "next", "update", "offer", "view", "uri", "server", "message", "result", "res", "resource", "header", "location", "onse", "report", "re", "json", "string", "dict", "resp"], "parentdir": [" parentdiff", "homeDir", "homedir", "hostdir", "parentfile", "hostdirectory", "partfile", "Parentdir", "rootdirectory", " parentdict", "parentdiff", " parentfile", "parentDir", "homediff", "hostdict", "parentsdiff", "rootlib", "partdirectory", " parentDir", "parentsfile", "parentsdir", "rootdir", "Parentdirectory", "parentlib", "parentsDir", "Parentdict", "partlib", "parentdirectory", "parentdict", "partdir", " parentlib", "homefile", " parentdirectory", "rootfile"]}}
{"id1": "9236363", "id2": "17729554", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"unJarStart": ["syncJarRest", "syncServerRest", "copyjarRest", "copyServerEnd", "copyJarPath", "syncJarStart", "copyZipEnd", "copyServerPath", "copyZipRest", "syncServerPath", "copyjarPath", "copyJarEnd", "syncServerEnd", "copyJarStart", "copyJarRest", "copyjarStart", "syncJarEnd", "copyjarEnd", "syncJarPath", "copyZipPath", "copyZipStart", "syncServerStart", "copyServerStart", "copyServerRest"], "jarPath": [" jarUrl", "relFile", "JarCh", "javaPath", " jarpath", "badUrl", "JarPath", "badPath", "javaText", "jarContent", "jarLog", " jarText", "Jarpath", "garContent", " jarName", "jamPath", "narPath", "relEntry", "badpath", "JarFile", "garPath", "zipPath", "archivepath", "garpath", "javaCh", "narpath", "javaLog", "zippath", "garUrl", "garText", " jarFile", " jarLog", " jarContent", "archiveLog", "archiveDir", "javaUrl", "badLog", "garFile", "JarContent", "jamLog", "jamDir", "jarpath", "jarUrl", "javapath", "javaName", "jarCh", "jarText", " jarDir", "javaEntry", "jarName", "relpath", "jarDir", "jampath", "jarFile", "javaFile", "zipEntry", "zipFile", "narCh", "archivePath", "JarName", "narName"], "jarEntryStart": ["jarFileStart", "tarentryPart", "jarFileFinish", " jarEntrySource", "jarEntName", "tarentryName", "jarEntryFollow", "jarImportPart", "tarEntrySource", "jarentryName", "jarAttemptStart", "tarEntryName", "jarFileEnd", "tarentryStart", " jarEntryPart", "jarPartEnd", "jarEntryEnd", "jarentrySource", "jarImportFollow", " jarImportPart", " jarFileEnd", " jarImportStart", "jarPartStart", "jarEntSource", "jarAttemptPart", " jarImportFollow", " jarImportEnd", "jarPartPart", "jarImportSource", "jarEntryName", "jarEntrySource", "jarImportStart", "jarAttemptEnd", "jarEntStart", "tarEntryStart", "tarEntryPart", " jarEntryEnd", "jarImportFinish", " jarFileFinish", "jarImportName", "jarFileSource", "jarentryPart", "jarEntryPart", " jarFileName", "jarImportEnd", " jarEntryName", "jarEntryFinish", "tarentrySource", " jarEntryFinish", "jarAttemptFollow", " jarFilePart", "jarentryStart", "jarEntPart", "jarFileName", "jarPartFinish", "jarFileFollow", " jarFileSource", " jarEntryFollow", "jarFilePart", " jarFileStart"], "path": ["work", "text", "source", "cookie", "cache", "json", "session", "config", "PATH", "image", "default", "loc", "left", "location", "dest", "directory", "url", "base", "name", "log", "code", "ith", "zip", "temp", "key", "template", "dir", "type", "ion", "ctx", "error", "pattern", "mode", "uri", "clean", "home", "root", "ath", "po", "conn", "data", "object", "graph", "api", "test", "mount", "id", "parent", "method", "prop", "output", "Path", "wd", "folder", "resource", "next", "string", "prefix", "step", "boot", "content", "p", "th", "inner", "system", "archive", "pass", "pointer", "ph", "it", "host", "patch", "ha", "file", "request", "route", "then", "right", "context"], "relPath": ["relativeName", "relativePath", " relPos", " relName", "Relpath", "RELPos", "relativeDir", "RELPath", " relDir", "relativePos", "relDir", " relpath", "RelDir", "relName", "RELpath", "relPos", "relpath", "RelName", "RelPath", "RELName", "relativepath"], "jar": [" manifest", "pipe", "cookie", " parser", "ssl", "cache", "browser", "parse", "bar", "bag", "keeper", "com", "ball", "archive", "java", "rar", "ler", "per", " war", "war", "Jar", "drop", "sheet", "magic", "car", "module", "folder", "gap", "open", "sr", "ar", " dir", "url", "log", "fire", "server", " module", "ge", "zip", "sl", "sp", "dr", " tar", "plugin", "spin", "tar", " archive", "space", "start", "ser", "pack", "dir", " capsule", "er", "tab", "her", "mag", "xml", "pkg", "jo", "zone", " java"], "entries": ["quents", "enders", "entryries", "Entrys", "counters", "entryers", "antry", "Enties", "Entry", "countries", "antlements", "entEntry", "ientlements", "entryEntry", "Entursions", "itories", "ientries", "iters", "ENTents", "Entlements", "entensions", "entents", "quies", "itrys", "adders", "countensions", "entrys", "enters", "ientursions", "enties", "itries", "ENTies", "Enters", "quries", "entryensions", "endries", "entursions", "addries", "countEntry", "addensions", "antursions", "Entries", "ENTlements", "ENTries", "antries", "Entents", "addEntry", "endrys", "entories", "Entories", "entlements", "endories", "ientry", "qulements"], "entry": ["ent", "pie", " Entry", "se", "parse", "ry", "cat", "Entry", "e", "ie", "ler", "de", "enter", "cel", "oe", "or", "lie", "module", "resource", "ce", "la", "be", "name", "ries", "add", "mer", "it", "server", "ge", "obj", "zip", "address", "je", "element", "part", "r", "pack", "key", "reader", "jo"], "jarEntry": ["javaRule", "serFile", "celRule", "javaPath", "archiveRule", "jarEnt", "jobImport", "jobEntry", "javaentry", "jobentry", " jarEnt", "carEnt", " jarImport", "jarRule", "jobPath", " jarentry", "celEntry", "carElement", "archiveEntry", "javaElement", "archiveElement", "carPath", "archiveName", "javaName", "javaImport", "celFile", "javaEntry", "archiveFile", "jarName", "serEntry", "jarentry", "archiveEnt", "jarFile", "javaFile", "celEnt", " jarElement", "jarImport", "serName", "javaEnt", "jarElement", "carEntry", "serElement"], "ze": ["se", "z", "zer", "aze", "e", "ie", "kee", " ace", "cel", "ZE", "zy", "za", "ce", "ne", "ke", "be", "ide", "jo", "ja", "pe", "te", "code", "ge", "zip", " je", "sl", "fe", "zo", "li", "je", "zie", "zes", "ine", "zen", "xe", "ipe", "le", "zi"], "bin": ["init", "inn", "bar", "abin", "pin", "inner", "bb", "gi", "info", "len", "bas", "sin", "abi", "data", "ini", "in", "win", "resource", "proxy", "binary", "bot", "bi", "isin", "arin", "bit", "base", "log", "vin", "bn", "zip", "body", "index", "bank", "lock", "di", "cin", "plugin", "spin", "lib", "file", "kin", "login", "boot", "zone", "bis"]}}
{"id1": "18489832", "id2": "15580610", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"downLoadZippedFile": [" doLoadZaggedFiles", " doLoadZedFiles", " doLoadZippedFiles", " doLoadzippedFiles", " doLoadZaggedContent", " doLoadZippingDir", " doLoadzippingContent", " doLoadZippingFile", " doLoadZaggedDir", " doLoadzippedFile", " doLoadzippingFile", " doLoadZippingContent", " doLoadZaggedFile", " doLoadzippingFiles", " doLoadzippedContent", " doLoadZedDir", " doLoadZippedFile", " doLoadZedContent", " doLoadzippedDir", " doLoadzippingDir", " doLoadZippingFiles", " doLoadZedFile", " doLoadZippedContent", " doLoadZippedDir"], "url": ["ur", "proxy", "page", "log", "uri", "ssl", "resource", "image", "server", "ll", "b", "connection", "event", "store", "link", "f", "zip", "route", "URL", "download", "i", "source", "pull", "config", "client", "l", "web", "lr", "base", "r", "file", "c", "loader", "sl", "bug", "Url", "or", "update", "http", "lib", "open"], "destDir": ["destFile", " destFile", " destFolder", "tempFile", "destdir", "destFolder", "tmpdir", "tempFolder", " destdir", "tmpDirectory", " destDIR", "tmpDIR", "outputFile", "DestFile", "outputDirectory", " destDirectory", "DestDir", "tempDIR", "tempDir", "outputDIR", "outputDir", "outputFolder", "DestDIR", "destDIR", "destDirectory", "outputdir", "tmpDir", "DestFolder"], "urlConnection": ["urlNetwork", "webConnect", "URLChannel", "urlConnect", "URLconnection", "webChannel", "httpNetwork", "httpFactory", "URLConnect", "webconnection", "downloadNetwork", "webConnection", "URLConnection", "fileConn", "fileFactory", "urlConn", "urlChannel", "urlconnection", "downloadFactory", " urlConnect", " urlChannel", "httpConnection", "fileNetwork", "fileConnection", "downloadConnection", "urlFactory", "downloadConn", " urlconnection", "httpConn"], "tmpFile": ["destFile", "mpfile", "mpFile", " tmpFolder", " tmpPath", "partfile", "mpPath", "tempPath", "tmpFolder", "destWorld", "zipFiles", "tmpfile", "TempPath", "tempFile", "tmpFiles", "destFolder", "tempFiles", "tempEntry", " tmpFiles", "partFolder", "tmpPath", "partFile", "mpDir", "TempWorld", "destPath", "tmpLine", "Tempfile", "tempLine", "partDir", " tmpLine", " tmpfile", "tmpEntry", " tmpDir", "mpFolder", "zipFile", "tempfile", "zipfile", " tmpWorld", "tempDir", "destEntry", "zipLine", "mpFiles", "tmpWorld", "destfile", "tmpDir", "TempFile", " tmpEntry"], "in": ["ex", "ins", "In", "copy", "ax", "n", "connection", "en", "init", "info", "data", "sync", "inc", "socket", "gin", "f", "input", "din", "IN", "lin", "inn", "Out", "conn", "cin", "i", "is", "win", "source", "reader", "kin", "rin", "pull", "nin", "l", "a", "login", "work", "inner", "min", "r", "id", "token", "ac", "bin", "err", "con", "c", "file", "up", "pin", "ini", "as", "arin", "again"], "out": ["at", "ex", "writer", "one", "server", "call", "copy", "In", "null", "n", "connection", "cmd", "init", "io", "off", "outer", "this", "sync", "inc", "socket", "output", "no", "check", "o", "index", "IN", "Out", "conn", "download", "i", "source", "client", "nin", "co", "login", "inner", "point", "outs", "min", "exec", "bin", "file", "err", "obj", "name", "up", "OUT", "op", "again", "line", "ext"], "localURL": ["externalAPI", "LocalCL", "LocalAPI", "LocalUrl", " localFile", "localFile", "externalCL", "localAPI", "remoteURI", " localCL", "externalURL", "localCL", "externalUrl", "remoteURL", " localAPI", "localURI", "remoteUrl", " localURI", "remoteFile", "LocalURL", "localUrl", " localUrl", "baseFile", "baseURI", "baseURL", "baseUrl"]}}
{"id1": "19849797", "id2": "22135199", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"copyFile": ["cloneFile", " copyfile", " copyFiles", "transferFile", "cloneFiles", "copyfile", "cloneSource", "transferFiles", "copyFiles", "clonefile", "copySource", "transferSource", " copySource", "transferfile"], "sourceFile": ["srcDir", " sourcefile", "SourceFile", "SourceUrl", "sourcefile", "destUrl", "ourceDirectory", "destfile", "SourceDir", "SourceDirectory", "srcfile", "SourceFolder", "ourceFile", "ourceUrl", "sourceUrl", "destDirectory", " sourceFolder", "srcFile", "sourceFolder", "Sourcefile", "sourceDirectory", "sourceDir", "ourcefile", "srcFolder", " sourceDir"], "destFile": ["targetFile", "destPath", "resultfile", "sourceFiles", "resultDir", "destDir", "srcDir", " destDirectory", "foreignFiles", "srcFiles", "DestDirectory", "destPoint", "targetPath", "destfile", "foreignFile", "destFiles", "srcfile", "DestPath", "Destfile", "resultLine", "srcDirectory", "resultFile", "DestFile", "targetFiles", "destDirectory", "srcLine", "srcFile", "DestPoint", "sourcePoint", "foreignfile", " destFiles", "destLine", "DestDir", "sourceDir", "targetLine", " destDir", "DestFiles", " destPoint", "targetfile", "foreignPath", "targetDir", " destfile"], "source": ["resource", "scene", "slave", "root", "status", "route", "si", "use", "seed", "channel", "current", "cache", "context", "Source", "table", "view", "inner", "proxy", "service", "scope", "input", "ource", "manager", "api", "from", "slice", "this", "dest", "ce", "object", "unit", "ie", "connection", "storage", "server", "url", "get", "component", "config", "size", "index", "iter", "session", "wrapper", "image", "SOURCE", "start", "sin", "remote", "result", "file", "reader", "output", "secure", "target", "null", "id", "parent", "stream", "client", "uri", "src", "site", "core", "reference"], "destination": ["dominated", "identination", "identinated", "Destruction", "participination", " destinator", "participinate", "domination", "constinator", "construction", " destribution", "generination", " destation", "destribution", "generinated", "Destation", "destinator", "destation", "distruction", " destion", "generinator", "Destinator", "Destination", "destion", "dominator", "destinated", "Destion", "Destinated", "Destinate", "destinate", "constination", "destruction", "participinated", "generruction", "Destribution", " destinated", " destruction", "identinate", "distinated", "identinator", "distination", "distinator", "distion", "domation", "constribution", "participinator"]}}
{"id1": "4599372", "id2": "9236363", "code1": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"readFixString": ["readfixString", "createFixedstring", "createFixedArray", "createFixContent", "readAdjustString", "readFixedArray", "readAdjustArray", "readAdjustContent", "createFixedContent", "createFixedString", "readFixContent", "readAdjuststring", "readFixedContent", "createFixstring", "createFixArray", "readFixedstring", "readfixContent", "readfixArray", "readFixstring", "createFixString", "readFixArray", "readFixedString", "readfixstring"], "len": ["lt", "line", "n", "string", "limit", "str", "le", "Len", "ll", "list", "length", "lit", "count", "fn", "loc", "l", "part", "base", "pos", "lin", "size", "sl", "f", "enc", "e", "code", "i", "li", "lp", "el", "split", "val", "file", "data", "en", "lf", "body", "ln", "lc"], "sw": ["wh", "wt", "sh", "so", "nw", "serv", "zip", " SW", "sf", "iw", "tw", "wx", "io", "sc", "wa", "sa", "Sw", "ew", "ww", "sr", "wp", "w", "fw", "WS", "sn", "sp", "aw", "ws", "sb", "sl", "SW", "hw", "wra", "rw", "lv", "writer", "wr", "bb", "fl", "sv", "null", "es", "stream", "wb", "ss", "ow"]}}
{"id1": "21063400", "id2": "14794404", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "label": 0, "substitutes": {"doImageProcess": [" doImageFile", "doimageProcess", "doFileFile", "doThumbnailProcess", " doimageProcess", "doimageprocess", "doimageFile", "doThumbnailFile", " doimageprocess", "doImageprocess", " doimageFile", "doThumbnailprocess", " doImageprocess", "doFileProcess", "doFileprocess", "doImageFile"], "request": ["req", "writer", "url", "resource", "image", "server", "message", "report", "method", "data", "application", "model", "result", "input", "Request", "type", "xml", "instance", "reader", "config", "client", "header", "stream", "object", "name", "path", "query"], "response": ["wave", "resp", " Response", "page", "description", "writer", "respond", "default", "report", "message", "server", "image", "resource", "example", "complete", "view", "Response", "connection", "body", "version", "more", "session", "output", "application", "document", "status", "result", "site", "model", "reply", "index", "error", "out", "results", "api", "client", "queue", "object", "video", "cache", "success", "service", "host", "next", "full", "json", "location", "pool", "collection", "http", "feed", "ception", "onse"], "imgSize": ["ifSize", "imgC", "largeSize", "bgWidth", " imgLength", "dimSize", "imgLen", "augLen", "imagesize", "bgLength", "hrType", " imgWidth", "refSize", "imgHeight", "bgScale", "augWidth", "ifName", "imgWidth", "imagsize", "imgLength", "imHeight", "dimsize", " imgFamily", "ifLen", "imageLength", "imageSize", "dimHeight", "imageName", "refLength", "augSize", "imageLen", "imSize", " imgLen", "imageScale", "hrSize", "imLength", " imgName", "dimLength", "imgsize", "largeType", "bgLen", "imgScale", "bgSize", "imagType", "imgType", "imagC", "ifsize", "refHeight", "refsize", "hrsize", "augFamily", "imgFamily", "bgFamily", "imagSize", "largesize", " imgScale", "largeC", "imsize", " imgsize", "imgName", "hrC"], "imageInputStream": [" imageOutputSteam", "imageInstream", " imageOutputView", "imageReadFile", "imageStreamStream", "imageContentSteam", " imageInputFile", "imageInString", "pictureUploadFile", "imageInputSteam", "imageReadLength", "pictureUploadStream", "imageUploadstream", "imageReadstream", " imageOutputFile", "imageFilestream", "fileInputString", "imageFileString", "imageReadString", "imageInputFile", "imageInputView", "imageOutputView", "pictureInputstream", "imageInputstream", "pictureInputSteam", "fileReadStream", "fileInputstream", "imageUploadView", "photoReadSteam", "photoInputStream", "photoInputFile", "pictureUploadstream", "pictureInputStream", "pictureUploadSteam", "imageOutputFile", "imageReadStream", "fileInputLength", "fileInputStream", "photoReadStream", "photoInputSteam", "imageContentView", "pictureInputFile", "imageUploadStream", "imageUploadSteam", "imageOutputSteam", "fileReadString", " imageInputView", " imageOutputStream", "imageStreamFile", " imageInputSteam", "imageInLength", "imageStreamSteam", "imageInputString", "imageContentStream", "imageInStream", "fileReadstream", "imageContentFile", "photoReadstream", "imageStreamstream", "imageFileLength", "photoReadFile", "fileReadLength", "imageUploadFile", "imageFileStream", "imageReadSteam", "photoInputstream", "imageOutputstream", "imageOutputStream", "imageInputLength"], "imageBytes": ["imgBytes", "fileBlocks", "ImageBlocks", "audioBytes", "viewbytes", " imageUrl", "ImageData", "fileBytes", "viewBytes", "Imagebytes", "imageUrl", "fileData", "pictureData", "imageByte", "imgByte", "imgData", "audioBuffer", "viewData", "audiobytes", " imagebytes", "imagebytes", "imageBlocks", "ImageBytes", "imgBuffer", " imageData", "imageData", "audioByte", "filebytes", "picturebytes", "imgUrl", "viewUrl", " imageBuffer", "pictureBlocks", "imageBuffer", "imgbytes", "pictureBytes", " imageByte"]}}
{"id1": "494226", "id2": "13063241", "code1": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"linesep": ["timeseps", "linpace", "linedew", "linesearch", "linesupp", "linesew", "linep", "linspec", "linerspec", "timesep", "geseps", "lineupp", "linersew", "codeseps", "lineps", "linepace", " linesupp", "codesep", "lineseper", "linsew", "nsep", "nseps", " lineseng", " linesearch", "linedip", "linerseter", "linedep", "linersip", "linersearch", "linesip", "inesep", "timesyp", "ringsep", "linerseps", "codesip", "lineeps", "lineearch", "linseng", "linpe", "linesaper", " lineseper", " linesew", " lineseter", "linespe", "linespec", "linerseng", "linyp", "gesyp", "gespe", "linepec", "codesew", "linesyp", "linspace", "gesep", "linsep", "timespe", "linseps", "linespace", "inesaper", "linersep", "ringsupp", " linespace", "ineseps", " lineseps", "linseter", "nsaper", " linesaper", "lineseps", "ineseper", "lineep", " linespec", "lineseter", "nseper", "ringspace", "linpec", "ringspec", "linedeps", "lineseng"], "fos": ["eo", "Foses", "FOs", "zol", "forats", " fOS", "infotes", "fios", "fullis", "goss", "fops", "infops", " fios", "infoses", "pols", "fulloes", "focks", "Foss", "infol", " fOs", "loadOs", "fingoss", "foros", " fats", "infoes", "eos", "Fes", "fats", "fo", " fops", "fingos", "fulloser", " fes", "infis", "Focks", "poos", "foes", "fotes", "foses", "fes", "cols", "Fos", "zotes", "Fios", "eotes", "foss", "Foser", "fol", "go", "coos", "fols", " foS", "fingocks", "Fops", "cos", "infols", " foser", "loadops", "Fis", "loados", "coes", "Fats", " fis", "forOS", "Fo", "foroses", " foes", "foser", "infios", "eol", "fingo", "gos", " foses", "infos", "foos", "poes", " fo", "foS", "pos", "gocks", "FoS", "fOS", "fullos", "zo", "infoos", "fis", "FOS", "zos", "fOs", "infes", "Foes", "info", "loadoS"], "files": ["pages", "boxes", "names", "classes", "books", "bs", "bugs", "resources", "lines", "apps", "results", "http", "ids", "headers", "images", "tools", "objects", "events", "ins", "groups", "members", "plugins", "locks", "fs", "facts", "tests", "l", "obs", "strings", "ls", "projects", "balls", "scenes", "ports", "f", "services", "keys", "thumbnails", "blocks", "features", "archives", "rules", "states", "data", "items", "docs", "Files", "iles", "rows", "workers", "users", "jobs", "lets", "file", "models"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "ini", "ii", "c", "m", "pi", "current", "col", "y", "d", "inner", "ci", "di", "io", "z", "slice", "ji", "ui", "ri", "count", "ie", "it", "p", "phi", "j", "I", "fi", "eni", "index", "f", "e", "oi", "li", "start", "v", "gi", "ti", "type", "ai", "yi", "b", "xi", "t", "id", "info", "uri", "ix"], "metaprops": ["metaporeps", "metopproperties", "metepropps", "metaparpps", "metepprops", "metappropp", "metoppropps", "metaproperties", "metepropes", "metaprobps", "metaparp", "metaprospes", "metapropp", "metaprope", "metoprop", "meteprope", "meteppropes", "metapPropps", "meteppropps", "metapPrope", "metoprops", "metaporepe", "metapropps", "metapproperties", "metaporepps", "metapprops", "metopropes", "metaprobperties", "metaprpe", "metaprosps", "metaprobpp", "metappropes", "metaprop", "metopprops", "metaprobpps", "metaprobpe", "metappropps", "metaprobp", "metoppropes", "metaparpp", "metapprop", "meteprops", "metaprobpes", "metaprospps", "metapProps", "metapropes", "metoproperties", "metoppropp", "metaparps", "metepprope", "metapPropes", "metoprope", "metaporepes", "metopropps", "metopprope", "metopropp", "metaprosperties", "metopprop", "metaprpes", "metaprpps", "metaprps", "metapprope"], "itsect": ["itssect", "litect", " itsection", " itna", "itconnect", "litna", "itersect", "itna", "itrupt", " itect", "itssector", "Itect", " itconnect", "iterconnect", "Itsection", "itssection", "iterrupt", "itsection", "litsect", "Itrupt", " itrupt", "Itna", "Itsector", "itect", "Itsect", " itsector", "itsector", "Itconnect", "litrupt", "iterect"], "section": ["entry", "route", "line", "function", "description", "string", "step", "environment", "version", "script", "area", "service", "ion", "ect", "search", "year", "division", "key", "vision", "second", "child", "mission", "header", "loc", "ie", "sect", "part", "rc", "element", "j", "config", " Section", "array", "sec", "Section", "set", "protection", "sector", " sections", "page", "closure", " subsection", "esc", "job", "sub", "account", "edition", "text", "ection", "name", "sections"]}}
{"id1": "7981642", "id2": "10715601", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"update": ["save", "login", "data", "edit", "create", "put", "change", "send", "setup", "set", "add", "copy", "register", "user", "check", "text", "u", "and", "password", "key", "updated", "address", "Update", "build", "init", "exec", "h", "delete", "url", "config", "sum", "sign", "post", "up", "append", "replace", "UPDATE", "auth", "push", "insert", "write", "end", "apply"], "mail": ["ul", "msg", "office", "gmail", "alt", "login", "lock", "name", "phone", "mails", "m", "ge", "gal", "xml", "label", "Email", "local", "model", "html", "user", "text", "front", "zip", "old", "password", "address", "md", "proxy", "fax", "source", "value", "url", "hello", "uri", "server", "date", "group", "view", "file", "folder", "dial", "id", "message", "Mail", "contact", "dir", "host", "company", "who", "string", "ip", "username"], "email": ["office", "gmail", "ail", "cdn", "alt", "login", "cn", "name", "phone", "archive", "wd", "note", "mails", "el", "info", "dn", "en", "xml", "Email", "inet", "class", "log", "model", "description", "text", "online", "zip", "old", "line", "password", "address", "md", "nick", "fax", "url", "enter", "li", "n", "uri", "server", "hello", "eu", "folder", "file", "id", "message", "Mail", "dir", "host", "home", "addr", "ip", "element", "username"], "pwd": ["pwt", "cpwd", "cpws", " pWD", "Pws", "ppwd", "Ppassword", "hwd", "hwa", " ppass", "pwa", "hWD", "Pwd", "Pwh", " pwa", " pwt", "ppassword", "cpwt", "Ppass", " pwh", "cpWD", "pWD", "pwh", "Pwa", "ppwh", "hpass", "PWD", "Pwt", "pws", " pws", "pppassword", " ppassword", "ppass", "pppass"], "firstname": ["firstemail", "caseName", "lastkey", "lastuser", " firstName", "hostname", "lastnames", "casename", " firstuser", "lastName", " firstpass", "firstkey", "lastpass", "firstuser", " firstnames", "hostemail", "firstnames", "newuser", "firstpass", "casepass", "hostkey", "newname", " firstemail", "hostName", " firstkey", "caseemail", "lastemail", "newnames", "firstName"], "lastname": [" lastday", "lastkey", "firstday", "lastn", "secondName", "lastnames", "fullname", "lastName", "firstkey", " lastaddress", "firstaddress", "fulln", "lastday", " lastName", "secondname", "lastaddress", "secondkey", "firstnames", " lastnames", " lastn", "fullnames", "fullday", " lastkey", "fullName", "firstn", "firstName", "secondaddress"], "connection": ["manager", "nc", "pool", "handler", "database", "sc", "session", "creator", "ca", "m", "application", "lc", "di", "conn", "b", " Connection", "client", "this", "connected", "condition", "cc", "connect", "db", "cf", "h", "object", "response", "ion", "system", "context", "config", "document", "relation", "server", "Conn", "c", "function", "management", "index", "con", "directory", "Connection", "communication", "bc", "graph"], "attrs": ["attacts", "attks", "attributes", "attras", "Attps", " attks", "atras", "attars", "matps", "atributes", "attps", " attr", "atRS", "Attributes", "Attrs", " attRS", "AttRs", "addars", "atr", "addras", "atrs", "addributes", "attRs", " attRs", " attributes", "addRS", " attps", " attacts", "atps", "Attr", "addRs", "atars", " attars", "attr", "atks", "matars", "addps", "addrs", "matrs", "Attars", "attRS", "Attras", "atacts", "matributes", "Attacts", "addr", "addks"], "sha": ["ema", "meta", "volume", "ka", "ha", "sche", "si", "ua", "ca", "ma", "na", "da", "pi", "lambda", "shi", "base", "hi", "acl", "ami", "mac", "alias", "password", "va", "la", "md", "sm", "wa", "h", "asha", "sum", "sa", "mm", " SHA", "ga", "a", "pa", "eta", "pg", "alpha", "ya", "SHA", "sh", "HA"], "digest": ["mdest", "modEST", " digester", " digests", "DigEST", "diggest", "Digester", "digested", "moded", "modests", "Digcode", " diggest", "digester", "tagest", "digEST", "diged", " digcode", "mdested", "mdester", "mdgest", "digcode", "Diged", " digEST", "Digested", "Diggest", "modest", " diged", "tagester", "digests", "tagcode", " digested", "tagested", "Digest", "Digests"], "hash": ["rh", "bin", "ag", "ha", "hed", "version", "body", "array", "enc", "hex", "bh", "base", "match", "dig", "user", "mac", "her", "kh", "password", "key", "secret", "block", "image", "build", "value", "h", "url", "sum", "code", "raw", "message", "ash", "cover", "auth", "Hash", "json", "html", "sh"], "ctx": [" cx", " rc", "cb", "qa", "loc", "Context", "cn", " cs", "cca", "fw", "sc", "ca", " conn", "ct", "hw", "ck", "pc", "rc", "cs", "lc", " context", "cci", "conn", "jp", "cr", "client", "sq", "cmp", "ci", "cc", "vc", "anc", "cf", "xc", "context", "cl", "config", "conv", "cu", "cv", "c", "cas", "tc", " c", "ctrl", "cm", "mc", "cp", "tx", "bc", "pkg"], "newName": ["oldAddress", " newAddress", "newEmail", "Newname", "oldname", "oldEmail", "newAddress", "NewName", " newEmail", "newname", "NewAddress", " newname", "NewEmail"], "oldName": ["oldHome", "origname", " oldAddress", "OldName", "newHome", "OldHome", "newAddress", "OldAddress", " oldPath", "OldPath", "origName", " oldEmail", "Oldname", "oldname", " oldname", "oldPath", " oldHome", "oldAddress", "OldEmail", "newEmail", "oldEmail", "origPath", "origEmail"]}}
{"id1": "1954410", "id2": "8430178", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitexecuteRun", "doExecRun", "submitexecuteute", "doSendApply", "submitexecuteutes", "doSendute", "doExecutes", "submitExecute", "doexecuteRun", "submitExecRun", "doexecuteutes", "doexecuteApply", "doExecApply", "submitexecuteApply", "doSendutes", "doexecuteute", "doSendRun", "submitExecApply", "submitExecutes"], "mapping": ["finding", "minding", "amapping", "fapper", "mapper", " mapper", "amatching", "fapping", "matching", "amapper", "aminding", " matching", " minding", "fatching"], "form": ["flow", "method", "field", "Form", "formation", "feed", "submit", "config", "forms", "format", "transform", "pattern", "post", "object", "page", "builder", "definition", "dom", "control", "command", "xml", "app", "component", "FORM", " forms", "template", "url", "owner"], "request": ["re", "_", "method", "model", "resource", "q", "create", "ware", "submit", "this", "view", "self", "current", "format", "Response", "input", "json", "worker", "req", "message", "add", "queue", "use", "Reply", "object", "QUEST", "Bytes", "application", "Accept", "session", "route", "path", "query", "Request", "hello", "type", "result", "uri", "frame", "pull", "client", "context", "xml", "Upload", "report", "name", "server", "user", "data", "HTTP", "parent", "call", "instance", "s", "reader", "complete", "requ", "url", "address"], "response": ["model", "resource", "view", "Response", "json", "req", "message", "output", "object", "page", "application", "status", "resp", "handler", " responses", "result", "v", "client", "Resp", "xml", "report", "server", "data", " Response", "res", "reply"], "errors": [" calls", " logger", " management", " managers", " changes", " events", " replies", " Messages", " logs", " mess", " streams", " commands", " session", " this", " messaging", "mess", " responses", " payload", " failures", " messenger", " messages", " error", " translations", " status", " flashes", " problems", " updates", " acc", " warnings"], "isMultipart": ["isMultipost", "isMultippart", "isMultiipPart", "isMultippedart", "isMultIPound", "isMultitart", "isMultipated", "isMultitarts", "isMultiarts", "isMultitated", "isMultiIPound", "isMultiIPart", "isMultipound", "isMultiated", "isMultiipart", "isMultipage", "isMultIPart", "isMultiage", "isMultIPost", "isMultompPart", "isMultippedPart", "isMultippedost", "isMultippedound", "isMultIPPart", "isMultiparts", "isMultompound", "isMultitage", "isMultiipound", "isMultippage", "isMultompost", "isMultompart", "isMultipparts", "isMultiIPost", "isMultipPart", "isMultiipost", "isMultiIPPart", "isMultiart", "isMultippated"], "mailInstance": [" emailinstance", "mailManager", "fileManager", " emailInst", " emailInstance", "fileUsage", "mailUsage", "emailInst", " mailManager", "mailinstance", "emailinstance", " mailUsage", " mailinstance", "fileInstance", "fileInst", "emailManager", " mailInst", "mailInst", "emailInstance", " emailUsage", "fileinstance"], "fields": ["archives", "gets", "boxes", "field", "comments", "objects", "posts", "keys", "forms", "types", "locks", "changes", "utils", "input", "flows", "lines", "plugins", "links", "services", "maps", "details", "ments", "packs", "rules", "ids", "properties", "events", "views", "facts", "files", "uploads", "params", "groups", "headers", "rows", "atts", "lists", "cells", "acks", "holders", "checks", "tags", "states", "qs", "users", "members", "models", "features", "pages", "data", "forces", "classes", "loads", "words", "strings", "dates", "parts", "s"], "attachments": ["attachions", "attlements", " attachparts", "suppment", "extions", "exters", "supplements", "achresses", "attment", "attachers", "payresses", "Attachments", "attachps", "payment", " attachment", "attachparts", "payments", "achments", "suppments", "Attachlements", "attachlements", "payparts", "achparts", "attees", "suppees", "Attachps", "attions", "attachment", "extps", "attachresses", "attments", "atters", "achment", "Attachers", "attps", "Attachment", " attachresses", "attachees", "Attachions", "Attachees", "extments"], "items": ["its", "objects", "keys", "types", "locks", "phones", "ops", "children", "lines", "plugins", "links", "orders", "ids", "list", "events", "files", "apps", "groups", "rows", "Items", "lists", "apters", "qs", "ins", "reports", "models", "es", "alls", "ips", "pages", "data", "names", "results", "parts", "ers"], "iter": ["err", "ver", "outer", "end", "walker", "inner", "event", "coll", "ul", "order", "skip", "inter", "edit", "gener", "exp", "zip", "master", "ir", "http", "slice", "list", "finder", "page", "Iter", "li", "er", "itter", "izer", "it", "oper", "loop", "altern", "ip", "ner", "ite", "chain", "cher", "keep", "ter", "former", "file", "ser", "iterator", "el", "Iterator", "ator", "reader", "enter", "i", "loc", "inc", "upper"], "item": ["resource", "temp", "storage", "current", "full", "page", "hop", "element", "next", "result", "it", "layer", "name", "volume", "file", "source", "folder", "service", "slice", "api", "info", "example", "album", "token", "handler", "original", "Item", "issue", "all", "ip", "app", "server", "user", "instance", "reader", "get", "plugin", "base", "other", "inner", "event", "entry", "post", "object", "extra", "update", "atom", "custom", "er", "type", "attribute", "container", "entity", "data", "or", "anything", "obj", "image", "index", "section", "site", "coll", "val", "art", "order", "up", "load", "widget", "area", "more", "li", "missing", "i", "complete", "url"], "aux": ["aw", "lc", "ou", "des", "sub", "packages", "prefix", "aus", "ants", "offs", "abs", "alias", "except", " Aux", "anc", "aff", "ox", "axe", "uf", "extra", "sup", "array", "buf", "amp", "au", " auxiliary", "lang", "cmp", "ras", "etc", "cas", "off", "ups", "ext", "auc", "asc", "union", "data", "ux", "af", "abc", "pkg", "strings", "fax", "uc", "frac", "ru", "aos", "imp"], "part": ["action", "html", "field", "base", "plugin", "section", "change", "point", "step", "val", "po", "format", "pre", "art", "patch", "player", "obj", "group", "ref", "add", "back", "pair", "key", "area", "l", "ch", "b", "full", "object", "list", "info", "fact", "class", "pos", "act", "element", "pi", "join", "p", "type", "and", "diff", "comp", "layer", "block", "start", "but", "name", "joined", "partial", "co", "PART", "word", "component", "data", "user", "file", "on", "id", "instance", "Part", "f", "error", "per", "one", "no", "connection", "parent", " Part", "parts"], "baos": ["abaOs", "baOS", "baoss", " baOS", "BAoss", "bois", "bao", "bais", "boosh", "Bao", "BAos", "BAis", " baoS", "pao", "BAosh", "baot", "boOS", "hao", "BaOs", "Baos", "baosh", " baot", "haos", " bao", "abais", "Bais", "abaosi", "boot", "paos", "paosh", "BAoS", "BAOs", "boos", " bais", "baoS", "BAo", "BaoS", "baOs", "boo", "Baosi", "BAosi", "pais", "paot", "hais", "abaos", " baoss", "haoss", "paOS", "baosi"], "body": ["fee", "html", "resource", "options", "end", "Body", "content", "common", "json", "text", "message", "zip", "output", "shell", "b", "media", "full", "object", "string", "null", "summary", "flash", "params", "headers", "state", "pass", "query", "translation", "type", "parts", "length", "size", "name", "tree", "data", "document", "binary", "port", "description", "comment", "value", "connection", "template", "source", "reply", "url", "header"], "preferencesInstance": ["prefirmsClient", "prefiesInstance", "preffeesinstance", "prefferencesinstance", "prefirmsinstance", "preffeesClient", "prefferencesInstance", "prefiesinstance", "prefiesClient", "prefeesClient", "preffeesInstance", "preferencesinstance", "prefeesInstance", "preferencesClient", "prefirmsInstance", "prefferencesClient", "prefeesinstance"]}}
{"id1": "8000624", "id2": "1097146", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"CopyTo": ["copyFile", " copyTo", " transferFrom", " transferTo", "copyto", "CopyFrom", "Copyto", " copyFrom", " transferFile", " copyFile", " copyto", "copyTo", " transferto", "CopyFile", "copyFrom"], "dest": ["folder", "txt", "temp", "done", "class", "exit", "rest", "opt", "table", "dist", "bin", "destroy", "transform", " Dest", "path", "desc", "die", "object", "content", "sup", "comb", "w", "orig", "tmp", "delete", "flat", "filename", "Dest", "img", "output", "test", "data", "write", "them", "obj", "target", " destination", "source", "wb", "cont", "src", "name", "later", "file"], "in": ["fa", "In", "pull", "pass", "plus", "issue", "again", "n", "ini", "IN", "m", "cin", "inner", "din", "bin", "input", "as", "con", "wave", "pin", "ins", "ac", "conn", "inn", "kin", "up", "l", "connection", "init", "win", "s", "rin", "lin", "isin", "x", "gin", "thin", "f", "inside", "i", "nin", "image", "lib", "h", "sin", "login", "reader", "ax", "ln", "vin", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "temp", "or", "plus", "external", "not", "again", "outside", "n", "cache", "o", "ex", "call", "inner", "bin", "Out", "copy", "outer", "io", "outs", "this", "sync", "pin", "conn", "no", "user", "object", "our", "err", "up", "app", "part", "w", "net", "exec", "url", "x", "other", "off", "i", "nin", "image", "lib", "socket", "writer", "ext", "file", "output", "data", "ou", "OUT", "vert", "b", "target", "inc", "client", "name", "one"], "c": ["dc", "ch", "pc", "fc", "u", "cm", "n", "m", "col", "o", "ca", "pointer", "d", "comment", "abc", "ci", "ic", "xc", "sc", "char", "ct", "cf", "cu", "ac", "ce", "content", "C", "oc", "p", "cr", "cl", "cc", "l", "rc", "exc", "x", "config", "bc", "f", "enc", "e", "code", "i", "arc", "uc", "cb", "v", "r", "t", "cy", "ec", "esc", "buffer", "lc"]}}
{"id1": "8490710", "id2": "14191679", "code1": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 0, "substitutes": {"actualizar": ["actualisiada", "actualizeado", "actualizerar", " actualizeas", "actualizear", "actualizada", " actualizeado", "actualizeras", "actualizeas", " actualizado", " actualizas", "actualizas", "actualizeada", "actualisias", " actualizada", "actualizerado", "actualisiado", " actualizear", "actualisiar", "actualizado", "actualizerada", " actualizeada"], "ClassNotFoundException": ["ClassNameSupportedES", "ClassNameSupportedError", "ClassNotFindError", "ClassNotFoundES", "ClassNotPresentException", "ClassNameFoundException", "ClassNotPresentError", "ClassNotPresentES", "ClassNameFoundError", "ClassNotSupportedException", "ClassNotFindException", "ClassNotSupportedES", "ClassNameSupportedException", "ClassNameFoundES", "ClassNotFindES", "ClassNotSupportedError", "ClassNotFoundError"], "Exception": ["Application", "Event", "ERROR", "ceptions", "Default", "Warning", "Null", "Transaction", "Except", "EX", "X", "Element", "T", " exception", "Ex", "Exc", "Abstract", "Throw", "E", "Exp", "Connection", "Problem", "Failure", "ception", "F", "except", "Unknown", "Un", "Document", "Adapter", "Context", "Request", "Information", "Entity", "Fail", "W", "Error", "Class", "Interface", "IO", "Engine"], "conn": ["cm", "mc", "client", "ca", "ann", "util", "Connect", "ob", "ou", "reg", "jc", "cb", "db", "oci", "comm", "connect", "session", "oss", "sql", "state", "cr", "cp", "c", "ci", "cc", "ct", "en", "connection", "Connection", "n", "cs", "config", "enc", "loc", "nt", "pub", "mm", "sn", "ok", "dc", "p", "h", "pg", "rc", "col", "cli", "cn", "ch", "dh", "ens", "coll", "con", "nc", "cat", "Conn", "conf", "ctx"], "ms": ["mos", "md", "mc", "ins", "MS", "gm", "pse", "pm", "sem", "ts", "rs", "vs", "ws", "bm", "mo", "es", "ims", "mb", "ns", "mt", "ks", "res", "s", "cms", "ls", "sql", "mi", "os", "m", "ys", "models", "js", "cs", "mis", "ops", "ans", "ps", "mes", "mm", "tm", "cus", "ma", "ds", "fs", "em", "oms", "Ms", "mn", "mod", "hm", "me", "is", "ums", "ens", "ems", "mx", "mas", "qs", "DS", "keys", "ml", "details", "bs", "mp", "gs"], "fechaSystem": ["fechlaSys", "fechasSTEM", "febaServer", "fechetaSys", "fekaSystem", "fechaService", "fichasystem", "fechmasystem", "fetchasystem", "fetchaSTEM", "fechasSys", "fekaSTEM", "fechmaSTEM", "fechmaServer", "fekaSys", "fechlaSTEM", "febasService", "fechlaSystem", "fechtasystem", "fechmaService", "fechetaSystem", "fechtaSys", "fetchmaSTEM", "fechaServer", "fekasSys", "fechaSys", "febasServer", "fichlaSystem", "fechlasystem", "fetchmasystem", "fekasSystem", "febaService", "fechaSTEM", "fechasystem", "fechoSystem", "fechoSTEM", "fechosystem", "fechasServer", "fetchaSystem", "febasSys", "fechtaSystem", "fichaSys", "fekasSTEM", "febaSys", "fechmaSys", "fechetaService", "fechetaServer", "febasSystem", "fechasSystem", "fechasService", "fichaSystem", "fechmaSystem", "fetchmaSystem", "fichlasystem", "fechassystem", "fichlaSys", "febaSystem"], "aaaammdd": ["aaaymmdd", "aaaammd", "aaaaamdd", "aaaaamsd", "aaaaammsd", "aaaammsd", "aaaymmds", "aaaamtz", "aaaaammtz", "aaaasmds", "aaaaamds", "aaaymmd", "aaaaamtz", "aaaamds", "aaaymmsd", "aaaaammd", "aaaasmd", "aaaaammdd", "aaammtz", "aaaasmdd", "aaammds", "aaammsd", "aaaaamd", "aaaamdd", "aaaamd", "aaaammds", "aaammd", "aaaammtz", "aaammdd", "aaaaammds", "aaaasmtz", "aaaamsd"], "fzafsis": ["fzhahtics", "fzafsi", "fzahtics", "fzaphsi", "fzhahs", "fzaftics", "fzhafsi", "fzAFs", "fzaphtics", "fzhahsis", "fzaphsis", "fzahsi", "fzhahsi", "fzAFsis", "fzahs", "fzhafs", "fzafs", "fzaphs", "fzhaftics", "fzhafsis", "fzAFtics", "fzAFsi"], "hhmmss": ["HHMMds", "hhhmms", "hhmdess", "HHmmds", "hhMMs", "hhmmds", "hhmdds", "hhmlss", "hhhmmmds", "hhmds", "hhhmmess", "hhmmess", "HHmmms", "hhhmmms", "hhmss", "HHmmss", "hhhmmmess", "hhmlds", "hhhmmmss", "hhmdss", "hhmms", "HHMMms", "hhhmmds", "hhms", "HHmms", "hhmls", "hhMMess", "hhMMss", "hhmmmds", "hhMMms", "hhmlms", "hhMMds", "hhmmms", "hhhmmss", "hhmmmess", "hhmmmss", "HHMMs", "HHMMss"], "sss": ["rssp", "ussses", "\u00dfls", "\u00dfss", "hessns", "ssses", "\u00dfs", " ssses", "ssls", "rsss", " ssp", " ssss", "rssses", "hessls", "usss", "ussp", "hessss", "ssp", "rssns", "rssss", "ssss", "rssls", "ussss", "ssns", "hesss", "\u00dfns"], "ss": ["ross", "su", "less", "sv", "st", "account", "ng", "eps", "str", "ts", "rs", "vs", "ws", "ess", "uss", "sl", "oss", "ns", "string", "s", "ls", "styles", "struct", "tz", "xx", "nn", "si", "iss", "SS", "ses", "hh", "pps", "ssl", "hess", "sq", "js", "\u00df", "cs", "WS", "ps", "ass", "css", "ds", "fs", "pg", "pass", "rss", "ssh", "sf", "bs", "settings"], "fzahsis": ["fzafses", "fzafsi", "fzahtics", "fzavsi", "fzaftics", "fzavsis", "fzajses", "fzeaftics", "fzajsis", "fzeafsi", "fzavses", "fzeajses", "fzahsi", "fzeajtics", "fzajtics", "fzeafsis", "fzavtics", "fzahses", "fzeafses", "fzajsi", "fzeajsis", "fzeajsi"], "afectados": ["rafctados", "afemptados", "rafectado", "rafectados", "afescados", "afectionanos", "afescadas", "AFectadas", "afectionatos", "afemptatos", "rafectatos", "afescanos", "AFectanos", "rafctadas", "afemptadas", "afctados", "rafctatos", "afecanos", "afctado", "afctatos", "afectantes", "afectadas", "afectionados", "afecados", "rafctado", "afecantes", "afectionado", "AFectados", "AFecados", "AFecantes", "afescantes", "afectionantes", "afectionadas", "afectado", "AFectantes", "afemptado", "afectatos", "rafectadas", "AFecadas", "afectanos", "afctadas", "afecadas", "AFecanos"]}}
{"id1": "22993368", "id2": "13783549", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2String", "decodeStringToFile", "decodeFile2Stream", "decodeFile2Files", "decodeFileFromFiles", "decodeStringToStream", "decodeFileAsFiles", "decodeFileAsString", "decodeStringToFiles", "decodeFileFromFile", "decodeFileToStream", "decodeString2File", "decodeFileToString", "decodeFileFromString", "decodeFileFromStream", "decodeFile2String", "decodeFileAsFile", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeFile2File", "decodeString2Files", "decodeFileAsStream"], "infile": ["Inbase", "Infile", "infiles", "InFile", " inFile", " instream", "inFile", "Instream", "minstream", "inputfiles", "infilename", "inbase", "outfilename", "minfile", " infilename", "outfiles", "minbase", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "instream", " inbase", "inputfile", "minFile"], "outfile": ["outputfilename", "outputpath", "outpath", "inputdatabase", "infolder", "inputFile", " outpath", "outdatabase", "inFile", "outFile", "outputdatabase", "outfolder", " outfolder", "infilename", "outfilename", " outFile", "outputfile", "inputpath", " outfilename", "outputfolder", " outdatabase", "outputFile", "inputfile"], "in": ["gin", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "ini", "input", "ic", "In", "s", "conn", "inner", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "lin", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "log", "session", "conn", "obj", "In", "inner", "name", "to", "image", "write", "err", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "channel", "file", "up", "work", "pass", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "bin", "transfer", "feed", "raw", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "channel", "server", "source", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "connect", "seek", "length", "ind", "play", "start", "end", "write", "next", "len", "i", "count", "ride", "wait", "r", "n", "fill", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "positive", "error", "cess", " succ", "primary", "status", "follow", "ccess", "growth", "flash", "fast", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", "construct", " successful", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "comment", "response"]}}
{"id1": "11968328", "id2": "17158020", "code1": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getSHA32", "getMD32", " getCD5", "getSHA512", " getMD53", " getSHA5", " getCD32", " getMD32", " getSHA53", " getMC32", " getMC512", " getMC53", " getCD53", "getMD512", "getSHA53", " getCD512", " getMD512", " getSHA32", " getSHA512", "getSHA5", " getMC5", "getMD53"], "_pwd": ["_npass", "_sword", "_nwn", "_nWD", "_swd", "_dpass", "_sWD", "_Pword", "_pwn", "_dwd", "_Ppass", "_pWD", "_Pwn", "_nwd", "_spass", "_dword", "_dWD", "_pword", "_ppass", "_PWD", "_Pwd"], "md": ["mand", "mm", "mp", "amd", "wd", "dig", "cmd", "dm", "po", "mb", "meta", "mg", "ind", "m", "nm", "pg", "metadata", "mad", "ad", "mac", "bf", "editor", "rm", "sm", "vd", "um", "kg", "pd", "sha", " MD", "gb", "od", "dd", "mo", "mt", "hd", "cd", "MD", "dh", "mc", "ma", "df", "mu", "pkg", "mag", "pm", "db", "d", "bd"]}}
{"id1": "19206412", "id2": "4468255", "code1": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"md5String": ["md512string", "md4string", "md5Str", " md512Bytes", " md512string", "md512Bytes", " md512String", "md512String", "md5string", "md6String", "md6Str", " md5Str", "md6string", " md5Bytes", "md512Str", "md4Bytes", " md512Str", "md5Bytes", "md4Str", "md6Bytes", "md4String", " md5string"], "str": ["text", "kr", "char", "result", "re", "arr", "out", "st", "dict", "br", "Str", "f", "s", "this", "bytes", "pass", "e", "txt", "STR", "stri", "data", "strings", "star", "sr", "self", "url", "name", "hr", "obj", "msg", "sp", "dr", "string", "exp", "fr", "enc", "tr", "r", "er", "err", "doc"], "md": ["me", "mand", "hm", "mm", "mp", "mod", "amd", "Cmd", "wd", "mk", "dig", "cmd", "dm", "mb", "mg", "data", "m", "map", "metadata", "ad", "mac", "sm", "ms", "vd", "um", "code", "pd", " MD", "ld", "od", "dd", "mo", "mt", "hd", " Md", "am", "cd", "sum", "MD", "dh", "mc", "ma", "df", "mu", "mag", "pm", "db", "d", "cmp", "rpm", "bd", "mail"], "hash": ["dot", "char", "cache", "arr", "check", "ash", "memory", "f", "ver", "image", "count", "kh", "chip", "print", "url", "base", "array", "search", "Hash", "host", "code", "number", "sha", "hex", "body", "address", "index", "h", "header", "range", "sum", "sh", "filter", "block", "html", "ha", "value", "tr", "part", "key", "her", "diff", "id", "rh", "bin", "error"], "hexChars": ["hexKhars", "hexchacters", " hexchARS", "hexCharats", "hexChashes", "hexCHARS", "hexCharars", "hashChars", "hexchARS", "hexCharases", "hashchacters", "hexchats", "hashChash", " hexChARS", "hexCHats", " hexchashes", "hexChases", "hashChacters", " hexchats", "hexKhash", "hashchars", " hexChats", "hashCHashes", " hexChashes", "hexCHacters", "hexCharashes", "hashCHash", "hexCars", "hashCHars", "hashCHARS", "hashchases", " hexchars", "hexchashes", "hexchars", "hashchARS", "hexCHashes", "hexCHars", "hexKhARS", "hexCharARS", "hexChARS", "hexCHases", "hexChash", "hexChacters", "hexCharacters", "hexCash", "hashChashes", "hashChases", "hexKhashes", "hexChats", "hashChARS", "hexCashes", "hexCHash", "hexCARS", "hexchases"], "res": ["rules", "ris", "ret", "result", "ps", "cs", "re", "ss", "out", "arr", "us", "cache", "s", "reg", "bytes", "Results", "vals", "resp", "des", "data", "req", "RS", "rs", "vs", "ras", "ros", "RES", "bs", "rss", "Rs", "Result", "string", "rus", "pres", "details", "vers", "rez", "resolution", "rex", "ress", "Res", "css", "pers", "es", "abs", "r", "response", "results", "err", "rev", "cons", "rows"], "i": ["p", "x", "uri", "length", "field", "c", "f", "ai", "gi", "ii", "info", "ix", "e", "ie", "l", "I", "k", "ci", "abi", "m", "in", "multi", "ip", "io", "bi", "iu", "a", "si", "base", "b", "u", "it", "ti", "code", "ui", "pi", "oi", "ji", "index", "li", "j", "h", "hi", "di", "qi", "y", "xi", "temp", "part", "mu", "o", "id", "diff", "v", "ri", "d", "phi"]}}
{"id1": "14303294", "id2": "21395184", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    @Test\n    public void test30_passwordAging() throws Exception {\n        Db db = DbConnection.defaultCieDbRW();\n        try {\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"5\", 1);\n            PreparedStatement pst = db.prepareStatement(\"UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?\");\n            pst.setString(1, \"esis\");\n            db.executeUpdate(pst);\n            db.commit();\n            p_logout();\n            t30login1();\n            assertTrue(isPasswordExpired());\n            PeopleInfoLine me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().before(DateHelper.now()));\n            t30chgpasswd();\n            assertFalse(isPasswordExpired());\n            me = getCurrentPeople();\n            assertNotNull(me.getPasswordExpirationDate());\n            assertTrue(me.getPasswordExpirationDate().after(DateHelper.now()));\n            p_logout();\n            t30login2();\n            assertFalse(isPasswordExpired());\n            t30chgpasswd2();\n            db.begin();\n            Config.setProperty(db, \"com.entelience.esis.security.passwordAge\", \"0\", 1);\n            db.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            db.rollback();\n        } finally {\n            db.safeClose();\n        }\n    }\n", "label": 0, "substitutes": {"getServerHash": ["getSessionHash", "getServerAddress", " getServerAddress", "getSecureSalt", "getServerSalt", "getserverAddress", " getSecureAddress", "getserverHash", "getSessionAddress", "getserverSHA", "getSecureSHA", "getSecureHash", "getSecureAddress", "getserverSalt", "getSessionSalt", "getSessionSHA", " getServerSHA", " getSecureSalt", " getSecureHash", "getServerSHA", " getServerSalt", " getSecureSHA"], "passwordHash": ["passwordhash", " PasswordHash", " passwordCode", "PasswordHash", "passwordPass", "PasswordPassword", " passwordhash", "PasswordPass", " passwordPass", "privatePassword", " PasswordPass", " PasswordCode", "privatehash", "passwordCode", "privateHash", " passwordSalt", "passwordSalt", "privateSalt", " passwordPassword", "Passwordhash", "PasswordCode", "passwordPassword"], "PasswordSalt": [" PasswordHash", "password256", " passwordSecret", "PasswordHash", "PasswordPassword", "passwordSecret", "PasswordSecret", "PASSSalt", "PASSPassword", "PASSHash", " Password256", " passwordSalt", "passwordSalt", "Password256", "PASS256", " passwordPassword", " PasswordPassword", " PasswordSecret", "passwordPassword"], "hash": ["row", "sh", "string", "cache", "mac", "Hash", "sha", "response", "sum", "copy", "log", "search", "hex", "number", "key", "auth", "content", "user", "address", "kh", "build", "crypt", "ha", "base", "url", "work", "ash", "size", "array", "pool", "code", "value", "password", "her", "image", "h", "check", "result", "change", "html", "error", "data", "dig", "message", "update", "buffer", "block"], "digest": ["hashener", "digener", " digall", "generall", "hashest", " diger", "digusher", "mdest", "Digener", " digher", "Digester", " digusher", "integested", "mdested", "signest", "Digested", "integest", " digger", "digested", "digester", "signer", "Digusher", " digester", " digested", "Digher", "generest", "mdusher", "signester", "hasher", "hashester", "signher", "generester", "Diger", "diger", "Digger", "integester", "generested", " digener", "integall", "digger", "mdester", "Digest", "digher", "digall", "signger"]}}
{"id1": "20855053", "id2": "7166270", "code1": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 1, "substitutes": {"init": ["process", "connect", "loading", "load", "app", "construct", "install", "parse", "handler", "Init", "check", "register", "info", "boot", "resource", "Initialized", "build", "start", "activate", "loader", "log", "test", "it", "strap", "setup", "create", "config", "launch"], "context": ["request", "sc", "component", "obj", "tx", "ctx", "ce", "cc", "app", "parent", "e", "ex", "cf", " contexts", "or", "bc", "http", "exc", "req", "vc", "cl", "pc", "processor", "cms", "Context", "config", "c", "ec"], "classLoader": ["ClassWriter", "logPath", "objectLoad", "resourcePath", "ClassLoading", "objectLoader", " classLoading", "ClassPath", " classWriter", "logloader", "classWriter", " classloader", " classReader", "logWriter", "ClassLoad", "classPath", "resourceLoading", "classReader", "classloader", "logLoader", "ClassLoader", "classLoading", " classPath", "objectReader", "Classloader", "objectloader", "classLoad", "ClassReader", "resourceloader", "resourceLoader", " classLoad"], "urls": ["urlps", "URLches", " urllines", "resourcelines", "httpions", "sls", "URLps", "resourceions", "URLs", " urlps", "webs", "URLions", "webches", "webls", "resourcels", "urlis", "resources", "slls", "slches", "webis", "urlls", "urlions", "URLlines", "https", "resourceps", "httplines", "URLis", "urllines", "httpls", "urlches", "URLls", "slis", " urlls"], "url": ["lr", "r", "job", "image", "ball", "buffer", "sl", "ul", "element", "entry", "rl", "full", "host", "class", "object", "feed", "user", "layer", "ls", "bb", "id", "page", "coll", "server", "address", "loc", "result", "connection", "found", "http", "URL", "resource", "li", "pull", "io", "path", "ssl", "file", "link", "f", "Url", "channel", "base", "err", "gl", "loader", "b", "rel", "org", "ll", "name", "l", "browser", "string", "uri", "source"], "reader": ["r", "iterator", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "i", "feed", "ro", "input", "e", "rx", "handler", "server", "per", "or", "ler", "editor", "resource", "io", "keeper", "rr", "row", "reading", "file", "rar", "iter", "ri", "re", "loader", "er", "oder", "l", "upper", "parser", "read", "layer"], "className": ["stringType", " classDescription", "typeLine", "stringName", "lassType", "ClassPath", " classInfo", "Classname", "classString", "staticType", " classCode", "typeInfo", " classValue", "CLASSType", "classText", "stringInfo", "ClassLine", "clName", "urlName", "objectPath", "objectNumber", "clCode", "clInfo", " classString", "lassEl", " classNumber", "classLine", "urlname", " classPath", "caseDescription", "caseLine", "typeName", "clNumber", "staticname", "classDescription", "clString", "urlText", "lassBase", "classname", "clText", " classname", "classPath", " classType", "lassInfo", "classInfo", " classText", "objectname", "clBase", "staticEl", "CLASSName", "objectName", "classBase", "clname", "classType", "urlValue", "caseValue", "caseName", "typeType", "CLASSEl", "staticName", "objectString", "CLASSname", " classLine", "stringLine", "ClassString", "clValue", "classCode", "lassname", "classValue", "classEl", "lassCode", " classBase", "clPath", "lassName", "ClassValue", "classNumber", "ClassDescription", "ClassName"], "clazz": ["clclass", " cllass", "Clazz", "plade", "cluster", "class", " clclass", "clade", "Class", "glass", "gllass", "classazz", "classuster", "cllass", "pllass", "classlass", "glade", "classclass", "plazz", "glazz", "plass", "Cllass", "Clclass", "Clade", "Cluster", " cluster"]}}
{"id1": "6966398", "id2": "471804", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"reader": ["resource", "df", "or", "row", "reads", "ry", "k", "instance", "context", "o", "reading", "rake", "oder", "ler", "raf", "input", "cer", "manager", "io", "ner", "feed", "driver", "cms", "ri", "client", "pp", "keeper", "er", "handler", "book", "p", "connection", "rc", "pe", "server", "load", "dr", "config", "loader", "read", "Reader", "iter", "per", "rw", "her", "writer", "se", "rr", "r", "parser", "rar", "source", "stream", "buffer", "builder", "file"], "ks": ["ics", "acts", "akes", "reads", "kes", "hs", "KS", "ms", "books", "bs", "k", "opens", "ko", "checks", "gets", "orks", "ctx", "co", "ke", "powers", "acs", "fs", "qs", "ki", "ans", "ls", "inks", "acks", "cks", "vs", "ops", "ches", "keys", "icks", "cs", "ns", "ds", "ku", "CS", "kb", "ges", "ips", "sk", "se", "ps", "DS", "es", "rs", "works", "ck", "kies", "ss", "rows"], "key": ["Key", "seed", "k", "c", "cache", "pg", "ca", "secret", "ee", "service", "state", "io", "co", "char", "pair", "ke", "ce", "ring", "trust", "user", "p", "base", "ki", "court", "pe", "server", "keys", "read", "code", "value", "transfer", "ssl", "type", "point", "sign", "lock", "client", "file"], "chain": ["wrap", "root", "container", "c", "cache", "chains", "table", "wheel", "secret", "circle", "family", "path", "sequence", "box", "network", "list", "none", "slice", "pair", "object", "store", "cr", "rule", "mc", "scale", "base", "coll", "Chain", "config", "enc", "code", "set", "image", "range", "stack", "lock", "crypt", "block", "collection", "file"], "os": ["rss", "ms", "ol", "ios", "ob", "osi", "oid", "op", "o", "opens", "is", " o", "oss", "options", "io", "outs", "aos", "object", "bos", " bos", "p", "fs", "s", "pos", "los", "iso", "ops", "cos", "ot", "Os", "ds", "oses", "ros", "res", "ou", "ps", "es", "rs", "OS"], "stamper": ["starmple", "spampe", "function", " nostameple", "g", "spamper", " nostamler", "streampe", "stammper", "stAMper", "spammer", "path", "spAMpe", "stAMmer", "stampper", "stammple", "this", " nostamepper", "starmper", "stammpe", "starmpper", " nostamper", " nostameper", "stammmer", "s", "stAMpe", "stampe", "streammer", "stameple", "streamper", "spamler", "stamler", "spAMler", "stameler", "_", "stample", "starmler", "stammler", "stammer", "stammpper", "stamepper", "stAMler", "stameper", "data", " nostample", "streamler", " nostameler", " nostampper", "spAMper", "spAMmer"], "appearance": ["ppearance", "attfacing", "installear", "appasion", " appears", "ppearing", "suppearing", "byearance", "feedearance", "feedointment", "formismo", "atteared", "formearing", "appfacing", "askence", "appence", " appfacing", "appearing", "suppearance", "appismo", "ppaser", "signearing", "appointment", "attence", "feedfacing", "suppfacing", "byismo", "askeared", "feedear", " appeared", "Appearance", "signfacing", "ppear", "signear", "byearing", "suppasion", "signearance", "askearance", "installearing", "Appears", "formaser", " applier", "appears", "signointment", "askfacing", "formear", "byear", "installearance", "appear", "ppasion", "signears", "signlier", "attearance", "suppointment", "applier", "Appearing", " appence", "appaser", " appear", " appearing", " appaser", "formearance", " appismo", "installasion", "Applier", "suppear", "appeared"]}}
{"id1": "23199071", "id2": "22338097", "code1": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 0, "substitutes": {"getInputStream": ["getInputSteam", "newInputSteam", "getInputChannel", "getInputstream", "getReadStream", "newContentStream", "newContentChannel", "getStreamSteam", "newInputChannel", "getStreamstream", "getReadstream", "getContentstream", "newContentstream", "getContentSteam", "getStreamChannel", "getReadSteam", "getContentStream", "getStreamStream", "newInputstream", "newContentSteam", "getReadChannel", "getContentChannel", "newInputStream"], "url": ["image", "resources", "log", "html", "URL", "base", "resource", "in", "email", "feed", "lr", "service", "www", "q", "fr", "coll", "rule", "ul", "cl", "Url", "download", "ref", "http", "remote", "l", "api", "full", "href", "page", "left", "string", "class", "null", "link", "r", "bel", "route", "buffer", "path", "fl", "type", "rel", "uri", "build", "pull", "dir", "secure", "ur", "name", "location", "ssl", "tool", "loc", "host", "id", "data", "server", "ll", "ob", "gl", "user", "str", "sl", "i", "el", "rl", "default", "jar", "source", "web", "f", "address"], "file": ["File", "log", "folder", "base", "letter", "resource", "unit", "feed", "image", "child", "model", "rule", "plain", "fe", "http", "cache", "zip", "local", "play", "use", "l", "b", "info", "full", "object", "page", "class", "files", "route", "path", "work", "able", "job", "line", "part", "place", "uri", "fp", "dir", "FILE", "name", "live", "data", "id", "e", "money", "lib", "connection", "loc", "source", "db", "f"]}}
{"id1": "9796161", "id2": "17901739", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["getmd4", " getSHAHash", "getMD512", "getSHA512", "getmdHash", " getSHA5", "getmd512", "getmd5", "getHTML4", "getSHA4", "getHTMLHash", " getMD4", "getMD4", "getSHA5", " getMDHash", " getMD512", " getSHA4", "getMDHash", "getSHAHash", " getSHA512", "getHTML512", "getHTML5"], "s": ["services", "string", "ssl", "i", "input", "self", "n", " ads", "ns", "comments", "c", "S", "l", "styles", "bs", "abs", "si", "is", "ates", "in", "rs", "ms", "ings", "parts", "sync", "its", "ws", "source", "lines", "sb", "strings", "str", "g", " fails", "data", "gs", "ends", "ows", "scripts", "ips", "p", "es", "ts", "js", "e", "ls", "sets", "tests", "ss", "sym", "bytes", "a", "ses", "b", "v", "ds", "cs", "als", "os", "f", "ps"], "m": ["om", "tm", "mu", "um", "i", "arm", "vm", "M", "c", "l", "am", "wm", "mr", "manager", "ms", "sm", "ym", "cm", "mac", "d", "pm", "machine", "md", "mm", "h", "mi", "p", "hm", "fm", "e", "t", "dm", "mut", "nm", "mc", "mand", "me", "em", "v", "bm", "rm", "man", "f", "gm", "im", "module"]}}
{"id1": "11377441", "id2": "1005108", "code1": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void googleImageSearch(String search, String start) {\n        try {\n            String u = \"http://images.google.com/images?q=\" + search + start;\n            if (u.contains(\" \")) {\n                u = u.replace(\" \", \"+\");\n            }\n            URL url = new URL(u);\n            HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();\n            httpcon.addRequestProperty(\"User-Agent\", \"Mozilla/4.76\");\n            BufferedReader readIn = new BufferedReader(new InputStreamReader(httpcon.getInputStream()));\n            googleImages.clear();\n            String text = \"\";\n            String lin = \"\";\n            while ((lin = readIn.readLine()) != null) {\n                text += lin;\n            }\n            readIn.close();\n            if (text.contains(\"\\n\")) {\n                text = text.replace(\"\\n\", \"\");\n            }\n            String[] array = text.split(\"\\\\Qhref=\\\"/imgres?imgurl=\\\\E\");\n            for (String s : array) {\n                if (s.startsWith(\"http://\") || s.startsWith(\"https://\") && s.contains(\"&amp;\")) {\n                    String s1 = s.substring(0, s.indexOf(\"&amp;\"));\n                    googleImages.add(s1);\n                }\n            }\n        } catch (Exception ex4) {\n            MusicBoxView.showErrorDialog(ex4);\n        }\n        MusicBoxView.jButton7.setEnabled(true);\n        ImageIcon icon;\n        try {\n            icon = new ImageIcon(new URL(googleImages.elementAt(MusicBoxView.googleImageLocation)));\n            ImageIcon ico = new ImageIcon(icon.getImage().getScaledInstance(100, 100, Image.SCALE_SMOOTH));\n            MusicBoxView.albumArtLabel.setIcon(ico);\n        } catch (MalformedURLException ex1) {\n            MusicBoxView.showErrorDialog(ex1);\n        }\n    }\n", "label": 0, "substitutes": {"resolvePlugins": ["resolvePluginplugins", "resolvingPlugings", "resolvePluginings", "resolvePluginin", "resolvePlugINS", "resolvingPlugplugins", "resolvePluginINS", "resolvingPluginplugins", "resolvingPlugin", "resolvePlugings", "resolveplugins", "resolvingPlugINS", "resolvingPluginins", "resolvingPluginings", "resolvePlugplugins", "resolveplugings", "resolvePluginins", "resolvingPluginINS", "resolveInstallins", "resolveplugplugins", "resolveInstallplugins", "resolveInstallin", "resolvingPluginin", "resolveInstallINS", "resolvingPlugins", "resolvePlugin", "resolveplugin"], "cacheDir": ["acheDirectory", "cacheFolder", " cacheFolder", "CacheFolder", "outputDIR", "CacheDir", "pluginDir", "cacheDirectory", "acheDIR", "outputDir", "CacheDIR", "pluginDIR", "CachePath", "baseFolder", "pluginFolder", "pluginPath", "outputPath", "baseDir", "acheFolder", "cachePath", "acheDir", "baseDirectory", "outputFolder", " cacheDirectory", "baseDIR", " cacheDIR", "cacheDIR"], "pluginsFile": ["driversUrl", "insfile", "resultsFILE", " pluginsFolder", "pluginDir", " pluginsDir", " pluginsFILE", "driversfile", "pluginsFILE", "resultsfile", "pluginFile", "pluginsUrl", "pluginFILE", "versionsFile", "driversFILE", "pluginFolder", "pluginsFolder", "resultsDir", "insDir", "resultsFile", "insFile", "driversFile", "versionsUrl", "pluginsfile", "versionsFILE", "pluginsDir", "pluginfile", "insFolder", " pluginsUrl", "versionsfile", " pluginsfile"], "pluginURL": ["pluginsUR", "PluginURL", "configUR", "plugUrl", "plugURL", "pluginsurl", "pluginsUrl", "pluginFile", "configURL", " pluginUrl", "configurl", "pluginCL", "pluginurl", "plugFile", "pluginUrl", "PluginUrl", "pluginsURL", "configUrl", "pluginUR", "pluginsCL", " pluginurl", "PluginCL", "PluginFile", "plugCL", " pluginUR"], "is": ["x", "ais", "Is", "iss", "cos", "ri", "s", "bs", "ins", "bos", "ori", "info", "has", "ics", "isa", "IS", "was", "ops", "ar", "its", "i", "ci", "api", "or", "ois", "bis", "ui", "vs", "ists", "uri", "ir", "io", "ps", "osi", "as", "in", "iso", "ris", "id", "iris", "ours", "opens", "ai", "out", "us", "ios", "ss", "ms", "lis", "ip", "fs"], "os": ["oS", "ais", "cos", "ot", "s", "oss", "bs", "oos", "bos", "ori", "ol", "oid", "ies", "obs", "oses", "o", "i", "OS", "mos", "Os", "bis", "oes", "ois", "io", "osi", "as", "otes", "iso", "aos", "ours", "ears", "ros", "es", "ss", "us", "ios", "los", "so", "nos", "dos"]}}
{"id1": "13886238", "id2": "20619879", "code1": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "code2": "    public void copyLogic() {\n        if (getState() == States.Idle) {\n            setState(States.Synchronizing);\n            try {\n                FileChannel sourceChannel = new FileInputStream(new File(_properties.getProperty(\"binPath\") + name + \".class\")).getChannel();\n                FileChannel destinationChannel = new FileOutputStream(new File(_properties.getProperty(\"agentFileLocation\") + name + \".class\")).getChannel();\n                sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n                sourceChannel.close();\n                destinationChannel.close();\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            setState(States.Idle);\n        }\n    }\n", "label": 1, "substitutes": {"init": ["art", "build", "Init", "info", "reset", "it", " discover", "check", "launch", "error", "test", "rest", " Init", "strap", "parse", "config", "activate", " reload", "load", "start", "destruct", "initialized", "setup", "update", "construct", "open"], "backupFile": ["backoutFile", "BackdownFile", "backupFiles", "lookoutFILE", "backupfile", "backupFILE", "BackdownStream", "lookoutFile", "BackureFiles", "BackureSourceFile", "BackupF", "backbookF", "backUPFiles", "backupStream", "backbookFiles", "backupsDir", "backdownF", "backdownFile", "backureFile", "backupsFiles", "backacyFolder", "backacyfile", "backbackFILE", "backdownFiles", "BackureFile", "backUPFile", "backbackFolder", "BackdownFiles", "backoutfile", "lookoutFolder", "backbackFile", "BackupSourceFile", "backrapSourceFile", "lookupfile", "backupDir", "backureFiles", "backrapFiles", "BackupStream", "backUPF", "BackupDir", "backacyFILE", "backdownStream", "backureDir", "backrapFile", "backUPStream", "backupSourceFile", "backupF", "backacyFile", "BackureDir", "backupsSourceFile", "backbookFile", "BackupFiles", "backupsFile", "backureSourceFile", "backupFolder", "lookupFolder", "backoutFILE", "backbackfile", "lookupFILE", "lookoutfile", "backbookStream", "BackupFile", "backoutFolder", "BackdownF", "lookupFile", "backrapDir"], "buff": ["buf", "font", "uf", "pad", "bind", "txt", "length", "build", "b", "cp", "cod", "cmd", "fb", "back", "ph", "sb", "shape", "cond", "now", "zip", "pb", "ch", "rb", "utf", "comb", "cb", "Buff", "mb", "gg", "bf", "uff", "bound", "boot", "flush", "ffff", "grab", "comment", "bg", "ff", "oct", "slice", "load", "gz", "gb", "app", "fab", "cast", "ob", "buffer", "comp", "fe", "pp", "feed", "bb", "char"], "in": ["ins", "ssl", "url", "e", "image", "In", "b", "n", "connection", "data", "inc", "socket", "part", "old", "gin", "f", "input", "din", "IN", "inn", "lin", "s", "pass", "el", "cin", "i", "win", "reader", "inside", "nin", "l", "stream", "login", "inner", "min", "slice", "r", "id", "ac", "exec", "bin", "con", "c", "up", "diff", "pin", "get", "ini", "or", "again", "serv", "isin"], "out": ["prefix", "ex", "gen", "writer", "ins", "one", "copy", "b", "conf", "n", "ax", "io", "sync", "inc", "socket", "part", "output", "exp", "o", "IN", "Out", "conn", "pass", "win", "reader", "client", "co", "inner", "outs", "user", "exec", "bin", "file", "err", "up", "net", "lib", "OUT", "again", "line", "serv", "doc", "ext"], "read": ["k", "bind", "count", "view", "data", "reading", "search", "fill", "row", "pass", "roll", "ad", "send", "r", "exec", "start", "find", "readable", "ink", "text", " Read", "en", "input", "index", "Read", "i", "add", "parse", "max", "iter", "skip", "x", "close", "feed", "log", "play", "length", "build", "ok", "sync", "last", "check", "reads", "d", "seek", "run", "end", "size", "ind", "id", "wait", "next", "buffer", "use", "block", "open", "write", "ask", "copy", "se", "b", "n", "lock", "lex", "child", "raw", "reach", "ride", "connect", "READ", "reader", "work", "ip", "load", "select", "get", "current", "level", "sleep"], "reportWriter": [" reportJournal", "summaryPublisher", "exportJournal", "reviewEditor", "reportedEditor", "reportWalker", "resultPage", "reportApplication", " reportWalker", "reportedHelper", " reportHelper", " reportPublisher", "exportApplication", "reportEditor", "reportedDriver", " reportReader", "exportReader", "resultWrite", "summaryWrite", "ReportWrite", "reportedTime", "exportWalker", "reportedWs", "exportWrite", "commentWrite", "reviewEngine", "ReportReader", "reportPage", "ReportApplication", "exportHelper", "reviewWrite", " reportEditor", " reportWs", "reportWriting", "reportJournal", "reportedEngine", "reportHelper", " reportWrite", "exportWriter", "reviewTime", "commentWriter", "summaryPage", "commentStream", "reportedWalker", "resultStream", "reportTime", "reportedWriter", " reportApplication", "reportEngine", "reportWrite", "reviewWriter", "reportStream", "reportedReader", "resultWriter", "summaryWriter", "ReportWriter", "reportedWriting", "reportPublisher", "exportPublisher", " reportTime", "summaryStream", " reportWriting", "commentPage", "reviewDriver", " reportEngine", " reportDriver", "ReportWs", "reportDriver", "reportWs", "reportedWrite", "summaryJournal", "ReportWriting", "reportReader"], "restarting": ["restrupted", "RestartING", "restrupting", "restrited", "restarmING", "restartING", "restruptable", "restartsting", "Restritting", "Restritating", "restartating", "restritING", "restarsING", "restartting", "restartable", "restritable", "Restrited", "restarsating", "restarted", "RestritING", "Restritable", "Restartting", "restritating", "restruptING", "restarsting", "Restriting", "Restarting", "Restarted", "restarming", "restartsating", "restarsing", "restarmable", "restartsing", "restriting", "restarmed", "restritting", "restartsING", "Restartating", "Restartable"]}}
{"id1": "17583193", "id2": "14450108", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"populateRecord": ["extulateAll", "poputeAll", "extulateRecord", "poputeRecord", "popractRecord", "extractInstance", "extractModel", "extulateModel", "extulateInstance", "popractAll", "populatesRecord", "populatesAll", "poputeInstance", "poputeModel", "populateInstance", "popractInstance", "populatesInstance", "populatesModel", "extractAll", "populateModel", "populateAll", "popractModel", "extractRecord"], "attrIDs": ["sortID", "attIDS", "attrIDES", "attributeids", "attributeIDs", "addrID", "attrID", "tagIDS", "attributeENTS", "sortIDS", "tagIDs", "attributeIDES", "attrids", "attributeID", "addrIDs", "attID", "sortids", "attrIDS", "addrIDS", "tagIDES", "attids", "attIDES", "attrENTS", "tagID", "attributeIDS", "addrENTS", "sortIDES", "attIDs", "attENTS"], "i": ["x", "init", "ai", "I", "k", "ci", "left", "ami", "ip", "u", "li", "y", "key", "slice", "start", "ti", "d", "uri", "info", "ini", "multi", "io", "bi", "iu", "n", "g", "pi", "api", "ki", "eni", "cli", "id", "ii", "e", "ind", "a", "si", "b", "is", "ji", "h", "mi", "di", "qi", "xi", "o", "ri", "my", "phi", "p", "ij", "length", "z", "inner", "c", "ni", "f", "gi", "ix", "ori", "ie", "l", "yi", "m", "in", "it", "ui", "ik", "oi", "index", "fi", "v"], "sortIDs": ["SortUID", "sortID", "allIDS", "filterID", "allIDES", "useIDS", "syncID", "syncIDS", "altIDES", "ortIDS", "searchID", "searchids", "orderADS", "attrID", " sortIDS", "allID", "allIDs", "useID", "SortIDES", "sortIDS", " sortids", "altIDs", "orderID", "sortFiles", "SortIDS", "SortIDs", "filterUID", "filterIDs", "altIDS", "syncIDES", "sortADS", "orderIDES", "sortids", "ortIDs", "orderIDs", " sortFiles", "attrIDS", "altID", "searchIDES", "useIDs", "attrADS", "sortUID", "updateFiles", "syncIDs", "searchIDS", " sortUID", "ortUID", "orderIDS", " sortADS", "orderids", "orderFiles", " sortID", "updateIDs", "searchIDs", "ortID", "updateIDES", "sortIDES", "useIDES", "attrFiles", "filterIDS", "ortids", "updateIDS", "SortID", "updateID", "attrUID", "ortIDES", " sortIDES"], "j": ["p", "x", "last", "ij", "z", "br", "jl", "f", "ii", "bj", "ix", "w", "e", "dj", "ie", "l", "k", "aj", "left", "q", "n", "next", "job", "v", "jj", "ja", "b", "u", "obj", "ui", "oj", "ji", "jet", "li", "je", "h", "jc", "fr", "di", "qi", "jp", "pr", "y", "xi", "part", "key", "adj", "uj", "o", "J", "section", "js", "d", "jo"], "temp": [" dummy", "flat", " Temp", "empty", "ash", " original", "emp", "tc", "alt", "porary", "ex", "needed", "max", "ed", " fake", "tem", "Temp", "stable", "tmp", "fake", " temporary", "modified", " unused", " test", " modified", "holder", " tmp", "wrap", "orig", "used", "iter", "test", "tr", "partial", "key", "pack", " orig", "non", "get", " result"]}}
{"id1": "9954926", "id2": "7872659", "code1": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "code2": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"simulate": ["simure", "Simulate", "animure", "simulator", "imulation", "imulate", "Simulator", "simulation", "animulator", "animulate", "imulator", "Simure", "Simulation", "animulation", "imure"], "out": ["external", "error", "outs", "cache", "gen", "window", "tmp", "raw", "log", "session", "name", "conn", "plain", "writer", "report", "null", "post", "flush", "data", "server", "full", "group", "part", "client", "db", "string", "state", "word", "lock", "write", "prefix", "down", "Out", "user", "object", "o", "buffer", "key", "store", "in", "page", "cli", "pool", "dump", "comment", "exit", "net", "result", "base", "OUT", "w", "now", "io", "obj", "err", "lib", "info", "again", "parent", "list", "outer", "resource", "copy", "con", "temp", "sys", "flow", "output", "bin", "view", "exp", "pre", "ex", "co", "table", "point", "line", "up"], "file": ["fp", "url", "address", "FILE", "base", "cache", "output", "port", "feed", "path", "log", "filename", "name", "stream", "queue", "ile", "files", "fe", "File", "connection", "report", "pe", "b", "rule", "handler", "socket", "loader", "buffer", "message", "resource", "l", "line", "data", "in", "source", "page", "full", "collection", "unit", "book", "f", "le"], "obtainUserReputationRequest": ["obtainUserRepentionResponse", "obtainUserRepulationEntry", "obtainUserRepentionrequest", "obtainUserReputeResponse", "obtainUserComputeEntry", "obtainUserReputerequest", "obtainUserReputionGrant", "obtainUserRepigrationResponse", "obtainUserReputedResponse", "obtainUserRelutationGrant", "obtainUserRepigrationQuery", "obtainUserReputationEntry", "obtainUserAnnutationResponse", "obtainUserAnnutationQuery", "obtainUserReputationInfo", "obtainUserComputerequest", "obtainUserRepigrationrequest", "obtainUserReputionResponse", "obtainUserReputeRequest", "obtainUserRepentionGrant", "obtainUserRepigrationRequest", "obtainUserReputationrequest", "obtainUserAnnigrationQuery", "obtainUserRepositoryInfo", "obtainUserRelutationRequest", "obtainUserAnnigrationGrant", "obtainUserRelentionrequest", "obtainUserAnnutationRequest", "obtainUserRelutationResponse", "obtainUserReputeInfo", "obtainUserRepurationResponse", "obtainUserRelentionGrant", "obtainUserRepositoryRequest", "obtainUserAnnigrationRequest", "obtainUserRelentionResponse", "obtainUserComputationEntry", "obtainUserRelentionRequest", "obtainUserRepentionRequest", "obtainUserComputationInput", "obtainUserComputationRequest", "obtainUserComputeRequest", "obtainUserRepositoryrequest", "obtainUserRepurityInput", "obtainUserRepulationResponse", "obtainUserReputableResponse", "obtainUserReputeQuery", "obtainUserRepurationGrant", "obtainUserRepurationQuery", "obtainUserComputationInfo", "obtainUserComputationrequest", "obtainUserComputationResponse", "obtainUserReputablerequest", "obtainUserReputeEntry", "obtainUserAnnutationGrant", "obtainUserReputeGrant", "obtainUserRepurationRequest", "obtainUserComputeInfo", "obtainUserReputedrequest", "obtainUserReputedGrant", "obtainUserReputableRequest", "obtainUserReputionRequest", "obtainUserRepurityEntry", "obtainUserRepositoryResponse", "obtainUserRepurityRequest", "obtainUserRepigrationGrant", "obtainUserReputationInput", "obtainUserRelutationrequest", "obtainUserReputeInput", "obtainUserRepigrationInfo", "obtainUserReputationGrant", "obtainUserRepulationRequest", "obtainUserComputeInput", "obtainUserReputedRequest", "obtainUserRepurityResponse", "obtainUserRepulationInput", "obtainUserReputationQuery", "obtainUserReputionrequest", "obtainUserComputeResponse", "obtainUserAnnigrationResponse"], "obtainUserReputationResponse": ["obtainUserExputationRequest", "obtainUserRepurationResponse", "obtainUserRepurationRequest", "obtainUserReputationResp", "obtainUserRepositoryRequest", "obtainUserExpositoryRequest", "obtainUserReputeRequest", "obtainUserReputeResponse", "obtainUserRepositoryResponse", "obtainUserExputationResponse", "obtainUserExpositoryResponse", "obtainUserRepositoryResp", "obtainUserReputeResp", "obtainUserExputationResp", "obtainUserExpositoryResp", "obtainUserRepurationResp"], "rateUserRequest": ["issueCustomerForce", "rateUResponse", "rateMachineRequest", "ratedUserRequest", "ratedUserFunction", "issueCustomerQUEST", "RateFileResponse", "rateFileResult", "rateUCustomer", "gradeLineRequest", "ratedFileRequest", "rateUsageForce", "rateUsRequest", "gradeLineCustomer", "rateUsageResponse", "ratePostrequest", "ratedFileFunction", "rateFileQuery", "RateUserQUEST", "gradeUserRequest", "rateuserRequest", "rateCustomerRequest", "rateClientRequest", "rateUsageReturn", "rateLineQUEST", "rateUserQUEST", "rateLineQuery", "rateUsageQUEST", "rateHumanVersion", " rateuserQUEST", "rateUSERForce", "ratePostQUEST", "rateFileCommand", "rateUsForce", "ratePostRequest", "rateUsageGrant", "RateFileQUEST", "ratedUsageRequest", " rateuserRequest", "featureUserRequest", "rateUCommand", "rateUSERQUEST", " rateClientrequest", "rateUserVersion", " rateUserrequest", "rateLinerequest", "issueUserForce", "rateWordRequest", "rateServiceRequest", "rateUQuery", "rateFileFunction", " rateuserResponse", "rateUserReturn", "rateUError", "issueCustomerReturn", "rateUserCustomer", "rateApplicationUser", "rateClientGrant", "rateFilerequest", "rateUSERRequest", "rateLineResponse", "rateWordrequest", "rateUsageQuery", " rateApplicationRequest", "rateUsQUEST", "RateFilerequest", "ratedUsageForce", "ratedUsagerequest", "ratedUserForce", "featureMachineResult", "rateLineError", "rateMachineResult", " rateuserrequest", "rateApplicationQuery", "rateMachinerequest", " rateUserGrant", "rateUsageUser", "ratedFileQuery", "rateURequest", "rateuserQUEST", "rateUserGrant", "rateFileResponse", "ratedUsageQUEST", "ratePostResponse", "featureMachineRequest", "rateUFunction", "rateMachineVersion", "rateHumanrequest", "rateServiceQuery", " rateUserQuery", "RateUserrequest", "rateUserrequest", "rateFileVersion", "issueUserQUEST", "rateUserError", "rateUserUser", "rateUserQuery", "rateApplicationRequest", "featureUserResult", "rateUserCommand", "rateUsagerequest", "rateWordCustomer", "rateUsageRequest", "rateuserResponse", "ratedFileCommand", " rateApplicationResponse", "gradeLinerequest", "ratedUserQuery", "rateUserResult", "featureUserVersion", " rateClientGrant", " rateUserQUEST", "rateWordQuery", "RateUserRequest", "rateHumanResult", "rateCustomerQUEST", "rateHumanRequest", " rateClientRequest", "rateCustomerForce", "rateUsReturn", "rateWordError", "featureMachineVersion", "rateFileUser", "gradeUserCustomer", "rateUrequest", "ratedUserCommand", "featureMachinerequest", "rateServiceFunction", "issueUserRequest", "RateUserResponse", "ratedUserrequest", "ratedUsageQuery", "rateClientrequest", "rateUQUEST", "rateFileRequest", "rateUserFunction", "rateUSERrequest", "rateUserForce", "issueUserReturn", "featureUserrequest", "ratedUserQUEST", " rateApplicationQuery", "rateCustomerReturn", "rateServiceCommand", " rateUserUser", "rateLineRequest", "gradeUserError", "issueCustomerRequest", "gradeLineError", "RateFileRequest", "gradeUserrequest", " rateApplicationUser", "rateLineGrant", "rateUForce", "rateuserrequest", "rateLineCustomer", "rateApplicationResponse", "rateFileQUEST"], "rateUserResponse": ["rateUsersStatus", "rateUResponse", "rateTimeStatus", "rateUserReply", "rateFileResult", "RateTimeResp", "rateCustomStatus", " rateFileResult", " rateApplicationResp", " rateUReply", "RateUserStatus", "rateUResp", "rateTimeResponse", "rateCustomerRequest", " rateUResponse", " rateUserReply", "rateUresponse", "rateClientResp", "rateCustomResponse", "rateClientStatus", "rateUserResp", " rateFileResponse", "rateApplicationResp", "rateFileResp", " rateUserResp", "rateUsersResp", "rateUsersRequest", " rateApplicationData", "rateuserResult", "rateFileReply", "rateUserData", "RateUserResp", "rateUserCustomer", "rateUserReference", " rateUserresponse", "rateuserReference", "rateTimeCustomer", "rateUserStatus", "rateClientCustomer", "rateUserResource", "rateApplicationData", "rateuserReply", "rateUReply", "rateFileResponse", " rateUserResult", "rateCustomResp", " rateUResp", "rateuserStatus", "rateCustomerResponse", "rateCustomerData", "rateUserresponse", "rateuserResponse", " rateApplicationResponse", "rateUserResult", "rateFileStatus", "RateUserRequest", " rateUserData", " rateUserReference", "RateTimeResponse", "rateFileresponse", "rateuserResp", "rateuserresponse", "rateUsersResource", "RateTimeStatus", "rateApplicationReference", "rateuserData", "rateTimeResp", "rateCustomerResource", "RateUserResponse", "RateUserCustomer", " rateFileResp", "rateUsersResult", " rateUserStatus", " rateFileStatus", "rateUsersResponse", "RateTimeCustomer", " rateApplicationReference", "RateUserResource", "rateClientResponse", "rateCustomerReference", "rateCustomCustomer", "rateCustomerResp", "rateApplicationResponse", " rateUresponse"], "fis": [" fiss", "fris", " fIs", "bis", "sfris", "sfIs", "bIs", "FIs", "Fris", "bris", "biss", "fIs", "Fis", "Fiss", "sfiss", "fiss", " fris", "sfis"], "br": ["bc", "result", "reader", "str", "ob", "bp", "ber", "io", "arr", "brush", "ler", " tr", "res", "hr", "bridge", "fin", "cr", "err", "bro", "bl", "wr", "Br", "Reader", "bed", "r", "b", "browser", "buf", "body", "tr", "fr", "buffer", "lr", "rb", " fr", "dr", "BR", "ch", "gr", "ref", " bio", "sp", "sw", "bs", "pr"], "call": ["flow", "address", "url", "result", "cl", "voice", "cod", "str", "output", "e", "comment", "phone", "ell", "use", "load", "invoke", "throw", "check", "request", "xml", "input", "string", "name", "play", "Line", "contact", "c", "doc", "callback", "code", "type", "charge", "info", "Call", "cu", "user", "text", "body", "query", "co", "loc", "buffer", "message", "calling", "ck", "line", "data", "work", "sc", "push", "claim", "fax", "create", "roll", "cat", "called", "ack", "f", "response", "cell", "msg"]}}
{"id1": "22993368", "id2": "22135199", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2String", "decodeStringToFile", "decodeFile2Stream", "decodeFile2Files", "decodeFileFromFiles", "decodeStringToStream", "decodeFileAsFiles", "decodeFileAsString", "decodeStringToFiles", "decodeFileFromFile", "decodeFileToStream", "decodeString2File", "decodeFileToString", "decodeFileFromString", "decodeFileFromStream", "decodeFile2String", "decodeFileAsFile", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeFile2File", "decodeString2Files", "decodeFileAsStream"], "infile": ["Inbase", "Infile", "infiles", "InFile", " inFile", " instream", "inFile", "Instream", "minstream", "inputfiles", "infilename", "inbase", "outfilename", "minfile", " infilename", "outfiles", "minbase", "inputfp", "infp", " infiles", "inputfilename", " infp", "outfp", "instream", " inbase", "inputfile", "minFile"], "outfile": ["outputfilename", "outputpath", "outpath", "inputdatabase", "infolder", "inputFile", " outpath", "outdatabase", "inFile", "outFile", "outputdatabase", "outfolder", " outfolder", "infilename", "outfilename", " outFile", "outputfile", "inputpath", " outfilename", "outputfolder", " outdatabase", "outputFile", "inputfile"], "in": ["gin", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "ini", "input", "ic", "In", "s", "conn", "inner", "err", "inas", "m", "a", "i", "r", "b", "again", "sin", "socket", "nin", "win", "inn", "min", "pin", "is", "into", "cin", "data", "source", "lin", "init", "inside", "rin", "pass", "ac", "con", "as"], "out": ["net", "exec", "base", "error", "OUT", "client", "outs", "cache", "job", "output", "bin", "ou", "io", "inc", "one", "log", "session", "conn", "obj", "In", "inner", "name", "to", "image", "write", "err", "off", "no", "Out", "lib", "or", "writer", "ex", "parent", "again", "o", "co", "socket", "sync", "post", "outer", "timeout", "point", "copy", "line", "channel", "file", "up", "work", "pass", "home", "exit"], "buffer": ["Buffer", "address", "url", "result", "base", "uffer", "reader", "cache", "bb", "bin", "transfer", "feed", "raw", "input", "border", "length", "seed", "binary", "offset", "queue", "write", "layer", "type", "reference", "batch", "count", "b", "null", "buf", "slice", "padding", "iter", "bytes", "wave", "flush", "data", "channel", "server", "source", "limit", "value", "split", "size", "buff"], "read": ["exec", " skip", " Read", "ip", "reader", "send", " copy", "parse", "lex", "allow", "use", "id", "feed", "io", "load", "inc", "raw", "current", "_", "check", "x", " count", "connect", "seek", "length", "ind", "play", "start", "end", "write", "next", "len", "i", "count", "ride", "wait", "r", "n", "fill", "find", "Read", "slice", "sync", "READ", "tell", " write", "ad", "iter", "add", "get", "copy", "work", "sleep", "se", "limit", "reads", "pass", "reading", "size", "select", "f", "run"], "success": ["complete", "first", "result", "positive", "error", "cess", " succ", "primary", "status", "follow", "ccess", "growth", "flash", "fast", "right", "Success", "valid", "model", "func", "path", "default", " succeed", " Success", "true", "winner", "rolled", "results", "xx", "failed", "danger", "construct", " successful", "method", "null", "again", "ceed", "good", "message", "done", "rolling", "successfully", "content", "continue", "data", "warning", "successful", "pass", "roll", "initial", "better", "fail", "value", "open", "comment", "response"]}}
{"id1": "10451698", "id2": "3806532", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["drop", "share", "change", "delete", "paste", "rm", "transfer", "zip", "Copy", "load", "replace", "remote", "py", "cp", "archive", "lock", "write", " cp", "type", "cop", "ignore", "parent", "sync", "list", "update", "clip", "get", "process", "move", "file", "download", "create", "dump", "split", "cat", "ssh", "part", "clone", "run"], "source": ["ource", "slave", "url", "result", "reader", "client", "cache", "project", "scope", "view", "site", "use", "current", "proxy", "model", "path", "folder", "remote", "target", "filename", "start", "name", "seed", "string", "secure", "stream", "flat", "archive", "section", "image", "Source", "storage", "ie", "info", "connection", "class", "root", "null", "directory", "object", "parent", "config", "slice", "iter", "service", "resource", "plus", "from", "document", "data", "file", "server", "src", "unit", "sf", "ce", "SOURCE"], "destinationDirectory": ["destributionDirectory", "destructionFolder", "DestributionHome", "destributionPath", "DestinationFolder", "DestinationDir", "destributionHome", "destructionDir", " destinationFolder", " destinationFile", " destinationsFolder", "destarationPoint", " destinationDir", "DestinationHome", "DestributionFolder", "destificationDirectory", "destinationFile", "DestinationDirectory", "destippingDirectory", "destinatorPoint", "destinationsDirectory", "destinationPath", "destinationDir", "DestributionDirectory", " destinationsFile", "destinationHome", "destippingFolder", "destinatorPath", "destificationFolder", "destippingHome", "destinationsDir", "destinationsFolder", "DestributionPath", "destippingDir", "DestributionDir", " destinationsDir", "destinatorDirectory", "destarationDirectory", "destinationsFile", "destructionDirectory", "destributionFolder", "DestributionPoint", "destructionFile", "destinationFolder", "destarationPath", " destinationsDirectory", "destinationPoint", "destributionPoint", "destificationHome", "destributionDir", "destributionFile", "destificationDir", "DestinationPoint", "DestinationPath"], "newDir": ["NewFolder", " newDirectory", " newFolder", "NewDir", "NewDirectory", "newDirectory", " newdir", "nextdir", "NewFile", "Newdir", "nextFolder", "nextDirectory", "newFolder", "nextDir", "newdir", "nextFile"], "children": ["rules", "iv", "url", "ins", "uc", "packages", "iblings", "roots", "which", "when", "ren", "child", "current", "sub", "members", "sort", "father", "kids", "filename", "parents", "values", "projects", "files", "words", "items", "ools", "rows", "parent", "loc", "each", "list", "begin", "ul", "events", "blocks", "mount", "opens", "content", "other", "pages", " Children", "data", "ums", "Children", "scenes", "balls", "collection", "names", "web", "pes", "tests"], "i": ["qi", "v", "lc", "k", "iv", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "q", "start", "end", "li", "ui", "u", "hi", "inner", "multi", "ci", "si", "mi", "ii", "m", "y", "j", "type", "ie", "info", "ori", "b", "n", "o", "slice", "ri", "uri", "p", "gi", "key", "h", "ix", "fi", "it", "di", "in", "oi", "d", "ji", "part", "mu", "f", "pi"], "newFile": ["createDir", "Newfile", "NewFiles", "oldFiles", " newDirectory", "nextfile", "createfile", "nextFiles", "NewDir", "NewDirectory", "newDirectory", "createSource", " newSourceFile", "NewFile", " newfile", "NewSource", "oldDir", " newFiles", "oldFile", "nextSource", "newfile", "newSource", "NewSourceFile", "nextSourceFile", "nextDir", "oldDirectory", "nextFile", "createFile", "newFiles", "newSourceFile"], "output": ["complete", "external", "flow", "address", "result", "oper", "error", "console", "change", "after", "current", "ou", "put", "Output", "target", "out", "core", "binary", "generation", "four", "ilo", "generated", "image", "write", "operation", "writer", "connection", "application", "object", "parent", "kernel", "o", "again", "config", "socket", "outer", "update", "display", "service", "resource", "option", "other", "page", "file", "unit", "web", "control", "response", "temp"], "input": ["exec", "flow", "error", "client", "reader", "audio", "feed", "current", "inc", "child", "raw", "Input", "operator", "request", "index", "keep", "out", "context", "stream", "inner", "image", "this", "self", "storage", "connection", "print", "text", "parent", "config", "pull", "socket", "buffer", "resource", "inf", "plus", "form", "http", "in", "data", "work", "before", "instance", "ink", "ack", "temp"], "buff": ["bind", "uf", "cf", "cod", "bb", "gb", "ob", "bin", "comb", "feed", "load", "cur", "boot", "fb", "length", "cp", "bug", "cmd", "bound", "fe", "info", "ph", "batch", "count", "b", "shape", "buf", "text", "cast", "Buff", "ff", "back", "oct", "slice", "pad", "hello", "buffer", "pack", "uff", "rb", "flush", "data", "char", "gz", "txt", "comment", "cb", "f"], "read": ["exec", "k", "ip", "send", "reader", "allow", "parse", "lex", "use", "id", "feed", "io", "load", "transfer", "check", "skip", "x", "readable", "ask", "index", "reading", "start", "length", "ind", "end", "seek", "play", "write", "next", "len", " load", "rate", "en", "type", "wait", "count", "b", "fill", "text", "n", "find", "Read", "config", "sync", "slice", "READ", "ok", "buffer", " write", "iter", "close", "add", "get", "se", "loop", "and", "reads", "pass", "ink", "open", " count", "size", "select", "f", "run"]}}
{"id1": "5977352", "id2": "12766394", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyDir", "copyfile", " copyDir", "CopyFile", "copyFiles", " copyFiles", "transferfile", "transferFile", "transferDir", "Copyfile", "CopyFiles", " copyfile", "CopyDir"], "src": ["source", "filename", "sb", "uri", "fp", "path", "config", "s", "this", "buf", "view", "input", "ource", "conn", "inst", "loc", "data", "loader", "resource", "proxy", "img", "url", "tmp", "b", "proc", "obj", "files", "sel", "sc", "sl", "dist", "rc", "rb", "ins", "gb", "stream", "file", "slice"], "dest": ["source", "cache", "output", "table", "st", "path", " destination", "config", "home", "store", "this", "master", " Dest", "txt", "d", "de", "trans", "project", "rest", "cdn", "folder", "done", "dep", "later", "img", "class", "url", "tmp", "name", "cont", "null", "die", "obj", "destroy", "zip", "dist", "cp", "thin", "orig", "desc", "file", "temp", "route", "wb", "Dest", "part", "dir", "parent", "opt", "target", "delete", "dc"], "bufSize": ["buf2", "ufSize", "bufferSize", "buffersize", " bufsize", "bufLen", "uf2", "queueSize", "ufLen", " buf2", " bufLen", "queuesize", "queueLen", "buffer2", "ufsize", "bufsize", "bufferLen"], "force": ["ride", "p", "source", "Force", "remote", "ist", "sync", "push", "dirty", "load", "forces", "front", "f", "store", "use", "place", "hard", "urse", "count", "base", "deep", "rc", "require", "write", "only", "auto", "replace", "like", "file", "parent", "forcing", "pull", "route", "id", "forced", "apply", "flush", "delete", "no"], "buffer": ["source", "result", "cache", "length", "memory", "load", "buff", "fb", "buf", "seed", "bytes", "uffer", "border", "padding", "data", "binary", "zero", "limit", "url", "base", "b", "null", "transfer", "split", "address", "append", "Buffer", "queue", "write", "raw", "batch", "reference", "iter", "value", "request", "feed", "slice", "reader", "flush", "bin", "offset"], "read": ["work", "text", "ride", "seek", "create", "select", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "lex", "len", "use", "view", "pass", "show", "level", "READ", "i", "input", "send", "skip", "ed", "count", "k", "sleep", "ind", "data", "build", "close", "ad", "open", "play", "find", "ip", "io", "n", "connect", "next", "b", "add", " write", "allow", "exec", "reads", "index", "size", "write", "raw", "block", "iter", "wait", "feed", "id", "reader", "end", "get", "start", "d", "fill", "run"], "in": ["source", "as", "init", "inn", "gin", "pin", "inner", "c", "ac", "f", "pass", "ex", "i", "input", "socket", "conn", "image", "sin", "inside", "serv", "IN", "m", "con", "win", "ini", "up", "n", "isin", "a", "url", "base", "din", "b", "nin", "min", "ins", "connection", "cin", "thin", "In", "inc", "again", "rin", "kin", "lib", "part", "pull", "r", "err", "login", "id", "reader", "bin"], "out": ["source", "call", "init", "app", "cache", "output", "sync", "client", "net", "inner", "ac", "at", "home", "this", "with", "w", "ex", "i", "one", "max", "socket", "conn", "OUT", "line", "image", "by", "writer", "n", "io", "up", "bin", "url", "name", "b", "ou", "outer", "ext", "exec", "obj", "nin", "connection", "exp", "plain", "Out", "write", "outs", "again", "off", "lib", "part", "err", "key", "o", "id", "user", "inc", "co", "can", "no"]}}
{"id1": "3756429", "id2": "4798332", "code1": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 1, "substitutes": {"scramble": [" scrambling", "scambling", " screambling", "screambles", "screamble", "scrambles", "scamble", "scrouble", " scrambler", "scroubling", "scroubler", "scambles", " screamble", "screambler", "scambler", " scrambles", " screambles", "screambling", " screambler", "scroubles", "scrambler", "scrambling"], "text": ["image", "in", "buffer", "bytes", "obj", "output", "class", "object", "pattern", "username", "input", "Text", "code", "content", "path", "message", "TEXT", "editor", "word", "ext", "out", "str", "binary", "letter", "data", "struct", "secret", "test", "token", "name", "password", "body", "string", "texture", "source", "config", "txt"], "md": ["mm", "mac", "db", "ind", "m", "grad", "mad", "ad", "bb", "mn", "pd", "metadata", "um", "cd", "od", "ma", "bm", "rm", "mb", "cm", "amd", "df", "wd", "dh", "mand", "bd", "gd", "f", "sm", "dm", "pm", "mt", "MD", "mp", "di", "mc", "mod", "hd", "vd", "d", "mag", "rpm", "am", "ms", " Md", "cmd", "dd", " MD", "hm"], "sb": ["db", "su", "bp", "buffer", "sync", "bf", "src", "ab", "lb", "bs", "s", "bt", "SB", "ib", "bb", "ls", "usb", "sa", "sf", "sg", "bc", "rb", "fb", "bm", "kb", "mb", "ob", "gb", "ssl", "pb", "bh", "bd", "sr", "eb", "buf", "binary", "wb", " SB", "BB", "bsp", "xb", "obb", " eb", "nb", "cb", "erb"], "b": ["db", "buffer", "bytes", "p", "obj", "bf", "bis", "br", "block", "i", "ab", "object", "bs", "bb", "boot", "rb", "a", "fb", "beta", "be", "mb", "ob", "pb", "B", "bd", "eb", "f", "binary", "base", "bot", "l", "bin", "d", "body", "nb", "orb", "machine", "cb", "c"]}}
{"id1": "6987642", "id2": "14785308", "code1": "    public static String encodePassword(String password) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n            md.update(password.getBytes());\n            String encodedPassword = new String(md.digest(), new Base64Provider().charsetForName(\"x-base64\"));\n            return encodedPassword;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"encodePassword": [" enodePassword", "enodePassword", " encodeString", "encodePass", " enodeAuth", " enodeString", "enodedPassword", "enressAuth", "encodeAuth", "enodePass", "enodeString", "enodedPass", "enodeAuth", " encodePass", " encodeAuth", " enodePass", "enressString", "enressPass", "enressPassword", "encodeString", "enodedAuth", "enodedString"], "password": ["crypt", "prefix", "text", "p", "padding", "auth", "message", "sha", " passwords", "data", "username", "sword", "phrase", "hash", "input", "wd", "out", "pass", "code", "number", "SHA", "user", "Pass", "address", "token", "string", "name", "confirmed", "pattern", "words", "path", "word", "content", "value", "Password", "secret", " Password", "database", "PASS"], "md": ["mad", "m", "rm", "hd", " MD", "Cmd", " Md", "nd", "mp", "sha", "cmd", "dr", "data", "mo", "dig", "dd", "gd", "hash", "mc", "mag", "d", "vd", "od", "me", "ms", "mb", "hm", "ng", "amd", "mg", "dm", "bd", "metadata", "pd", "MD", "di", "mn", "ad", "mac", "ind", "mand", "mm", "sm", "ma", "am", "pm", "grad", "mt", "mod", "dh"], "encodedPassword": ["encachedText", "encodedText", "enodedText", "encodingString", "enccodedUser", "encachedSecret", "Enccodedpassword", "encodedString", "Encodedpassword", "enccodedString", "EnccodedUser", "enodedPassword", "enodedSecret", "enccodedpassword", "enryptedPassword", "EncodedPassword", "encryptedString", "enryptedText", "encodepassword", "enryptedString", "encryptedText", "EnccodedString", "encodingPassword", "encodedUser", "encryptedUser", "encodingText", "encryptedPassword", "encachedPassword", "EncodedUser", "EnccodedPassword", "encodingSecret", "encodeString", "encryptedSecret", "encryptedpassword", "encodedpassword", "enodedString", "enccodedPassword", "enryptedSecret", "encodedSecret", "EncodedString", "encodeUser", "encachedString"]}}
{"id1": "17901739", "id2": "20724937", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static TopicMap getTopicMap(URL url) {\n        String baseURI = url.toString();\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return getTopicMap(inputStream, baseURI);\n    }\n", "label": 0, "substitutes": {"setMembers": ["SetMethods", "SetMember", "parseMethods", "SetMembers", "parseMembers", "SetJoin", "parseJoin", "setMethods", " setJoin", "setJoin", "setMember", " setMethods", " setMember", "parseMember"], "url": ["image", "URL", "base", "resource", "service", "www", "feed", "email", "Url", "entry", "channel", "hub", "http", "queue", "l", "string", "path", "io", "org", "uri", "client", "blog", "article", "loader", "socket", "ssl", "location", "server", "data", "file", "user", "sl", "connection", "source", "address"], "reader": ["err", "resource", "feed", "stream", "rer", "inner", "input", "entry", "worker", "http", "parser", "ler", "reading", "rar", "bird", "l", "writer", "table", "read", "driver", "builder", "r", "rc", "handler", "er", "io", "rr", "row", "ner", "loader", "report", "server", "file", "e", "iterator", "Reader", "per", "i", "keeper", "iter", "f", "editor"], "buffer": ["resource", "window", "filename", "queue", "bb", "page", "null", "result", "layer", "length", "expression", "received", "file", "binary", "seed", "str", "comment", "rb", "source", "button", "wave", "fr", "flush", "input", "cache", "sync", "output", "password", "bin", "b", "info", "texture", "string", "read", "background", "code", "stage", "phrase", "response", "loader", "pause", "server", "document", "template", "Buffer", "header", "base", "game", "paste", "parse", "text", "bytes", "fb", "uffer", "line", "row", "FFER", "bar", "request", "data", "batch", "address", "image", "video", "feed", "sequence", "player", "http", "message", "writer", "buf", "flash", "buff", "border", "padding", "counter", "uri", "transfer", "iter"], "pattern": ["re", "rule", "letter", "model", "image", "graph", "log", "system", "script", "feed", "child", "config", "event", " Pattern", "format", "function", "patch", "match", "Pattern", "serial", "filter", "group", "cache", "parser", "atter", "slice", "password", "regular", "object", "print", "builder", "string", "array", "position", "condition", "path", "handler", "part", "type", "counter", "df", "number", "layer", "command", "expression", "cher", "app", "file", "document", "str", "template"], "matcher": ["matchches", "motner", "matchched", "matger", "Matter", "mitch", "Matcher", "captter", "matter", "matchpattern", "mircher", " match", "mancher", "matched", "Matner", "attcher", "attger", " matler", "attching", "Matger", "manner", "patchers", "harcher", " mather", "captcher", "mather", "mitchers", "patch", "patner", "motpattern", " matchers", "captatter", "mirher", "patcher", "ratching", "compcher", "patatcher", " matacher", "patter", "matchcher", "linatter", "compches", " matpattern", "Matacher", "manher", "ratacher", "mither", "matner", "patpattern", "reched", "matpattern", "mirpattern", "reach", "matchler", "lincher", "linpattern", "matchers", "matchher", "mitcher", "match", "compach", "statpattern", "harner", "harler", " matner", "compner", "Mather", "matach", "statler", "matchatcher", "captpattern", " matter", "linter", "matler", "manacher", "matchacher", " matatter", "reches", "motcher", "statner", "mirter", "pather", "compched", "matchter", "matacher", "compter", "ratger", "statcher", "Matpattern", "matatter", "harpattern", "motter", "matches", "recher", "matatcher", "compatcher", "matchner", "Matching", "matching", "attacher", "matchach", "ratcher"], "erg": ["urg", "dr", "ga", "igor", "aga", "aug", "jing", "rog", "eng", "game", "ag", "orters", "usa", "clus", "era", "gas", "worker", "feat", "berg", "anger", "gra", "ocr", "gy", "eric", "uster", "ger", "eur", "ERG", "arc", "ander", "gg", "agg", "rg", "git", "ord", "ard", "oga", "der", "irc", "gr", "forge", "ig", "er", "yang", "porter", "progress", "eri", "alg", "ager", "org", "sg", "east", "ung", "gd", "region", "agog", "justice", "ero", "orter", "magic", "gru", "ider", "gae", "og", "ers", "rator"], "start": ["unit", "need", "current", "step", "cost", "begin", "speed", "show", "scale", "state", "grad", "boot", "it", "ish", "fit", "name", "seed", "old", "like", "source", "in", "send", "stop", "check", "grade", "count", "run", "add", "bin", "info", "style", "read", "fill", "sort", "ad", "first", "size", "init", "id", "last", "get", "base", "inner", "none", "End", "match", "something", "pad", "starting", "set", "position", "st", "ind", "ie", "shift", "type", "se", "diff", "rest", "off", "sum", "pend", "max", "address", "sol", "index", "end", "offset", "art", "head", "pick", "open", "find", "load", "space", "pos", "middle", "work", "plus", "part", "stat", "Start", "started", "min", "close", "mid"], "von": ["vid", "ou", "endon", "ver", "mun", "andon", "ten", "kn", "uber", "fat", "don", "fun", "hn", "fin", "fen", "feat", "bon", "lon", "zon", "bin", "tun", "oni", "mon", "aven", "olson", "evin", "wen", "vor", "tin", "flo", "hon", "una", "jen", "su", "eni", "nn", "len", "melon", "bn", "endor", "han", "ln", "onna", "jan", "john", "tu", "dn", "won", "fn", "byn", "vin", "non", "di", "vu", "lu", "anon", "lin"], "bis": ["vals", "offs", "lus", "uno", "bits", "ls", "lins", "uss", "ui", "bb", "ri", "bes", "boot", "os", "nas", "isin", "nexus", "los", "lin", "bat", "pins", "ours", "isi", "bos", "bin", "oni", "pi", "obs", "outs", "onis", "ni", "su", "cedes", "is", "bian", "us", "oris", "BUS", "bus", "zi", "udi", "base", "des", "prefix", "bles", "idis", "bett", "abi", "fb", "eni", "cin", "oss", "sis", "bps", "vin", "di", "vid", "fat", "vs", "val", "bid", "bas", "pos", "buff", "li", "ris", "bi", "len", "phis", "cos", "cus", "ori", "ois", "bs", "ios"], "m_strComponents": ["m_strCommales", "m_intReports", "m_intRepales", "m_strExpenses", "m_strComponentonents", "m_intReponents", "m_strReponents", "m_strExponents", "m_arrCompales", "m_arrComponent", "m_strComponent", "m_strComponentonent", "m_strCommorts", "m_arrCompenses", "m_arrCommenses", "m_intRepenses", "m_strExpales", "m_intCompenses", "m_strCompales", "m_arrComponents", "m_strCommonents", "m_strCommonent", "m_strComponentenses", "m_strCommenses", "m_strComports", "m_strCompenses", "m_strRepenses", "m_strReports", "m_arrCommales", "m_arrCommonent", "m_intComponents", "m_strExports", "m_arrCommonents", "m_strExponent", "m_strComponentales", "m_intCompales", "m_intComports", "m_strRepales"], "m_strPriorities": ["m_strQualifiers", "m_StrPositions", "m_intPriorities", "m_strPosifiers", "m_strPrioritives", "m_strPrefitives", "m_strActivities", "m_strQualities", "m_strPositions", "m_strComparities", "m_intPrioritives", "m_strPrefities", "m_StrPriorifiers", "m_strActivitives", "m_strMonities", "m_strPosity", "m_strMonries", "m_strPrefitions", "m_strPosities", "m_StrPriority", "m_intPriorries", "m_strMonitions", "m_StrPriorities", "m_strPriority", "m_strPriorifiers", "m_intPrefities", "m_strQuality", "m_intPrefitions", "m_strQualitions", "m_strComparity", "m_strPriorries", "m_intPrefitives", "m_strComparitions", "m_StrPrioritions", "m_strActivitions", "m_intPrefries", "m_StrPosifiers", "m_intPrioritions", "m_StrPosities", "m_strActivries", "m_strPrefries", "m_strMonitives", "m_StrPosity", "m_strComparifiers", "m_strPrioritions"]}}
{"id1": "3558512", "id2": "397240", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"serialize": ["serialization", "finalized", " serialization", "finalify", "Serialization", "serialify", "serialze", "normalze", " serializable", "erialze", "Serializable", "Serialize", " serialze", "normalized", "normalify", "Serialized", "erialization", "serializable", "serialized", "Serialify", "erializable", "finalze", "normalize", "finalize", "Serialze", "erialize"], "out": ["source", "png", "filename", "buffer", "copy", "cache", "output", "client", "archive", "page", "w", "ex", "i", "dump", "OUT", "image", "conn", "data", "writer", "loader", "io", "up", "a", "name", "server", "gen", "obj", "pool", "exec", "string", "Out", "raw", "outs", "file", "temp", "err", "o", "parent", "bin", "report", "content"], "parser": ["p", "lp", "arser", "as", "copy", "cache", "ss", "parse", "instance", "system", "seed", "master", "rar", "per", "processor", "txt", "manager", "loader", "writer", "Parser", "builder", "tt", "up", "class", "base", "pe", "server", "upload", "worker", "cp", "handler", "plugin", "wrapper", "php", "test", "file", "er", "pp", "reader", "pkg", "parent", "xml", "pillar"], "on_disk": ["onnetdrive", "onJdemand", "onJdisk", "on_storage", "onbookdisk", "off_drive", "onjdisk", "on_lock", "on_demand", "onJdrive", "onbootstorage", "onbootdrive", "onbookdrive", "on_space", "off_space", "onbootlock", "onjdrive", "onnetdisk", "on_file", "onnetfile", "on_drive", "off_delete", "onJlock", "onnetspace", "off_disk", "onjspace", "off_storage", "off_file", "off_lock", "onjfile", "onbootdisk", "onnetdemand", "onbookdelete", "on_delete", "off_demand"], "in": ["source", "as", "copy", "inn", "pin", "inner", "c", "ac", "f", "ax", "info", "pass", "i", "input", "socket", "conn", "inas", "IN", "data", "ini", "win", "con", "din", "min", "ins", "connection", "thin", "stream", "lin", "In", "inc", "again", "rin", "file", "kin", "r", "login", "o", "reader", "bin"]}}
{"id1": "17901739", "id2": "13368520", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public void sendTextFile(String filename) throws IOException {\n        Checker.checkEmpty(filename, \"filename\");\n        URL url = _getFile(filename);\n        PrintWriter out = getWriter();\n        Streams.copy(new InputStreamReader(url.openStream()), out);\n        out.close();\n    }\n", "label": 0, "substitutes": {"setMembers": ["setJoin", "SetJoin", "SetMembers", "setMember", "SetMethods", " setJoin", "parseMembers", " setMethods", "parseMember", "parseJoin", "setMethods", "parseMethods", "SetMember", " setMember"], "url": ["image", "blog", "client", "service", "email", "sl", "entry", "queue", "socket", "feed", "user", "server", "address", "connection", "http", "location", "URL", "resource", "path", "io", "hub", "ssl", "file", "Url", "channel", "base", "data", "loader", "org", "article", "l", "string", "uri", "source", "www"], "reader": ["r", "iterator", "writer", "ner", "worker", "Reader", "entry", "stream", "rer", "i", "rc", "feed", "input", "e", "handler", "server", "per", "ler", "http", "inner", "editor", "report", "resource", "io", "keeper", "rr", "row", "reading", "file", "rar", "iter", "f", "builder", "err", "loader", "er", "driver", "l", "table", "parser", "read", "bird"], "buffer": ["video", "image", "stage", "sync", "flash", "FFER", "comment", "Buffer", "address", "info", "fb", "http", "str", "iter", "buf", "base", "text", "string", "uri", "window", "flush", "length", "request", "bytes", "batch", "feed", "input", "parse", "page", "cache", "rb", "response", "message", "buff", "file", "uffer", "b", "bar", "border", "pause", "button", "writer", "fr", "received", "output", "bb", "expression", "phrase", "result", "padding", "line", "row", "null", "player", "paste", "wave", "background", "password", "counter", "seed", "layer", "source", "filename", "template", "queue", "read", "transfer", "sequence", "server", "game", "code", "resource", "binary", "data", "loader", "document", "bin", "header", "texture"], "pattern": ["image", "position", " Pattern", "match", "template", "cher", "script", "object", "print", "feed", "app", "slice", "serial", "expression", "patch", "handler", "Pattern", "rule", "cache", "child", "group", "format", "array", "graph", "path", "regular", "df", "function", "file", "part", "str", "letter", "model", "system", "builder", "type", "log", "number", "atter", "document", "password", "counter", "string", "parser", "command", "filter", "event", "re", "layer", "config", "condition"], "matcher": ["reches", "ratger", "patatcher", "manacher", "statcher", "compner", "patner", "mitchers", "ratacher", "Matpattern", "matchpattern", "Matger", "statpattern", "captatter", "attacher", "compatcher", " matter", "captpattern", "patcher", "matacher", "mirher", "matches", " matpattern", "mither", "Matner", "harpattern", "matchher", "matchers", "motpattern", "reched", "harcher", "reach", "compach", "patch", "mather", "Matching", "matatcher", "matchched", "mancher", "compched", " matacher", "harner", " mather", "captter", "motner", "matchches", " matatter", "matger", " matler", "attcher", "matchler", "matchter", "manher", "matching", "patpattern", "compter", "matatter", "patter", "matpattern", "matler", "mirter", "Matacher", "linter", "matach", "matchach", "pather", "ratcher", " matchers", "Matter", "compcher", " match", "ratching", "captcher", "linatter", "statler", "linpattern", "statner", "motter", "lincher", "attching", "match", "matchcher", "mircher", "attger", "patchers", "manner", "mirpattern", "harler", "Matcher", "mitcher", "compches", "matchatcher", "matchacher", "matched", "recher", "motcher", "matter", "matner", " matner", "mitch", "matchner", "Mather"], "erg": ["der", "gr", "ander", "gae", "irc", "orter", "eur", "gru", "eri", "progress", "ag", "worker", "justice", "rator", "rog", "git", "ga", "ord", "eng", "igor", "gra", "east", "ger", "gg", "urg", "ero", "sg", "eric", "yang", "game", "dr", "aug", "alg", "berg", "region", "gy", "magic", "oga", "gd", "feat", "orters", "era", "ager", "porter", "uster", "jing", "org", "arc", "ERG", "er", "agog", "ig", "forge", "rg", "ider", "og", "usa", "clus", "ers", "ocr", "aga", "ard", "anger", "gas", "ung", "agg"], "start": ["pad", "size", "sort", "grad", "old", "mid", "address", "open", "info", "last", "something", "end", "space", "st", "base", "name", "ind", "get", "End", "fit", "off", "load", "begin", "check", "boot", "diff", "state", "inner", "index", "find", "part", "started", "close", "unit", "set", "scale", "pend", "offset", "stop", "like", "middle", "in", "stat", "art", "init", "ad", "starting", "id", "run", "plus", "sum", "grade", "pick", "Start", "show", "work", "count", "step", "min", "it", "seed", "speed", "head", "first", "add", "shift", "source", "position", "match", "cost", "max", "ie", "pos", "read", "sol", "se", "send", "fill", "need", "ish", "none", "rest", "type", "bin", "style", "current"], "von": ["fin", "su", "flo", "jan", "tu", "eni", "melon", "vid", "bn", "endon", "nn", "vu", "ou", "tin", "fen", "oni", "ln", "won", "zon", "han", "jen", "aven", "dn", "lin", "ver", "fat", "bon", "anon", "vin", "andon", "lon", "olson", "fn", "uber", "fun", "feat", "len", "kn", "hon", "wen", "don", "byn", "tun", "mun", "di", "hn", "vor", "onna", "bin", "ten", "mon", "lu", "evin", "endor", "una", "john", "non"], "bis": ["os", "bs", "vid", "ois", "phis", "lins", "bid", "zi", "fb", "bas", "len", "bits", "prefix", "base", "bat", "vs", "bos", "outs", "isin", "eni", "is", "bus", "uno", "nas", "isi", "ris", "val", "boot", "ios", "li", "vin", "buff", "offs", "bi", "uss", "su", "BUS", "us", "cus", "oss", "ls", "bb", "nexus", "abi", "lin", "obs", "cos", "bps", "sis", "bian", "ri", "bles", "cedes", "vals", "pos", "oris", "cin", "oni", "ui", "los", "fat", "ori", "bes", "ours", "pi", "onis", "des", "ni", "pins", "di", "bin", "lus", "bett", "udi", "idis"], "m_strComponents": ["m_strExpales", "m_strComponent", "m_strExpenses", "m_intRepales", "m_intComports", "m_arrCommales", "m_intReports", "m_strRepales", "m_intRepenses", "m_strCompenses", "m_strReports", "m_strExponents", "m_strRepenses", "m_arrCommonent", "m_arrCompenses", "m_arrComponents", "m_strReponents", "m_strCommonent", "m_strExports", "m_arrCommenses", "m_strCommales", "m_intReponents", "m_intCompales", "m_strCommenses", "m_strComponentonents", "m_arrComponent", "m_intCompenses", "m_strCommorts", "m_intComponents", "m_arrCommonents", "m_strExponent", "m_strCommonents", "m_strCompales", "m_strComponentales", "m_strComponentonent", "m_arrCompales", "m_strComponentenses", "m_strComports"], "m_strPriorities": ["m_intPrefries", "m_strActivities", "m_strActivries", "m_StrPriority", "m_strComparifiers", "m_strPrioritives", "m_strMonities", "m_intPrioritions", "m_strMonitives", "m_StrPosity", "m_strComparities", "m_intPriorries", "m_intPriorities", "m_StrPriorities", "m_strPrefitions", "m_StrPrioritions", "m_intPrioritives", "m_strPositions", "m_strComparitions", "m_StrPositions", "m_strPriorries", "m_strActivitions", "m_intPrefitives", "m_strPrefries", "m_strPrefitives", "m_StrPosifiers", "m_strQualitions", "m_strActivitives", "m_strMonitions", "m_strComparity", "m_strPosity", "m_strMonries", "m_intPrefities", "m_strPosities", "m_strPriority", "m_strPriorifiers", "m_intPrefitions", "m_StrPosities", "m_strQuality", "m_strQualifiers", "m_strPosifiers", "m_strQualities", "m_StrPriorifiers", "m_strPrioritions", "m_strPrefities"]}}
{"id1": "12586404", "id2": "19147281", "code1": "    @Override\n    public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException {\n        File file = new File(src);\n        BufferedReader in;\n        InputStream is = null;\n        try {\n            if (!file.exists() || !file.canRead()) {\n                try {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src);\n                    in = new BufferedReader(new InputStreamReader(is));\n                } catch (Exception ex1) {\n                    try {\n                        is = RuleReaderImpl.class.getResourceAsStream(src);\n                        in = new BufferedReader(new InputStreamReader(is));\n                    } catch (Exception ex2) {\n                        try {\n                            URL url = new URL(src);\n                            in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        } catch (Exception ex3) {\n                            throw new IOException(\"Cannot read from \" + src);\n                        }\n                    }\n                }\n            } else {\n                FileReader fr = new FileReader(file);\n                in = new BufferedReader(fr);\n            }\n            List<ProvaSolution[]> results = prova.consult(agent, in, key);\n            return results;\n        } finally {\n            if (is != null) is.close();\n        }\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"run": ["process", "connect", "master", "use", "apply", "submit", "report", "Run", "work", "build", "start", "close", "unit", "exec", "execute", "trial", "test", "runner", "running", "call", "un", "runs", "setup", "add", "create", "config"], "prova": ["peva", "proba", "Proda", "pega", "Prova", " proba", "Proba", "perva", "Proga", "PROVA", "peVA", "proda", "ProVA", "perba", "proga", "perfa", " profa", "pefa", "perda", " proda", "profa", "PROfa", "PROva", "Profa", "proVA", "PROga"], "agent": ["domain", "r", "ace", "client", "writer", "service", "attr", "fax", "entry", "man", "input", "monitor", "server", "address", "reg", "conn", "Agent", "state", "graph", "report", "resource", "manager", "ant", "director", "agency", "acc", "gent", "ator", "agents", "model", "session", "contract", "actor", "act", "config", "account"], "key": ["KEY", "ip", "client", "service", "cert", "entry", "host", "user", "id", "ak", "server", "rule", "address", "json", "keys", "state", "or", "path", "param", "resource", "air", "work", "row", "step", "str", "link", "base", "k", "type", "secret", "contract", "role", "name", "ring", "string", "Key", "sign", "source", "config"], "src": ["sc", "ruby", "sl", "sync", "sec", "stream", "rl", "host", "rc", "s", "proxy", "input", "sit", "route", "sin", "RC", "sb", "server", "address", "loc", "code", "rb", "rss", "path", "resource", "inst", "resources", "ssl", "img", "rin", "dest", "Source", "secure", "config", "dist", "sr", "sel", "prot", "st", "null", "rest", "loader", "rou", "SourceFile", "text", "method", "sch", "string", "href", "seed", "uri", "ser", "ource", "source", "filename", "ources", "username"], "file": ["image", "service", "full", "stream", "files", "class", "socket", "object", "el", "feed", "proxy", "use", "input", "il", "id", "File", "rule", "cache", "per", "fe", "loc", "info", "connection", "http", "resource", "path", "fp", "io", "work", "FILE", "ile", "link", "f", "binary", "this", "base", "zip", "model", "pe", "loader", "b", "log", "local", "it", "l", "reader", "folder", "uri", "lock", "play", "source", "filename"], "in": ["r", "ai", "image", "get", "p", "pin", "ic", "ie", "inn", "isin", "gin", "i", "rc", "s", "init", "cin", "el", "input", "on", "id", "include", "ci", "din", "conn", "info", "or", "lin", "dr", "inner", "index", "io", "nin", "out", "ini", "rin", "rec", "kin", "part", "str", "x", "min", "f", "req", "exec", "login", "ri", "err", "with", "it", "ins", "l", "In", "ar", "bin", "reader", "IN", "and", "again", "read", "config", "ac", "inc"], "is": ["lis", "image", "os", "iso", "isl", "isa", "i", "s", "impl", "sit", "ci", "info", "iss", "http", "isc", "nis", "x", "sel", "iter", "api", "er", "ins", "uri", "sp", "get", "r", "ip", "ire", "isin", "eni", "sin", "es", "isi", "ris", "IS", "inner", "ios", "be", "ais", "err", "does", "internet", "as", "si", "ai", "Is", "us", "ic", "was", "id", "ini", "min", "ri", "it", "ar", "ise", "cms", "bis", "ie", "its", "il", "ui", "or", "ori", "has", "ir", "iris", "abs", "are", "im"], "url": ["r", "image", "sl", "stream", "rl", "feed", "impl", "layer", "id", "server", "address", "bel", "loc", "info", "connection", "http", "URL", "resource", "ref", "path", "ob", "pull", "ssl", "str", "link", "f", "Url", "base", "b", "ll", "l", "string", "web", "ur", "uri", "source", "www"], "fr": ["lr", "fin", "compl", "br", "rl", "form", "el", "fi", "fl", "il", "Fr", "fm", "fe", "sf", "ris", "dr", "adr", "fb", "raf", "fp", "ir", "rr", "rin", "fc", "sr", "rf", "f", "err", "range", "rel", "rt", "kr", "arr", "fer", "yr", "frac", "ur", "tr", "pr"], "results": ["items", "vals", "details", "models", "files", "grades", "ips", "maps", "features", "properties", "objects", "result", "response", "reports", "terms", "params", "resources", "roots", "changes", "relations", "values", "forms", "groups", "errors", "RESULTS", "lists", "rows", "ids", "versions", "res", "runs", "rules", "Results", "devices", "tests", "plugins"]}}
{"id1": "4531653", "id2": "7166270", "code1": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 0, "substitutes": {"md5": ["mp5", "mp512", "mp7", " md6", "MD5", " md7", "md512", "MD6", "MD512", " md512", "md7", "md6", "MD7", "mp6"], "data": ["text", "source", "message", "method", "buffer", "media", "cache", "output", "str", "script", "DATA", "pad", "this", "bytes", "input", "image", "in", "format", "ata", "a", "name", "base", "database", "code", "sha", "hex", "dat", "body", "address", "api", "string", "alpha", "key", "template", "content"], "md": ["mand", "mm", "mp", "mod", "amd", "wd", "dig", "cmd", "dm", "ds", "mb", "meta", "material", "mg", "m", "nm", "metadata", "ad", "mac", "editor", "docker", "grad", "sm", "code", "pd", "gd", " MD", "od", "di", "dd", "mo", "mt", "hd", "cd", "MD", "mc", "ma", "rod", "mag", "pm", "db", "d", "bd"]}}
{"id1": "5998352", "id2": "4164833", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"testStandardTee": ["testStandardBee", "testStandardTees", "teststandardMees", "testStandardMee", "testStandardBees", "teststandardTee", "teststandardTeed", "testStandardFee", "testStandardTeed", "teststandardMae", "testStandardMae", "testStandardMeed", "testStandardFees", "teststandardTae", "teststandardMee", "testStandardFae", "testStandardTae", "testStandardFeed", "testStandardBeed", "teststandardTees", "testStandardBae", "teststandardMeed", "testStandardMees"], "reference": ["distance", "forward", "prefix", "Reference", "description", "attribute", "proxy", "url", "uri", "resource", "message", "report", "References", "copy", "server", "length", "connection", "remote", "relative", "version", "single", "hello", "external", "sequence", "output", "primary", "document", "archive", "index", "ref", "test", "type", "code", "see", "memory", "directory", "filename", "pair", "target", "number", "variable", "ference", "address", "string", " Reference", "REF", "c", "name", "re", "relation", "binary", "order", "location", "path", "pointer", "specified", "buffer", "format", "collection", "request", "rice", "database", "compatible"], "source": ["proxy", "text", "writer", "url", "resource", "e", "server", "se", "copy", "parent", "g", "view", "connection", "ce", "io", "ie", "output", "Source", "result", "input", "ref", "code", "temp", "i", "iter", "driver", "reader", "src", "config", "target", "table", "r", "object", "slice", "string", "ource", "service", "SOURCE", "context", "buffer", "fe"], "destination1": ["destinator01", "destribution1", "destinate01", "constinator2", "destarationOne", "destinatorOne", "Destension0", "Destension1", "destination01", "DestinateOnce", "destentionOnce", "constinationOne", "destribution0", "destinations2", "DestinationOnce", "constination01", "destaration0", "DestensionOne", "destentionOne", "destension0", "destination0", "destinate2", "DestinateOne", "destention1", "destinatorOnce", "destinateOne", "Destination1", "destaration1", "DestinationOne", "destinate1", "constination1", "constinatorOne", "destensionOne", "destinator2", "destinateOnce", "Destination0", "destinationOnce", "destinations01", "destinator1", "constinator1", "constinator01", "destributionOne", "Destinate1", "constination2", "destinationsOne", "destension1", "destinations1", "destinationOne"], "destination2": ["coordinate2", "coordinate22", "destignmentSecond", "destribution2", "destationtwo", "destinations02", "descination02", "destication22", "coordination8", "destication8", "destination02", "descination2", "destination22", "Destinationtwo", "desticationSecond", "Destination2", "descinationsSecond", "destinationSecond", "destinateSecond", "coordination2", "destation1", "coordinate8", "descinationSecond", "destination4", "destinating2", "destinate02", "destignment02", "coordination22", "destication2", "destinate8", "descination1", "destinatingtwo", "destinationsSecond", "destinationtwo", "destinations2", "Destination4", "destation4", "destinatetwo", "coordinationSecond", "coordinateSecond", "destinate22", "destinate2", "destination8", "Destination1", "descinations2", "destation2", "destribution8", "descinations02", "destributionSecond", "destinate1", "destribution22", "destignment2", "destinate4", "Destinate1", "destignment1", "descinations1", "Destinate4", "Destinate2", "Destinatetwo", "destinations1", "destinating4", "destinating1"], "tee": ["leee", "teee", "TEee", "eeee", " teec", "ettef", "lepe", " tef", "cee", " teee", "TEe", "TEc", "ceee", "eeffe", "tef", "chef", "cec", " teae", "teffe", "lee", "ceea", "sef", "tepe", "chee", "leec", "seae", "tec", "teec", "see", "eee", "chei", " tei", "etteee", "seee", "tei", " tec", "teae", " tepe", "TEea", "lei", " teffe", "ettee", "leffe", "etteae", "lef", " teea", "eeec", "chepe", "teea"]}}
{"id1": "13852596", "id2": "22410173", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"execute": ["register", "create", " invoke", "submit", "Exec", "ute", "parse", "load", "run", "process", "code", "apply", "all", "evaluate", "handle", " perform", "start", "report", "test", "server", "transfer", "call", "exec", "install", "copy", "invoke"], "resources": ["rings", "archives", "resource", "objects", "types", "locks", "chains", "stores", "rates", "workers", "flows", "plugins", "services", "maps", "ids", "rules", "thumbnails", "events", "roots", "files", "apps", "projects", "params", "groups", "images", "Resources", "works", "writers", "relations", "ions", "cells", "issues", "items", "series", "reports", "users", "models", "features", "pages", "stars", "classes", "results", "strings", "scripts"], "i": ["ini", "j", "o", "hi", "isi", "phi", "iri", "cli", "ii", "ir", "mu", "l", "info", "ui", "we", "ami", "ri", "pi", "gi", "ic", "abi", "li", "k", "ci", "ie", "p", "ani", "multi", "xi", "si", "io", "bi", "I", "uri", "v", "ai", "eni", "wei", "ip", "is", "ori", "esi", "h", "ti", "qi", "id", "e", "iu", "vi", "f", "u", "di", "oi", "s"], "classFile": ["CLASSFile", "sessionfile", " classClass", " classfile", "ClassEntry", "classGlobal", "packFile", "ClassGlobal", "classUrl", "staticLine", "serviceLine", " classStream", "lassFile", "classDirectory", "CLASSPage", "customEntry", "objectFile", " classFilename", "sessionFactory", "ClassFilename", "CLASSFiles", "serviceFILE", "staticFILE", " classDir", "finalfile", "finalFILE", " classFILE", " classLine", "fileLine", "CLASSLoader", "fileFiles", "ruleFilename", "classPage", "ClassDir", "sessionFile", "ClassFile", "sessionEntry", "CLASSEntry", "classFILE", "ruleLine", "objectFiles", " classFactory", "staticfile", "CLASSUrl", "CLASSfile", "classLine", "classImage", "packEntry", "ruleFiles", "classStream", "ClassPage", "fileFile", "classesPath", "classPath", "objectfile", "basefile", "servicefile", "classEntry", "sessionFiles", "ClassLine", " classPage", " classPath", "lassClass", "classesfile", "filefile", " classLoader", "packfile", "ClassFactory", "classfile", "packFILE", "ClassClass", "baseFILE", "serviceFile", "customFiles", "ClassDirectory", "classesFile", "CLASSFILE", "baseFile", "CLASSDirectory", " classEntry", "Classfile", "objectDir", "finalFile", "fileImage", " classGlobal", "classFactory", "classClass", "CLASSLine", "classFiles", "classLoader", "classesFiles", "lassFiles", "ClassFiles", "ruleFile", "ClassStream", "connectionfile", "staticFile", "ClassFILE", "customFile", "connectionFile", "ClassPath", "finalUrl", "sessionFILE", " classFiles", "classFilename", "CLASSImage", "customFILE", "connectionFiles", "lassGlobal", "fileDirectory", "classDir", "ClassImage", "connectionStream", "fileLoader", "baseUrl"], "inputStream": ["outputstream", "childStream", "inputContext", "binaryStreamer", "importStreamer", "outputSw", "outputContext", "importStream", "inputstream", "binarySteam", "binaryFile", "InputSteam", "InputFile", "importSteam", "InputSw", "InputStreamer", "uploadStream", "outputSteam", "childReader", "inputSw", "initstream", "outputReader", "initStream", "initSteam", " inputSteam", "rawSteam", "uploadstream", "activeSteam", "inputFile", "rawStreamer", "inputSteam", " inputFile", " inputReader", "activestream", "rawStream", "importstream", "activeStream", "inputStreamer", " inputContext", " inputStreamer", "inputReader", "InputStream", "uploadSw", "childstream", "outputStreamer", "initStreamer", "uploadFile", " inputstream", "childContext", "rawFile", "Inputstream", "outputFile", "activeStreamer", "binaryStream"], "reader": ["re", "right", "dr", "resource", "draft", "system", "rx", "stream", "rer", "inner", "arser", "owner", "input", "entry", "worker", "http", "parser", "ler", "reading", "rar", "key", "sync", "ger", "copy", "read", "driver", "builder", "ri", "buffer", "rc", "oder", "reflect", "handler", "er", "writers", "author", "io", "rr", "row", "director", "layer", "client", "ner", "context", "manager", "riter", "loader", "report", "Writer", "request", "wrapper", "server", "war", "seed", "Reader", "per", "shared", "keeper", "iter", "or", "source", "book", "ee", "editor"], "oldSize": ["OldName", "OldLength", "prevSize", "prevName", "prevLength", " oldSc", "oldLength", "oldName", "OldSize", " oldName", "oldSc", " oldLength", "prevSc", "OldSc"], "writer": ["writing", "her", "written", "index", "draft", "resource", "service", "child", "walker", "inner", "dc", "w", "format", "write", "player", "worker", "parser", "ler", "widget", "wer", "object", "builder", "driver", "engine", "read", "string", "r", "element", "creator", "buffer", "wr", "token", "oder", "handler", "er", "writers", "author", "winner", "io", "wire", "row", "director", "ner", "manager", "riter", "Writer", "loader", "report", "word", "wrapper", "data", "war", "document", "e", "Reader", "rw", "writ", "iter", "maker", "ee", "editor"], "b": ["base", "br", "eb", "ba", "w", "l", "bin", "bb", "object", "null", "c", "r", "buffer", "g", "d", "fb", "k", "be", "bd", "p", "boot", "db", "lb", "B", "orb", "pb", "bar", "a", "h", "binary", "ob", "e", "emb", "u", "abc", "rb", "m", "f", "ab"], "outputStream": ["outputstream", "OutputSteam", " outputSteam", "dataSteam", "inputView", "outputView", "OutputStream", "inputstream", "protectedstream", "protectedStreamer", "outputContainer", "outstream", "dataStreamer", " outputContainer", "outputSteam", " outputStreamer", "outStreamer", "inputSteam", "outSteam", "outStream", "Outputstream", "inputStreamer", "OutputView", "inputContainer", " outputstream", "outputStreamer", " outputView", "dataStream", "dataContainer", "OutputStreamer", "protectedStream", "protectedSteam"], "injectedClasses": ["injectedClasss", "injectedclassies", "injectedClassies", "injectedWrities", "injectionClassies", "injectedclasses", "injectedclasss", "injectionclasses", "injectedClassites", "injectedProjects", "injectionclassites", "injectionclassies", "injectionClassites", "injectionclasss", "injectedWritites", "injectedWrites", "injectedProjectites", "injectionClasss", "injectedProjecties", "injectedclassites", "injectedWrits", "injectionClasses", "injectedProjectes"], "newSize": [" newLength", "newFontSize", "NewLength", " newStorage", "newLength", "finalSize", "newStorage", "NewStorage", "NewFontSize", "finalStorage", "finalLength", "finalFontSize", " newFontSize", "NewSize"]}}
{"id1": "7006052", "id2": "7149578", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyFilesFile", " copyFilesTo", "copySourceFileFile", "copyfileFrom", "copyFileFrom", " copyFileFrom", "copySourceFileFrom", " copyFilesFile", "copyfileInfo", "copySourceFileTo", "copyfileFile", " copyFilesFrom", "copyFileInfo", "copyFileFile", " copyFilesInfo", " copyFileInfo", "copyFilesTo", "copyFilesInfo", "copyfileTo", "copyFilesFrom", "copySourceFileInfo", " copyFileFile"], "src": ["source", "remote", "filename", "sb", "uri", "sync", "path", "config", "s", "archive", "txt", "image", "sin", "loc", "data", "resource", "rs", "old", "img", "sup", "url", "inf", "b", "code", "sel", "sub", "sc", "sl", "rc", "rb", "string", "fn", "upload", "stream", "file", "href", "slice", "js"], "dest": ["source", "filename", "result", "flat", "output", " destination", "home", " Dest", "txt", "project", "default", "loc", "data", "des", "const", "folder", "done", "later", "img", "sup", "tmp", "name", "b", "die", "sub", "secure", "dist", "comb", "orig", "test", "desc", "temp", "route", "wb", "Dest", "dir", "bin", "opt", "target", "delete"], "destFile": ["destfile", "targetfile", " destDir", "destDir", "DestF", "DestDir", "destF", "DestFiles", " destinationF", "targetDir", "targetFiles", " destFiles", "targetFile", " destinationFile", " destfile", "DestFile", " destinationFiles", " destinationDir", "destFiles", "Destfile", " destF"], "in": ["source", "init", "ln", "gin", "inn", "pin", "inner", "f", "s", "pass", "i", "input", "l", "socket", "inside", "image", "trans", "IN", "data", "con", "win", "ini", "up", "n", "url", "din", "is", "nin", "ins", "cin", "thin", "stream", "lin", "In", "impl", "inc", "again", "rin", "kin", "r", "err", "login", "id", "reader", "diff", "bin"], "out": ["work", "copy", "cache", "output", "sync", "client", "net", "inner", "ac", "this", "extra", "w", "ex", "one", "conn", "OUT", "image", "data", "writer", "other", "up", "io", "n", "bin", "log", "cos", "null", "outer", "ext", "exec", "post", "obj", "pool", "exp", "plain", "Out", "again", "off", "file", "parent", "part", "err", "o", "user", "inc"], "buf": ["cv", "bh", "buffer", "result", "cache", "uf", "seq", "uc", "length", "path", "br", "bag", "c", "pad", "buff", "fb", "bytes", "bl", "ff", "loc", "data", "map", "box", "bf", "cas", "bc", "tmp", "b", "pool", "Buffer", "rb", "rc", "blocks", "queue", "raw", "batch", "orig", "block", "off", "vec", "cap", "ctx", "v", "bin", "cb", "bd"], "len": ["pre", "lf", "ln", "length", "c", "f", "all", "bytes", "nt", "ie", "lim", "l", "pos", "count", "line", "val", "ind", "data", "n", "url", "base", "num", "lc", "fd", "fl", "split", "body", "li", "min", "size", "coll", "el", "en", "Len", "iter", "off", "cap", "part", "id", "rev", "end", "fin", "no"]}}
{"id1": "19322941", "id2": "2910383", "code1": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"test_lookupResourceType_FullSearch_TwoWordsInMiddle": ["test_lookupResourceType_FullSearchWithtwoW", "test_lookupResourceType_FullSearchWithtwoWord", "test_lookupResourceType_FullSearch_ThreeWord", "test_lookupResourceType_FullSearch_Threewords", "test_lookupResourceType_FullSearch_ThreeW", "test_lookupResourceType_FullSearch_twoW", "test_lookupResourceType_FullSearchWithtwoWords", "test_lookupResourceType_FullSearchWithtwowords", "test_lookupResourceType_FullSearch_Fourwords", "test_lookupResourceType_FullSearch_twoWords", "test_lookupResourceType_FullSearch_FourW", "test_lookupResourceType_FullSearch_FourWords", "test_lookupResourceType_FullSearch_TwoWords", "test_lookupResourceType_FullSearch_twowords", "test_lookupResourceType_FullSearch_Twowords", "test_lookupResourceType_FullSearch_twoWord", "test_lookupResourceType_FullSearchWithTwoWords", "test_lookupResourceType_FullSearch_TwoWord", "test_lookupResourceType_FullSearchWithTwoWord", "test_lookupResourceType_FullSearch_ThreeWords", "test_lookupResourceType_FullSearch_FourWord", "test_lookupResourceType_FullSearchWithTwowords", "test_lookupResourceType_FullSearchWithTwoW", "test_lookupResourceType_FullSearch_TwoW"], "url": ["link", "image", "method", "log", "URL", "base", "resource", "feed", "system", "Url", "entry", "channel", "http", "l", "b", "conn", "object", "page", "string", "c", "position", "path", "https", "org", "uri", "client", "bug", "ssl", "server", "user", "file", "document", "sl", "contact", "config", "location", "web", "f", "address"], "connection": ["body", "image", "method", "j", "link", "service", "resource", "section", "ion", "event", "function", "which", "entry", "channel", "version", "Connection", "http", "cache", "use", "l", "b", "conn", "password", "object", "application", "c", "position", "condition", "session", "relation", "handler", "translation", "result", "io", "uri", "number", "response", "client", "character", "context", "bug", "expression", "communication", "proxy", "operation", "con", "wrapper", "server", "loc", "document", "established", "connect", "database", "contact", "bc", "connected", "config", "location", "db"]}}
{"id1": "8000624", "id2": "11032546", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"CopyTo": [" copyFrom", " transferFile", " copyTo", "copyTo", " copyto", "copyFile", "copyFrom", "CopyFile", " transferTo", "Copyto", "copyto", " transferto", " transferFrom", " copyFile", "CopyFrom"], "dest": ["bin", "data", "sup", "name", "opt", "later", " destination", "table", "them", "cont", "destroy", "comb", "class", "orig", "die", "desc", "w", "output", "txt", "content", "img", "done", "dist", "temp", "test", "source", "path", "filename", "object", " Dest", "delete", "exit", "flat", "file", "wb", "folder", "transform", "src", "Dest", "target", "write", "obj", "tmp", "rest"], "in": ["x", "reader", "bin", "connection", "isin", "sin", "f", "login", "issue", "s", "ins", "pin", "m", "cin", "In", "vin", "inside", "kin", "conn", "b", "inner", "again", "rin", "win", "r", "l", "din", "IN", "ax", "plus", "pull", "ini", "i", "source", "image", "init", "inc", "lib", "nin", "h", "n", "pass", "thin", "inn", "as", "up", "fa", "id", "wave", "lin", "input", "con", "ln", "re", "ac", "gin"], "out": ["x", "bin", "app", "ext", "outside", "data", "name", "socket", "pin", "sync", "ex", "outs", "not", "timeout", "one", "copy", "conn", "w", "b", "output", "cache", "again", "inner", "part", "vert", "user", "writer", "err", "plus", "o", "off", "OUT", "temp", "this", "client", "call", "i", "lib", "external", "image", "inc", "nin", "or", "outer", "exec", "object", "other", "url", "no", "our", "n", "io", "net", "up", "file", "target", "ou", "Out"], "c": ["x", "abc", "cb", "arc", "f", "char", "sc", "m", "ca", "ct", "C", "p", "enc", "ec", "pc", "rc", "lc", "u", "content", "cr", "l", "r", "e", "o", "exc", "esc", "dc", "d", "i", "pointer", "ci", "cc", "comment", "buffer", "ch", "t", "uc", "cf", "xc", "v", "cl", "config", "code", "n", "oc", "cu", "ce", "ic", "cm", "ac", "col", "fc", "bc", "cy"]}}
{"id1": "16931472", "id2": "17901739", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "label": 1, "substitutes": {"handler": ["process", " callback", " fire", " finish", " rewrite", " setup", " handle", " serve", " init", " notify", " success", " complete", "handle", " response", " handling", " on", " processing", "callback", " fn", " next", " load", "Handler", " dispatch", " f", " done", " redirect", " transfer"], "result": ["match", "buffer", "output", "order", "view", "map", "dict", "page", "json", "cache", "complete", "group", "array", "response", "report", "message", "resource", "Result", "results", "manager", "row", "feature", "session", "data", "status", "record", "document", "table", "res", "list", "event", "re", "source"], "target": ["request", "next", "image", "favorite", "client", "template", "that", "the", "html", "master", "output", "class", "object", "layout", "proxy", "host", "theme", "owner", "version", "reference", "parent", "environment", "route", "page", "server", " Target", "tail", "connection", "content", "location", "response", "resource", "http", "manager", "link", "this", "base", "unit", "goal", "session", "data", "download", "type", "Target", "token", "database", "task", "it", "site", "external", "arget", "project", "style", "about", "event", "current", "source", "config"], "url": ["blog", "buffer", "service", "sl", "stream", "socket", "view", "feed", "user", "page", "server", "address", "connection", "http", "URL", "resource", "path", "io", "ssl", "file", "build", "str", "Url", "channel", "base", "loader", "org", "l", "browser", "string", "uri", "source"], "reader": ["iterator", "in", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "i", "rc", "feed", "input", "e", "rx", "ry", "server", "ler", "http", "editor", "report", "io", "rr", "row", "reading", "file", "iter", "f", "ri", "err", "builder", "loader", "er", "over", "driver", "parser", "read", "layer", "bird"], "line": ["error", "sync", "lf", "key", "profile", "cell", "comment", "info", "str", "end", "link", "iter", "no", "base", "range", "ine", "text", "name", "body", "string", "non", "sl", "rl", "view", "user", "parse", "lined", "page", "rule", "home", "lines", "strip", "response", "message", "li", "file", "definition", "err", "live", "status", "l", "plugin", "lock", "look", "email", "el", "e", "id", "lc", "limit", "Line", "lin", "row", "liner", "o", "pe", "log", "cl", "frame", "nl", "point", "source", "lo", "side", "buffer", "block", "or", "code", "zip", "inline", "data", "LINE", "site", "style", "header", "le"], "entry": ["match", "writer", "service", "ner", "term", "element", "ie", "key", "cell", "rc", "feed", "owner", "layer", "e", "enter", "section", "page", "ry", "archive", "ener", "per", "or", "connection", "inner", "editor", "resource", "se", "exit", "value", "row", "part", "link", "ge", "data", "builder", "her", "ent", "entity", "Entry", "member", "string", "counter", "uri", "extra", "source"], "fromIndex": ["toOffset", "FromPoint", "fromSection", "sourcePoint", "fromPoint", "FromOffset", " fromLength", "fromLength", "toIndex", " fromPosition", "FromPosition", "toPosition", "fromPosition", "FromSection", " fromPoint", "FromIndex", "startOffset", "startPosition", "startLength", "toPoint", " fromSection", "startIndex", "sourcePosition", " fromOffset", "fromOffset", "FromLength", "sourceIndex", "sourceSection"], "r": ["lr", "fr", "m", "p", "ner", "attr", "rl", "q", "rc", "rs", "cr", "e", "ru", "rb", "array", "rr", "nr", "sr", "mr", "f", "ri", "u", "range", "b", "v", "er", "w", "vr", "l", "rg", "res", "ar", "d", "R", "re", "c", "pr"]}}
{"id1": "1698200", "id2": "11341711", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginBitShares", "loginBandRay", "loginbitShares", "loginbitshare", " loginBitRay", "loginBandshare", " loginBitshare", " loginBitShares", "loginbitShare", "loginBitshare", "loginBandShares", "loginBandShare", "loginbitRay", "loginBitRay"], "params": ["ls", "param", "page", "lp", "ssl", "eters", "server", "details", "cmp", "par", "manager", "ps", "fps", "options", "parts", "ns", "parser", "reports", "phrase", "radius", "bis", "vs", "Parameters", "photos", "settings", "results", "posts", "api", "parse", "properties", "config", "license", "ip", "Par", "pi", "base", "eps", "cache", "mm", "ams", "ops", "ctx", "pm", "php", "rules", "words", "json", "pro", "utils", "services", "http", "p", "ds"], "httpclient": ["ttpserver", "webserver", "httpsclient", "httpsapi", " httphttp", "phpapi", "htmlclient", "ttpClient", "httpsconnection", "htmlresponse", "webClient", "httpClient", "webclient", " httpapi", "httpconnection", "ttphttp", "httpsresponse", "httphttp", " httpserver", "httpsClient", "phpclient", " httpClient", "phpconnection", "httpserver", "htmlClient", "httpapi", "phpClient", "webhttp", " httpconnection", "ttpclient", "htmlconnection"], "httppost": ["httpport", " httplost", " httplort", "httpoint", "httpperost", "httphort", "httphost", "httppeost", " httpoint", " httposter", "httport", " httppeood", "httpood", "httppsoint", " httppeost", "httppeoint", "httcppood", "httcpposter", " httppood", " httploster", "httcppost", " httppoint", " httpprost", "httphoster", "httpprost", " httpost", "httplpost", "httppsost", " httprost", "httploster", "httppsoster", "httplost", "httprost", " httpposter", " httppeoster", "httppoint", "httpposter", "httppood", "httcppoint", "httphpost", "httposter", "httpppost", "httpost", " httppeoint", "httppeoster", " httpport", "httplort", " httpppost", "httppeood", " httplpost", "httppsrost"], "formparams": ["formparam", "formedblock", "Formparams", "FORMams", "formedams", "Formsettings", "handargs", "fauthors", "feedparam", "formams", "feedsettings", "feedparams", "feedams", "handParameters", "handams", "headparam", "formargs", " formblock", "formauthors", "fams", "fparams", " formams", " formparam", "Formparam", "FORMparams", " formnames", " formsettings", "FORMblock", " formargs", "formnames", "formedparam", "FORMparam", "FormParameters", "headnames", " formauthors", "Formargs", "formedparams", "formsettings", "formParameters", "handparams", "Formams", "formedauthors", "Formnames", "headams", " formParameters", "fparam", "headparams", "formblock"], "entity": ["page", " entities", "url", "ities", "e", "resource", "server", "html", "body", "connection", "form", "Entity", "event", "data", "output", "ec", "entry", "document", "model", "result", "translation", "ent", "type", "el", "xml", "api", "article", "db", "et", "object", "email", "file", " Entity", "service", "environment", "json", "response", "query", "content", "collection", "person"], "httpresponse": ["phpresponse", "phpresp", "htmlclient", "htmlresponse", " httpresp", "hyperclient", "Httpresponse", "hyperserver", "httpresp", " httpserver", "phpserver", "htmlserver", "httpserver", "hyperresponse", "Httpserver", "Httpresp"], "it": ["ort", " It", "ins", "ct", "ait", "IT", "It", "st", "init", "ul", "iti", "si", "you", "not", "in", "ati", "entry", "iv", "set", "index", "itted", "sort", "and", "end", "the", "i", "ist", "mit", "l", "edit", "ip", "lit", "slice", "pit", "ind", "which", "ic", "start", "I", "op", "ite", "cont", "or", "iz", "quit", "its", "rit"], "escookie": ["Escaddy", " escaddy", "Escerve", "ascinel", "descenter", "estaddy", "escinel", " esccookie", "ascake", "escake", "ascaddy", "sccel", " enookie", "estenter", "scale", " encookie", "escenter", "cookie", "ecookie", "esccookie", "eccookie", "scake", "scookie", "Escenter", "ascale", "esccel", "desccel", "Escinel", "ascookie", "descake", "caddy", "escoding", "Esccel", "ascerve", "escaddy", "escale", "Escookie", "asccel", "estookie", "descaddy", "cerve", "ecoding", "ecaddy", "escerve", "descookie", "estcel", " escoding", "cinel", " enoding", "descale", " enaddy"]}}
{"id1": "8064604", "id2": "17207832", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    @Test\n    public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception {\n        Exception e = new UnsuccessfulResponseException(resp);\n        expect(mockBackend.execute(host, req, ctx)).andThrow(e);\n        replay(mockBackend);\n        HttpResponse result = impl.execute(host, req, ctx);\n        verify(mockBackend);\n        assertSame(resp, result);\n    }\n", "label": 0, "substitutes": {"init": ["create", "reset", "set", "client", "load", "update", "config", "info", "construct", "sleep", "build", "install", "open", "initial", "it", "setup", "transfer", "exec", "connection", "Init", "activate", "cli", "boot", "launch", "start"], "mgr": ["amgr", "ambr", "amigr", "marr", "Mgr", "pigr", "amrr", " migr", "migr", " mr", "mr", "mbr", "prr", "mrr", "Mtr", "cgr", "pgr", "mtr", "cr", " mtr", "Marr", "pbr", " mrr", "ctr", " marr", "Mr", "carr", " mbr"], "cfg": ["cache", "MC", " chain", "cf", " config", "cb", "config", " conf", " cf", "map", "gate", "gp", "g", "Conf", "Msg", "Hash", "gen", "password", " cache", "conf", "bm", " img", "chain", "mem", "file", "mc", " ssh", "db", " configuration"], "sock": [" socket", "opensib", "opensocket", "opensocks", " socks", "gesocks", "gesink", "Sink", "gesock", "socket", "Socket", "Sock", "opensock", "sib", "gesocket", "Socks", " sink", " sib", "socks", "Sib", "sink"], "_cman": [" _cgr", "_cfg", "_mman", "_cmn", " _cmn", "_mcgr", " _mcfg", " _cfg", " _mcman", "_mfg", " _mcmn", "_gman", "_mcman", "_mmn", "_gfg", "_mcfg", "_cgr", "_mcmn", "_mgr", "_gmn", "_ggr", " _mcgr"], "_sock": ["_unsock", "_opensocket", " _svc", "_sdk", "_nsock", "_Svc", " _serve", "_socket", "_csocks", "_sort", "_svc", "_nsockets", "_openserve", "_docks", "longsock", "_unsocks", "_opensort", "_unsocket", "_Socks", "_sockets", "_asockets", "_unsdk", "_Sock", "_bocket", "longsrc", "_opensvc", " _socks", "longnsrc", "_bort", "_Sdk", "_dock", "_socks", "_csock", "_dort", "_opensock", "_jsocks", "longnsocks", "_docket", "_jsdk", "_nsocks", "_bock", "_nsrc", "_opensocks", "_jsock", "_bocks", "longnsockets", "_src", "longsocks", "_csockets", "longnsock", "_asock", "longsockets", "_asocks", "_csrc", "_jsocket", "_serve", "_Serve", "_asrc", "_Socket"], "i": ["p", "x", "my", "uri", "field", "inner", "ni", "f", "ai", "s", "ii", "gi", "ix", "info", "e", "ie", "l", "I", "k", "ci", "m", "ini", "in", "q", "chi", "multi", "ip", "io", "bi", "iu", "si", "n", "u", "ti", "it", "b", "is", "ui", "pi", "ji", "oi", "li", "index", "j", "h", "hi", "mi", "di", "qi", "value", "y", "xi", "r", "slice", "o", "id", "v", "ri", "d", "phi"], "key": ["text", "source", "json", "k", "ip", "base", "name", "search", "code", "rule", "pid", "temp", "entry", "type", "section", "char", "token", "ace", "check", "shift", "phrase", "root", "data", "pick", "fix", "label", "ki", "sum", "id", "order", "pair", "secret", "match", "kid", "cy", "str", "fee", "field", "point", "link", "cert", "nice", "number", "string", "prefix", "qi", "value", "op", "KEY", "ck", "length", "wire", "ask", "ie", "kh", "q", "mac", "mix", "change", "query", "index", "connection", "patch", "lock", "trust", "row", "sign", "Key"], "_sout": ["_sbio", "_sbout", "_sein", "_seio", "_seout", "_SOut", "_sOut", "_Sin", "_Sio", "_sin", "_sio", "_sbin", "_sbOut", "_seOut", "_Sout"], "_sinp": ["_sinpc", "_inpc", "_dispc", "_srer", "_inp", "_disp", "_srb", "_sinb", "_disb", "_srpc", "_iner", "_siner", "_inb", "_diser", "_srp"], "seed": ["secret", "source", "kid", "cookie", "char", "shape", "token", "json", "username", "shift", "pad", "slave", "driver", "root", "input", "black", "sleep", "kh", "data", "pick", "folder", "eed", "sudo", "shadow", "name", "random", "host", "theme", "password", "zip", "prime", "address", "sha", "delay", "index", "string", "finger", "dd", "digit", "scale", "sum", "serial", "sample", "test", "sql", "parser", "ruby", "row", "grain", "slice", "feed", "id", "pattern"], "rand": ["who", "re", "reg", "rr", "rar", "Rand", "max", "gram", "bird", "ind", "pick", "win", "bot", "round", "next", "grad", "der", "NG", "random", "gen", "cr", "nd", " random", "dist", "min", "dr", "rc", "dev", "chain", "ng", "range", "sample", "r", "roll", "id", "user", "rh", "start", "draw", "go"], "hex": ["x", "text", "cookie", "json", "buff", "loc", "auth", "transform", "ip", "code", "zip", "sha", "div", "tri", "serial", "lit", "pex", "iter", "temp", "pack", "rh", "pattern", "form", "closure", "char", "token", "check", "shift", "quant", "cross", "view", "cube", "shadow", "ticket", "wh", "raw", "sum", "batch", "id", "bin", "secret", "hess", "alph", "cf", "box", "string", "exp", "alpha", "chain", "scale", "loop", "sex", "length", "pad", "ex", "kh", "ph", "num", "mix", "letter", "ch", "oct", "index", "lock", "digit", "rex", "row", "cmp"], "pass": ["ride", "secret", "access", "press", "ss", "parse", "oss", "path", "flash", "push", "session", "cross", "skip", "line", "read", "process", "service", "auth", "PASS", "strip", "act", "fix", "allow", "proc", "gen", "code", "post", "password", "report", "oct", "rss", "Pass", "worker", "lock", "prefix", "fail", "test", "Password", "ass", "ress", "task", "route", "step", "feed", "sign", "login", "handle", "run", "mail"], "md5": ["MD85", "mand3", "sha2", "sha7", " MD\n", "MD\n", "mand5", "ma5", "md4", "md2", "sha4", " md3", "md\n", " mdody", "MD4", "md512", " md7", "sha512", "md3", "mdody", "md7", "sha5", "ma4", " md2", "MD2", "md\t", "MD5", "md85", "mand2", "ma85", " md85", "sha3", " MD\t", "MD512", " md4", " md\t", "ma2", "MDody", " md512", "mandody", " md\n", "MD\t", "MD7", "MD3"], "hash": ["text", "secret", "hed", "cache", "ash", "alt", "dig", "build", "kh", "addr", "auth", "mac", "url", "base", "host", "code", "password", "sha", "h", "string", "header", "lock", "sum", "ruby", "block", "ha", "html", "version", "her", "id", "rh", "db"], "banner": ["banorer", "warnler", "Banning", "planorer", "planners", "planning", "bannet", "banning", "ironnet", "annning", "binning", "warnner", "bannel", "planner", "bann", "bluener", "plann", "ironner", "Banker", "binorer", "blueler", "warnnel", "Banorer", "Bannel", "blueker", "banler", "annner", "ironning", "Banner", "bluenel", "banners", "Bann", "warnker", "binn", "annnet", "binner", "ironners", "annners", "Banler", "plannet", "banker"], "txt": ["text", " text", "rx", "flat", "lines", "json", "str", "pty", "git", "cb", "vt", "config", "info", "buff", "fb", "gz", "np", "bytes", "wd", "buf", "js", "notes", "ff", "tx", "xml", "qt", "data", "elt", "utt", "TEXT", "bot", "email", "pdf", "img", "tmp", "tty", "ext", "Text", "obj", "zip", "rss", "htm", "struct", "gold", "thin", "details", "parser", "test", "file", "xt", "diff", "xxx", "kt", "tin", "hea", "rpm"], "sname": ["asname", "nsdata", "esnames", "esName", "vesnames", " sName", "sdata", "vesname", "snames", "esnamed", "sName", " snames", "asdata", " sdata", "asnamed", " snamed", "snamed", "vesName", "nsnames", "asnames", "vesnamed", "nsname", "nsnamed", "esname"], "spass": ["espasses", "spash", "Sposs", "splash", "SPill", "SPasses", "aspad", "sloss", "espash", "SPass", "slill", "slasses", "Spasses", "sposs", "splass", "spasses", "espass", "Spill", "spill", "spad", "splasses", "splad", "aspass", "SPoss", "Spass", "slass", "espad", "aspash", "aspasses"], "sseed": ["ssroot", "psecret", "stoken", " spassword", "psslave", "sgrain", "gseed", "gsgrain", "sentry", "pseed", " sentry", "psseed", "Seed", "symseed", "submitentry", "Sseed", "submittoken", "sslave", "sroot", "symkey", "gsseed", "symeed", "pslave", "dtoken", " stoken", "ssseed", "skey", "ssslave", "psroot", "proot", "spassword", "submitseed", "symgrain", "gskey", "dseed", "Skey", "sssecret", "dpassword", "Sgrain", "submitpassword", "dentry", "ssecret", "pssecret"], "items": ["parts", "apps", "ends", "units", "locks", "lines", "orders", "cats", "photos", "bits", "Items", "ips", "keys", "lists", "styles", "bytes", "groups", "js", "xml", "item", "projects", "data", "names", "rooms", "cells", "opens", "flows", "values", "pieces", "pins", "objects", "qs", "boxes", "params", "files", "ants", "members", "links", "models", "pages", "loads", "plugins", "owners", "abs", "results", "events", "ids", "articles", "images", "rows", "posts", "phones", "ops"]}}
{"id1": "4481712", "id2": "6371580", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"deleteObject": ["saveItem", "deleteItem", "saveObject", "saveDB", " deleteObj", "removeObject", "deleteDB", " deleteItem", " deleteDB", "removeDB", "removeItem", "removeObj", "deleteObj", "saveObj"], "id": ["string", "path", "info", "root", "i", "uri", "resource", "lock", "uid", "sid", "query", "ident", "database", "in", "ids", "key", "type", "source", "rid", "model", "parent", "data", "object", "oid", "ip", "delete", "name", "it", "pid", "sql", "url", "ID", "create", "f", "error", "Id", "api"], "conn": ["Connection", "nw", "ssl", "core", "ou", "Conn", "cc", "server", "n", "serv", "cmp", "cf", "rc", "enc", "lock", "con", "c", "act", "cb", "col", "host", "pool", "co", "rt", "dc", "nc", "ec", "client", "cms", "nt", "cm", "cp", "sync", "cache", "lc", "cond", "ct", "connection", "ch", "cat", "config", "cmd", "ca", "parent", "h", "log", "ai", "po", "coll", "ci", "exec", "cr", "ann", "db", "pc", "mc", "ctx", "sql", "comm", "auth", "conf", "err", "connect", "cn", "ac", "orp", "cli", "error", "cur", "pg", "org", "loc"], "stmt": ["strmn", "stql", "strm", "strmp", "tm", "tmn", "Stmm", "Stmn", "strtx", " stmb", " stm", " stmp", "istmt", " stmit", "pttx", " stmm", "strmt", "tmt", "ptmn", " stmd", "stmp", "Stma", "Stmr", "stmd", "tmm", "stm", "strmd", "stma", " sttx", "Stmp", "dma", "istmr", "stmit", "istmit", "dmt", "dmb", "stmr", "Stmd", "Stmit", "strmi", "strmb", "dm", "Stm", "strmr", "Stmb", "stmm", "ptql", "strmm", " stma", "Stmi", " stql", " stmn", " stmr", "stmn", "stmb", "sttx", "ptmt", "Stmt", "stmi", "istm", " stmi", "strql"], "dbConn": ["dbConnection", "dbconn", "cbConnection", "cbCon", "bbConn", " dbConnect", "bdConnection", "dbConnect", "databaseConn", "databaseConnection", "cbConnect", " dbConnection", "bbconn", " dbconn", "bdCon", "bdConn", "databaseConnect", "bbConnect", "databaseconn", "cbConn", " dbCon", "bdConnect", "bbConnection", "dbCon"], "selfConnection": [" selfconnection", "passReference", "parentconnection", "passConnection", "thisConnection", "SelfConnection", "parentConn", "thisConn", "selfconnection", "SelfConnect", "thisConnect", "selfReference", " selfConn", "Selfconnection", " selfConnect", "passConn", "thisReference", "selfConnect", "selfConn", " selfReference", "thisconnection", "parentConnect", "passConnect", "SelfReference", "SelfConn", "passconnection", "parentConnection"]}}
{"id1": "22057083", "id2": "9327525", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"Connect": ["Load", "Dial", "Run", "New", "Host", "Login", "Setup", "Socket", "Close", "connect", "Config", "Build", "Connector", "Create", "Sync", "Construct", "Init", "Connection", "Client", " Connection", "Open", " Close", "Fail", "Subscribe", "Remote", "Process", "Conn", "connected"], "client": ["cm", "cl", "console", "cache", "clean", "cod", "local", "util", "project", "call", "force", "port", "proxy", "ace", "child", "command", "request", "default", "plugin", "remote", "host", "connect", "session", "conn", "secure", "core", "cp", "end", "name", "friend", "c", "cc", "ci", "lib", "code", "ssl", "connection", "user", "parent", "cloud", "handler", "Client", "per", "socket", "config", "co", "service", "resource", "api", "close", "get", "http", "grid", "cli", "pool", "server", "cn", "channel", "pc", "con", "open", "manager", "ce", "cell"], "reply": ["address", "result", "ping", "error", "send", " response", "status", "call", "answer", "comment", "replace", "request", "state", "ret", "err", "next", "link", "bot", "prefix", "code", "respond", "read", "reason", "repl", "connection", "info", "Reply", "echo", "query", "sync", "ply", "message", "related", "buffer", "post", "rc", "dy", "continue", "resp", " replies", "part", "response"]}}
{"id1": "1769771", "id2": "14231545", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFile", "CopyFiles", " copyFiles", "copyfile", "CopyChannel", " copyfile", "copyChannel", "transferfile", "transferChannel", " copyChannel", "copyFiles", "Copyfile", "transferFiles", "transferFile"], "in": ["m", "ex", "ins", "url", "image", "In", "lock", "io", "data", "inc", "f", "input", "IN", "inn", "lin", "index", "i", "source", "win", "reader", "config", "l", "work", "login", "inner", "base", "min", "id", "bin", "file", "c", "name", "diff", "pin", "query", "again"], "out": ["prefix", "ex", "writer", "default", "write", "image", "server", "plain", "call", "resource", "b", "n", "io", "off", "dot", "external", "output", "o", "Out", "conn", "target", "base", "outs", "point", "user", "cache", "string", "v", "exec", "file", "c", "name", "extra", "up", "w", "OUT", "x", "again", "p", "ext"], "inChannel": ["outClient", "outchannel", "inputChan", "inputChannel", "InStream", " inStream", "InChan", "INChannel", "insChannel", " inchannel", "inClient", "InChannel", "insChan", "inStream", "inChan", "binStream", "INStream", "inchannel", "binClient", "binchannel", "binChannel", "insStream", "winStream", "INchannel", "inputchannel", " inChan", "binChan", "outStream", "inputStream", "insClient", "winChannel", " inClient", "InClient", "outChan", "winChan", "Inchannel", "INChan", "winchannel"], "outChannel": ["outchannel", "inputChan", "inputChannel", "nChan", "nManager", "outputStream", "inConnection", "OutChan", " outManager", "outCh", "inStream", "inController", "inChan", " outChan", "outManager", "nStream", "OutConnection", "OutChannel", "inchannel", "inputchannel", "Outchannel", " outchannel", "inCh", "outputCh", "inputController", "outStream", "nChannel", "inManager", " outStream", "outputChan", "outChan", " outCh", "outController", "outputController", "outConnection", " outConnection", "outputChannel", "outputchannel"]}}
{"id1": "4481712", "id2": "4599372", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    @Override\n    public String readFixString(final int len) {\n        if (len < 1) {\n            return StringUtils.EMPTY;\n        }\n        final StringWriter sw = new StringWriter();\n        try {\n            IOUtils.copy(createLimitedInputStream(len), sw, null);\n        } catch (IOException e) {\n            throw createRuntimeException(e);\n        }\n        return sw.toString();\n    }\n", "label": 0, "substitutes": {"deleteObject": ["saveItem", "deleteItem", "saveObject", "saveDB", " deleteObj", "removeObject", "deleteDB", " deleteItem", " deleteDB", "removeDB", "removeItem", "removeObj", "deleteObj", "saveObj"], "id": ["string", "path", "info", "root", "i", "uri", "resource", "lock", "uid", "sid", "query", "ident", "database", "in", "ids", "key", "type", "source", "rid", "model", "parent", "data", "object", "oid", "ip", "delete", "name", "it", "pid", "sql", "url", "ID", "create", "f", "error", "Id", "api"], "conn": ["Connection", "nw", "ssl", "core", "ou", "Conn", "cc", "server", "n", "serv", "cmp", "cf", "rc", "enc", "lock", "con", "c", "act", "cb", "col", "host", "pool", "co", "rt", "dc", "nc", "ec", "client", "cms", "nt", "cm", "cp", "sync", "cache", "lc", "cond", "ct", "connection", "ch", "cat", "config", "cmd", "ca", "parent", "h", "log", "ai", "po", "coll", "ci", "exec", "cr", "ann", "db", "pc", "mc", "ctx", "sql", "comm", "auth", "conf", "err", "connect", "cn", "ac", "orp", "cli", "error", "cur", "pg", "org", "loc"], "stmt": ["strmn", "stql", "strm", "strmp", "tm", "tmn", "Stmm", "Stmn", "strtx", " stmb", " stm", " stmp", "istmt", " stmit", "pttx", " stmm", "strmt", "tmt", "ptmn", " stmd", "stmp", "Stma", "Stmr", "stmd", "tmm", "stm", "strmd", "stma", " sttx", "Stmp", "dma", "istmr", "stmit", "istmit", "dmt", "dmb", "stmr", "Stmd", "Stmit", "strmi", "strmb", "dm", "Stm", "strmr", "Stmb", "stmm", "ptql", "strmm", " stma", "Stmi", " stql", " stmn", " stmr", "stmn", "stmb", "sttx", "ptmt", "Stmt", "stmi", "istm", " stmi", "strql"], "dbConn": ["dbConnection", "dbconn", "cbConnection", "cbCon", "bbConn", " dbConnect", "bdConnection", "dbConnect", "databaseConn", "databaseConnection", "cbConnect", " dbConnection", "bbconn", " dbconn", "bdCon", "bdConn", "databaseConnect", "bbConnect", "databaseconn", "cbConn", " dbCon", "bdConnect", "bbConnection", "dbCon"], "selfConnection": [" selfconnection", "passReference", "parentconnection", "passConnection", "thisConnection", "SelfConnection", "parentConn", "thisConn", "selfconnection", "SelfConnect", "thisConnect", "selfReference", " selfConn", "Selfconnection", " selfConnect", "passConn", "thisReference", "selfConnect", "selfConn", " selfReference", "thisconnection", "parentConnect", "passConnect", "SelfReference", "SelfConn", "passconnection", "parentConnection"]}}
{"id1": "18374478", "id2": "20663364", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 1, "substitutes": {"updateUser": ["createUsers", "updateRole", "editUsers", " updateMember", "addUsers", "addUser", "deleteRole", "updateuser", "editUser", "deleteUsers", "updatedWord", "updateUsers", "deletePassword", " updateAccount", "createRole", "adduser", "deleteMember", "UpdateUsers", "deleteUser", "editRole", "updatedUsers", "updatePassword", " updateUsers", "updatedUser", "updateMember", "addWord", "updateduser", "editAccount", "deleteWord", "UpdatePassword", "deleteuser", " updateWord", "updateWord", "UpdateWord", " updatePassword", "createAccount", " updateRole", "updateAccount", "UpdateRole", "createUser", "UpdateUser", "Updateuser", "UpdateMember", " updateuser"], "user": ["job", "account", "match", "client", "self", "app", "p", "creator", "User", "full", "author", "profile", "you", "object", "use", "view", "USER", "ro", "character", "instance", "version", "bug", "used", "parent", "page", "rule", "server", "per", "group", "module", "result", "connection", "ver", "content", "response", "resource", "message", "pool", "manager", "row", "str", "post", "this", "null", "model", "session", "data", "update", "system", "contact", "log", "users", "record", "name", "auth", "me", "site", "member", "plugin", "project", "string", "custom", "current", "person", "config", "username"], "conn": ["ha", "db", "pt", "client", "connect", "ca", "Conn", "h", "sync", "ctx", "n", "oss", "cond", "cp", "host", "rc", "cn", "cc", "pg", "el", "socket", "ou", "cat", "cr", "cli", "nt", "ci", "core", "coll", "cache", "server", "cb", "ann", "loc", "reg", "connection", "nc", "dc", "ob", "cm", "pool", "con", "conf", "uc", "part", "pub", "util", "col", "ch", "enc", "serv", "exec", "sql", "url", "close", "ac", "api", "log", "org", "ct", "pc", "co", "mc", "sth", "Connection", "lock", "act", "config", "c", "pr", "ec"], "autoCommit": ["autoDebmit", " autoDebitting", "autoCommits", "autoBlIT", "autoRebit", "automaticCommit", "autoComend", "autoCommite", "autoComIT", "autoDebend", " autoCommite", "automaticCommmit", "autoComite", " autoCommitting", "autoDebits", "autoAbit", "autoBlend", "automaticDebmit", " autoComite", " autoDebmit", "autoCommend", " autoCommmit", "autoDebit", "autoCommmit", "autoCit", "autoCmit", "autoRebite", "autoCommited", " autoComits", "autoComit", "autoDebitting", "autoDebIT", " autoCommits", "autoAbmit", " autoCommited", "autoCommitting", "autoComits", "autoCommIT", "autoBlmit", "automaticCommend", "autoDebited", "autoDebite", "automaticDebend", "autoCited", " autoComit", "automaticCommIT", "automaticDebIT", " autoDebited", "autoBlit", "autoAbitting", " autoDebit", "autoCitting", "autoRebits", "automaticDebit", "autoAbited"], "deleteRoles": ["deleteGrols", "deleteRooles", "deleteNols", "insertRoases", "deleteColes", "deleteRodes", "deleteSlases", "deleteRole", "insertRases", "deleteCodes", "delLole", "insertRooles", "deleteGroles", "deleteRoases", "insertRoules", "deleteLole", "deleteDoots", "deleteDases", "deleteNoles", "delLases", "deleteRoole", "delRodes", "delLodes", "insertRules", "destroyRols", "delRoles", "deleteCole", "deleteRoots", "deleteSloles", "deleteLoles", "destroyNoots", "destroyNols", "deleteNoots", "deleteRsole", "deleteNils", "deleteRsases", "deleteRases", "deleteRils", "deleteRsoles", "deleteCases", "deleteSlodes", "deleteDils", "deleteSlole", "destroyRils", "deleteRules", "deleteDole", "insertRole", "delRole", "deleteGroots", "destroyNoles", "destroyRoles", "deleteRoules", "deleteLases", "deleteDoles", "deleteDols", "deleteRsules", "delLoles", "deleteGrils", "destroyNils", "insertRoole", "deleteRols", "delRases", "destroyRoots", "deleteLodes", "deleteDules"], "insertRoles": ["insertGows", "insertSloots", "updateRols", "insertRsules", "copyRules", "copyGules", "insertRanges", " insertRules", "deleteSloles", "insertRows", "insertShole", "deleteRanges", "deleteSlodes", "insertLows", "deleteSloots", "insertRoots", "insertGules", "insertSloles", "copyRows", "insertLols", " insertShole", "insertGoots", "deleteRodes", " insertShodes", "insertSoles", "updateLoles", "insertRodes", " insertRole", "deleteRoots", "insertSlanges", "copyGoots", "updateLles", "insertSodes", "insertRsanges", "insertLules", "updateLols", "insertShodes", "insertRsows", "insertLles", "insertRles", "insertShules", "copyRoots", "insertGoles", "insertRules", "updateRles", "copyGoles", "insertRsoles", "copyRoles", "insertRsles", "insertSole", "deleteSlanges", "insertSules", "insertRols", " insertRodes", "insertLoots", "updateLules", "updateRules", "copyGows", "insertSholes", "insertSlodes", "insertRsodes", " insertShules", " insertSholes", "updateRoles", "insertLoles", "insertRole", "insertRsoots", "insertRsols"], "role": ["error", "de", "service", "Role", "one", "entry", "rl", "label", "tool", "key", "relation", "profile", "guard", "ro", "repl", "roller", "ole", "rol", "slave", "route", "rule", "val", "to", "group", "alias", "or", "module", "resource", "zone", "function", "row", "link", "base", "type", "range", "shadow", "tag", "force", "l", "member", "string", "le", "username"]}}
{"id1": "13362846", "id2": "17557289", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"setContenu": ["setContenuit", "setContineu", "setContineuit", "setTonenuer", "setContenues", "setTonenu", "setContonenuer", "setContennues", "setTenuit", "setContineuer", "setTenu", "setContenuer", "setContonenues", "setContennu", "setContonenu", "setContineues", "setTenuer", "setTenues", "setContennuer", "setTonenues", "setContonenuit", "setTonenuit", "setContennuit"], "contenuFichier": ["contenuFaffie", "contenuFaffier", "contenuFochique", "contenuPFicher", "contenuTicheery", "contenuFcherer", "contenuMichique", "contenuFrenchique", "contenuFrencherer", "contenuPhactoryoyer", "contenuTicheiere", "contenuFactoryie", "contenuTichiere", "contenuFichieri", "contenuFaffer", "contenuFichery", "contenuFichtique", "contenuFichique", "contenuMaffiers", "contenuFocher", "contenuFochiere", "contenuFicheier", "contenuFichtiere", "contenuPFichier", "contenuPrefichiers", "contenuFactoryiere", "contenuMichie", "contenuPhactoryier", "contenuFichtier", "contenuMrenchique", "contenuMichiers", "contenuMrenchier", "contenuFactoryoyer", "contenuPrefaffiers", "contenuPrefichiere", "contenuPrefichie", "contenuFchery", "contenuFicheiere", "contenuFochie", "contenuFaffieri", "contenuFicie", "contenuPhichoyer", "contenuFichtie", "contenuFaffiere", "contenuFicier", "contenuMaffieri", "contenuTicherer", "contenuFichiers", "contenuPrefaffiere", "contenuFicher", "contenuFicheery", "contenuTicheerer", "contenuFchiere", "contenuPFochique", "contenuFactoryier", "contenuPhactoryie", "contenuPhichiere", "contenuFrenchiere", "contenuFichiere", "contenuPhactoryiere", "contenuPFocher", "contenuPrefaffie", "contenuFchier", "contenuPFichiere", "contenuFicheique", "contenuFrenchery", "contenuTicheier", "contenuFrenchoyer", "contenuFicheieri", "contenuFichoyer", "contenuPrefichier", "contenuMrenchiere", "contenuFochiers", "contenuMaffier", "contenuMaffie", "contenuTichery", "contenuFochier", "contenuMichier", "contenuFrenchier", "contenuMaffiere", "contenuFrenchie", "contenuFicheie", "contenuPhichie", "contenuPFochier", "contenuFaffique", "contenuFiciere", "contenuFicherer", "contenuPhichier", "contenuFrenchiers", "contenuFicheerer", "contenuPrefaffier", "contenuPFichique", "contenuPFochiere", "contenuMrenchie", "contenuMichiere", "contenuFicoyer", "contenuFicheer", "contenuFichie", "contenuFaffiers", "contenuMichieri", "contenuFichtieri", "contenuTichier"], "fichierElectronique": ["fichierElectorniques", "fichierElectron\u00e9e", "fichierElectroneier", "fichierElectrolier", "fichierAdministronier", "fichierElectromistic", "fichierAustrolier", "fichierElectrolique", "fichierElectonlique", "fichierAdministronsique", "fichierElectronsiere", "fichierElectronsiques", "fichierElectaronie", "fichierElectornique", "fichierAustroliere", "fichierAdministronsie", "fichierElectronsical", "fichierElectroliere", "fichierElectroneique", "fichierCentornlique", "fichierElectronsique", "fichierElectolonique", "fichierElectoloniere", "fichierElectolonica", "fichierElectroneiere", "fichierElectrons\u00e9e", "fichierElectonie", "fichierAdministronsical", "fichierAdministroniques", "fichierElectrolie", "fichierCentornique", "fichierElectpronique", "fichierAustronique", "fichierElectromical", "fichierElectronsica", "fichierAdministronsier", "fichierElectoloniques", "fichierElectroniere", "fichierElectroneie", "fichierAustroniques", "fichierAdministronie", "fichierElectornlique", "fichierCentronique", "fichierCentroniques", "fichierElectroliques", "fichierAdministrons\u00e9e", "fichierElectonier", "fichierElectronical", "fichierElectproniques", "fichierElectronlique", "fichierAdministronique", "fichierElectrolica", "fichierElectornier", "fichierElectronistic", "fichierElectronslique", "fichierElectaronier", "fichierAdministronsistic", "fichierElectaron\u00e9e", "fichierCentronier", "fichierElectronsistic", "fichierAustroliques", "fichierElectonique", "fichierAdministronical", "fichierElectronica", "fichierCentronlique", "fichierElectpronical", "fichierElectpronistic", "fichierCentorniques", "fichierElectronsier", "fichierAustrolique", "fichierElectromique", "fichierElectroneiques", "fichierAustroniere", "fichierElectroniques", "fichierAdministronslique", "fichierElectrol\u00e9e", "fichierElectronsie", "fichierAdministron\u00e9e", "fichierAustronier", "fichierElectronie", "fichierAdministronsiques", "fichierElectromiques", "fichierElectronier", "fichierElectronelique", "fichierAdministronistic", "fichierAdministronlique", "fichierElectaronique", "fichierCentornier"], "utilisateurCourant": ["utilisationCourants", "utilisateurGovernateur", "utilisateurCourateur", "utilisateurGovernante", "utilisationCourante", "utilisateurGovernant", "utilisateurCourants", "utilisationApplicante", "utilisateurGovernants", "utilisationCourant", "utilisateurParticipant", "utilisationApplicateur", "utilisateurCourante", "utilisateurApplicants", "utilisateurApplicateur", "utilisateurParticipante", "utilisationCourateur", "utilisateurApplicant", "utilisateurApplicante", "utilisationApplicant", "utilisateurParticipants", "utilisationApplicants", "utilisateurParticipateur"], "support": ["pport", "contact", "util", "facebook", "concept", "summary", "media", "client", "push", "Support", "cover", "feature", "config", "system", "info", "compatible", "knowledge", "control", "services", "respect", "friend", "evidence", "review", "service", "proxy", "help", "format", "supported", "force", "storage", " Support", "accept", "document", "ann", "share", "allow", "utils", "supp", "best", "bank", "plugin", "Library", "settings", "protection", "pull", "library", "know"], "ficheDocument": ["fielCatalog", "fcheMatrix", "inficheDoc", "fraudDirectory", "fineFeature", "fagueDocument", "fagueDirectory", "facheDocument", "foineDocument", " fcheDirectory", "fcheDirectory", "facheDocuments", "ficheNumber", "FcheContent", "affinedocument", " ficheDocuments", "enfoiceDocument", "fraudCompany", "afficheFeature", "FicheDoc", "foiceDirectory", "ficheDocuments", "fchaDoc", "affineDocument", " fcheDocuments", "ficheCatalog", "afficheDocument", "foiceDocument", " ficheDirectory", "ficheMatrix", "foineDoc", "infraudNumber", " fcheDocument", "fetchDocument", "FcheDocument", "enficheCompany", "inficheNumber", "ficheFeature", "fielDirectory", "fruitDocument", "ficheCompany", "enficheCatalog", "enficheDirectory", "enfoiceDirectory", "enfoiceCompany", "infraudDocument", "enficheDocument", "friqueDocument", "infichedocument", "fcheDocuments", " ficheMatrix", "FcheDoc", "fielCompany", "fetchdocument", "finedocument", " fcheMatrix", "fcheContent", "fchaContent", "FicheContent", "financeNumber", "enfoiceCatalog", "Fichedocument", "friqueContent", "affichedocument", "fraudNumber", "fagueMatrix", "foineFeature", "facheMatrix", "foiceCatalog", "financeDocument", "facheDirectory", "Fchedocument", "affineDoc", "infraudDoc", "affineFeature", "fetchFeature", "fineDoc", "ficheContent", "fineDocument", "fcheDoc", "afficheDoc", "fraudDoc", "fetchDoc", "ficheDoc", "friquedocument", "infrauddocument", "fchedocument", "fchadocument", "fichedocument", "fruitdocument", "inficheDocument", "fruitNumber", "fcheDocument", "frauddocument", "fchaDocument", "foiceCompany", "FicheDocument", "friqueDoc", "foinedocument", "fagueDocuments", "fraudDocument", "ficheDirectory", "financeDoc", "fielDocument", "fruitDoc", "fraudCatalog", "financedocument"], "nomFichier": ["nomWchery", "nomPhichiere", "nomNichiller", "nomFachiller", "nomPichien", "nomFichien", "nomPichery", "nomVich\u00e8re", "nomFichtery", "nomVcher", "nomFiqurier", "nomFichiere", "nomWichire", "nomPchery", "nomVchieri", "nomF\u00e9tier", "nomWichiere", "nomFichieri", "nomF\u00e9tien", "nomPchien", "nomNichier", "nomPrefchieri", "nomFachrier", "nomPchier", "nomFichtiner", "nomVchier", "nomPhicherer", "nomFachieri", "nomFichire", "nomFochier", "nomWchier", "nomFiscier", "nomFrench\u00e8re", "nomFochery", "nomPrefchier", "nomPrefichieri", "nomFchy", "nomFachier", "nomFchire", "nomVch\u00e8re", "nomFichery", "nomPhichieri", "nomPhachiere", "nomFichtiere", "nomFichiner", "nomPhichier", "nomFiscy", "nomNichtiner", "nomPrefichire", "nomFachiner", "nomFchieri", "nomFichtire", "nomFitherer", "nomPrefichrier", "nomFochiere", "nomFrenchier", "nomFrenchieri", "nomFacherer", "nomFacher", "nomFichtiller", "nomVicher", "nomFchiere", "nomWichery", "nomFithiere", "nomFachire", "nomFiquier", "nomNicher", "nomVichieri", "nomNichtier", "nomFochire", "nomPchy", "nomFithieri", "nomFisciller", "nomFch\u00e8re", "nomF\u00e9ty", "nomFchrier", "nomFicherer", "nomFchier", "nomFiquieri", "nomVichier", "nomFchery", "nomPichy", "nomPrefchire", "nomFithier", "nomFisciner", "nomFichterer", "nomFichtier", "nomFichtieri", "nomPhachieri", "nomWchire", "nomFchien", "nomPrefichier", "nomWichier", "nomFiscery", "nomWchiere", "nomF\u00e9tery", "nomFiscien", "nomFcher", "nomFrencher", "nomFichy", "nomPhachier", "nomFachiere", "nomPrefchrier", "nomFichrier", "nomFich\u00e8re", "nomNichter", "nomFach\u00e8re", "nomPichier", "nomNichiner", "nomFichter", "nomFichiller", "nomFiscer", "nomFicher", "nomPhacherer", "nomFiquire", "nomNichtiller"], "extension": ["Extension", "Extime", "extception", "extensions", "EXTension", "anchension", "Extression", "encion", "encension", "encception", "EXTensions", "extion", "anchensions", "exception", "exression", "exension", "EXTime", "anchime", "Extception", "Extion", "extime", "encression", "extression", "Extensions", "exion"], "fichierElectroniqueExistant": ["fichierElectroniqueXist", "fichierElectroniquesExists", "fichierElectroniqueExplclusive", "fichierElectroniqueExplistant", "fichierElectroniqueExplivist", "fichierElectroniquesExistance", "fichierElectroniquesXist", "fichierElectroniquesXclusive", "fichierElectroniqueExilingual", "fichierElectroniqueSistance", "fichierElectroniqueexclusive", "fichierElectroniqueXistant", "fichierElectroniquesXistent", "fichierElectroniqueXistent", "fichierElectroniqueexists", "fichierElectroniquesXilingual", "fichierElectroniqueSistent", "fichierElectroniquesXistance", "fichierElectroniqueXists", "fichierElectroniquesXistant", "fichierElectroniqueexivist", "fichierElectroniquesExilingual", "fichierElectroniqueSilingual", "fichierElectroniqueexistance", "fichierElectroniquesExist", "fichierElectroniqueexist", "fichierElectroniqueExistance", "fichierElectroniquesXivist", "fichierElectroniqueExplists", "fichierElectroniqueexistant", "fichierElectroniqueexilingual", "fichierElectroniquesExistant", "fichierElectroniqueXilingual", "fichierElectroniqueExistent", "fichierElectroniqueExists", "fichierElectroniquesExistent", "fichierElectroniqueExplistance", "fichierElectroniqueExclusive", "fichierElectroniqueXivist", "fichierElectroniquesXists", "fichierElectroniquesExclusive", "fichierElectroniqueXclusive", "fichierElectroniquesExivist", "fichierElectroniqueSistant", "fichierElectroniqueExist", "fichierElectroniqueXistance", "fichierElectroniqueexistent", "fichierElectroniqueExivist", "fichierElectroniqueExplist"], "idIgid": ["idUgname", "idIgenids", "idIgnID", "idIgnid", "idIogdid", "idUguids", "idIgubit", "idEGbit", "idIgudid", "idEGdid", "idEgdid", "idIggids", "idUguID", "idUguid", "idIgenname", "idIgids", "idUguname", "idIgod", "idIGids", "idEGids", "idIgdid", "idIgmid", "idIgID", "idIguod", "idIGdid", "idIgenid", "idUgID", "idIgmids", "idIogid", "idEGid", "idUgid", "idUgids", "idEgid", "idIogids", "idIgname", "idIgenID", "idIgmname", "idIgmID", "idIggod", "idEgids", "idIguid", "idEgbit", "idIggID", "idIGid", "idIguids", "idIguname", "idIGbit", "idIguID", "idIggid", "idIgbit", "idIogbit", "idIgnids", "idIgnod"], "inputStream": ["InputStreamer", " inputThread", " inputstream", "outputStreamer", "eventStream", "InputThread", "InputLength", " inputLength", "Inputstream", "eventStreamer", "inputstream", "InputStream", "eventSteam", "inputLength", "outputLength", "InputSteam", "eventstream", "inputStreamer", " inputSteam", "inputThread", "outputstream", "inputSteam", "outputThread", "outputSteam"], "outputStream": ["entityStream", "OutputStream", "OutputStreamer", "OutputSteam", "officeStream", "Outputstream", "inputContext", "outputStreamer", "officeSteam", "OutputContext", "entityStreamer", "outputContext", " outputSteam", "inputstream", "entitystream", "officeStreamer", "entitySteam", " outputContext", "inputStreamer", "outputstream", "inputSteam", "officestream", " outputstream", "outputSteam"], "typeMime": ["typeMatangle", "TypeSmime", "TypeSmangle", "typeMimes", "TypeMangle", "typeMetime", "typeSmangle", "TypeMide", "typeMetimes", "typeMatide", "typeSmimes", "typeMatime", "TypeMimes", "typeMangle", "typeMatimes", "typeSmime", "typeMetide", "TypeSmimes", "typeMide", "TypeMime", "typeSmide", "TypeSmide", "typeMetangle"], "tailleFichier": [" tailleFicheier", " tailleFochie", " taillefichie", " taillefochie", " tailleFignier", " taillefocher", " taillefochier", " tailleFochier", " tailleFichie", " taillefichiers", " tailleFigner", " tailleFichiers", " taillefochiers", " tailleFochiers", " taillefichier", " tailleFignie", " tailleFocher", " tailleFicheiers", " tailleFicheer", " tailleFicheie", " tailleFigniers", " tailleficher", " tailleFicher"]}}
{"id1": "23118425", "id2": "18613870", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"encrypt": [" Encipher", "enrypted", " Encrypted", " Encrypt", "Encrypt", "enipher", "enrypt", "enccrypt", "encipher", "encrypted", "Enccrypt", "Encipher", "Encrypted", " Enccrypt"], "plaintext": ["broadtext", "flatdata", "plaindata", "plainstruct", "protectedText", "plainText", " plainText", "flattext", "broadText", "flatText", "broadsource", " plaindata", "flatstring", " plainsource", "protecteddata", "plainstring", "flatsource", "flatstruct", " plainstring", " plainstruct", "protectedtext", "broadstring", "plainsource", "protectedstruct"], "md": ["mad", "m", "mb", "hd", " MD", "Cmd", "message", "mp", "sha", "cmd", "pg", "material", "data", "mo", "ph", "dig", "dd", "mc", "mag", "d", "vd", "od", "meta", "nm", "hm", "wd", "code", "amd", "mg", "dm", "bd", "pkg", "metadata", "pd", "MD", "db", "ad", "mac", "mand", "ms", "mm", "ma", "mem", "dc", "am", "ld", "pm", "kg", "mt", "cd", "mu", "mod", "dh"], "raw": ["buf", "partial", "original", "shared", "array", "pack", "message", "image", "null", "empty", "RAW", "dec", "channel", "wrap", "input", "hex", "feed", "row", "ng", "instance", "ack", "rew", " RAW", "stream", " hex", "local", "load", "initial", "Raw", "def", "binary", "full", "clean", "response", "unknown", "unsigned", "content", "buffer", "serial", "enc", "custom", "block"], "hash": ["secret", "crypt", "text", "ash", "array", "auth", "log", "url", "message", "image", "html", "build", "sha", "rh", "empty", "data", "version", "her", "hex", "sum", "password", "h", "key", "row", "code", "kh", "header", "base", "mac", "id", "cache", "string", "full", "Hash", "response", "value", "buffer", "block"]}}
{"id1": "9210168", "id2": "665420", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"run": ["image", "register", "unit", "base", "in", "create", "inner", "stop", "render", "launch", "runs", "process", "add", "output", "replace", "un", "update", "show", "home", "code", "background", "display", "apply", "running", "work", "job", "out", "loop", "start", "name", "test", "runner", "call", "Run", "execute", "exec", "invoke"], "url": ["re", "err", "image", "URL", "base", "resource", "fr", "lr", "service", "Url", "http", "remote", "l", "b", "api", "string", "path", "uri", "plug", "nr", "ur", "loader", "ssl", "loc", "server", "user", "file", "id", "browser", "str", "sl", "rl", "source", "f", "address"], "fis": ["Fais", "flisa", "flis", " fIS", "pis", " fIs", "bais", "bIS", "pIs", "piss", "fais", "FIs", "fIs", "bIs", " fisa", " fiss", "Fis", " fais", "fIS", "fisa", "bis", "pisa", "Fiss", "fliss", "fiss", "biss", "FIS", "flIs"], "r": ["err", "resource", "fr", "rx", "vr", "kr", "rt", "ir", "ler", "rar", "l", "b", "pr", "ri", "c", "rf", "rc", "wr", "tr", "d", "er", "p", "rr", "BR", "nr", "rh", "rus", "mr", "is", "rs", "ur", "hr", "sr", "R", "e", "Reader", "reader", "rb", "i", "res", "rl", "ru", "ar", "cr", "f", "s"], "br": ["err", "dr", "lr", "fr", "rx", "vr", "HR", "bl", "arr", "rt", "yr", "bridge", "b", "bb", "ch", "buf", "gr", "tr", "wr", "fb", "bro", "bf", "be", "result", "Br", "BR", "mr", "B", "hr", "sr", "ob", "brush", "browser", "str", "reader", "rb", "res", "bc", "bh", "cr"], "line": ["link", "letter", "lc", "base", "end", "nl", "liner", "lf", "bl", "cl", "lines", "entry", "inline", "LINE", "Line", "key", "column", "l", "b", "shell", "style", "string", "code", "buffer", "pass", "li", "split", "part", "number", "row", "le", "character", "name", "word", "sel", "ge", "data", "file", "id", "cell", "char", "header", "str", "sl", "i", "rl", "comment", "el", "cr", "f", "lin"], "sb": ["ib", "wb", "nb", "bsp", "lr", "bm", "eb", "storage", "zb", "bl", "SB", "ls", "sa", "xb", "src", "amb", "b", "bb", "cb", "bp", "usb", "buf", "gb", "buff", "abb", "buffer", "sn", "fb", "lb", "rob", "bf", "bd", "si", "obb", "sg", "sv", "erb", "bt", "pb", "bis", "bs", "binary", "sf", "sth", "rb", "mb", "bc", "bh", "bj", "BB", "db", "ab"], "text": ["letter", "config", "content", "format", "input", "entry", "obj", "message", "output", "b", "info", "object", "string", "txt", "code", "TEXT", "font", "buffer", "Text", "path", "translation", "result", "name", "title", "test", "ext", "data", "id", "str", "value", "comment", "connection", "source"]}}
{"id1": "15051083", "id2": "17558353", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            URL urlhome = new URL(\"http://www.verussolutions.biz/NGLDashBoard.xml\");\n            URLConnection uc = urlhome.openConnection();\n            InputStreamReader input = new InputStreamReader(uc.getInputStream());\n            BufferedReader in = new BufferedReader(input);\n            String inputLine;\n            String xmlData = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                xmlData += inputLine;\n            }\n            in.close();\n            PrintWriter fw = new PrintWriter(new FileWriter(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            fw.println(xmlData);\n            fw.flush();\n            fw.close();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n        try {\n            Document doc = new SAXBuilder().build(new File(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            String onlinsuppcdat = doc.getRootElement().getChild(\"OnlineSupportInformation\").getText();\n            CDATA cdata = new CDATA(onlinsuppcdat);\n            host.setOnlineInformationHTML(cdata.getText());\n            onlinsuppcdat = doc.getRootElement().getChild(\"News\").getText();\n            cdata = new CDATA(onlinsuppcdat);\n            host.setNewsHTML(cdata.getText());\n            host.fillData();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getMessageDesignest", "getmessageDigest", "getMessageDigester", "getMessageHashest", "getMessageHashests", "getMessageHashester", "getmessagedigester", "getmessageDigester", "getMessagedigester", "getmessagedigests", "getMessageHashature", "getMessageDigature", "getMessageDesignature", "getMessagedigature", "getmessageDigature", "getMessageDesignests", "getMessageDigests", "getMessagedigest", "getMessagedigests", "getmessagedigest", "getmessagedigature", "getMessageDesignester", "getmessageDigests"], "digest": ["Diger", " Digest", "digiter", "hexest", "greatest", "hexEST", "sandest", "DigEST", "Digger", " digEST", " digeter", "greatiter", "Digeter", "feedester", "Digex", "Digester", "digEST", "Digest", " digested", " Digeter", "sandesting", " digex", "digesting", "greatester", "hexex", " Digger", "sandester", "signest", "digger", "sandested", "hexests", " diger", " Dighed", "greatested", " digests", " Digester", " digester", " digger", "signested", " Diger", "digeter", "Digested", "Digesting", "digester", "digex", "signester", "Digests", "digests", "dighed", "Dighed", "Digiter", "diger", " dighed", "digested", "signesting", "feedest", "feedested", "signiter"], "node": ["component", "Node", "uri", "one", "resource", "server", "module", "parent", "n", "connection", "remote", "event", "child", " nodes", "document", "ode", "route", "index", " source", "element", "instance", "source", "config", " parent", "network", "self", " annotation", "point", "internal", "object", "local", "address", "name", "entity", " namespace", "root", "global", " Node", "location", "path", " child", "odes"], "external": ["intern", "ex", "ternal", "resource", "e", "n", "remote", " remote", "outer", "international", "outside", "foreign", "External", "tern", "multiple", "out", "element", "instance", "source", "network", "client", "target", "Intern", "internal", "object", "local", "https", "account", "name", "secondary", "global", "binary", "reference", " foreign", "environment", " global", " External", "export"], "messageDigest": ["messageMarkester", "messageModester", "messageSignested", "MessageDigest", "messagedigger", "messageMarkested", "messageModesting", "messageDigested", "messageDesignesting", "messagedigest", " messageHashest", "messageDigesting", " messageHashesting", "messageHashesting", "messageDesignest", " messageDesignger", "MessageSignest", "messageDesignger", " messageDigesting", "messageMarkenge", "messageDest", "messagedigester", " messageDigger", " messageDesignest", "messageSignenge", "messageDenge", "messageDesignested", "messageDigger", "messagedigested", " messageDigester", "messageModest", " messageDesignester", "messageHashest", "MessageSignester", "messageModested", "MessageDigenge", "MessageSignested", "messageDigenge", "messageDesignester", "messageSignest", " messageHashested", "messageDested", "messageMarkest", "messageSignester", " messageDigested", "MessageDigester", "MessageDigested", "messageHashested", "messageDester", "MessageSignenge", "messageHashester", " messageHashester", " messageDesignested", "messageDigester"]}}
{"id1": "19810820", "id2": "13516684", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyFilechannel", "transferfileStream", "copyDirectoryChannel", "copyDirectoryChan", "copyDirectorychannel", "copyStreamChan", "copyfileStream", "transferFilechannel", "transferFileChan", "copyDirectoryStream", "copyfileChan", "transferFileStream", "transferFileChannel", "transferfilechannel", "transferfileChan", "copyStreamChannel", "copyfileChannel", "copyFileChan", "copyStreamStream", "copyStreamchannel", "copyFileStream", "transferfileChannel", "copyfilechannel"], "src": ["path", "rest", "sel", "sin", "ssl", "sc", "server", "input", "sys", "rc", "Source", "lower", "slice", "filename", "sub", "dest", "loc", "s", "inst", "func", "rs", "SOURCE", "sync", "client", "sit", "source", "rb", "sb", "dist", "upload", "config", "ruby", "tmp", "sq", "conn", "ls", "sth", "start", "RC", "sup", "sl", "ctx", "url", "ses", "scene", "stream", "b", "st", "cur", "download", "img"], "dst": ["tst", "drc", " dST", "dart", "adrc", "adST", "ddest", "Ddest", "DST", "adput", "stlt", "bart", "bst", "dST", "Dost", "fdst", "dost", " ddest", "bput", "tart", "fdrc", "ldost", "lddest", "ldST", "dput", "bST", "start", "ldst", "fdput", "Dst", "stst", "stST", "blt", "adst", "dlt", " dost", "fdST", "tlt", "brc", "tST"], "preserveModificationTime": ["preserveModifiedFile", "preserveModifyingTime", "preserveModifytime", "preserveModifyTime", "preserveMinificationFile", "preserveMinificationTime", "preserveModationFile", "preserveModifiedtime", "preserveModifiedTime", "preserveModifyingFile", "preserveMinifiedtime", "preserveMinificationtime", "preserveModificationFile", "preserveMinifiedTime", "preserveMinifiedFile", "preserveModificationtime", "preserveModationTime", "preserveModifyingtime", "preserveModationtime"], "inputChannel": ["errorChannel", "fileConnection", " inputConnection", "outputConnection", " inputBuffer", " inputchannel", "inputchannel", "inputSocket", "InputBuffer", "outputBuffer", "outputGate", "imagechannel", "imageGate", "InputQueue", "binaryGate", "binaryChan", "fileChannel", "outputSocket", " inputSocket", " inputConsole", "InputSocket", "outputQueue", " inputCode", "inputChan", " inputQueue", "fileChan", "inputConsole", "inputBuffer", "binarychannel", "inputConnection", " inputStream", "errorChan", "errorCache", "outputCache", "outputStream", "inputCache", "errorStream", "inputStream", "outputchannel", "InputChannel", "requestStream", "requestCode", "Inputchannel", "fileConsole", "binaryChannel", "outputConsole", " inputChan", " inputCache", "outputChan", "InputChan", "inputGate", "inputQueue", "outputCode", "requestChan", "imageChan", "requestChannel", "imageChannel", "inputCode"], "outputChannel": ["Outputchannel", " outputchannel", "outputManager", "OutputQueue", " outputQueue", "OutputChannel", " outputManager", " outputButton", "outputQueue", "inputChan", "outStream", "outchannel", "outChan", "OutputStream", "writeQueue", " outputStream", "writeChannel", "outputStream", "outputchannel", "inputStream", " outputChan", "outputButton", "outButton", "writeStream", "writeManager", "outputChan", "OutputChan", "writeChan", "outChannel", "inputButton", "inputManager"], "length": ["base", "max", "sum", "buffer", "head", "duration", "id", "lock", "sequence", "slave", "current", "end", "result", "volume", "limit", "l", "join", "php", "child", "number", "last", "offset", "next", "form", "part", "session", "type", "load", "delay", "value", "len", "Length", "build", "section", "text", "size", "style", "complete", "start", "available", "full", "pull", "position", "partial", "with", "count", "block", "width"], "total": ["base", "max", "sum", "i", "translation", "duration", "id", "info", "current", "result", "limit", "set", "all", "otal", "done", "failed", "key", "last", "offset", "part", "less", "type", "no", "Total", "len", "used", "size", "complete", "start", "available", "toc", "full", "always", "partial", "count", "found", "multi", "scale", "error", "cur", "valid"]}}
{"id1": "15409512", "id2": "3187685", "code1": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"inFileName": ["sourceFileName", "inSourceFileName", "sourcefileLocation", "inFileLength", "inLineLength", "inStreamSystem", "incFilename", "inFileSystem", "inStreamLocation", "incFileLength", "inStreamname", "inFilenameLength", "infileName", "sourcefilePath", "inStreamPath", "outFileSystem", "infileLocation", "inLinename", "incFilenameLocation", "incFileLocation", "inSourceFilePath", "inLineLocation", "outFilePath", "sourceFilePath", "incFileName", "inFilenameName", "inFilePath", "sourcefileName", "inFILEPath", "incFilenameLength", "sourceFileLocation", "sourceFilename", "inFilenamename", "outStreamSystem", "inLineName", "inStreamIn", "inFilenamePath", "inFILESystem", "outStreamName", "infileLength", "inSourceFilename", "incFilenamename", "inSourceFileLocation", "inFileIn", "incFilenameName", "inFILEIn", "outFileIn", "outStreamPath", "inStreamName", "inFilenameIn", "outStreamIn", "infilePath", "inFilename", "inFilenameLocation", "infilename", "inFILEName", "inFileLocation", "sourcefilename", "inFilenameSystem"], "outFileName": ["OutFileLine", "outPackageName", "outFILEUrl", "inDirNum", "outFILELocation", "outSourceFileLine", "outPackageNum", "inFileNum", "inDirPath", "outSourceFileLocation", "inDirLine", "OutFileName", "outFilenameLine", "outSourceFileAddress", "OutFilenameName", "OutFilenameUrl", "outFilenameAddress", "outSourceFileUrl", "outputSourceFileName", "OutFileUrl", "outDirNum", "outFileLine", "outFilenameNum", "inFileLine", "outDirName", "outFilePath", "outFilenameName", "outStringName", "outFilenamePath", "outputFileName", "inFilePath", "outFileLocation", "outputSourceFileAddress", "outFileUrl", "outFileNum", "outFileAddress", "outFilenameLocation", "OutFilenameLine", "outFILEName", "outputSourceFileLocation", "outStringLine", "outFilenameUrl", "outDirLine", "outDirPath", "inDirName", "outStringUrl", "outFILEAddress", "outputFileLocation", "outputFileUrl", "outSourceFileName", "outputFileAddress", "outPackagePath", "outputSourceFileUrl", "outPackageLine"], "position": ["index", "order", "address", "release", "job", "i", "buffer", "duration", "id", "Position", "lock", "pose", "move", "option", "version", "sequence", "clock", "maximum", "number", "limit", "character", "location", "length", "patch", "layout", "sort", "slice", "time", "condition", "offset", "expression", "part", "type", "session", "use", "operation", "connection", "ion", "before", "page", "object", "size", "motion", "name", "image", "port", "pos", "pointer", "url", "unit", "shape", "left", "portion", "state", "display", "point", "loc"], "bis": ["uds", "lis", "bus", "fits", "be", "tis", "cb", "bones", "obb", "bs", "abs", "ois", "obos", "is", "uno", "cus", "bes", "binary", "sb", "ros", "bps", "ais", "oris", "buff", "bian", "BBC", "ubis", "bas", "ob", "nis", "onis", "fb", "phis", "bb", "bi", "idis", "opus", "ris", "obs", "ls", "lins", "isin", "iris", "ios", "ses", "pins", "abi", "los", "zo", "os", "bits", "rots", "kos", "vas", "boot", "cos"], "bos": ["uds", "mos", "bh", "bies", "antis", "zos", "dos", "bones", "outs", "obb", "bs", "bo", "ois", "obos", "bin", "oos", "obo", "obi", "bes", "so", "ros", "ops", "ubis", "bas", "ob", "bott", "ubs", "ods", "oids", "phis", "bi", "osi", "opus", "obs", "banks", "lins", "ios", "oS", "ses", "osa", "los", "zo", "os", "bits", "kos", "asio"], "b": ["buffer", "base", "i", "bf", "emb", "bd", "lb", "c", "cb", "o", "l", "orb", "bin", "mb", "reb", "rb", "ab", "d", "binary", "sb", "buff", "r", "machine", "ob", "g", "fb", "object", "bb", "p", "null", "e", "m", "bit", "nb", "db", "bytes", "a", "B", "k", "v", "br", "bl", "f"]}}
{"id1": "19549489", "id2": "21125261", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" copying", "delete", "paste", "transfer", "zip", "io", "Copy", " copied", "Transfer", "write", "upload", "Cop", "all", "cop", "sync", "p", " transfer", " copies", "source", "move", "file", "download", "create", " move", "split", " Copy", "clone"], "sourceFile": ["sourceFiles", "resourceFile", "searchFilename", "resourcefile", " sourceFiles", " sourceFILE", "resourceDirectory", "servicefile", "sourceFILE", "resourceFiles", "sourceFilename", " sourceDirectory", "SourceDirectory", " sourcefile", "siteFiles", "SourceFile", "searchfile", "sourcefile", "siteDirectory", "serviceFiles", "serviceFilename", "SourceFILE", "sourceDirectory", "serviceFile", " sourceFilename", "Sourcefile", "searchFiles", "siteFILE", "siteFile", "SourceFiles", "searchFile"], "destinationFile": ["destinatorImage", "destinationImage", "destinatedImage", "destinatedFiles", "destinatorDir", "DestinationDir", "destinationFiles", "DestinationFiles", "destinatedFile", "distinatedFiles", "DestinationFile", "distinationImage", "destationFiles", "destationfile", "destinatorFile", "distinatedFile", "distinatedDirectory", "distinationDirectory", "destinationDir", "destinatedDir", "destationDir", "destinatorFiles", "destationImage", "DestinatorDir", "distinatedImage", "destinatedfile", "destationDirectory", "destationFile", "distinationFiles", "destinatedDirectory", "destinatorDirectory", "destinationfile", "DestinatorFiles", "distinationFile", "destinationDirectory", "DestinatorFile", "destinatorfile", "Destinatorfile", "Destinationfile"], "sourceFileChannel": ["sourceFilesChannel", "sourceLibraryChan", " sourceFilesService", "targetFileChan", "sourceDirchannel", "sourceLineSocket", "sourceDirChan", "targetLibrarySocket", "sourceFileSocket", "sourceFileContext", "sourceFileClient", "ourceStreamChannel", "sourceStreamContext", "sourceFunctionConnection", " sourceFilesConnection", "targetLibraryChan", " sourceFileContext", "sourceDirectorySocket", "sourceFunctionService", " sourceFileService", "targetFileClient", "sourceFileConnection", "sourceDirectoryChan", "sourceLibraryChannel", "sourceStreamConnection", " sourceFilesChannel", "sourceLinechannel", "sourceLibraryClient", "sourceFilesContext", "sourceFileStream", "targetLibraryChannel", "sourceStreamStream", "sourceFunctionChannel", "ourceStreamStream", "ourceFileChannel", "sourceLineChannel", "sourceStreamService", "targetFileSocket", "ourceFileChan", "sourceFilesService", "sourceFileChan", "sourceStreamchannel", "sourceStreamChan", "sourceFilesConnection", "targetLibraryClient", "sourceDirectoryClient", "targetFileChannel", "sourceDirStream", "ourceFilechannel", " sourceFilesContext", "sourceLineClient", "ourceStreamChan", "sourceLineChan", "sourceStreamChannel", "sourceLineStream", "sourceFunctionContext", "sourceFilechannel", "sourceDirChannel", "sourceDirectoryChannel", "ourceStreamchannel", "sourceFileService", " sourceFileConnection", "sourceLibrarySocket", "ourceFileStream"], "destinationFileChannel": ["destinationFilesConnection", "destinatorFileConnection", "destinationFilesChannel", "destinationLineHandler", "destinationIOCache", "destinationFilesHandler", "destinationFileService", "destinationDirectoryChannel", "destinationLineChan", "destinationLineClient", "destinationDirectoryClient", "destinationIOClient", "destinationFilesService", "destinatorFileCache", "destinationDirectoryChan", "destinatorFileHandler", "destinatorFilesHandler", "destinationDirectoryConnection", "destinationFilesChan", "destinatorFilesChan", "destinationFileClient", "destinationLineConnection", "destinationIOChannel", "destinationFilesCache", "destinatorFileChan", "destinationDirectoryHandler", "destinationLineChannel", "destinationDirectoryService", "destinatorFileClient", "destinatorFilesConnection", "destinationIOService", "destinatorFilesService", "destinationLineService", "destinationFileConnection", "destinatorFileService", "destinatorFilesChannel", "destinationFileChan", "destinationFileCache", "destinatorFileChannel", "destinationFileHandler", "destinatorFilesCache", "destinationFilesClient", "destinationDirectoryCache", "destinatorFilesClient"]}}
{"id1": "6890417", "id2": "20190303", "code1": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"a1": ["ga1", "an3", "a01", "alpha01", " a01", "an1", "alpha2", "ga0", "alpha1", "A01", "A3", "alpha0", "an01", "A2", "a0", "an2", "ga01", "ga2", "A1", " a0"], "a2": ["p4", "p1", "A4", "n5", "n4", "p5", "A2", "A8", "p2", "A1", "n2", "A5", "n8"], "a3": ["la33", "alpha5", "an3", " a23", "ga5", "alpha3", "la23", "ga9", "alpha9", "alpha2", "ga3", "a33", "la3", " a33", "an23", "a23", "ga2", "an33"], "a4": ["as5", "A9", "ma8", "A4", "pa8", "ma10", "pa4", "pa10", "ga4", "A2", "ma4", "as4", "as2", "ga10", "ga8", "A5", "as9"], "a5": ["n6", "alpha5", " a7", "a6", "p7", "alpha4", "A4", " a6", "alpha6", "n5", "n7", "a7", "p5", "alpha8", "p6", "A8", "p2", "n2", "A6", "A5"], "a8": [" a7", "a6", "alpha11", "A11", "A6", "alpha4", "A4", "alpha6", " a6", "an7", "b7", "an10", "b8", "a7", "an8", "alpha8", "an6", "b11", "A8", "b10", "b6", "b4"], "a9": ["A9", "alpha7", " a7", "p7", "alpha11", "A11", "alpha9", "alpha10", "alpha09", "a7", "p09", "p10", "alpha8", "A8", "p9", " a09", "A7", "a09"], "a10": ["as8", "a12", "A9", "as09", "A10", "alpha9", "A09", "alpha10", "an10", " a12", "alpha12", "as10", "b09", "b8", "b9", "an8", "an12", "alpha8", "A8", "b10", "an9", "a09", "as9"], "a11": ["a12", "A18", "am10", " a7", "A10", "a18", "alpha11", "A11", "alpha18", " a13", "am7", " a12", "alpha12", "a7", "A13", "alpha8", "am11", "A8", " a18", "A7", "A12", "am13", "a13"], "ps": ["ppa", "os", "ups", "details", "ils", "p", "PS", "points", "ipes", "pp", "qs", "pos", "pa", "files", "is", "cs", "s", "proxy", "rs", "ls", "pes", "ns", "ips", "ases", "pres", "es", "py", "properties", "lines", "per", "gets", "ks", "ams", "cases", "pers", "params", "aps", "ras", "posts", "ples", "ons", "ds", "changes", "ts", "pi", "pass", "alls", "pe", "jp", "hes", "eps", "ins", "ops", "vs", "Ps", "settings", "res", "als", "ss", "pse", "as", "js", "ports", "pps", "gs", "parts", "ms", "rules", "ws", "tests", "pr"], "url": ["image", "client", "buffer", "service", "sl", "object", "proxy", "fl", "user", "bug", "ls", "page", "server", "address", "connection", "http", "URL", "response", "ssl", "file", "build", "cloud", "f", "Url", "base", "download", "control", "contact", "log", "gl", "ll", "document", "l", "browser", "string", "web", "twitter", "uri", "config", "www"], "request": ["next", "r", "client", "buffer", "connect", "rate", "p", "access", "upload", "hello", "worker", "reply", "transfer", "use", "user", "server", "complete", "per", "open", "child", "info", "result", "connection", "http", "response", "resource", "report", "pull", "post", "req", "this", "rest", "session", "builder", "temp", "pe", "method", "call", "Request", "external", "remote", "respond", "web", "push", "re", "create"]}}
{"id1": "2022160", "id2": "4593012", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"write": ["writer", "play", "flow", "cycle", "append", "call", "copy", "wrote", "lex", "data", "store", "writing", "sync", "written", "writ", "output", "connect", "set", "run", "read", "end", "Write", "out", "code", "process", "flush", "create", "add", "size", "dump", "send", "pipe", "exec", "kill", "service", "w", "next", "put", "update", "close", "feed", "export", "open"], "byteBuffers": ["byteChers", "bytesAkers", " byteOrdeners", "byteAkors", "ByteBufflers", "bytesDefatters", "byteChered", " byteBuffinals", "bytesAkelines", "bytesPackERS", " byteBuffiners", "byteOrdeners", "bytebuffings", "byteIntegeners", "byteDefatters", " byteOrdinals", "byteBuilderers", "doubleHeadings", "byteBuffatters", " byteBufferers", "byteBuffinals", "byteInteginals", "byteCornlers", "connectionBuffers", "byteChERS", "doubleBuffered", "bytebuffeners", "connectionBuffERS", "bytebuffered", "byteOffers", "byteHeadERS", "doubleHeadered", "ByteBufferers", "byteBuffERS", "byteAkers", "bytesCornered", "byteIntegERS", "byteWriters", " byteOrderers", " byteOrdlers", "doubleBuffERS", "bytebuffinals", "byteOffors", "wordBuffatters", "bytesDefelines", "wordBuffers", "bytesCornests", "byteCornares", "byteIntegers", "byteDefers", "byteWriterers", "doubleHeaders", "bytebuffelines", "byteBufferatters", "byteWritelines", "byteIntegatters", "bytebufferers", "bytebuffers", "byteWritiners", "doubleBuffings", "byteBuffters", "byteHeadered", "byteBuffererers", "bytesDefers", "connectionbuffERS", "bytesBufferers", " byteOffters", "bytesCornatters", "bytePackapers", "ByteOrderers", " byteBuffors", "byteHeaders", "byteBufferERS", " byteOffors", "bytesBuffizers", "byteWritizers", "byteBuffors", "ByteBuffresses", "ByteOrdERS", "byteBuffresses", " byteBufflers", "byteChings", "byteBuffeners", "bytebuffERS", "connectionbuffers", "wordBuffERS", " byteCompERS", "bytePackerers", " byteBuffares", "byteOrdapers", "byteCompares", "bytesBuffatters", "bytesBuffests", "byteOrders", "ByteOrders", " byteCompers", " byteOrdERS", "byteComplers", "bytesBuffERS", "byteBufferers", "doubleHeadERS", "bytesAkizers", "byteOffters", "byteInfers", "byteCornatters", "bytebuffatters", "byteOrderers", "byteDefelines", "byteCompers", "wordBufferers", "byteBuffings", "bytePackERS", "byteCornERS", "byteBuffapers", "byteCornests", "byteDefERS", "byteInferers", "bytesBuffapers", "byteOrdERS", " byteBuffERS", "bytebufflers", "byteBufferapers", "bytebuffors", " byteBuffters", "byteAkizers", "bytesCorners", "byteBuildERS", "byteHeadings", "bytesPackapers", "ByteBuffERS", "byteBuffered", "byteCorners", "doubleBuffers", " byteCompares", "bytesBuffors", "byteBufflers", "bytebuffizers", " byteComplers", "byteBufferelines", "byteBuffares", "byteBuffiners", " byteOffERS", "bytebuffests", "byteOffERS", "byteOrdlers", "byteCompERS", "byteWritors", "bytesDefERS", "byteAkelines", "byteCornered", "ByteOrdresses", "bytesBuffered", "byteWritlers", " byteOrders", " byteOrdiners", "byteOrdiners", "byteInfatters", " byteOffers", "byteBuffizers", "byteBuildatters", "connectionbufferers", "connectionBufferers", "byteBuffests", " byteBuffeners", "ByteBuffers", "bytebuffters", "bytebuffresses", "byteBuilders", "bytesPackerers", "byteOrdresses", "byteOrdinals", "bytePackers", "byteInfERS", "byteBuffereners", "bytesBuffers", "connectionBuffeners", "bytesAkors", "bytesBuffelines", "byteBuffelines", "byteBufferlers", "bytebuffiners", "byteIntegelines", "connectionbuffeners", "bytesPackers"], "m_initialOutBuffer": ["m_initialInFile", "m_initialInLine", "m_finalOutLine", "m_initialAuthBuffer", "m_InitialOutFile", "m_initialoutCache", "m_initialoutChannel", "m_initialOutChannel", "m_initialClientBuffer", "m_finalOutMessage", "m_initialOutputHeader", "m_initialInBuffer", "m_finalOutCache", "m_InitialOutputBuffer", "m_finalOutFile", "m_initialoutAddress", "m_initialShortFile", "m_originaloutBuffer", "m_initialOutHeader", "m_initialoutBuff", "m_initialOutputLayer", "m_initialOutBuff", "m_initialNewFile", "m_InitialOutLayer", "m_finaloutBuffer", "m_finalOutBuff", "m_initialSocketLayer", "m_initialOutputFile", "m_finalInLine", "m_initialNewMessage", "m_finaloutFile", "m_initialOutMessage", "m_initialOutputBuffer", "m_originalOutBuffer", "m_finalOutBuffer", "m_initialOutLayer", "m_initialoutFile", "m_initialAuthFile", "m_initialShortCache", "m_initialInLayer", "m_initialSocketFile", "m_finaloutBuff", "m_initialNewBuffer", "m_originaloutLine", "m_initialSocketBuffer", "m_originaloutFile", "m_originalOutAddress", "m_InitialOutputFile", "m_initialInCache", "m_finalInFile", "m_originaloutAddress", "m_finalOutChannel", "m_initialClientBuff", "m_initialInChannel", "m_initialOutCache", "m_initialOutLine", "m_initialAuthLine", "m_InitialOutputHeader", "m_initialOutAddress", "m_InitialOutHeader", "m_finalInMessage", "m_initialOutputBuff", "m_initialoutBuffer", "m_initialInMessage", "m_initialNewBuff", "m_originalOutLine", "m_finalInChannel", "m_initialClientFile", "m_initialClientLine", "m_initialOutFile", "m_finalInBuff", "m_initialShortChannel", "m_initialOutputChannel", "m_initialoutLine", "m_initialInAddress", "m_InitialOutBuffer", "m_initialAuthAddress", "m_finalInBuffer", "m_initialOutputMessage", "m_initialInBuff", "m_InitialOutputLayer", "m_initialSocketHeader", "m_initialShortBuffer", "m_originalOutFile", "m_initialInHeader", "m_finalInCache", "m_finaloutChannel"], "buffer": ["console", "writer", "null", "view", "data", "bc", "phrase", "row", "temp", "queue", "cache", "string", "file", "uffer", "wave", "page", "resource", "message", "server", "event", "cell", "back", "shell", "port", "limit", "input", "template", "read", "timeout", "builder", "iter", "config", "er", "worker", "object", "loader", "layer", "feed", "url", "fb", "channel", "batch", "cur", "flush", "comment", "holder", "re", "binary", "transfer", "FFER", "block", "buf", "array", "copy", "engine", "Buffer", "ker", "output", "document", "f", "stack", "source", "reader", "header", "client", "buff", "base", "table", "slice", "address", "window", "pool", "response", "bridge", "callback"], "buffers": ["bufered", "buffERS", "ufors", "affaches", "buffered", "bufering", "buffler", "transformers", "bufresses", " buffators", "phages", "Bufferers", "buferers", "transformERS", "buffators", "Buffars", "transformler", "bufler", "buffages", " buffler", "buffaches", "affering", "phators", " buffering", "buffering", "Buffers", " buffERS", "phers", "Buffered", "bufages", " buffered", "phresses", "transformering", "affers", " buffresses", "ufering", "ufaches", "bufERS", "buffresses", " buffages", "ufers", "bufaches", " bufferers", " buffars", "bufers", "bufars", "bufors", "bufators", "bufferers", "buffars", "buffors", "affors"], "result": ["res", "url", "default", "resource", "report", "message", "complete", "view", "rc", "rate", "event", "info", "data", "successful", "session", "winner", "search", "output", "status", "f", "acc", "valid", "error", "date", "val", "out", "test", "row", "ver", "results", "comment", "future", "driver", "consumer", "true", "flash", "er", "Result", "inner", "user", "r", "cache", "match", "err", "card", "success", "re", "sr", "up", "grade", "diff", "ret", "json", "response", "runner", "function", "or", "cup", "manager", "use", "request"], "encrypted": ["available", "text", "pad", "padding", "image", "body", "channel", "selected", "entry", " data", "temp", "flush", "source", "config", "reader", "flash", "stream", "inner", "internal", "packed", "cache", "loader", "extra", "interrupted", "binary", "layer", "transfer", "secret"]}}
{"id1": "12066447", "id2": "16825994", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"truncate": ["trrenate", "trunational", "trrenator", "truncator", "trunator", "autuncator", "truncation", "autuncational", "autatenation", "autuncation", "trrenation", "truncational", "autatenational", "autuncate", "tratenate", "trrenational", "tratenational", "tratenator", "autatenator", "trunate", "tratenation", "trunation", "autatenate"], "file": ["source", "local", "filename", "File", "fp", "cache", "out", "uri", "current", "path", "f", "info", "this", "model", "page", "ile", "plus", "archive", "e", "one", "per", "l", "image", "single", "line", "or", "get", "data", "folder", "object", "resource", "format", "binary", "FILE", "directory", "io", "class", "url", "base", "log", "name", "document", "it", "files", "function", "zip", "address", "body", "time", "string", "connection", "future", "handler", "stream", "queue", "full", "type", "parent", " File", "db", "http"], "backupRoot": ["BackupPath", "backupsDirectory", "backbaseRoot", "backbackDirectory", "backupDir", "backbasePath", "frontupDir", "backupHome", "frontdownroot", "backbackRoot", "backflowDir", "backdownDirectory", "backdownFolder", "backupDirectory", "backureHome", "BackbackFile", "backUpDir", "frontdownDir", "backUpFolder", "backdownHome", "backupsroot", "BackureDirectory", "backupPath", "BackdownRoot", "backupFile", "backUproot", "BackdownDirectory", "backbackDir", "backdownRoot", "backUpRoot", "frontupFolder", "BackupDirectory", "backureDirectory", "backbackHome", "backdownroot", "backbaseroot", "backupsPath", "BackbackDir", "BackdownPath", "backbackFile", "backflowFile", "backflowRoot", "frontdownRoot", "backflowroot", "BackupHome", "BackupDir", "backupFolder", "frontupRoot", "backdownFile", "backureDir", "Backuproot", "backupsFolder", "backupsDir", "frontdownFolder", "backbaseDirectory", "BackureDir", "BackbackRoot", "backuproot", "BackupFile", "backupsRoot", "backdownDir", "backdownPath", "Backbackroot", "backureRoot", "frontuproot", "Backdownroot", "BackureHome", "BackureRoot", "backbackroot", "BackupRoot"], "df": ["flow", "DF", "md", "fp", "dict", "cf", "f", "fb", "CF", "dm", "de", "ds", "func", "data", "da", " def", "format", "dl", "bf", "pdf", "af", "io", "deb", "fd", "dt", "fs", "fe", "pd", "fn", "fr", "di", "dd", "tf", "dp", "fc", "def", "dn", "sf", "xf", "dq", "db", "d", "raf", "dc"], "date": ["work", "x", "pre", "created", "form", "message", "create", "style", "ate", "days", "re", "output", "str", "out", "fee", "sync", "day", "update", "back", "use", "ale", "input", "dates", "complete", "atom", "data", "m", "updated", "year", "module", "format", "open", "age", "valid", "url", "name", "log", "stage", "pe", "modified", "dt", "code", "ge", "dat", "time", "min", "j", "string", "tag", "dose", "rule", "Date", "D", "value", " Date", "version", "bug", "custom", "diff", "type", "db", "d"], "zipFile": ["sqlModel", "ZipFile", "zipfile", "ressFile", "Zipfile", "ressfile", "zipFiles", "zipSection", "zFiles", "ressModel", " zipFiles", "zipModel", " zipfile", "zFile", "ZipFiles", "zfile", "zModel", "zSection", "ZipEntry", "ressSection", "zipEntry", "sqlFile", "sqlfile", "sqlSection", " zipEntry", "zEntry"], "zos": ["ls", "closure", "dos", "hess", "bos", "z", "chini", "obb", "iffs", "zer", "zl", "gz", "zik", "tz", "robe", "han", "zona", "nz", "cash", "zy", "zb", "proxy", "zzy", "bitcoin", "eros", "ros", "zero", "ses", " sands", "os", "cos", "los", "ZA", "inos", "dylib", "zip", "fits", "zo", "address", "webkit", "uz", "zag", "budget", "zes", "zh", "zn", "exit", "las", "liquid", "rez", "outs", "settings", "zen", "kos", "lins", "ils", "css", "ozo", "zan", "ssl", "asio", "her", "osi", "zi", "zx", "jas", "nox", "js", "forge", "zon", "zar", "bes", "ops"], "fis": ["lids", "rafris", "fliss", "infias", "flids", "fiz", "infiss", "Fiss", "fiss", "lias", "rafis", "rafias", "flias", "flis", " fits", "flris", "vils", "bos", " fiss", "rafiss", " fiz", " fos", "biss", "bisl", "fris", "fisl", "fias", "infits", "Fos", "Fias", "lis", "liss", "Fis", "infis", " fils", "vits", "Fris", "fits", "fils", "vis", "Fisl", "Fisp", " fias", " fisp", "fisp", "infiz", "infils", "fos", " fisl", "flisp", "fids", "bis", "infids", " fris", "viz"], "entry": [" Entry", "style", "the", "uri", "se", "ace", "so", "z", "ry", "cell", "ion", "Entry", "info", "archive", "event", "extra", "e", "ie", "per", "de", "card", "image", "cel", "or", "data", "record", "array", "comment", "and", "next", "si", "ries", "lc", "add", "it", "server", "obj", "ui", "zip", "ge", "address", "term", "letter", "index", "zo", "exp", "element", "auto", "row", "r", "feed", "key", "her", "reader", "offset"], "buffer": ["vector", "sequence", "position", "shape", "cache", "result", "length", "available", "memory", "pad", "buff", "bb", "buf", "page", "seed", "bytes", "uffer", "padding", "border", "FFER", "data", "writer", "binary", "comment", "b", "device", "null", "server", "transfer", "number", "address", "Buffer", "beta", "header", "channel", "queue", "layer", "batch", "reference", "iter", "row", "wave", "feed", "slice", "reader", "flush"], "readed": ["inputED", " ReadED", "inputled", "inted", "intED", "textized", "readled", "textED", "readended", " readable", "readned", " Readed", " Readered", "readable", "bootered", "inputned", " readered", " readED", "bootable", "textended", "inputed", " readended", "texted", " Readned", " Readable", "intended", " readized", "readED", " Readled", " readled", "readered", "readized", "bootED", " readned", "booted", "intized"]}}
{"id1": "10131427", "id2": "16590954", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "copyChannel", "CopyFiles", "copyfile", "transferFiles", "copyFiles", "CopyChannel", " copyChannel", "CopyFile", "transferChannel", "transferfile"], "in": ["resource", "In", "or", "again", "at", "ini", "c", "IN", "m", "ex", "inner", "bin", "input", "copy", "io", "ins", "ac", "min", "inn", "base", "url", "work", "config", "index", "i", "image", "a", "login", "reader", "diff", "data", "b", "inc", "id", "source", "buffer", "name", "file"], "out": ["temp", "external", "at", "n", "c", "string", "cache", "o", "ex", "Out", "copy", "io", "outs", "dest", "conn", "object", "p", "part", "w", "base", "connection", "prefix", "exec", "x", "off", "image", "writer", "v", "output", "data", "OUT", "point", "target", "source", "buffer", "client", "name", "file"], "sourceChannel": [" sourceSocket", "srcChan", "SourceStream", "srcConnection", "Sourcechannel", "ourceChan", "targetChan", "srcSocket", "SourceManager", " sourcechannel", "ourceStream", "ourcechannel", "srcQueue", " sourceQueue", "sourceConnection", " sourceConnection", "SourceChan", "srcStream", "srcManager", " sourceChan", "sourcechannel", "SourceChannel", "SourceConnection", "sourceSocket", "SourceSocket", "sourceQueue", "sourceManager", "ourceChannel", "targetchannel", "SourceQueue", "sourceStream", "targetChannel", "srcChannel", " sourceStream", " sourceManager", "sourceChan", "targetStream"], "destinationChannel": ["destinatedChan", "DestinatorConnection", "destationChan", "DestinatorCh", "destinatorchannel", "destinationsStream", "destinatorStream", "Destinatorchannel", "DestinationConnection", "DestinationChannel", "destinationchannel", "DestinationCh", "destinationCh", "destinateChannel", "DestinationStream", "destinationsConnection", "destinatedCh", "destinationStream", "destinateConnection", "DestinationChan", "destinationChan", "destinatorChan", "Destinationchannel", "destinationsChannel", "destinatorChannel", "DestinatorChannel", "destationCh", "destationchannel", "destinatedConnection", "destinateStream", "destationConnection", "DestinatorStream", "destinationschannel", "destinatorCh", "destinatedChannel", "destationChannel", "destinatorConnection", "destinatechannel", "destinationConnection", "DestinatorChan"]}}
{"id1": "5760649", "id2": "400275", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createFile": [" createResource", "CreateContent", "CreateFolder", " createFolder", "CreateFile", "createContent", " createContent", "createResource", "createFolder", "saveContent", "CreateResource", "saveFile", "saveFolder", "saveResource"], "src": ["resources", "resource", "stream", "Source", "content", "input", "load", "slice", "href", "ruby", "cb", "url", "string", "txt", "buf", "gb", "files", "r", "rc", "path", "rob", "sc", "upload", "uri", "sb", "proc", "SourceFile", "dest", "img", "fp", "sit", "secure", "name", "ssl", "sel", "data", "file", "fn", "username", "rss", "sl", "rb", "loc", "source", "obj", "s"], "filename": ["wb", "resource", "prefix", "dll", "metadata", "acl", "which", "feat", "output", "l", "utf", "string", "txt", "ame", "files", "ames", "route", "path", "fil", "Filename", "source", "uri", "SourceFile", "fp", "ename", "FILE", "length", "loader", "name", "title", "nil", "file", "fn", "sf", "username", "s", "rl", "location", "f", "url", "directory"], "fis": ["sfos", "Fais", " fIS", "cfais", "cfris", " fbs", "cfis", "cfIS", "fais", "sfiss", " fiss", "Fbs", "Fos", "Fis", " fais", "cfos", "fris", "fIS", "Fiss", "sfris", "fiss", "sfis", "fbs", "FIS", "Fris", "cfbs", " fris"], "fos": ["fios", "sfios", "sfos", " fops", "fOS", "affis", "Fas", "Fbos", "bos", "Fios", " fios", "foras", "FOS", "bbos", "fbos", "foros", " fas", "Fos", "Fis", "affios", "bis", "sfis", "fops", "Fops", "affbos", "foris", "affos", "sfops", " fOS", "fas", "bios", "forOS"]}}
{"id1": "7103223", "id2": "17286898", "code1": "    public void testPost() throws Exception {\n        HttpPost request = new HttpPost(baseUri + \"/echo\");\n        request.setEntity(new StringEntity(\"test\"));\n        HttpResponse response = client.execute(request);\n        assertEquals(200, response.getStatusLine().getStatusCode());\n        assertEquals(\"test\", TestUtil.getResponseAsString(response));\n    }\n", "code2": "                public void run() {\n                    BufferedReader reader = null;\n                    String message = null;\n                    int messageStyle = SWT.ICON_WARNING;\n                    try {\n                        URL url = new URL(Version.LATEST_VERSION_URL);\n                        URLConnection conn = url.openConnection();\n                        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                        String latestVersion = reader.readLine();\n                        latestVersion = latestVersion.substring(latestVersion.indexOf(' ') + 1);\n                        if (!Version.getVersion().equals(latestVersion)) {\n                            message = Labels.getLabel(\"text.version.old\");\n                            message = message.replaceFirst(\"%LATEST\", latestVersion);\n                            message = message.replaceFirst(\"%VERSION\", Version.getVersion());\n                            messageStyle = SWT.ICON_QUESTION | SWT.YES | SWT.NO;\n                        } else {\n                            message = Labels.getLabel(\"text.version.latest\");\n                            messageStyle = SWT.ICON_INFORMATION;\n                        }\n                    } catch (Exception e) {\n                        message = Labels.getLabel(\"exception.UserErrorException.version.latestFailed\");\n                        Logger.getLogger(getClass().getName()).log(Level.WARNING, message, e);\n                    } finally {\n                        try {\n                            if (reader != null) reader.close();\n                        } catch (IOException e) {\n                        }\n                        final String messageToShow = message;\n                        final int messageStyleToShow = messageStyle;\n                        Display.getDefault().asyncExec(new Runnable() {\n\n                            public void run() {\n                                statusBar.setStatusText(null);\n                                MessageBox messageBox = new MessageBox(statusBar.getShell(), messageStyleToShow);\n                                messageBox.setText(Version.getFullName());\n                                messageBox.setMessage(messageToShow);\n                                if (messageBox.open() == SWT.YES) {\n                                    BrowserLauncher.openURL(Version.DOWNLOAD_URL);\n                                }\n                            }\n                        });\n                    }\n                }\n", "label": 0, "substitutes": {"testPost": ["testingPost", " testPOST", "testingTest", "Testpost", "testPOST", "TestPost", " testTest", "TestPOST", "TestTest", "testingPOST", "testingpost", "testpost", "testTest", " testpost"], "request": ["next", "get", "client", "buffer", "rate", "query", "upload", "worker", "i", "q", "transfer", "delete", "use", "object", "user", "instance", "reference", "e", "copy", "server", "complete", "address", "open", "child", "result", "http", "resource", "message", "report", "submit", "xml", "send", "build", "post", "url", "req", "throw", "api", "rest", "session", "data", "update", "test", "remove", "application", "method", "call", "document", "Request", "string", "push", "QUEST", "add", "create", "claim", "condition"], "response": ["next", "image", "error", "success", "client", "tree", "block", "full", "output", "reply", "object", "feed", "parent", "environment", "page", "server", "json", "result", "connection", "http", "report", "message", "resource", "index", "pool", "xml", "Response", "out", "resp", "f", "ception", "o", "api", "onse", "session", "data", "collection", "status", "application", "method", "document", "site", "body", "respond"]}}
{"id1": "18504192", "id2": "3958807", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "io", "inc", "old", "ini", "index", "input", "In", "name", "inner", "image", "c", "m", "or", "at", "i", "info", "b", "again", "parent", "diff", "buffer", "inn", "min", "copy", "data", "file", "d", "src", "ac", "part"], "out": ["exec", "external", "base", "OUT", "client", "outs", "cache", "w", "call", "output", "io", "inc", "target", "name", "conn", "obj", "string", "c", "err", "prefix", "Out", "writer", "connection", "b", "ex", "n", "object", "again", "o", "dest", "p", "copy", "point", "line", "data", "file", "password", "part", "temp"], "source": ["ource", "slave", "reader", "client", "project", "scope", "view", "use", "proxy", "sl", "input", "target", "start", "core", "secure", "stream", "Source", "settings", "self", "storage", "clone", "ssl", "ie", "i", "connection", "component", "writer", "null", "parent", "sin", "dest", "slice", "sync", "ources", "iter", "service", "get", "copy", "from", "channel", "se", "server", "src", "origin", "unit", "size", "SOURCE"], "destination": ["destinator", "testinations", "Destinated", "Destification", "Destining", " destining", "Destination", "testinated", "dependification", " destinations", "destinations", "declification", "declinated", " destinator", "declinator", "contining", "dependinated", "testination", " destinated", "declination", "dependination", "destinated", "testinator", "destining", "contination", "dependinator", "destification", "Destinations", "continated", "Destinator", "continator"]}}
{"id1": "21182766", "id2": "3024992", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 0, "substitutes": {"load": ["Load", "loading", "save", "call", "parse", "delete", "use", "proc", "check", "path", "include", "start", "set", "resources", "setup", "write", "build", "loads", "read", "construct", "info", "LOAD", "class", "find", "config", "install", "loader", "update", "pack", "resource", "loaded", "add", "get", "copy", "store", "process", "init", "download", "create", "dump"], "propsName": ["pepsName", "pepsname", "propsDesc", "comppertiesname", "pepsNames", "profsName", "profsPath", "profsname", "pepertiesNames", "propertiesPath", "proPSDesc", "comppsDesc", "pepertiesName", "comppertiesPath", "pepertiesPath", "propsNames", "comppertiesName", "proPSname", "pepsPath", "propertiesName", "comppsPath", "comppsName", "propertiesname", "comppertiesDesc", "propsPath", "proPSNames", "pepertiesname", "proPSName", "propertiesNames", "profsDesc", "profsNames", "comppsname", "propertiesDesc", "propsname", "proPSPath"], "props": ["probs", "compps", "protpr", "perps", "precs", "pets", "pebs", "peps", "pripos", "pecs", "protperties", "pribs", "prebs", "propps", "crops", "compds", "Procs", "Props", "prpr", "properties", "cropr", "prpps", "prots", "cropps", "Probs", "prids", "procs", "propos", "comppos", "compbs", "prperties", "preps", "prips", "perpos", "croperties", "protps", "prets", "propr", "perds", "Prots", "protpps", "prods", "perbs", "prps"], "url": ["cl", "base", "ob", "e", "id", "feed", "URL", "jar", "not", "path", "xml", "sl", "fl", "Url", "location", "name", "gl", "stream", "event", "ssl", "i", "r", "user", "b", "browser", "config", "loader", "buffer", "uri", "service", "resource", "api", "bel", "http", "l", "page", "source", "file", "server", "data", "channel", "ref", "src", "f"]}}
{"id1": "5551393", "id2": "8064604", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"getMD5": [" getM5", " getM4", "getmd4", "getmd512", " getM512", "getMD4", "getM256", " getMD256", " getM256", "getSHA4", "getSHA512", "getM512", "getmd5", "getMD256", "getSHA256", "getMD512", "getmd256", " getMD512", "getM5", "getSHA5", " getMD4", "getM4"], "source": ["text", "message", "style", "result", "buffer", "output", "length", "config", "info", "bytes", "seed", "input", "src", "ource", "SOURCE", "data", "Source", "service", "object", "resource", "proxy", "dest", "expected", "url", "name", "base", "sm", "security", "code", "address", "secure", "string", "size", "file", "temp", "template", "slice", "unit", "start", "target", "content"], "tmp": ["stuff", "result", "sb", "copy", "output", "cache", "fp", "mp", "current", "buffer", "py", "emp", "vt", "buf", "txt", "src", "var", "meta", "default", "data", "nm", "metadata", "binary", "Temp", "bf", "storage", "tt", "dest", "foo", "b", "array", "vm", "params", "code", "obj", "zip", "body", "rb", "cpp", "test", "html", "temp", "part", "ignore", "cb", "cmp"], "md": ["mand", "mmm", "mm", "mp", "mod", "amd", "wd", "cmd", "dm", "mb", "meta", "oda", "mg", "ind", "sd", "m", "nm", "ad", "mad", "mac", "bf", "editor", "rm", "ms", "vd", "nd", "zip", "pd", "gd", " MD", "mi", "od", "di", "dd", "mn", "mo", "cm", "mt", "hd", "ld", "cd", "MD", "mc", "ma", "mu", "mag", "pm", "d", "rpm", "bd"]}}
{"id1": "23672408", "id2": "4468255", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyIconFiles": [" copyIconFile", "copyFileImages", " copyiconImages", "copyiconFiles", "copyFileFile", "copyiconFile", "copyImageFile", "copyiconTypes", " copyiconFile", "copyFileFiles", "copyIconImages", " copyiconTypes", "copyFileTypes", "copyIconTypes", " copyiconFiles", " copyIconImages", "copyIconFile", "copyiconImages", "copyImageTypes", "copyImageImages", " copyIconTypes", "copyImageFiles"], "clazz": ["Claz", "Closs", " cluster", "cllass", "Clclass", "clab", "closed", "slod", "glazz", " clobe", "closer", "cluster", "clance", "slaz", "pllass", "hellazz", "Clab", " closed", "plclass", " cllass", "sllass", "flazz", "llasso", "flunk", " clclass", "clod", "sluster", " clab", "Cllass", "classo", "llazz", "hellasse", "Closer", " closer", "CLod", " classo", "closs", "Cluster", "glod", " closs", "slazz", "hellasso", "claz", "sloss", "glance", "llclass", "slance", "fluster", "glaz", " claz", "hellosed", " classe", "Clazz", "llasse", "ploser", "llab", "CLaz", "Clunk", "slosed", "helllass", "CLance", " clunk", "classe", "clunk", "CLazz", " clance", "hellance", "clobe", "llobe", "flaz", "hellobe", "plazz", "llaz", "clclass"], "i16": ["pi64", "ii16", "i64", "l64", "pi15", "si24", "int24", "io24", "si14", "ai16", "ii2016", "i14", "si64", "pi24", "i17", "ai2016", "I15", "int15", "io2016", "l24", "i15", "si2016", "l15", "pi16", "int2016", "ini15", "io15", "I17", "si15", "ini14", "ini2016", "ii17", "ini17", "io16", "ai15", "ini16", "l16", "ii15", "I16", "I14", "i24", "ii14", "si16", "i2016", "int16", "ii24", "ai14"], "fileType": ["fileLike", " filePatch", "playSpread", "iconType", "filePath", "singleType", "playFamily", "FileUnit", " fileAuth", "playType", "wordAuth", "wordType", " fileFamily", "feedInfo", "fileFamily", "imagePath", " fileState", "iconPath", "fileKey", "iconKey", "feedType", " fileStyle", "fileTime", "iconAuth", "feedtype", "messagePatch", "imageUnit", "wordLength", "messagetype", "fileBlock", "fileStyle", "singleStyle", "messagePath", "FileLocation", " fileLocation", " fileKey", " fileInfo", "fileFile", "feedPath", "messageType", " fileTy", "fileInfo", "imageTime", "iconLength", "transferTy", "fileTy", " fileBlock", "FileLike", " fileTime", " filePath", " fileLike", " fileUnit", "singleFile", "filetype", "documentState", "FileInfo", "transferType", "letterTy", "imageType", "fileSpread", " fileFile", "playTy", "FileFamily", "filePatch", "fileLength", "imageFamily", "imageFile", "feedPatch", "letterState", "documenttype", "letterSpread", "letterType", "wordTy", "letterFamily", "imageStyle", "lettertype", "transferFamily", "FileStyle", "fileState", "iconTy", "transferSpread", "documentType", "documentBlock", "imageKey", "feedLocation", " fileLength", "fileLocation", "feedLike", "singleTime", "letterBlock", "FileType", " filetype", "fileAuth", "fileUnit", "iconStyle"], "desti16": ["targeti2016", "destI15", "targeti16", "combini32", "desturi64", "targetI16", "desturi32", "destini16", "destf15", "combini15", "desti15", "destf16", "desti2016", "destini64", "destsi32", "targetI15", "desti016", "destabi2016", "destf2016", "combini64", "destabi016", "destini15", "destI016", "destini32", "destsi64", "combini16", "destsi16", "desturi15", "destI2016", "desti64", "combi15", "desturi16", "targeti016", "destf016", "combi32", "targeti15", "combi16", "targetI2016", "destabi15", "destabi16", "combi64", "targetI016", "destI16", "destsi15"], "src": ["resource", "thumbnails", "filename", "cb", "uv", "url", "null", "usr", "rc", "grad", "img", "sel", "file", "desc", "rb", "pkg", "uc", "lib", "scene", "source", "s", "in", "gz", "input", "cur", "target", "sync", "output", "b", "front", "r", "sc", "upload", "pull", "crop", "tmp", "sys", "scenes", "ser", "rl", "bh", "console", "loc", "ug", "support", "conv", "stream", "req", "iv", "gb", "dist", "st", "rob", "cmp", "https", "attr", "sq", "secure", "ssl", "sr", "data", "cv", "default", "socket", "image", "video", "func", "view", "root", "coll", "download", "hub", "ctrl", "http", "load", "back", "buf", "cdn", "ource", "uri", "proc", "dest", "bs", "gl", "inst", "sl", "ctx", "config", "rss"], "dst": ["sdsl", "sdsc", "adst", "adbl", "dput", "dedost", "dedst", "Dst", "rdst", "ldbl", "adct", "dsost", " dste", "drsc", "rdST", "rdsc", "dsput", "Dost", "Ddr", "Dsts", "sddest", "nrest", " dsl", "dste", "sdst", "dsts", "dbl", "idest", "Dput", "drd", "Dbl", "sdest", "idst", "drput", " ddest", "nst", "dsdr", "ldst", "drST", " drest", " dest", "nste", "sdrd", "idrd", "ddest", " dput", "ddr", "drst", "ldost", " dsts", "nsts", "dsst", "dedput", "idsl", " drd", " dbl", "sdbl", "idsc", "deddr", "adost", "dost", "ldct", "idbl", "drest", "dct", "Dct", "dest", "dsl", "dsc", "Dste", " dsc", "dST", "Drest", "iddest", " dST", "rdput"], "i32": ["I35", "ri33", "i42", "I30", "si33", "ui34", "qi32", "ini35", "ui32", "I32", "in33", "iu32", "i31", "I31", "iu33", "i30", "I33", "in15", "ini32", "i15", " i35", "ri42", "i34", "i33", " i42", " i31", "si22", "ini33", "ri32", " i34", "ui30", "in32", "qi15", "I42", "qi33", "ui31", "i22", "i35", "si32", " i33", "in34", " i22", "iu15", "iu34", "ini22", "qi34", " i30", "I34", "ri35", "si35"], "desti32": ["destsi15", " destsi32", "targeti32", "targetiu34", "destii28", "destiu34", " destsi16", "destii33", "targeti34", "desti15", "destic22", "destsi32", "destsi22", " desti22", " destsi15", "destiu33", "destin28", " desti15", "destin33", "destsi16", "destic16", "destin34", "targetiu32", "destic32", "targeti28", "destiu32", "destabi22", "targetiu28", "targeti33", "destabi32", "desti28", "destin32", "destiu28", "destic15", " destsi22", "destabi15", "destii32", "destabi16", "desti34", "desti22", "destii34", "targetiu33", "desti33"]}}
{"id1": "14567939", "id2": "5138455", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"baseHash": ["Basehash", "BaseFile", " chainFile", " generateSecret", " chainhash", "baseFile", "BaseHash", "BaseSecret", " generatehash", "baseSecret", " generateFile", " generateHash", " chainSecret", "basehash", " chainHash"], "name": ["ame", "NAME", "prefix", "resource", "image", "parent", "style", "n", "data", "hello", "part", "alias", "member", "definition", "hash", "named", "key", "type", "class", "create", "Name", "base", "user", "object", "id", "address", "names", "account", "string", "file", "host", "path", "normal", "word", "secret"], "password": ["crypt", "prefix", "text", "padding", "attribute", "auth", "priv", "profile", "data", "username", "sword", "phrase", "hash", "input", "paste", "key", "wallet", "wd", "pass", "code", "source", "seed", "token", "string", "account", "stroke", "security", "device", "pattern", "diff", "words", "path", "word", "value", "Password", "secret", "PASS"], "digest": ["Diger", "Digusher", "mdester", "DigEST", "Digger", "modest", "modester", "signger", "Digester", "mdEST", "digEST", "Digest", " digested", "Digr", "mdr", "decr", "signusher", "signest", "digger", " diger", "signer", " digusher", "moder", " digester", " digger", "Digested", "digester", "decester", "signester", "decest", "diger", "digested", "mdest", "decEST", "digusher", "digr", "modested"]}}
{"id1": "23035537", "id2": "8588992", "code1": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "label": 0, "substitutes": {"getContent": ["readBody", "postContents", "postcontent", "createContent", "readContent", "postBody", "createBody", "getBody", "postContent", "createContents", "readContents", "createcontent", "readcontent", "getContents", "getcontent"], "userId": ["USEROr", "userName", "userID", " userOr", "userPath", "messageName", " userID", "UserPath", "messageId", " userName", " userPath", "USERName", "messageID", "UserOr", "UserName", "userOr", "USERPath", "UserID", "USERId", "UserId"], "latestMsgId": ["latestMsgTime", "lastMsgId", " latestmsgid", "latestChanID", " latestmsgTime", "latestMessageId", "latestMsgID", "latestMessageTime", "lastMsgid", " latestmsgID", "latestMessageid", "latestmsgTime", "latestUserID", "latestChanId", "latestmsgID", "latestmsgid", "latestChanTime", "lastMessageid", "latestMessageID", "lastMsgID", "latestUserid", "latestMsgid", " latestmsgId", "latestUserId", "lastMessageID", " latestMsgid", "lastMessageId", " latestMsgTime", "latestmsgId", "latestChanid", " latestMsgID"], "targetUrl": ["targeturl", "targetPage", "sourceURL", "TargetUrl", " targetPage", "sourcePage", "Targeturl", " targetURL", "sourceUrl", " targeturl", "targetUr", "TargetUr", "targetURL", "sourceurl", "TargetURL", " targetUr", "TargetPage", "sourceUr"], "url": ["string", "path", "base", "address", "ssl", "i", "id", "uri", "resource", "server", "feed", "user", "http", "window", "l", "location", "host", "URL", "client", "source", "browser", "connection", "r", "data", "file", "channel", "page", "image", "link", "sl", "Url", "www", "stream", "b", "download", "f", "api"], "in": ["IN", "string", "i", "input", "inas", "resource", "serv", "ini", "gin", "inner", "as", "socket", "ins", "s", "arin", "record", "bin", "query", "is", "pass", "raw", "source", "reader", "load", "login", "r", "wave", "inc", "data", "file", "out", "get", "again", "m", "ax", "image", "isin", "In", "nin", "kin", "a", "stream", "b", "err", "xml", "inn", "din"], "list": ["string", "info", "i", "server", "id", "entry", "sequence", "lp", "table", "document", "json", "result", "join", "l", "set", "pool", "all", "record", "detail", "queue", "la", "LIST", "lc", "live", "item", "group", "collection", "listed", "section", "data", "li", "parent", "cl", "language", "cli", "test", "lists", "coll", "tree", "dict", "chain", "array", "parse", "xml", "batch", "tx", "view"], "parser": ["info", "handler", "class", "arser", "loader", "builder", "http", "document", "lp", "per", "json", "system", "jack", "api", "php", "util", "ler", "er", "paragraph", "reader", "player", "collection", "parent", "data", "director", "p", "language", "plugin", "rss", "writer", "worker", "a", "layer", "parse", "processor", "command", "xml", "Parser"], "dao": ["idaba", " dosa", " daos", "idosa", "datao", "datala", "adosa", "Daos", "adala", "Dao", "Daba", "Dosa", "adaos", "daba", "dala", "daos", "idao", "dataos", "adao", "idaos", "datosa", " daba", "dosa", " dala"]}}
{"id1": "4618237", "id2": "11049257", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 0, "substitutes": {"writeFileToFile": ["writeFileAndStream", "writeFile2Channel", "writeFileToChannel", "writeFilesToFiles", "writeFilesToFile", "writeFileAndChannel", "writeFilesToChannel", "writeFileAndFile", "writeFilesAsChannel", "writeFileAndFiles", "writeFileToFiles", "writeFile2File", "writeFile2Files", "writeFilesAsStream", "writeFilesAsFile", "writeFileToStream", "writeFile2Stream", "writeFileAsStream", "writeFileAsFiles", "writeFilesAsFiles", "writeFileAsChannel", "writeFilesToStream", "writeFileAsFile"], "fin": ["fp", "thin", "din", "inv", "rf", "include", "ini", "FIN", "conn", "fm", "ris", "ln", "raf", "rt", "fa", "Fin", "en", "ori", "fine", "pins", "fr", "nir", "inn", "inf", "pin", "fi", "fd", "arin", "lin", "fn", "file", "init", "kin", "rin", "fen", "f", "fat"], "fout": [" fint", "Fint", "rfint", "bin", " foff", "rfin", "rfOut", "bOut", "fint", "Fin", "rfout", "bout", "Foff", " fOut", "boff", "FOut", "fOut", "foff", "Fout"], "append": ["send", "save", "apply", "leaf", "opp", "app", "protect", "flat", "pend", "end", "atten", "ext", "string", "ending", "remove", "batch", "ended", "null", "text", "printf", "enc", "want", "future", "pad", "padding", "except", "update", "pack", "add", "optional", "flush", "adjust", "vert", "push", "password", "spread", "only", "fail", "open"], "inChannel": ["innerConnection", "outQueue", "innStream", "inputChan", " inchannel", " inQueue", "inChan", "inQueue", "InStream", "innerChannel", "outChan", "InChannel", "inchannel", "outchannel", "innerchannel", "loginchannel", "outStream", "inputConnection", "inputStream", "innChannel", "INChan", " inStream", "INchannel", "inStream", "INChannel", "innchannel", "innerStream", "INStream", "inConnection", "INConnection", "InChan", "innerChan", "INQueue", "loginStream", "Inchannel", "loginChannel", "inputChannel"], "outChannel": ["Outchannel", "outputChan", "outContext", "inChan", "OutStream", " outChan", "outputchannel", " outContext", "outChan", "inchannel", "outchannel", "outputChannel", "externalChan", "outStream", "outputSocket", "inSocket", "ioChan", "inStream", "externalChannel", "ioStream", "ioChannel", "externalSocket", "OutContext", " outchannel", "outSocket", "iochannel", "OutChan", "OutChannel", "inContext", "externalchannel"]}}
{"id1": "19944975", "id2": "4118412", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["saveConfig", "writeConfig", " writeConfig", " writeReport", "writeReport", "WriteReport", "WriteConfiguration", "WriteSection", " writeSection", "saveConfiguration", "saveSection", "saveReport", "WriteConfig", "writeSection"], "out": ["err", "pool", "resource", "base", "o", "temp", "prefix", "this", "inner", "flush", "w", "write", "plain", "project", "at", "obj", "window", "exp", "exec", "filename", "output", "OUT", "password", "writer", "conn", "list", "object", "key", "sync", "scope", "string", "c", "IN", "external", "again", "outs", "path", "m", "line", "io", "Out", "client", "xml", "report", "name", "init", "inas", "ext", "dump", "server", "user", "file", "ex", "reader", "res", "lib", "connection", "config", "parent"], "url": ["image", "URL", "base", "resource", "service", "feed", "stream", "Url", "open", "channel", "http", "l", "b", "api", "conn", "object", "page", "string", "r", "path", "io", "rel", "org", "uri", "xml", "location", "ssl", "server", "data", "file", "ll", "ob", "sl", "connection", "config", "source", "web", "f", "address"], "in": ["ini", "err", "kin", "resource", "login", "serv", "stream", "gin", "inner", "inn", "input", "In", "inc", "cms", "bin", "b", "conn", "c", "pin", "r", "IN", "again", "source", "nin", "cin", "min", "ins", "is", "xml", "as", "lin", "socket", "inas", "ssl", "a", "inside", "ac", "data", "rin", "isin", "file", "id", "i", "reader", "win", "n", "din", "f", "copy", "s"]}}
{"id1": "21316706", "id2": "19687456", "code1": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 0, "substitutes": {"openConnection": [" openConnect", "openconnection", " openconnection", "initConnection", "initconnection", "createConnector", "initConnect", "openConnect", "createconnection", "createConnection", "openConnector", "initConnector", "createConnect", " openConnector"], "url": ["address", "base", "client", "str", "ob", "port", "io", "URL", "db", "path", "log", "default", "sl", "Url", "host", "string", "name", "ls", "image", "link", "or", "layer", "ssl", "connection", "user", "library", "null", "object", "socket", "loader", "uri", "service", "lr", "resource", "http", "l", "page", "source", "file", "server", "channel", "email", "ref", "web", "f"], "proxy": ["address", "base", "ip", "pa", "client", "cache", "project", "pse", "port", "zip", "io", "child", "host", "pointer", "roxy", "friend", "Proxy", "lib", "ssl", "connection", "pe", "library", "object", "parent", "config", "socket", "uri", "service", "resource", "p", "http", "page", "source", "pool", "server", "fax", "instance", " proxies", "web", "clone", "manager"]}}
{"id1": "659316", "id2": "23273706", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"argv": ["paramb", "argsf", " argver", "argumentver", "argf", " argl", "paramV", "argumentc", " argf", "argsv", "argl", "paramv", "argver", "Argve", "interV", "ArgV", "interl", "paraml", "argc", "Argl", " argV", "Argver", "Argv", "argumentve", "interc", "argb", " argb", "Argc", " argve", "argsl", "interv", "Argb", "argve", "argumentv", "argsc", "argV", "Argf", " argc"], "sources": ["psources", "fors", "tource", "vesores", "tources", "sesences", "statources", "issource", "statigs", "sores", "fource", "sresources", "fides", "sigs", "psource", "issources", "vesigs", "vesources", " sors", " sides", "sences", "tresources", "issides", "sesores", "statences", "sors", "issors", "psresources", "psides", "sesources", "fources", "fresources", "sides", "statores", "sesigs", "vesences", "tides"], "targets": ["tagnencies", "taxlets", "targends", " taxes", "targens", " taxends", "Targens", "tampels", " targens", "toket", "Targels", "tiges", "taxens", "tanglets", "taxets", "Tangets", "tagnets", "taxends", "taxels", "Tanglets", "targes", "tokets", "tagnet", "tagnens", "tangends", "tigens", "Tangens", "tamplets", " taxens", "tampets", "tangens", "tanges", "targels", " targes", " tokens", "targencies", "tokens", "Targlets", "tangets", " tokets", "tigets", "targlets", "tigends", "Targets", "taxes", " targends", "tanget", " taxets", "tampens", "tangels", "Tangels", " toket", " tokencies", "tokencies", " targencies", "tangencies"], "srclen": ["srCLength", "rscelEN", "srcelEN", "srplen", "rsclens", "srploen", "rsclEN", "srseln", "srctoen", " srcloen", "srselen", "srclens", "srClens", "srCln", "srClen", "srceln", "srselens", "rsclen", "srpleno", " srclength", " srploen", "rsceln", "rscelen", " srplength", "srclEN", "srClEN", "srcten", "srctength", "srcleno", "srCLen", "rscelens", " srcleno", "srcln", "srplength", "srcelen", "srselEN", " srpleno", "rscln", "srclength", " srplen", "srcteno", "srcelens", "srcloen", "srCLoen", "srCLeno"], "source": ["create", "remote", "copy", "cache", "uri", "current", "out", "client", "path", "config", "s", "use", "view", "seed", "event", "component", "model", "link", "driver", "ources", "input", "src", "ource", "image", "SOURCE", "single", "get", "Source", "in", "service", "resource", "proxy", "force", "self", "dest", "url", "sl", "secure", "rc", "scope", "channel", "size", "stream", "ssl", "slice", "id", "reader", "unit", "type", "parent", "start"], "tgt": ["tnt", " tgz", "hret", " tret", " tgs", " tgh", " tkt", "Targ", "Tkt", "Tch", "hnt", "bitarg", "hgz", "lret", "rkt", "ptgt", "Tgs", "tkt", "hgt", "tgz", "bitgt", "biticket", " tbuster", "tch", " tch", "tret", "targ", "rgt", "ticket", "lgz", "tgh", " targ", " tnt", "ptbuster", "Tgt", "lbuster", "rch", "Ticket", "larg", "lnt", "lgt", " ticket", "ptnt", "ptarg", "Tgh", "bitgh", "tbuster", "tgs", "rgs"], "target": ["match", "remote", "result", "output", "goal", "out", "port", "client", "path", "session", "current", "download", "point", "cross", "archive", "event", "component", "master", "tail", "driver", "nt", "slave", "view", "to", "arget", "conn", "project", "manager", "image", "service", "object", "Target", "resource", "director", "open", "force", "dest", "io", "core", "next", "url", "base", "null", "it", "child", "connection", "external", "channel", "handler", "plugin", "mount", "route", "unit", "parent", "member", "rel"], "deletes": ["deises", "delouts", "dedates", " dedates", "downdates", "degrades", "delises", "kesouts", "kesleted", "Deires", "desletes", "exletes", "desists", "disires", "disists", "desles", "exlete", "deles", "downletes", " deleted", "exdates", " deouts", "disletes", "deouts", "Deles", " degrades", "deleted", "delletes", "kesises", "exgrades", "disles", " deises", "Deists", "kesletes", "delleted", "Deletes", "downgrades", "desires", "deires", "deists", "delete", " delete", "downlete"], "del": ["local", "copy", "se", "dec", "clean", "update", "download", "model", "d", "de", "bl", "skip", "down", "install", "data", "nl", "dl", "up", "base", "name", "add", "null", "change", "Del", "sel", "fl", "delay", "neg", "lock", "coll", "el", "ll", "fail", "ul", "def", "file", "pull", "syn", "err", "remove", "dir", "diff", "id", "get", "Delete", "delete", " Del", " delete", "rel"]}}
{"id1": "3375722", "id2": "8024375", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"importarSetor": [" importTarsetor", " importTarSetorn", " importTarSetor", " importarStructor", " importarsetor", " importarSetorn", " importarStructutor", " importTarsetori", " importTarsetutor", " importarStructorn", " importarsetori", " importarProcessorn", " importarStructori", " importarsetorn", " importarProcessutor", " importTarsetorn", " importTarSetori", " importarSetutor", " importarProcessor", " importarProcessori", " importarSetori", " importarsetutor", " importTarSetutor"], "pArquivoXLS": ["pArquivaEXls", "pArquivoTXSL", "pArquivoXls", "pArquivaEXLS", "pArquivoTXLS", "pArquivoZXls", "pArquivaXML", "pArquivoYCL", "pArquivoTXCL", "pArquivoEXML", "pArquivoZXSL", "pArquivoYls", "pArquivoYML", "pArquivaXSL", "pArquivaXCL", "pArquivoXSL", "pArquivoEXSL", "pArquivaXls", "pArquivoEXCL", "pArquivoXML", "pArquivoZXLS", "pArquivaEXML", "pArquivoEXls", "pArquivoEXLS", "pArquivaXLS", "pArquivoZXML", "pArquivaEXCL", "pArquivoXCL", "pArquivoTXls", "pArquivaEXSL", "pArquivoYLS", "pArquivoTXML"], "pCabecalhoSetor": ["pCabecalhaSetor", "pCabecalhoSelector", "pCabecalhaSelecte", "pCabecalhaSete", "pCabecalhoSetors", "pCabecalhoSelectors", "pCabecalhoEditors", "pCabecalhaSelector", "pCabecalhoEditeur", "pCabecalhoSelecteur", "pCabecalhoEditor", "pCabecalhoSeteur", "pCabecalhoSelecte", "pCabecalhaSeteur", "pCabecalhaSelecteur", "pCabecalhoSete", "pCabecalhaSelectors", "pCabecalhoEdite", "pCabecalhaSetors"], "pAndamento": ["pAndamentO", "pAndementono", "pOramentos", "pAndmentono", "pOramentono", "pOrementos", "pAndamentos", "pAndietono", "pAndementO", "pAndietos", "pOremento", "pOrementono", "pOramento", "pAndmento", "pAndietO", "pAndemento", "pAndamentono", "pAndmentos", "pAndieto", "pOramentO", "pOrementO", "pAndementos", "pAndmentO"], "iLinha": ["iPlanha", "iFranha", "NumLinha", "iPlanHa", "NumPlanya", "iMalHa", "iMalya", "NumLinya", "iLineno", "iFranHa", "NumLineno", "iLinya", "iLinHa", "iMalha", "iFranya", "iPlanya", "NumPlanha", "NumLinHa", "NumPlaneno", "NumPlanHa", "iFraneno", "iMaleno", "iPlaneno"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialESTination", "stmtLimpezaIniciodestino", "stmtLimpezaInicialDesania", "stmtLimpezaInicialdestino", "stmtLimpezaIniciadestaco", "stmtLimpezaInicialESTaco", "stmtLimpezaInicialCombina", "stmtLimpezaInicioDestino", "stmtLimpezaInicialdestination", "stmtLimpezaInicialdestin", "stmtLimpezaInicialDesino", "stmtLimpezaInicioDestina", "stmtLimpezaInicialDesination", "stmtLimpezaInicialDestination", "stmtLimpezaIniciadestination", "stmtLimpezaInicialdestaco", "stmtLimpezaIniciodestaco", "stmtLimpezaInicialCombino", "stmtLimpezaInicialDesINO", "stmtLimpezaInicioDestINO", "stmtLimpezaIniciodestination", "stmtLimpezaIniciodestania", "stmtLimpezaInicialDestina", "stmtLimpezaInicialESTino", "stmtLimpezaInicioDestania", "stmtLimpezaIniciadestin", "stmtLimpezaInicialDestINO", "stmtLimpezaIniciaDestin", "stmtLimpezaIniciadestino", "stmtLimpezaInicioDestaco", "stmtLimpezaInicialCombINO", "stmtLimpezaInicialESTin", "stmtLimpezaInicialDestaco", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialdestina", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialdestINO", "stmtLimpezaInicioDestination", "stmtLimpezaIniciaDestino", "stmtLimpezaIniciodestINO", "stmtLimpezaInicialDestania", "stmtLimpezaIniciodestina", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialdestania", "stmtLimpezaInicialDestin"], "stmtDestino": ["stmtdestin", "stmtRestINO", "stmrdestinning", "stmpDestino", "stmdestino", "stmtCombINO", "stmtRestinning", "stmtRestin", "stmtCombino", "stmDestin", "stmtdestino", "stmdestinos", "stmpdestINO", "stmpdestorno", "stmtdestinos", "stmpdestaco", "stmpDestorno", "stmtDistINO", "stmpDestaco", "stmrDestinning", "stmtDestINO", "stmrdestINO", "stmtDistaco", "stmtLocationINO", "stmtLocationaco", "stmpDestINO", "stmtDestin", "stmtRestinos", "stmtRestino", "stmtCombin", "stmtdestaco", "stmtDestorno", "stmpdestino", "stmDestino", "stmtDestinos", "stmrdestaco", "stmtDestinning", "stmtdestorno", "stmtDestaco", "stmrDestINO", "stmDestINO", "stmtDistorno", "stmDestinos", "stmtRestaco", "stmtdestINO", "stmtCombinos", "stmrDestaco", "stmtDistino", "stmdestINO", "stmrdestino", "stmtdestinning", "stmdestin", "stmtLocationinning", "stmrDestino", "stmtLocationino"], "arquivo": ["arQUico", " ar\u00e7ivo", " arqiva", "Arqoso", " ar\u00e7icio", "arQUiva", "arqico", " arquiva", " ar\u00e7arius", "arquarius", "arQuivo", "Arquiva", "Arqiva", " ar\u00e7iva", "Arqivo", "arquico", "arqicio", " arqivo", "arQuiva", " arqicio", "arqiva", " arQuiva", "arquoso", " arQuarius", "arqarius", "arQuico", "arquiva", " arquicio", " arQuivo", "arQUoso", " arqarius", "arQuoso", "arqivo", " arquarius", " arQuicio", "arquicio", "Arquoso", "arQUivo", "Arqico", "arqoso", "Arquico", "Arquivo"], "plan1": ["Plan0", "Plan2", "plan2", " Plan0", " plan0", " planName", " plan2", "planOne", " planOne", "PlanName", "plan0", "planName", " Plan1", "product2", "productName", "product0", " Plan2", " PlanOne", "Plan1", "PlanOne", "product1"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTROAD", "QUANTIDADE_DE_REGISTROSAD", "QUANTIDADE_DE_REGISTEROAD", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTRASAD", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTROS__", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTERO__", "QUANTIDADE_DE_REGISTRO__", "QUANTIDADE_DE_REGISTEROSAD", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRosAD", "QUANTIDADE_DE_REGISTRONS_", "QUANTIDADE_DE_REGISTEROS__", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTRATES__", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRONS__", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRos_"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTROsEC", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTRYAS_", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTROsJ", "QUANTIDADE_DE_REGISTRYOS_", "QUANTIDADE_DE_REGISTRYOSJ", "QUANTIDADE_DE_REGISTRYASJ", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRosEC", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRos_"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTROID", "QUANTIDADE_DE_REGISTRES_", "QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTRON_", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRATESJ", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTRATESEC", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRESEC", "QUANTIDADE_DE_REGISTEROID", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTEROSID", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRONID", "QUANTIDADE_DE_REGISTRosID", "QUANTIDADE_DE_REGISTRESJ", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTROSID"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstivator", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstifadas", "quantidadeDeRegistrosEstimmator", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstifator", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstifado", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstimator", "quantidadeDeRegistrosEstimmado"], "vSetor": ["vSetoring", "vSelector", " vSete", "vShipe", "vSelecte", " vSetoring", "vSelectoring", "vSete", "vShipor", "vSetors", "vShiporing", "vSelectors", " vSetors", "vShipors"], "vSubsetor": ["vSubjectors", "vSubscor", "vSubseto", "vSubscriptor", "vSubscr", "vSubsco", "vsubsetor", "vSubjector", "vsubsetr", "vSubscors", "vsubscors", "vSubscripto", "vsubscor", "vsubsco", "vSubjecto", "vSubscriptors", "vSubjectr", "vsubscr", "vSubsetors", "vSubscriptr", "vSubsetr", "vsubsetors", "vsubseto"], "vSegmento": ["vSegMENTo", "vGamentos", "vSegmenta", "vSegMENTos", "vSegamentos", "vSegamento", "vSegmentationor", "vGamentor", "vSegmentationa", "vSegMENTor", "vGmentor", "vGmenta", "vSegamenta", "vGamenta", "vSegmentationo", "vGmento", "vGamento", "vGmentos", "vSegMENTa", "vSegmentationos", "vSegmentos", "vSegmentor", "vSegamentor"], "registroAtual": ["RegistroAtual", "Registroatual", "RegistroGenual", "Registrosatial", "RegistroGenional", "RegistroGenUAL", "RegistroExional", "RegistroGenial", "RegistroatUAL", "RegistrosAtUAL", "Registroatial", "RegistrosAtial", "RegistroAtUAL", "RegistrosatUAL", "RegistroExual", "RegistrosAtual", "Registroational", "RegistrosAtional", "RegistroAtional", "Registrosational", "RegistroExUAL", "Registrosatual", "RegistroExial", "RegistroAtial"], "vPapeisPorSegmento": ["vPapeisPorSegmente", "vPapeisPorSegmentsor", "vPapeisPorSegmentor", "vPapeisPorSegmentos", "vPapeisPorSegmentationos", "vPapeisPorSegamentor", "vPapeisPorFragmento", "vPapeisPorSegamento", "vPapeisPorSegmentationo", "vPapeisPorSegmentatione", "vPapeisPorFragmente", "vPapeisPorFragmentsos", "vPapeisPorSegmentationor", "vPapeisPorFragmentsor", "vPapeisPorFragmentso", "vPapeisPorFragmentos", "vPapeisPorFragmentse", "vPapeisPorSegamente", "vPapeisPorSegmentsos", "vPapeisPorFragmentor", "vPapeisPorSegmentse", "vPapeisPorSegmentso", "vPapeisPorSegamentos"], "sql": ["ls", "sol", "description", "statement", "log", "http", "ln", "url", "ssl", "install", "sf", "html", " SQL", "script", "body", "term", "os", "sv", "acl", "data", "msg", "shell", "csv", "QL", "sb", "spec", "zip", "str", "sn", "nl", "s", "sq", "dl", "pr", "comment", "section", "seed", "sg", "db", "base", "eps", "slice", "id", "layout", "string", "params", "select", "sl", "spr", "json", "query", "setup", "where", "util", "serv", "SQL", "ql"]}}
{"id1": "21425787", "id2": "8135072", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "base", "i", "input", "id", "ex", "ini", "c", "inner", "ins", "bin", "at", "reader", "source", "up", "connection", "min", "login", "inc", "work", "data", "file", "or", "again", "name", "m", "exec", "image", "io", "In", "a", "url", "b", "ac", "inn"], "out": ["base", "temp", "ex", "output", "n", "server", "user", "c", "OUT", "result", "dest", "outs", "o", "off", "client", "part", "at", "source", "cache", "up", "connection", "target", "w", "inc", "data", "file", "object", "x", "p", "conn", "name", "again", "exec", "Out", "writer", "io", "to", "call", "prefix", "v", "b", "point"], "sourceChannel": ["srcConnection", " sourcechannel", "sourcechannel", "ourceChan", "ourceConnection", "Sourcechannel", " sourceSocket", "targetChan", "SourceStream", " sourceStream", "sourceChan", "ourceSocket", " sourceChan", "targetStream", "sourceConnection", "srcSocket", "resourcechannel", "resourceChan", "ourcechannel", "srcChannel", "ourceChannel", "sourceStream", "SourceChan", "sourceSocket", "resourceChannel", "targetchannel", "srcChan", "SourceChannel", "targetChannel", "SourceConnection", " sourceConnection", "resourceConnection"], "destinationChannel": ["destinationFile", "destationChannel", "destinatedchannel", "DestinationFile", "destinatorchannel", "destinatorChannel", "destructionChan", "destinationConnection", "destinateChannel", "destinatedChannel", "destinatingChan", "destinationChan", "destationConnection", "Destinatorchannel", "DestinatingStream", "destinatorManager", "destinatedChan", "destinatedFile", "destinatedManager", "destationchannel", "DestinationConnection", "destinatorFile", "destinatingChannel", "DestinationChan", "DestinationChannel", "destinatorConnection", "destinateChan", "Destinationchannel", "DestinatingManager", "DestinatingChan", "destinationStream", "DestinationManager", "destructionConnection", "destinationManager", "DestinationStream", "destinatingManager", "DestinatorConnection", "DestinatingChannel", "destinationchannel", "DestinatorChannel", "DestinatorFile", "destinatingStream", "DestinatorChan", "destinatorStream", "destinateConnection", "destationFile", "destinatorChan", "destinatedConnection", "destinatedStream", "destructionChannel"]}}
{"id1": "13233761", "id2": "3024992", "code1": "    public void executeUpdateTransaction(List queries) throws SQLException {\n        assert connection != null;\n        boolean autoCommit = connection.getAutoCommit();\n        connection.setAutoCommit(false);\n        try {\n            Iterator iterator = queries.iterator();\n            while (iterator.hasNext()) {\n                String query = (String) iterator.next();\n                Statement statement = connection.createStatement();\n                statement.executeUpdate(query);\n            }\n            connection.commit();\n            connection.setAutoCommit(autoCommit);\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(e.getMessage());\n        }\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 0, "substitutes": {"executeUpdateTransaction": ["executeInsertStatement", "executeQuerySession", "executeDatabaseTransaction", "executeQueryStatement", "executeUpdateSession", "executeDatabaseTx", " executeUpdateSession", " executeUpdateStatement", "executeInsertTx", "executeUpdateStatement", "executeInsertSession", "executeDatabaseStatement", " executeDatabaseSession", "executeQueryTx", " executeDatabaseTransaction", " executeDatabaseStatement", "executeInsertTransaction", "executeDatabaseSession", " executeDatabaseTx", "executeQueryTransaction", " executeUpdateTx", "executeUpdateTx"], "queries": ["blands", "squands", "commires", "compests", "blests", "compands", "squips", "squires", "questires", "quires", "squests", "questeries", "quests", "bleries", "commands", "quips", "comperies", "compips", "blips", "quands", "squeries", "questands", "commeries", "questips", "commips"], "autoCommit": [" autoCommmit", "AutoCommit", " autoComits", "AutoDebit", "autoommitted", "autoDebmit", "autoommits", "autoDebits", "autocommit", "autoCommmit", "autoCommrit", "autoComits", "autoCompitted", " autoCommits", "autocommrit", "AutoCommits", "autoCompmit", "AutoCommmit", " autoComitted", "autoCommits", "autoCompits", "autocommmit", "autoComitted", "AutoCommrit", "AutoDebits", "autoommit", "autocommits", "autoCommitted", " autoComit", "AutoDebrit", "autoComit", "autoDebrit", " autoCommitted", "autoDebit", "autoCompit", "AutoDebmit", "autoommmit", "autoComrit"], "iterator": ["reader", "connection", "iter", "sequence", "data", "division", "ator", "gener", "population", "vector", "handler", "database", "runners", "slice", "creator", "later", "stream", "filter", "started", "info", "inst", "set", "ie", "adder", "loop", "inner", "instance", "walker", "loader", "size", "section", "former", "done", "internet", "collection", "encer", "parser", "ter", "list", "i", "entry", "step", "pointer", "init", "starter", "interstitial", "outer", "next", "context", "finder", "metadata", "Iterator", "index", "series", "consider", "cher", "inter", "string", "start", "end", "runner", "ski"], "query": ["connection", "sequence", "data", "name", "question", "q", "table", "command", "press", "filter", "str", "expression", "rule", "commit", "qu", "key", "sq", "row", "comment", "call", "entry", "style", "condition", "select", "value", "next", "update", "uri", "script", "search", "message", "action", "ql", "result", "record", "join", "sql", "string", "Query"], "statement": ["connection", "sequence", "data", "si", "start", "session", "s", "database", "command", "table", "usage", "inst", "state", "mt", "expression", "commit", "conn", "section", "parser", "flush", "comment", "style", "storage", "condition", "response", "ment", "next", "document", "unit", "function", "script", "action", "Statement", "stat", "result", "join", "sql", "execute", "string", "use", "element"]}}
{"id1": "12055086", "id2": "15445861", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copyDeletging", " copydeleing", " copyDeleing", " copyDeleteting", " copyDeleging", " copydeletting", " copyDeletting", " copyDeletter", " copyDeleteter", " copyDequeter", " copyDeleter", " copyDeleteing", " copydeleter", " copydeleging", " copyDequeging", " copydeleting", " copyDequeting", " copyDeleteging", " copydeletging", " copydeletter", " copyDequeing"], "source": ["ource", "base", "master", "reader", "cache", "view", "site", "use", "e", "path", "remote", "input", "target", "s", "stream", "inner", "archive", "image", "Source", "down", "storage", "ie", "connection", "i", "route", "sin", "config", "ources", "iter", "service", "resource", "from", "copy", "file", "src", "f", "SOURCE"], "dest": ["slave", "de", "result", "master", "thin", "img", "bin", "tmp", "comb", "path", "folder", "default", "target", "flat", "destruct", "Dest", "class", "orig", "desc", "null", "pipe", "slice", "wb", "done", "content", "destroy", "file", "dir", "dist", " destination", "src", "die", "later", "home", "opt", "trans", "exit", "temp"], "buf": ["Buffer", "uf", "vec", "bc", "result", "base", "img", "uc", "br", "tmp", "port", "cv", "bd", "bp", "feed", "raw", "ctx", "fb", "length", "seq", "cp", "cmd", "queue", "len", "off", "bag", "code", "batch", "b", "ff", "config", "loc", "pad", "buffer", "bytes", "rb", "feat", "rc", "data", "append", "bh", "pos", "src", "bf", "txt", "cb", "buff"], "in": ["exec", "url", "gin", "ins", "thin", "din", "reader", "IN", "login", "bin", "id", "isin", "inc", "io", "ini", "input", "In", "conn", "inner", "stream", "image", "c", "read", "i", "b", "n", "again", "sin", "tin", "socket", "nin", "win", "inn", "p", "min", "pin", "plus", "is", "data", "up", "file", "inside", "init", "src", "rin", "con", "f"], "out": ["exec", "img", "client", "OUT", "outs", "w", "output", "bin", "app", "exp", "io", "inc", "conn", "ext", "obj", "inner", "image", "err", "down", "Out", "lib", "at", "writer", "i", "b", "ex", "n", "again", "o", "parent", "sync", "socket", "win", "outer", "buffer", "pool", "file", "up", "part", "f"], "count": ["base", "cache", "allow", "handle", "use", "id", "feed", "current", "child", "zip", "path", "Count", "index", "val", "start", "length", "ind", "max", "name", "offset", "lock", "c", "len", "code", "read", "all", "type", "b", "number", "n", "parent", "weight", "cond", "buffer", "depth", "close", "key", "pool", "ch", "num", "limit", "coll", "part", "sum", "size", "f"]}}
{"id1": "22264586", "id2": "7499186", "code1": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"copyFiles": ["clonePages", "cloneFile", "transferFile", "CopyChildren", "Copyfiles", "clonefiles", "copyFile", "CopyFiles", " copyfiles", "copyPages", "transferChildren", "transferPages", "transferFiles", " copyPages", "copyChildren", " copyChildren", "cloneFiles", "transferfiles", " copyFile", "CopyFile", "copyfiles"], "strPath": ["stFile", " strpath", "strName", "striFile", "stPath", " strName", "strFile", "striLog", "STRpath", "StrLog", "STRLog", "stName", "stripath", "striPath", "strpath", "StrFile", "stpath", "strLog", "Strpath", "STRFile", "StrName", "StrPath", "STRPath", " strFile"], "dstPath": ["dstsFile", "dblpath", "dstFile", "ddestDir", "drcpath", "dndPath", "fstsDir", "sdndPath", "dblFile", "sdstName", "drcDir", "sdndName", "ddestFile", "dstName", "drcName", "sdndpath", "fstPath", "sdndDir", "sdstPath", "dstDir", "dblPath", "dndDir", "dndpath", "ddestName", "sdstDir", "fstspath", "dstspath", "drcPath", "dblDir", "dstpath", "dndName", "sdstpath", "fstsPath", "fstFile", "fstsFile", "fstDir", "ddestPath", "dstsPath", "ddestpath", "dstsDir", "fstpath"], "src": ["txt", "cmp", "project", "obl", "front", "host", "Source", "ruby", "dist", "scripts", "self", "input", "ource", "path", "inst", "ctx", "sc", "slice", "this", "sys", "in", "sync", "client", "download", "loc", "sup", "s", "rc", "rob", "ls", "reverse", "upload", "tmp", "cur", "url", "config", "sb", "sl", "back", "SOURCE", "split", "sin", "cb", "RC", "img", "st", "ssl", "secure", "ources", "sub", "rs", "source", "stream", "sel", "sit", "rb", "iv", "sq", "sort"], "dest": ["dc", "folder", "cdn", "txt", "done", "slave", "temp", "wh", "cat", "project", "front", "zip", "rest", "later", "dat", "dist", "d", "destroy", " Dest", "desc", "di", "wd", "div", "sup", "dd", "comb", "trans", "default", "out", "tmp", "delete", "du", "thin", "flat", "des", "ds", "home", "gd", "Dest", "result", "img", "secure", "test", "style", "target", "prop", "de", "source", "wb", "dep", "db"], "list": ["status", "full", "map", "dl", "ll", "none", "files", "pair", "members", "dir", "p", "l", "s", "delete", "url", "like", "val", "stat", "filter", "write", "lists", "parent", "version", "lc", "names", "entry", "lines", "str", "la", "LIST", "bl", "cl", "strings", "keys", "code", "data", "null", "stream", "sort", "www", "listed", "queue", "part", "all", "ls", "coll", "arr", "load", "size", "array", "set", "diff", "type", "stack", "id", "cont", "name", "group", "run", "string", "parents", "is", "remove", "path", "key", "json", "batch", "base", "chain", "config", "read", "split", "test", "info", "source"], "i": ["hi", "si", "qi", "ip", "u", "multi", "n", "ii", "c", "m", "pi", "o", "y", "abi", "ci", "di", "io", "key", "slice", "ji", "ui", "ri", "length", "me", "bi", "ie", "p", "part", "phi", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "start", "gi", "v", "ti", "type", "ai", "data", "r", "b", "xi", "id", "info", "uri", "ix", "mu"], "dest1": ["srcOne", "sourceone", "Dest0", "Dest2", "dest0", "source2", "destOne", "DestOne", "homeone", "source0", "src2", "source1", "src0", "dest2", " destone", "sourceOne", "destone", "home1", "Dest1"], "src1": ["srcOne", "sourceone", "rc1", "source2", " src2", "rcOne", "src2", "rcone", "source1", " srcone", " srcOne", "sourceOne", "rc2", "srcone"], "sourceChannel": ["srcChan", "SourceStream", "ourceChan", "Sourcechannel", "sourceContext", "SourceContext", "targetChan", "ourceStream", " sourcechannel", "SourceChan", "srcStream", "srcContext", " sourceChan", "sourcechannel", "SourceChannel", "ourceChannel", "targetContext", "targetchannel", "sourceStream", "srcChannel", " sourceStream", "sourceChan", "targetStream", " sourceContext", "ourceContext"], "targetChannel": ["TargetChannel", "destContext", "TargetContext", "TargetManager", " targetConnection", "sourceContext", "targetChan", "destChannel", " targetManager", "destConnection", "argetManager", " targetContext", "targetManager", "destChan", " targetChan", "argetChan", " targetchannel", "sourcechannel", "targetConnection", "Targetchannel", "argetChannel", "targetContext", "targetchannel", "argetchannel", "TargetConnection", "sourceChan", "TargetChan"]}}
{"id1": "17817568", "id2": "20426057", "code1": "    public Reader getGETReader_bak(URL url) {\n        Reader reader = null;\n        if (Navigator.isVerbose()) System.out.println(\"Web3DService.getGETReader caching \" + url);\n        int contentLength = -1;\n        URLConnection urlc;\n        try {\n            urlc = url.openConnection();\n            urlc.setReadTimeout(Navigator.TIME_OUT);\n            if (getEncoding() != null) {\n                urlc.setRequestProperty(\"Authorization\", \"Basic \" + getEncoding());\n            }\n            urlc.connect();\n            String content_type = urlc.getContentType();\n            if (content_type == null || content_type.equalsIgnoreCase(\"x-world/x-vrml\") || content_type.equalsIgnoreCase(\"model/vrml\") || content_type.equalsIgnoreCase(\"model/vrml;charset=ISO-8859-1\")) {\n                InputStream is = urlc.getInputStream();\n                DataInputStream d = new DataInputStream(is);\n                contentLength = urlc.getContentLength();\n                byte[] content = new byte[contentLength];\n                if (d != null) {\n                    d.readFully(content, 0, contentLength);\n                }\n                is.close();\n                d.close();\n                ByteArrayInputStream bais = new ByteArrayInputStream(content);\n                reader = new InputStreamReader(bais);\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip\")) {\n                InputStream is = urlc.getInputStream();\n                BufferedInputStream bis = new BufferedInputStream(is);\n                GZIPInputStream gis = new GZIPInputStream(bis);\n                StringBuffer sb = new StringBuffer();\n                BufferedReader zipReader = new BufferedReader(new InputStreamReader(gis));\n                char chars[] = new char[10240];\n                int len = 0;\n                contentLength = 0;\n                while ((len = zipReader.read(chars, 0, chars.length)) >= 0) {\n                    sb.append(chars, 0, len);\n                    contentLength += len;\n                }\n                chars = null;\n                gis.close();\n                zipReader.close();\n                bis.close();\n                is.close();\n                reader = new StringReader(sb.toString());\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(cis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    cis.close();\n                    bufReader.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    GZIPInputStream gis = new GZIPInputStream(cis);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(gis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    bufReader.close();\n                    gis.close();\n                    cis.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"text/html;charset=utf-8\")) {\n                System.out.println(\"text/html;charset=utf-8\");\n            } else {\n                System.err.println(\"ContentNegotiator.startLoading unsupported MIME type: \" + content_type);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return reader;\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"getGETReader_bak": ["getGETReader_bcaz", "getGETReader_abak", "getGETReader_cunk", "getGETReader_bunk", "getGETReader_bck", "getGETReader_bcunk", "getGETReader_ck", "getGETReader_abaz", "getGETReader_bk", "getGETReader_bcak", "getGETReader_abk", "getGETReader_abunk", "getGETReader_cak", "getGETReader_baz", "getGETReader_caz"], "url": ["resource", "pull", "stream", "string", "host", "http", "str", "service", "www", "URL", "path", "ll", "ur", "api", "feed", "gl", "Url", "rl", "client", "user", "address", "bug", "loc", "lr", "build", "l", "connection", "base", "rc", "server", "location", "coll", "config", "loader", "sl", "f", "link", "image", "html", "ssl", "page", "r", "uri", "buffer", "source", "org", "name", "file", "lc"], "reader": ["resource", "entry", "row", "library", "instance", "http", "oder", "inner", "service", "input", "io", "feed", "driver", "object", "handler", "er", "rc", "server", "dr", "loader", "read", "Reader", "rer", "iter", "per", "writer", "ser", "data", "rr", "r", "parser", "rar", "buffer", "source", "client"], "contentLength": ["ContentLen", "encSize", " contentSize", "messageSize", " contentlength", "messageLength", "contentOffset", "Contentlength", "resourceLength", "ContentLength", "contentLen", "contentlength", "ContentSize", "loadlength", " contentOffset", "resourceLen", "resourcelength", "enclength", "contentSize", "outputlength", "ContentOffset", "outputLength", "resourceType", "resourceSize", "messageType", "ContentType", "loadLength", "resourceOffset", "contentType", " contentType", "encLength", "loadSize", "messageLen", "messagelength", "loadType", " contentLen", "outputType", "outputLen"], "urlc": ["urlac", "relC", "webci", "urlf", "URLi", " urlci", "UrlC", "URLcb", "urlp", "certcase", "blogf", " urli", "Urlci", "blogd", " urln", "relc", "looklc", "Urle", "urld", "httpc", " urlac", "Urlf", " urlf", "Urlc", "urlcb", "relcase", "runC", "urllc", "httpac", "urlci", "blogac", "runcase", " urld", "URLp", "webp", "methodc", "httpd", "lln", "certc", "httpi", "llc", "lookf", "urle", "Urlac", "urln", " urlcase", "looki", "Urln", "runcs", "urcb", "Urld", "relcs", "urlcs", "methodd", "methode", " urle", "urll", "URLC", "URLci", " urll", "urlC", "urc", "URLcase", "URLe", "blogc", "urlcase", "urli", " urlp", "certe", "llf", "URLc", "Urli", "httpf", "lookc", " urllc", "runc", "httplc", "webcs", " urlcs", "lli", "certl", " urlC", "urC", "URLac", "URLl", "methodci", "webc", " urlcb", "urp", "URLcs"], "content_type": ["contentEsize", "documentaltype", "contentEversion", "Content_Type", "content_info", "Content_name", "document_key", "content_token", "document_type", "contentaltoken", "content__type", "Content_types", "content64type", "Content_block", "contentFileversion", " content_types", "content64key", "document_state", "content64token", "contentalkey", "contentEtype", "content__Type", "content_name", "content_Type", " content_size", "content_size", "contentTypeinfo", "content_block", "content__family", "contentTypetypes", "Content_platform", " content_info", "contentFilekey", "content__name", "document_token", "contentTypestyle", "contentalstate", "content_platform", " content_style", "contentEkey", "contentaltype", "content_state", "documentaltoken", "content_key", "content_style", "content64state", "content_family", "Content_type", "contentTypetype", " content_version", "Content_family", "documentalkey", "content_types", "contentFiletype", "contentFilesize", "content_version", " content_key", "documentalstate"], "is": ["ics", "dis", "si", "isa", "ios", "ois", "im", "ii", "isl", "ir", "ide", "was", "iris", "has", "as", "ais", "os", "IS", "ins", "ri", "are", "address", "ie", "it", "isin", "init", "s", "qs", "Is", "vs", "iss", "iso", "its", "idis", "iter", "isi", "isc", "sis", "i", "ori", "iri", "alis", "sin", "mis", "lis", "nis", "ps", "tis", "id", "es", "info", "iv", "ris"], "d": ["dc", "df", "done", "did", "g", "c", "m", "dat", "dos", "dist", "dl", "da", "di", "fd", "z", "bd", "ad", "p", "dd", "l", "w", "cd", "del", "s", "dh", "dr", "dt", "f", "nd", "e", "dump", "director", "i", "ds", "gd", "q", "dom", "h", "dm", "ded", "der", "v", "dad", "data", "dig", "md", "sd", "b", "de", "id", "D", "dim", "db"], "content": ["resource", "status", "media", "section", "stream", "c", "current", "cache", "xml", "script", "comment", "cover", "layer", "desc", "cont", "json", "child", "address", "header", "default", "document", "device", "model", "exec", "server", "Content", "load", "x", "config", "complete", "read", "array", "children", "enc", "code", "value", "image", "page", "result", "output", "data", "raw", "message", "source", "buffer", "text", "body", "version", "core", "dec"], "bais": ["BAiss", "dais", "xaiss", "caiss", "cai", "baiss", "baas", "haiss", "xaish", "BAis", "daiss", "BAas", "BAi", "haas", "xais", "xai", "hai", "cais", "bai", "hais", "baish", "caish", "BAish", "dai", "daas"], "bis": ["ses", "ios", "bs", "bps", "ii", "ois", "cus", "bin", "uds", "abi", "ubis", "series", "di", "abs", "ais", "slice", "dies", "ri", "boot", "bos", "bi", "fs", "isin", "gb", "pins", "vs", "onis", "iss", "cos", "alis", "sin", "mis", "lis", "nis", "nas", "esi", "tis", "bus", "rb", "lins", "las", "ris", "phis"], "gis": ["gris", " gids", "cfgis", "jios", "jist", "gids", "jis", "giss", "Giss", "jos", "gos", "ghios", "bios", "ghist", "bos", " giss", "ghos", "cfgris", "Gris", "ghis", "gist", " gris", "gios", "cfgids", "Gids", "cfgiss", "Gis", "bist"], "sb": ["ib", "mb", " eb", "usb", "erb", "sth", "nb", "bs", "B", "bps", "pb", "sm", "sf", "dB", "src", "stab", "bg", "obb", "bp", "SB", "eb", "orb", "xb", "abb", "lb", "gb", "rob", "bc", "lp", "zb", " SB", "kb", "BB", "cb", "ssl", "bb", "sg", "b", "bf", "fb", "buffer", "wb", "ab", "bm", "rb", "db", "sq"], "zipReader": ["archiveReader", " zipperRunner", "Zipreader", " zipperRead", "gzWriter", "ZipParser", " zipParser", "archiveWriter", "archiveParser", " zipWriter", "gzRead", " zipreader", " zipperWriter", "zipParser", "archivereader", "ZipWriter", "zipreader", " zipRunner", "zipRead", " zipRead", "gzReader", "zipRunner", "ZipReader", " zipperReader", "zipWriter", "gzRunner"], "chars": ["quapters", "characters", " Ch\n", "chacters", "Chars", "Chaks", "charans", "chashes", "clars", "charars", "Ch\n", "cheacters", "charts", "Chans", "quaks", "charapters", "shapes", "Charts", "chararts", "chans", "clacters", "shars", "cheashes", "clarts", " chapters", "clashes", "chears", "shacters", "quarts", "chapters", " charts", "ch\n", " ch\n", "chapes", " chans", "Chapters", "charapes", "quars", " chacters", "chaks", "sharts", " chapes", "charashes", " chaks", "chearts"], "len": ["span", "lt", "n", "fin", "dl", "ann", "ler", "le", "fun", "Len", "ll", "la", "num", "length", "min", "seq", "lit", "count", "ie", "err", "rel", "cl", "l", "part", "pos", "lin", "del", "all", "ls", "size", "sl", "f", "li", "lim", "ind", "el", "split", "led", "val", "nt", "data", "elt", "fl", "hl", "en", "lf", "rev", "lon", "id", "ln", "lc", "end"]}}
{"id1": "13362846", "id2": "15445861", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setTenuit", "setTonenu", "setContenues", "setContineues", "setContineuer", "setTonenues", "setTenu", "setContennues", "setContineuit", "setTonenuer", "setContonenuer", "setContenuer", "setTenuer", "setContineu", "setContonenuit", "setContennu", "setContennuit", "setContonenues", "setTonenuit", "setContenuit", "setContonenu", "setTenues", "setContennuer"], "contenuFichier": ["contenuPrefichiers", "contenuFocher", "contenuPFochier", "contenuFrenchier", "contenuMichier", "contenuFaffier", "contenuTichiere", "contenuMrenchiere", "contenuMaffiere", "contenuFrenchiers", "contenuMichiers", "contenuFochiere", "contenuPFicher", "contenuMaffie", "contenuMaffieri", "contenuFchery", "contenuPrefaffie", "contenuFicheiere", "contenuPrefichier", "contenuFochie", "contenuPrefaffier", "contenuTicheery", "contenuMrenchique", "contenuFaffie", "contenuFichery", "contenuFicherer", "contenuFicoyer", "contenuFrenchery", "contenuFactoryiere", "contenuFicier", "contenuFaffiers", "contenuFicheique", "contenuFicheer", "contenuPFichique", "contenuPhichiere", "contenuFichtique", "contenuFichtiere", "contenuPrefaffiere", "contenuFichiers", "contenuFrenchoyer", "contenuFrenchie", "contenuPhichoyer", "contenuTicheiere", "contenuPrefichiere", "contenuTichery", "contenuFicher", "contenuPhactoryiere", "contenuPFochiere", "contenuPrefaffiers", "contenuFrenchique", "contenuFichtier", "contenuFaffieri", "contenuFrencherer", "contenuMaffier", "contenuFichoyer", "contenuTicheier", "contenuPhichier", "contenuPFichier", "contenuFiciere", "contenuFactoryie", "contenuFochiers", "contenuTicheerer", "contenuMichiere", "contenuFicheerer", "contenuFcherer", "contenuMichie", "contenuFichique", "contenuPhactoryoyer", "contenuFichie", "contenuMaffiers", "contenuTichier", "contenuMrenchie", "contenuFichtie", "contenuFaffiere", "contenuFaffer", "contenuFchier", "contenuMrenchier", "contenuFochier", "contenuFicie", "contenuFchiere", "contenuFaffique", "contenuMichieri", "contenuFichieri", "contenuFichiere", "contenuFrenchiere", "contenuFicheie", "contenuFicheieri", "contenuPhichie", "contenuTicherer", "contenuFicheery", "contenuFactoryoyer", "contenuMichique", "contenuPhactoryie", "contenuFactoryier", "contenuPhactoryier", "contenuPrefichie", "contenuFicheier", "contenuFichtieri", "contenuPFocher", "contenuPFochique", "contenuPFichiere", "contenuFochique"], "fichierElectronique": ["fichierAustrolique", "fichierCentornier", "fichierAdministronistic", "fichierElectron\u00e9e", "fichierElectromical", "fichierElectroneiques", "fichierElectronistic", "fichierElectronsique", "fichierElectaronique", "fichierElectonlique", "fichierElectronsie", "fichierAustroniere", "fichierElectoloniques", "fichierElectrolique", "fichierAdministronsie", "fichierElectronsiques", "fichierElectolonique", "fichierElectronsiere", "fichierElectroneie", "fichierElectpronique", "fichierElectronlique", "fichierAdministronical", "fichierElectaronier", "fichierAdministronique", "fichierElectornier", "fichierElectromique", "fichierElectrolier", "fichierElectromiques", "fichierElectronelique", "fichierElectonique", "fichierAdministronie", "fichierElectronslique", "fichierElectornique", "fichierAustronique", "fichierElectroniques", "fichierElectronica", "fichierAustroliere", "fichierAdministronlique", "fichierCentornique", "fichierAdministronslique", "fichierElectronsica", "fichierAdministronsique", "fichierAustrolier", "fichierElectronsical", "fichierElectolonica", "fichierCentronier", "fichierElectoloniere", "fichierAdministronier", "fichierAdministronsier", "fichierAdministronsical", "fichierElectromistic", "fichierAustroliques", "fichierElectronier", "fichierElectronical", "fichierElectpronistic", "fichierElectroneique", "fichierCentronique", "fichierElectrolie", "fichierCentornlique", "fichierElectorniques", "fichierAdministronsistic", "fichierElectrol\u00e9e", "fichierElectpronical", "fichierElectproniques", "fichierElectonier", "fichierCentroniques", "fichierElectornlique", "fichierElectronsistic", "fichierElectrons\u00e9e", "fichierAdministron\u00e9e", "fichierAdministroniques", "fichierElectaronie", "fichierElectaron\u00e9e", "fichierElectroneiere", "fichierElectronsier", "fichierAustronier", "fichierAdministrons\u00e9e", "fichierCentronlique", "fichierAdministronsiques", "fichierElectroniere", "fichierElectrolica", "fichierElectronie", "fichierCentorniques", "fichierAustroniques", "fichierElectroliques", "fichierElectroliere", "fichierElectonie", "fichierElectroneier"], "utilisateurCourant": ["utilisateurParticipants", "utilisationApplicants", "utilisateurParticipante", "utilisationCourante", "utilisationApplicateur", "utilisateurApplicant", "utilisateurParticipant", "utilisationCourateur", "utilisateurApplicante", "utilisateurGovernant", "utilisationApplicant", "utilisationCourant", "utilisateurCourateur", "utilisateurCourante", "utilisateurGovernateur", "utilisateurGovernante", "utilisateurCourants", "utilisationCourants", "utilisateurParticipateur", "utilisationApplicante", "utilisateurApplicants", "utilisateurApplicateur", "utilisateurGovernants"], "support": ["services", "push", "Support", "info", "know", "accept", "Library", "settings", " Support", "document", "system", "library", "concept", "util", "client", "friend", "allow", "protection", "respect", "cover", "proxy", "facebook", "media", "feature", "evidence", "config", "best", "share", "supp", "bank", "control", "plugin", "format", "knowledge", "force", "ann", "compatible", "supported", "pull", "review", "summary", "contact", "help", "utils", "pport", "service", "storage"], "ficheDocument": ["friquedocument", "FcheContent", "ficheDoc", "inficheDocument", "fchadocument", "enfoiceDocument", "fchaDocument", "enficheCompany", "fcheMatrix", "fraudDocument", "afficheDoc", "inficheNumber", "infraudDoc", "friqueDoc", "fraudCatalog", "inficheDoc", "fcheDocuments", "infraudDocument", "fraudCompany", "fcheDocument", " fcheMatrix", " ficheDocuments", "foiceDirectory", "fagueDirectory", "financeNumber", "fielCompany", "fielDirectory", "affineFeature", "foinedocument", "affichedocument", "affinedocument", "fruitNumber", "afficheDocument", "infraudNumber", "facheMatrix", "friqueDocument", "FcheDoc", "foineFeature", "ficheNumber", "afficheFeature", "enfoiceCatalog", "ficheFeature", "fetchDoc", "FicheContent", "fetchFeature", "fchaContent", " ficheMatrix", "friqueContent", "ficheCompany", "fielCatalog", "facheDocument", "fcheDirectory", "enfoiceDirectory", "fetchdocument", "fineDocument", "fagueDocuments", "facheDocuments", "fichedocument", "enficheDocument", "fagueMatrix", "affineDoc", "financedocument", "fielDocument", "fchaDoc", "infichedocument", "facheDirectory", "Fichedocument", "finedocument", "fineDoc", "foiceDocument", "FicheDoc", "ficheCatalog", " ficheDirectory", "foiceCompany", "ficheDirectory", " fcheDocument", "financeDocument", "ficheContent", "fraudDirectory", "enficheDirectory", "fruitdocument", "FcheDocument", "fraudDoc", "infrauddocument", "fruitDocument", "fineFeature", "foiceCatalog", "fcheContent", "foineDocument", "fchedocument", " fcheDirectory", "Fchedocument", "fruitDoc", "FicheDocument", "ficheMatrix", "frauddocument", " fcheDocuments", "foineDoc", "fetchDocument", "fagueDocument", "enficheCatalog", "enfoiceCompany", "fraudNumber", "fcheDoc", "ficheDocuments", "financeDoc", "affineDocument"], "nomFichier": ["nomFchy", "nomVichieri", "nomPichier", "nomVich\u00e8re", "nomFichtier", "nomFichtiller", "nomFachire", "nomFrench\u00e8re", "nomNicher", "nomWichery", "nomNichier", "nomFichiner", "nomFachiere", "nomFiqurier", "nomFrenchier", "nomFchien", "nomWichier", "nomFichtieri", "nomFochier", "nomPhichiere", "nomFichterer", "nomPchy", "nomFichery", "nomPhichieri", "nomVchieri", "nomWichire", "nomFiquier", "nomFachiller", "nomFchieri", "nomFch\u00e8re", "nomFitherer", "nomVicher", "nomNichter", "nomF\u00e9tier", "nomFachieri", "nomFichy", "nomPrefichier", "nomFichtiner", "nomFiquire", "nomFisciller", "nomF\u00e9tery", "nomPhichier", "nomPrefichieri", "nomPhachieri", "nomPrefichire", "nomPrefchieri", "nomFachier", "nomFicher", "nomPchier", "nomNichtier", "nomFichire", "nomPichy", "nomFiscier", "nomFisciner", "nomFicherer", "nomPchien", "nomFochire", "nomFichrier", "nomVch\u00e8re", "nomFiscer", "nomVcher", "nomFich\u00e8re", "nomFichien", "nomPhacherer", "nomFachiner", "nomFacher", "nomF\u00e9ty", "nomNichiller", "nomPichery", "nomPhachiere", "nomFichieri", "nomWchiere", "nomVichier", "nomPrefchrier", "nomWchire", "nomNichtiner", "nomFchery", "nomF\u00e9tien", "nomFachrier", "nomPhachier", "nomFrencher", "nomVchier", "nomFichtery", "nomFichter", "nomWichiere", "nomFcher", "nomWchery", "nomPchery", "nomFchiere", "nomPrefchier", "nomFichiller", "nomNichtiller", "nomWchier", "nomFach\u00e8re", "nomPrefchire", "nomPhicherer", "nomFiscien", "nomFithier", "nomFithiere", "nomNichiner", "nomPichien", "nomFochery", "nomFiquieri", "nomFichtiere", "nomFithieri", "nomFichiere", "nomFiscy", "nomPrefichrier", "nomFchier", "nomFchire", "nomFchrier", "nomFacherer", "nomFochiere", "nomFichtire", "nomFiscery", "nomFrenchieri"], "extension": ["encension", "extion", "Extception", "exion", "encception", "anchensions", "encression", "exression", "EXTime", "anchension", "Extression", "encion", "exception", "extception", "EXTensions", "exension", "EXTension", "Extension", "extime", "Extensions", "extensions", "Extime", "extression", "Extion", "anchime"], "fichierElectroniqueExistant": ["fichierElectroniquesXclusive", "fichierElectroniqueXivist", "fichierElectroniqueExplists", "fichierElectroniqueXistance", "fichierElectroniqueexistant", "fichierElectroniquesXistent", "fichierElectroniqueExistance", "fichierElectroniqueexists", "fichierElectroniqueexclusive", "fichierElectroniquesExistant", "fichierElectroniquesXivist", "fichierElectroniqueSistent", "fichierElectroniqueSistant", "fichierElectroniqueExists", "fichierElectroniqueXistant", "fichierElectroniquesExilingual", "fichierElectroniquesExistent", "fichierElectroniqueexistance", "fichierElectroniquesXistant", "fichierElectroniqueexist", "fichierElectroniqueExplist", "fichierElectroniqueSilingual", "fichierElectroniqueExistent", "fichierElectroniqueXists", "fichierElectroniqueXistent", "fichierElectroniquesXists", "fichierElectroniquesExivist", "fichierElectroniqueXilingual", "fichierElectroniquesExclusive", "fichierElectroniquesXilingual", "fichierElectroniqueSistance", "fichierElectroniquesExist", "fichierElectroniquesExists", "fichierElectroniquesXistance", "fichierElectroniqueexivist", "fichierElectroniqueexilingual", "fichierElectroniquesExistance", "fichierElectroniqueExist", "fichierElectroniqueExplistance", "fichierElectroniqueExilingual", "fichierElectroniqueExplivist", "fichierElectroniqueXist", "fichierElectroniqueexistent", "fichierElectroniqueExclusive", "fichierElectroniqueXclusive", "fichierElectroniqueExplistant", "fichierElectroniqueExplclusive", "fichierElectroniqueExivist", "fichierElectroniquesXist"], "idIgid": ["idIogids", "idUgid", "idIogbit", "idIgudid", "idIgmids", "idIgmname", "idIgdid", "idIgubit", "idIgenname", "idUguids", "idIguname", "idIogdid", "idIgenid", "idIgnids", "idIGid", "idIguID", "idIgnid", "idEGid", "idIguod", "idUguname", "idIggid", "idEgid", "idIgenids", "idIgids", "idIggod", "idEGids", "idIggID", "idUgname", "idUgID", "idIgID", "idIgbit", "idEGbit", "idIgname", "idIgnID", "idIGdid", "idEgbit", "idIGbit", "idIgenID", "idUguid", "idIgod", "idUguID", "idIguid", "idIogid", "idIgmID", "idIggids", "idEGdid", "idUgids", "idIGids", "idIgnod", "idEgids", "idIgmid", "idEgdid", "idIguids"], "inputStream": ["eventSteam", "InputThread", "eventstream", "inputStreamer", "outputLength", "InputStreamer", "outputSteam", "InputLength", "inputSteam", " inputThread", "eventStreamer", "inputThread", " inputstream", "inputLength", "outputstream", " inputSteam", "outputStreamer", "outputThread", " inputLength", "Inputstream", "inputstream", "InputSteam", "InputStream", "eventStream"], "outputStream": ["inputStreamer", "entityStream", "officeStream", "outputSteam", "inputSteam", "OutputContext", "OutputStreamer", "Outputstream", "entitySteam", " outputstream", "officeSteam", "OutputSteam", "outputstream", "outputStreamer", "OutputStream", " outputContext", "officestream", "outputContext", "inputContext", "officeStreamer", "entitystream", "entityStreamer", " outputSteam", "inputstream"], "typeMime": ["TypeMide", "TypeSmimes", "typeMangle", "TypeSmangle", "typeSmangle", "typeMatimes", "typeSmimes", "TypeMime", "typeMatime", "typeMimes", "TypeSmide", "TypeMangle", "typeMide", "typeMatangle", "typeSmide", "typeMetime", "typeMetimes", "TypeMimes", "typeMetide", "TypeSmime", "typeMetangle", "typeMatide", "typeSmime"], "tailleFichier": [" tailleFichiers", " tailleFigner", " taillefichie", " tailleFicheiers", " tailleFocher", " tailleFicheer", " tailleFignier", " tailleFicheie", " tailleFignie", " tailleFochie", " taillefochier", " taillefochiers", " taillefichiers", " tailleFochier", " tailleFigniers", " tailleFichie", " tailleficher", " taillefochie", " tailleFochiers", " tailleFicheier", " tailleFicher", " taillefichier", " taillefocher"]}}
{"id1": "17475530", "id2": "9327525", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"testAddLinkToImage": ["testAddLinkOfPicture", "testAddLinkToPicture", "testAddLinkFromPicture", "testAddLinktoFile", "testAddLinksToLink", "testAddLinkOfLink", "testAddLinksToPicture", "testAddLinkstoPicture", "testAddLinkFromLink", "testAddLinkOfFile", "testAddLinktoLink", "testAddLinkstoLink", "testAddLinkToLink", "testAddLinkToFile", "testAddLinksToImage", "testAddLinkFromImage", "testAddLinkstoFile", "testAddLinkOfImage", "testAddLinktoImage", "testAddLinkFromFile", "testAddLinkstoImage", "testAddLinksToFile", "testAddLinktoPicture"], "in": ["r", "image", "get", "m", "pin", "n", "inn", "gin", "isin", "stream", "is", "i", "socket", "el", "cin", "input", "version", "copy", "id", "ex", "din", "val", "conn", "diff", "ax", "or", "connection", "exp", "index", "resource", "path", "nin", "xml", "ssl", "out", "ini", "con", "work", "file", "rin", "at", "min", "f", "url", "pass", "exec", "serv", "login", "doc", "data", "err", "with", "token", "ins", "name", "bin", "In", "reader", "IN", "as", "again", "uri", "win", "source", "ac", "inc"]}}
{"id1": "5237257", "id2": "21824901", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"download": ["process", "upload", "release", "output", "transfer", "delete", "load", "archive", "complete", "run", "open", "register", "submit", "report", "pack", "file", "start", "url", "exec", "update", "zip", " downloading", "log", "paste", "Download", "dump", "select"], "fileName": ["resourcePath", "FileType", " fileFolder", "fileType", " fileType", "resourceFolder", " fileCode", "FileName", "FileDirectory", "fileUrl", "resourceType", "FilePath", " fileUrl", "resourceName", "FileCode", "resourceCode", " fileDirectory", "fileDirectory", "fileCode", "FileUrl", "fileFolder", "resourceUrl", "FileFolder", "resourceDirectory"], "filePath": ["resourcePath", "FileLocation", "filepath", "fileFile", "FilePart", "fileLocation", "FileName", "resourceFile", "FileFile", "filePart", "FilePath", "resourcepath", " fileLocation", "resourceName", "resourceLocation", " filepath", "Filepath", "resourcePart", " filePart", " fileFile"], "in": ["r", "image", "m", "pin", "sync", "n", "inn", "gin", "isin", "i", "is", "socket", "init", "cin", "input", "copy", "on", "id", "spin", "din", "ax", "lin", "cgi", "a", "inner", "resource", "io", "nin", "con", "ini", "rin", "file", "work", "x", "inside", "f", "url", "this", "login", "data", "err", "b", "ins", "name", "bin", "In", "l", "reader", "IN", "as", "again", "re", "win", "issue", "source", "up", "ac", "inc"], "out": ["Out", "image", "error", "client", "writer", "sync", "obj", "n", "off", "one", "up", "output", "socket", "view", "user", "write", "copy", "on", "id", "ex", "office", "cache", "server", "option", "to", "conn", "or", "inner", "ext", "path", "exp", "io", "nin", "line", "at", "file", "x", "url", "prefix", "o", "null", "exec", "this", "base", "lib", "err", "with", "log", "net", "call", "name", "bin", "In", "password", "by", "again", "IN", "string", "point", "outs", "extra", "cmd", "outer", "source", "OUT"]}}
{"id1": "6379126", "id2": "12766394", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": ["riarTinyPage", "riarTinyDir", "riartourpage", "riarTourDir", "riarTutorialElement", "riartutorialPage", "riarTutorialDir", "riarTourElement", "riarTravispage", "riartutorialDir", "riarTinypage", "riarTinyElement", "riarTourPage", "riarTutorialPage", "riarTravisElement", "riartourElement", "riarTravisPage", "riartutorialElement", "riarTourpage", "riartutorialpage", "riarTutorialpage", "riartourPage", "riartourDir", "riarTravisDir"], "indexDir": ["IndexTier", "includeJar", "zipJar", "indexJar", "includeTier", "zipTier", "IndexDir", "zipDir", "zipDIR", "IndexDIR", "includeDir", "indexDIR", "indexTier", "includeDIR", "IndexJar"], "cssDir": ["catsDoc", "javascriptDir", "CSSLen", "ssUrl", "fontDIR", "fontDir", "cssDIR", "piecesDie", "cssDie", "ssD", "CSSDir", "catsDir", "javascriptDb", "CSSDirectory", "javascriptDar", "ssDIR", "CSSDar", "gzDir", "cssDb", "fontD", "cssD", "CSSDIR", "codesDoc", "javascriptDIR", "CSSDb", "ssDir", "cssDar", "codesDir", "catsLen", "piecesD", "ssDb", "gzDIR", "CSSDoc", "cssLen", "cssDirectory", "fontDie", "gzDirectory", "gzUrl", "piecesDir", "ssDar", "codesLen", "ssDie", "CSSUrl", "ssDirectory", "cssDoc", "cssUrl", "piecesDIR"], "capDir": ["capdir", "CapVol", "capDirectory", "casDir", "casdir", "Capdir", "CapDirectory", "casVol", "apsDir", "apsdir", "casDirectory", "apsVol", "CapDir", "capVol", "apsDirectory"], "licDir": ["volDoc", "lifManager", "lifDir", "libManager", "licManager", "libDoc", "lifDoc", "voldir", "volDir", "licdir", "volManager", "lifdir", "licDoc", "libdir", "libDir"], "midDir": ["middir", "casDir", "limTier", "mindDir", "limDir", "midTier", "casDIR", "casdir", "limDIR", "casTier", "mindTier", "mindDIR", "minddir", "midDIR", "limdir"], "filesDir": ["ballsPos", "ballsVol", "filesFolder", "pagesVol", "ballsDir", "pagesPos", "stylesDir", "FilesDir", "filesVol", "videosFile", "videosFolder", "imagesFile", " filesVol", "filesDur", "opensDIR", "stylesDirectory", "stylesDIR", "videosDirectory", "filesPos", "filesDirectory", "opensDirectory", "filesDIR", "opensDur", "stylesDur", "locksDirectory", "imagesDir", "locksDIR", "imagesDirectory", " filesPos", "FilesFolder", "FilesDirectory", "pagesDir", "imagesFolder", "FilesFile", "opensDir", "filesFile", "locksDir", "locksDur"], "videosDir": ["viewsUrl", "videosDb", "videoUrl", "videoFile", " videosDb", " videosDirectory", "videosFile", "viewsDir", "viewsDirectory", "videosDirectory", "viewsFile", "imagesDir", " videosFile", "videoDb", " videosUrl", "imagesDb", "videosUrl", "videoDirectory", "videoDir"], "imagensDir": ["imgentsFile", " imagensDirectory", " imagersDirectory", "imagentsFile", "imagenciesDir", "imgensDir", " imagensFile", " imagersFile", "imgensDirectory", "imagersDirectory", "imgentsDirectory", "imgentsDIR", " imagersJar", "imagentsJar", "imgentsDir", "imagersDIR", "imagenJar", "imagenFile", "imagensDirectory", "imagersDir", " imagersDir", "imagenciesDirectory", "imgensFile", "imgensDIR", "imagensDIR", "imagenDirectory", "imagenciesDIR", "imagenciesFile", "imagensJar", "imagersJar", "imagenDir", " imagensJar", "imagersFile", "imagentsDir", "imagentsDIR", "imagentsDirectory", "imagensFile"], "local": ["request", "where", "localhost", "shared", "p", "upload", "same", "defined", "tmp", "global", "user", "basic", "managed", "internal", "serial", "pal", "input", "directory", "valid", "json", "home", "loc", "relative", "state", "location", "safe", "path", "inner", "standard", "http", "conf", "file", "available", "part", "dir", "util", "active", "Location", "prefix", "pass", "base", "Local", "data", "temp", "LOC", "log", "partial", "personal", "total", "name", "l", "small", "specified", "d", " Local", "remote", "present", "lock", "current", "back", "self", "initial", "username"], "srcCss1": ["srcRcss0", "srcCpe4", "srcCrss1", "srcCss11", "srcCrss3", "srcRss2", "srcPss81", "srcRss0", "srcCcss0", "srcPcss1", "srcPssPre", "srcCss81", "srcRss1", "srcCse1", "srcCcss1", "srcRcss2", "srcCrss2", "srcPss1", "srcCass2", "srcCass0", "srcCcssPre", "srcPcss2", "srcPcss3", "srcCpe1", "srcPcssPre", "srcCpe2", "srcCcss81", "srcCpePre", "srcRcss11", "srcCass1", "srcCssPre", "srcRss81", "srcRss11", "srcCfg1", "srcCass3", "srcCrss11", "srcCcss3", "srcRcss81", "srcPcss4", "srcCse2", "srcPss3", "srcCcss4", "srcRcss1", "srcPcss81", "srcCcss2", "srcCse11", "srcCfg4", "srcCass81", "srcCcss11", "srcCrss81", "srcCass11", "srcCse0", "srcCss0", "srcCfg2", "srcPss4", "srcPss2", "srcCfgPre"], "destCss1": ["destCass1", "destPcss3", "destPssCard", "destCcss3", "destCfg3", "destPcss81", "destPss2", "destCss0", "destCrss81", "destCxxCard", "destPcss1", "destCxx1", "destCass81", "destCass3", "destCss81", "destCssCard", "destPss0", "destCcss2", "destCcss1", "destCcssCard", "destCfg1", "destPcss2", "destCass2", "destCrss1", "destCcss0", "destCfg0", "destCassCard", "destCrss0", "destCfg2", "destCrss2", "destPcssCard", "destCxx3", "destPss1", "destCrss3", "destPss3", "destPcss0", "destCxx2", "destCcss81", "destPss81"], "srcCss2": ["srcCcssL", "srcCass52", "srcCrssL", "srcCssTwo", "srcCrss1", "srcChessTwo", "srcCssB", "srcCrss3", "srcCss27", "srcChess1", "srcUcssTwo", "srcCfgL", "srcCng27", "srcCross4", "srcPss27", "srcChessB", "srcAcss2", "srcPcss1", "srcUssTwo", "srcCross1", "srcCrss2", "srcCcss1", "srcPss1", "srcUcss1", "srcCass2", "srcUcssB", "srcAccss2", "srcAccss52", "srcPcss27", "srcCross2", "srcPcss2", "srcPcss3", "srcCng1", "srcCng2", "srcCass1", "srcPssL", "srcCcss27", "srcUcss2", "srcChess2", "srcCfg1", "srcAcss4", "srcPcssL", "srcCcss3", "srcPss3", "srcCcss4", "srcCcss52", "srcCssL", "srcCcssB", "srcCfg3", "srcCfgB", "srcAccss1", "srcCass4", "srcCcss2", "srcCcssTwo", "srcUss1", "srcUss2", "srcAcss52", "srcCfgTwo", "srcCss52", "srcUssB", "srcAccss4", "srcCross52", "srcCrss27", "srcAcss1", "srcCfg2", "srcPss2"], "destCss2": ["destCess1", "destCfg3", "destCcss72", "destCcss3", "destNcss32", "destNcss2", "destNss1", "destCess32", "destCest2", "destCcss4", "destCcssB", "destCess4", "destNcss3", "destNcssB", "destNss2", "destNss32", "destCcss32", "destCfg32", "destNss4", "destCest3", "destCcss2", "destCcss1", "destNssB", "destNcss4", "destCfg1", "destNss72", "destCess72", "destCfgB", "destCfg4", "destNss3", "destCess2", "destCestB", "destCssB", "destCfg2", "destNcss72", "destCfg72", "destCest1", "destCss32", "destNcss1", "destCss72"], "srcCss3": ["srcRss2", "srcCsh183", "srcScss3", "srcCsl183", "srcRss1", "srcScstyle93", "srcCssThird", "srcCstyle6", "srcScstyle2", "srcCsh2", "srcCcss4", "srcCstyleAND", "srcPss6", "srcCstyle15", "srcCstyle93", "srcCfg2", "srcCcss93", "srcCss15", "srcCssAND", "srcCsl3", "srcCstyle3", "srcCss183", "srcCass2", "srcRcss3", "srcCcss15", "srcCrss6", "srcRss3", "srcCass1", "srcCfg1", "srcCcss3", "srcPss3", "srcClass3", "srcRcss1", "srcCss93", "srcPcss6", "srcCass4", "srcCcssThird", "srcCrss3", "srcScstyle3", "srcCstyle2", "srcCcss6", "srcClass2", "srcRcss183", "srcClass15", "srcPcss2", "srcPssAND", "srcCrssAND", "srcClass93", "srcCass3", "srcRssThird", "srcCslThird", "srcCsh3", "srcRss183", "srcCsl2", "srcRcss4", "srcCfg3", "srcCfg4", "srcRss4", "srcRcssThird", "srcPcss3", "srcScss93", "srcCcss183", "srcCrss2", "srcRcss2", "srcCcss1", "srcScss15", "srcPcssAND", "srcCcssAND", "srcScss2", "srcCshThird", "srcScstyle15", "srcCcss2", "srcPss2"], "destCss3": ["destPcss3", "destCcss3", "destCross3", "destNcss2", "destCstyle2", "destScss183", "destCstyle03", "destCja6", "destPss2", "destScss3", "destCrss183", "destCss43", "destCross03", "destCstyle53", "destCstyle43", "destCross53", "destNcss3", "destScrss2", "destCrss6", "destNss2", "destNss43", "destScrss6", "destCass3", "destNcss43", "destCss53", "destScss6", "destCja3", "destPcss53", "destPcss03", "destCcss2", "destScrss3", "destCstyle3", "destPcss2", "destCass2", "destCss03", "destPss53", "destScrss183", "destCss183", "destNss3", "destCja183", "destScss2", "destCja2", "destCrss2", "destCcss6", "destCross2", "destCrss3", "destPss3", "destCcss183", "destPss03", "destCcss53", "destCcss03", "destCcss43", "destCass43"], "srcCss4": ["srcCrss1", "srcPcss1", "srcPssFour", "srcCrss2", "srcCcss1", "srcPss1", "srcCass2", "srcPcss2", "srcCass1", "srcCssFour", "srcCassFour", "srcCrss4", "srcCrssFour", "srcCcssFour", "srcPcss4", "srcCcss4", "srcPcssFour", "srcCcss2", "srcCass4", "srcPss4", "srcPss2"]}}
{"id1": "21821404", "id2": "7118860", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 1, "substitutes": {"getWebPage": ["parsewebpage", "getwebpages", "parsewebPage", "getVirtualPage", "getVirtualpages", "getwebpage", "getWebpage", "parseWebpages", "parsewebpages", "parseWebpage", "getVirtualpage", "parseWebPage", "getwebPage", "getWebpages"], "urlObj": [" urlObject", "URLobj", "resourceObject", "urlExt", "httpobj", "blogobj", "URLObject", "UrlObj", "Urlobj", "urlobj", " urlExt", "URLObj", " urlobj", "strobj", "strObject", "blogObj", "httpOb", "resourceobj", "resourceObj", "URLExt", " urlInst", "blogInst", " urlOb", "strObj", "strInst", "resourceExt", "UrlOb", "urlInst", "urlOb", "httpObj", "urlObject", "blogObject"], "content": ["resource", "online", "section", "clean", "string", "c", "css", "lines", "comment", "response", "core", "java", "continue", "report", "cont", "feed", "empty", "json", "object", "address", "header", "document", "out", "model", "server", "Content", "url", "load", "coll", "work", "array", "code", "value", "page", "result", "html", "output", "data", "write", "raw", "comments", "message", "source", "buffer", "text", "body", "file"], "is": ["il", "or", "isp", "ires", "us", "isa", "ip", "ios", "im", "ois", "isl", "est", "you", "rest", "site", "ir", "irc", "was", "iris", "as", "be", "io", "ais", "abs", "os", "IS", "ui", "cms", "in", "ins", "ri", "does", "ie", "it", "fs", "s", "Is", "out", "iss", "iso", "ar", "ops", "x", "its", "isi", "isc", "i", "any", "mis", "bis", "lis", "ser", "ai", "al", "nis", "r", "ps", "id", "es", "info", "stream", "ris", "ise", "problem"], "reader": ["or", "row", "actor", " Reader", "reading", "oder", "inner", "ler", "io", "ner", "driver", "in", "ri", "er", "handler", "bird", "ro", "l", "rc", "server", "x", "loader", "read", "Reader", "iter", "rer", "e", "director", "i", "worker", "h", "writer", "editor", "ser", "rr", "r", "parser", "rar", "buffer", "stream", "rx"], "line": ["item", "inline", "entry", "row", "pass", "section", "string", "col", "word", "lines", "ine", "LINE", "str", "character", "comment", "Line", " inline", "response", "char", "key", "object", "user", "cr", "cl", "l", "part", "connection", "lin", "cell", "out", "server", "url", "block", "link", "f", "code", "cle", "strip", "page", "data", "lf", "message", "buffer", "source", "text", "body", "column", "name", "file", "lc"]}}
{"id1": "21016435", "id2": "8079516", "code1": "    private String getFullScreenUrl() {\n        progressDown.setIndeterminate(true);\n        System.out.println(\"Har: \" + ytUrl);\n        String u = ytUrl;\n        URLConnection conn = null;\n        String line = null;\n        String data = \"\";\n        String fullUrl = \"\";\n        try {\n            URL url = new URL(u);\n            conn = url.openConnection();\n            conn.setDoOutput(true);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = rd.readLine()) != null) {\n                if (line.contains(\"fullscreenUrl\")) {\n                    data = line.trim();\n                }\n            }\n            rd.close();\n            System.out.println(data);\n            int start = 0;\n            String[] lines = data.split(\"&\");\n            String[] tmp = null;\n            String video_id = null;\n            String t = null;\n            String title = null;\n            for (int i = 0; i < lines.length; i++) {\n                if (lines[i].startsWith(\"video_id=\")) {\n                    tmp = lines[i].split(\"=\");\n                    video_id = tmp[1];\n                }\n                if (lines[i].startsWith(\"t=\")) {\n                    tmp = lines[i].split(\"=\");\n                    t = tmp[1];\n                }\n                if (lines[i].startsWith(\"title=\")) {\n                    tmp = lines[i].split(\"=\");\n                    title = tmp[1].substring(0, (tmp[1].length() - 2));\n                }\n                System.out.println(lines[i]);\n            }\n            System.out.println(\"So we got...\");\n            System.out.println(\"video_id: \" + video_id);\n            System.out.println(\"t: \" + t);\n            System.out.println(\"title: \" + title);\n            ytTitle = title;\n            fullUrl = \"http://www.youtube.com/get_video.php?video_id=\" + video_id + \"&t=\" + t;\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getLocalizedMessage());\n        }\n        progressDown.setIndeterminate(false);\n        return fullUrl;\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"getFullScreenUrl": ["getFullscreenImage", "getFullScreenURL", "getFullScreenImage", "getFullScreenLink", "getFullscreenURL", "getFullscreenLink", "getFullscreenUrl"], "u": ["ur", "nu", "uri", "lu", "e", "uc", "uu", "ru", "n", "b", "ul", "ut", "universal", "uv", "f", "o", "su", "d", "iu", "uni", "uid", "cu", "a", "l", "base", "user", "r", "c", "tu", "up", "U", "ou", "hu", "ui", "util", "p"], "conn": ["conv", "rt", "ssl", "nn", "fr", "cn", "ct", "b", "g", "n", "connection", "conf", "lock", "loc", "rc", "cp", "pg", "en", "act", "cmd", "session", "sync", "reg", "Connection", "syn", "pt", "connect", "URL", "rn", "ch", "coll", "nc", "cb", "out", "Conn", "api", "rl", "client", "cli", "l", "db", "ann", "util", "r", "exec", "con", "c", "dc", "dn", "ld", "net", "ctx", "pub", "path", "Url", "enc", "http", "dh", "p", "open", "serv"], "line": ["page", "LINE", "log", "frame", "lf", "message", "one", "label", "le", "write", "style", "letter", "item", "cell", "profile", "link", "sync", "shell", "part", "entry", "f", "definition", "str", "lin", "cl", "nl", "error", "type", "key", "el", "end", "val", "row", "inline", "band", "comment", "job", "parse", "pass", "section", "header", "li", "l", "len", "base", "user", "object", "id", "look", "string", "file", "Line", "name", "sl", "pin", "lc", "feed", "block"], "data": ["DATA", "page", "text", "uri", "photo", "message", "resource", "image", "arr", "html", "style", "body", "info", "single", "parts", "part", "output", "pos", "stuff", "result", "area", "input", "str", "dat", "bytes", "inline", "type", "meta", "home", "download", "code", "results", "source", "action", "api", "media", "di", "a", "base", "ata", "string", "json", "picture", "response", "content", "buffer", "format", "state", "feed", "space"], "fullUrl": ["shorturl", "completeURL", "FullPath", "shortURL", "shortUrl", "shortPath", "fullurl", "FullURL", "Fullurl", "fullURL", " fullurl", " fullURL", " fullPath", "completeurl", "completeUrl", "completePath", "fullPath", "FullUrl"], "url": ["ur", "ls", "fl", "ssl", "uri", "ll", "image", "server", "resource", "fr", "b", "connection", "cdn", "rel", "blog", "channel", "f", "impl", "connect", "www", "URL", "nl", "download", "pull", "api", "rl", "client", "l", "stream", "lr", "r", "con", "obj", "sl", "host", "Url", "lc", "http", "open"], "rd": ["fd", "rt", "rm", "rss", "fr", "xd", "rob", "rx", "nd", "ru", "dr", "mr", "rc", "rs", "rh", "dig", "dd", "director", "gd", "Reader", "vd", "rn", "rb", "erd", "rg", "wd", "RS", "RD", "rw", "bd", "reader", "pd", "rl", "rr", "lr", "r", "ird", "adr", "dra", "td", "ld", "RF", "cr", "ri"], "start": ["art", "pad", "Start", "count", "offset", "st", "info", "last", "pos", "in", "limit", "it", " Start", "no", "check", "set", "index", "end", "stop", "time", "is", "starting", "max", "size", "id", "next", "from"], "lines": ["ls", "forms", "values", "scenes", "rows", "pins", "ins", "items", "points", "books", "links", "sites", "ns", "parts", "lists", "shows", "cases", "dates", "loads", "sections", "plugins", "groups", "lins", "verts", "comments", "split", "elines", "ines", "breaks", "balls", "ips", "lights", "objects", "posts", "flows", "works", "plays", "les", "vals", "qs", "pps", "files", "pages", "states", "ids", "steps", "mails", "bands", "models", "codes", "tests", "xs", "cells", "rules", "blocks", "boxes", "limits", "strings", "ks", "runs", "ds", "styles"], "tmp": ["buf", "bb", "ppa", "own", "pad", "txt", "image", "xt", "html", "b", "mp", "cmp", "cp", "term", "tc", "fb", "bt", "bp", "part", "pos", "sb", "output", "py", "stuff", "zip", "not", "tt", "videos", "rb", "template", "attr", "meta", "test", "lab", "tab", "cb", "temp", "chart", "metadata", "api", "src", "config", "media", "ff", "wp", "kk", "db", "video", "po", "v", "amp", "qt", "obj", "params", "sup", "app", "sp", "proc", "ext", "nb", "pp", "fp", "p", "tp", "img", "cop"], "video_id": ["voice_bid", "video___id", "voice_type", "video_name", "videoFlowident", "media_id", "voice_length", "video_ID", "voice_name", "videoFlowname", "media_type", "video_ident", "video_length", "video___name", "video___ID", "voiceFlowident", "video__id", "video_ids", "video__type", " video_ID", "videoFlowtype", "voice_id", "voiceFlowname", " video_ids", "voiceFlowtype", "video__ids", " video_name", "media_ids", "video___ids", "video_type", "videoFlowid", "voice_ident", "video_bid", "voiceFlowid"], "t": ["at", "m", "text", "txt", "e", "tip", "xt", "g", "b", "term", "ot", "tm", "part", "pt", "f", "tt", "trial", "ta", "template", "the", "test", "type", "tf", "s", "h", "T", "time", "y", "a", "l", "target", "id", "token", "string", "tp", "v", "c", "qt", "name", "ts", "p", "dt"], "title": ["ppa", "page", "description", "text", "doc", "unit", "itle", "tip", "resource", "html", "het", "body", "term", "summary", "version", "duration", "part", "pt", "translation", "template", "meta", "type", "tf", "test", "code", "te", "yt", "api", "media", "filename", "license", "target", "alt", "artist", "id", "video", "Title", "desc", "qt", "alpha", "detail", "name", "sl", "content", "front", "format", "pretty", "note", "label", "plot", "p"], "i": ["k", "m", "p", "uri", "e", "j", "l", "g", "b", "fi", "init", "ori", "io", "info", "si", "ie", "f", "ni", "it", "iv", "index", "d", "ci", "iu", "oi", "key", "uni", "multi", "y", "api", "li", "di", "cli", "mi", "ip", "pi", "xi", "hi", "inner", "slice", "eni", "yi", "id", "vi", "ti", "gi", "v", "ix", "I", "ai", "zi", "phi", "ini", "ii", "ui", "mu", "qi", "x", "q", "ri"], "ytTitle": ["gtTitle", "rtFilename", "ttData", "gtData", "rtData", "rtExt", "ttTitle", "ttFilename", "rtTitle", "ytFilename", "ttExt", "ytExt", "gtExt", "ytData", "gtFilename"]}}
{"id1": "22479286", "id2": "17158020", "code1": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"md5": ["md512", "MD4", "sha2", "md2", "m5", "m512", "m2", "MD512", "md4", "MD2", "sha512", "MD5", "sha5", "m4", "sha4"], "plainText": ["publictext", "plainString", "plainSecret", "singleText", " plainValue", " plainWidth", "extraByte", "encryptedText", "publicKey", "messageContent", "singleTEXT", " plainSecret", "flatWidth", "coreContent", "plaintext", "flatString", " plainByte", "regularCode", " plainCode", "plainValue", "regularSecret", "messageText", "coreText", "publicContent", "regularString", " plainKey", "flatText", "singleWidth", "regularText", " plainTEXT", "plainCode", "plainTEXT", "rubyContent", "regularShort", "messageSecret", "publicText", "flatTEXT", " plaintext", "encryptedContent", "messageCode", "extraContent", "plainKey", "publicTEXT", "plainShort", "encryptedtext", " plainShort", "regulartext", " plainString", "rubyValue", "flatShort", "plainWidth", "coreTEXT", "plainByte", "rubyText", " plainContent", "flattext", "rubyByte", "coreValue", "extraTEXT", "rubyTEXT", "extraText", "encryptedTEXT", "regularContent", "flatKey", "plainContent"], "md": ["df", "mb", "mp", "mg", "pd", "ms", "pm", "mand", "rm", "mac", "Cmd", "m", "sm", " MD", "d", "sha", "hm", "MD", "bd", "meta", "wd", "hd", "ad", "dd", "mc", "gb", "cd", "mod", "cmd", "mag", "f", "am", "dm", "hash", "amd", "rpm", "dig", "mm", "de", "metadata", "vd", "message", "mt", "me", "mo"], "digest": ["dedest", "dedex", "dimex", "dimEST", "dested", "mdest", "digex", "Digester", "Digested", "compit", "compest", "compEST", "digitester", "digitest", " digEST", "digested", "digester", "dest", "DigEST", "mdit", " digester", " digested", "dimested", "mdger", "Digit", "dedEST", "digEST", "digitEST", "Digger", "dimest", "digitested", "dester", "digger", "dEST", "digit", "Digest", "compger", "mdEST", "Digex", "dedested"], "hexString": ["rawArray", "tempstring", "stringSingle", "stringString", "hexSingle", "exText", " hexSingle", "hexstring", "tempBuffer", "exString", "exService", "exContent", "rawString", "exstring", "longText", " hexstring", "tempService", "hexContent", "longService", " hexBuffer", " hexText", "hexArray", "hexBuffer", " hexArray", "hexService", "stringArray", " hexService", "tempString", "longString", "exBuffer", " hexContent", "rawBuffer", "rawSingle", "longContent", "hexText", "stringBuffer"], "i": ["si", "qi", "u", "at", "multi", "n", "ii", "c", "m", "pi", "k", "o", "d", "ci", "di", "io", "z", "number", "slice", "ui", "in", "length", "ri", "bi", "count", "p", "it", "l", "part", "phi", "s", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "start", "v", "gi", "ti", "type", "ai", "b", "xi", "t", "id", "info", "uri", "mu", "end"]}}
{"id1": "10383721", "id2": "15516136", "code1": "    @SuppressWarnings(\"unchecked\")\n    private ReaderFeed processEntrys(String urlStr, String currentFlag) throws UnsupportedEncodingException, IOException, JDOMException {\n        String key = \"processEntrys@\" + urlStr + \"_\" + currentFlag;\n        if (cache.containsKey(key)) {\n            return (ReaderFeed) cache.get(key);\n        }\n        List<Post> postList = new ArrayList<Post>();\n        URL url = new URL(urlStr);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Cookie\", \"SID=\" + sid);\n        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"UTF-8\"));\n        SAXBuilder builder = new SAXBuilder(false);\n        Document doc = builder.build(reader);\n        Element root = doc.getRootElement();\n        Namespace grNamespace = root.getNamespace(\"gr\");\n        Namespace namespace = root.getNamespace();\n        String newflag = root.getChildText(\"continuation\", grNamespace);\n        String title = root.getChildText(\"title\", namespace);\n        String subTitle = root.getChildText(\"subtitle\", namespace);\n        List<Element> entryList = root.getChildren(\"entry\", namespace);\n        DateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n        for (Element e : entryList) {\n            Post post = new Post();\n            post.setTitle(e.getChildText(\"title\", namespace));\n            try {\n                post.setDate(sdf.parse(e.getChildText(\"published\", namespace)));\n            } catch (ParseException e1) {\n            }\n            post.setUrl(e.getChild(\"link\", namespace).getAttributeValue(\"href\"));\n            post.setSauthor(e.getChild(\"author\", namespace).getChildText(\"name\", namespace));\n            String content = e.getChildText(\"content\", namespace);\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"description\", namespace);\n            }\n            if (StringUtils.isEmpty(content)) {\n                content = e.getChildText(\"summary\", namespace);\n            }\n            post.setContent(content);\n            postList.add(post);\n        }\n        ReaderFeed readerFeed = new ReaderFeed();\n        readerFeed.setTitle(title);\n        readerFeed.setSubTitle(subTitle);\n        readerFeed.setFlag(newflag);\n        readerFeed.setPostList(postList);\n        cache.put(key, readerFeed);\n        return readerFeed;\n    }\n", "code2": "    public static synchronized BufferedImage loadBufferedJPEGImage(URL url) {\n        BufferedImage image = null;\n        if (url != null) {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(in);\n                image = decoder.decodeAsBufferedImage();\n            } catch (Exception e) {\n                log.severe(\"URL: \" + url + \" - \" + e.getMessage());\n                image = null;\n            } finally {\n                try {\n                    if (in != null) in.close();\n                } catch (IOException ioe) {\n                    log.severe(\"URL: \" + url + \" - \" + ioe.getMessage());\n                }\n            }\n            if (image != null) {\n                log.config(\"Image type : \" + image.getType());\n                if (image.getWidth() <= 0 || image.getHeight() <= 0) {\n                    log.severe(\"URL: \" + url + \" =0\");\n                    image = null;\n                }\n            }\n        }\n        return image;\n    }\n", "label": 0, "substitutes": {"processEntrys": ["processDistriers", "processDistris", "processENTrings", "processEntris", "processEllriers", "runEntris", "processEllrys", "processEntriers", "processEllrings", "processDistrys", "processENTris", "runENTrys", "processEllris", "runEntriers", "processEntrings", "runENTris", "processDistrings", "processENTriers", "runENTrings", "runEntrys", "runENTriers", "runEntrings", "processENTrys"], "urlStr": ["uriStr", "URLSTR", "UrlStr", "httpSTR", "urlSTR", "urlString", "uriString", "httpStr", "filestr", " urlstr", "resourceSTR", " urlString", "urlstr", "uriSTR", "httpstr", "UrlSTR", "urlSt", "Urlstr", "httpString", "URLString", "resourcestr", "fileSTR", "fileStr", " urlSTR", "resourceString", " urlSt", "URLSt", "uriSt", "URLStr", "resourceStr"], "currentFlag": ["currentBit", "currentTag", "nextflag", "nextTag", " currentText", "currentField", "activeTag", " currentField", "activeFLAG", "CurrentBit", "nextFlag", "CurrentText", "reportedText", "reportedBit", "activeflag", " currentBit", "CurrentFLAG", "reportedField", "reportedFlag", "currentflag", "activeFlag", "CurrentField", "CurrentFlag", "nextFLAG", "currentFLAG", "currentText", "CurrentTag", "Currentflag"], "key": ["full", "msg", "lock", "data", "name", "point", "roy", "type", "method", "seed", "k", "field", "lease", "str", "ie", "base", "rule", "here", "match", "cache", "KEY", "text", "check", "part", "section", "mac", "query", "ace", "secret", "kid", "list", "step", "entry", "service", "value", "or", "path", "parent", "hash", "sign", "empty", "keys", "scope", "function", "id", "search", "prefix", "message", "fix", "ey", "ry", "fee", "exp", "string", "Key"], "postList": [" postlist", "postlist", "postGroup", "PostCollection", "Postlist", "POSTList", "PostList", "POSTlist", "postCollection", " postGroup", " postCollection", "POSTCollection", "POSTGroup", "PostGroup"], "url": ["sl", "director", "data", "loc", "org", "socket", "channel", "ur", "web", "base", "ssl", "log", "page", "conn", "cache", "text", "l", "client", "address", "Url", "service", "URL", "entry", "image", "build", "feed", "proxy", "path", "server", "uri", "http", "file", "www", "resource", "host", "link", "location", "string"], "connection": ["open", "director", "version", "machine", "channel", "socket", "handler", "database", "remote", "creator", "body", "to", "application", "position", "conn", "b", "wrapper", "section", " Connection", "l", "writer", "collection", "password", "client", "proxy", "connected", "URL", "condition", "connect", "response", "object", "character", "config", "document", "relation", "uri", "server", "number", "io", "http", "c", "function", "resource", "con", "out", "directory", "Connection", "communication"], "reader": ["iter", "er", "f", "data", "channel", "handler", "stream", "body", "xml", "per", "loader", "r", "writer", "parser", "client", "row", "buffer", "entry", "oder", "feed", "driver", "document", "read", "server", "reading", "io", "file", "resource", "input", "ler", "Reader", "editor"], "builder": ["er", "manager", "database", "building", "creator", "info", "xml", "base", "b", "loader", "bridge", "wrapper", "keeper", "builders", "r", "writer", "bug", "parser", "bean", "client", "row", "buffer", "entry", "build", "image", "db", "driver", "or", "editor", "Builder", "default", "config", "document", "http", "result", "runner"], "doc": ["doctor", "open", "app", "df", "f", "data", "tree", "git", "body", "Doc", "info", "div", "str", "xml", "ger", "gen", "base", "text", "r", "writer", "bug", "parser", "dr", "md", "dc", "d", "lib", "build", "db", "project", "context", "document", "file", "resource", "coll", "dir", "docs", "html", "graph", "node"], "root": ["data", "name", "archive", "container", "creator", "div", "roots", "section", "path", "default", "null", "rt", "owner", "html", "element", "tree", "error", "sys", "Root", "page", "inner", "front", "query", "rew", "back", "project", "parent", "outer", "document", "author", "result", "record", "home", "leaf", "node", "director", "ver", "remote", "first", "xml", "component", "nav", "loader", "r", "writer", "parser", "rup", "n", "empty", "http", "valid", "rss", "manager", "master", "head", "body", "zero", "bot", "rec", "top", "box", "user", "article", "comment", "entry", "db", "child", "ree", "server", "scope", "right", "cover", "string"], "grNamespace": ["grnamespe", "grNamesche", "GrNamespace", "Grnamespe", "grnamespace", "grMemberspaces", "grNamespe", "grMembersche", "grNamespaced", "Grnamescape", "grMemberspace", "grNamescape", "grnamescape", "Grnamespaces", "GrNamescape", "grnamespaced", "Grnamespace", "GrNamespaced", "grNamespaces", "grnamespaces", "GrNamespe", "GrNamesche", "grnamesche", "grMemberspaced", "GrNamespaces"], "namespace": ["workspaces", "namespec", "kesase", " namespaces", "namescape", "Namesase", "New", "kespaced", " namespaced", "Namespec", "Namespaces", " namespect", "nameternal", "inasspace", "workspect", "Namesternal", "Namespect", " namesception", " namespec", "Namesace", "Namescore", "Namescape", "namespect", "memberspace", " Namespaced", "technpace", "namesception", " Namespec", "namescore", "membersspace", "Namespaced", "membersternal", "namesase", "namespaced", "_", "memberscore", "xml", "add", "memberspaces", " Namespaces", "inaspace", "namesace", " namesspace", "this", "Namesspace", "namespaces", "feed", "memberscape", "http", "Namesception", " namescore", " namesternal", " namesace", " namescape", "namesternal", "kespace", "s", "namecape", "Namespace", " Namespace", "worksception", "namesspace", "namepace", "membersace", " namesase", "workspace", "inasace", "technspace", "nameception", "inasternal", "namepaces"], "newflag": ["lnstyle", " newStatus", " newstyle", "newStatus", "nextflag", " newFlag", "nextstyle", "newFlag", "nextStatus", "lnStatus", "lnFlag", "newstyle", "nextFlag", "lnflag"], "title": ["name", "version", "type", "body", "Title", "label", "summary", "format", "description", "itle", "text", "term", "subject", "Content", "published", "template", "itles", "filename", "author", "details", "message", "header", "resource", "html", "license"], "subTitle": ["ubTitle", " subtitle", "subName", "ubtitle", "SubTitle", " subName", "ubName", "SubName", "Subtitle", " subDescription", "subtitle", "ubDescription", "SubDescription", "subDescription"], "entryList": ["entrylist", "elementList", "ziplist", "entryLIST", "zipList", " entryQueue", "elementQueue", " entryChain", " entryL", "zipLIST", "tryList", "elementChain", "trylist", "tryChain", "elementlist", "postlist", "zipL", "entryChain", "entryL", "postL", " entryLIST", " entrylist", "postLIST", "tryQueue", "entryQueue"], "sdf": ["ssdd", "sdd", " sde", "rsdd", "ssde", "rsdf", "asdd", "scf", "asdf", "psde", "psdd", "sde", "Sdf", " scf", "psdf", "Sfd", "Sdd", "rsfd", "asde", "rsde", "ascf", "pscf", " sdd", "ssfd", "Sde", "ssdf", "sfd"], "e": ["be", "le", "er", "f", "y", "oe", " pe", "edge", "ze", "el", "m", "ente", "p", "j", "se", " event", "ge", "one", " entity", "ae", "en", "ec", "eb", "event", "me", "ie", " me", " E", "entity", "je", "r", "l", "line", "E", "o", "d", " element", "entry", "ne", "i", " ie", "t", "Element", "enter", "te", "n", "pse", "c", "eu", "ce", "ele", "ed", "ve", "ea", "de", "esi", "ee", "end", "element", "node"], "post": ["get", "edit", "archive", "posted", "head", "create", "tax", "install", "p", "one", "wp", "load", "set", "add", "copy", "page", "check", "user", "text", "part", "op", "article", "pre", "posts", "patch", "row", "list", "comment", "entry", "style", "feed", "child", "project", "mod", "Post", "POST", "object", "cross", "next", "form", "system", "default", "read", "server", "pass", "author", "the", "index", "valid", "upload", "result", "ost", "record", "link", "home", "draw", "push", "pod", "maybe", "node"], "content": ["data", "name", "version", "archive", "language", "body", "status", "summary", "description", "page", "text", "output", "size", "Content", "source", "image", "template", "value", "path", "comments", "code", "file", "draft", "script", "message", "resource", "header", "media"]}}
{"id1": "19912848", "id2": "6682825", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    KeyStore getKeyStore() throws JarSignerException {\n        if (keyStore == null) {\n            KeyStore store = null;\n            if (providerName == null) {\n                try {\n                    store = KeyStore.getInstance(this.storeType);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                try {\n                    store = KeyStore.getInstance(storeType, providerName);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                } catch (NoSuchProviderException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (storeURI == null) {\n                throw new JarSignerException(\"Cannot load the keystore \" + \" error con el keystore\");\n            }\n            try {\n                storeURI = storeURI.replace(File.separatorChar, '/');\n                URL url = null;\n                try {\n                    url = new URL(storeURI);\n                } catch (java.net.MalformedURLException e) {\n                    url = new File(storeURI).toURI().toURL();\n                }\n                InputStream is = null;\n                try {\n                    is = url.openStream();\n                    store.load(is, storePass);\n                } finally {\n                    if (is != null) {\n                        is.close();\n                    }\n                }\n            } catch (Exception e) {\n                throw new JarSignerException(\"Cannot load the keystore \" + storeURI, e);\n            }\n            keyStore = store;\n        }\n        return keyStore;\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "20735941", "id2": "7425022", "code1": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"getFile": ["newFile", "openFiles", "getfile", "createResource", "getFiles", "openfile", "getResource", "newResource", "openFile", "newFiles", "createFile", "createfile", "createFiles", "openResource", "newfile"], "home": ["f", "family", "Home", "name", "first", "HOME", "base", "library", "log", "class", "user", "house", "include", "domain", "root", "plus", "back", "this", "bar", "build", "project", "path", "parent", "h", "hub", "default", "store", "server", "owner", "up", "folder", "search", "resource", "www", "dir", "host", "join", "directory", "location", " HOME"], "fileName": ["FilePath", "fullPath", "fileType", " fileType", "FileType", "resourcePath", "FileNum", "singleType", "remoteUrl", "urlName", "fullname", "remoteName", "urlNum", " filePart", "filePart", " fileUrl", "Filename", "FilePart", " filePath", "singlePath", "fullPart", "urlname", "fileUrl", "filePath", "remotePath", "filename", " fileNum", "fileNum", "singleName", "resourceName", "fullName", "resourceUrl", "FileName", "urlPath", " filename", "singlename"], "file": ["be", "job", "full", "connection", "le", "lock", "f", "data", "get", "name", "it", "File", "current", "place", "handler", "play", "type", "table", "el", "fe", "local", "letter", "class", "base", "log", "model", "plain", "rule", "part", "user", "output", "zip", "l", "work", "line", "e", "buffer", "lib", "source", "run", "image", "db", "child", "ile", "money", "feed", "path", "parent", "object", "live", "filename", "or", "store", "uri", "http", "up", "function", "folder", "resource", "FILE", "fp", "dir", "use"], "url": ["job", "connection", "sl", "f", "data", "loc", "name", "org", "socket", "ur", "el", "web", "download", "base", "rule", "ource", "ls", "bb", "log", "page", "b", "ssl", "conn", "zip", "l", "r", "fr", "address", "pull", "Url", "service", "URL", "source", "i", "lib", "feed", "api", "image", "path", "object", "lr", "uri", "server", "io", "http", "impl", "resource", "www", "coll", "host", "location", "rl", "string", "ob", "il"], "in": ["reader", "bin", "isin", "login", "f", "data", "into", "socket", "s", "ins", "stream", "In", "is", "inside", "b", "inner", "again", "r", "l", "line", "IN", "e", "plus", "din", "pull", "ini", "i", "source", "init", "image", "inc", "n", "io", "inn", "c", "up", "as", "a", "lin", "resource", "input", "ac", "gin"], "out": ["bin", "ext", "data", "socket", "sync", "to", "ex", "outs", "In", "plain", "base", "is", "copy", "conn", "b", "again", "output", "inner", "line", "writer", "serv", "err", "flow", "o", "client", "IN", "OUT", "this", "i", "source", "init", "inc", "exec", "object", "null", "io", "net", "up", "co", "resource", "exp", "Out", "write"]}}
{"id1": "9236363", "id2": "16825994", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"unJarStart": ["syncServerPath", "copyJarPath", "copyJarStart", "copyjarRest", "syncServerRest", "syncJarRest", "copyJarEnd", "copyServerRest", "copyjarEnd", "copyServerPath", "copyjarPath", "syncJarEnd", "copyJarRest", "copyZipRest", "syncJarStart", "copyjarStart", "copyServerEnd", "copyServerStart", "copyZipStart", "copyZipEnd", "syncServerEnd", "syncServerStart", "copyZipPath", "syncJarPath"], "jarPath": ["relEntry", "Jarpath", "jarLog", "jarText", "zipPath", "jamLog", "zippath", "archivePath", " jarpath", "javaPath", "jamPath", "javaCh", "jarName", " jarText", "JarName", "narCh", "jarContent", " jarContent", " jarUrl", "garText", "JarFile", "relFile", "archivepath", "javaFile", "badPath", "jarpath", "garUrl", "javaName", "badLog", "jarFile", "JarCh", "narPath", "javaText", " jarLog", "garPath", " jarFile", " jarDir", "javaEntry", "garFile", "javaUrl", "jarUrl", "jarCh", "archiveDir", "javapath", " jarName", "badpath", "javaLog", "badUrl", "archiveLog", "zipEntry", "zipFile", "jampath", "garpath", "narpath", "JarContent", "garContent", "jamDir", "relpath", "narName", "JarPath", "jarDir"], "jarEntryStart": ["jarEntSource", " jarEntryFollow", "jarEntPart", "jarEntryName", " jarImportStart", "tarEntryPart", "jarFileSource", " jarFileStart", "jarFileName", "jarImportPart", "jarEntryPart", "jarEntrySource", "jarEntStart", " jarFilePart", " jarEntrySource", "jarFileStart", " jarEntryEnd", "jarEntName", "jarFileFollow", " jarImportPart", "jarEntryFinish", "jarentryName", "jarFileEnd", "jarImportName", "jarentryStart", "tarentryName", "jarEntryFollow", "jarAttemptStart", "tarEntrySource", "jarEntryEnd", "jarImportStart", " jarFileEnd", "jarAttemptPart", "tarEntryStart", " jarFileFinish", "jarImportFollow", " jarImportEnd", "jarAttemptFollow", "jarentrySource", "jarFileFinish", " jarFileName", "jarImportFinish", " jarEntryFinish", "jarentryPart", "tarentryStart", "jarAttemptEnd", "jarFilePart", "tarentrySource", " jarImportFollow", "jarPartStart", "jarImportSource", "tarentryPart", "jarPartFinish", " jarFileSource", " jarEntryName", " jarEntryPart", "jarImportEnd", "jarPartEnd", "jarPartPart", "tarEntryName"], "path": ["zip", "then", "root", "base", "temp", "output", "resource", "patch", "host", "content", "default", "file", "archive", "context", "conn", "graph", "it", "mount", "url", "PATH", "ph", "step", "string", "id", "clean", "location", "next", "source", "cache", "dir", "ion", "ath", "work", "parent", "route", "object", "test", "name", "th", "left", "cookie", "boot", "directory", "uri", "json", "Path", "inner", "system", "mode", "dest", "wd", "session", "request", "p", "template", "image", "prop", "method", "error", "api", "pass", "key", "pattern", "type", "config", "data", "text", "log", "folder", "po", "home", "ha", "pointer", "prefix", "ctx", "ith", "right", "code", "loc"], "relPath": ["RelPath", "relativeDir", " relName", "RELPath", "RELpath", "Relpath", " relPos", " relDir", "RELPos", "relPos", "relativepath", "relDir", "RelName", "relativePath", "RelDir", "relativePos", "relName", "RELName", " relpath", "relpath", "relativeName"], "jar": ["zip", "ssl", "pkg", "her", " tar", "server", "mag", "drop", "fire", " manifest", "per", "ge", " parser", "java", "tar", " java", " capsule", "jo", " dir", "dr", "sheet", "zone", "keeper", "magic", "ler", "bag", " archive", "er", " war", "bar", "Jar", "cache", "tab", "dir", "browser", "sr", "open", "pipe", "war", "archive", " module", "rar", "log", "plugin", "ball", "folder", "start", "pack", "car", "sl", "spin", "url", "com", "ser", "parse", "sp", "cookie", "gap", "xml", "ar", "module", "space"], "entries": ["entryers", "countries", "ENTlements", "antlements", "countEntry", "addries", "entrys", "ientlements", "Entursions", "adders", "endories", "antursions", "entryensions", "entEntry", "quries", "entensions", "Entry", "entursions", "itrys", "iters", "counters", "Entrys", "Entries", "addensions", "quies", "endries", "antry", "endrys", "itries", "ENTies", "entlements", "countensions", "Entories", "enters", "qulements", "enties", "addEntry", "Entlements", "itories", "Entents", "ENTries", "entories", "Enters", "entryries", "ientry", "antries", "enders", "ENTents", "ientursions", "ientries", "entents", "entryEntry", "quents", "Enties"], "entry": ["zip", "ry", "address", "server", "resource", "be", "add", "ie", "ge", "se", "jo", "ries", "Entry", " Entry", "key", "ler", "la", "pie", "ent", "part", "reader", "ce", "module", "je", "r", "cat", "de", "or", "cel", "name", "e", "lie", "pack", "it", "parse", "mer", "obj", "oe", "element", "enter"], "jarEntry": ["jarentry", "jobentry", "carEnt", "serName", "jarName", "javaPath", "archiveEntry", "jarRule", "archiveElement", "archiveName", "archiveEnt", "celFile", "jobEntry", "jobPath", "javaFile", "serEntry", "javaElement", "javaName", "jarFile", " jarImport", " jarEnt", "javaEntry", "jobImport", "javaImport", "archiveRule", "javaentry", "jarEnt", "carEntry", "carPath", "serElement", " jarentry", "jarImport", "javaRule", "javaEnt", "serFile", "carElement", "celEntry", " jarElement", "celRule", "celEnt", "archiveFile", "jarElement"], "ze": ["zip", "fe", "zer", "ipe", "ke", "be", "zes", "zy", "ie", "kee", "ge", "z", "se", "aze", "jo", "ide", "te", "ine", " ace", "za", "ja", "ce", "je", "li", "ZE", "le", " je", "ne", "cel", "xe", "e", "zi", "sl", "pe", "zo", "zen", "code", "zie"], "bin": ["zip", "index", "info", "base", "sin", "pin", "bis", "resource", "lock", "ini", "inner", "abin", "arin", "zone", "in", "bar", "binary", "lib", "proxy", "login", "len", "bas", "data", "file", "body", "vin", "bb", "log", "bi", "bank", "init", "plugin", "bn", "bit", "isin", "kin", "gi", "di", "spin", "bot", "abi", "cin", "inn", "win", "boot"]}}
{"id1": "13596891", "id2": "21152728", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "label": 0, "substitutes": {"doTransfer": ["handleSend", "handleImport", " doSend", "doSend", "handleTransfer", "handleRequest", "makeImport", "doRequest", " doImport", " doRequest", "makeRequest", "makeTransfer", "doImport", "makeSend"], "request": ["enter", "req", "subject", "resource", "message", "server", "report", "complete", "connection", "requ", "form", "remote", "event", "data", "version", "this", "session", "in", "application", "model", "result", "input", "Request", "type", "rf", "xml", "instance", "time", "QUEST", "create", "reader", "config", "client", "record", "stream", "command", "user", "queue", "object", "position", "re", "context", "query", "condition", "current", "q", "http", "post", "received", "com"], "response": ["warning", "resp", " Response", "page", "res", "writer", "respond", "default", "report", "resource", "server", "message", "image", "call", "view", "Response", "connection", "body", "en", "remote", "event", "version", "session", "output", "application", "status", "document", "result", "site", "model", "reply", "index", "error", "out", "results", "client", "header", "object", "cache", "success", "re", "service", "full", "next", "cover", "json", "content", "http", "serv", "onse"], "method": ["prefix", "METHOD", "text", "description", "direction", "subject", "resource", "message", "call", "cmd", "term", "reason", "version", "session", "verb", "status", "mode", "route", "sort", "Method", "date", "type", "process", "time", "class", "pull", "command", "sign", "send", "position", "string", "property", "path", "json", "content", "format", "head", "use", "callback", "hod"], "servletContext": ["ServletsController", "ServletContext", "servletscontext", "servletsContext", "servleContext", " servletConfig", " servantContext", "servLETProvider", "servletProvider", "servletCurrent", "ServletConfig", "servletConfig", " servantCurrent", "servleProvider", " servantProvider", "servletcontext", "servLETCurrent", "servantContext", "servletsController", "servleCurrent", " servantConfig", "servApplicationcontext", "Servletcontext", "servletsConfig", "servleConfig", "servletController", "servApplicationConfig", "servlexController", "ServletController", "ServletsContext", " servletProvider", "servApplicationController", "Servletscontext", "servantProvider", "servlexConfig", "servlexContext", "ServletsConfig", " servletCurrent", "servLETConfig", "servApplicationContext", "servlexcontext", "servLETContext", "servantConfig", "servantCurrent"], "wac": ["wae", "wsAC", " Wae", "wAC", "wacs", " Wac", " wae", " WAC", " wAC", " Wacs", " wacs", "wsae", "wsacs", "wsac"], "szUrl": ["szeurl", "szenURL", "szeUrl", "asizFrame", " sizFolder", "aszURL", "szurl", "sziUrl", "sznURL", "aszUrl", "aszPath", "sziURL", "szenFolder", "asizPath", "szerFrame", "szeURL", "szerUr", "szPath", "szaUrl", "aszUr", " sizURL", "szenUrl", " szurl", "szerUrl", "asizurl", "sznUrl", "szFolder", "szerURL", "sizPath", "sizurl", "sziurl", " sizurl", "sizURL", "sznurl", "szeFrame", "sznPath", "szUr", "szURL", "sziUr", "sizUrl", "szeUr", "asizUr", "szFrame", "szenurl", "sizFolder", "sizUr", " szFolder", "sznUr", "szaUr", "asizUrl", " szURL", "sizFrame", "aszFrame", " sizUrl", "aszurl", "szaURL", "asizURL", "szaPath", "szeFolder"], "url": ["ur", "page", "log", "fl", "uri", "ssl", "resource", "ll", "server", "connection", "loc", "rel", "il", "ul", "org", "event", "lb", "socket", "cloud", "impl", "f", "www", "URL", "key", "el", "conn", "xml", "source", "config", "rl", "li", "client", "web", "l", "stream", "base", "user", "string", "gl", "file", "obj", "name", "re", "service", "sl", "host", "context", "location", "Url", " URL", "get", "buffer", "http"], "is": [" are", "uri", "rx", "isl", "isi", "rc", "os", "lis", "il", "io", "info", "iso", "oss", " bis", "it", " isn", "bis", "IS", "isc", "us", "ci", "ios", "i", "src", "cms", "im", "web", "ip", "ib", "ils", "iss", "isf", "ir", "ais", "ris", "has", "Is", "ai", "ii", "as", "x", "isa", "was", "bs", "serv", "ri", "isu"], "sout": ["Sout", "sOut", " souts", "SOut", " sOut", "sin", "souts", " sin", "Sdata", "Souts", "sdata", "Sin", "SOUT", " sOUT", " sdata", "sOUT"], "con": ["conv", "java", "un", "cn", "core", "const", "wan", "view", "CON", "single", "bc", "fa", "cl", "nc", "conn", "ver", "win", "l", "min", "internal", "xc", "cache", "pc", "exec", "wa", "net", "pre", "query", "non", "on", "ocon", "pen", "com", "m", "crit", "Internal", "server", "uc", "cp", "connection", "en", "rc", "remote", "event", "version", "inc", "func", "syn", "status", "coll", "type", "cc", "ctrl", "can", "c", "ctx", "cf", "lc", "ca", "close", "util", "gen", "ct", "general", "Common", "ran", "run", "cur", "don", "co", "web", "login", "user", "re", "pin", "common", "http", "san", "open", "cons", "subject", "ssl", "C", "conf", "Con", "cos", "ec", "Connection", "connect", "client", "fun", "fc", "get", "ren", "author", "fe"], "hNames": ["hrKeys", " hFiles", "HBlocks", "hostNs", "HFiles", "HNames", "hName", "HVs", "ihVs", " hBlocks", "hostNames", "HTypes", " hName", "hrFiles", "hostTypes", "ihNames", "hBlocks", "hKeys", "hNs", "hrName", "hVs", "hrNames", "hrNs", "ihBlocks", "ihName", "HName", "hostKeys", " hKeys", "hTypes", "hrTypes", " hNs", " hTypes", " hVs", "hFiles"], "txt": ["prot", "text", "ct", "rx", "wt", "xt", "struct", " text", "sv", "tin", "bt", "htm", "inet", "csv", "tx", "in", "phrase", "kt", "py", "ht", "zip", "str", "elt", "nt", "XT", "gt", "key", "nm", "cb", "utt", "vt", "wx", "section", "header", "rr", "fx", "TEXT", "et", "lv", "v", "gi", "qt", "obj", "gz", "name", "xxx", "t", "binary", "ctx", "value", "git", "jp", "q", "lt", "fp", "dt", "Text"], "inBody": ["inbody", "insBody", "InFile", " inReader", "InStream", " inStream", "INbody", "Inbody", "insFile", "inReader", "inStream", "INStream", "InBody", "INReader", "insStream", "inFile", " inFile", "InReader", "outStream", "insReader", "INBody", "INFile", " inbody", "outFile", "outBody", "outbody"], "bufCh": [" bufChar", "bufChar", "buffch", "queueCh", "queueCH", "ufCol", " bufCH", "bufCH", " bufC", "bufC", "buffCh", "bufCol", "bufferch", "buffCH", "ufChar", "bufch", "ufC", "buffC", " bufch", "bufferCH", "queuech", " bufCol", "bufferChar", "queueCol", "ufCH", "ufCh", "bufferCh", "ufch"], "r": ["k", "m", "rt", "p", "res", "u", "fr", "R", "e", " rg", "ru", "b", "g", "n", "nr", "rc", "rs", "rh", "ner", "reg", "range", "f", "result", "str", "d", "rb", "rg", "rf", "rw", "i", "pr", "reader", "rl", "ar", "er", "rr", "lr", "br", "v", "c", "err", "re", "rd", "sr", "w", "hr", "ror", "x", "q", "cr", "ri"], "outReq": ["outREq", "outSeque", "outRequest", " outRece", "outRreq", " outReh", "outRck", " outRq", "outDeque", " outRsque", "outREque", "outEreq", "outRece", "outSeck", " outRereq", "outREce", " outReque", " outRsce", " outEreq", " outReck", " outRque", " outRsh", "outRecq", " outRce", "outRecce", " outRsq", "outEck", " outEq", "outSequest", "outSece", "outRecreq", " outRquest", "outREh", "outReh", "outSeq", " outRequest", " outSeque", " outSeck", "outConque", "outRsce", "outEque", "outDece", "outRce", "outReck", "outRsq", "outREck", " outSeq", "outRsque", "outRquest", "outReque", "outDequest", "outRecque", "outConq", "outRq", "outEq", " outEque", "outConh", " outSece", "outConce", "outRque", "outRsh", "outRereq", "outDeq", " outEck", "outRecck"], "buff": ["buf", "uf", "p", "array", "b", "Info", "num", "info", "data", "Buffer", "f", "map", "ch", "lines", " chunk", "Buff", "Pad", " buffers", "Msg", "file", " Buff", " Buffer", "buffer", "bb", "Ptr"]}}
{"id1": "17475530", "id2": "19251426", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkFromImage", "testAddLinkToFile", "testAddLinkFromPicture", "testAddLinkstoImage", "testAddLinkstoFile", "testAddLinkOfFile", "testAddLinkToLink", "testAddLinkOfLink", "testAddLinkstoLink", "testAddLinktoImage", "testAddLinkOfPicture", "testAddLinkFromLink", "testAddLinktoPicture", "testAddLinktoLink", "testAddLinkFromFile", "testAddLinkToPicture", "testAddLinksToPicture", "testAddLinksToLink", "testAddLinktoFile", "testAddLinkOfImage", "testAddLinksToFile", "testAddLinkstoPicture", "testAddLinksToImage"], "in": ["ini", "image", "err", "index", "resource", "login", "serv", "stream", "gin", "inn", "val", "input", "with", "din", "In", "at", "version", "exp", "bin", "conn", "pin", "r", "IN", "again", "pass", "token", "path", "work", "doc", "nin", "uri", "cin", "diff", "min", "out", "ins", "is", "xml", "as", "socket", "ssl", "name", "ac", "con", "data", "file", "isin", "rin", "ax", "id", "el", "ex", "i", "win", "reader", "n", "get", "or", "connection", "m", "source", "exec", "f", "url", "inc", "copy"]}}
{"id1": "14819747", "id2": "9319440", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 0, "substitutes": {"debug": ["enabled", "doc", "log", "DEBUG", "console", "play", "module", "details", "build", "remote", " debugger", " debugging", "tag", " DEBUG", "depth", "store", "die", "reg", "display", "enable", "status", "error", "dev", "date", "test", "plugin", "progress", "trace", "comment", "config", " Debug", "print", "develop", "github", "dump", "Debug", "db", "ger", "quiet", "export", "cache", "show", "file", "err", "development", "admin", "help", "root", "bug", "production", "real", "active"], "prologFile": ["PrologModule", " problogFull", "Prologfile", " prologfile", "deflogSourceFile", "prologPath", " proLogHeader", "prolexModule", "defLogFILE", "problogDir", " proLogFiles", "problogFull", "proconfigFile", "procatFile", "prologSource", "ProLogString", "prolangSourceFile", "proLogFILE", "problogHeader", "proLogfile", "rologPath", "roLogPath", " problogfile", "ProLogModule", "prolangfile", "procatPath", "prollPath", "prollFile", "proLogFiles", "propathFile", "prologHeader", "procatfile", "rologfile", "problogfile", "deflogFILE", "defblogFile", "problogStream", "probaseFiles", "prologSourceFile", "PrologFile", "proconfigModule", "proLogHeader", "rologFile", "rologSource", "prologFull", "proLogFull", "proLogStream", "procatSource", "prolexfile", "prollfile", " problogFile", "proLogSource", "probaseFile", "prologDir", " proLogFile", "proconfigString", "defLogPath", "proLogFile", "defblogDir", "proflowSourceFile", "prolexString", " proLogStream", "propathfile", "deflogDir", " prologSourceFile", "defblogfile", "roLogFile", "probaseStream", "prolangFile", " prologFiles", "deflogPath", "prologStream", "prolexFile", "proLogModule", "proversionPath", "propathDir", "problogFile", " prologStream", "prologModule", "proflowDir", " prologHeader", " problogSourceFile", "ProLogFile", "proflowfile", "proconfigPath", "prologString", "ProLogfile", " prologFull", "proversionSourceFile", "proconfigSourceFile", "problogSourceFile", "problogFiles", "probaseHeader", "proversionFILE", "prollSource", "prologFILE", "proversionFile", "prolangFull", "proLogString", "defLogSourceFile", "defblogSourceFile", "roLogfile", "proconfigfile", "proLogSourceFile", "proLogPath", "deflogfile", "deflogFile", "propathSourceFile", "prologFiles", "proflowFile", "PrologString", "prologfile", "proconfigFILE", "defLogFile", "roLogSource"], "targetFile": [" targetDirectory", "Targetfile", "targetDir", "targetPath", "sourceDirectory", " targetFiles", " targetfile", "TargetFile", "targetFiles", "outputFile", "sourceFile", "TargetDir", "sourcefile", "TargetPath", "outputPath", "TargetDirectory", "targetfile", "TargetFiles", "targetDirectory", "outputDir", "sourceFiles", "sourcePath", "sourceDir", "outputfile"], "source": ["proxy", "text", "description", "uri", "unit", "resource", "message", "style", "scope", "view", "term", "body", "data", "options", "session", "model", "Source", "result", "input", "str", "zip", "stack", "template", "type", "i", "class", "comment", "src", "config", "parse", "target", "slice", "position", "id", "language", "string", "ource", "file", "name", "service", "sl", "SOURCE", "json", "content", "buffer", "format", "use"], "myParser": [" myReader", "MyProgram", "yourProgram", "yourReader", "yourParser", "yourJar", " myJar", "MyJar", "myReader", "myJar", "MyReader", "MyParser"], "myProgram": ["Myprogram", "MYprogram", "MyPlan", "yourprogram", "MYProgram", "yourMath", " myprogram", "theMath", "yourParser", "theParser", "MYParser", "yourPlan", "myprogram", "theProgram", "myMath", "yourProgram", "MyProgram", "myPlan", "theprogram", " myPlan", " myMath", "MyParser"], "myVisitor": ["myAuditors", "myVisitable", "myVisititable", "myVisulator", "myVisiter", " myVisitable", "mySignitor", "myvisit", "myAuditable", "myVISIT", "MyVisitor", " myVisIT", "MyVisiter", "mySigniter", "myExitor", "myvisIT", "Myvisitors", "myVisitit", "mySignulator", "myvisitable", "myVISitor", " myvisitable", "MyVisulator", "myExitors", " myvisit", " myvisitor", " myvisitors", "myVisititor", "myVISitable", "myAudit", " myVisitors", "Myvisulator", "MyVisitors", "myExulator", "myVisititors", "myDesignitable", "myDesignIT", "myVISit", "myvisulator", "myExiter", "mySignitors", "myVisit", "Myvisiter", "myDesignitor", "myDesignit", " myVisit", "Myvisitor", "myvisitors", "myVisIT", "myvisitor", " myvisIT", "myvisiter", "myAuditor", "myVisitors"], "adapterLayer": ["adptionFactory", "adaptersLayer", "acapterBuffer", "adviceLanguage", "adptionBuffer", "admissionLayer", "admissionContainer", "adapterContainer", "acaptersContainer", "adaptersBuffer", "adviceInfo", "acapterInfo", "admissionLanguage", "acapterLayer", "acapterLanguage", "adapterInfo", "adviceLayer", "adapterBuffer", "adviceBuffer", "acaptersInfo", "adaptersInfo", "adapterFactory", "adaptersLanguage", "adviceContainer", "acaptersLanguage", "acaptersBuffer", "adptionLayer", "adptionInfo", "adviceFactory", "acaptersFactory", "adaptersContainer", "adaptersFactory", "acapterFactory", "acapterContainer", "acaptersLayer", "adapterLanguage"], "classLoader": ["ClassLoader", "classPath", "staticLoader", "classDir", "staticloader", "ClassPath", " classPath", "staticDir", "Classloader", "classloader", " classDir", "ClassDir", " classloader", "staticPath"], "adapterWriter": ["admissionWriter", "attaptersWrite", "admissionWrite", "adaptersWrite", "adaptersWriter", "attaptersReader", "adAdapterWrite", "adAdapterwriter", "attapterReader", "admissionReader", "admissionwriter", "adapterswriter", "attapterWriter", "attapterwriter", "adapterReader", "adAdapterWriter", "attapterWrite", "adapterwriter", "adapterWrite", "attapterswriter", "adAdapterReader", "adaptersReader", "attaptersWriter"], "annotationGenerator": ["annotationgencer", "annnotationGenator", "annotationGator", "annotationGenerators", "annotationGcer", "annnotationGenercer", "annnotationGenators", "annnotationGenerator", "annotationGencer", "annnotationGenerators", "annnotationGeneroder", "annnotationGencer", "annotationgenators", "annnotationGenoder", "annotationgenator", "annotationGators", "annotationGoder", "annotationGenator", "annotationGenators", "annotationgenoder", "annotationGenercer", "annotationGenoder", "annotationGeneroder"], "out": ["prefix", "page", "gen", "log", "array", "flow", "server", "parent", "copy", "n", "cmd", "lock", "io", "outer", "store", "sys", "sync", "raw", "output", "in", "group", "Out", "error", "conn", "code", "temp", "print", "cli", "dump", "point", "outs", "user", "bar", "cache", "v", "err", "obj", "list", "up", "net", "pre", "OUT", "down", "diff", "query", "state", "chain", "again", "line", "post"]}}
{"id1": "771802", "id2": "19147281", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"createOutputStream": ["createInputFile", " createByteStream", " createInputStream", " createByteSteam", " createOutputReader", " createOutputSteam", " createOutputFile", " createInputReader", "createOutputFile", " createIOSteam", " createByteReader", "createInputSteam", " createIOFile", " createInputFile", "createInputReader", "createOutputReader", "createInputStream", " createIOStream", "createOutputSteam", " createByteFile", " createIOReader", " createInputSteam"], "inFile": ["incFile", "inStream", "inputfile", "outfile", "infile", "inputFile", "outFiles", "sourceFile", "incfile", "outStream", "sourceFiles", "incStream", "insFiles", "inFiles", "insStream", "sourcefile", "inputFiles", "insfile", "incFiles", "inputStream", "sourceStream", "insFile"], "outFile": [" outDirectory", "workFile", "outDir", "inTime", " outfile", "inputTime", "inputfile", "outTime", "outfile", "workfile", "infile", "inputFile", "targetfile", "outStream", "inputDir", "workingDirectory", "workingfile", "targetStream", "inDir", "workTime", "outDirectory", "targetDirectory", "workDir", " outStream", "workingFile", "workingStream", "targetFile"], "k_blockSize": ["k_blockCount", "k_byteCount", "k_byteInfo", "k_lockCount", "k_blocksCount", "k_byteLength", "k_bitInfo", "k_blocksLen", "k_byteLen", "k_lockCode", "k_blocksLength", "k_BlockSize", "k_lockLength", "k_BlockCount", "k_byteCode", "k_blockInfo", "k_lineInfo", "k_lockSize", "k_blocksSize", "k_BlockCode", "k_bitCount", "k_byteSize", "k_blockCode", "k_bitSize", "k_BlockLength", "k_blockLength", "k_lineCount", "k_lineSize", "k_blockLen", "k_lockLen"], "byteCount": ["byteLength", "blockLength", "ByteLength", "byteLen", " bytecount", "ByteLen", "ByteSize", " byteSum", "characterLength", "flushcount", "characterCount", "blockCount", "byteSum", "flushCount", "ByteSum", "ByteCount", " byteSize", "blockSize", "flushLength", " byteLength", "Bytecount", "blockSum", "characterSize", "characterLen", " byteLen", "flushSize", "bytecount", "byteSize"], "buf": ["base", "buffer", "border", "Buffer", "bf", "alloc", "feed", "rc", "bh", "cap", "cb", "loc", "result", "feat", "queue", "uf", "la", "bag", "cv", "rb", "cas", "buff", "len", "data", "config", "src", "tmp", "fb", "exc", "append", "background", "brace", "vec", "font", "ucc", "fd", "bytes", "ctx", "flush", "Buff", "seq", "b", "batch", "cmd", "img"], "ofp": ["OFnp", "Ofnp", "afl", "Oft", "ofl", "oft", "OFtp", "oftp", "OFt", "OFp", "ofnp", "OFl", "fortp", "afp", "OFc", "Ofl", "forp", "afc", "fort", "Ofc", "forc", "Oftp", "Ofp", "ofc", "afnp"], "zos": ["zip", "css", "tz", "zyk", "fits", "zy", "bos", "zar", "zers", "zona", "js", "gz", "enos", "zi", "lins", "zin", "zl", "uz", "ZA", "zo", "liquid", "utils", "ogl", "iffs", "dylib", "ZI", "hz", "z", "bs", "modules", "rons", "packs", "za", "bes", "zig", "zx", "nox", "zb", "oS", "lol", "webkit", "nz", "los", "zen", "zag", "cfg", "zn", "cos", "budget", "core", "oses", "zes", "robe", "iframe", "outs", "soon", "zh", "ws", "ossus", "owicz", "forge", "ses", "jas", "ozo", "os", "osi", "kos", "zer", "oda", "obb", "zon", "ros", "ops", "inos", "ls", "obs", "rez", "bitcoin", "zik", "abi"], "osw": ["osnow", "esnow", "osfw", "osssw", "bsw", "ossd", "esfw", "lsws", " osow", "ossfw", "osd", "osy", " osww", "isd", " osfw", "osww", "essw", "ossy", "esd", "iswd", "bsws", "esww", "osow", "bx", "bswo", "lsw", "ossow", "oswo", "oswd", "lswo", "isy", "bwo", "isnow", "ossw", "lsx", "bsx", "ossnow", "issw", "esy", "ossww", "esw", "oshell", "osx", "osshell", "esow", "osswd", "bws", "eswd", "ishell", "osws", "eshell", "isw"], "bw": ["bbew", "bbws", "fbw", "bsw", "owu", "bbwh", " baw", "bbz", "fbwd", "bbw", "lbwh", "lw", "owa", "lbx", "fwh", "lwa", "bwu", "oaw", "bW", "abw", "fw", "bbwa", "fwa", "fr", "bwe", " bew", "Bew", "ebwe", "Bwa", " bz", "ebwd", " bwu", "bx", "lsw", " bws", "bew", " bwa", "Bw", "bbwu", " bwh", "lbr", "Bws", "abwd", "abwe", "lbws", "ebw", "lbwa", "fbW", "bwa", "fsw", "lbsw", "fbwe", "bwd", "bz", "lbw", "lbz", "ebW", "bws", "bwh", "baw", "ow", "bbaw", "abW", "lx", "fx"], "zot": ["Ziot", "jori", "Zor", "azit", " ziot", "zerori", "azita", "jot", "zerot", " zor", "Zot", "zeros", "zerott", "Zott", "azot", "ziot", "azott", "zor", "zerit", "Zit", "zerita", "jit", " zori", "zita", "jos", "zott", "aziot", "Zita", "azor", "zori"], "ifp": [" ifl", " iff", " ifb", "ipp", " ifi", "ifl", "Iff", "ipl", "ifc", "ifb", "IFc", "iff", "ipc", "ipb", "IFi", "IFf", " ifc", "Ifc", "ifi", "Ifp", "IFl", "IFb", "IFp", "Ifi"], "zis": ["jisi", "zip", "zeiss", "jis", "zib", "zipits", "xis", "xit", "zais", "zIS", "Zip", " zib", "xits", "xisi", "jits", "Ziss", "zenis", "Zits", " zIS", "ziss", "zeis", "zenIS", "zipiss", "zipis", "zeip", "xais", " zais", "xib", "zisi", "xIS", "zipip", "zeits", "Zis", "jit", "zenais", " zisi", "zenib", " zits", "zits"], "isr": ["ispr", "rispr", "isrc", "ISsr", "risr", " iscr", " isrs", "irpr", "ISrc", "isssr", "IScr", "isrb", "irrb", "ISr", " issr", "iscr", "isscr", "risrb", "risrc", "ISpr", "issr", "irr", "isrs", "ISrb", "ISrs", "irrc", "issrs"], "br": [" BR", "obl", "bh", "HR", "rib", "ibr", "lr", "fr", " dr", "mr", "rs", "shr", "bro", "obi", "arr", "BR", "bar", " fr", "rb", "ctr", "browser", "ocr", "r", "ch", "Br", "str", "ob", "div", " Br", "body", "ibl", "yr", "gr", "cro", "tr", "bc", "bp", "hr", "b", "kr", "bl", "err", "sp", "bsp", "ber", "sr", "img"], "zit": ["jita", "zip", "jite", "zeIT", "jic", "zite", "jIT", " zi", "zenits", "zipita", "zitter", "zipits", " zite", "xit", "xith", "zIT", "zipite", "zic", " zip", "zeith", "ji", "zenith", "zeitter", "jits", "zith", " zith", "zenitter", "jip", "zeita", "zenit", "zi", "zipitter", "zipip", " zic", "xi", "zipith", "jith", "zipIT", "zeits", "zeit", "jit", "zita", "xic", " zits", "zits", "zipit"]}}
{"id1": "17724879", "id2": "18370075", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "label": 1, "substitutes": {"getDigest": ["createDigest", "createdigHash", "createdigest", "getMDHash", "createDigests", "getMDest", "createDigHash", "getMDester", "getdigHash", "getSignest", "getMDests", "getDigester", "getdigest", "getdigester", "createdigests", "createdigester", "createDigester", "getDigests", "getDigHash", "getSignester", "getSignests", "getSignHash", "getdigests"], "attribute": ["att", "image", "client", "component", "attr", "element", "argument", "entry", "class", "object", "character", "instance", "reference", "layer", "route", "directory", "expression", "metadata", "ribute", "address", "Attribute", "property", "connection", "ident", "resource", "audio", "message", "pair", "operation", "manager", "value", "function", "prefix", "feature", "api", "set", "definition", "data", "type", "subject", "application", "document", "name", "node", "individual", "entity", "plugin", "variable", "uri", "event", "device", "config", "username"], "digestAlgorithm": ["digestalgebra", "digestalgorith", "digestALgo", "digestElger", "digestElgo", "digestALgebra", "digestALgorithm", "digESTAlger", "digestAlgebra", "digESTAlg", "digesterAlgebra", "digestElg", "digestalgorithm", "digestalger", "digestAlgo", "digesterAlgorith", "digestElgorithm", "digESTAlgo", "digestALgorith", "digestAlgorith", "digesterAlgorithm", "digESTAlgorithm", "digestAlger", "digestAlg", "digesterAlgo", "digestalgo", "digestalg"], "digest": [" digested", "Diguration", "Digtest", "signest", "labester", "longEST", "multiplest", "DigEST", "multiplEST", "signgest", "digger", "diggest", "labEST", " digtest", "longest", " digEST", "dger", "bigester", "Digest", "signger", " diguration", "biggest", "multiplester", "dgest", "labtest", "Digester", " digester", "dest", "digester", "multipluration", "digEST", "digtest", "bigger", "labest", "longested", "digested", "bigest", "diguration", "dester", "longester", "Digested", "signester"], "md": ["mm", "mac", "der", "mo", "sd", "m", "db", "kg", "my", "mad", "app", "ad", "po", "mn", "pd", "ht", "ng", "metadata", "arm", "mid", "id", "ui", "um", "module", "cd", "ma", "od", "rm", "editor", "mb", "amd", "nm", "cm", "df", "manager", "wd", "own", "ds", "bd", "mr", "sm", "doc", "dm", "pm", "mi", "nd", "mt", "MD", "mp", "di", "mc", "hd", "mag", "plugin", "d", "ml", "mod", "ld", "ms", "meta", "cmd", "dev", "dd", " MD", "cb"]}}
{"id1": "6379126", "id2": "838844", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": ["riarTinyDir", "riarTravispage", "riartourPage", "riartutorialElement", "riarTutorialElement", "riarTravisPage", "riarTinyPage", "riarTourElement", "riarTutorialPage", "riartutorialPage", "riarTutorialDir", "riarTourpage", "riartutorialpage", "riarTinyElement", "riarTourDir", "riartutorialDir", "riartourElement", "riarTourPage", "riartourDir", "riarTinypage", "riarTravisElement", "riartourpage", "riarTravisDir", "riarTutorialpage"], "indexDir": ["zipDIR", "indexJar", "zipDir", "includeTier", "IndexDIR", "IndexDir", "indexDIR", "zipTier", "includeJar", "zipJar", "indexTier", "includeDIR", "IndexJar", "IndexTier", "includeDir"], "cssDir": ["javascriptDir", "cssUrl", "CSSDirectory", "catsDoc", "ssD", "fontD", "fontDir", "piecesDIR", "cssDIR", "ssDb", "gzDir", "gzUrl", "gzDirectory", "cssLen", "cssDb", "CSSUrl", "ssUrl", "javascriptDar", "ssDirectory", "cssDoc", "cssDie", "codesDoc", "catsLen", "cssDar", "CSSDar", "javascriptDb", "catsDir", "ssDIR", "piecesDie", "codesLen", "cssDirectory", "CSSDb", "CSSDir", "gzDIR", "cssD", "javascriptDIR", "ssDar", "CSSDoc", "CSSDIR", "CSSLen", "piecesDir", "piecesD", "fontDIR", "fontDie", "ssDie", "ssDir", "codesDir"], "capDir": ["CapDir", "casDir", "apsDirectory", "CapDirectory", "casDirectory", "apsDir", "Capdir", "casdir", "apsVol", "capVol", "apsdir", "casVol", "CapVol", "capDirectory", "capdir"], "licDir": ["licDoc", "volDoc", "volDir", "libManager", "volManager", "lifDir", "libDir", "libdir", "libDoc", "lifManager", "licdir", "licManager", "voldir", "lifdir", "lifDoc"], "midDir": ["limDIR", "middir", "casDir", "limDir", "casdir", "limdir", "midDIR", "casTier", "mindDir", "mindDIR", "casDIR", "midTier", "mindTier", "minddir", "limTier"], "filesDir": ["pagesDir", "FilesFolder", "FilesFile", "videosDirectory", " filesPos", "stylesDir", "opensDIR", "videosFolder", "opensDur", "locksDur", "videosFile", "opensDir", "FilesDirectory", "filesDirectory", "imagesFolder", "stylesDur", "ballsDir", "imagesFile", "pagesPos", "locksDir", "filesFolder", "filesFile", "imagesDir", "filesDIR", "stylesDirectory", "imagesDirectory", "locksDIR", "ballsPos", "filesDur", "FilesDir", "stylesDIR", "pagesVol", "opensDirectory", "filesPos", "filesVol", "ballsVol", "locksDirectory", " filesVol"], "videosDir": ["videoDir", "videosDirectory", "viewsFile", "viewsDirectory", "videoUrl", "videoDirectory", "videosUrl", " videosUrl", " videosDirectory", "videosFile", " videosDb", "viewsDir", "imagesDir", " videosFile", "imagesDb", "viewsUrl", "videoFile", "videosDb", "videoDb"], "imagensDir": ["imagersDirectory", "imagenJar", "imagenFile", "imagenciesDirectory", " imagersDir", " imagensDirectory", "imagentsJar", "imgentsDirectory", "imagensDIR", " imagersFile", "imgentsFile", "imagersDir", " imagensJar", " imagersDirectory", "imagentsFile", "imagersFile", "imagenciesDir", "imgentsDIR", "imgensDirectory", "imagenDirectory", "imgentsDir", "imagentsDIR", "imagersJar", "imagenciesDIR", "imgensFile", "imagensDirectory", "imagensFile", " imagersJar", "imagentsDirectory", "imgensDIR", "imagersDIR", "imagensJar", "imagentsDir", " imagensFile", "imagenciesFile", "imagenDir", "imgensDir"], "local": ["available", "prefix", "partial", "request", "log", "shared", "http", "localhost", "standard", "conf", "loc", "lock", "remote", "relative", "data", "username", "pal", "back", "part", "managed", "input", "Location", "valid", "d", "small", "home", "pass", "temp", "total", "basic", "dir", "directory", "LOC", "tmp", "l", "self", "same", "base", "user", "inner", "internal", "present", "file", "upload", "safe", "name", "personal", "initial", "global", "defined", "Local", "location", "path", "json", "current", " Local", "state", "specified", "where", "serial", "active", "util", "p"], "srcCss1": ["srcPss81", "srcPss1", "srcRcss81", "srcRcss11", "srcCcss3", "srcCass81", "srcCrss11", "srcCfg1", "srcPcssPre", "srcCass11", "srcCss11", "srcCpePre", "srcCss81", "srcRss81", "srcCfgPre", "srcCcss0", "srcCcss2", "srcRss2", "srcCcss11", "srcCse2", "srcPss3", "srcPcss81", "srcRss1", "srcCpe4", "srcCcss4", "srcCcss1", "srcCrss2", "srcCrss3", "srcCss0", "srcRcss1", "srcRcss2", "srcCass0", "srcCse0", "srcCssPre", "srcCse11", "srcCass3", "srcCrss81", "srcCpe2", "srcRss11", "srcCfg2", "srcCfg4", "srcCcssPre", "srcCrss1", "srcPcss3", "srcRss0", "srcCcss81", "srcRcss0", "srcPss4", "srcCse1", "srcPcss1", "srcPcss2", "srcPss2", "srcCass2", "srcCass1", "srcPssPre", "srcCpe1", "srcPcss4"], "destCss1": ["destPcss3", "destPss2", "destCcss3", "destCcss1", "destPss3", "destPssCard", "destCfg1", "destCrss2", "destPcss81", "destCass81", "destPss0", "destCrss3", "destCcss0", "destPss81", "destCfg0", "destPcssCard", "destPcss2", "destPss1", "destCss0", "destCcss81", "destCcss2", "destCrss81", "destCss81", "destCxx2", "destCxx1", "destCass2", "destCxx3", "destCrss0", "destCfg3", "destCass1", "destCassCard", "destCfg2", "destPcss0", "destCxxCard", "destCass3", "destPcss1", "destCssCard", "destCcssCard", "destCrss1"], "srcCss2": ["srcCfgL", "srcCssB", "srcChess1", "srcPss1", "srcUcss1", "srcCcss52", "srcUssTwo", "srcChess2", "srcAccss2", "srcCcss3", "srcCass52", "srcUss1", "srcCss27", "srcAccss52", "srcPcss27", "srcCfg1", "srcAccss1", "srcCross1", "srcCcssL", "srcCcss2", "srcCross52", "srcPss3", "srcChessTwo", "srcAcss2", "srcUcssB", "srcCcss4", "srcCcss1", "srcCcssB", "srcCass4", "srcCrss3", "srcCross4", "srcPssL", "srcCfgTwo", "srcCssTwo", "srcCcssTwo", "srcAcss4", "srcUssB", "srcPcssL", "srcCng27", "srcUcss2", "srcCss52", "srcCross2", "srcCfg3", "srcChessB", "srcCfg2", "srcCng2", "srcCrss1", "srcPcss3", "srcCng1", "srcUcssTwo", "srcAccss4", "srcCcss27", "srcCrss27", "srcPcss1", "srcCass2", "srcPcss2", "srcPss2", "srcPss27", "srcAcss1", "srcCass1", "srcAcss52", "srcCssL", "srcCrssL", "srcCrss2", "srcCfgB", "srcUss2"], "destCss2": ["destNss72", "destCest1", "destNss3", "destCssB", "destCess32", "destNss32", "destCcss3", "destCfg32", "destCcss1", "destCfg4", "destCfg1", "destNssB", "destCcss72", "destCess1", "destCess4", "destCss32", "destNcss3", "destNss2", "destNcss32", "destCcss4", "destCess2", "destCcss2", "destCcss32", "destNcss1", "destNcss72", "destNcssB", "destCfg3", "destNss1", "destCest3", "destNss4", "destCest2", "destCfg2", "destCestB", "destCss72", "destCfg72", "destCfgB", "destNcss2", "destCcssB", "destNcss4", "destCess72"], "srcCss3": ["srcScss15", "srcScstyle2", "srcCstyle15", "srcClass93", "srcPss6", "srcRssThird", "srcClass2", "srcScstyle93", "srcCsl2", "srcCstyle2", "srcCfg3", "srcCstyle93", "srcCsh2", "srcCss15", "srcRcss183", "srcCass2", "srcPss2", "srcScss93", "srcScss3", "srcClass3", "srcCssAND", "srcRss2", "srcCcss6", "srcPss3", "srcRss1", "srcCsl183", "srcCcss1", "srcCass4", "srcCrss3", "srcCsl3", "srcCcss15", "srcCfg2", "srcPcss3", "srcClass15", "srcRcss4", "srcPssAND", "srcCsh3", "srcCass1", "srcCrss2", "srcCstyle3", "srcRss183", "srcCcssAND", "srcScss2", "srcCcss3", "srcCfg1", "srcCcss93", "srcRcss3", "srcCrssAND", "srcCstyle6", "srcCslThird", "srcCssThird", "srcRss4", "srcPcssAND", "srcCshThird", "srcCss93", "srcCsh183", "srcPcss2", "srcCss183", "srcPcss6", "srcCcss2", "srcCcss4", "srcCcss183", "srcScstyle15", "srcRcss2", "srcRcss1", "srcCrss6", "srcCass3", "srcRss3", "srcCstyleAND", "srcScstyle3", "srcCfg4", "srcRcssThird", "srcCcssThird"], "destCss3": ["destScss3", "destPcss3", "destCcss3", "destNss3", "destPss2", "destCcss6", "destScss183", "destPss3", "destCja6", "destScrss2", "destCrss2", "destScrss6", "destPss53", "destCcss03", "destNcss3", "destNss2", "destCrss3", "destCross53", "destCcss53", "destPcss2", "destCross3", "destCstyle53", "destNss43", "destScrss183", "destCja3", "destCrss6", "destScss2", "destCcss2", "destCss53", "destCja2", "destPcss53", "destPcss03", "destCrss183", "destCass2", "destPss03", "destCstyle03", "destCstyle43", "destCstyle3", "destCss03", "destCass43", "destCss183", "destCstyle2", "destCcss183", "destCja183", "destCcss43", "destCass3", "destScrss3", "destCross03", "destScss6", "destNcss2", "destCross2", "destNcss43", "destCss43"], "srcCss4": ["srcPss1", "srcPssFour", "srcCcss2", "srcCrssFour", "srcCcss4", "srcCcss1", "srcCassFour", "srcCass4", "srcCssFour", "srcPcssFour", "srcCrss4", "srcCrss1", "srcPcss4", "srcPss4", "srcCcssFour", "srcPcss1", "srcCass2", "srcPcss2", "srcPss2", "srcCass1", "srcCrss2"]}}
{"id1": "18374478", "id2": "11334468", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"updateUser": ["editUser", "deleteUsers", "deleteuser", "createAccount", " updateRole", "createRole", " updateuser", "deletePassword", "UpdatePassword", "adduser", " updatePassword", "addUsers", "createUser", "Updateuser", "deleteRole", " updateWord", "UpdateMember", "editAccount", "createUsers", " updateMember", "updateAccount", "editRole", "UpdateUser", "updateMember", "editUsers", "updatePassword", "updateUsers", "UpdateRole", "addWord", "deleteMember", "deleteWord", "updateduser", "updateWord", "updateuser", "UpdateUsers", "deleteUser", "addUser", " updateAccount", "updatedWord", " updateUsers", "updatedUser", "updateRole", "UpdateWord", "updatedUsers"], "user": ["p", "account", "match", "me", "group", "message", "contact", "app", "result", "ro", "current", "str", "client", "username", "session", "instance", "author", "config", "ver", "update", "this", "model", "use", "view", "person", "page", "system", "per", "manager", "project", "USER", "data", "record", "object", "resource", "auth", "module", "self", "job", "character", "name", "log", "null", "server", "you", "pool", "post", "connection", "rule", "string", "profile", "plugin", "full", "used", "creator", "users", "version", "bug", "row", "response", "custom", "site", "parent", "member", "content", "User"], "conn": ["org", "util", "pt", "cache", "uc", "client", "sync", "oss", "cb", "c", "ac", "cat", "config", "reg", "Connection", "nt", "ca", "Conn", "serv", "ci", "socket", "loc", "con", "close", "pg", "act", "pub", "ec", "n", "sth", "connect", "core", "url", "pc", "ann", "log", "col", "ou", "server", "host", "pool", "cr", "exec", "conf", "ch", "api", "rc", "connection", "cc", "nc", "h", "lock", "cp", "cond", "enc", "coll", "pr", "el", "cm", "sql", "ha", "cn", "mc", "part", "cli", "ob", "ct", "ctx", "db", "co", "dc"], "autoCommit": ["autoComend", "autoComits", "autoRebits", "autoCommIT", "autoDebend", "autoDebIT", " autoComits", "autoBlend", "autoComIT", " autoDebit", " autoDebmit", "autoComit", "autoDebitting", "automaticDebit", "autoCmit", "automaticCommIT", " autoComit", "autoComite", "autoBlIT", "autoDebits", "autoAbit", "autoAbmit", "autoAbited", " autoCommmit", " autoCommitting", "autoCommite", "autoCommend", "autoBlmit", "autoDebite", "autoCommitting", "autoBlit", "autoCommits", "autoCited", " autoCommited", "automaticCommmit", " autoDebitting", "automaticDebmit", "automaticCommit", "autoRebite", "autoAbitting", "autoCit", "autoCitting", "automaticCommend", " autoCommits", " autoCommite", " autoComite", "autoCommmit", " autoDebited", "automaticDebIT", "autoRebit", "autoCommited", "autoDebmit", "autoDebited", "automaticDebend", "autoDebit"], "deleteRoles": ["delRole", "delLodes", "deleteGroles", "deleteSlases", "deleteRodes", "deleteNoots", "deleteDils", "deleteRases", "deleteRsases", "deleteGrils", "deleteSlole", "deleteGroots", "deleteRsoles", "insertRooles", "deleteCodes", "deleteCases", "deleteDoots", "delRoles", "destroyNoles", "destroyNils", "destroyRols", "deleteNols", "deleteRsole", "destroyNols", "deleteRoases", "deleteDases", "delLoles", "deleteDules", "insertRoases", "deleteGrols", "insertRoules", "deleteRoots", "deleteRols", "deleteRsules", "deleteRole", "deleteSloles", "deleteColes", "delLole", "deleteNils", "deleteRils", "deleteRules", "deleteLodes", "delRases", "delRodes", "destroyNoots", "insertRases", "deleteNoles", "deleteLole", "deleteRoules", "insertRules", "destroyRoles", "deleteLases", "deleteDoles", "deleteRoole", "insertRoole", "deleteRooles", "insertRole", "deleteSlodes", "deleteDole", "delLases", "destroyRoots", "deleteDols", "deleteLoles", "destroyRils", "deleteCole"], "insertRoles": ["insertRsoles", "insertRodes", "deleteSlanges", "insertGows", "deleteRoots", "deleteSloles", "insertShules", "insertGoots", "insertLules", "insertSloots", "copyRoots", "updateRoles", "insertRols", "insertRsanges", "insertSlanges", "updateLles", "updateRles", "deleteRodes", "insertRsodes", "insertRanges", "insertRles", "insertLows", " insertRole", " insertRodes", "insertSole", "deleteSloots", "copyRules", "insertRules", "insertSlodes", " insertSholes", "copyGoots", "insertLoles", "insertGules", "insertLles", "copyGows", "insertLols", "insertRows", " insertShole", "insertRsles", " insertShules", "insertRsols", "insertSodes", "insertRsoots", "updateRols", "updateLoles", "deleteRanges", "insertRsules", "insertRoots", "insertRole", "insertLoots", "updateLols", "deleteSlodes", " insertRules", "insertSloles", "insertSholes", "copyRows", "insertShole", "insertRsows", "copyGoles", "copyGules", "insertSules", "updateLules", "insertShodes", " insertShodes", "copyRoles", "insertGoles", "updateRules", "insertSoles"], "role": ["group", "relation", "ro", "username", "tool", "alias", "slave", "link", "one", "de", "l", "to", "or", "val", "module", "service", "resource", "force", "shadow", "error", "Role", "base", "roller", "label", "rl", "function", "guard", "string", "rule", "tag", "profile", "repl", "range", "route", "row", "key", "entry", "le", "type", "member", "ole", "rol", "zone"]}}
{"id1": "13783898", "id2": "8747840", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFiletoFiles", "encodeFileToFiles", "encodeFiletoFile", "encodeString2File", "encodeString2Stream", "encodeFileToStream", "encodeFileFromStream", "encodeStringToStream", "encodeFileFromFile", "encodeString2String", "encodeFile2Files", "encodeStringToFile", "encodeFile2File", "encodeFileToString", "encodeString2Files", "encodeFiletoString", "encodeStringToString", "encodeFile2Stream", "encodeFiletoStream", "encodeStringToFiles", "encodeFileFromString", "encodeFileFromFiles", "encodeFile2String"], "infile": ["infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", " infp", "inputfp", "inputFile", "outfiles", " infilename", "inputfiles", "Infilename", " infiles", "outfp", "Infile", "InFile", "inputfilename", "infilename", "Infiles"], "outfile": ["newfile", "Outname", "infp", "outfilename", "outputfile", "outFile", "newname", " outFile", "infolder", " outfolder", "outputfolder", "newfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "Outfolder", " outname", "outname", "OutFile", "Outfile", "infilename", "newFile", " outfilename"], "in": ["IN", "base", "pin", "i", "input", "inas", "sin", "id", "ini", "gin", "into", "ic", "con", "inner", "as", "socket", "ins", "s", "bin", "pass", "is", "reader", "source", "thin", "login", "min", "inside", "r", "inc", "data", "rin", "vin", "init", "conn", "again", "m", "image", "re", "isin", "In", "nin", "a", "err", "b", "ac", "cin", "inn", "win", "din"], "out": ["base", "ou", "job", "ex", "output", "outer", "copy", "timeout", "on", "net", "OUT", "socket", "inner", "outs", "o", "off", "write", "bin", "co", "line", "exit", "post", "client", "sync", "session", "no", "cache", "source", "one", "up", "lib", "inc", "parent", "work", "file", "conn", "or", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "In", "err", "obj", "error", "point"], "buffer": ["address", "base", "Buffer", "input", "uffer", "feed", "server", "border", "slice", "limit", "result", "length", "write", "queue", "offset", "iter", "split", "raw", "type", "reader", "cache", "binary", "source", "seed", "buff", "value", "buf", "len", "wave", "data", "fb", "size", "bb", "null", "bytes", "layer", "flush", "url", "b", "reference", "count", "padding", "transfer", "batch"], "read": ["play", "close", "i", "input", "Read", "feed", "n", "copy", "reading", "id", "add", "ind", "slice", "current", "end", "limit", "run", "se", "find", "length", "write", "reads", "ride", "pass", "sleep", "ad", "iter", "next", "raw", "sync", " count", "select", "allow", "use", "load", "reader", " Read", "len", "seek", "work", "inc", "check", " copy", "ip", "size", "x", "get", "fill", "start", "exec", "io", "lex", "send", "tell", "_", "parse", "connect", "wait", "count", "READ", " write", " skip", "f"], "success": ["respons", "roll", "error", "path", "response", "rolling", "continue", "results", "ceed", "modified", "xx", "message", "primary", "warning", "better", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "model", "default", "open", "data", "growth", "flash", "null", "cess", "danger", "complete", "again", "status", " successful", "good", "Success", "comment", "right", "successful", "successfully", "rolled", " succ", "method", "fast", "first", "winner", "initial"]}}
{"id1": "6301863", "id2": "12171364", "code1": "    protected String doRawRequest(String postData) throws IOException {\n        URL url = new URL(SERVICE_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(postData);\n        wr.flush();\n        BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n        StringBuffer sb = new StringBuffer();\n        String line;\n        while ((line = rd.readLine()) != null) {\n            sb.append(line);\n        }\n        wr.close();\n        rd.close();\n        return sb.toString();\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"doRawRequest": ["doPostPost", "DoRawRequest", "doPostResponse", "DoDirectRequest", "doPostMessage", "DoDirectResponse", "doRawMessage", "doFullResponse", "doDirectResponse", "DoDirectPost", "DoRawPost", "doFullRequest", "DoRawMessage", "doDirectRequest", "doFullMessage", "doPostRequest", "doDirectMessage", "doFullPost", "DoDirectMessage", "DoRawResponse", "doDirectPost", "doRawPost", "doRawResponse"], "postData": ["Postdata", "postString", " postdata", "POSTString", "postdata", "POSTData", "PostBody", "PostData", "postBody", "PostPart", "POSTPart", " postPart", " postString", " postBody", "postPart", "PostString", "POSTBody", "POSTdata"], "url": ["connection", "nt", "open", "sl", "f", "org", "fl", "ur", "web", "download", "str", "ll", "ssl", "base", "ls", "log", "bb", "b", "page", "blog", "user", "r", "l", "client", "Url", "service", "URL", "db", "api", "lr", "cl", "config", "server", "uri", "http", "c", "resource", "www", "host", "rl"], "conn": ["connection", "nt", "open", "lock", "cb", "rn", "loc", "cn", "reg", "org", "nc", "session", "g", "ct", "Connect", "sync", "dn", "enc", "not", "pub", "pc", "ann", "ssl", "w", "contract", "cr", "r", "client", "dc", "ci", "db", "connect", "ch", "cf", "exec", "close", "conv", "n", "rt", "Conn", "c", "wb", "co", "po", "coll", "ai", "con", "cm", "fp", "fail", "auth", "cp", "Connection", "apt", "act"], "wr": ["rh", "mr", "wt", "ww", "wd", "fw", "kr", "raft", "vr", "wp", "ru", "pr", "w", "wrap", "wm", "cr", "r", "writer", "ra", "Wr", "dr", "rr", "wn", "rb", "shr", "war", "WR", "hr", "wa", "rw", "sw", "nr", "rt", "wire", "wb", "RW", "wer", "rx", "nw", "fd", "wy", "rss", "Writer", "write", "wx"], "rd": ["rh", "reader", "bd", "rn", "RS", "RD", "rm", "wd", "ds", "dd", "adr", "rod", "ru", "rc", "ld", "dig", "pr", "rob", "cr", "r", "writer", "ra", "fr", "dr", "rb", "rr", "rowd", "gd", "hr", "db", "rw", "rg", "erd", "dra", "rt", "sr", "src", "ird", "fd", "rss", "tr", "xd", "wx", "pd", "rl", "rx"], "sb": ["SB", " SB", "BB", "cb", "bd", "su", "sg", "nn", "si", "lp", "bj", "gb", "s", "bs", "buff", "bt", "eb", "lab", "bh", "binary", "xb", "ssl", "bb", "ls", " eb", "b", "mb", "sv", "bp", "lines", "bc", "rb", "buffer", "abb", "db", "ws", "lb", "zb", "bg", "bps", "sa", "wb", "nb", "src", "bsp", "bf", "sf", "fp", "obb", "fb", "pb", "buf"], "line": ["job", "reader", "le", "sl", "f", "data", "name", " Line", "error", "type", "body", "sync", "non", "one", "str", "letter", "lc", "inline", "page", "user", "text", "part", "l", "r", "cell", "err", "lines", "key", "e", "lf", "row", "comment", "i", "source", "Line", "object", "character", "no", "cl", "code", "pass", "unit", "in", "split", "file", "id", "LINE", "word", "len", "message", "lin", "link", "string", "ip", "end"]}}
{"id1": "8778962", "id2": "6171406", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2Stream", "decodeFile2Stream", "decodeFileToString", "decodeFileToStream", "decodeFile2File", "decodeFileAsFile", "decodeFile2String", "decodeFileFromString", "decodeString2File", "decodeFileAsStream", "decodeStringToFile", "decodeFileFromStream", "decodeStringToStream", "decodeString2Files", "decodeString2String", "decodeFileToFiles", "decodeFileAsFiles", "decodeFileAsString", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeStringToFiles", "decodeStringToString"], "infile": ["infp", " infiles", "InFile", "inputfiles", "minstream", " inbase", "instream", "outfp", "inbase", "outfilename", "inFile", " inFile", "minbase", "inputfp", "infiles", "Infile", "Instream", "infilename", "inputfilename", "minFile", "inputfile", "Inbase", "outfiles", " instream", " infp", "minfile", " infilename"], "outfile": [" outfilename", " outpath", "outputfilename", " outfolder", "outputfolder", "inputFile", "inputdatabase", " outFile", "outfilename", "inFile", "outputFile", "outpath", "outdatabase", "outputdatabase", "inputpath", "outfolder", "infilename", "inputfile", "outputpath", "infolder", "outFile", " outdatabase", "outputfile"], "in": ["into", "m", "ins", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "log", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "channel", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "pass", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "obj", "err", "name", "up", "net", "ou", "OUT", "or", "again", "line", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "data", "Buffer", "raw", "channel", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "base", "queue", "slice", "address", "cache", "bin", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "r", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "func", "follow", " Success", "model", "status", "winner", "result", "primary", "fail", "valid", "positive", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "14303294", "id2": "7633336", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    private JSONObject executeHttpGet(String uri) throws Exception {\n        HttpGet req = new HttpGet(uri);\n        HttpClient client = new DefaultHttpClient();\n        HttpResponse resLogin = client.execute(req);\n        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));\n        StringBuilder sb = new StringBuilder();\n        String s = null;\n        while ((s = r.readLine()) != null) {\n            sb.append(s);\n        }\n        return new JSONObject(sb.toString());\n    }\n", "label": 0, "substitutes": {"getServerHash": [" getSecureSHA", "getServerSHA", " getServerSHA", " getSecureSalt", "getserverHash", "getSessionSalt", "getSecureSHA", "getSessionSHA", " getSecureAddress", "getSecureHash", "getSessionAddress", "getSecureSalt", "getserverSHA", "getserverAddress", "getServerSalt", " getServerAddress", "getSecureAddress", " getSecureHash", " getServerSalt", "getserverSalt", "getServerAddress", "getSessionHash"], "passwordHash": ["passwordPass", " passwordSalt", " passwordPassword", "privatePassword", "passwordhash", " passwordhash", "PasswordCode", "Passwordhash", " PasswordPass", "PasswordHash", "passwordCode", " PasswordHash", " passwordCode", "privateHash", "PasswordPass", "passwordSalt", " passwordPass", "privateSalt", "passwordPassword", "privatehash", "PasswordPassword", " PasswordCode"], "PasswordSalt": [" passwordSalt", " passwordPassword", " PasswordSecret", "PASSPassword", " Password256", " PasswordPassword", "PasswordSecret", " PasswordHash", "PasswordHash", " passwordSecret", "password256", "passwordSecret", "Password256", "PASSHash", "passwordSalt", "PASS256", "passwordPassword", "PasswordPassword", "PASSSalt"], "hash": ["ha", "image", "error", "mac", "buffer", "h", "size", "dig", "html", "ash", "block", "crypt", "key", "user", "copy", "cache", "address", "check", "sh", "result", "sum", "array", "content", "response", "message", "code", "pool", "change", "value", "row", "Hash", "build", "work", "url", "base", "update", "data", "her", "log", "sha", "number", "search", "auth", "password", "string", "kh", "hex"], "digest": ["hashester", " digested", "signest", "mdester", " digger", "generest", "hasher", "signher", "digusher", "mdusher", "digger", "mdest", "integall", "integested", "diger", "integester", "Diger", "generall", "Digest", "signger", "Digger", " diger", "Digester", " digester", "hashest", " digall", "digener", "digall", "digester", "Digener", "generester", "Digher", "mdested", "signer", "digher", "Digusher", " digusher", "hashener", "digested", "integest", " digener", "Digested", "generested", "signester", " digher"]}}
{"id1": "13596891", "id2": "20028790", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"doTransfer": ["handleTransfer", "doImport", " doSend", "makeSend", "doRequest", "makeImport", "handleRequest", "makeRequest", " doImport", "makeTransfer", "handleSend", "doSend", "handleImport", " doRequest"], "request": ["message", "form", "create", "remote", "result", "position", "re", "current", "client", "session", "instance", "config", "com", "this", "model", "http", "event", "command", "input", "enter", "complete", "condition", "req", "data", "q", "in", "object", "resource", "record", "QUEST", "subject", "server", "requ", "post", "query", "time", "connection", "stream", "queue", "rf", "received", "version", "reader", "type", "user", "xml", "Request", "report", "context", "application"], "response": ["message", "call", "remote", "result", "re", "output", "json", "client", "out", "cache", "session", "cover", "status", "model", "page", "view", "event", " Response", "success", "serv", "image", "default", "application", "resp", "writer", "warning", "service", "object", "resource", "reply", "next", "document", "server", "Response", "res", "body", "index", "onse", "connection", "header", "respond", "full", "en", "version", "results", "site", "error", "report", "content", "http"], "method": ["text", "message", "call", "position", "property", "mode", "json", "METHOD", "path", "session", "date", "head", "use", "cmd", "command", "send", "process", "resource", "format", "description", "class", "callback", "subject", "reason", "hod", "verb", "term", "time", "string", "direction", "prefix", "sort", "version", "route", "pull", "sign", "type", "Method", "status", "content"], "servletContext": ["servlexConfig", "servletsConfig", "ServletsConfig", "servleContext", "Servletscontext", "servantCurrent", " servletCurrent", "servantProvider", " servletConfig", "ServletsController", "servletConfig", "servlexContext", "servApplicationcontext", " servantConfig", "ServletConfig", "servletsController", "Servletcontext", "ServletsContext", "servApplicationConfig", "servleConfig", "ServletController", "servantConfig", "servantContext", "servlexcontext", "servApplicationController", "servleProvider", " servantCurrent", "servLETCurrent", "servletcontext", "servletsContext", "servApplicationContext", " servletProvider", " servantProvider", "servLETProvider", "ServletContext", "servletProvider", "servLETContext", "servletscontext", "servletCurrent", "servLETConfig", "servlexController", "servleCurrent", " servantContext", "servletController"], "wac": ["wsacs", " Wae", " Wacs", " wAC", "wsac", "wae", " wae", "wAC", "wsAC", " Wac", " WAC", " wacs", "wacs", "wsae"], "szUrl": ["szeFrame", "sizUrl", "szerURL", "szaURL", "szurl", "szaUrl", " sizURL", "asizFrame", "szeurl", "sizURL", "szenURL", "szeUr", "szenurl", "sznURL", "szPath", "szeURL", "aszUrl", "sizFrame", " szURL", "aszurl", "aszURL", " szurl", "szerUr", "szeFolder", " sizFolder", " sizUrl", "sznurl", "aszUr", "szeUrl", "aszFrame", "asizUrl", "sziurl", "sizurl", "szFrame", "szenFolder", "sznPath", "szaUr", "szerUrl", "aszPath", "sznUr", " szFolder", "asizURL", "asizurl", "sznUrl", " sizurl", "sizFolder", "sziUrl", "sizUr", "sziURL", "szaPath", "szerFrame", "szenUrl", "sizPath", "sziUr", "szFolder", "szUr", "szURL", "asizUr", "asizPath"], "url": ["source", "org", "gl", "buffer", "cloud", "re", "uri", "client", " URL", "Url", "f", "config", "page", "event", "il", "l", "socket", "conn", "loc", "web", "service", "resource", "location", "context", "lb", "www", "base", "name", "log", "server", "host", "obj", "URL", "rl", "fl", "sl", "li", "connection", "string", "ur", "stream", "ul", "el", "ll", "impl", "file", "ssl", "key", "user", "get", "xml", "rel", "http"], "is": ["x", "as", "ris", "rx", "uri", "IS", "im", " isn", "isa", "was", "oss", "us", "ai", "info", "ii", "il", "isu", "iss", "i", "Is", "src", "serv", "ci", "iso", "web", "ib", "lis", "ir", " bis", "ip", "io", " are", "os", "it", "isf", "isc", "isl", "bs", "isi", "rc", "ais", "ios", "ils", "bis", "has", "ri", "cms"], "sout": ["Souts", " souts", "sdata", "sin", "SOut", " sOut", " sin", "Sin", "Sout", "souts", " sdata", "SOUT", "Sdata", "sOUT", "sOut", " sOUT"], "con": ["remote", "cache", "uc", "event", "Connection", "ca", "close", "core", "conf", "Con", "cur", "cc", "cp", "general", "fc", "un", "crit", "ct", "ctx", "type", "run", "can", "http", "ren", "pre", "util", "client", "ctrl", "pin", "ocon", "com", "ver", "view", "java", "conn", "const", "win", "don", "cos", "lc", "rc", "nc", "coll", "user", "cons", "pen", "fun", "cf", "single", "internal", "wa", "bc", "pc", "subject", "C", "gen", "wan", "en", "version", "san", "syn", "non", "login", "get", "inc", "status", "Internal", "xc", "re", "net", "c", "author", "l", "func", "m", "web", "open", "ec", "on", "connect", "conv", "server", "exec", "ran", "fe", "query", "min", "connection", "fa", "cl", "Common", "cn", "ssl", "CON", "common", "co"], "hNames": ["hrName", " hKeys", "hostNs", " hName", "HFiles", "HNames", "hBlocks", "hVs", "hrNs", " hNs", "HVs", " hBlocks", "hostTypes", "HName", " hFiles", " hVs", "ihBlocks", "hrTypes", "hTypes", "hKeys", "hostKeys", "hNs", " hTypes", "HBlocks", "hostNames", "ihName", "ihVs", "hrNames", "hFiles", "hrKeys", "ihNames", "HTypes", "hrFiles", "hName"], "txt": ["text", "ht", " text", "rx", "gt", "tin", "fp", "str", "fx", "git", "csv", "py", "vt", "gi", "lt", "gz", "wt", "rr", "phrase", "nt", "tx", "et", "XT", "qt", "elt", "utt", "nm", "q", "in", "prot", "TEXT", "binary", "name", "bt", "wx", "dt", "Text", "obj", "zip", "htm", "header", "struct", "inet", "jp", "value", "lv", "t", "key", "xt", "ct", "sv", "xxx", "kt", "v", "section", "cb", "ctx"], "inBody": [" inbody", "insReader", "InReader", "outFile", "inReader", "INbody", "insFile", "INStream", "Inbody", "insBody", "INReader", "InFile", " inReader", "InBody", " inFile", "INFile", "inFile", "inbody", "INBody", "insStream", " inStream", "outStream", "outbody", "outBody", "inStream", "InStream"], "bufCh": ["bufferch", "buffCh", " bufChar", "ufCol", "ufCH", "bufferCH", "ufCh", "queueCol", "bufch", "ufChar", "bufC", " bufC", "ufC", "queueCh", "ufch", "buffC", "queuech", " bufch", " bufCH", "bufferChar", "bufChar", "bufCH", "buffch", "bufferCh", " bufCol", "buffCH", "queueCH", "bufCol"], "r": ["p", "x", " rg", "result", "re", "str", "br", "c", "f", "reg", "rr", "w", "e", "i", "k", "m", "q", "ner", "rs", "ru", "sr", "n", "g", "ar", "v", "b", "u", "hr", "R", "nr", "rl", "cr", "rd", "res", "rc", "rb", "fr", "rw", "pr", "range", "lr", "rf", "rt", "er", "ror", "err", "reader", "rh", "ri", "d", "rg"], "outReq": ["outRquest", "outRece", " outRequest", " outRereq", "outConh", " outReh", "outDece", "outRsque", "outREce", " outEreq", " outEque", "outRecck", "outEque", "outRecce", " outSeck", "outReck", " outRsh", "outRque", "outREh", " outRque", "outREq", "outRsce", "outRreq", " outEq", "outEck", " outEck", "outDequest", "outRecque", "outREck", "outEq", "outSeq", "outReh", "outSequest", "outDeque", "outRq", "outREque", " outReck", "outRecreq", " outRece", "outConce", " outRsce", "outRsq", " outSeq", " outRsq", "outEreq", " outRsque", "outRereq", "outConq", "outSeck", " outReque", "outRsh", " outSeque", " outRquest", "outConque", "outRecq", "outDeq", "outRce", " outRce", " outSece", "outSeque", "outReque", "outRck", "outSece", " outRq", "outRequest"], "buff": [" Buff", "p", "buffer", "uf", "lines", "f", "bb", "info", "buf", "map", "data", "num", "b", "array", "Msg", "Pad", " Buffer", "Ptr", "Buffer", "ch", " chunk", "Info", "file", " buffers", "Buff"]}}
{"id1": "2396191", "id2": "1954410", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksfromURLSafe", "getLinksFromURLSlow", "getLinksFromURLSafe", "getLinksfromURLSlow", "getLinksFromURLfast", "getLinksFromUrlSlow", "getLinksFromUrlfast", "getLinksfromUrlFast", "getLinksfromURLfast", "getLinksFromSSLfast", "getLinksfromUrlSafe", "getLinksfromUrlfast", "getLinksFromUrlSafe", "getLinksFromStringfast", "getLinksFromSSLSafe", "getLinksFromUrlFast", "getLinksfromUrlSlow", "getLinksFromSSLSlow", "getLinksFromStringSlow", "getLinksFromSSLFast", "getLinksFromStringSafe", "getLinksFromStringFast", "getLinksfromURLFast"], "p_url": ["p6url", "eklink", "pfpage", "p6config", "pamlayer", "p6line", "p24link", "pfline", "pfurl", "p_service", "p64url", "pkhtml", "p24root", "pamurl", " p_line", "pipfile", "p6root", "pxline", "p24url", "x_service", "pflink", "p_root", "pklayer", "x_domain", "pe_url", "tp24file", "pe_root", "p__name", "tp_root", "p25layer", "p_link", "e_layer", "p_path", "tp_url", "p_html", "p9resource", "e_link", "p25link", "p25url", "p__resource", "p_file", "tp24root", "pe_config", "tp_file", "p_layer", "e_html", "p64path", "pfpath", "ekhtml", "p25html", "pxroot", "pe_line", "pklink", "p__path", "x_resource", "pxurl", "p_name", "pxconfig", " p_path", "pkurl", "ekurl", "p_domain", "p64page", " p_page", "pfroot", "p_line", "p9service", "pamhtml", "p_resource", "tp24link", "tp_link", "piproot", "pamlink", "p9url", "p_config", " p_resource", "p_page", " p_name", "e_url", "eklayer", "p9domain", "pffile", "tp24url", "pipurl", "piplink", "p__url", "p24file", "p64line"], "x_url": ["p_host", " x_log", "x_loc", " x_resource", "p_loc", " x_ssl", "x_ssl", "p_conn", "x_resource", "x_log", "x_host"], "x_conn": ["x_con", "p_con", "x_client", "p_client", "wx_conv", "x___client", "wx_conn", "x___db", "wx_cat", "wx_con", "x___conn", "x_conv", "x_cat", "x_db", "p_conn", "x___con", "p_db"], "x_is_reader": ["x_is_stream", "x_ismldraft", "x_is_draft", "x_ismlmanager", "x_is_pointer", "x_is_resource", "x_ismlreader", "x_is_writer", "x_ismlstream", "x_is_manager"], "x_reader": ["cross_url", "x8root", "X_reader", "cross_parser", "x8parser", "cross8reader", "X_result", "x8url", "x67root", "x_stream", "x24result", "cross8url", "x_parser", "x67url", "x67parser", "cross_root", "x24stream", "cross8parser", "X_stream", "X_parser", "x24reader", "cross8root", "x67reader", "x24parser", "x8reader", "cross_reader"], "x_line": ["x_record", "xingcell", "x__line", "xingline", "p_line", "xx_comment", "x_lin", "x_cell", "p_link", "x24line", "ex_line", "ex_cell", "x__link", "xingpage", "p_page", "x__page", "x24link", "x__url", "x24lin", "ex_record", "ex_page", "xx_lin", "xx_line", "xingrecord", "x24comment", "xx_link", "x_comment"], "e": ["p", "me", "match", "eps", "eve", "re", "se", "ace", "c", " E", "eu", "f", "event", "eur", "ie", "driver", "l", "line", "oe", "ele", "E", "m", "ce", "ze", "ec", "ne", "n", "g", "error", "ente", "b", "pe", "edge", "te", "code", "ge", "exec", "fe", "entity", "body", "je", "eb", "he", "element", "ee", "el", "engine", "ae", "en", "file", "es", "y", "ev", "r", "er", "t", "entry", "o", "le", "end", "v", "esi", "ue", "d", "ea"], "x_match": ["xlmatch", "e_match", "x5case", "p__pattern", "x__case", "xlgroup", "ax5link", " x_tag", "xamslice", "p_matched", "x___check", "extJmatch", "xjurl", "x__url", "p__matched", " x_case", "x5match", "xldate", " x__slice", "x_info", "x_group", "xJmatch", " x_group", "x_date", "x_matched", "ax5case", " x_replace", "x___matched", "xlsearch", "x__match", "x_replace", "ax5info", "x_meet", "x5link", "x__replace", "xlpattern", "ext_search", "xjmatch", "extJpattern", "x_search", "p_pattern", "e_matched", "x__matched", "ext_member", " x_date", "ax_link", "ax_match", "xamcase", "x___match", "p_match", "xJpattern", "e___matched", "e_meet", " x_slice", "e_check", "x_pattern", "x___meet", "xJsearch", "ext_pattern", "x_member", "extJsearch", "xjmatched", "x_check", "x5info", "e___meet", "xJmember", " x__case", "x_case", "xammatch", "p__match", "x_slice", " x__replace", "ax_info", "x_tag", "ext_match", "xamreplace", "xltag", "e___check", "e___match", "x__pattern", "x__slice", "xjpattern", " x__match", "xlmember", "p__url", "ax5match", "extJmember", "ax_case"], "x_dir": ["x_group", "xnetgroup", " x_group", "x6url", " x_file", "xneturl", "x6group", "xnetfile", "x_file", "x6file", "xnetdir", "x6dir"], "x_root": ["x7alias", "x7root", "xml_directory", "x7path", "xml_path", "x_path", "x7directory", "xml_root", "xml_alias", "x_alias", "x_directory"], "x_links": [" x_ids", " x_points", " x_lines", "x67ids", "x_ids", "x67lines", "x67links", "x_lines", "x67points", "x_points"], "x_texts": ["x_pathes", "x_paths", "x_logches", "x_urls", "x_pathls", "x_loges", "x_textches", "x_logls", "x_urlches", "x_logs", "x_urlls", "x_textes", "x_pathches", "x_urles", "x_textls"], "x_buf": ["y_rc", "x_bag", "y__rc", "x1buf", "x__tmp", "X_buf", "x__buff", "ex__tmp", "x___bag", "x64rc", "x_wb", "X_buffer", "x_uf", "x___buf", "x__buffer", "x_tmp", "x__cb", "x1buff", "x64uf", "X_buff", "x1tmp", "x64bag", "y_buf", "x__buf", "x64buf", "ex__cb", "ex_cb", "X_wb", "ex__buff", "y_bag", "y__uf", "x__wb", "x__rc", "ex_tmp", "x___uf", "ex_buff", "x___rc", "y__bag", "x_cb", "x1cb", "x__uf", "ex_buf", "ex__buf", "x_rc", "y_uf", "x_buffer", "x__bag", "x_buff", "y__buf"], "x_matches": ["x_attched", "x_patcks", "x_bathes", "x_matures", "x_Matures", "x_calhes", "x_mathes", "x_matchers", "x_patchers", "x_matchches", "x_attcks", "x_matchcher", "x_matched", "xKtextings", "x_batches", "x_batures", "x_Matches", "x_textches", "xKtexthes", "x_matchched", "x_matcher", "x_morched", "x_matchchers", "x_patched", "x_attches", "x_atthes", "x__matches", "x__matures", "x_matoms", "xKmatings", "x_pathes", "x_loches", "x_matcks", "xKmatches", "x_locting", "x_morches", "x_matings", "x_matting", "xKtextches", "x_calches", "xKtextoms", "x_textoms", "x_textings", "x__mathes", "x_patches", "x_Matchers", "x_locches", "x_caloms", "x_matchings", "x_batchers", "x_matchhes", "x_Matcher", "x_calings", "x_locched", "x_morting", "xKmatoms", "x_Mathes", "x_patcher", "x__matchers", "x_morhes", "xKmathes", "x_matchcks", "x_matchting", "x_texthes", "x_matchoms"], "x_page": ["xerline", "x_feed", "X_page", "X_url", "x67page", "X_line", "x_loc", "ex_link", "ex_file", "tx_feed", "xerlink", "x67file", "x67link", "x_file", "tx_line", "x67loc", "tx_page", "ex_loc", "x_path", "ex_page", "xerfeed", "X_path", "xerpage", "tx_link"], "x_link": ["xpubline", " x_loc", "ex_link", "x_loc", "xpublink", "xpubtarget", "ex_line", "ex_url", " x_target", "ex_page", "xpubloc", "x_target"], "i": ["p", "x", "uri", "z", "c", "f", "ai", "gi", "ii", "info", "ori", "ix", "ie", "I", "k", "count", "ci", "ini", "in", "chi", "multi", "n", "io", "iu", "a", "si", "bi", "u", "b", "it", "iv", "ui", "pi", "oi", "ji", "index", "li", "j", "hi", "di", "qi", "eni", "y", "xi", "r", "key", "o", "id", "zi", "v", "ri", "ti", "phi"]}}
{"id1": "22264586", "id2": "21656668", "code1": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFiles": ["copyPages", "Copyfiles", " copyfiles", "copyChildren", "copyFile", "transferPages", " copyPages", "copyfiles", "transferfiles", "CopyFile", " copyFile", "transferFile", "cloneFile", " copyChildren", "CopyFiles", "cloneFiles", "clonefiles", "transferChildren", "CopyChildren", "clonePages", "transferFiles"], "strPath": [" strFile", "strpath", "strLog", "STRLog", "strFile", "striLog", "StrLog", " strpath", "strName", " strName", "STRpath", "stName", "Strpath", "StrPath", "STRPath", "stPath", "STRFile", "stpath", "striFile", "stripath", "striPath", "StrName", "StrFile", "stFile"], "dstPath": ["fstFile", "fstpath", "drcPath", "dndDir", "drcDir", "dstDir", "dndName", "dndPath", "fstsFile", "sdstpath", "dblFile", "sdndName", "sdndPath", "ddestPath", "drcName", "fstsPath", "fstPath", "dblpath", "dstsDir", "ddestName", "dstFile", "dblDir", "ddestDir", "drcpath", "dstsFile", "dndpath", "fstspath", "dstsPath", "sdndpath", "sdstPath", "dstspath", "fstDir", "dstName", "fstsDir", "dblPath", "sdndDir", "sdstDir", "dstpath", "sdstName", "ddestpath", "ddestFile"], "src": ["back", "in", "sc", "client", "self", "sort", "sl", "ctx", "upload", "scripts", "sync", "stream", "host", "rc", "s", "tmp", "sit", "slice", "rs", "input", "ls", "sin", "reverse", "RC", "sb", "loc", "source", "rb", "path", "cur", "inst", "ssl", "img", "sup", "Source", "dist", "config", "secure", "sel", "url", "st", "this", "download", "sq", "SOURCE", "obl", "split", "sub", "project", "front", "sys", "cmp", "iv", "ource", "ruby", "cb", "rob", "ources", "txt"], "dest": ["db", "de", " Dest", "delete", "default", "tmp", "dd", "comb", "cat", "thin", "slave", "home", "Dest", "target", "result", "dc", "wh", "desc", "dep", "later", "img", "out", "cdn", "sup", "ds", "dist", "wd", "secure", "gd", "wb", "rest", "des", "zip", "flat", "div", "temp", "trans", "done", "test", "di", "du", "style", "d", "front", "project", "prop", "folder", "destroy", "dat", "source", "txt"], "list": ["size", "sort", "entry", "key", "s", "chain", "map", "parent", "info", "str", "base", "dl", "test", "name", "string", "p", "batch", "full", "is", "load", "strings", "json", "stack", "val", "lines", "keys", "diff", "array", "bl", "path", "part", "set", "lists", "ll", "remove", "status", "arr", "l", "like", "filter", "www", "stat", "stream", "files", "delete", "ls", "LIST", "id", "lc", "run", "pair", "dir", "url", "null", "split", "cl", "names", "cont", "source", "la", "all", "queue", "version", "write", "coll", "group", "listed", "code", "members", "none", "data", "type", "parents", "read", "config"], "i": ["r", "ai", "ip", "m", "j", "p", "n", "ie", "key", "multi", "ix", "slice", "e", "phi", "id", "mu", "ci", "gi", "abi", "ui", "info", "a", "li", "index", "ii", "io", "bi", "part", "start", "x", "pi", "f", "o", "xi", "ti", "ri", "type", "u", "data", "b", "y", "v", "ji", "oi", "di", "hi", "me", "si", "qi", "uri", "c", "I", "length"], "dest1": ["sourceOne", "srcOne", "source1", " destone", "Dest0", "homeone", "sourceone", "source2", "source0", "destone", "destOne", "home1", "dest0", "dest2", "Dest1", "src0", "src2", "DestOne", "Dest2"], "src1": [" src2", "sourceOne", "srcOne", "source1", "sourceone", "source2", " srcOne", "rc2", "rcOne", "rc1", "src2", "rcone", "srcone", " srcone"], "sourceChannel": ["srcChannel", "SourceStream", "srcChan", "ourceChan", "sourceChan", " sourceStream", "ourceContext", "ourceStream", "sourceContext", "targetStream", "ourceChannel", "targetchannel", "targetChan", "sourceStream", "srcStream", "targetContext", " sourceChan", " sourceContext", "SourceContext", " sourcechannel", "srcContext", "SourceChannel", "Sourcechannel", "sourcechannel", "SourceChan"], "targetChannel": ["argetChan", "sourceChan", "TargetChan", "TargetContext", "sourceContext", "destChan", "targetManager", "TargetConnection", "targetchannel", "targetChan", "TargetChannel", "argetchannel", "targetContext", "destContext", " targetchannel", "destChannel", "argetChannel", " targetContext", "argetManager", "Targetchannel", " targetConnection", "destConnection", "TargetManager", "sourcechannel", "targetConnection", " targetChan", " targetManager"]}}
{"id1": "6190356", "id2": "4750967", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldM5", " hashPasswordForOldM3", " hashPasswordForNewM512", " hashPasswordForOldM512", " hashPasswordForNewMD5", " hashPasswordForOldMC5", " hashPasswordForOldmd4", " hashPasswordForNewM3", " hashPasswordForOldM4", " hashPasswordForOldMC3", " hashPasswordForOldMD3", " hashPasswordForOldmd5", " hashPasswordForOldmd3", " hashPasswordForNewMD512", " hashPasswordForNewMD4", " hashPasswordForOldMD512", " hashPasswordForOldMC512", " hashPasswordForNewM5", " hashPasswordForOldMD4", " hashPasswordForOldMC4", " hashPasswordForNewM4", " hashPasswordForOldmd512", " hashPasswordForNewMD3"], "password": ["pass", "words", "username", "token", "seed", "sword", "string", "word", "secret", "input", "Password", "PASS", "wallet", "path", "key", " passwords", "auth", "pad", "wd", "content", "address", "p", " Password", "phrase", "array", "code", "value", "hash", "result", "data", "account", "message", "pattern", "buffer", "crypt", "text", "name", "encrypted", "padding"], "md": ["dc", "df", "mb", "mp", "pd", "pm", "od", "mand", "clean", "mac", "Cmd", "m", "pg", "rm", "um", " MD", "km", "d", "hm", "di", "MD", "bd", "meta", "wd", "hd", "vm", "dd", "mc", "cd", "mod", "cmd", "mag", "ma", "f", "am", "gd", "ind", "dm", "nm", "amd", "managed", "rpm", "dig", "mm", "metadata", "vd", "grad", "mt", "mo"], "messageDigest": ["messageDest", "MessageAddest", "messageDester", " messageDigester", "messageDigse", "messageModests", "messageModEST", " messageModests", "MessageDigester", "messageAddse", "messagedigest", "messageDigester", "messagedigse", "messagedigester", "messageModester", "MessageAddester", "messageDigEST", " messageDigests", "messageAddester", "MessageAddse", "MessageDigEST", "messagedigEST", " messageModest", "messageDigests", "messagedigests", "messageAddests", "messageAddEST", "MessageModse", "MessageModester", "MessageModest", "messageDEST", "MessageDigest", " messageModester", "messageDse", "MessageAddEST", "messageModest", "MessageModEST", "MessageDigse", "messageAddest", "messageModse", " messageDigEST", " messageModEST"], "hexString": ["crossFunction", "stringService", " hexFile", "tempstring", "hashString", "stringString", "tempFunction", "sumFile", "transformBuffer", "hexstring", "hexFile", "transformString", "hashService", "crossString", "hashSection", " hexstring", "sumstring", "octString", "transformArray", "hexSection", " hexBuffer", "stringSection", "hexArray", " hexArray", "hexBuffer", "hexService", "stringArray", "tempFile", "transformStr", "sumString", "octArray", "hexStr", " hexService", "tempString", "crossStr", "hexFunction", "octBuffer", "octStr", "tempStr", "sumStr", "crossstring", " hexFunction", "hashArray", " hexSection", " hexStr"], "i": ["si", "qi", "ip", "u", "multi", "n", "c", "ii", "m", "pi", "k", "o", "d", "ci", "di", "io", "slice", "ji", "ui", "length", "ri", "bi", "p", "l", "phi", "s", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "a", "h", "v", "ti", "ai", "r", "b", "xi", "t", "id", "info", "uri", "ix"], "hex": ["temp", "cmp", "ip", "nexus", "full", "string", "cache", "utf", "zero", "host", "rh", "ex", "exp", "http", "shift", "str", "character", "pixel", "transform", "path", "none", "char", "bit", "json", "length", "letter", "lit", "cookie", "batch", "alpha", "default", "oct", "orig", "hello", "pex", "he", "serial", " Hex", "rex", "comp", "sex", "hash", "h", "format", "result", "data", "raw", "digit", "null", "pack", "hack", "buff", "pattern", "binary", "text", "form"]}}
{"id1": "6470716", "id2": "20920051", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"st": ["struct", "fe", "stage", "sth", "class", "est", "string", "rest", "ust", "sf", "ost", "str", "d", "ist", "www", "ft", "ST", "inst", "sc", "pt", "ct", "const", "ste", "ld", "cl", "s", "stress", "ast", "sb", "f", "sta", "code", "start", "St", "std", "sts", "r", "put", "t", "id", "tt", "Str", "src", "fr"], "url": ["or", "fr", "ob", "zip", "string", "blog", "host", "http", "tool", "pl", "www", "URL", "log", "path", "ll", "ur", "open", "feed", "gl", "Url", "impl", "download", "user", "address", "bel", "bug", "loc", "build", "err", "cl", "l", "connection", "base", "ls", "server", "coll", "sl", "f", "link", "hub", "ul", "image", "html", "ssl", "bb", "page", "fl", "b", "id", "web", "uri", "stream", "source", "org", "file"], "fis": ["afIs", "fips", "fIS", "flIs", "biss", "Fiss", "lils", "flos", "fli", "afis", " fips", "flils", "flris", "liss", "lris", "fils", "fIs", " fiss", "bos", "fris", "bi", "zris", "afiss", " fi", "FIS", "fi", " fris", "FIs", " fIS", "flis", "Fis", "zips", "fliss", " fils", "Fos", "bis", "lis", "afos", "Fris", "Fips", "fiss", "zIS"], "zis": ["zits", "ziss", " zais", "zeisa", "qbis", "qi", "zais", "zeIS", " ziss", "zisa", "zenis", " zisa", "zeips", "zipisi", " zips", "Ziss", "zipi", "zipits", " zits", "zipis", "qiss", " zisi", " zbis", "qis", "zenisi", "Zais", " zois", "zenais", "ezisa", "zbis", "zipois", "zipbis", "Zits", "zips", "zois", "zipais", " zIS", "ezIS", "zenois", "Zis", "ezis", "zisi", "zeis", "zipiss", "zi", " zi", "zIS", "ezips"], "entry": ["dc", "row", "or", "je", "fr", "ry", "country", "si", "line", "cat", "zip", "exp", "spec", "Entry", "comment", "inner", "ge", "feed", "match", "key", "la", "enter", "in", "object", "address", "archive", "ie", "part", "cell", "pe", "element", "rc", "sea", "sec", "ident", "index", "e", "ries", "session", "li", "image", "auto", "record", "result", "nt", "se", "next", "reader", "parse", "obj", "ent", "r", "de", "inc", "info", "ace", "cel", "file", "lc", "extra"], "count": ["use", "line", "c", "cache", "current", "depth", "limit", "more", "sum", "log", "feed", "Count", "list", "number", "add", "skip", "length", "child", "default", "part", "base", "max", "load", "size", "read", "index", "code", "len", "allow", "i", "ind", "start", "check", "_", "val", "counter", "type", "write", "en", "id", "parent", "buffer", "offset", "name", "file", "end"], "data": ["string", "cache", "zero", "dat", "shift", "results", "d", "str", "area", "input", "feed", "empty", "buf", "number", "length", "content", "p", "alpha", "batch", "load", "DATA", "size", "read", "block", "code", "len", "i", "value", "image", "start", "a", "bytes", "result", "reader", "error", "raw", "message", "info", "buffer", "text", "body"], "fos": ["Fol", "fnos", "fol", "zol", "frosh", "flos", "efoses", "froses", "fosh", "dfos", "efosh", "dfosi", "dfosh", "fros", "flOS", "flnos", "efos", "fOS", "fosi", "foses", "efosi", "frosi", "flol", "Fos", "FOS", "dfoses", "zos", "znos", "Fnos", "zOS"], "dest": ["dc", "cdn", "temp", "done", "txt", "wh", "exit", "zip", "rest", "dat", "dist", "inner", "transform", "sum", "desc", "di", "outer", "south", "die", "slice", "sync", "dev", "coord", "const", "loc", "sup", "trans", "default", "comb", "flash", "out", "tmp", "des", "home", "writer", "Dest", "result", "std", "img", "output", "test", "style", "target", "prop", "de", "source", "stream", "wb", "cont", "src", "later", "end"]}}
{"id1": "9371421", "id2": "1985677", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public SRWGuiClient(String initialURL) {\n        super(\"Simple Swing Browser\");\n        this.initialURL = initialURL;\n        addWindowListener(new ExitListener());\n        WindowUtilities.setNativeLookAndFeel();\n        JPanel topPanel = new JPanel();\n        topPanel.setBackground(Color.lightGray);\n        homeButton = new JIconButton(\"home.gif\");\n        homeButton.addActionListener(this);\n        JLabel urlLabel = new JLabel(\"URL:\");\n        urlField = new JTextField(30);\n        urlField.setText(initialURL);\n        urlField.addActionListener(this);\n        topPanel.add(homeButton);\n        topPanel.add(urlLabel);\n        topPanel.add(urlField);\n        getContentPane().add(topPanel, BorderLayout.NORTH);\n        try {\n            URL url = new URL(initialURL);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            boolean xml = true;\n            String inputLine;\n            StringBuffer content = new StringBuffer(), stylesheet = null;\n            Transformer transformer = null;\n            inputLine = in.readLine();\n            if (inputLine == null) {\n                System.out.println(\"No input read from URL: \" + initialURL);\n                return;\n            }\n            if (!inputLine.startsWith(\"<?xml \")) {\n                xml = false;\n                content.append(inputLine);\n            }\n            if (xml) {\n                inputLine = in.readLine();\n                if (inputLine.startsWith(\"<?xml-stylesheet \")) {\n                    int offset = inputLine.indexOf(\"href=\");\n                    String href = (inputLine.substring(inputLine.indexOf(\"href=\") + 6));\n                    href = href.substring(0, href.indexOf('\"'));\n                    System.out.println(\"href=\" + href);\n                    url = new URL(url, href);\n                    String stylesheetURL = url.toString();\n                    System.out.println(\"stylesheet URL=\" + url.toString());\n                    transformer = (Transformer) transformers.get(stylesheetURL);\n                    if (transformer == null) {\n                        BufferedReader sheetIn = new BufferedReader(new InputStreamReader(url.openStream()));\n                        sheetIn.readLine();\n                        stylesheet = new StringBuffer();\n                        while ((inputLine = sheetIn.readLine()) != null) stylesheet.append(inputLine).append('\\n');\n                        System.out.println(stylesheet.toString());\n                        TransformerFactory tFactory = TransformerFactory.newInstance();\n                        StreamSource xslSource = new StreamSource(new StringReader(stylesheet.toString()));\n                        transformer = tFactory.newTransformer(xslSource);\n                        transformers.put(stylesheetURL, transformer);\n                    }\n                }\n            }\n            while ((inputLine = in.readLine()) != null) content.append(inputLine).append('\\n');\n            htmlPane = new JEditorPane();\n            if (transformer != null) {\n                StringReader stringRecordReader = new StringReader(content.toString());\n                StringWriter xmlRecordWriter = new StringWriter();\n                StreamSource streamXMLRecord = new StreamSource(stringRecordReader);\n                transformer.transform(streamXMLRecord, new StreamResult(xmlRecordWriter));\n                String html = xmlRecordWriter.toString();\n                int i = html.indexOf('>');\n                html = \"<html>\" + html.substring(html.indexOf('>') + 1);\n                System.out.println(html);\n                htmlPane.setContentType(\"text/html\");\n                htmlPane.setText(\"<html><head><META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\"><title>GSAFD Thesaurus</title></head><body><center><h2>GSAFD Thesaurus</h2></center><p>A thesaurus of genre terms to support the \\\"Guidelines on Subject Access to Individual Works of Fiction , Drama\\\" (GSAFD)</p><table cellspacing=\\\"5\\\" width=\\\"100%\\\"><tr><td><h3>Search</h3><p></p></td><td valign=\\\"top\\\"><h3>Browse</h3></td></tr></table></body></html>\");\n            } else htmlPane.setText(content.toString());\n            htmlPane.setEditable(false);\n            htmlPane.addHyperlinkListener(this);\n            JScrollPane scrollPane = new JScrollPane(htmlPane);\n            getContentPane().add(scrollPane, BorderLayout.CENTER);\n        } catch (IOException ioe) {\n            warnUser(\"Can't build HTML pane for \" + initialURL + \": \" + ioe);\n        } catch (TransformerException e) {\n        }\n        Dimension screenSize = getToolkit().getScreenSize();\n        int width = screenSize.width * 8 / 10;\n        int height = screenSize.height * 8 / 10;\n        setBounds(width / 8, height / 8, width, height);\n        setVisible(true);\n    }\n", "label": 0, "substitutes": {"eventHash": ["messageDig", " eventKey", "bytehash", "byteDig", "messageKey", " eventDig", "byteHash", "eventDig", "byteKey", "eventhash", "eventKey", "messagehash", " eventhash", "messageHash"], "eventstr": ["errorStr", "eventdict", "Eventstr", " eventsource", "exStr", "Eventstring", "exstr", " eventStr", "errorsource", "errorstring", "Eventdict", "EventStr", " eventstring", "Eventsource", " eventdict", "eventStr", "exdict", "errorstr", "exstring", "eventstring", "eventsource"], "md": ["m", "wd", "hd", " MD", "mp", "dr", "cmd", "sha", "data", "mo", "dig", "dd", "rpm", "hash", "map", "mc", "mag", "d", "vd", "od", "ms", "meta", "key", "hm", "ng", "amd", "mg", "dm", "bd", "mb", "metadata", "cm", "MD", "di", "mn", "ad", "mac", "id", "mand", "mm", "sm", "ma", "mem", "ke", "ld", "em", "pm", "mt", "mu", "mod", "dh", "doc"], "theDigest": ["TheDigEST", " theSignester", " theSignEST", "thedigester", "theDigester", "theHashEST", "theHashester", "thedighest", "thedigEST", " theDighest", "TheDigester", "Thedigester", "theDighest", "theSignest", "theSignEST", "ThedigEST", " theSignest", "theSignester", "theHashest", "theDigEST", "thedigest", "theSignhest", " theDigEST", " theSignhest", "Thedigest", " theDigester", "TheDigest"]}}
{"id1": "22268798", "id2": "8486429", "code1": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "code2": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["createContent", "buildResource", "buildContent", "loadResource", "getContents", "loadcontent", "getcontent", "createContents", "buildContents", "getResource", "buildcontent", "loadContent", "createResource", "loadContents", "createcontent"], "principal": ["prunctential", "prercipal", "Princunctential", "pruncteter", "princeter", "prerceter", "Princincipal", "prunctipal", "Princincificate", "pricipificate", "Princuncteter", "pricipeter", "Princunctipal", "pricipipal", "princificate", "prunctificate", "prercificate", "prercential", "Princunctificate", "Princincential", "princential", "Princinceter", "pricipential"], "path": ["text", "source", "method", "property", "prop", "uri", "client", "Path", "instance", "info", "link", "PATH", "ath", "root", "pointer", "project", "data", "loader", "object", "location", "resource", "format", "context", "class", "next", "name", "api", "string", "prefix", "file", "request", "part", "user", "parent", "node", "pattern"], "version": ["current", "json", "depth", "str", "out", " versions", "vision", "versions", "date", "ver", "model", "VERSION", "level", "project", "val", "release", "object", "resource", "format", "server", "string", "Version", "value", "parent", "v", "node", "target"], "properties": ["types", "property", "ps", "prop", "perties", "json", "ips", "state", "options", "resources", "data", "metadata", "values", "Property", "objects", "params", "address", "features", "details", "settings", "Pro", "plugins", "pro", "results", "items", "classes", "fields"], "uniqueName": ["stringName", " uniquename", " uniqueTime", "basePath", "filename", "basename", "blockPath", " uniqueType", "uniqueKey", "filePath", "UniqueTime", "Uniquename", "fileTime", "stringKey", "UniquePath", "uniqueType", "baseKey", "UniqueName", "stringPath", "blockType", "stringname", "uniquePath", "fileName", "baseName", " uniqueKey", " uniquePath", "UniqueType", "uniqueTime", "blockName", "UniqueKey", "blockKey", "uniquename"], "url": ["ls", "source", "position", "uri", "client", "Url", "download", "f", "bb", "this", "page", "link", "l", "conn", "image", "build", "loc", "found", "web", "object", "location", "resource", "proxy", "open", "www", "base", "name", "log", "server", "host", "URL", "address", "sl", "string", "channel", "layer", "el", "ll", "coll", "html", "file", "ssl", "feed", "ob", "user", "parent", "error", "http"], "content": ["source", "message", "create", "remote", "result", "copy", "media", "output", "current", "client", "cache", "cf", "cover", "c", "load", "instance", "config", "ac", "this", "model", "page", "update", "ca", "conn", "image", "complete", "default", "condition", "data", "const", "object", "resource", "proxy", "ce", "location", "comment", "core", "document", "cont", "lc", "ext", "host", "code", "server", "change", "child", "address", "container", "section", "handler", "cm", "layer", "wrapper", "full", "coll", "creator", "Content", "temp", "file", "key", "response", "reader", "user", "parent", "common", "node"], "connection": ["relation", "position", "uri", "client", "connected", "session", "c", "config", "Connection", "http", "control", "conn", "image", "loc", "data", "con", "object", "resource", "context", "open", "proxy", "communication", "io", "directory", "connect", "character", "database", "server", "pool", "number", "container", "string", "channel", "handler", "coll", "creator", "response", "reader", "section", "application"], "mimeType": ["mmimeInfo", "mimesType", "mIMEInfo", "miveInfo", "MimeType", "mangPath", "mimeName", "mmimeType", "MIMEtype", "mimePath", "mimeInfo", "mimetype", "Mimetype", "mIMEName", "metyInfo", "mmiveType", "mIMEtype", "metyType", "mimestype", "MimeName", "mmimetype", "mIMEPath", "mangName", "MIMEPath", "mangType", "mmivetype", "MIMEName", "mangtype", "mivetype", "miveType", "mmiveInfo", "mimesPath", "MimePath", "MIMEType", "mIMEType", "metytype", "mimesName"]}}
{"id1": "21642215", "id2": "7545002", "code1": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "code2": "    public static String POST(String url, String[][] props) throws IOException {\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        for (int i = 0; i < props.length; ++i) {\n            conn.addRequestProperty(props[i][0], props[i][1]);\n        }\n        conn.connect();\n        try {\n            return new String((byte[]) conn.getContent());\n        } finally {\n            conn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"addIDs": ["loadID", "loadLinks", "addIDS", "findIDs", "findLinks", "loadIDS", "addLinks", "loadIDs", "findIDS", "addID", " addIDS", " addID", "findID", " addLinks"], "row": ["item", "entry", "group", "ry", "scan", "col", "table", "view", "copy", "report", "feed", "list", "key", "post", "tr", "user", "bug", "batch", "up", "ro", "cell", "server", "query", "index", "per", "array", "tab", "head", "record", "result", "reader", "raw", "r", "job", "info", "column", "builder", "Row", "ow", "rows"], "name": ["Name", "resource", "username", "description", "n", "string", "word", "title", "str", "named", "time", "path", "search", "key", "number", "connection", "prefix", "query", "size", "filename", "image", "start", "ame", "NAME", "filter", "type", "info", "source", "alias", "file"], "in": ["resource", "string", "In", "token", "container", "again", "serv", "at", "n", "c", "ini", "IN", "rec", "m", "cin", "ex", "cache", "xml", "http", "is", "inner", "din", "bin", "with", "input", "ic", "as", "path", "con", "pin", "ins", "doc", "conn", "min", "inn", "user", "err", "it", "l", "init", "s", "win", "out", "query", "gin", "f", "iter", "session", "i", "nin", "a", "image", "record", "socket", "login", "ssl", "file", "reader", "gen", "diff", "r", "b", "inc", "buffer", "stream", "source", "lock", "re", "update"], "urlName": ["filePart", "fileName", "urlPart", "UrlName", "toolPath", "lname", "URLName", "urlStr", "UrlPart", "lName", "toolName", " urlname", "urlPath", " urlPath", "URLPath", " urlType", "Urlname", "lPath", "urlname", "filePath", "UrlStr", " urlStr", "lStr", "toolname", "filename", " urlPart", "URLname", "lType", "UrlType", "urlType", "UrlPath"], "url": ["resource", "channel", "http", "service", "input", "URL", "path", "io", "open", "feed", "gl", "Url", "client", "user", "bel", "l", "connection", "base", "out", "server", "loader", "sl", "f", "link", " URL", "hub", "image", "socket", "ssl", "reader", "fl", "r", "b", "web", "uri", "stream", "source", "buffer", "org", "file"], "inputLine": ["InputLo", "typeline", "readSync", "rawL", " inputline", "readLook", "inputString", "againLINE", "inputStream", "dataLINE", "readline", "InputBlock", "requestUrl", "inputBlock", "searchLine", "formLINE", "formLin", "indexEntry", "inputline", "dataLink", "formline", "inputLo", " inputSync", "htmlString", "dataRoute", "InputStream", "issueline", "uploadline", "formLine", "Inputline", " inputEntry", "responseFile", "requestEmail", "dataLook", "inputFile", "inputLook", "uploadLin", "dataUrl", " inputFile", "dataSync", "typeLink", "indexLine", "rawFile", " inputString", "htmlline", "typeLine", "inputL", " inputLINE", "inputLink", "InputLink", " inputLo", "updateLine", "input\n", "againLine", "inputWrite", "dataLo", "uploadSel", "dataLine", "indexLINE", "againUrl", "output\n", "execEmail", "readL", " inputLin", "accessLINE", "execLine", "readLin", "baseline", "dataFile", " inputL", "Input\n", "requestLINE", " inputStream", "requestLine", "dataline", " inputUrl", "accessSync", "InputRoute", "requestline", "readFile", " inputWrite", "htmlLine", "InputFile", "inputLINE", "baseLine", "responseLink", "accessLine", "rawline", "inputLin", "dataSource", "updateLin", " inputLook", "htmlLINE", "InputLine", "searchStream", "rawLine", "baseLINE", "againWrite", "typeLINE", "inputSource", "readLine", "responseLine", "inputSync", " inputLink", "uploadLine", "inputUrl", "updateline", "indexSync", "accessEntry", " inputSel", "InputSource", "responseLINE", " inputEmail", "execUrl", "dataLin", "searchFile", "baseFile", " inputRoute", "dataBlock", "inputEntry", "requestString", "issueLine", "updateLINE", " inputBlock", " inputSource", "dataWrite", "inputSel", "inputRoute", " input\n", "InputLINE", "InputSync", "issueLin", "InputL", "execline", "inputEmail", "searchL", "issueSel"], "score": ["scoring", "live", "ranking", "status", " Score", "seed", "fee", "speed", "Score", "player", "winner", "time", "cost", "sc", "match", "ner", "key", "fit", "length", "count", "weight", "grade", "rate", "confidence", "width", "rank", "price", "size", "game", "index", "code", "gain", "value", "rice", "feature", "result", "loss", "test", "level", "error", "message", "core"], "metaboliteID": ["metovaliteName", "metabolitionID", "metabololeName", "metabolheticId", "metmboliqueType", "metabolheticIndex", "metabolitionId", "metabolitableID", "metabolitationId", "metmboliteIDs", "metabolriteIN", "metovaliteAddress", "metabolicizeID", "metovalriteIN", "metabolizeName", "metabolriteScore", "metabolidateScore", "metabolriteAddress", "metabolizeScore", "metabolriteId", "metovalriteIndex", "metabolverseIN", "metabolitableName", "metabolheticID", "metovaliteIndex", "metaboliciteName", "metovalriteId", "metaboliteIDs", "metaboliciteInfo", "metmboliqueIDs", "metovalriteAddress", "metabolitableType", "metaboliqueIDs", "metabolriteIndex", "metabololeSize", "metaboliqueID", "metabolidateInfo", "metmboliqueID", "metabolitationName", "metabolizeID", "metabolitableSize", "metmboliteID", "metaboliciteScore", "metabolicizeName", "metovaliteId", "metabolheticAddress", "metmboliteIndex", "metaboliqueId", "metmbolitableIndex", "metaboliteType", "metovaliteIN", "metovalriteID", "metaboliqueType", "metabolriteInfo", "metaboliteAddress", "metabolriteSize", "metabolriteName", "metabololeIndex", "metabolriteType", "metabolitionAddress", "metovalriteName", "metabolizeInfo", "metaboliteScore", "metabolitionIndex", "metabolverseName", "metaboliteName", "metaboliteId", "metabolverseId", "metaboliciteID", "metabolitationIN", "metabolriteIDs", "metabolitableId", "metaboliteIndex", "metmboliteId", "metmbolitableSize", "metabolitationID", "metabolitableIndex", "metaboliteSize", "metabolicizeScore", "metabolidateName", "metabolidateID", "metabolitableIDs", "metabololeID", "metabolverseID", "metmboliqueId", "metmbolitableID", "metmboliteName", "metmboliteType", "metaboliteInfo", "metabolicizeInfo", "metmbolitableName", "metabolriteID", "metaboliteIN", "metmboliteSize", "metovaliteID"], "dataScore": [" dataMatch", "laScore", " dataLevel", " dataRank", "DataScore", "DataMatch", "inputMatch", "laPath", "numberType", "dataID", "videoType", "DataSize", "doubleWeight", "inputSource", "DataRank", "dataRank", "laSum", "styleWeight", "DataSum", "dataWeight", "numberGrade", " dataSum", "inputScore", "DataPath", "dataPath", "videoScore", "numberWeight", "styleSize", "dataMatch", "dataSize", "indexScore", "DataLevel", "indexPath", "doubleScore", "numberScore", "inputPath", "dataType", "numberLevel", " dataPath", "styleScore", "dataSum", "indexSource", " dataGrade", "doubleRank", "indexID", "styleType", "dataGrade", " dataSize", " dataSource", " dataWeight", "numberRank", "DataGrade", "inputID", " dataType", "videoSize", "laLevel", "dataSource", "inputSize", " dataID", "videoWeight", "doubleType", "dataLevel"], "data": ["resource", "done", "media", "zip", "string", "map", "dat", "results", "area", "response", "input", "empty", "key", "number", "ui", "pad", "json", "div", "content", "weight", "sample", "batch", "missing", "alpha", "DATA", "size", "array", "code", "value", "image", "split", "result", "change", "error", "picture", "style", "ata", "info", "source", "message", "text", "body", "buffer", "extra"], "molecularWeight": ["molecularWidth", "mosellularWidth", "moleularWidth", "mosellularFlow", "mosecularWidth", "moleuralWeight", "molellularFlow", "moleciumWidth", "molecularSize", "molescularWeight", "molellularWeight", "moleculeSize", "mosecularFlow", "molescularWidth", "moleuralWidth", "moleciumWeight", "mosellularWeight", "moleculeWeight", "mosecularWeight", "molecularFlow", "molesularWeight", "moleularSize", "moleuralSize", "moleculeWidth", "molesularWidth", "molesularSize", "moleularWeight", "moleciumFlow", "molescularSize", "moleculeFlow", "molellularWidth"]}}
{"id1": "9796161", "id2": "20929570", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "label": 1, "substitutes": {"getMD5": ["getMD4", "getmd4", "getmdHash", "getmd512", "getHTMLHash", " getSHA4", "getHTML4", "getMDHash", "getSHA5", "getmd5", "getMD512", " getMD512", "getSHA512", "getSHAHash", " getSHA512", " getMD4", "getSHA4", "getHTML512", " getSHAHash", " getMDHash", " getSHA5", "getHTML5"], "s": ["ls", "js", "ssl", " ads", "e", "als", "g", "b", "n", "ss", "os", "rs", "ps", "data", "parts", "ns", "si", "sync", "in", "sb", " fails", "f", "es", "input", "str", "ings", "ows", "comments", "sets", "bytes", "lines", "ms", "ips", "ws", "i", "source", "ends", "is", "sym", "a", "l", "self", "scripts", "ses", "S", "string", "v", "c", "tests", "ts", "gs", "cs", "abs", "ates", "services", "strings", "bs", "its", "p", "ds", "styles"], "m": ["rm", "e", "module", "mut", "mr", "md", "um", "tm", "wm", "f", "fm", "mc", "d", "man", "h", "me", "hm", "ms", "nm", "dm", "i", "bm", "cm", "gm", "l", "mi", "im", "mac", "ym", "mand", "v", "mm", "c", "machine", "sm", "am", "t", "pm", "em", "M", "arm", "mu", "vm", "om", "manager", "p"]}}
{"id1": "8778962", "id2": "8490297", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFile2String", "decodeFileAsStream", "decodeFileToFiles", "decodeFile2File", "decodeFileToString", "decodeStringToStream", "decodeStringToString", "decodeFileAsString", "decodeFileAsFile", "decodeString2File", "decodeFileFromFiles", "decodeFileFromFile", "decodeString2Stream", "decodeString2String", "decodeFileFromStream", "decodeStringToFiles", "decodeString2Files", "decodeFileToStream", "decodeFile2Stream", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2Files", "decodeFileFromString"], "infile": ["inputfilename", "outfilename", "infilename", " instream", "inputfile", "inputfiles", "minfile", "outfiles", "infp", "Instream", "inputfp", "Inbase", "outfp", "minstream", " infilename", " infp", " infiles", " inbase", " inFile", "instream", "infiles", "minFile", "inbase", "minbase", "InFile", "Infile", "inFile"], "outfile": ["inputFile", "outputfilename", "outfilename", "infilename", "inputfile", "outpath", "outputFile", "outFile", " outfilename", "inputdatabase", " outdatabase", "inputpath", " outpath", " outFile", "outputdatabase", "outdatabase", " outfolder", "outputfile", "infolder", "outputpath", "outputfolder", "outfolder", "inFile"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "lin", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "channel", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "log", "copy", "conn", "cache", "again", "output", "inner", "line", "writer", "work", "err", "off", "client", "o", "OUT", "lib", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "pass", "post", "io", "net", "file", "up", "co", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "bin", "reader", "border", "uffer", "iter", "data", "channel", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "queue", "input", "result", "length", "write", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "r", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "positive", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "2676365", "id2": "17111859", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 0, "substitutes": {"reset": ["save", "delete", "activate", " rebuild", " shutdown", " checkpoint", "start", "clear", "set", "setup", " reconnect", " disconnect", "release", " Reset", "et", "back", "stop", "sync", "update", " migrate", "disable", "close", "flush", "commit", "destroy", "init", "register", " restore"], "currentPilot": ["currentPortector", " currentCPooter", "currentpilot", "currentpiece", "currentPayistor", " currentPooter", "currentPortacket", "currentCPilot", "currentPayacket", "currentpacket", "currentpooter", "activePistor", " currentCPilot", "currentCPacket", " currentPector", "activePilot", "currentPistor", "currentPointilot", "activepistor", "currentPointiece", "activepiece", "currentPooter", "currentPortooter", "activePacket", "currentPointistor", "currentpector", "activePiece", "currentCPector", "currentPayilot", " currentPacket", "currentPointacket", "currentPector", " currentCPector", "currentPayiece", "currentPortilot", "currentCPooter", "currentPiece", "currentPacket", "activepacket", "currentpistor", " currentCPacket", "activepilot"], "psta": ["jste", "pesa", "jda", " pste", "pasi", " psa", "pppa", "parsta", "Pla", "Psa", "jsa", "Pda", "psa", "pesta", " pppa", "parasi", "peppa", "Psta", "pda", " pda", "Pasi", "paresta", "Pste", "Pesta", " pesta", "pela", "parsa", "pla", "pste", "jsta", " pla", "Pppa", " pasi"]}}
{"id1": "17999474", "id2": "6501291", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipAtDir", "getTempAsPlace", "getTempAsFile", "getZipAtfile", "getTempAsDir", "getZipAsfile", "getZipasPlace", "getZipAsPlace", "getZipAtFile", "getZipasFile", "getZipasDir", "getZipAsDir", "getZipasfile", "getZipAtPlace", "getTempAsfile"], "digOb": [" digObject", "dimObject", " digObj", " digob", "signObject", "ditOb", "dimObj", "signob", "Digob", "signOb", "dimOl", "ditob", "DigOl", "signObj", "digob", " digOl", "signOB", "ditObject", "digObj", "DigObject", "DigOb", "digOl", "dimOb", "DigObj", "ditOB", "digOB", "digObject", " digOB"], "folderName": ["folderPath", "Foldername", "FolderDir", "foldername", "packagename", "foldPath", " folderPath", "FolderInfo", "packageName", "folderInfo", "foldname", "packagePath", "packageDir", "fileInfo", "folderDir", "foldName", " folderDir", "FolderName", "fileName", " foldername", "FolderPath", "filePath", "foldInfo", "filename"], "tmpFolder": [" temporaryManager", "tempDir", "tmpfolder", " tmpDir", "mpDir", "tempfolder", " tmpfolder", "mpfolder", "tmpManager", " tmpManager", " tmpDirectory", "tmpDir", "tempFolder", " temporaryFolder", " temporaryfolder", "mpDirectory", "tmpDirectory", " temporaryDirectory", "tempDirectory", "tempManager", "mpFolder"], "zip": ["job", "ip", "ress", "p", "sl", "upload", "ie", "flow", "ce", "tmp", "proxy", "feed", "slice", "install", "copy", "pkg", "ze", "cf", "archive", "json", "py", "Zip", " ZIP", "clip", "io", "cop", "zone", "pack", "ignore", "z", "xml", "fp", "file", "ulp", "lex", "bag", "f", "url", "lib", " zipper", "temp", "download", "flat", "wrap", "seed", "folder", "gz", "lock", "jar", "source", "ipped", "pipe"], "out": ["Out", "plain", "os", "in", "client", "writer", "obj", "sync", "upload", "flow", "output", "is", "object", "socket", "user", "write", "copy", "parent", "cli", "page", "ex", "cache", "conn", "child", "info", "result", "connection", "a", "path", "io", "z", "line", "file", "box", "f", "url", "o", "null", "base", "this", "temp", "err", "download", "log", "loader", "again", "outs", "gz", "gen", "flush", "source", "OUT"]}}
{"id1": "14820302", "id2": "22411381", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"innerProcess": [" innerWrite", "subprocess", "binaryConnect", "innerprocess", "binaryWrite", "binaryprocess", " innerConnect", "subProcess", "innerWrite", "subConnect", "binaryProcess", " innerprocess", "innerConnect", "subWrite"], "curi": ["furi", "lcURI", "cri", "lURI", " cURI", "lcunit", "cgui", "Cui", "CURI", "lcuri", "pri", "fri", "firi", "Curi", "fui", " cui", " cgui", "luri", "Cunit", "lcui", "capi", "Cgui", "Cri", "cURI", "pURI", "Capi", " cri", "lri", "lcri", "cui", "Curl", " capi", "Ciri", "lcgui", "papi", "curl", " cunit", " curl", "ciri", "cunit", "lciri", "fURI", "lurl", "puri"], "regexpr": ["pregexer", "renexpr", "pregexpl", "reggexr", "Regexpre", "reggexper", "Renexpre", "renexper", "reggexpl", "recer", "relexPR", "recrepl", "recreer", "reggexpr", "relexpre", "regnexpr", "regexer", "pregexpr", "rerer", "rerepl", "rereper", "RenexPR", "regexPR", "Regexpr", "regnexr", "renexer", "prenexer", "recrepr", "prenexpl", "recrepre", "Renexp", "renexpl", "pregexp", "recrep", "renexr", "regexp", "recrePR", "renexPR", "reruer", "renexp", "Renexpr", "regexr", "prenexp", "receper", "relexpr", "rerupl", "rerupr", "regexpl", "regnexper", "relexp", "regexpre", "renexpre", "regexper", "recepr", "regnexpl", "Regexp", "RegexPR", "prenexpr", "rerepr", "recepl", "rerup"], "cs": ["Cs", "bc", "lc", "cm", "cf", "ins", "ms", "ca", "cache", "cers", "CS", "cb", "rs", "vs", "tc", "es", "ns", "ks", "conn", "cms", "cr", "ls", "cells", "cing", "cp", "cks", "c", "cc", "ci", "spec", "ios", "os", "ec", "acts", "codes", "cer", "acs", "acks", "js", "ps", "ars", "sync", "ced", "cus", "css", "ces", "ds", "ics", "fs", "cas", "wcs", "rc", "cos", "sc", "cn", "ches", "qs", "icks", "coll", "pc", "ac", "cases", "details", "ss", "bs", "cons", "ctx", "ce", "gs"], "digest": [" digested", "bigEST", " digity", "digit", "hashest", "signEST", "igity", "signest", "Digity", "bigest", " digests", "hashcher", "digcher", "logester", "Digger", " digcher", "digEST", "igest", "signger", "diggest", "biggest", " digester", "digester", " diggest", "Digcher", " digEST", "digests", "igester", "logger", "signests", "signgest", " digit", "digity", "hashger", "digested", "Diger", "Digester", "logit", "hashester", "signester", "diger", "igested", "Digest", " diger", "signer", "digger", "Digested", "logest", "Digit", "bigests", " digger", "signested"], "s": ["su", "v", "address", "services", "ms", "groups", "str", "e", "sets", "rs", "ws", "sl", "ns", "abs", "string", "u", "ls", "binary", "c", "states", "si", "ses", "os", "strings", "t", "sum", "sb", "r", "g", "b", "js", "n", "o", "ans", "ps", "sym", "S", "sync", "ds", "p", "bytes", "h", "obs", "is", "l", "data", "ss", "bs", "f", "gs", "settings"], "m": ["map", "cm", "v", "mc", "imm", "ms", "mr", "gm", "e", "rm", "pm", "am", "bm", "mo", "machine", "string", "fm", "man", "M", "c", "sm", "mi", "ym", "om", "r", "mm", "tm", "p", "hm", "wm", "me", "match", "vm", "nm", "dm"], "newDigestValue": ["newDigesterKey", "newDigestValues", "newDigestedValues", "newSignestValue", "newDigestVal", "newDigESTKey", "newDigestKey", "newSignestedValues", "newDigeterString", "newSignestValues", "newSignestedValue", "newSignestString", "newDigestedKey", "newSignestKey", "newSignestedString", "newDigESTValue", "newDigeterValue", "newDigestedValue", "newDigESTValues", "newDigesterVal", "newSignestedKey", "newDigestedVal", "newDigeterKey", "newDigesterString", "newDigeterVal", "newDigesterValues", "newDigesterValue", "newDigestedString", "newDigESTString", "newDigestString"]}}
{"id1": "8062076", "id2": "12306305", "code1": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 0, "substitutes": {"updateUser": ["updatePerson", "UpdateAccount", "UpdateRole", "UPDATERole", "UpdateUser", "updateRole", "UPDATEAccount", "changeUser", "changePerson", "updateAccount", "UpdatePerson", "changeAccount", "UPDATEPerson", "changeRole", "UPDATEUser"], "portalUserBean": ["portalUserBEam", "portalUserPeane", "portalFileBAN", "portalUserDeAN", "portalUserPeean", "portalGroupBeans", "portalUserPean", "portalUserEan", "portalGroupBEans", "portalUserBoin", "portalUserBeAN", "portalUserBEan", "portalUserEAN", "portalUserBane", "portalUserPlean", "portalUserBeane", "portalGroupBean", "portalUserBeam", "portalGroupBEAN", "portalUserPlane", "portalFileBane", "portalFileBin", "portalUserDeans", "portalFileBeAN", "portalClientBeane", "portalUserBoane", "portalUserDean", "portalUserBoan", "portalUserBann", "portalUserBEane", "portalUserBoam", "portalUserBeans", "portalClientBEans", "portalUserBans", "portalUserBin", "portalFileBeane", "portalUserBEann", "portalUserBEans", "portalUserDeane", "portalClientBEAN", "portalUserBEAN", "portalUserBegann", "portalUserBeean", "portalUserBegan", "portalUserBam", "portalClientBEan", "portalUserBoAN", "portalUserPlAN", "portalClientBean", "portalFileBean", "portalUserPeans", "portalUserPlan", "portalFileBan", "portalUserBeann", "portalFileBans", "portalUserBein", "portalUserPeAN", "portalFileBeean", "portalClientBeAN", "portalUserEans", "portalClientBeam", "portalUserBegAN", "portalUserEane", "portalGroupBeAN", "portalClientBEane", "portalUserEin", "portalUserBegans", "portalUserBan", "portalUserBoans", "portalGroupBEan", "portalFileBein", "portalClientBeans", "portalGroupBeann", "portalUserBAN", "portalFileBeans", "portalGroupBEann", "portalClientBEam"], "authSession": [" authsession", " authConn", "authConnection", "uthClient", " authConnection", "uthSession", "AuthClient", "AuthSession", "authClient", "Authsession", "uthConn", "AuthConn", "httpsession", "httpConnection", "authStream", "httpStream", "AuthStream", "AuthConnection", " authStream", "authsession", "authConn", " authClient", "httpSession", "uthsession"], "dbDyn": ["dbdYN", "dbBsyn", "dbSyn", "dbCodyn", "dbByr", "cbBien", "dbDoyan", "libDys", " dbBsyn", "dbDsyn", "bbDYN", "dbdyn", "DbPyr", "DbSyn", "dbIyan", "dbFyr", "dbCym", "dbNYN", "DbSyl", "cbDien", "dbCodyr", "dbFsyn", "dbCynam", "dbPyr", "DbDyl", "dbDoynam", " dbDoynam", "DbCYN", "dbDoyn", "dbDoyr", "cbDYN", "dbDoneYN", "dbDefym", "cbByn", "dbWYN", "dbDefys", "dbBSyn", "bbDyn", "dbBYN", "dbCYN", "dbBynam", "dbdgn", "dbIsyn", "DbDYN", "dbWyn", "dbDosyn", "dbFYN", "DbCyn", "dbFyn", "bbFyn", "dbCyn", "dbBien", "cbBYN", "cbBynam", "dbWsyn", " dbBynam", "dbCodSyn", "DbCynam", "dbDoneyn", " dbDoyan", " dbByr", "dbDSyn", "DbPSyn", "DbPyn", "DbDyr", "dbWSyn", "DbDahn", "dbCSyn", "dbSyl", "dbDefSyn", "dbByn", "dbPahn", "bbDSyn", "dbdynam", "dbFSyn", "dbdyl", "bbFSyn", "dbBahn", "dbDgn", "dbIynam", " dbDyan", "cbDynam", "dbDyl", "dbDynam", "libDSyn", "libDym", "dbIyn", "bbFsyn", "dbPyn", "dbDym", "libDyn", " dbDyr", "dbNyl", "dbDyr", "dbDien", "dbFynam", "dbDoneien", "DbDSyn", "dbdSyn", " dbDsyn", "dbSgn", "DbCSyn", "dbNyn", "dbNgn", "DbDyn", "dbDefyn", "dbPSyn", "cbDyn", "bbDsyn", " dbDosyn", "DbSgn", "dbDYN", "dbCys", "DbSYN", "bbFYN", " dbByn", "dbDahn", " dbDynam", "DbPahn", "dbSYN", "DbDynam", "dbDoneynam", " dbDoyn", "DbDgn", "dbDyan", "dbDys", "dbFyan", "dbCodahn"], "ps": ["jp", "posts", "ins", "pa", "ms", "eps", "pse", "PS", "pre", "ts", "proxy", "rs", "ils", "vs", "ws", "py", "ns", "res", "ks", "s", "ls", "lines", "this", "Ps", "pl", "fe", "where", "os", "pers", "PD", "pps", "hs", "als", "properties", "ras", "pe", "js", "cs", "ops", "cop", "ppa", "ups", "per", "css", "post", "ds", "aps", "fs", "p", "les", "pg", "ips", "http", "its", "ons", "pb", "ports", "qs", "pos", "pc", "pp", "details", "as", "sp", "ss", "pes", "bs", "mp", "gs", "pr", "po"], "sql": ["sys", "csv", "su", "fp", "url", "sol", "sv", "params", "description", "util", "job", "rel", "eps", "str", "dl", "ob", "id", "zip", "shell", "db", "log", "function", "nl", "SQL", "sl", "session", "string", "conn", "ls", "s", "seed", "ln", "pr", " SQL", "lock", "setup", "spec", "serial", "os", "sg", "ssl", "sq", "sb", "repl", "html", "ql", "printf", "ll", "join", "query", "sync", "general", "http", "l", "fn", "details", "statement", "sf", "comment", "select", "msg", "acl"], "idList": ["addressLIST", "idSet", "IdList", "IdTree", "userLIST", "dateList", "userSet", "idTree", "IdColl", "dateColl", "userList", " idColl", "IdSet", " idInfo", "dateInfo", "IdLIST", "userlist", "dateTree", "IdInfo", " idTree", "idlist", "idInfo", "addressList", "addresslist", "idLIST", "idColl", "addressSet", "Idlist"], "num": ["su", "sol", "result", "gen", "nb", "inc", "Num", "one", "nov", "um", "gru", "div", "index", "nom", "node", "nr", "nam", "uni", "umi", "multi", "off", "nn", "len", "no", "np", "hex", "dim", "mon", "miss", "numbered", "norm", "i", "count", "NUM", "number", "n", "nu", "mult", "oct", "loc", "ord", "begin", "lang", "sn", "du", "dom", "form", "mn", "non", "fn", "init", "pos", "coord", "loop", "con", "lim", "unit", "sum", "size", "zero", "uu", "temp"], "i1": ["I1", " i11", "I5", "i81", "I0", "ii11", "xi81", "ii4", "I81", " i81", "xi11", " i0", "ci0", "i0", "ii81", "i4", "i11", "xi4", " i4", "ii1", "i5", " i5", "ci5", "ci1", "xi1", "ci81"]}}
{"id1": "11049257", "id2": "18202328", "code1": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 1, "substitutes": {"generate": [" genation", " genate", "GenerATE", "generATE", " genating", "validating", "Generate", "validATE", "generating", "Generation", "validate", "generation", "Generating", "validation", " genATE"], "secure": ["https", "secondary", "force", "socket", "session", "remote", "encrypted", " securely", "sys", "ssl", "ite", "zip", "deep", "password", "client", "sensitive", "secret", "sq", "proxy", " insecure", " secured", "service", "sec", "express", "config", "quiet", "server", "protect", "ssh", "weak", "Secure", "sr", "debug", "host", "security", "stable"], "sep": ["spepel", "perseep", " seb", "sepa", "sepel", "SEp", "spep", "sepent", "ensepel", "SEpa", " sepa", "SEb", "sept", " sepel", "seep", " sepent", " seep", "persepa", "persep", "ensepent", "spepent", "seb", "perseb", "spept", "ensept", "ensep", " sept", "SEep"], "messagedigest": ["messagagse", "messagedighester", "messagedaghest", "messagedigester", "messagedagist", "messagedigress", "messagedimester", "messagedimest", "messagigester", "messagedligester", "messageddighest", "messagedighse", "messagagher", "messagigest", "messagedegher", "messagighester", "messagaghest", "messagedighEST", "messagedegester", "messagigress", "messageddigher", "messagedigse", "messagagester", "messagigist", "messagagest", "messagedeghest", "messagagress", "messagedagest", "messagedigist", "messagedimist", "messagedligist", "messagedighest", "messagighEST", "messageddigester", "messagedagress", "messagighest", "messagedligEST", "messagagEST", "messagedligress", "messagedigEST", "messagighse", "messagedagher", "messagedagEST", "messagagist", "messagedligse", "messagedimress", "messagigEST", "messageddigest", "messagedegest", "messagedigher", "messagedagester", "messagedligest", "messagedagse", "messagigse", "messagigher"], "stringbuffer": ["serialbuffer", " stringbuf", "writebuf", " stringsource", "binarybuf", "systemqueue", "numberbuf", "Stringbuffer", " stringbuff", "groupuffer", "jsonbuffer", "stringcache", "ringurl", " stringqueue", "stringbase", "binarybuffer", "stringboard", "Stringbase", "stringaddress", "stringbuff", "stringmanager", "defaultbuf", "groupbuf", "stringurl", "serialboard", " stringmanager", "systembuffer", " stringuffer", "linequeue", "functionbuffer", " stringcache", "stringbuilder", "writebuff", "arraybuf", "numberqueue", "numberbuffer", "linebuffer", "arraybuffer", "systembuff", "stringthrow", "filecache", "fileboard", "numberbuilder", "ringmanager", "filemanager", "defaultbuffer", "defaultqueue", "groupbuffer", "filebuff", "groupaddress", "binarythrow", "writethrow", "functionbuf", " stringurl", "stringqueue", "fileurl", "linebuf", "linebuff", "ringsource", " stringthrow", "jsonaddress", "serialcache", "Stringbuf", "systembuf", "filesource", "numberbase", "arraybase", "writebuffer", "ringbuffer", " stringboard", "stringsource", "defaultaddress", "serialbuff", "arraybuilder", "functionbuff", "jsonuffer", " stringaddress", "jsonbuf", "stringuffer", "numberaddress", "binarybuff", "stringbuf", "Stringbuilder", "filebuffer", "functionqueue"], "stringbuffer2": ["stringpage2", "stringbuf82", "objectbuffer5", "stringbuff10", "stringbuf002", " stringBuffer4", " stringbuffer3", "objectbuff2", "stringbufAll", "stringbuff32", "stringbase3", " stringreaderTwo", " stringcommentTwo", "doubleBuffer3", "stringbuf3", "stringbuffL", "stringufferII", "stringbuilder02", "stringbuffCache", "stringfb2", "stringfbCache", " stringbuffer12", "doublebufferTwo", "stringbarTwo", "stringuffer64", "stringloopL", "stringcopy62", "stringloaderII", " stringcomment2", " stringbuffer5", " stringbuffer02", "stringbuffType", "stringpageL", "stringbuffer10", "stringbuffer02", "stringcode2", "stringbufferL", "doubleBuffer2", "stringbar32", "stringloader64", "stringbuffer12", "doublebuffer52", "stringbuff62", "stringbufType", "stringcache02", " stringloop2", " stringBuffer52", "stringbuffer4", " stringbufferAll", "finalbuffer5", "stringviewTwo", "stringbuffer62", "stringbuff200", " stringbuffer82", "stringbase2", "doublebuffer1", " stringbuffer8", "stringBuffer1", " stringBuffer3", "stringcomment2", "stringfbAll", "doublebuffer3", "doublebuffer4", "listbufferL", "stringbuffAll", " stringreaderII", "stringbuilder12", "stringbuffer82", "stringcode5", "stringbuff8", "stringbuffer002", " stringbufferCache", "stringbuff4", "doubleBuffer4", "stringbuffer64", "stringcache12", "stringreaderII", " stringcache02", " stringloop8", " stringbuffer52", " stringfb20", "stringbuff20", "objectbuff5", "stringserverTwo", "finalbuff2", "stringqueue62", " stringbuffer200", "stringbuff1", "stringbreak4", "stringloaderTwo", "stringbufferAll", "stringview2", "stringbuf52", " stringbufferTwo", "stringloop200", "stringcache2", "stringbufferTwo", "stringbuff3", "doubleBuffer52", "stringloopTwo", "stringbreak2", "stringcache10", "stringbuffTwo", "objectbuff62", "stringcomment002", "listbufferTwo", "stringbuilder10", "stringserver002", "stringloader2", " stringbuffer002", "finalbufferTwo", "stringpageTwo", " stringcode5", "stringreader2", "listloop2", "stringbar5", "finalbuffer2", " stringcache2", "stringloop2", "stringBuffer2", "stringbufCache", "stringcodeTwo", "listloopL", "objectbuffer62", "stringuffer2", "stringfb200", " stringloop200", "stringview52", " stringreader64", "stringloop02", "stringbuf4", " stringloopTwo", "stringBuffer52", "stringbreak3", "finalbuffTwo", "stringbase52", "stringbufferII", " stringcache12", "finalbufferType", "stringBuffer4", "stringview4", " stringreader2", "stringserver82", "finalbuffType", " stringbuffer20", "stringreaderTwo", " stringfbCache", " stringcomment82", " stringbuffer10", "stringbufferCache", "stringfbTwo", "stringbufTwo", "stringqueue5", "stringserver5", "stringbuffer200", " stringfb2", "stringbase4", "stringbuffer20", " stringcode2", "stringcode32", "stringloop8", "stringbuf20", " stringcache10", "stringBufferTwo", " stringcodeTwo", " stringbuffer64", "stringbuffer5", "stringbuff02", " stringcode32", " stringfbAll", "stringreader64", "stringpage02", "stringbuilder2", "finalbuff5", "stringcopy5", "stringbreak1", "doubleBuffer1", "listbuffer2", "stringbuffer8", "stringbuf5", "stringbuff12", "stringbufferType", "listbuffer02", "objectbuffer2", "listloopTwo", "stringqueue2", "stringserver2", "stringBuffer3", "stringbuffer32", " stringbufferII", "stringcopy2", "stringcommentTwo", "stringfb8", "stringbar2", "stringbuff2", "stringufferTwo", " stringbuffer32", "doublebuffer2", "stringbuffer52", "listloop02", " stringbuffer4", "doubleBufferTwo", "stringserverType", " stringcomment002", "stringbuffer3", " stringBuffer2", "stringbuf2", "stringcomment82", "stringbuff5", "stringfb20"], "inetaddress": ["networkAddress", "iotimage", "etimage", "etaccount", "tunimage", "inetimage", "tunAddress", "nethost", "ethost", "inethost", "netaddress", "iotAddress", "etaddr", "tunaccount", "tunaddress", "netaddr", "etaddress", "inetaccount", "networkaddress", "etAddress", "networkaddr", "netAddress", "iotaddress", "inetAddress", "networkhost", "inetaddr", "iotaccount"], "l": ["sl", "tl", "f", "lp", "al", "dl", "el", "m", "p", "ll", "lc", "ls", "kl", "u", "b", "r", "L", "lf", "lang", "d", "z", "t", "lb", "v", "lr", "li", "n", "nl", "c", "lv", "ln", "rl", "length"], "l1": ["l81", "l51", "l2", "ll1", " lOne", "lc1", " l2", "il1", "sl2", "L7", " l5", " l7", " l81", "l5", "lx", "L2", "lc2", "il51", " lone", " lx", "L81", "llone", "sl1", "sl5", "Lx", "il5", "slOne", "ll2", "Lone", "ll81", "cl1", "lOne", "sl51", "lone", "l7", "lcx", "clOne", "lc7", "cl2", "L1", " l51"], "abyte0": ["byte000", "ome0", "iterator000", "iterator1", "ome1", "abytei", "iterator8", "abase0", "abytes1", "abasekeeper", "abytes8", "abase50", "umboj", "umboi", " arrayzero", "abyte000", "omej", "bytei", "byte1", "abytezero", " array50", "abasezero", "abytej", "omei", "gmentkeeper", " array0", "byte8", " arraykeeper", "bytej", "abyte1", "umbo1", "abytes000", "abytekeeper", "umbo0", "gmentzero", "abyte8", "abyte50", "iterator0", "byte0", "gment0", "gment50", "abytes0"], "stringbuffer1": [" stringview1", " stringviewone", "stringbuffer01", "Stringbuffer1", "stringview81", " stringbuffer3", "stringviewFirst", "stringbuf1", "StringBuffer2", "stringufferone", "Stringbuffer11", "stringbuf3", "stringview1", "doubleBuffer81", "stringbuff11", "stringlayer81", " stringuffer3", "stringBuffer8", "doubleBuffer2", " stringbufferone", " stringuffer01", "stringufferOne", "stringbuffer11", "doublebuffer81", "stringbuilder8", "Stringbuffer8", "StringBuffer8", "doublebuffer1", "stringBuffer1", "stringlayerone", "doublebufferOne", "doubleBufferOne", "stringbuff8", "stringuffer1", "stringbufferOne", "stringviewone", "stringuffer01", " stringviewFirst", "stringbufferFirst", "stringBuffer81", "stringufferFirst", "stringbuff1", "stringbuf01", "stringbuff3", " stringbufferFirst", "StringBuffer11", "stringbufferone", "stringBuffer2", "stringbuff01", "stringuffer2", "stringBuffer11", " stringuffer1", "stringuffer3", "stringbuilder2", "doubleBuffer1", "StringBuffer1", "stringbuffer8", "stringbuilder1", "stringlayerFirst", "stringbuffer81", "stringBufferOne", " stringbuffer81", "Stringbuffer2", "stringbuilder11", "stringbuff2", "stringuffer81", " stringview81", "doublebuffer2", " stringbuffer01", "stringlayer1", "stringbuffer3"], "i": ["x", "ji", "f", "y", "si", "ti", "ri", "slice", "p", "ori", "pi", "k", "ind", "ie", "ix", "hi", "I", "di", "u", "bi", "qi", "fi", "e", "o", "ini", "abi", "d", "ci", "z", "h", "xi", "v", "oi", "ui", "mi", "yi", "li", "uri", "n", "ii", "io", "c", "in", "id", "index", "iu", "vi", "eni", "ai", "gi", "phi", "ip"], "j": ["x", "job", "ji", "ij", "f", "jj", "bj", "si", "note", "g", "p", "kj", "k", "ie", "ix", "b", "jp", "jet", "qi", "aj", "ja", "e", "journal", "o", "cell", "jc", "d", "z", "ali", "ch", "js", "J", "v", "li", "n", "ii", "jo", "c", "jack", "jl", "oj", "dj", "adj", "length", "json", "obj"], "s": ["ts", "f", "hes", "g", "ins", "bs", "m", "services", "sets", "results", "p", "ns", "str", "os", "ssl", "is", "ls", "words", "u", "b", "sports", "parts", "abs", "sv", "r", "rs", "e", "its", "o", "lines", "strings", "resses", "S", "hs", "ws", "ings", "qs", "t", "js", "h", "xs", "v", "bis", "gs", "n", "styles", "south", "ps", "http", "c", "as", "ions", "sites", "series", "a", "seconds", "states", "es", "ss", "tests", "sb", "us", "ms", "ches", "string", "fs", "ses"]}}
{"id1": "14303294", "id2": "22338097", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    private final String createMD5(String pwd) throws Exception {\n        MessageDigest md = (MessageDigest) MessageDigest.getInstance(\"MD5\").clone();\n        md.update(pwd.getBytes(\"UTF-8\"));\n        byte[] pd = md.digest();\n        StringBuffer app = new StringBuffer();\n        for (int i = 0; i < pd.length; i++) {\n            String s2 = Integer.toHexString(pd[i] & 0xFF);\n            app.append((s2.length() == 1) ? \"0\" + s2 : s2);\n        }\n        return app.toString();\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getserverSHA", " getServerSalt", "getserverAddress", "getserverSalt", "getServerSalt", "getSecureHash", "getserverHash", "getSecureSalt", "getSecureAddress", "getSessionHash", " getServerAddress", " getSecureSalt", " getSecureAddress", "getServerSHA", "getServerAddress", "getSessionAddress", "getSessionSHA", "getSecureSHA", " getSecureSHA", "getSessionSalt", " getServerSHA", " getSecureHash"], "passwordHash": ["privatePassword", "Passwordhash", "privateHash", " passwordSalt", "PasswordPass", "passwordhash", "passwordCode", " passwordhash", "privatehash", " passwordPassword", " passwordPass", "passwordPassword", " PasswordPass", "PasswordPassword", "privateSalt", " PasswordCode", "PasswordCode", " passwordCode", "passwordSalt", "PasswordHash", " PasswordHash", "passwordPass"], "PasswordSalt": [" passwordSalt", "PASS256", "PASSHash", "password256", "Password256", "passwordSecret", " passwordPassword", "PASSPassword", "PasswordSecret", "passwordPassword", "PASSSalt", "PasswordPassword", " passwordSecret", "passwordSalt", "PasswordHash", " Password256", " PasswordHash", " PasswordSecret", " PasswordPassword"], "hash": ["string", "address", "buffer", "sum", "base", "her", "response", "copy", "user", "message", "kh", "result", "number", "hex", "Hash", "html", "pool", "ash", "key", "content", "password", "cache", "mac", "sha", "value", "build", "work", "data", "check", "h", "size", "search", "row", "log", "dig", "change", "image", "ha", "array", "url", "update", "sh", "auth", "block", "crypt", "error", "code"], "digest": ["Digester", "signester", "digher", "Diger", "hashener", "signest", "integest", "generester", "signer", "generested", " digested", " diger", "signger", " digusher", "mdusher", "hashest", "mdest", "mdested", "hasher", " digger", "digester", "signher", "Digener", "hashester", "Digher", "mdester", "digger", "digested", "integester", " digall", "Digest", " digher", "Digusher", "digener", "digusher", "generall", "diger", "integall", " digester", "Digger", "Digested", "generest", "digall", " digener", "integested"]}}
{"id1": "2461169", "id2": "12246545", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void load(String url) throws IOException {\n        this.url = url;\n        int col = url.indexOf(':');\n        if (col > 1 && col < 5) {\n            load(new URL(url).openStream());\n        } else {\n            if (new File(url).exists()) {\n                System.out.println(\"Loading JAD from file : \" + url);\n                FileInputStream fin = new FileInputStream(url);\n                try {\n                    load(fin);\n                } finally {\n                    fin.close();\n                }\n            } else {\n                InputStream in = getClass().getResourceAsStream(url);\n                if (in != null) {\n                    System.out.println(\"Loading JAD from classpath : \" + url);\n                    load(in);\n                } else {\n                    throw new IOException(\"\\\"\" + url + \"\\\" was found in file system or classpath\");\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeStringToFiles", "decodeFileAsFiles", "decodeStringToFile", "decodeFileAsStream", "decodeString2Stream", "decodeFileFromStream", "decodeFileFromFiles", "decodeStringToString", "decodeFile2File", "decodeFileAsString", "decodeFileFromFile", "decodeStringToStream", "decodeFileToString", "decodeString2String", "decodeFile2String", "decodeFile2Files", "decodeFileToStream", "decodeFileToFiles", "decodeFileAsFile", "decodeString2File", "decodeString2Files", "decodeFileFromString", "decodeFile2Stream"], "infile": [" infp", " instream", "minbase", "Inbase", "inputfilename", "infp", "minstream", "outfiles", " infiles", "minFile", "inputfp", "inputfiles", "minfile", "outfilename", "Infile", "inbase", " inbase", "outfp", " infilename", "instream", "InFile", "inFile", "inputfile", " inFile", "Instream", "infiles", "infilename"], "outfile": ["outputpath", "outfolder", " outdatabase", "inputFile", "outputFile", "inputdatabase", " outFile", "outfilename", "inputpath", " outfilename", " outfolder", "outpath", " outpath", "outputdatabase", "inFile", "inputfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", "infilename", "outdatabase"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "rin", "lin", "gin", "thin", "inside", "i", "nin", "a", "socket", "sin", "login", "reader", "data", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "pass", "exit", "line", "again", "cache", "channel", "o", "ex", "inner", "bin", "Out", "copy", "outer", "log", "io", "outs", "co", "post", "sync", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "client", "one", "file"], "buffer": ["seed", "channel", "cache", "uffer", "limit", "padding", "bin", "input", "layer", "wave", "feed", "buf", "queue", "slice", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "check", "connect", "next", "reader", " copy", "parse", "write", "se", "raw", "r", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "right", "fast", "path", "open", "Success", "primary", "ceed", "first", "warning", "construct", "content", "ccess", "positive", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "follow", "data", "error", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "13565787", "id2": "14733078", "code1": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["encryptString", "encryptedpassword", "decryptPass", "encipherPass", "enccryptpassword", "decipherPassword", "decryptPassword", "encryptPass", "decryptString", "encryptpassword", "enccryptString", "enccryptPassword", "encryptedPassword", "encipherPassword", "enccryptPass", "encipherString", "decipherpassword", "decryptpassword", "decipherString", "decipherPass", "encryptedPass", "encipherpassword", "encryptedString"], "plainPassword": ["plainString", "messagepassword", "encryptedpassword", "protectedpassword", "protectedPass", " plainCode", "messageText", "flatText", "flatpassword", "plainCode", "flatPassword", " plainpassword", "encryptedPassword", " plainText", " plainPass", "plainPass", "messageCode", " plainString", "encryptedPass", "messagePassword", "flatCode", "plainpassword", "protectedString", "encryptedString", "protectedPassword", "plainText"], "sb": ["mb", "usb", "bh", "nb", "erb", "si", "sth", "bs", "bps", "pb", "sf", "bm", "gs", "bg", "bd", "BG", "buf", "sa", "obb", "bsp", "bp", "SB", "eb", "orb", "xb", "lb", "gb", "ls", "url", "sp", "wb", "bc", "zb", "BB", "kb", "split", "cb", "fp", "ssl", "bb", "sg", "obj", "sv", "bj", "b", "bf", "buff", "fb", "buffer", "binary", "bt", "ab", "src", "rb", "db"], "messageDigest": ["messageDest", " messageDigenge", "messagedigenge", "messageDester", " messageDigester", "messageDger", "messagedigested", "messagediger", "messageDiger", "MessageDigester", "messagedigest", "messageDigester", "messageMarkested", "messageRobest", "messagedigester", "messageMarkusher", "messageDigusher", " messageDested", "MessageDesignest", "messageDesignester", "messagedigger", " messageDest", "MessageDesigner", " messageDigusher", "messageAddesting", "messageDested", "MessageDesignester", " messageDester", " messageDusher", " messageDger", "messageMarkest", "messageAddester", "MessageDigesting", "messageDigenge", " messageDenge", "messageDigested", "messageDenge", "MessageDesignesting", "messageDesignest", "messageDesigner", "messageDusher", "messageRobenge", " messageDigested", "messageDesignesting", "messageRobester", "MessageDigest", "messageAdder", "messagedigusher", " messageDigger", "messageDigger", "MessageDiger", "messagedigesting", "messageAddest", "messageDigesting", "messageMarkester", "messageRobger"], "digestBytes": ["digestedByte", "digestbytes", "Digestbytes", "DigestPart", "DigestedByte", "DigestString", "digestString", " digestedbytes", "digestedbytes", "digestByte", "DigesterByte", "DigesterPart", "digesterBytes", "digESTByte", "Digesterbytes", "digestedBytes", "digESTbytes", "dighestbytes", "digestedPart", "digesterbytes", "DigestBytes", "DigestedString", "Digestedbytes", "digseString", "digsebytes", "digesterByte", "digESTParts", "digesterPart", " digestedParts", "DigestByte", " digestParts", " digestbytes", "dighestByte", "digestedString", " digestByte", "digestedParts", " digestedByte", " digestedBytes", "dighestPart", "digesterParts", "digestParts", "dighestBytes", "digseBytes", "digestPart", "digseByte", "DigesterBytes", "digesterString", "DigestedBytes", "digESTBytes"], "hex": ["hs", "ctr", "wh", "cmp", "ip", "zip", "string", "cache", "utf", "rh", "ex", "exp", "str", "bin", "sha", "path", "shape", "bits", "char", "key", "json", "num", "length", "coord", "letter", "address", "header", "lit", "kh", "cookie", "ph", "oct", "alph", "url", "x", "pex", "index", "serial", " Hex", "iter", "su", "rex", "sex", "tx", "xf", "hash", "format", "h", "check", "ext", "dig", "digit", "null", "pack", "buff", "id", "pattern", "binary", "text", "form"], "i": ["hi", "si", "qi", "ip", "u", "multi", "n", "c", "ii", "m", "pi", "k", "o", "d", "ci", "di", "io", "slice", "ui", "length", "ri", "bi", "p", "l", "s", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "v", "gi", "ti", "ai", "r", "b", "zi", "t", "id", "xi", "uri", "ix", "end"]}}
{"id1": "3024987", "id2": "300397", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Coder", "testCopy_readerToOutputStream_Coded", "testCopy_readerToOutputStream_Integoded", "testCopy_readerToOutputStreamForEncoded", "testCopy_readerToOutputStreamForEncode", "testCopy_readerToOutputStream_Integode", "testCopy_readerToOutputStream_encode", "testCopy_readerToOutputStreamForencoding", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStreamForEncoding", "testCopy_readerToOutputStream_Encode", "testCopy_readerToOutputStreamForencoded", "testCopy_readerToOutputStream_Integoding", "testCopy_readerToOutputStreamForencode", "testCopy_readerToOutputStream_Code", "testCopy_readerToOutputStreamForencoder", "testCopy_readerToOutputStreamForEncoder", "testCopy_readerToOutputStream_Coding", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStream_Integoder"], "in": ["r", "image", "buffer", "m", "n", "inn", "entry", "Reader", "i", "is", "init", "input", "slice", "id", "include", "arin", "din", "inas", "or", "a", "inner", "io", "ini", "rin", "rec", "reading", "file", "inside", "min", "url", "pass", "login", "re", "data", "err", "with", "ins", "bin", "In", "IN", "again", "read", "win", "source", "inc"], "reader": ["r", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "ink", "i", "feed", "input", "rx", "handler", "per", "ler", "or", "pointer", "inner", "io", "rr", "iner", "ra", "reading", "file", "rar", "iter", "x", "loader", "b", "her", "oder", "er", "driver", "parser", "read", "source"], "baout": ["waout", "BAin", "waoutput", "BaOut", "baparent", "BAout", "aain", "vaparent", "abain", "bain", "daout", "abaOut", "vaout", "daOut", "vaOut", "baoutput", "Bain", "baOUT", "daOUT", "wain", "BAOut", "Baout", "vain", "aaout", "waOut", "Baparent", "BAparent", "dain", "aaoutput", "abaout", "baOut", "BAOUT", "BAoutput", "abaOUT", "aaOut"], "out": ["Out", "image", "client", "buffer", "writer", "obj", "output", "object", "user", "write", "parent", "cache", "server", "to", "inas", "array", "inner", "ext", "ref", "io", "pool", "line", "file", "o", "null", "exec", "base", "lib", "builder", "err", "with", "arr", "OUT", "again", "outs", "up", "inc"], "bytes": ["items", "os", "size", "ipes", "ies", "files", "output", "les", "bs", "units", "strings", "cells", "its", "ls", "ns", "ips", "comments", "odes", "css", "reads", "es", "lines", "objects", "android", "seconds", "content", "tes", "bps", "Bytes", "codes", "pieces", "classes", "bits", "binary", "pages", "ones", "null", "zip", "data", "blocks", "values", "rows", "text", "body", "string", "parts", "outs"]}}
{"id1": "4716110", "id2": "13516684", "code1": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    void run(PseudolocalizerArguments arguments) throws IOException {\n        List<String> fileNames = arguments.getFileNames();\n        PseudolocalizationPipeline pipeline = arguments.getPipeline();\n        if (arguments.isInteractive()) {\n            runStdin(pipeline);\n            return;\n        }\n        if (fileNames.size() == 0) {\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(arguments.getType());\n            writeMessages(msgCat, readAndProcessMessages(pipeline, msgCat, System.in), System.out);\n            return;\n        }\n        String suffix = arguments.getVariant();\n        if (suffix == null) {\n            suffix = \"_pseudo\";\n        } else {\n            suffix = \"_\" + suffix;\n        }\n        for (String fileName : fileNames) {\n            File file = new File(fileName);\n            if (!file.exists()) {\n                System.err.println(\"File \" + fileName + \" not found\");\n                continue;\n            }\n            int lastDot = fileName.lastIndexOf('.');\n            String extension;\n            String outFileName;\n            if (lastDot >= 0) {\n                extension = fileName.substring(lastDot + 1);\n                outFileName = fileName.substring(0, lastDot) + suffix + \".\" + extension;\n            } else {\n                extension = \"\";\n                outFileName = fileName + suffix;\n            }\n            System.out.println(\"Processing \" + fileName + \" into \" + outFileName);\n            String fileType = arguments.getType();\n            if (fileType == null) {\n                fileType = extension;\n            }\n            MessageCatalog msgCat = FormatRegistry.getMessageCatalog(fileType);\n            InputStream inputStream = new FileInputStream(file);\n            List<Message> processedMessages = readAndProcessMessages(pipeline, msgCat, inputStream);\n            OutputStream outputStream = new FileOutputStream(new File(outFileName));\n            writeMessages(msgCat, processedMessages, outputStream);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copiedContent", " copyChannel", "CopyChannel", "copyFiles", "CopyFile", "CopyContent", " copiedFiles", "copyContent", " copyContent", " copiedChannel", "CopyFiles", "copyChannel", " copiedFile", " copyFiles"], "in": ["work", "source", "buffer", "copy", "inn", "inner", "c", "ac", "config", "at", "ex", "i", "input", "image", "or", "IN", "data", "m", "ini", "io", "a", "url", "base", "name", "din", "b", "min", "ins", "connection", "In", "inc", "again", "file", "part", "login", "id", "reader", "diff", "bin"], "out": ["p", "x", "source", "copy", "cache", "output", "client", "c", "f", "point", "at", "w", "ex", "OUT", "conn", "image", "data", "writer", "object", "dest", "n", "io", "up", "base", "name", "server", "exec", "string", "connection", "external", "prefix", "Out", "outs", "file", "part", "o", "user", "v", "target"], "sourceChannel": ["SourceContext", "sourceConnection", "inputMessage", "SourceChan", "ourceChannel", "inputChan", "ourceContext", " sourcechannel", "inputChannel", " sourceMessage", "sourceChan", "SourceConnection", " sourceContext", "targetConnection", " sourceConnection", "SourceSocket", "inputchannel", " sourceStream", "SourceMessage", "sourceSocket", "sourceMessage", "ourceStream", "sourceContext", "targetchannel", " sourceChan", "targetChan", " sourceSocket", "ourceSocket", "sourcechannel", "sourceStream", "targetStream", "SourceChannel", "SourceStream", "Sourcechannel", "targetChannel"], "destinationChannel": ["destinatingChan", "destinationchannel", "DestinationChannel", "destinatingStream", "destributionchannel", " destributionCh", "destinatedChannel", "DestinationManager", "DestinationConnection", "destinateConnection", "destinationCh", "destinationStream", "destinateChannel", "DestinatorChannel", "destinatedCh", "DestinatorManager", "destructionChannel", "destinatedManager", "destructionchannel", "destinatorManager", "destributionCh", " destributionChan", " destinationChan", "destinationChan", "DestinationStream", " destributionChannel", "DestinatorConnection", "destinatedChan", "destinatorConnection", "destinatingchannel", "destinationConnection", "destinatedConnection", "DestinatorChan", "destructionStream", "DestinatorStream", "destinatorChan", "destinatedchannel", "destinatedStream", " destinationCh", "destinationManager", "destinatingChannel", "destinateManager", "Destinationchannel", "DestinationChan", " destinationchannel", "Destinatorchannel", "destributionChannel", "destructionChan", "destinatorCh", "destributionChan", "destinateStream", " destributionchannel", "destinatorchannel", "destinatorChannel", "destinatorStream"]}}
{"id1": "23398710", "id2": "23611770", "code1": "    public String getUser() {\n        try {\n            HttpGet get = new HttpGet(\"http://api.linkedin.com/v1/people/~\");\n            consumer.sign(get);\n            HttpClient client = new DefaultHttpClient();\n            HttpResponse response = client.execute(get);\n            if (response != null) {\n                int statusCode = response.getStatusLine().getStatusCode();\n                if (statusCode != 200) {\n                    this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n                }\n                StringBuffer sBuf = new StringBuffer();\n                String linea;\n                BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), \"UTF-8\"));\n                while ((linea = reader.readLine()) != null) {\n                    sBuf.append(linea);\n                }\n                reader.close();\n                response.getEntity().consumeContent();\n                get.abort();\n                String salida = sBuf.toString();\n                String user_firstname = salida.split(\"</first-name>\")[0].split(\"<first-name>\")[1];\n                String user_lastname = salida.split(\"</last-name>\")[0].split(\"<last-name>\")[1];\n                return user_firstname + \" \" + user_lastname;\n            }\n        } catch (UnsupportedEncodingException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (IOException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthMessageSignerException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthExpectationFailedException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthCommunicationException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        }\n        return null;\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 0, "substitutes": {"getUser": ["getPerson", "createProfile", "newProfile", "newAccount", "createAccount", "newUser", "newPerson", "createPerson", "getProfile", " getProfile", "getAccount", " getAccount", " getPerson", "createUser"], "get": ["p", "url", "resource", "call", "build", "g", "view", "body", "got", "remote", "google", "init", "like", "method", "ge", "this", "single", "GET", "model", "it", "status", "check", "Get", "set", "read", "handle", "i", "consumer", "create", "api", "parse", "pull", "cli", "sign", "send", "object", "token", "show", "give", "cache", "c", "v", "start", "service", "find", "entity", "json", "query", "invoke", "put", "update", "http", "request", "open", "post"], "client": ["p", "console", "url", "ssl", "resource", "server", "call", "copy", "connection", "manager", "io", "method", "this", "session", "channel", "output", "result", "connect", "conn", "i", "consumer", "api", "bird", "cli", "web", "contact", "Client", "send", "control", "https", "con", "handler", "app", "service", "per", "php", "secure", "http", "request", "open"], "response": ["wave", "resp", "page", "writer", "subject", "respond", "uri", "resource", "message", "server", "image", "report", "view", "Response", "connection", "body", "successful", "data", "version", "serv", "output", "application", "status", "document", "result", "site", "reply", "index", "error", "results", "api", "tree", "send", "queue", "object", "handler", "success", "service", "relation", "full", "json", "generation", "collection", "http", "feed", "request", "offer", "received"], "statusCode": ["StatusC", "statusC", "successCode", " statusType", "statuscode", "responseCode", "statusType", "StatusType", "responseType", " statusC", " statuscode", "Statuscode", "StatusCode", "successcode", "successC", "successType"], "sBuf": ["sBbuff", " sBuff", "sPluf", " sFbuf", " sBlu", "sQbuf", "sBBumb", " sFlu", "sBerumb", "sAbuf", "sBeruf", "sFumb", " sFumb", "sFlu", " sAbuf", "sQumb", "sBerlu", "sBbuf", "sBlu", " sFuf", "sBBuff", "sPlbuf", "sBuff", "sFuff", " sAbuff", " sBbuff", " sBBuf", " sBBbuf", "sBerbuf", "sAuf", "sAbuff", "sFbuf", "sAuff", " sBumb", " sAuff", "sQuf", "sPllu", "sFuf", "sFbuff", "sBBbuf", "sBumb", "sBBbuff", "sBBuf", "sPlumb", " sBBumb", " sBbuf", " sAuf"], "linea": ["Lineha", " lineA", "idea", "ideA", " lineha", "lineA", "linva", "linas", " lineas", "Lineas", "lineha", "Linea", " lineva", "ideva", "linha", "linA", "lineas", "lineva", "Lineva", "ideas", "LineA", "lina"], "reader": ["writer", "e", "server", "rx", "rer", "ser", "io", "data", "ner", "reading", "rar", "parser", "f", "result", "Reader", "input", "editor", "upper", "read", "row", "player", "i", "builder", "iter", "driver", "bird", "stream", "er", "l", "rr", "worker", "inner", "r", "handler", "loader", "per", "cher", "layer", "keeper", "ler", "pointer", "buffer", "wrapper", "oder", "line", "feed", "ri", "right"], "salida": [" salicka", "bilicka", "salara", "salido", " salidas", "saticka", "milida", "slida", "bilara", "salicka", "bilido", "milidas", "Salara", "Salida", "slidas", " salanda", "satara", "satida", "Salido", "satido", "Salidas", "salidas", "slara", "milanda", " salido", "milido", "slanda", "salanda", "Salanda", " salara", "bilida"], "user_firstname": ["user_thirdname", "user_fullname", "user_realnames", "user_lastName", "user_headame", "user_firstName", "user_realname", "user_lastame", "user_fullName", "user_firstame", "user_thirdphone", "user_realame", "user_fullame", "user_firstphone", "user_lastnames", "user_realName", "user_fullnames", "user_firstnames", "user_headname", "user_headphone", "user_lastphone", "user_thirdame"], "user_lastname": ["user_fullname", "user_pastName", "user_lastName", "user_lastword", "user_firstword", "user_lastame", "user_pastaddress", "user_fullName", "user_firstame", "user_fullame", "user_longname", "user_longaddress", "user_longame", "user_fulladdress", "user_pastame", "user_lastnames", "user_fullnames", "user_firstnames", "user_pastname", "user_fullword", "user_longName", "user_lastaddress"]}}
{"id1": "12537270", "id2": "9033639", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["report", "ge", " analyse", "se", "patch", "match", "read", "split", "raw", "load", "see", "build", "parser", "open", "format", "ract", "apply", "pack", "update", "ize", "arse", "process", "scan", "xml", "Parser", "eval"], "link": ["path", "string", "info", "base", "address", "lang", "uri", "id", "lock", "Link", "http", "add", "message", "rel", "html", "l", "match", "location", "URL", "line", "tag", "linked", "like", "type", "links", "source", "load", "connection", "data", "file", "text", "route", "li", "local", "page", "inline", "href", "style", "msg", "name", "e", "image", "word", "ln", "bug", "xml", "ink", "loc"], "conn": ["Connection", "ssl", "Conn", "cc", "n", "enc", "rc", "con", "c", "socket", "ctrl", "act", "col", "dr", "rt", "dc", "nc", "er", "client", "nt", "cp", "ct", "connection", "rn", "r", "ch", "open", "config", "ca", "out", "p", "rec", "ai", "ci", "Config", "io", "cr", "ann", "db", "pc", "mc", "ctx", "apt", "err", "connect", "cn", "ac", "pt", "cmd", "pg", "loc"], "rd": ["rw", "dra", "bd", "rc", "RR", "RS", "ru", "rg", "lr", "dr", "rt", "fr", "wd", "dc", "rs", "ld", "RD", "rb", "reader", "rh", "xd", "ra", "rn", "rid", "r", "nd", "RM", "rr", "rss", "rx", "rog", "adr", "fd", "rl", "hr", "ds", "rm", "dd", "sr"], "kit": ["qt", "info", "base", "loader", "Kit", "sci", "feed", "spec", "site", "net", "fit", "py", "et", "pot", "wt", "rt", "ui", "kat", "util", "ku", "rot", "nt", "tools", "sit", "reader", "tk", "lib", "ct", "browser", "cat", "kt", "w", "ut", "config", "h", "p", "plugin", "init", "format", "io", "t", "cr", "kin", "bot", "k", "ki", "bug", "b", "pit", "os", "f", "tool", "api", "auto"], "doc": ["val", "root", "info", "base", "Doc", "http", "docs", "document", "ref", "DOC", "pub", "html", "tag", "dr", "fr", "dc", "in", "config", "d", "dir", "div", "md", "data", "file", "text", "out", "de", "open", "mm", "body", "page", "msg", "po", "desc", "m", "coll", "pos", "dec", "db", "pc", "di", "mc", "tt", "bc", "bug", "ac", "xml", "dom", "f", "tx", "api", "loc"], "url": ["path", "address", "base", "ssl", "server", "uri", "resource", "feed", "http", "lr", "l", "location", "host", "URL", "html", "el", "util", "cdn", "source", "connection", "config", "github", "file", "src", "page", "ll", "log", "href", "name", "image", "blog", "sl", "rl", "pull", "Url", "service", "www", "bug", "ur", "xml", "f", "hub", "gl", "org", "download", "loc"], "it": ["ite", "info", "dit", "id", "ic", "IT", "et", "end", "se", "l", "mit", "in", "iter", "split", "nt", "its", "sit", "stat", "r", "ip", "iterator", "p", "init", "lit", "or", "edit", "ci", "iti", "t", "ait", "you", "v", "st", "It", " It", "pit", "iz"], "elem": [" Eade", "oelem", "eject", " neade", "pelev", "eelements", " nelem", "oelev", "Element", "Elev", " Element", " Eler", "peler", "eler", "oeler", "seject", "Eler", "Elem", "pelem", "Elements", "selem", "eade", "pelement", " nelement", " neler", "Eade", "eeject", "elev", "eelement", "Eject", "eelem", "selement", "elements", "oelement", "selements", " Elem", "element"], "s": ["services", "string", "ssl", "sf", "server", "n", "fs", "spec", "ns", "c", "S", "sch", "se", "o", "set", "si", "rs", "params", "parts", "sync", "session", "ws", "d", "sb", "strings", "ops", "scope", "r", "sv", "g", "attr", "gs", "xs", "h", "p", "es", "u", "ts", "submit", "ls", "js", "e", "m", "sets", "t", "ss", "details", "sl", "sym", "a", "ses", "v", "b", "ds", "os", "f", "ps", "service"], "lnk": ["nlks", "olnkr", "lnok", "dlf", "dlk", "linf", "lenky", "lnku", "knkh", "olnk", "lenke", "dlok", "dnkr", "gnky", "dnf", "lenk", "olnf", "lnke", "dnky", "lnkh", "nlK", "nnky", "lnky", "lnK", "olnK", "dnke", "lnkr", "dlks", "nlkh", "linky", "gnk", "nlke", "nnke", "olnke", "nlok", "linke", "lenku", "gnke", "nlky", "nlk", "nnku", "dnku", "dlky", "lnf", "dnk", "knK", "nnk", "knke", "lenks", "lnks", "gnok", "knk", "olnkh", "dlke", "nlf", "dlkr"], "j": ["index", "info", "job", "uj", "n", "ij", "note", "dj", "ie", "jc", "ind", "z", "o", "jl", "jo", "si", "fr", "ii", "key", "aj", "qi", "syn", "part", "ja", "ji", "pr", "ch", "g", "li", "x", "p", "jj", "ne", "J", "js", "name", "m", "kj", "pos", "jp", "a", "obj", "adj", "ni", "br", "y", "oj", "im"], "urlLink": ["fileHub", "resourceConnect", "urlHub", "urlLine", "fileUrl", "resourceLine", "URLLink", "strlink", " urlPath", "resourceLink", " urlUrl", "URLUrl", "filePath", "UrlPath", " urllink", " urlConnect", " urlLine", "resourcelink", "urlUrl", "urlPath", "urlConnect", "fileLink", "urlPage", "urlRel", " urlPage", "UrlLink", "strLine", " urlRel", "UrlRel", "strLink", "URLRel", "UrlPage", "UrlUrl", "urllink", " urlHub", "URLPage", "strConnect", "UrlHub"], "str": ["sta", "string", "n", "wr", "enc", "res", "inner", "spr", "l", "line", "fr", "dr", "inst", "pass", "char", "arr", "elt", "txt", "Str", "pr", "ctr", "r", "div", "STR", "data", "text", "js", "name", "coll", "t", "cr", "dec", "sl", "tr", "strip", "ext", "hr", "b", "sp", "br", "kr", "st", "err", "obj", "f", "stri", "sr"], "i": ["index", "info", "mu", "id", "n", "pi", "uri", "ini", "yi", "slice", "c", "fi", "ri", "o", "l", "si", "ui", "ii", "in", "ori", "en", "qi", "vi", "ti", "ji", "phi", "chi", "li", "ip", "x", "p", "mi", "bi", "u", "init", "uli", "ai", "oi", "e", "I", "ci", "io", "eni", "zi", "m", "xi", "di", "gi", "hi", "v", "b", "ni", "y", "abi", "iu", "multi", "f", "ix"], "skip": [" bypass", " scan", "cmp", "copy", "replace", "add", "jump", " exclude", "active", "Skip", " skipping", "iter", "loop", " dup", "append", "ips", "empty", " duplicate", "complete", " repeat", "special", " skipped", "sp", "scan", "error", "fast", "stop"]}}
{"id1": "6190356", "id2": "13012591", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "label": 1, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForNewMD3", " hashPasswordForNewMD5", " hashPasswordForNewM3", " hashPasswordForOldMC3", " hashPasswordForOldMD512", " hashPasswordForNewM512", " hashPasswordForNewM4", " hashPasswordForOldmd5", " hashPasswordForNewMD4", " hashPasswordForOldmd4", " hashPasswordForOldmd512", " hashPasswordForOldMC5", " hashPasswordForOldMC512", " hashPasswordForOldM5", " hashPasswordForNewMD512", " hashPasswordForNewM5", " hashPasswordForOldMD3", " hashPasswordForOldMD4", " hashPasswordForOldM3", " hashPasswordForOldMC4", " hashPasswordForOldM512", " hashPasswordForOldM4", " hashPasswordForOldmd3"], "password": ["crypt", "secret", "text", "padding", "pad", "array", "auth", "message", " passwords", "data", "username", "sword", "phrase", "result", "hash", "input", "encrypted", "key", "wd", "wallet", "pass", "code", "seed", "address", "token", "string", "account", "name", "pattern", "words", "path", "word", "content", "buffer", "value", "Password", "p", " Password", "PASS"], "md": ["m", "rm", "hd", " MD", "Cmd", "mp", "cmd", "pg", "mo", "um", "dig", "dd", "km", "gd", "f", "managed", "rpm", "mc", "mag", "d", "vd", "od", "mb", "meta", "hm", "wd", "nm", "amd", "dm", "bd", "metadata", "pd", "MD", "di", "mac", "ind", "mand", "mm", "ma", "dc", "am", "pm", "grad", "mt", "cd", "clean", "vm", "mod", "df"], "messageDigest": ["messageModester", "messagedigests", "messageAddse", "MessageDigEST", "MessageDigest", "messageAddester", "messageAddEST", "messageModEST", "messagedigest", " messageModester", " messageModEST", "messageAddests", "MessageModse", "messageDest", "messagedigester", "MessageAddse", "messageDEST", "messageAddest", "MessageDigse", " messageDigester", "messageModest", "MessageModester", " messageModest", "messageModse", "MessageModest", " messageDigEST", "messagedigEST", "messageDigse", "MessageAddester", "MessageAddest", "messagedigse", "messageDigests", "MessageDigester", "messageModests", "messageDigEST", "MessageAddEST", "messageDester", "MessageModEST", " messageDigests", "messageDse", "messageDigester", " messageModests"], "hexString": ["stringSection", "stringService", "crossstring", "stringString", " hexstring", " hexFunction", "crossFunction", "sumstring", "octBuffer", "hexBuffer", "transformStr", " hexFile", "transformString", "tempFile", "hexstring", "hexService", "stringArray", " hexStr", "transformBuffer", "tempString", "hexArray", "hexStr", "hashString", "hashSection", "transformArray", " hexArray", "hashService", "crossStr", "tempStr", "sumString", "sumFile", "tempstring", "octStr", "octString", " hexService", " hexSection", "hexFunction", "octArray", "hexSection", "tempFunction", "hexFile", "hashArray", " hexBuffer", "crossString", "sumStr"], "i": ["k", "m", "p", "u", "uri", "e", "j", "length", "b", "n", "fi", "io", "info", "si", "f", "o", "index", "d", "ci", "h", "oi", "s", "ji", "multi", "li", "a", "l", "di", "ip", "pi", "xi", "slice", "r", "id", "ti", "v", "c", "t", "ix", "I", "ai", "phi", "ii", "ui", "x", "bi", "qi", "ri"], "hex": ["text", "ex", "he", "pack", "default", "hack", "length", "null", "cmp", "letter", "form", "pixel", "none", "rh", "data", "nexus", "bit", "hello", "raw", "cookie", "result", "hash", "str", "exp", "digit", "batch", "shift", "utf", "h", "temp", "pex", "buff", "ip", "oct", "lit", "transform", "cache", "sex", "string", "character", " Hex", "alpha", "binary", "host", "full", "pattern", "json", "path", "comp", "zero", "orig", "serial", "rex", "format", "http", "char"]}}
{"id1": "4398382", "id2": "12171364", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"digest": ["Digse", "mdested", "mdests", "mdest", "encse", "encester", "digester", "generests", " digse", " digests", "Digester", "generester", "generested", "digests", "digress", " digress", "mdester", "Digress", "encest", "encress", "digested", "generest", " digested", "digse", "Digest", " digester"], "algorithm": ["malgebra", "alignment", "malignment", " algebra", "algo", "aloding", "Alignment", "aroding", " algo", "algebra", "Algebra", "challenge", "Algo", "argebra", " alenge", "challgo", "argorithm", "alenge", "Algorithm", "malgorithm", "Alenge", "challgebra", "maloding", "arignment", "challgorithm", "Aloding"], "text": ["image", "letter", "feed", "config", "content", "sequence", "format", "input", "pattern", "message", "output", "password", "bytes", "object", "struct", "string", "txt", "code", "TEXT", "buffer", "Text", "token", "path", "attribute", "secret", "length", "name", "test", "ext", "word", "data", "username", "str", "value", "connection", "source", "url", "address"], "mDigest": ["mGest", " mGester", "mSignEST", "mGast", "MDiger", "amPostest", "mDester", "MDigEST", "MDigest", " mGge", "amPostested", "mDenge", "mDesigngest", "mDiggest", "mSignast", "mDEST", "mDgest", "mCodener", "mSignge", "mSignest", "mDer", "mGge", "MDigenge", "mDesignest", "mPostested", "mdiger", " mGast", " mDigast", "mdigener", "mDesigner", "mSignester", "MDer", "mDest", "mPostener", "mCodest", " mDigester", "MDester", "MDgest", "mEncge", "mDigener", "mDesignester", "amDigested", "mPostest", "mdigester", "mSignenge", "mDigester", "mDigenge", "mDiger", "mEncast", "mGester", "MDiggest", "mdiggest", "amDigest", " mGest", "MDest", "mDigEST", "mDigast", "mDigge", "mEncest", " mDigge", "mdigested", "mCodested", "mEncester", "mdigest", "mDigested", "amDigener", "amPostener", "MDigester"], "raw": ["image", "Raw", "enc", "feed", "hex", "content", "input", "json", "none", "serial", "message", "output", "full", "null", "array", "buf", "orig", "initial", "buffer", "original", "wrap", "result", "container", "row", "response", "unsigned", "clean", "internal", "data", "binary", "RAW", "instance", "default", "partial", "source"], "encoder": ["decoding", "deccode", "enccode", "Encoding", "eccode", " encoded", "ecoding", " encoding", "encoded", "Encoded", "encoding", "Encoder", "ecoded", "ecoder", "decode", "ecode", "encode", "enoder", "decoder", " encode", "enode", "Encode", "enoding"]}}
{"id1": "10385815", "id2": "21232043", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public File call() throws IOException {\n        HttpURLConnection conn = null;\n        ReadableByteChannel fileDownloading = null;\n        FileChannel fileWriting = null;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            if (size == -1) {\n                size = conn.getContentLength();\n            }\n            fileDownloading = Channels.newChannel(conn.getInputStream());\n            fileWriting = new FileOutputStream(file).getChannel();\n            long left = size;\n            long chunkSize = BLOCK_SIZE;\n            for (long downloaded = 0; downloaded < size; left = size - downloaded) {\n                if (left < BLOCK_SIZE) {\n                    chunkSize = left;\n                }\n                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);\n                downloaded += chunkSize;\n                setProgress(downloaded);\n            }\n        } finally {\n            if (file != null) {\n                file.deleteOnExit();\n            }\n            if (conn != null) {\n                conn.disconnect();\n            }\n            if (fileDownloading != null) {\n                try {\n                    fileDownloading.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0441\u043a\u0430\u0447\u0438\u0432\u0430\u043d\u0438\u044f\", ioe);\n                }\n            }\n            if (fileWriting != null) {\n                try {\n                    fileWriting.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b\", ioe);\n                }\n            }\n        }\n        return file;\n    }\n", "label": 0, "substitutes": {"copy": ["Cop", "paste", "cmp", "send", "zip", "Copy", "move", "open", "Transfer", "process", "sync", "download", " Copy", "replace", "upload", "exec", "clone", "delete", "get", "split", "transfer", "file", "change", "write", "put", "update", "create"], "fileFrom": [" fileStart", "FileSource", "FileStart", "fileStart", "mailIn", "ioSource", "FileTo", "FileIn", "ioStart", "mailTo", " fileSource", "mailFrom", " fileAs", "FileFrom", "ioFrom", "fileSource", "FileAs", "mailAs", "fileAs", "ioTo", " fileIn", "fileIn"], "fileTo": ["fpto", "resourceFile", "resourceTarget", "fileTO", " fileFile", "FileTo", " fileto", "resourceFrom", "resourceTo", "fpFrom", " fileTO", "fpTO", "fileto", "fileTarget", " fileTarget", "Fileto", "FileFrom", "fpTo", "FileTarget", "fileFile", "FileFile", "FileTO"], "inputStream": ["inputContext", "outputSteam", " inputSteam", "inputFile", "InputChannel", " inputFile", "outputFile", "inputSync", "outputContext", "inputstream", "InputContext", " inputstream", "InputSteam", "InputFile", " inputContext", "Inputstream", "outputSync", " inputSync", "InputSync", "InputStream", "outputstream", "inputSteam"], "outputStream": ["referenceStream", "outputSteam", "OutputStream", "fourStream", "fourChannel", " outputChan", "outputStreamer", "referenceSocket", "outputSocket", " outputSteam", "fourStreamer", "inputSocket", "writeSocket", "fourSteam", "writeChannel", "OutputChan", "referenceSteam", "OutputStreamer", "outputPath", "OutputSteam", "outputChan", "inputPath", " outputStreamer", " outputPath", "OutputPath", "writeSteam", "inputChan", "writeStream", "OutputChannel", "referenceChannel", "inputSteam"], "inputChannel": ["inputContext", "audioClient", "butContext", "parentPassword", "InputChannel", " inputClient", "outputSocket", "butCommand", "outputContext", " inputPassword", "inputSocket", "inputCam", "butChan", " inputCam", "InputContext", "parentStream", "outputPassword", "audioChannel", " inputSocket", " inputChan", "outputChan", " inputCommand", "inputClient", " inputContext", "outputCam", "inputCommand", "parentChannel", "InputSocket", "butChannel", "InputChan", "inputPassword", "inputChan", "outputCommand", "outputClient", "audioStream", "audioCam", "parentChan", "InputStream"], "outputChannel": ["inputContext", "outputchannel", "OutputStream", "outChannel", "OutputContext", " outputQueue", " outputChan", "outputContext", " outputContext", "OutputChan", " outputchannel", "outputChan", "OutputQueue", "outStream", "outChan", "outputQueue", "inputChan", "OutputChannel", "inputQueue", "inputchannel", "outContext", "Outputchannel"]}}
{"id1": "23666973", "id2": "15745420", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    private void download(String address, String localFileName) throws UrlNotFoundException, Exception {\n        String ext = G_File.getExtensao(address);\n        if (ext.equals(\"jsp\")) {\n            throw new Exception(\"Erro ao baixar pagina JSP, tipo negado.\" + address);\n        }\n        File temp = new File(localFileName + \".tmp\");\n        if (temp.exists()) temp.delete();\n        OutputStream out = null;\n        URLConnection conn = null;\n        InputStream in = null;\n        try {\n            try {\n                URL url = new URL(address);\n                conn = url.openConnection();\n                in = conn.getInputStream();\n            } catch (FileNotFoundException e2) {\n                throw new UrlNotFoundException();\n            }\n            out = new BufferedOutputStream(new FileOutputStream(temp));\n            byte[] buffer = new byte[1024];\n            int numRead;\n            long numWritten = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                out.write(buffer, 0, numRead);\n                numWritten += numRead;\n            }\n        } catch (UrlNotFoundException exception) {\n            throw exception;\n        } catch (Exception exception) {\n            throw exception;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n            }\n        }\n        File oldArq = new File(localFileName);\n        if (oldArq.exists()) {\n            oldArq.delete();\n        }\n        oldArq = null;\n        File nomeFinal = new File(localFileName);\n        temp.renameTo(nomeFinal);\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["createStreamSource", "createSteamSource", "openStreamAsync", "openSteamAsync", "createStreamRaw", "openstreamRaw", "openFileRaw", "openFileSource", "openStreamInternal", "createStreamAsync", "openstreamSource", "createSteamAsync", "openFileInternal", "openSteamSource", "openSteamInternal", "createStreamInternal", "createSteamInternal", "createSteamRaw", "openstreamInternal", "openFileAsync", "openstreamAsync", "openStreamSource", "openSteamRaw"], "filename": ["directory", "string", "path", "class", "loader", "sf", "uri", "resource", "n", "username", "dll", "kl", "subject", "wl", "fp", "location", "length", "fn", "l", "lua", "il", "database", "password", "txt", "utf", "source", "Filename", "which", "login", "undle", "FILE", "license", "SourceFile", "acl", "data", "file", "src", "size", "nil", "journal", "href", "ppa", "title", "name", "fil", "word", "prefix", "fd", "rl", "sql", "fax", "sound", "download", "f", "kn", "phrase", "actual", "ename", "jpg"], "stream": ["zip", "ssl", "class", "temp", "resource", "output", "http", "cont", "host", "content", "raw", "uc", "model", "open", "file", "bb", "row", "context", "coll", "sl", "transform", "download", "impl", "string", "buffer", "accept", "server", "feed", "clean", "result", "trans", "sync", "source", "load", "live", "value", "w", "parent", "channel", "through", "hook", "object", "control", "full", "pair", "event", "path", "rest", "core", "video", "response", "message", "slice", "socket", "length", "loop", "session", "reader", "back", "Stream", "upload", "body", "null", "image", "steam", "wrapper", "stack", "stage", "ream", "method", "cur", "callback", "view", "valid", "input", "enc", "continue", "draft", "current", "instance", "child", "pool", "thread", "form", "client", "sample", "size", "log", "port", "pull", "sw", "f", "iv"], "url": ["string", "path", "base", "ssl", "loader", "server", "resource", "uri", "feed", "id", "http", "rel", "l", "URL", "line", "el", "fl", "source", "lib", "data", "file", "channel", "web", "page", "ll", "name", "coll", "e", "image", "sl", "Url", "www", "b", "ul", "f", "plug", "api", "loc"], "cl": ["hell", "sel", "class", "loader", "cc", "sc", "ssl", "Cl", "lock", "kl", "con", "c", "cont", "ctrl", "col", "l", "shell", "pl", "el", "fl", "ec", "comb", "client", "lc", "uc", "lib", "ct", "ocl", "acl", "ll", "cel", "ls", "coll", "cr", "cle", "ml", "decl", "sl", "CL", "ctx", "bc", "pe", " CL", "sh", "bl", "scl", "cli", "gl", "loc"], "cn": ["ains", "core", "cc", "n", "cf", "enc", "gin", "net", "con", "ns", "jc", "act", "cb", "fn", "arn", "hn", "dc", "CW", "nc", "ec", "CN", "cm", "cdn", "icon", "lc", "auc", "uh", "ct", "rn", "cy", "ca", "gn", "nam", "xc", "CA", "wcs", "ae", "conn", "cone", "ain", "bn", "nic", "coll", "dn", "cr", "kin", "mc", "ln", "nat", "abc", "mn", "sn", "kn", "Ns"]}}
{"id1": "9796161", "id2": "11049257", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String generate(boolean secure, boolean sep) throws UnknownHostException {\n        MessageDigest messagedigest;\n        StringBuilder stringbuffer = new StringBuilder();\n        try {\n            messagedigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException nosuchalgorithmexception) {\n            throw new RuntimeException(nosuchalgorithmexception);\n        }\n        StringBuffer stringbuffer2;\n        InetAddress inetaddress = InetAddress.getLocalHost();\n        long l = System.currentTimeMillis();\n        long l1 = 0L;\n        if (secure) l1 = _secureRand.nextLong(); else l1 = _rand.nextLong();\n        stringbuffer.append(inetaddress.toString());\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l));\n        stringbuffer.append(\":\");\n        stringbuffer.append(Long.toString(l1));\n        messagedigest.update(stringbuffer.toString().getBytes());\n        byte abyte0[] = messagedigest.digest();\n        StringBuffer stringbuffer1 = new StringBuffer();\n        for (int i = 0; i < abyte0.length; i++) {\n            int j = abyte0[i] & 0xff;\n            if (j < 16) stringbuffer1.append('0');\n            stringbuffer1.append(Integer.toHexString(j));\n        }\n        String s = stringbuffer1.toString();\n        stringbuffer2 = new StringBuffer();\n        if (sep) {\n            stringbuffer2.append(s.substring(0, 8));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(8, 12));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(12, 16));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(16, 20));\n            stringbuffer2.append(\"-\");\n            stringbuffer2.append(s.substring(20));\n            return stringbuffer2.toString();\n        } else {\n            return s;\n        }\n    }\n", "label": 1, "substitutes": {"getMD5": ["getSHA4", " getSHA4", "getMD4", "getmdHash", " getSHAHash", "getmd5", "getSHA5", "getSHA512", "getmd512", "getMDHash", "getmd4", " getMDHash", " getSHA5", "getSHAHash", " getMD4", "getHTML5", "getMD512", " getSHA512", "getHTML4", " getMD512", "getHTML512", "getHTMLHash"], "s": ["v", " ads", "services", "ms", "str", "scripts", "e", "sets", "ts", "rs", "ws", "ates", "es", "input", "ns", "abs", "string", "ls", "styles", "lines", "c", "si", "als", "ses", "self", "comments", "strings", "os", "ssl", "sb", "i", "a", "g", "b", "js", "n", "cs", " fails", "ps", "sym", "S", "sync", "ends", "ows", "ds", "parts", "p", "bytes", "its", "ips", "is", "l", "in", "data", "source", "f", "ss", "bs", "tests", "gs", "ings"], "m": ["cm", "md", "v", "im", "mc", "ms", "mr", "gm", "e", "rm", "pm", "am", "bm", "um", "manager", "machine", "fm", "mut", "man", "M", "c", "sm", "mi", "ym", "mand", "t", "i", "om", "arm", "mm", "tm", "em", "p", "h", "mac", "hm", "wm", "me", "l", "vm", "d", "nm", "dm", "mu", "f", "module"]}}
{"id1": "20375440", "id2": "411595", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "srcFile": ["destFiles", "sourceFiles", " srcfile", "destDir", "srcDir", "srcfile", " srcFiles", "srcPath", "destfile", "sourcePath", "sourcefile", "sourceFile", "rcfile", "rcPath", " srcPath", "rcFile", "rcFiles", " srcDir", "srcFiles", "sourceDir"], "destFile": ["destFiles", "destPlace", "targetFiles", "DestFiles", " destfile", "DestPlace", "Destfile", "targetFile", "DestFile", "destPath", "targetfile", "targetPlace", "restfile", "restFiles", "destfile", " destFiles", "tempFile", " destPath", "tempFiles", "tempfile", "tempPath", "DestPath", "restPlace", "restFile"], "src": ["sys", "ser", "url", "img", "stat", "reader", "client", "sup", "sr", "gb", "sec", "sub", "proc", "func", "cur", "ws", "ctx", "sl", "input", "start", "conn", "secure", "conv", "stream", "upload", "self", "sel", "construct", "ssl", "sb", "sq", "config", "slice", "loc", "sync", "ources", "inst", "loader", "rb", "rc", "in", "source", "sc", "dist", "RC", "req", "impl", "bs", "cb", "rs", "cmp"], "dest": ["rest", "slave", "test", "de", "result", "thin", "img", "sup", "output", "tmp", "comb", "proc", "path", "ws", "div", "target", "out", "end", "ui", "cp", "stream", "obj", "this", "std", "ssl", "writer", "Dest", "des", "transform", "class", "desc", "dat", "null", "cdn", "wb", "ds", "wh", "dc", "source", "destroy", "usr", "dir", "dist", "d", "dev", "home", "trans", "opt", " Dest", "temp"], "buffer": ["Buffer", "position", "address", "result", "header", "base", "uffer", "reader", "cache", "bin", "transfer", "feed", "raw", "request", "row", "input", "length", "string", "offset", "memory", "queue", "write", "layer", "reference", "info", "writer", "batch", "b", "number", "buf", "null", "slice", "block", "message", "iter", "bytes", "wave", "key", "copy", "flush", "data", "source", "channel", "limit", "capacity", "value", "size", "buff"], "read": ["exec", "k", "ip", "reader", "level", "send", "parse", "allow", "use", "id", "feed", "load", "not", "raw", "check", "skip", "x", "default", "index", "input", "connect", "start", "length", "play", "ind", "end", "seek", "write", "next", "no", "build", "i", "count", "ride", "wait", "b", "number", "fill", "n", "text", "show", "shape", "find", "Read", "slice", "block", "sync", "READ", "ok", "iter", "close", "add", "key", "get", "copy", "data", "sleep", "work", "se", "d", "limit", "create", "reads", "pass", "pick", "open", "reading", "size", "select", "run"]}}
{"id1": "16388708", "id2": "4618237", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFileToStream", "decodeStringToString", "decodeFileAsFiles", "decodeFileAsStream", "decodeString2Files", "decodeStringToFiles", "decodeFile2String", "decodeFile2File", "decodeFileAsString", "decodeStringToFile", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeFileFromStream", "decodeFile2Stream", "decodeString2File", "decodeFileToFiles", "decodeStringToStream", "decodeFileToString", "decodeFileAsFile", "decodeString2String", "decodeString2Stream"], "infile": [" infilename", "infiles", "inputfile", "outfiles", "inFile", "InFile", " instream", "minstream", "Instream", "inputfilename", "inbase", " infiles", " infp", " inFile", "minbase", "minFile", "minfile", "outfilename", "outfp", "instream", "inputfiles", "infp", "Inbase", "inputfp", "infilename", " inbase", "Infile"], "outfile": ["outputdatabase", "outFile", "inputfile", " outFile", "outpath", "outputfilename", "inFile", " outpath", "inputdatabase", " outfilename", "outdatabase", "outfolder", "outputfolder", "outputpath", "inputpath", "inputFile", " outfolder", "infolder", "outfilename", " outdatabase", "outputfile", "infilename", "outputFile"], "in": ["re", "err", "ini", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "lin", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "m", "din", "socket", "inc", "s"], "out": ["ou", "err", "log", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "obj", "channel", "In", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "pass", "outs", "work", "job", "line", "io", "Out", "client", "off", "name", "co", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "channel", "count", "cache", "slice", "queue", "b", "bytes", "bin", "bb", "null", "buf", "buff", "border", "padding", "split", "uffer", "type", "result", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "r", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "method", "model", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "open", "better", "message", "growth", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "positive", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "12766394", "id2": "8079516", "code1": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"testReadHelloWorldTxt": ["testReadHelloWorldTXT", "testReadHelloWordTtxt", "testReadHelloWorldMXT", "testReadHelloWorldFext", "testReadHelloWorldText", "testReadHelloWordText", "testReadHelloWordMtxt", "testReadHelloWorldMtxt", "testReadHelloWordTxt", "testReadHelloWorldFtxt", "testReadHelloWordMxt", "testReadHelloWorldMext", "testReadHelloWorldMxt", "testReadHelloWorldTtxt", "testReadHelloWorldFXT", "testReadHelloWordMXT", "testReadHelloWordTXT", "testReadHelloWordMext", "testReadHelloWorldFxt"], "helloWorldIS": ["helloCommunityIs", "helloWorldIDE", " helloCityIS", " helloWorldIs", "helloCityIS", "helloCommunityIDE", "helloWestAS", "helloCityIR", "helloWestIS", "helloWestIR", "helloWorldis", "helloCityIs", " helloWorldIR", " helloCityIs", "helloCommunityIS", " helloCityIR", " helloWorldAS", " helloWorldIDE", "helloWestIs", "helloCityAS", " helloCityAS", "helloWorldIR", "helloWorldIs", "helloCityIDE", "helloCityis", "helloWorldAS", " helloWorldis"], "helloWorldPath": [" helloWorldDir", "helloworldPATH", "officeCommunityLocation", "helloWebUrl", "officeCommunityCorp", "helloWallName", "helloWorldName", "helloCommunityName", "hiWebpath", "helloWebpath", "helloWallPath", "helloWorldDir", "officeWorldPath", "hiWorldpath", "officeWorldLocation", "helloWallDir", "helloWebFile", "helloworldPath", "officeCommunityPath", " helloWorldName", " helloWorldpath", "officeWorldCorp", "officeCommunityPATH", "helloCommunityLocation", "helloWebPath", "helloCommunityCorp", "hiWorldUrl", "helloWorldUrl", "hiWebUrl", "helloWallpath", "helloworldLocation", "helloCommunityPATH", "helloCommunityPath", "hiWebFile", "helloWorldpath", "hiWebPath", "helloWorldCorp", "hiWorldPath", "helloworldCorp", "helloWorldPATH", "helloCommunityDir", "helloWorldLocation", "officeWorldPATH", "hiWorldFile", "helloCommunitypath", "helloWorldFile"], "fileOutputStream": ["fileWriteStream", "FileOutputstream", "fileOutputFile", "fileInputStream", "fileOutFile", "resourceInputSteam", "resourceOutputFile", "resourceOutputSteam", "resourceOutputPath", "fileWriteSteam", "resourceInputFile", "FileInputSteam", "resourceInputPath", "FileOutputHandler", "FileOutputSteam", "fileInputHandler", "FileOutputStream", "fileOutSteam", "fileInputPath", "fileoutputSteam", "fileWritePath", "fileOutputSteam", "FileInputStream", "FileInputstream", "fileoutputstream", "fileOutputHandler", "resourceOutputStream", "fileWritestream", "fileoutputStream", "fileoutputHandler", "FileInputFile", "fileInputFile", "fileOutPath", "fileWriteFile", "fileInputSteam", "FileOutputFile", "fileInputstream", "fileOutputstream", "fileOutStream", "FileInputHandler", "resourceInputStream", "fileOutputPath"], "contentResolver": [" contentresolver", "contentRoser", " contentresolution", "messageResultolver", "resourceResolve", "contentRevolve", "resourceResolver", "contentRolution", "contentresolver", "contentResponseolver", "resourceRolver", "contentRolving", "ContentRolver", "contentRlier", "contentResponseistor", "contentResistor", "contentRevolved", "messageResolver", "contentresolution", "contentRolve", " contentResolved", "contentResolves", "ContentRolution", " contentRevolve", "contentAbsolver", "contentResponseolve", "contentResultolve", "contentResponseolved", " contentRevistor", "contentAbsolution", "ContentResoser", "messageResultolution", "ContentResolution", "contentReslier", "ContentResolver", "contentResolve", "ContentResolving", "contentResolution", "resourceResolution", "contentResultlier", "messageResolution", "contentResoser", "contentRevolver", " contentResolution", "contentreslier", "contentAbsolve", "contentRolver", "messageReslier", "ContentResolve", "contentRevistor", "contentresolve", "contentResultistor", "contentAbsoser", " contentResolves", "contentresolving", "resourceRolution", "contentresolved", " contentRevolved", " contentResistor", "ContentRoser", "contentResolving", "contentRolves", "messageResultlier", "contentResultolver", "contentRevolution", "contentresolves", " contentresolves", "resourceResolved", "contentResolved", "contentRolved", "contentResultolved", "ContentRolve", "resourceRolve", "contentResultolution", "messageResultolve", " contentRevolver", " contentResolve", "ContentRolving", "contentRevolves", "resourceRolved", " contentresolve", "messageResolve"], "content": ["body", "image", "model", "lc", "html", "draft", "resource", "Content", "feed", "script", "child", "cont", "temp", "current", "write", "json", "children", "version", "text", "message", "cache", "load", "play", "output", "java", "password", "media", "conn", "full", "column", "page", "update", "string", "code", "read", "example", "fill", "status", "core", "path", "work", "next", "job", "result", "css", "response", "layer", "handle", "xml", "ontent", "size", "any", "name", "title", "ext", "word", "server", "data", "file", "valid", "document", "header", "value", "comment", "activity", "complete", "empty", "default", "connection", "config", "parent", "url", "copy", "address"]}}
{"id1": "62362", "id2": "324679", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["conversion", "CONvert", " deconversion", "Converting", "unverted", "subvert", "CONverted", "subverting", "Convert", "CONversion", "unception", "converted", "subversion", "oconvert", "Conversion", "Conception", "oconverting", " deconverted", "oconversion", "unversion", "conception", "converting", "CONception", "subverted", "unvert", " deconverting", " deconvert", "oconverted", "CONverting", "Converted"], "src": ["SourceFile", "buf", "sth", "fn", "prot", "component", "req", "url", "uri", "ssl", "resource", "st", "cmp", "loc", "Dest", "rc", "back", "username", "sys", "sb", "impl", "inst", "Source", "spec", "input", "sn", "cpp", "storage", "ref", "rb", "supp", "href", "attr", "cb", "s", "download", "code", "sin", "source", "reader", "config", "filename", "tmp", "stream", "rl", "slice", "sc", "video", "sit", "string", "load", "ource", "file", "obj", "upload", "gb", "name", "RC", "gz", "dist", "stage", "sel", "ctx", "proc", "path", "secure", "scene", "fp", "img", "feat"], "dest": [" dst", "std", "fn", "txt", "disk", "null", "Dest", "dat", "test", " destination", "home", "temp", "source", "class", "dir", "tmp", "di", "target", "bin", "obj", "dist", "dc", "path", "cont", "orig", "lib", "img"], "in": ["ex", "ins", "In", "n", "ps", "io", "data", "inc", "f", "input", "din", "IN", "d", "inn", "inas", "val", "inf", "pass", "i", "is", "source", "win", "reader", "a", "stream", "login", "r", "bin", "err", "file", "t", "up", "pin", "ini", "as", "doc", "isin"], "p": ["m", "pe", "np", "lp", "e", "j", "g", "b", "cp", "ps", "pg", "bp", "parser", "part", "f", "py", "P", "pa", "pb", "d", "o", "h", "s", "pr", "i", "pd", "l", "wp", "pi", "r", "po", "pc", "v", "c", "t", "per", "sp", "pre", "op", "pm", "jp", "pp", "fp", "tp", "cop"], "ds": ["des", "ths", "rs", "data", "ded", " DS", "vs", "dat", "ys", "dm", "models", "nas", "cs", "utils", "ups", "bs", "ks", "ipes", "df", "dos", "js", "ads", "DS", "obs", "parts", "gd", "dl", "qs", " sd", "eps", "dds", " ps", "dp", "ls", "points", "ps", "sys", "uds", "sts", "sync", "dd", "groups", "ges", "Ds", "d", "lines", "s", "pd", "db", "da", "ils", "icks", "ld", "ts", "gs", "services", "ants", "cons", "ins", "lp", "ss", " props", "os", "ns", "dates", "plugins", "hs", "amps", "docs", "posts", "tools", "vals", "di", "scripts", "dist", "tests", "dc", "xs", "ays", "ans", "words", "els", "dt", "styles"], "format": ["filter", "at", "fd", "prefix", "fn", "url", "frame", "unit", "struct", "style", "form", "letter", "act", "atter", "tag", "data", "version", "scale", "parser", "part", "model", "f", "spec", "template", "type", "sche", "plugin", "source", "class", "api", "config", "record", "nat", "filename", "table", "layout", "string", "language", "handler", "file", "Format", "name", "t", "magic", "pattern", "host", "function", "ant", "path", "fp", "feat"], "hasPixelData": ["hasByteStyle", " hasPixeldata", "hasPixelStyle", "hasPixeldata", "showsByteStyle", "haspixelSize", "haspixeldata", "hasByteDATA", "hasPicturedata", "showsPixelData", "showsPixeldata", "hasByteData", " hasPixelSize", "hasPixelDATA", "showsPixelStyle", "hasPixelSize", "hasByteSize", "showsBytedata", "showsPixelDATA", "hasPictureData", "hasPictureSize", "hasBytedata", "showsByteDATA", "haspixelData", "showsByteData"], "inflate": ["inflated", "infolATE", "invenode", "inFlation", "Inflace", "insvenATE", "InFlace", "inffated", "infloated", "inflation", "Inflation", "insvenode", "Inflated", "infloate", "inflating", "infolating", "inffate", "inadequate", "infloace", "insflate", "inflode", "inadequATE", "insflATE", "InFlated", "invenating", "inFlated", "infolode", "insflating", "inflace", "Inflate", "inadequode", "InFlation", "inFlate", "infface", "invenate", "inadequating", "inffation", "insvenating", "infloation", "inflATE", "invenATE", "insvenate", "inFlace", "insflode", "InFlate", "infolate"], "pxlen": ["fxden", "txlon", "pxcount", "camln", "txlen", "pnglen", "txlin", "pglen", "pxden", "xplength", "axlon", "pxLen", "mxln", "mxdata", "pgden", "ppl", "axlin", "fxLen", "campos", "pxlon", "pgLen", "xplen", "camdata", "mxsize", "pcln", "mxlen", "ppLen", "pxlin", "xpsize", "pxlength", "pgl", "fxlen", "fxln", "pnglength", "pclon", "mxcount", "mxpos", "pxpos", "ppden", "axlen", "pplen", "pxl", "mxlength", "camlen", "pclen", "axln", "fxl", "fxdata", "pngsize", "pxsize", "pxln", "fxpos", "pclin", "xpcount", "pngcount", "txln", "pxdata"], "out": ["page", "pad", "gen", "log", "server", "copy", "parent", "lock", "io", "store", "sys", "step", "session", "output", "group", "Out", "error", "conn", "cli", "work", "co", "dump", "point", "outs", "user", "cache", "v", "err", "obj", "list", "re", "up", "inter", "OUT", "query", "state", "again", "line", "lib", "post"]}}
{"id1": "8329093", "id2": "11968328", "code1": "    public void parse(ParserEvent event) {\n        logger.debug(\"parse() called for link \" + event.getLink().getURI());\n        if (event.getLink().getURI().matches(itemFilter)) {\n            logger.debug(\"Content \" + event.getLink().getURI() + \" matched\");\n            Statement stmt = null;\n            ResultSet rs = null;\n            long checksum1 = 0;\n            try {\n                URL url = new URL(event.getLink().getURI());\n                checksum1 = url.openConnection().getLastModified();\n            } catch (MalformedURLException mfe) {\n                logger.error(\"Malformed url \" + event.getLink().getURI() + \" - \" + mfe.getMessage());\n                return;\n            } catch (IOException ioe) {\n                logger.error(\"Couldn't read \" + event.getLink().getURI() + \" - \" + ioe.getMessage());\n                return;\n            }\n            if ((checksum1 == 0) || (checksum1 == 1)) {\n                Adler32 adler32 = new Adler32();\n                NodeList nodes = (NodeList) event.getPageData().getData();\n                adler32.update(nodes.toHtml().getBytes());\n                checksum1 = adler32.getValue();\n            }\n            try {\n                stmt = conn.createStatement();\n                rs = stmt.executeQuery(\"SELECT * FROM documents WHERE url='\" + event.getLink().getURI() + \"'\");\n                if (rs.first()) {\n                    long checksum2 = rs.getLong(\"checksum\");\n                    if (checksum1 == checksum2) {\n                        stmt.executeUpdate(\"UPDATE documents SET checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    } else {\n                        stmt.executeUpdate(\"UPDATE documents SET checksum=\" + checksum1 + \", checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    }\n                } else {\n                    stmt.executeUpdate(\"INSERT INTO documents VALUES \" + \"(DEFAULT, '\" + event.getLink().getURI() + \"', \" + checksum1 + \", '\" + providerId + \"', \" + String.valueOf(System.currentTimeMillis()) + \")\");\n                }\n            } catch (SQLException e) {\n                logger.error(\"Could't perform database query or update - \" + e.getMessage());\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    rs = null;\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    stmt = null;\n                }\n            }\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 0, "substitutes": {"parse": [" explode", " assemble", " scan", "patch", " setup", "parser", "process", "replace", "info", "apply", " merge", " split", " read", " parsing", "se", " discover", " patch", "Parser", "handle", " serve", "pack", " dissect", " parser", " sniff", "arse", " extract", " analyse", " build"], "event": ["image", "flow", "action", "resource", "other", "view", "stream", "this", "content", "input", "function", "open", "entry", "version", "load", "message", "cache", "text", "events", "info", "environment", "object", "update", "style", "element", "g", "item", "vent", "handler", "node", "author", "original", "type", "attribute", "result", "v", "x", "entity", "response", "ce", "layer", "context", "xml", "app", "request", "data", "ev", "document", "Event", "e", "user", "instance", "error", "comment", "actual", "config", "source", "parent", "address"], "stmt": ["stbl", "Stmt", " stct", "stct", "tct", "Stmb", "adbl", "stmd", "tm", "dmt", "adnt", "adql", "stql", "stpt", "tmb", " stmn", "rpt", "stnt", "stmn", "Stct", "tbl", "rnt", "dnt", " start", "spmt", "Stmd", "STm", " stmb", "stm", "tmd", " stbl", "start", "rmt", "Stpt", "dpt", "adpt", " stpt", "spbl", "rql", "adart", "STmn", "dql", "tpt", "Stm", " stm", "admt", "STmt", "spmd", "stmb", "spart", "tmt", " stmd", "Stbl", "STmd", "tmn", "admd"], "rs": ["resources", "ars", "sels", "vals", "rys", "eers", "odes", "RC", "ls", "runs", "lines", "rt", "details", "maps", "vers", "ges", "src", "repl", "events", "ms", "otes", "ws", "Rs", "pr", "rd", "r", "xs", "rows", "rc", "ps", "ats", "obs", "ows", "ds", "relations", "ris", "result", "acks", "ros", "rr", "ras", "cs", "mr", "opens", "qs", "ins", "hs", "hr", "ys", "sr", "gs", "icks", "nas", "bs", "RS", "results", "res", "ks", "ts", "stats", "rss"], "checksum1": [" checksum0", "checksums1", "checksque1", "checksque0", "checksnum91", " checkssum100", " checkssumOnce", "checksumi2", "checksum0", "checksumm2", "checksullOne", "checksnum1", " checkssum2", "checksummer91", "checksque2", " checksum3", " checksum91", "checksam2", "checksull61", "checksumi1", "checkssum1", " checksumOne", "checksumb2", "checksnumOne", "checksummOne", "checksUM3", " checkssum3", "checksumi3", "checksam100", "checksum61", "checksum100", "checksnum0", "checksum3", "checksums2", " checkssum91", "checksumbOne", "checksull1", "checkssum3", "checksumsOnce", "checksumm1", "checksUM2", "checksummer1", " checksum61", "checkssum91", "checkssum2", "checksUMOne", " checkssum1", " checkssumOne", "checksull2", "checksam0", "checkssum100", "checksumOne", "checksUM1", "checksummer0", "checksumb1", " checksum100", " checkssum0", "checksam1", "checksummer2", "checksum91", "checksnum2", "checksque100", "checksnum3", "checkssum0", "checkssumOnce", " checksumOnce", "checksnum61", "checkssumOne", " checkssum61", "checkssum61", "checksumOnce", "checksumsOne", "checksumbOnce"], "url": ["image", "link", "html", "URL", "base", "resource", "www", "Link", "impl", "stream", "coll", "content", "ul", "Url", "ball", "ls", "channel", "match", "http", "message", "text", "l", "b", "conn", "api", "object", "page", "string", " URL", "r", "bel", "buffer", "path", "job", "fl", "org", "uri", "pull", "layer", "blog", "orb", "xml", "URI", "ssl", "server", "data", "file", "ll", "user", "ob", "id", "el", "sl", "error", "connection", "loc", "location", "web", "f", "address"], "adler32": ["adlr40", "aclr16", " adler2", "adlr2", "adler31", "adger40", "adger32", "adlor32", " adger16", "adlr52", " adlr2", " adger31", "acler16", "adle32", "adlor2", "adlor16", "adlor52", "aclr52", "adder31", "adder40", "adder32", "adler40", " adler40", "aclr2", "aclr32", "adder16", "adle16", " adlr32", "adlr16", "acler52", "acler2", "adler52", "adlr32", "adle40", " adler31", "adger16", " adlr16", "acler32", " adler16", " adger40", " adlr40", "adger31", " adger32", "adler16", "adger2", "adler2", "adlr31", "adle2", "adger52"], "nodes": ["nubes", "snode", " nobs", "sents", "sode", "snodes", "nods", "Node", "Nobs", " node", "Nubes", " nubes", "todes", "tods", "node", "sods", "nents", "tents", "tode", "sodes", "snobs", "snubes", "Nents", "Nods", "Nodes", "nobs"], "checksum2": [" checksum0", "checksums1", "checkssum1", "checkssum0", "checksub2", " checkssum82", "checksummer82", "checksha1", "checksub1", " checksum82", "checksummer1", "checksums0", "checksha2", "checksha0", "checkssum2", "checksum0", " checkssum1", "checkssum82", " checkssum2", "checksub0", "checksummer0", "checksums2", "checksum82", " checkssum0", "checksha82", "checksummer2"]}}
{"id1": "14794404", "id2": "10391753", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["EncipherSecret", "encressSecret", "encipherString", "EncryptPassword", "encresspassword", "EncryptSecret", "encryptedpassword", "encressString", "encipherpassword", "EncipherPassword", "encryptedString", "encryptedSecret", "encressPassword", "encryptpassword", "encipherPassword", "encryptSecret", "encipherSecret", "encryptString", "Encryptpassword", "Encipherpassword", "EncryptString", "EncipherString"], "password": ["enc", "Password", "resource", "email", "prefix", "content", "input", " passwords", "pattern", "channel", "text", "message", "cache", "wd", "object", "device", "string", "definition", "array", "params", "buffer", "pass", "crypt", "token", "path", "padding", "phrase", "p", "attribute", "secret", "name", "PASS", "word", "data", "username", "sword", "description", "database", "words", "connection", "address"], "encryptedPassword": ["protectedString", "encryptedCode", "lockedString", " encryptedString", "protectedPass", " encryptedpassword", "encryptedPass", "lockedpassword", "encryptedpassword", "protectedCode", "protectedpassword", "ryptedString", "protectedPassword", "ryptedCode", "encryptedString", " encryptedPass", "ryptedpassword", "lockedPassword", "ryptedPass", "ryptedPassword", "lockedPass", " encryptedCode"], "md5": ["MD4", "digdown", "md6", "MD512", "MD5", " md6", "md512", " MD2", "MD45", " md512", "dig45", "md2", "md4", "mddown", " md2", " MD512", "MD6", "dig2", " MD5", "MDdown", "dig4", " md3", "amd4", " md4", "MD2", "MD3", "amd6", "dig3", "dig5", "amd2", " MD3", " mddown", "md45", " md45", "amd5", "md3"], "digest": ["digher", "Digher", "mdested", "Digenge", "digment", "digash", "mdests", "mdest", "mdash", " digher", "mdace", "encester", "digester", "Digests", "mdher", " digash", " digests", "signests", "Digester", " digment", "digenge", " digenge", " digace", "digests", "Digested", "Digace", "mdester", "mdenge", "encest", "signest", "signester", "digace", "encash", "digested", "signested", "Digest", " digester", "mdment", "encment"], "i": ["index", "j", "o", "oi", "hi", "phi", "ii", "ix", "l", "b", "ui", "ri", "pi", "c", "r", "gi", "t", "d", "li", "k", "ci", "p", "ie", "multi", "si", "io", "xi", "bi", "I", "v", "x", "ai", "it", "uri", "ip", "length", "ti", "h", "id", "qi", "e", "u", "di", "f", "zi", "s"], "hex": ["enc", "coord", "letter", "num", "temp", "prefix", "closure", "lit", "check", "mix", "none", "bits", "stick", "ix", "pattern", "serial", "oct", "alpha", "exp", "text", "zip", "bit", "sex", "slice", "bin", "pex", "utf", "ctr", "string", "hash", "null", "buff", "shift", "rh", "comp", "sign", "ip", "pixel", "length", "pack", "digit", "ext", "rex", "data", "id", "nexus", "binary", "char", "str", "ex", "di"]}}
{"id1": "5274228", "id2": "14194234", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    private String File2String(String directory, String filename) {\n        String line;\n        InputStream in = null;\n        try {\n            File f = new File(filename);\n            System.out.println(\"File On:>>>>>>>>>> \" + f.getCanonicalPath());\n            in = new FileInputStream(f);\n        } catch (FileNotFoundException ex) {\n            in = null;\n        } catch (IOException ex) {\n            in = null;\n        }\n        try {\n            if (in == null) {\n                filename = directory + \"/\" + filename;\n                java.net.URL urlFile = ClassLoader.getSystemResource(filename);\n                if (urlFile == null) {\n                    System.out.println(\"Integrated Chips list file not found: \" + filename);\n                    System.exit(-1);\n                }\n                in = urlFile.openStream();\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuffer xmlText = new StringBuffer();\n            while ((line = reader.readLine()) != null) {\n                xmlText.append(line);\n            }\n            reader.close();\n            return xmlText.toString();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"Integrated Chips list file not found\");\n            System.exit(-1);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"put": ["create", "cache", "output", "client", "parse", "st", "Put", "update", "PUT", "build", "data", "resource", "format", "transform", "add", "UT", "transfer", "post", "operation", "string", "patch", "write", "submit", "replace", "file", "pull", "get"], "resourceID": ["serviceIDs", "responseKey", "resourceId", "serviceId", "objectIDs", "ResourceURL", "responseID", "responseURL", "objectId", "resourceid", "resourceURL", "objectid", "resourceIDs", "resourceKey", "ResourceID", "responseId", "Resourceid", "requestId", "ResourceId", "objectID", "ResourceKey", "serviceID", "requestURL", "serviceid", "requestID", "ResourceIDs", "requestKey"], "headersMap": [" headersFile", "httpMap", "httpSet", "headersSet", "ersFile", "headersFile", "headerSet", "httpArray", "httpList", " headersSet", "headerList", "headerFile", "headerMap", "ersArray", "headerArray", "ersMap", "ersList"], "httpClient": ["HttpClient", "httpsClient", "ttpClient", "httpContext", " httpContext", "phpCall", "httpConnection", "httpsPut", " httpCall", "ttpConnection", "httpsBase", "HttpContext", " httpConnection", "httpServer", "httpsConnection", "HttpPut", "httpCall", "httpsServer", "httpCase", "httpBase", "ttpPut", "HttpServer", "HttpCase", "phpClient", " httpCase", " httpBase", "phpCase", "ttpBase", "HttpCall", " httpServer", "httpsContext", "phpPut"], "httpPut": ["HttpClient", "HttpPush", "phpPush", "phpSplit", "httpsClient", "phpGet", "viewPUT", " httpGet", "viewPut", " httpPUT", "phpAdd", " httpWrite", "httpsPut", "httpsPUT", "httpDo", "webPush", "httpGet", "httpsSplit", "webPut", "httpSplit", "httpPush", "httpsAdd", "HttpDo", "HttpPut", "internalPut", " httpAdd", "Httpput", "httpWrite", "internalGet", "internalPush", "httpput", "internalWrite", " httpPush", "httpAdd", "phpWrite", "webPUT", "httpsPush", "HttpPUT", "HttpGet", "httpsput", "httpPUT", "viewPush", "httpsGet", "viewput", " httpSplit", " httpDo", "httpsDo", "webGet", "phpPut"], "headersList": ["driversMap", " headersL", "headersSet", "ersL", "headerSet", " headersSet", "driversL", "headerList", "headerMap", "ersArray", "headerArray", "driversArray", "ersList", "headersL", "headerL", "driversList", "ersSet"], "iterator": ["vector", "sequence", "init", "set", "starter", "inner", "basic", "finder", "instance", "ter", "driver", "processor", "ie", "pointer", "gener", "loader", "walker", "writer", "done", "started", "later", "multi", "operator", "division", "next", "Iterator", "interstitial", "runner", "outer", "random", "Iter", "ator", "append", "li", "former", "size", "handler", "engine", "stream", "kick", "parser", "iter", "creator", "eni", "loop", "collection", "start", "step", "slice", "entry", "end", "reader", "inter", "oper", "ski", "adder"], "headersArray": ["filesAr", "headsList", "filesArray", "headsLength", "ersAr", " headersAr", "hersAr", "filesMap", " headersHash", "headsArray", "headersLength", " headersLength", "ersArray", "hersList", "ersMap", "hersArray", "filesHash", "headersHash", "ersHash", "hersLength", "headsAr", "headersAr"], "fields": ["FIELD", "types", "lines", "json", "field", "keys", "dates", "data", "errors", "format", "values", "params", "files", "zip", "body", "region", "prefix", "codes", "details", "Field", "properties", "dir", "comments", "pattern", "rows", "content"], "occiHeaders": ["occiBuilders", "occiBuilderers", "ocsiHeadlers", "ocsiBufflers", "occiHostlers", "occiBuffers", "ocsiHeaders", "occiHoster", "occiBuffer", "ocsiHeader", "ocsiBuffer", "occiBufflers", "occiHosterers", "occiHeader", "occiHeadlers", "occiHeaderers", "occiBuilder", "ocsiHeaderers", "ocsiBufferers", "occiBufferers", "occiHosters", "occiBuildlers", "ocsiBuffers"], "H": ["Hop", "F", "J", "HC", "L", "HT", "Header", "Length", "HR", "HS", "HTTP", "TH", "M", "I", "SH", "N", "B", "OH", "NH", "G", "W", "X", "C", "Index", "HH", "R", "DH", "HE", "HM", "T", "EH", "V", "ID", "HI", "K", "MH", "D", "Q", "Handler", "CH", "HB", "Y", "U", "S", "rh", "P", "Head"], "header": ["message", "bridge", "result", "buffer", "token", "Header", "feature", "cover", "inner", "frame", "f", "info", "back", "head", "ter", "event", "extra", "cher", "driver", "per", "ler", "ker", "manager", " request", "writer", "definition", "service", "consumer", "builder", "metadata", "later", "comment", "document", "outer", "server", "player", "dr", "string", "rule", "holder", "former", "detail", "handler", "layer", "second", "block", "value", "file", "request", "row", "key", "er", "response", "her", "entry", "reader", "liner", "http"], "statusLine": ["responseLine", "statusBody", "StatusLine", "statusFile", "StatusText", "StatusFile", "StatusString", " statusBody", " statusText", " statusString", "StatusCode", "responseFile", "responseText", "StatusBody", " statusFile", "errorLine", "statusString", "statusText", "errorCode", "errorBody", "responseCode", "errorString"], "httpResponse": ["Httpresponse", "httpresponse", "HttpEnvironment", "ttpResult", " httpPage", "HttpBlock", "statusBody", " httpEnvironment", "statusResponse", "httpResp", "HttpBody", "statusResult", "actualResponse", " httpResult", "httpsRequest", " httpBody", "actualresponse", "actualLine", "HttpLine", "httpBlock", "ttpResponse", "HttpStatus", " httpResp", "httpPage", "httpsPage", "httpsResponse", " httpStatus", "statusBlock", " httpRequest", " httpLine", "ttpResp", "httpResult", "HttpResponse", "templateResponse", "HttpPage", "httpRequest", "templateLine", "httpLine", "httpsEnvironment", "actualRequest", "httpStatus", "httpsBody", "httpEnvironment", " httpresponse", "HttpResp", "httpsResult", "HttpResult", "httpBody", "ttpRequest", "HttpRequest", "templateStatus", " httpBlock", "templateResp"], "statusCode": [" statusType", "StatusCount", "responseLine", " statuscode", "StatusLine", "errorType", "StatusType", "StatusData", "StatusText", "statusData", " StatusLine", " statusCount", "responseType", "StatusCode", "resultcode", "responseText", " StatusData", "statuscode", "errorText", "resultCode", "statusType", " StatusCode", "statusCount", "errorLine", "resultCount", " StatusType", "statusText", "resultLine", " statusData", "errorCode", "responseCode", "Statuscode"]}}
{"id1": "19849797", "id2": "414258", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", "copyfile", " copyfile", "transferfile", " copySource", "copyFiles", "clonefile", "copySource", "transferSource", "cloneFiles", "cloneFile", "cloneSource", "transferFiles", "transferFile"], "sourceFile": ["SourceFile", " sourceDir", "ourceFile", "SourceUrl", "ourceDirectory", "sourceDirectory", "sourceFolder", "srcDir", "Sourcefile", "srcfile", " sourceFolder", "ourceUrl", "sourcefile", "ourcefile", "destUrl", "destDirectory", "SourceFolder", "sourceUrl", "srcFolder", " sourcefile", "destfile", "SourceDirectory", "srcFile", "SourceDir", "sourceDir"], "destFile": [" destPoint", "DestPoint", "foreignFiles", "foreignFile", "resultLine", "sourcePoint", "destFiles", "DestDirectory", "targetPath", "targetDir", "destPoint", "srcDirectory", "srcDir", "srcFiles", "foreignPath", "srcLine", "destPath", "resultDir", "srcfile", "targetLine", "resultFile", "targetFiles", "resultfile", "DestFile", "destDir", "Destfile", " destDirectory", " destfile", "DestPath", "DestDir", "targetfile", "targetFile", " destFiles", "destDirectory", "sourceFiles", "foreignfile", "destfile", "srcFile", " destDir", "DestFiles", "destLine", "sourceDir"], "source": ["proxy", "component", "url", "uri", "unit", "resource", "image", "core", "server", "parent", "dest", "null", "scope", "view", "connection", "remote", "ce", "this", "si", "session", "ie", "channel", "output", "status", "Source", "result", "input", "site", "route", "storage", "index", "sin", "iter", "api", "src", "reader", "size", "client", "config", "stream", "target", "slave", "seed", "inner", "slice", "table", "object", "id", "cache", "ource", "file", "start", "service", "reference", "root", "SOURCE", "context", "get", "wrapper", "current", "secure", "scene", "manager", "use", "from"], "destination": ["domation", "distination", "generruction", "Destribution", "constination", "domination", "participinate", "identinated", "distion", "destinate", "Destation", "generinator", "constribution", "distruction", "destation", "destruction", "distinator", "Destinator", "distinated", "Destinate", "participinated", "generinated", "Destion", " destinated", "destion", "participinator", " destribution", "destribution", "identination", " destinator", "destinated", "Destination", " destation", "construction", "identinate", " destruction", "destinator", "Destinated", "Destruction", "dominator", "dominated", "generination", "constinator", " destion", "participination", "identinator"]}}
{"id1": "14473711", "id2": "11562165", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 0, "substitutes": {"str2md5": ["str2mdse", "str2MD512", "str_md512", "str2MDse", "str2MD5", "str2md512", "str2MD3", "str2h3", "str2h512", "str_md3", "str_mdse", "str2dig5", "str_MD512", "str_MDse", "str2md3", "str_MD5", "str2h5", "str2hse", "str_MD3", "str2dig512", "str_md5", "str2dig3", "str2digse"], "str": ["msg", "er", "f", "data", "name", "char", "s", "arr", "st", "kr", "p", "enc", "hex", "format", "br", "text", "inner", "txt", "bytes", "Str", "r", "cr", "err", "fr", "dr", "strings", "test", "buffer", "i", "source", "sp", "t", "spec", "url", "code", "pass", "empty", "STR", "in", "sr", "tr", "input", "result", "exp", "string", "obj", "dict"], "alga": ["Alja", "alqa", "ALja", "ala", "elda", "Alsa", "Algas", "ALgas", " alja", "ALga", " algas", "algas", "alsa", " alqa", "elga", "ALda", "alsqa", " ala", " alca", " alsa", "ela", "ALca", "elgas", "Alga", "alca", "ALqa", " alda", "alsca", "alsga", "alda", "ALsa", "alja", "ALa", "alsda"], "digesta": ["diffsta", "finesta", "badera", "digeste", "diffosta", "codsta", "diffesta", "fineste", "digsta", "badza", "badesta", "digosta", "codosta", "codeste", "finosta", "igosta", "diffeste", "igera", "igza", "igesta", "finsta", "digza", "badosta", "codera", "codza", "codesta", "digera"]}}
{"id1": "19934218", "id2": "5808579", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static final String encryptPassword(String loginName, String password) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(loginName.toUpperCase().getBytes(\"UTF-8\"));\n            md5.update(password.getBytes(\"UTF-8\"));\n            byte[] ba = md5.digest();\n            return byte2hex(ba);\n        } catch (Exception e) {\n            return password;\n        }\n    }\n", "label": 1, "substitutes": {"doCrypt": [" runExt", "DoCrypt", "DoMac", "DoDec", "DoExt", "murDec", " doMac", "murCrypt", "murExt", " runDec", " doDec", " runMac", " runCrypt", " doExt", "murMac"], "text": ["image", "letter", "in", " Text", "this", "hex", "content", "format", "input", "pattern", "message", "key", "password", "object", "struct", "url", "string", "txt", "class", "code", "font", "contract", "buffer", "crypt", "Text", "token", "path", "source", " TEXT", "secret", "length", "context", "name", "EXT", "ext", "word", "data", "binary", "seed", "str", "value", "connection", "config", "TEXT", "obj", "editor"], "UnsupportedEncodingException": ["UnsupportedEncodedEx", "UnsupportedEncasingException", "UnsupportedEncodedError", "UnsupportedEncodedException", "UnsupportedEncasingError", "UnsupportedEncasingEx", "UnsupportedEncodingEx", "UnsupportedEncoderEx", "UnsupportedEncoderError", "UnsupportedEncodingError", "UnsupportedEncoderException"], "md": ["dd", "body", "nm", "method", "sha", "cmd", "dr", "bm", "ud", "am", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "mad", "mode", "mo", "message", "ms", "ld", "wd", "mp", "vd", "hash", "code", "def", "mn", "d", "m", "mand", "bd", "ad", "pm", "df", "mt", "mg", "mac", "gd", "od", "sd", "me", " Md", "MD", "map", "Cmd", "mod", "data", "valid", "pd", "mag", "rm", "dm", "mc", "mb", "hm", "bf", "meta"], "sha1hash": ["shaonesha", "sha256h", "md1hash", "shaonehex", "SHA2hex", "sha256sha", "sha6h", "md1h", "SHA1hash", "sha5h", "sha1h", "SHA2hash", "md6h", "md1hex", "sha1sha", "shaonehash", "sha256Hash", "sha2sha", "sha256hash", "sha2sum", "SHA1h", "sha0hash", "SHA1sha", "sha5hash", "SHA1hex", "SHA1Hash", "sha2hex", "sha6hex", "sha6hash", "md6hash", "sha5hex", "SHA1sum", "md6hex", "sha2Hash", "sha5Hash", "sha0sum", "sha0sha", "SHA2Hash", "sha2hash", "sha0hex", "sha1hex", "sha2h", "shaoneh", "SHA2sha", "sha1sum", "sha1Hash", "sha256sum", "md6sha", "sha256hex", "sha5sha", "SHA2h", "sha6sha", "md1sha", "SHA2sum"]}}
{"id1": "23199071", "id2": "17996547", "code1": "            @Override\n            public InputStream getInputStream() {\n                try {\n                    String url = webBrowserObject.resourcePath;\n                    File file = Utils.getLocalFile(url);\n                    if (file != null) {\n                        url = webBrowserObject.getLocalFileURL(file);\n                    }\n                    url = url.substring(0, url.lastIndexOf('/')) + \"/\" + resource;\n                    return new URL(url).openStream();\n                } catch (Exception e) {\n                }\n                return null;\n            }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 0, "substitutes": {"getInputStream": ["getContentChannel", "getStreamChannel", "getReadChannel", "getStreamstream", "newContentStream", "getReadSteam", "newInputChannel", "getInputChannel", "getContentSteam", "getContentstream", "getStreamStream", "newInputSteam", "getReadstream", "newContentstream", "newInputStream", "getInputstream", "getReadStream", "getInputSteam", "newInputstream", "newContentSteam", "newContentChannel", "getStreamSteam", "getContentStream"], "url": ["string", "path", "base", "address", "remote", "i", "class", "id", "uri", "resource", "server", "feed", "buffer", "user", "http", "resources", "ref", "rel", "lr", "l", "location", "host", "URL", "html", "el", "fr", "in", "fl", "email", "type", "source", "rule", "jar", "dir", "q", "r", "str", "default", "ob", "build", "data", "route", "ssl", "cl", "web", "page", "ll", "bel", "log", "null", "href", "name", "coll", "image", "full", "link", "sl", "rl", "secure", "Url", "pull", "www", "ur", "left", "ul", "download", "f", "gl", "tool", "service", "api", "loc"], "file": ["play", "letter", "path", "info", "base", "class", "job", "fe", "zip", "id", "resource", "uri", "feed", "http", "plain", "place", "fp", "l", "child", "line", "File", "part", "source", "cache", "rule", "dir", "money", "lib", "live", "connection", "use", "model", "FILE", "work", "data", "route", "able", "page", "object", "local", "log", "name", "folder", "e", "image", "db", "full", "files", "unit", "b", "f", "loc"]}}
{"id1": "19810820", "id2": "8490297", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyFileStream", "copyfileChan", "transferfileChannel", "copyStreamStream", "copyfileStream", "copyDirectorychannel", "transferFileChan", "copyfilechannel", "copyStreamchannel", "copyStreamChan", "copyFilechannel", "copyDirectoryChannel", "transferfileChan", "copyFileChan", "copyStreamChannel", "transferfileStream", "copyDirectoryChan", "transferFileChannel", "transferfilechannel", "transferFileStream", "copyDirectoryStream", "transferFilechannel", "copyfileChannel"], "src": ["sc", "client", "sl", "sync", "upload", "ctx", "stream", "rc", "func", "s", "tmp", "sit", "slice", "rs", "input", "ls", "ses", "sin", "RC", "server", "sb", "conn", "loc", "source", "scene", "rb", "path", "cur", "inst", "ssl", "img", "dest", "sup", "Source", "dist", "config", "start", "sel", "url", "st", "rest", "download", "sq", "b", "SOURCE", "lower", "sub", "sth", "sys", "ruby", "filename"], "dst": ["bart", "Dost", "bput", "fdST", "stlt", "adrc", " dost", "lddest", "tart", "stst", "dost", "ddest", "dart", " dST", "bst", "fdput", "ldost", " ddest", "dST", "Ddest", "start", "brc", "tST", "Dst", "drc", "ldST", "tst", "dput", "adst", "blt", "tlt", "ldst", "stST", "dlt", "adST", "fdst", "fdrc", "bST", "adput", "DST"], "preserveModificationTime": ["preserveModifiedTime", "preserveModationtime", "preserveMinifiedTime", "preserveMinifiedtime", "preserveModificationFile", "preserveModifyingTime", "preserveMinificationFile", "preserveModifyTime", "preserveModationFile", "preserveModifyingtime", "preserveModifiedFile", "preserveModificationtime", "preserveModifyingFile", "preserveModifytime", "preserveModationTime", "preserveMinifiedFile", "preserveModifiedtime", "preserveMinificationTime", "preserveMinificationtime"], "inputChannel": ["imageGate", "Inputchannel", "imagechannel", " inputSocket", "errorChan", "InputBuffer", "InputSocket", "outputConsole", "InputChannel", "outputCode", "outputChan", "outputStream", "fileChannel", "outputSocket", "outputchannel", "binaryChannel", " inputConnection", "errorStream", " inputStream", "requestChannel", "binaryChan", "inputchannel", "outputCache", "errorCache", "inputConnection", "binaryGate", "requestStream", "requestChan", " inputQueue", "inputQueue", " inputCode", "inputChan", "imageChan", " inputConsole", "inputCode", "inputGate", "fileChan", "outputQueue", "inputBuffer", "requestCode", "fileConsole", "binarychannel", "imageChannel", "inputConsole", " inputBuffer", " inputchannel", " inputCache", "errorChannel", "InputQueue", "outputBuffer", "outputConnection", "inputCache", "inputStream", " inputChan", "outputGate", "fileConnection", "inputSocket", "InputChan"], "outputChannel": ["outStream", "Outputchannel", " outputchannel", "inputButton", "OutputStream", "outchannel", "outChan", " outputQueue", "writeManager", "outButton", "outputChan", "outputStream", "outputManager", "OutputQueue", "outputchannel", "writeChan", " outputStream", " outputChan", "inputChan", "inputManager", "writeQueue", "outChannel", "outputQueue", "writeChannel", "outputButton", "OutputChan", "writeStream", "OutputChannel", " outputButton", " outputManager", "inputStream"], "length": ["next", "position", "buffer", "max", "size", "block", "full", "current", "form", "load", "sequence", "slave", "delay", "section", "id", "limit", "complete", "child", "last", "result", "Length", "sum", "php", "pull", "value", "count", "available", "build", "len", "part", "end", "start", "base", "session", "type", "with", "partial", "offset", "number", "text", "width", "volume", "l", "style", "duration", "head", "lock", "join"], "total": ["toc", "error", "max", "size", "full", "all", "i", "key", "multi", "used", "id", "limit", "valid", "complete", "last", "info", "result", "sum", "found", "failed", "cur", "translation", "Total", "count", "available", "len", "start", "part", "no", "base", "set", "scale", "type", "partial", "offset", "done", "always", "otal", "duration", "current", "less"]}}
{"id1": "17557289", "id2": "13783549", "code1": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "source": ["resource", "temp", "use", "site", "Source", "input", "copy", "ource", "core", "path", "sc", "from", "slice", "this", "object", "unit", "connection", "base", "out", "server", "clone", "size", "sl", "link", "iter", "e", "SOURCE", "image", "start", "sin", "remote", "reader", "target", "id", "parent", "stream", "src", "name", "file"], "dest": ["folder", "dc", "temp", "done", "dat", "dist", "d", "src", "master", "destroy", "desc", "south", "die", "dir", "comb", "db", "orig", "tmp", "delete", "flat", "home", "Dest", "transfer", "test", "output", "data", "obj", "target", "null", " destination", "de", "wb", "dep", "later", "file", "end"], "srcChannel": ["srcChan", " srcStream", "srcConnection", "srcchannel", "distChan", "destChannel", "sourceContext", "srcButton", "destStream", "destchannel", "rcButton", "distConnection", "destConnection", "rcContext", "sourceButton", "rcChan", "srcStream", "destChan", " srcConnection", "srcContext", " srcContext", " srcButton", " srcChan", "sourcechannel", " srcchannel", "rcChannel", "rcchannel", "sourceChannel", "distStream", "rcConnection", "sourceChan", "sourceConnection", "distChannel"], "dstChannel": ["dstsChan", "dstContext", "ddestchannel", "dstStream", "ddestContext", "DdestChan", "dDestChan", "drcChan", "drcchannel", "drdContext", " dstStream", " dndStream", "DstChan", "drdChannel", "dutStream", " dstContext", "DdestChannel", " dndContext", "DstStream", "drdchannel", "drdChan", "dutchannel", "dutChannel", "dndChannel", "ddestChan", "ddestStream", "drcChannel", "ddstChannel", " dndchannel", " dstchannel", "dndchannel", "ddestChannel", "ddstchannel", "dDestchannel", "ddrdContext", "dstsChannel", "dDestChannel", "ddstChan", "dstChan", "dstsStream", "ddrdchannel", "ddrdChannel", "dndContext", "dstchannel", "Dstchannel", "DdestStream", "ddrdChan", "Ddestchannel", "drcContext", "dstschannel", "dndStream", "dutContext", "ddstContext", "dDestStream", "DstChannel", " dndChannel"]}}
{"id1": "20100809", "id2": "14502142", "code1": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["save", "get", "rm", "archive", "create", "remote", "type", "py", "change", "sync", "ge", "opy", "download", "move", "load", "dump", "part", "share", "zip", "clip", "cop", "patch", "paste", "map", "Copy", "process", "delete", "update", "transfer", "split", "clone", "replace", "cp", " cp", "write"], "srcPath": ["rcDir", "rcFile", "srcFile", "srcHalf", "sourcepath", "rcPath", "sourceDir", "destDir", "rcRoot", "srcpath", "destpath", " srcDir", " srcpath", "srcName", " srcRoot", "srcRoot", "sourceName", "rubypath", "destPath", "rubyPath", "rcHalf", "sourcePath", " srcFile", "rcpath", "rcName", " srcName", "destFile", "rubyRoot", " srcHalf", "sourceRoot", "rubyHalf", "sourceFile", "srcDir"], "dstPath": ["DstLocation", "drcPath", " drcPATH", "drestpath", "drestFile", "dndName", "fftPath", "DrcDir", "dstsName", "drcPATH", "dostPATH", "fstName", "dstsDirectory", "dstName", "dostDirectory", "dostHome", "drcHome", "dstHome", "sdstpath", "dftPath", "dsppath", "dstsDir", " dstHome", "dtdPATH", "Drcpath", "fstPath", "dndFile", "sdostRoot", "dtdpath", "dstsFile", "dspPath", "ddestpath", "dostPath", "dspFile", " dsppath", "dndPath", "sdostpath", "sdstRoot", "DstFile", "fftName", "dftpath", "dstPATH", "dstRoot", "drdFile", "dstsRoot", "drestHome", " drcHome", "dtdPath", " dstPATH", "dstspath", "dftFile", "dostRoot", "DrcUrl", "dstDirectory", "drcRoot", " dstFile", " dspHome", "drcLocation", "fftFile", "DrcLocation", "dstpath", "drestPath", "dstUrl", "dspHome", "ddestLocation", "DrcPath", "dstsLocation", " dstpath", "Dstpath", "dostpath", "dftName", "sdstDirectory", "fftpath", "sdstPath", "drdUrl", "DstDir", "dstDir", " drcPath", "dtdHome", " dspFile", "drcFile", "drcDir", "sdostDirectory", "sdostPath", "drcUrl", "dndUrl", "fstFile", "DstPath", "dstLocation", "dstsPath", "fstpath", "drdpath", "dndpath", " drcpath", "DrcFile", "drdPath", "drcDirectory", "dstFile", "drcpath", "ddestPath", " dspPath", "DstUrl", "ddestDir"], "result": ["feature", "rh", "df", "ure", "true", "force", "card", "master", "reason", "ack", "arr", "results", "event", "rc", "status", "match", "rule", "here", "successful", "ok", "success", "Result", "acc", "val", "err", "member", "dest", "rr", "found", "comment", "inc", "attr", "form", "particip", "sign", "pass", "make", "func", "rar", "valid", "res", "mate", "replace", "report", "start"], "files": ["pages", "f", "images", "data", "blocks", "sections", "ins", "balls", "events", "ips", "Files", "ls", "items", "cells", "models", "bytes", "features", "apps", "sheets", "tools", "lines", "strings", "assets", "objects", "filename", "books", "classes", "names", "boxes", "fields", "keys", "users", "plugins", "resources", "fs"], "file": ["le", "f", "data", "current", "name", "it", "File", "el", "info", "load", "fe", "letter", "per", "rule", "page", "part", "b", "content", "l", "line", "work", "e", "key", "source", "entry", "feed", "ile", "child", "path", "filename", "object", "url", "view", "uri", "unit", "route", "pe", "folder", "id", "queue", "input", "resource", "fp", "string", "use"], "in": ["reader", "bin", "connection", "login", "f", "get", "name", "into", "socket", "s", "ins", "pin", "m", "sync", "p", "cin", "info", "min", "In", "inside", "conn", "b", "inner", "again", "rin", "part", "win", "by", "din", "r", "l", "IN", "err", "work", "client", "pull", "ini", "call", "i", "source", "lib", "image", "init", "inc", "nin", "path", "url", "n", "pass", "server", "view", "thin", "inn", "c", "up", "as", "id", "a", "index", "on", "token", "input", "con", "diff", "ac", "re", "gin", "serv"], "out": ["connection", "bin", "extra", "ext", "name", "point", "manager", "channel", "socket", "pool", "sync", "to", "ex", "outs", "plain", "base", "conn", "b", "again", "output", "cache", "w", "inner", "part", "writer", "by", "serv", "err", "flow", "o", "off", "client", "OUT", "key", "plus", "i", "lib", "image", "inc", "ch", "cookie", "outer", "other", "url", "no", "n", "group", "server", "io", "net", "up", "word", "ou", "with", "home", "exp", "Out", "gin", "write"], "size": ["offset", "open", "loc", "data", "si", "sized", "scale", "name", "type", "send", "mode", "enc", "Size", "en", "shift", "time", "weight", "bytes", "content", "capacity", "shape", "export", "iz", "address", "flush", "ice", "seek", "count", "i", "pack", "clear", "path", "speed", "sec", "age", "order", "close", "sum", "eng", "number", "width", "transfer", "unit", "empty", "small", "code", "SIZE", "id", "len", "ize", "length", "write", "end", "now"], "buf": ["job", "bin", "cb", "bd", "seq", "data", "ha", "ff", "av", "batch", "BU", "buff", "cap", "Buffer", "rc", "feat", "b", "vec", "br", "bytes", "box", "r", "line", "bag", "la", "rb", "abi", "buffer", "cmp", "map", "uc", "cf", "ba", "cv", "uf", "cas", "coll", "bf", "fb", "bc", "pkg"]}}
{"id1": "160739", "id2": "20426057", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"createOutputStream": ["createOutputSteam", " createOutputSteam", " createInputSteam", " createIOSteam", " createByteFile", " createInputFile", "createOutputFile", "createInputReader", " createByteSteam", " createInputReader", " createByteStream", " createInputStream", "createInputFile", "createInputStream", " createIOFile", " createIOReader", " createByteReader", " createOutputFile", " createIOStream", "createOutputReader", " createOutputReader", "createInputSteam"], "inFile": ["incFiles", "infile", "insFile", "insfile", "inputFile", "inStream", "outFiles", "insFiles", "insStream", "incfile", "sourceFile", "outStream", "outfile", "sourcefile", "inputStream", "inputfile", "incStream", "incFile", "sourceFiles", "inputFiles", "inFiles", "sourceStream"], "outFile": [" outfile", "infile", "outTime", "workTime", "inputFile", "inTime", "workingStream", "workFile", "outDir", "targetStream", "workfile", "workingDirectory", "workingfile", "outStream", "outfile", "inDir", " outStream", "targetfile", "outDirectory", "targetFile", "workDir", "inputDir", "workingFile", "targetDirectory", "inputTime", "inputfile", " outDirectory"], "k_blockSize": ["k_byteCode", "k_byteLength", "k_lockCode", "k_lockLen", "k_bitCount", "k_BlockLength", "k_lockLength", "k_blockCode", "k_blockLen", "k_BlockSize", "k_BlockCount", "k_lineCount", "k_lockCount", "k_lineInfo", "k_lockSize", "k_blocksLen", "k_blocksSize", "k_blocksCount", "k_blockInfo", "k_lineSize", "k_blocksLength", "k_BlockCode", "k_byteLen", "k_byteSize", "k_blockCount", "k_blockLength", "k_byteInfo", "k_bitInfo", "k_byteCount", "k_bitSize"], "byteCount": ["ByteSum", " bytecount", "characterLength", " byteSize", "blockSize", " byteLen", "Bytecount", "characterLen", "ByteSize", "ByteLen", "flushcount", "flushCount", "byteSum", " byteSum", "ByteCount", "blockSum", "flushSize", "byteLen", "blockCount", "characterCount", "ByteLength", "flushLength", "byteLength", " byteLength", "blockLength", "bytecount", "characterSize", "byteSize"], "buf": ["fd", "border", "font", "cap", "cv", "uf", "append", "background", "b", "cmd", "loc", "rc", "fb", "data", "bh", "Buffer", "result", "bag", "rb", "batch", "feed", "bytes", "Buff", "cb", "cas", "alloc", "bf", "flush", "src", "config", "tmp", "buff", "len", "base", "queue", "la", "ucc", "vec", "brace", "ctx", "buffer", "exc", "seq", "feat", "img"], "ofp": ["Ofc", "afp", "OFl", "ofc", "fortp", "ofl", "forc", "afc", "fort", "ofnp", "afnp", "OFnp", "Oftp", "OFt", "Ofnp", "afl", "OFtp", "OFp", "OFc", "oft", "Ofl", "forp", "Ofp", "oftp", "Oft"], "zos": ["rons", "ogl", "kos", "core", "zh", "tz", "osi", "iframe", "owicz", "zag", "zers", "rez", "outs", "los", "gz", "zer", "bitcoin", "dylib", "webkit", "zon", "utils", "bs", "ros", "js", "z", "fits", "iffs", "obs", "ossus", "enos", "ozo", "zona", "zip", "bos", "zes", "oses", "zik", "lol", "bes", "zar", "zb", "ZI", "zx", "oda", "zy", "ops", "zi", "budget", "inos", "css", "ls", "zyk", "modules", "zo", "zen", "ses", "nox", "zig", "cfg", "ZA", "os", "jas", "uz", "zn", "nz", "cos", "robe", "liquid", "lins", "zin", "ws", "oS", "abi", "zl", "hz", "za", "forge", "packs", "obb", "soon"], "osw": ["ossnow", "isy", "osy", "esfw", "issw", "lsx", "eshell", "osws", "osow", "osswd", "oswd", "ishell", "lswo", " osfw", "iswd", "isw", "osshell", "osx", "lsws", "osnow", "osfw", "ossw", "isnow", "esw", " osww", "esd", "bx", "ossfw", "bws", "osww", "bwo", "ossd", "ossy", "oswo", "esow", " osow", "oshell", "isd", "bsws", "ossow", "osssw", "essw", "esww", "eswd", "esy", "osd", "bsx", "bsw", "bswo", "ossww", "esnow", "lsw"], "bw": ["bbz", "lbw", " bwa", "lx", "ebW", "fr", "fbW", "bz", "fsw", "lbz", "bwe", "ebwd", " bws", "bW", "ebw", "fbwe", "Bws", "bbwa", "Bw", "lbwa", "bew", "abw", "bbew", " baw", "abW", "Bwa", "bbwu", "lbsw", "ow", "fwa", "bwh", "fbw", "owa", " bwh", "abwe", "ebwe", "bx", "lbx", "bws", "fbwd", "Bew", "fx", " bew", "fw", "lbwh", "bwu", "owu", "fwh", "baw", "lwa", "bbws", "abwd", "bwa", "bbwh", "lbws", " bwu", "lw", "bwd", "bsw", "oaw", "lbr", "bbw", "bbaw", " bz", "lsw"], "zot": ["Zor", "zor", "jot", "Ziot", "zori", " zor", "azita", "azott", "zeros", "aziot", "ziot", "Zit", "jos", "jit", "zerott", "jori", "azor", "zerita", " zori", "zita", "zerori", "zott", "zerit", "Zita", "zerot", "azit", "Zot", "Zott", " ziot", "azot"], "ifp": ["Iff", "ifb", " ifi", "ipb", "IFb", "Ifi", " ifl", "ipp", "Ifc", " ifb", "ifl", "ipc", "ipl", "ifc", "ifi", "iff", "IFc", "IFl", " ifc", " iff", "IFi", "Ifp", "IFp", "IFf"], "zis": ["jits", "zisi", "jisi", "zIS", "zib", "xits", "zipis", "xais", "xit", " zits", "ziss", "xis", "zipits", "zenis", "zenib", "zeip", "zipip", "zipiss", "xisi", "zip", "Ziss", "zeits", "Zis", "jit", "xIS", "zeis", " zisi", "zits", "zenIS", "Zip", " zais", " zIS", "zais", "Zits", "zenais", " zib", "jis", "zeiss", "xib"], "isr": ["IScr", "irrb", "irrc", "irr", "ISr", "rispr", " issr", "ISsr", "risr", "ISrs", "risrc", "issrs", " isrs", "iscr", "ISrb", "risrb", "isrs", "irpr", " iscr", "ISrc", "isrb", "ISpr", "isssr", "isscr", "ispr", "issr", "isrc"], "br": ["kr", "obl", "bsp", "bro", "fr", "arr", "shr", "b", "body", "mr", "rs", "yr", "bh", "bp", "bc", "obi", "str", "HR", "cro", "rb", "ch", " BR", " Br", "BR", "rib", "lr", "ber", "bar", "tr", "r", "ctr", "div", "err", "ocr", " fr", " dr", "sr", "ibl", "gr", "ob", "sp", "hr", "bl", "Br", "ibr", "img", "browser"], "zit": ["jits", "zipita", "zIT", "zeith", "zenith", " zip", "xit", "zenitter", " zits", "zipits", "zitter", "jith", "jite", "xith", "jIT", "zipip", "zic", "zip", "xic", "zeits", " zi", "zipit", " zith", "jit", "zite", "jic", "zipith", "zenit", "zith", "ji", "zits", " zic", "zipite", "zeit", "zita", "zenits", "xi", "jita", " zite", "zipitter", "jip", "zi", "zeIT", "zipIT", "zeitter", "zeita"]}}
{"id1": "13499897", "id2": "8150996", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"CopyFile": ["CreateFolder", " CopyDir", "CopyFolder", "CreateFile", "Createfile", " copyFile", " CopyFolder", " copyDir", "CreateDir", " copyfile", "Copyfile", "CopyDir", " copyFolder", " Copyfile"], "sourcefile": ["destfilename", "configlog", "destFile", "deststream", " sourceFile", "configstream", "sinstream", "configFile", "sinFile", "sourcefilename", "Sourcefilename", "sourceFile", "SourceFile", "configfile", "sinlog", "Sourcef", "sourcestream", "Sourcefile", " sourcefilename", "sourcelog", "sinfile", "destf", " sourcef", "sourcef", "destlog"], "destfile": ["destfilename", "sourcestring", "tempFile", "destFile", "DestFile", "targetfilename", "tempfile", "buildfile", "srcfilename", "srcpath", "destroypath", "Destfilename", " desturl", "newfp", "desturl", "tempfilename", "destfp", "targeturl", "deststream", "newfilename", "Destpath", "tempstream", " deststring", "destroyfile", " destFile", "Desturl", "newfile", "buildstring", "srcstream", "deststring", "sourcefilename", "sourceFile", "targetfile", " destpath", "targetFile", "temppath", "destroystream", " destfp", "newFile", "destroyfilename", "Destfp", "srcfile", "destpath", "srcFile", "buildFile", "Destfile", "buildfilename", "targetpath", "sourcepath", " destfilename"], "last": ["nd", "right", "base", "child", "end", "depth", "offset", "latest", "current", "event", "cur", "count", "total", "key", "use", "later", "full", "cat", "after", "left", "style", "code", "from", "route", "core", "path", "next", "recent", "part", "Last", "se", "real", "prev", "first", "ending", "length", "size", "start", "range", "value", "empty", "old", "or", " Last", "max", "ast"], "parent": ["unit", "base", "child", "temp", "section", "point", "root", "fat", "current", "content", "po", "function", "patch", "target", "anc", "exp", "text", "cache", "filename", "key", "remote", "api", "post", "Parent", "home", "string", "null", "pa", "path", "next", "ant", "p", "line", "parents", "part", "pointer", "and", "dest", "mac", "ip", "name", "location", "test", "ac", "search", "data", "file", "id", "valid", "port", "shared", "partial", "loc", "source", "url", "ppa"], "f": ["folder", "j", "base", "o", "feed", "of", "found", "self", "fa", "inf", "lf", "F", "fe", "ref", "fc", "l", "b", "full", "c", "cf", "r", "g", "fd", "t", "d", "fb", "p", "v", "df", "flat", "fp", "fs", "dir", "h", "file", "af", "e", "sf", "i", "m", "s"], "srcChannel": ["srcchannel", " srcConnection", "destchannel", "rcClient", "destChannel", "rcChan", "destConnection", " srcChan", "rcchannel", "sourcechannel", "rcChannel", "srcChan", " srcchannel", "sourceChan", " srcClient", "sourceConnection", "sourceChannel", "destClient", "destChan", "srcClient", "rcConnection", "srcConnection"], "dstChannel": ["drcChannel", "idrcButton", "DstContext", "idstchannel", "DstChannel", "DestChan", "dstschannel", "destchannel", "DstChan", "drcChan", "DestContext", "dstsChan", "idstChan", "ddestContext", "dstButton", "DstBuffer", "destChannel", "dstBuffer", "Dstchannel", "dntChan", "ddestBuffer", "DestBuffer", "idrcChan", "idrcChannel", "dntBuffer", "dstchannel", "destBuffer", "dstsChannel", "drcButton", "idrcchannel", "destContext", "idstChannel", "dsrcChan", "dntContext", "dstChan", "ddestChannel", "destButton", "idstButton", "ddestChan", "drcchannel", "dsrcChannel", "destChan", "dsrcButton", "dsrcchannel", "Destchannel", "DestChannel", "dstContext", "dntChannel"]}}
{"id1": "1180878", "id2": "22993368", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchUrldata", "fetchUrlDATA", "fetchHTTPDATA", "fetchHTTPdata", "fetchUrlData", "frieveURLdata", "frieveUrlData", "frieveUrlDATA", "fetchURLdata", "fetchJSONData", "fetchURLDATA", "fetchJSONDATA", "fetchHTTPData", "fetchJSONdata", "frieveURLData", "frieveUrldata", "frieveURLDATA"], "url": ["resource", "username", "string", "host", "href", "view", "http", "xml", "www", "URL", "path", "ur", "api", "feed", "gl", "Url", "download", "user", "address", "loc", "l", "connection", "base", "ls", "server", "location", "sl", "f", "filename", "image", "el", "page", "html", "ssl", "data", "fl", "uri", "source", "text", "src", "name", "file"], "proxyHost": ["ProxyDomain", "Proxyhost", "ProxyServer", " proxyAddress", "cachehost", "proxyHead", "ProxyAddress", "baseHead", "baseHost", " proxyPath", "serverHost", "proxyAddress", "proxyDomain", "ProxyPort", "serverServer", "serverPath", "proxyServer", "baseDomain", "remoteHead", "serverAddress", "cacheHost", "ProxyHead", "ProxyHost", "remoteHost", "baseAddress", " proxyhost", "cachePort", "remoteDomain", "remoteAddress", "cacheAddress", " proxyServer", "proxyPath", "ProxyPath", "proxyhost"], "proxyPort": [" proxyport", "ProxyServer", " proxyAddress", "ProxyAddress", "proxyport", "proxyAddress", "Proxyport", "httpServer", "ProxyPort", "httpPort", "httpHost", "proxyServer", "cacheHost", "ProxyHost", "cachePort", "cacheport", "cacheAddress", "httpAddress", " proxyServer"], "con": ["ch", "ctrl", "pc", "ca", "http", "ci", "can", "out", "fac", "don", "pub", "socket", "gen", "ai", "fl", "ec", "ver", "fa", "an", "c", "cache", "rec", "cone", "fun", "xc", "pin", "cc", "cl", "connection", "mc", "win", "cn", "cp", "ocon", "cur", "x", "per", "pre", "login", "en", "conf", "sub", "connect", "re", "cm", "n", "act", "go", "conv", "open", "co", "sync", "cf", "ac", "min", "cr", "part", "rc", "ls", "f", "Con", "uc", "fan", "com", "run", "fc", "cas", "cons", "func", "canon", "ran", "conn", "on", "exec", "syn", "bc", "CON", "close", "remote", "change", "inc", "pen", "un", "common"], "is": ["ib", "il", "ics", "or", "js", "us", "si", "isa", "ios", "im", "serv", "bs", "isl", "act", "ir", "was", "state", "iris", "oss", "has", "as", "ci", "api", "can", "ais", "os", "IS", "abs", "cms", "in", "ri", "conn", "are", "does", "ie", "it", "p", "fs", "isin", "s", "Is", "out", "vs", "iss", "iso", "ar", "get", "sp", "ops", "cos", "its", "ws", "cs", "isi", "isc", "i", "ori", "bis", "mis", "lis", "ai", "isu", "ps", "id", "es", "info", "ris"], "u": ["iu", "us", "uci", "c", "ru", "m", "o", "http", "U", "ur", "io", "api", "os", "yu", "ue", "ui", "uv", "cu", "user", "conn", "p", "up", "l", "ut", "f", "fu", "su", "i", "q", "ul", "h", "uc", "hu", "file", "v", "ou", "tu", "b", "uri", "nu", "client", "lu", "un"], "proxy": ["resource", "timeout", "fe", "pc", "cop", "plus", "shadow", "ip", "zip", "c", "cache", "host", "http", "roxy", "pse", "copy", "api", "phone", "force", "pin", "xy", "address", " proxies", "p", "l", "connection", "pe", "pa", "port", "server", "Proxy", "clone", "x", "config", "bean", "pool", "f", "wrapper", " Proxy", "lib", "socket", "remote", "ssl", "type", "web", "XY", "uri", "prot", "client", "create"], "baos": ["abis", "caOS", "aas", "caos", "boas", "paOS", "abos", "bao", "Baros", "bolos", "bais", "baas", "balos", "paos", "baOs", "BAOs", "alos", "pais", "aos", "Bais", "BAis", "calos", "boos", "haOS", "Baos", "baOS", "baros", "caas", "hais", "aOS", "BAos", "haos", "hao", "BAOS", "BAros", "abros", "BaOs", "pao", "boOS", "abOs", "BAo"]}}
{"id1": "5951610", "id2": "10728243", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": ["testNETSSL", " testNetworkHTML", " testNetworkHttp", "testnetworkSSL", "testNetworkHTML", "testInternetSSL", " testNetworkSSL", " testInternetHTML", "testnetworkHTML", "testNETHTTP", "testInternetHTML", "testInternetHttp", " testInternetSSL", " testInternetHTTP", "testNETHTML", "testNetworkSSL", "testnetworkHTTP", "testnetworkHttp", "testNetworkHttp", " testInternetHttp", "testInternetHTTP", "testNETHttp"], "url": ["URL", "resource", "lr", "www", "impl", "ls", "channel", "group", "page", "job", "control", "layer", "ur", "file", "ll", "call", "el", "lib", "connection", "host", "lc", "log", "service", "cl", "output", "github", "r", "ml", "build", "pull", "il", "loader", "tool", "server", "user", "rl", "dl", "loc", "base", "email", "event", "bl", "entry", "text", "use", "l", "shell", "update", "left", "hl", "path", "large", "blog", "util", "ssl", "ol", "rel", "location", "web", "image", "mail", "feed", "nl", "view", "coll", "ul", "Url", "http", "load", "key", "buffer", "cloud", "pl", "fl", "org", "uri", "gl", "ob", "sl", "bf", "config"], "urlConnection": ["URLConnect", "urConnection", "urlReference", "implReference", "sslUnit", "viewconnection", "httpFactory", "emailconnection", " urlContainer", "uriUnit", "urlFactory", "urlConstruction", "uriComputer", "emailConstruction", "urlConn", " urlPool", "webconnection", "lConnect", " urlconnection", "flconnection", "htmlConstruction", "sslConnector", "termConnection", "UrlContainer", "serviceConn", "numberconnection", "numberConnector", "viewConstruction", "urlComputer", "URLConn", "flConstruction", "glConn", "webConnection", "numberConnect", "glConnect", "lConn", " urlEnvironment", "ulUnit", "serviceConnect", "flConnection", "UrlFunction", " urlUnit", "urlconnection", "httpFunction", "httpComputer", "resourceGate", "implEnvironment", "urFactory", "urlGate", "blogconnection", "uriFunction", "termComputer", "urlContainer", "lengthConnection", "emailClient", " urlReference", "UrlConnection", "numberConnection", "ulConnector", "viewConnect", "UrlConnect", "urlEnvironment", "sslConn", "urConn", "termConn", " urlFactory", "blogConnection", "serviceConnection", "emailConnect", "urFunction", "uriConnection", "emailConnection", "UrlReference", "urlFunction", "urlConnector", "urlClient", "blogConnector", "UrlConn", "implConnection", "lConnection", "lengthConnect", "urlConnect", "htmlConnection", "UrlEnvironment", "lengthconnection", " urlComputer", "webPool", "urlUnit", "emailGate", "lengthConstruction", "glConnection", "resourceClient", "lconnection", "ulConn", " urlClient", "URLConnection", "resourceConnection", "httpConnection", "flConnect", "resourceconnection", "htmlconnection", " urlGate", "glFunction", " urlConnector", "URLPool", "URLconnection", "blogConnect", "UrlComputer", "viewConnection", "flConnector", "urlPool", " urlConn", "httpConn", " urlFunction", " urlConnect", "httpUnit", "termContainer", "sslConnection", "ulConnection", "serviceconnection"], "rd": ["dd", "td", "nd", "dr", "lr", "fr", "rx", " reader", "nor", "rowd", "nl", "dig", "lf", "bl", "arr", "rid", "DR", "xd", "rt", "RD", "RR", "adr", "ld", "ird", "wd", "RW", "respond", "rod", "vd", "rg", "usr", "rf", "r", "RL", "RF", "fd", "wr", "tr", "d", "rob", "bd", "erd", "ds", "rand", "bf", "red", "rr", "addr", "rh", "director", "dj", "gd", "std", "own", "rs", "hr", "rown", "sr", "R", "lt", "dh", "pd", "rn", "sth", "Reader", "reader", "rb", "rw", "rl", "ng", "ru", "rss", "db", "dra"], "line": ["lc", "link", "log", "letter", "unit", "login", "end", "nl", "val", "lf", "cl", "write", "lines", "entry", "inline", "skip", "LINE", "day", "ne", "Line", "key", "l", "ld", "page", "string", "code", "status", "pass", "d", "li", "part", "len", "frame", "row", "response", "number", "le", "block", "name", "la", "col", "word", "sel", "ge", "msg", "data", "id", "lo", "cell", "user", "limit", "file", "el", "sl", "rl", "error", "comment", "loc", "source", "lin"]}}
{"id1": "1769771", "id2": "3187685", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyChannel", "copyFiles", "copyfile", "transferChannel", "transferFile", " copyChannel", "transferFiles", "CopyChannel", "CopyFile", "Copyfile"], "in": ["image", "m", "pin", "query", "inn", "i", "input", "id", "ex", "diff", "lin", "inner", "index", "io", "work", "file", "min", "f", "url", "base", "login", "data", "ins", "name", "bin", "In", "l", "reader", "IN", "again", "lock", "win", "source", "config", "c", "inc"], "out": ["Out", "plain", "image", "writer", "p", "off", "n", "up", "output", "default", "user", "write", "ex", "server", "cache", "conn", "target", "ext", "resource", "io", "file", "x", "dot", "o", "prefix", "base", "exec", "b", "v", "w", "call", "name", "again", "string", "point", "outs", "extra", "external", "OUT", "c"], "inChannel": [" inClient", "inClient", "insClient", "insStream", "outStream", "binClient", " inchannel", "inchannel", "inputChannel", "INStream", "INChan", "outchannel", "outChan", "binChannel", " inChan", "InClient", "InStream", "winchannel", "inputchannel", "binchannel", "INChannel", "InChan", "inputChan", "inChan", "binChan", " inStream", "InChannel", "winChannel", "winStream", "Inchannel", "insChan", "INchannel", "winChan", "insChannel", "outClient", "inputStream", "binStream", "inStream"], "outChannel": ["inputController", "outStream", " outchannel", "inputChannel", " outCh", "inchannel", "nChannel", "OutChan", "outchannel", "outChan", "outputController", "outCh", "inCh", "OutChannel", "outController", "outputChan", "outputStream", "OutConnection", "outputchannel", "nChan", "inputchannel", "outputCh", " outChan", "outputChannel", "nStream", " outConnection", " outStream", "inputChan", "inChan", "outConnection", " outManager", "inConnection", "nManager", "outManager", "inManager", "Outchannel", "inController", "inStream"]}}
{"id1": "2518655", "id2": "10715601", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"fnOut": ["fnEx", "FNOutput", "fpIn", "fpOut", "FNOut", "fpOUT", "FNIn", "fnOUT", "fpFile", " fnIn", "fpOutput", "lsFile", "fpEx", " fnOUT", "lsOutput", "lsOut", "fnFile", " fnOutput", "FNEx", " fnFile", "fnOutput", "lsOUT", " fnEx", "fnIn"], "writer": ["temp", "riter", "usher", "entry", "writ", "war", "nw", "writers", "word", "inner", "ler", "winner", "walker", "layer", "outer", "fd", "Writer", "wa", "key", "driver", "er", "handler", "wire", "w", "out", "server", "work", "loader", "ws", "per", "director", "worker", "a", "editor", "widget", "wr", "socket", "reader", "output", "writing", "write", "r", "parser", "buffer", "builder", "file"], "i": ["iu", "hi", "si", "chi", "qi", "ip", "u", "multi", "n", "ii", "c", "k", "pi", "m", "o", "ini", "abi", "ci", "di", "io", "z", "key", "ji", "ui", "ri", "bi", "ie", "p", "strength", "part", "phi", "s", "j", "I", "fi", "x", "eni", "index", "f", "e", "oi", "li", "ori", "h", "v", "gi", "ti", "type", "mi", "ai", "b", "xi", "id", "uri", "ix"], "fInput": ["sfInput", "sfFormat", "fOutput", "finput", "fSource", " fSource", "sfOutput", "sfSource", " finput", "fileInput", "fFormat", "fileOutput", "sfinput", "fileSource", " fFormat", "fileFormat", " fOutput", "fileinput"], "in": ["In", "inas", "line", "scan", "again", "ini", "c", "n", "IN", "cin", "reading", "din", "inner", "bin", "input", "ner", "pin", "ins", "min", "conn", "inn", "kin", "isin", "init", "s", "rin", "lin", "out", "connection", "win", "gin", "f", "inside", "nin", "socket", "sin", "login", "reader", "data", "vin", "b", "inc", "id", "ln", "version"]}}
{"id1": "237493", "id2": "19134229", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["ur", "uri", "ssl", "resource", "ll", "server", "image", "fr", "null", "html", "connection", "loc", "io", "link", "f", "www", "URL", "ref", "href", "bel", "el", "xml", "source", "config", "rl", "filename", "l", "lr", "base", "id", "address", "string", "file", "name", "loader", "service", "ob", "sl", "host", "location", "Url", "path", "buffer", "http", "feed"], "in": ["m", "ex", "ins", "ssl", "resource", "image", "In", "n", "init", "io", "data", "this", "socket", "inc", "part", "f", "gin", "impl", "input", "din", "IN", "inn", "val", "out", "conn", "xml", "i", "is", "source", "rin", "reader", "config", "cms", "inside", "a", "nin", "login", "inner", "min", "r", "id", "token", "con", "file", "err", "c", "bin", "pin", "ini", "as", "or", "again", "serv", "isin"]}}
{"id1": "22057083", "id2": "22410173", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"Connect": ["Build", "New", "connect", "Conn", " Close", "Close", "Setup", "Host", "Init", "Sync", "Socket", "Construct", "Fail", "Login", "Run", "Open", "connected", "Client", "Subscribe", "Load", " Connection", "Create", "Config", "Remote", "Connection", "Connector", "Process", "Dial"], "client": ["request", "get", "clean", "ace", "connect", "service", "console", "cp", "host", "ce", "cell", "socket", "cn", "proxy", "cc", "default", "user", "parent", "cli", "ci", "core", "port", "server", "cache", "handler", "per", "conn", "open", "child", "connection", "code", "http", "resource", "cm", "pool", "ssl", "manager", "con", "secure", "cloud", "end", "util", "Client", "close", "grid", "lib", "api", "channel", "session", "local", "cl", "force", "pc", "call", "name", "co", "plugin", "friend", "remote", "project", "cod", "command", "config", "c"], "reply": ["request", "next", "error", "echo", " replies", "buffer", "ping", "ply", "sync", "query", "comment", "rc", "Reply", "address", "replace", "answer", "info", "result", "state", "connection", " response", "code", "response", "reason", "message", "ret", "send", "resp", "part", "post", "link", "prefix", "err", "status", "bot", "continue", "call", "respond", "related", "read", "dy", "repl"]}}
{"id1": "23611770", "id2": "20924119", "code1": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"handle": [" post", " transport", " abort", "Handle", " process", " reload", " append", " redirect", " handles", " rewrite", " execute", " handler", " fn", " shutdown", " rename", " transform", " serve", " manage", "process", "transfer", " upload", " perform", " loop", " work", " restart", " next", " transfer", " operate"], "srcChannel": ["rcClient", "sourceChan", "rcConnection", "destClient", "sourceClient", " srcchannel", "destChan", "sourceChannel", "rcChan", "sourceConnection", " srcConnection", "srcClient", "srcChan", "sourcechannel", "srcchannel", "rcChannel", "destchannel", " srcClient", "srcConnection", " srcChan"], "destChannel": ["DestStream", "srcSocket", "sourceChan", " destHandler", " destSocket", " destStream", "Destchannel", "destStream", "DestCan", "descCan", "distStream", "distChannel", "destChan", "sourceChannel", "distChan", "DestChannel", "destCan", "descHandler", " destchannel", "srcChan", "destSocket", "DestHandler", " destChan", " destCan", "descChan", "destHandler", "sourceSocket", "distchannel", "destchannel", "descChannel", "DestChan"], "destOutFile": ["destPathfile", "destPointFile", "DestInFile", "destOutputFile", "tempOutSite", "destTemplatefile", "destOutSite", "destOutputSite", "destInDir", "DestInDirectory", "destInDirectory", "destoutDir", "destoutCode", " destOutfile", "destLogFilename", "tempOutDir", "DestInFiles", "destoutFiles", " destOutPath", "destPathFile", "DestOutfile", "destPathFiles", "destOutfile", "featOutFile", "featTemplatefile", "destActionfile", "destPointDir", " destOutputPath", "destOutDir", "destOUTCode", "destInFile", "featTemplateFiles", " destOutputFile", "DestInFilename", "featTemplateFile", "destInPath", " destPathFiles", " destOutputFilename", "destOUTSite", " destOutDir", "featOutFiles", "destOUTFile", " destOutputFiles", "destOutFiles", "destPathDir", "destOUTFiles", " destPathDir", "featOutDir", "destOUTDir", "tempOutFiles", "destOutputfile", "DestOutDirectory", "destLogFiles", "destOutputPath", "destInfile", "DestOutFile", "DestOutCode", "tempOutputFiles", "DestInCode", "tempOutputDir", "DestOutFiles", "DestOutFilename", "destInCode", "destOutputDirectory", "DestInfile", "destActionFile", "destInSite", " destOutFilename", "destInFiles", "destOutCode", " destPathFile", "destoutFile", "tempOutFile", " destPathfile", "destLogFile", "tempOutputSite", "destPointFilename", "DestInDir", "destTemplateFile", "destOutputDir", "destOutFilename", "destLogPath", "featTemplateDir", "destActionDir", "featOutfile", "destPointDirectory", "destTemplateDir", "destOutputFiles", "destInFilename", "destOutPath", "tempOutputFile", "destTemplateFiles", " destOutFiles", "destActionFiles", "destOutputFilename", "DestOutDir", "destOutDirectory"], "destOutFileCompressed": ["destOutFileSupression", "destOutFilesExported", "destOutFilesCompacted", "destOutFilesCompressor", "destOutFileExressor", "destOutLineCompressor", "destOutLineExpressed", "destOutFileEncressed", "destOutFilesComposed", "destOutLineExpression", "destOutFileExressed", "destOutFileExposed", "destOutFileSuppressed", "destOutFileExplied", "destOutLineCompacted", "destOutFilesExplied", "destOutFileExpression", "destOutFilesExpress", "destOutFileRepressed", "destOutLineRepressor", "destOutFileExpressed", "destOutLineCompress", "destOutFilecompressed", "destOutFileSuposed", "destOutFileExress", "destOutLineRepressed", "destOutLineRepression", "destOutFileSupressed", "destOutFilesCompression", "destOutFilesComplied", "destOutFileRepression", "destOutFilesExposed", "destOutFileExacted", "destOutFileSuppressor", "destOutLineRepacted", "destOutFileExpacted", "destOutFileComposed", "destOutFilecompression", "destOutFileEncorted", "destOutFileSuppacted", "destOutFileCompress", "destOutFileExosed", "destOutFileExpress", "destOutFileComplied", "destOutFileReposed", "destOutFilesCompressed", "destOutFileExported", "destOutFilecompress", "destOutFileEncress", "destOutFileSupress", "destOutLineExpressor", "destOutFilesCompress", "destOutLineExposed", "destOutLineRepress", "destOutLineCompression", "destOutFileCompression", "destOutFilesExpression", "destOutFileRepressor", "destOutFilesExpressed", "destOutFileCompacted", "destOutFilesExpressor", "destOutFileExorted", "destOutLineCompressed", "destOutFilesComported", "destOutLineComposed", "destOutFileReplied", "destOutFilesExpacted", "destOutFileComported", "destOutFileSuppress", "destOutFilecompacted", "destOutFilecompressor", "destOutFileRepacted", "destOutFileExpressor", "destOutFileRepress", "destOutFileCompressor", "destOutFileEncosed"], "out": ["full", "lock", "bin", "connection", "extra", "ext", "data", "doc", "name", "self", "socket", "error", "sync", "to", "ex", "outs", "one", "plain", "log", "copy", "conn", "w", "b", "output", "user", "again", "inner", "img", "part", "cache", "line", "writer", "cmd", "err", "o", "flush", "client", "OUT", "temp", "this", "key", "source", "image", "inc", "outer", "exec", "parent", "n", "conv", "post", "null", "io", "net", "server", "up", "file", "co", "resource", "exp", "Out", "obj"], "in": ["reader", "bin", "connection", "isin", "sin", "f", "login", "into", "data", "socket", "ins", "pin", "to", "cin", "min", "In", "log", "is", "part", "b", "inner", "again", "rin", "conn", "img", "win", "din", "l", "r", "IN", "err", "o", "pull", "ini", "source", "init", "image", "inc", "nin", "h", "config", "pass", "inn", "c", "up", "wave", "id", "file", "a", "lin", "token", "input", "con", "diff", "resource", "ac", "gin", "serv"], "buf": ["job", "cur", "cb", "bd", "seq", "data", "loc", "ff", "batch", "pool", "buff", "info", "Buffer", "cap", "bh", "rc", "log", "bl", "feat", "bb", "lc", "base", "b", "vec", "br", "num", "bytes", "box", "text", "val", "bag", "off", "la", "rb", "buffer", "block", "map", "ctx", "port", "uc", "lb", "path", "v", "context", "config", "cv", "func", "wb", "wave", "file", "pos", "src", "uf", "cas", "queue", "header", "bf", " buffer", "input", "ref", "pad", "result", "fb", "bc"], "len": ["nt", "lock", "le", "sl", "iter", "f", "data", "loc", "fl", "lim", "el", "rev", "body", "cap", "min", "en", "ind", " length", "ie", "ll", "lc", "part", "size", "num", "l", "line", "val", "pre", " lang", "lf", "la", "count", "limit", "url", "no", "li", "n", "led", "id", "pos", "lin", "fin", "Len", "length", "ln", "ler", "end"]}}
{"id1": "18793482", "id2": "22366505", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"modifyApplicationMessage": ["modifyapplicationMsg", "modifyApplicationContent", "modifyApplicationMsg", "modifyExternalContent", "modifiedapplicationContent", "modifiedapplicationMsg", "modifyApplicationmessage", "modifyExternalMsg", "modifyapplicationMessage", "modifyExternalmessage", "modifyExternalMessage", "modifyapplicationmessage", "modifiedApplicationmessage", "modifiedapplicationmessage", "modifyAppContent", "modifiedApplicationMessage", "modifiedApplicationMsg", "modifyAppMsg", "modifyAppmessage", "modifyAppMessage", "modifiedApplicationContent", "modifiedapplicationMessage", "modifyapplicationContent"], "locale": ["placeame", "locationALE", "placeale", "localame", "localale", "Locame", " locales", "LocALE", "locue", "localALE", "localator", "localales", "Locales", "Locue", "locationue", "locALE", "locame", "Locator", " locame", "locales", "Locale", "locationale", "placeALE", "locator", "locationales", "localue", "placeales", " locator"], "messageName": ["MessageKey", " messageKey", "messageType", "reasonValue", " messageType", "MessageValue", "phraseName", "MessageType", "messagename", " messagename", "Messagename", "reasonName", "msgValue", "msgName", "msgType", "reasonname", "phraseValue", "reasonType", "MessageName", "phraseType", "phraseKey", "msgKey", "messageKey"], "messageValue": ["messageVal", "messageType", " messageType", "MessageValue", "MessageType", " messageVal", "responseVal", "responseName", "msgValue", "responseType", "MessageVal", "msgName", "msgType", "msgVal", "MessageName", "responseValue"], "properties": ["property", "ps", "prop", "perties", "json", "py", "ips", "config", "txt", "options", "pb", "resources", "data", "metadata", " Properties", "Property", "tmp", "params", "obj", "conf", "api", "stats", " props", "settings", "Pro", "pro", "xml", "ops"], "i18nPath": ["i18nPart", "i18onUrl", "i11fUrl", "i18nFile", "i16nPath", "i32nPath", "i32ninPath", "i18npath", "i16nspath", "i16nStr", "i18ninLocation", "i18nUrl", "i18ninFile", "i11fPath", "i32ninLocation", "i11nUrl", "i18onFile", "i18fCorp", "i16nsPath", "i18naStr", "i18nLocation", "i18nsPath", "i32nFile", "i18ninUrl", "i18fUrl", "i18naPart", "i16nsPart", "i18nsFile", "i16npath", "i18fpath", "i18onPath", "i18nsPart", "i32ninUrl", "i18neUrl", "i11nCorp", "i18bpath", "i32nLocation", "i32nUrl", "i18nepath", "i16nPart", "i18ninPath", "i18nsStr", "i11npath", "i18bPath", "i18nspath", "i18nsLocation", "i11fpath", "i11nPath", "i16nsStr", "i18nePath", "i18napath", "i18nsCorp", "i18onLocation", "i32ninFile", "i18bStr", "i18naPath", "i18nStr", "i18fPath", "i11fCorp", "i18nsUrl", "i18bPart", "i18neCorp", "i18nCorp"], "englishFile": ["englishPath", "examplePath", "Englishfile", "EnglishFiles", "ianaJar", "propertiesPath", "englishFiles", " englishFiles", "exampleFile", "englishDir", "ianaPath", " englishJar", "ianaDir", "languageFile", "propertiesFolder", "EnglishFile", "propertiesfile", " englishDir", "EnglishFolder", " englishfile", "languageDir", "englishFolder", "languageFiles", "EnglishPath", " englishPath", "examplefile", "languagePath", "languagefile", "ianaFile", "propertiesFile", "exampleFolder", "englishJar", "languageJar", "englishfile"], "propertiesFilePath": ["pertiesFilepath", "propertiesfilePath", "pertiesfileURL", "propertiesFilepath", "propertiesFilespath", "pertiesFilePath", "propertiesfilepath", "propertiesSourceFileURL", "pertiesDirName", "propertiesDirName", "propertiesDirUrl", "pertiesFileName", "pertiesfilepath", "propertiesFileURL", "pertiesFileUrl", "propertiesfileUrl", "propertiesSourceFileName", "propertiesSourceFilepath", "propertiesfileName", "pertiesDirPath", "pertiesDirUrl", "pertiesfileName", "propertiesFileUrl", "propertiesDirPath", "propertiesFilesUrl", "propertiesFileName", "propertiesfileURL", "propertiesFilesURL", "pertiesDirpath", "propertiesFilesName", "propertiesFilesPath", "propertiesSourceFilePath", "pertiesFileURL", "pertiesfilePath", "propertiesDirpath"], "file": ["text", "source", "message", "buffer", "property", "File", "ile", "directory", "url", "base", "name", "log", "pe", "zip", "stream", "http", "application", "model", "use", "show", "one", "word", "or", "data", "module", "object", "binary", "play", "force", "up", "files", "book", "entity", "future", "unit", "parent", "media", "path", "language", "field", "socket", "single", "folder", "resource", "format", "FILE", "b", "die", "string", "h", "php", "reader", "content", "p", "filename", "fp", "f", "page", "l", "class", "it", "fe", "function", "letter", "child", "connection", "lock", "handler", "full", "part", "le"], "in": ["p", "init", "into", "inn", "gin", "pin", "inner", "f", "s", "plus", "i", "input", "l", "inside", "image", "sin", "or", "IN", "ic", "con", "ini", "win", "io", "n", "isin", "din", "b", "it", "nin", "ins", "cin", "lin", "In", "inc", "again", "rin", "kin", "r", "er", "login", "err", "reader", "bin", "ri", "d"], "out": ["p", "work", "output", "sync", "net", "inner", "f", "home", "s", "w", "ex", "i", "word", "one", "to", "socket", "OUT", "image", "by", "builder", "n", "io", "bin", "up", "and", "b", "ou", "outer", "ext", "exec", "string", "exp", "plain", "Out", "write", "full", "outs", "again", "lib", "part", "r", "err", "cli", "o", "end", "v", "inc", "error", "co"], "c": ["p", "x", "cy", "char", "xc", "uc", "dec", "cf", "ac", "f", "w", "i", "pointer", "l", "k", "ci", "con", "ce", "ice", "ec", "n", "a", "arc", "bc", "pc", "character", "b", "col", "lc", "C", "code", "cr", "cont", "sc", "ch", "rc", "cur", "h", "cc", "esc", "size", "enc", "cl", "cu", "t", "r", "ct", "o", "v", "d", "abc", "dc"], "is": ["as", "ris", "ps", "re", "IS", "str", "us", "isa", "info", "s", "its", "isu", "iss", "are", "i", "Is", "serv", "iso", "ib", "does", "ir", "si", "os", "it", "ui", "res", "api", "ins", "stream", "ais", "ios", "iter", "es", "id", "bis", "get", "has", "ri"], "breader": ["breaders", "feedamer", "breadr", "brewer", "webamer", " BreadER", "weber", " Breader", " Breaders", "webiter", "feediter", "feeder", " cakeers", " cakeER", " cakeler", " breadler", "webr", "brewamer", "breaditer", " cakeer", "feedr", "breadamer", " Breadler", "breadER", " breaders", " breadER", "brewr", "brewiter", "breadler"], "line": ["text", "message", "lf", "style", "look", "Line", "lines", "str", "parse", "lined", "sync", "cell", "lo", "frame", "day", "model", "page", "pass", "link", "phrase", "one", "word", "l", "item", "inline", "data", "definition", "nl", "strip", "comment", "ip", "next", "url", "base", "name", "log", "character", "lc", "band", "code", "split", "letter", "sl", "body", "li", "side", "string", "header", "rule", "LINE", "el", "lin", "write", "plugin", "block", "value", "part", "row", "key", "response", "feed", "entry", "end", "le", "liner", "section", "error", "status", "no"], "strBuilder": ["brbuilder", "brBuilder", "brBuild", "brBlock", "StrBuilder", "stringBuild", "brBuilding", "stringBuffer", " strBuilding", "strBuild", "brBuffer", "strBuilding", "StrBuilding", "StrBlock", " strBlock", "strBuffer", "StrBuffer", "stringBuilder", " strBuffer", " strBuild", "strBlock", "stringbuilder", "stringBuilding", "Strbuilder", " strbuilder", "strbuilder", "StrBuild"], "pieces": ["parts", "nets", "apps", "words", "lines", "bits", "forms", "marks", "bones", "lists", "keys", "ips", "styles", "bytes", "pots", "seconds", "groups", "services", "vals", "cards", "tips", "names", "strings", "cells", "flows", "values", "rings", "letters", "sections", "pins", "objects", "boxes", "files", "split", "cuts", "features", "steps", "pages", "places", "packs", "planes", "tops", "items", "blocks", "circle", "piece", "phones", "ops"], "found": ["created", "normal", "result", "Found", "identified", "loaded", "first", "successful", "f", "all", "not", "filled", "built", "lost", "printed", "l", "given", "still", "count", "successfully", "val", "defined", "updated", "left", "got", "required", "fixed", "missing", "old", "find", "matched", "valid", "expected", "null", "search", "sent", "fl", "letter", "true", "confirmed", "based", "full", "used", "failed", "fall", "temp", "made", "finding", "err", "broken", "changed", " Found"]}}
{"id1": "21488518", "id2": "18613870", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"createNew": ["openOpen", "openCopy", "createResource", "createCopy", "resourceNew", "openNew", "openResource", "newOpen", "resourceOpen", "newCopy", "createOpen", "resourceCopy", "newResource", "newNew", "resourceResource"], "name": ["directory", "anc", "path", "string", "address", "NAME", "class", "base", "non", "id", "n", "resource", "username", "self", "on", "filename", "current", "end", "number", "large", "code", "ame", "ui", "time", "key", "content", "client", "part", "type", "one", "no", "member", "value", "connection", "common", "model", "old", "default", "alias", "parent", "names", "file", "data", "none", "size", "x", "search", "style", "title", "Name", "folder", "image", "e", "label", "word", "full", "prefix", "url", "ext", "comment", "missing", "office", "named", "ename", "ix"], "in": ["IN", "buffer", "i", "input", "id", "resource", "plus", "ini", "slice", "con", "inner", "ins", "record", "bin", "pass", "read", "raw", "source", "reader", "thin", "up", "connection", "login", "len", "diff", "inc", "work", "data", "file", "src", "size", "init", "exec", "image", "In", "win", "din"], "length": ["path", "buffer", "duration", "id", "timeout", "sequence", "filename", "number", "limit", "line", "time", "offset", "content", "password", "type", "load", "len", "Length", "level", "body", "size", "bytes", "url", "ength", "count", "padding", "width"], "contentType": ["contenttype", "contentLength", " contentLength", "ContentType", "resourceType", "resourcetype", "contentPath", " contentPath", " contenttype", "resourceLength", "ContentPath", "ContentLength", "resourcePath", "Contenttype"], "dest": ["zip", "temp", "output", "cont", "result", "later", "destroy", "done", "trans", "dc", "txt", "comb", "cdn", "source", "d", "thin", "wb", "dir", "target", "dist", "upload", "store", "config", "parent", "flat", "src", "route", "Dest", "tmp", "de", "tif", "folder", "desc", "gz", "home", "opt", "sup", "conf", "prop", " destination", "trip", "tx", "transform", "orig", "img"], "out": ["zip", "path", "buffer", "temp", "ex", "output", "copy", "resource", "server", "lock", "OUT", "socket", "result", "outs", "o", "pool", "line", "bin", "password", "client", "sync", "source", "cache", "up", "connection", "parent", "data", "file", "channel", "page", "object", "log", "null", "conn", "again", "exec", "Out", "io", "image", "writer", "exp", "gz", "flush", "ext", "url", "obj", "err", "f", "cmd", "this", "view", "img"], "request": ["directory", "remote", "path", "base", "buffer", "job", "input", "Request", "resource", "claim", "response", "user", "report", "project", "forward", "instance", "child", "query", "req", "friend", "client", "rate", "type", "use", "respect", "upload", "store", "config", "open", "route", "get", "object", "complete", "rer", "QUEST", "quest", "call", "access", "url", "ext", "pe", "reference", "xml", "transfer", "wheel", "re", "external"]}}
{"id1": "2461169", "id2": "3266833", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeStringToString", "decodeFileAsStream", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileToStream", "decodeString2String", "decodeFileAsString", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2String", "decodeStringToStream", "decodeFileAsFile", "decodeFileFromString", "decodeString2Stream", "decodeFileFromFile", "decodeFileToString", "decodeFile2File", "decodeString2File", "decodeFileToFiles", "decodeStringToFiles", "decodeString2Files", "decodeFileFromStream", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "inputfile", " instream", " inbase", " infp", "inputfp", " inFile", "Instream", "minstream", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "Infile", "minFile", "minbase", "InFile", "inbase", "instream", "inputfilename", "infilename", "Inbase"], "outfile": ["outfilename", "outputfile", "inFile", "outFile", "inputfile", "outpath", " outFile", " outpath", "infolder", "outputfolder", "inputFile", "inputpath", " outfolder", "outdatabase", "outfolder", "outputdatabase", "outputfilename", " outdatabase", "inputdatabase", "outputpath", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "sin", "i", "input", "inas", "id", "ini", "gin", "into", "ic", "con", "inner", "as", "socket", "ins", "s", "bin", "pass", "is", "reader", "source", "thin", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "re", "isin", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "win", "din"], "out": ["base", "ou", "job", "ex", "output", "outer", "copy", "timeout", "net", "OUT", "socket", "inner", "outs", "o", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "one", "lib", "up", "inc", "parent", "work", "file", "channel", "log", "conn", "or", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "In", "obj", "err", "error", "point"], "buffer": ["address", "base", "Buffer", "input", "uffer", "feed", "server", "border", "slice", "limit", "result", "length", "write", "bin", "queue", "offset", "iter", "split", "raw", "type", "reader", "cache", "binary", "source", "seed", "buff", "value", "buf", "wave", "data", "channel", "size", "bb", "null", "bytes", "layer", "flush", "url", "b", "reference", "count", "padding", "transfer", "batch"], "read": ["play", "i", "Read", "feed", "n", "copy", "reading", "id", "add", "ind", "slice", "current", "end", "limit", "run", "se", "find", "length", "write", "reads", "ride", "pass", "sleep", "ad", "iter", "next", "raw", "sync", " count", "select", "allow", "use", "load", "reader", "len", " Read", "r", "seek", "work", "inc", "check", " copy", "ip", "size", "x", "get", "fill", "start", "exec", "io", "lex", "send", "tell", "_", "parse", "connect", "wait", "count", "READ", " write", " skip", "f"], "success": ["path", "roll", "error", "response", "rolling", "continue", "results", "ceed", "xx", "message", "primary", "warning", "better", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "model", "default", "open", "data", "growth", "flash", "null", "cess", "danger", "complete", "again", "status", " successful", "good", "Success", "comment", "positive", "right", "successful", "successfully", "rolled", " succ", "method", "fast", "first", "winner", "initial"]}}
{"id1": "949327", "id2": "7908169", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"f": ["r", "fr", "m", "self", "h", "p", "j", "lf", "bf", "g", "n", "fa", "ff", "fd", "form", "s", "feed", "fi", "fen", "e", "cf", "fo", "t", "fm", "sf", "fe", "inf", "a", "path", "ref", "fp", "io", "df", "function", "fn", "fc", "file", "fold", "fun", "of", "x", "rf", "fs", "this", "flat", "b", "v", "w", "name", "fx", "l", "d", "folder", "tf", "F", "filename", "c"], "in": ["image", "g", "inn", "ex", "fe", "a", "rin", "str", "v", "w", "ins", "In", "reader", "win", "r", "get", "p", "pin", "isin", "gin", "gen", "is", "input", "diff", "inner", "vin", "nin", "part", "err", "b", "l", "d", "again", "lock", "ac", "inc", "m", "ic", "fa", "init", "din", "t", "lin", "ssl", "ini", "min", "pass", "serv", "it", "IN", "source", "up", "c", "n", "socket", "cin", "thin", "or", "connection", "con", "rec", "exec", "login", "session", "data", "with", "token", "bin", "config"], "cbuf": ["bux", "cfuff", "rbuc", "rbbuf", "cfur", "bcur", "zbutf", "bcux", "fbuf", "bbuff", "cfuc", "cbur", "cfuf", "cfbuf", "bcul", "CBuf", "fbbuf", "bcault", "rbault", "bcuf", "cbull", "bbull", "cbuc", "cbbuf", "CBuc", "rbull", "cbault", "bcurs", "bcull", "bbuf", "buff", "CBuff", "cbuff", "cbux", "fbuc", "dbur", "rbutf", "zbuf", "rburs", "cbuu", "cburs", "buf", "dbuc", "ebuf", "bcuc", "rbul", "zbuff", "ebutf", "cbutf", "dbuff", "rbuu", "dbuf", "ebuu", "cbul", "CBul", "fbuff", "zbuu", "bburs", "rbux", "bcuff", "bault", "rbuff", "ebuff", "rbuf"], "read": ["error", "size", "sync", "g", "Read", "cel", "key", "old", "rc", "used", "ak", "open", "last", "seek", "only", "report", "raw", "change", "reading", "build", "end", "x", "iter", "en", "update", "re", "know", "er", "w", "allow", "text", "draw", "name", "reader", "create", "length", "get", "ind", "r", "connect", "ok", "full", "view", "feed", "load", "input", "parse", " write", "check", "val", "index", "num", "io", "sleep", "find", "lex", "close", "ack", "skip", "ing", "d", "repeat", "inc", " reading", " Read", "level", "ize", "stream", "bit", "ink", "q", "use", "print", "id", "valid", "run", "child", "work", "count", "start", "pass", "k", "pe", "log", "y", "put", "each", "wait", "it", "ride", "un", "insert", "add", "play", "buffer", "ed", " READ", "socket", "write", "reads", "want", "READ", "orig", "se", "readable", "send", "fill", "oct", "data", "type", "bind", "record", "call", "loop", "config", "select", "hex"], "totRead": ["tottUse", "totUse", "TottGet", "tntWrite", "tatLoad", "octotLength", "totReader", "ntottWrite", "towAccept", "TotWrite", "totalLoad", "tochReader", "totoFind", "totaLoad", "toyRead", "TotaRead", "towLength", "TottConnect", "octotRead", "tobyFind", "dottReader", " totWrite", "totalWrite", "totoRead", "ntottRead", "TotSearch", "tottReading", "tetReading", "nottLoad", "tottLength", "totaDraw", "totiBuild", "tottedGet", "TotReader", "tetRead", "tntRead", "totoLength", "totalBuild", "totConnect", "totGet", "nottWrite", "totAccept", "totingConnect", "tollWrite", "tottAccept", "TotRead", "tobyLoad", "tottDraw", "tottLoad", "totiWrite", "tottFind", "tottConnect", "tottedRead", "tochWrite", "totiRead", "ntottLoad", "notWrite", "totingRead", "tottBuild", "tottReader", "tazonLoad", "towReading", "dottRead", "TottLoad", "dottLoad", "tottWrite", "tetLoad", "totLength", "TotConnect", "TotReading", "totBuild", " totBuild", "totingSearch", "tcotLoad", "totClose", "ntotWrite", "tobyRead", "totiLink", "tcotClose", "dotReader", "totaReading", "totalRead", "intottLoad", "octotoLength", "tatWrite", "dottReading", "TottWrite", "tottSearch", "TottRead", "totFollow", "intotRead", "totaBuild", "dottUse", "totSearch", "dotReading", "totDraw", "TotaLoad", "octotWrite", "towRead", "ntotLoad", "notRead", " totalBuild", "totoLoad", "totLink", "totalAccept", "octotoRead", " totalWrite", "tottFollow", "ntotReader", "TotaWrite", " totalLink", "totoUse", "TotaDraw", "tollReading", "tazonBuild", "TotGet", "totLoad", "tazonRead", "toyLoad", "tollRead", "intottRead", "totaWrite", "intottClose", "octotoReading", "intotLoad", "notLoad", "totReading", "intotBuild", "dotLoad", "tochLoad", "tazonClose", "totalLink", " totLink", "tntReader", " totalRead", "tottedFollow", "octotoWrite", "tottedWrite", "intotClose", "TotDraw", "nottAccept", "totaRead", "tollLoad", "tetWrite", "tntLoad", "tatReader", "tatRead", "tobyUse", "towWrite", "dottFind", "totoSearch", "dotFind", "ntottReader", "totFind", "tottClose", "tochRead", "totoReading", "totaReader", "TottReading", "totingWrite", "intottBuild", "dottWrite", "dotRead", "totingGet", "tottRead", "toyWrite", "notAccept", "TotLoad", "tottGet", "TotFollow", "TottFollow", "nottRead", "totoConnect", "TottSearch", "octotReading", "dotUse", "totaLink", "ntotRead", "totWrite", "totoWrite", "towLoad", "totingFollow", "TottReader", "tcotRead", "toyDraw", "tcotBuild", "dotWrite"], "out": ["Out", "r", "client", "writer", "h", "p", "obj", "sync", "n", "g", "off", "output", "socket", "s", "init", "parent", "ex", "t", "conn", "plus", "connection", "a", "exp", "ext", "io", "fn", "conf", "file", "part", "x", "o", "exec", "ac", "err", "b", "v", "w", "net", "bin", "l", "In", "d", "again", "OUT", "outs", "outer", "up", "c", "inc"], "i": ["j", "g", "my", "ik", "key", "ci", "gi", "info", "zi", "ei", "x", "api", "u", "v", "name", "yi", "uri", "I", "length", "r", "ind", "ip", "p", "one", "eni", "is", "multi", "fi", "ix", "input", "phi", "li", "index", "io", "iu", "bi", "ti", "b", "mi", "l", "d", "si", "ai", "m", "ic", "q", "init", "slice", "e", "id", "abi", "z", "ini", "start", "o", "xi", "k", "ri", "y", "ji", "oi", "it", "hi", "chi", "source", "c", "buffer", "h", "ie", "ui", "ori", "ii", "pi", "data", "ni", "di", "me", "qi", "current"]}}
{"id1": "12085127", "id2": "14191679", "code1": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 0, "substitutes": {"navigate": [" Navig", "ajigating", "ajigate", "ivigate", " Navigation", "navigated", "Navigating", "avigating", "ajig", "ivigation", "avigation", "navigating", "ivigated", " Navigating", "Navigate", "Navig", "Navigation", "avigate", " Navigate", "navig", "ajigation", "ivigating", "navigation", "avigated", "Navigated"], "url": ["article", "address", "base", "job", "ssl", "i", "server", "uri", "resource", "feed", "id", "user", "entry", "http", "c", "html", "l", "host", "location", "URL", "account", "fr", "follow", "client", "source", "rule", "str", "r", "org", "build", "config", "file", "route", "page", "object", "ll", "web", "plugin", "e", "image", "blog", "link", "sl", "Url", "position", "www", "bug", "obj", "f", "gl", "element", "service", "api"], "connection": ["Connection", "handler", "i", "server", "resource", "response", "uri", "cf", "http", "ie", "character", "con", "c", "socket", "connected", "l", "database", "condition", "client", "session", "lc", "proxy", "which", "application", "open", "channel", "page", "context", "conn", "or", "coll", "ci", "io", "link", "position", "bc", "unit", "b", "connect", "wrapper", "communication", "loc"], "is": ["info", "bis", "i", "iss", "lis", "serv", "fs", "IS", "isa", "gets", "Is", "as", "api", "ins", "bs", "abs", "il", "s", "ui", "ii", "in", "isl", "its", "was", "ops", "ais", "isc", "ir", "ip", "es", "ai", "ris", "ci", "io", "iris", "ils", "ios", "us", "ib", "isi", "cs", "os", "isu", "im", "iso", "mis"]}}
{"id1": "19050432", "id2": "6457199", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["openParamingresource", "openNamedResources", "openNnamedResources", "openNamingResources", "openNestedresource", "openNamingresource", "openParamedResources", "openParamingResources", "openNestedResource", "openParamingURI", "openNamingURI", "openParamingResource", "openNnamedResource", "openParamedresource", "openNamedresource", "openNamingResource", "openNnamedresource", "openNnamedURI", "openNamedURI", "openNestedURI", "openParamedURI", "openParamedResource", "openNestedResources"], "name": ["source", "filename", "uri", "str", "path", "username", "ame", "NAME", "info", "word", "Name", "data", "names", "definition", "resource", "old", "n", "class", "url", "base", "address", "string", "size", "prefix", "full", "named", "file", "value", "version", "part", "key", "sea", "id", "type", "parent"], "in": ["source", "as", "result", "rec", "inn", "gin", "out", "token", "pin", "inner", "ac", "f", " out", "i", "input", "socket", "conn", "val", "get", "IN", "data", "con", "win", "resource", "ini", "url", "din", "pc", "b", "vin", "nin", "ins", "connection", "cin", "thin", "In", "fc", "inc", "again", "rin", "kin", "r", "oin", "login", "err", "reader", "edIn", "bin", "ic"], "propsURL": ["proopsLL", " propsUR", "proportsELF", "proppsUR", "prosUL", " propsSSL", "prorsUrl", "prorsurl", "propsCL", "prodsUrl", "proportsUL", " propsLL", "perrsurl", " propsUrl", "prosUrl", "propsLL", "propsUrl", " propsUL", "prosSSL", " prodsURI", "proopsURI", "PropsSSL", "probsURL", "proopsUrl", "probsLL", "procsSSL", " prodsURL", "procsURL", "prodsLL", "pronsURL", "protsURL", "protsurl", "prosLL", "perrsFile", " propsELF", " prolsSSL", "propdsUR", "prodsCL", "propsSSL", " prolsurl", "proopsUR", " propsurl", " prodsurl", "prodsSSL", "prosURL", "propdsUrl", "prodsURI", " propsCL", "prodsURL", "prodsFile", "progsURI", "ProsURI", " proportsUR", "protsFile", "proppsURL", "proppsLL", "prolsurl", "perpsURL", "propsELF", "prolsSSL", "PropsUrl", "probsUL", "prorsFile", "procsurl", "probsUrl", " proportsLL", " proportsUrl", " propsURI", "perpsFile", "propdsURL", " prodsCL", " proportsUL", "perrsURL", "prolsURI", "propsUR", "proportsURL", "propsUL", "prodsurl", "ProsSSL", "prorsELF", "proportsurl", "PropsURL", "propsFile", "propdsLL", "proportsUR", "pronsUrl", "propsurl", "procsURI", "proopsURL", "ProsURL", "proopsurl", "progsURL", "progsurl", "procsUrl", " prolsURL", "progsCL", "prodsUR", "proportsLL", " prolsURI", "prosURI", "proportsSSL", "prorsURL", "pronsLL", "proppsUrl", "propsURI", "proportsUrl", "proopsELF", "PropsURI", "proportsURI", "pronsUR", "prolsURL", " proportsURL", " proportsELF", "proopsCL", "ProsUrl", "perpsurl", "prorsUR"], "urlConn": ["httpconn", "URLConnect", "httpContext", "sslconn", "sslCod", "urlContext", "sslConn", "fileConn", "httpConnect", "urlCod", "sslCond", "URLConn", "URLContext", "httpCod", " urlCond", "urlconn", " urlConnect", "URLConf", "urlCond", "fileConnect", "httpConn", "urlCmd", "urlConnect", "sslCmd", " urlContext", " urlConf", "fileCond", "fileCmd", "sslConnect", " urlCmd", "urlConf", " urlconn", "httpConf", " urlCod"], "httpURL": ["httpsURI", "apiUR", "HttpUrl", "HttpURI", "autoUrl", "httpURI", "httpsUR", "httpsUrl", "apiML", "HttpURL", "httpSSL", " httpurl", " httpSSL", " httpML", "httpUrl", "apiURL", "httpsURL", "httpsurl", "httpurl", "httpsSSL", "HttpUR", " httpUR", "autoURL", "autoSSL", "apiUrl", "httpUR", " httpUrl", " httpURI", "autourl", "HttpML", "httpML"], "hdrVal": [" hheaderVal", "hrStr", "hhrval", "HhrVal", "hdValues", "Hhrval", "hreqStr", "hdrValues", "hrVol", "hDRval", "hndValue", "hdrVol", "hreqVal", " hdrStr", "HdrBu", "hdValue", "HdrValues", "hndBu", " hheaderVol", "HdrDef", "hdval", "hDRValue", "hhrDef", "hhrVal", "hrValue", "HhrBu", "hrcVal", "hrVal", "HhrValues", "Hdrval", "hrcValue", "hhrValues", "hhrValue", "hdVal", "hreqValue", "hheaderVal", " hheaderStr", "hheaderStr", "hndDef", "HhrDef", "hheaderValue", "HdrValue", "hdrDef", "HdrVal", "hDRValues", "hDRVal", "hdrStr", "hrcBu", "hndVal", " hheaderValue", "HhrValue", " hdrVol", " hdrValue", "hrcDef", "hdrval", "hreqVol", "hdrValue", "hheaderVol", "hhrBu", "hdrBu"], "code": ["text", "message", "result", "mode", "ode", "check", "c", "cat", "info", "status", "charge", "state", "success", "e", "one", "level", "ie", "count", "line", "data", "const", "age", "ce", "comment", "ec", "expected", "core", "class", "no", "url", "pc", "reason", "pe", "ge", "zip", "number", "grade", "msg", "Code", "index", "see", "ack", "cc", "category", "rule", "rc", "header", "string", "codes", "fail", "score", "test", "desc", "cod", "value", "version", "xx", "key", "response", "id", "rate", "type", "zone", "error", "co", "go", "content", "coded"]}}
{"id1": "8000624", "id2": "12236729", "code1": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"CopyTo": [" copyFrom", " transferFile", " copyTo", "copyTo", " copyto", "copyFile", "copyFrom", "CopyFile", " transferTo", "Copyto", "copyto", " transferto", " transferFrom", " copyFile", "CopyFrom"], "dest": ["bin", "data", "sup", "name", "opt", "later", " destination", "table", "them", "cont", "destroy", "comb", "class", "orig", "die", "desc", "w", "output", "txt", "content", "img", "done", "dist", "temp", "test", "source", "path", "filename", "object", " Dest", "delete", "exit", "flat", "file", "wb", "folder", "transform", "src", "Dest", "target", "write", "obj", "tmp", "rest"], "in": ["x", "reader", "bin", "connection", "isin", "sin", "f", "login", "issue", "s", "ins", "pin", "m", "cin", "In", "vin", "inside", "kin", "conn", "b", "inner", "again", "rin", "win", "r", "l", "din", "IN", "ax", "plus", "pull", "ini", "i", "source", "image", "init", "inc", "lib", "nin", "h", "n", "pass", "thin", "inn", "as", "up", "fa", "id", "wave", "lin", "input", "con", "ln", "re", "ac", "gin"], "out": ["x", "bin", "app", "ext", "outside", "data", "name", "socket", "pin", "sync", "ex", "outs", "not", "timeout", "one", "copy", "conn", "w", "b", "output", "cache", "again", "inner", "part", "vert", "user", "writer", "err", "plus", "o", "off", "OUT", "temp", "this", "client", "call", "i", "lib", "external", "image", "inc", "nin", "or", "outer", "exec", "object", "other", "url", "no", "our", "n", "io", "net", "up", "file", "target", "ou", "Out"], "c": ["x", "abc", "cb", "arc", "f", "char", "sc", "m", "ca", "ct", "C", "p", "enc", "ec", "pc", "rc", "lc", "u", "content", "cr", "l", "r", "e", "o", "exc", "esc", "dc", "d", "i", "pointer", "ci", "cc", "comment", "buffer", "ch", "t", "uc", "cf", "xc", "v", "cl", "config", "code", "n", "oc", "cu", "ce", "ic", "cm", "ac", "col", "fc", "bc", "cy"]}}
{"id1": "9805906", "id2": "15580610", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"dump": ["save", "df", "f", "data", "info", "download", "load", "copy", "all", "files", "zip", "Dir", "export", "flush", " dumped", "ump", "db", " dumps", "update", " dumping", "transfer", "store", "println", "diff", "dir", "out", "ln"], "source": ["connection", "iter", "sin", "ources", "current", "start", "s", "slice", "remote", "from", "stream", "se", "base", "ource", "SOURCE", "address", "this", "service", "parent", "view", "uri", "server", "core", "unit", "http", "file", "series", "src", "scene", "resource", "input", "Source", "slave", "string", "use", "site"], "target": ["office", "connection", "it", "force", "master", "arget", "effect", "database", "table", "to", "settings", "base", "top", "output", "goal", "alias", "root", "dest", "address", "pointer", "template", "port", "project", "path", "parent", "object", "large", "next", "platform", "null", "file", "Target", "enemy", "src", "follow", "resource", "out", "result", "host", "replace"], "is": ["ens", "ais", "Is", "iss", "isl", "s", "oss", "bs", "ins", "bos", "ori", "info", "has", "ics", "im", "gets", "isa", "IS", "ls", "cs", "abs", "was", "obs", "ops", "oses", "its", "i", "mis", "ws", "or", "nis", "bis", "ois", "ui", "ists", "ps", "ris", "io", "as", "in", "iso", "iris", "es", "ai", "opens", "us", "ios", "lis", "ip", "ses", "isi"], "os": ["ens", "ais", "ues", "oa", "cos", "ds", "oos", "s", "bs", "oss", "boot", "bos", "ori", "ips", "outs", "ows", "cs", "ies", "obs", "ops", "oses", "o", "its", "i", "OS", "or", "Os", "oes", "vs", "ose", "ps", "io", "osi", "as", "pos", "aos", "acs", "ros", "ss", "es", "los", "ios", "us", "ols", "nos", "fs", "ks", "dos"], "done": ["did", "once", "current", "loaded", "data", "Done", "later", "made", "complete", "started", "got", "due", "after", "ready", "one", "disabled", "finished", "odo", "future", "die", "part", "enabled", "expected", "defined", "doing", "confirmed", "next", "nice", " finished", "checked", "dad", "empty", "yes", "last", "running", "gone", "none", " Done", "foo", "progress", "always", "de", "dirty"]}}
{"id1": "1954410", "id2": "5299276", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitExecutes", "doexecuteApply", "doexecuteutes", "submitExecApply", "doSendApply", "doSendRun", "submitexecuteutes", "doExecRun", "submitExecRun", "doExecutes", "submitexecuteRun", "submitexecuteApply", "doSendute", "doexecuteRun", "submitExecute", "doSendutes", "submitexecuteute", "doExecApply", "doexecuteute"], "mapping": ["fapper", "matching", "fapping", "minding", "aminding", "amapping", "amapper", "finding", "mapper", " mapper", " minding", " matching", "amatching", "fatching"], "form": ["flow", "method", "app", "FORM", "forms", "field", "Form", "config", "component", "page", "command", "control", "owner", "definition", "object", "format", "builder", "transform", "url", " forms", "formation", "post", "submit", "dom", "feed", "template", "xml", "pattern"], "request": ["message", "method", "create", "call", "Bytes", "result", "re", "uri", "json", "client", "current", "path", "hello", "session", "Accept", "instance", "frame", "Upload", "s", "this", "model", "use", "view", "HTTP", "input", "complete", "req", "data", "q", "object", "resource", "format", "QUEST", "self", "ware", "url", "name", "add", "server", "requ", "Response", "query", "address", "worker", "queue", "submit", "Reply", "_", "parent", "route", "pull", "reader", "user", "type", "xml", "Request", "report", "context", "application"], "response": ["message", "result", "output", "json", "client", "status", "model", "page", "view", " Response", " responses", "application", "resp", "data", "req", "object", "resource", "Resp", "server", "Response", "res", "handler", "v", "xml", "report", "reply"], "errors": [" status", " flashes", " payload", " translations", " Messages", " session", " commands", " logger", " error", " this", " responses", " warnings", " changes", " replies", " management", " managers", "mess", " acc", " updates", " mess", " messages", " messaging", " problems", " calls", " messenger", " failures", " events", " logs", " streams"], "isMultipart": ["isMultipparts", "isMultippedost", "isMultIPound", "isMultompost", "isMultipost", "isMultipound", "isMultompPart", "isMultipage", "isMultiipound", "isMultIPPart", "isMultompound", "isMultitage", "isMultiipPart", "isMultippart", "isMultIPart", "isMultiIPart", "isMultiated", "isMultippedound", "isMultompart", "isMultiparts", "isMultiipart", "isMultippated", "isMultitart", "isMultiIPost", "isMultippedart", "isMultiIPPart", "isMultIPost", "isMultitarts", "isMultipPart", "isMultippedPart", "isMultiarts", "isMultitated", "isMultippage", "isMultiIPound", "isMultiipost", "isMultiage", "isMultiart", "isMultipated"], "mailInstance": ["fileManager", "fileinstance", "fileInstance", "mailUsage", "emailinstance", " emailinstance", " mailUsage", "emailInstance", "fileUsage", " emailInstance", "mailinstance", " emailUsage", "mailInst", "emailManager", " emailInst", " mailInst", " mailinstance", "mailManager", "emailInst", " mailManager", "fileInst"], "fields": ["types", "parts", "rules", "holders", "locks", "words", "lines", "forms", "field", "lists", "keys", "forces", "s", "groups", "input", "services", "atts", "dates", "data", "gets", "strings", "checks", "cells", "flows", "archives", "objects", "qs", "boxes", "params", "ments", "files", "facts", "utils", "members", "features", "states", "links", "acks", "models", "tags", "pages", "uploads", "views", "details", "loads", "plugins", "packs", "users", "properties", "headers", "changes", "maps", "classes", "comments", "events", "ids", "rows", "posts"], "attachments": ["Attachments", "payments", "attachers", "Attachees", "extions", "exters", "attions", "attees", "attachresses", "attps", "attachlements", "payment", "achresses", "Attachps", "Attachlements", "suppees", "achments", "attachps", "attments", "attachment", " attachment", " attachparts", "attachparts", "attachions", "attment", "Attachions", "extps", "achparts", "atters", "attlements", "achment", "supplements", "payparts", "payresses", "Attachers", "extments", "suppment", "suppments", " attachresses", "attachees", "Attachment"], "items": ["types", "parts", "apps", "locks", "lines", "orders", "lists", "Items", "keys", "ips", "its", "ers", "groups", "data", "names", "objects", "apters", "qs", "files", "reports", "list", "ins", "links", "models", "pages", "plugins", "es", "results", "children", "events", "ids", "alls", "rows", "phones", "ops"], "iter": ["itter", "edit", "inner", "finder", "ver", "ite", "ter", "page", "event", "master", "cher", "i", "keep", "enter", "skip", "upper", "gener", "loc", "ner", "walker", "ir", "ip", "Iterator", "it", "izer", "outer", "Iter", "zip", "altern", "ator", "li", "list", "exp", "former", "chain", "coll", "el", "ul", "inc", "file", "loop", "err", "er", "ser", "end", "reader", "inter", "slice", "iterator", "oper", "order", "http"], "item": ["source", "current", "instance", "event", "extra", "image", "val", "ip", "url", "base", "name", "post", "Item", "li", "temp", "slice", "entry", "type", "section", "volume", "result", "token", "load", "info", "all", "i", "area", "or", "data", "example", "object", "other", "up", "original", "obj", "entity", "api", "layer", "coll", "plugin", "art", "site", "user", "order", "update", "hop", "atom", "issue", "folder", "resource", "next", "container", "element", "attribute", "more", "reader", "get", "app", "widget", "album", "inner", "page", "complete", "anything", "service", "missing", "storage", "it", "server", "index", "handler", "full", "file", "custom", "er"], "aux": ["offs", " auxiliary", "uc", "ups", "uf", "frac", "union", "alias", "buf", "aus", "extra", "etc", " Aux", "data", "des", "ux", "aff", "strings", "amp", "af", "ras", "cas", "ru", "sup", "aw", "array", "lc", "asc", "ext", "ou", "ants", "sub", "lang", "imp", "prefix", "axe", "aos", "fax", "auc", "ox", "off", "abs", "anc", "au", "pkg", "packages", "cmp", "abc", "except"], "part": ["p", "pre", "group", "parts", " Part", "ref", "field", "instance", "f", "point", "info", "back", "component", "per", "one", "word", "po", "l", "pos", "area", "joined", "val", "data", "PART", "object", "format", "act", "on", "action", "and", "class", "error", "base", "name", "b", "add", "change", "fact", "obj", "player", "pi", "ch", "connection", "list", "patch", "but", "layer", "comp", "element", "full", "plugin", "block", "html", "Part", "file", "start", "step", "partial", "key", "art", "diff", "join", "id", "type", "parent", "section", "user", "co", "no", "pair"], "baos": ["BAo", "baoss", "baOs", "baot", "paot", "baoS", "abaosi", " baoS", "BAis", "Bao", " baoss", "baosh", "boOS", "pao", "boo", "BAOs", "BAoss", "haos", "BaOs", " bao", "baOS", "bois", "paOS", "Baos", "BAoS", "Baosi", "abais", "abaOs", " baOS", "BaoS", "bais", "hao", "boosh", "hais", "abaos", "BAosi", "baosi", " bais", "boos", "Bais", "pais", "boot", "bao", "BAos", "paos", "paosh", " baot", "BAosh", "haoss"], "body": ["text", "source", "message", "parts", "media", "summary", "output", "port", "json", "length", "fee", "translation", "flash", "Body", "state", "pass", "options", "tree", "data", "object", "resource", "binary", "comment", "description", "shell", "document", "url", "name", "b", "null", "params", "zip", "query", "string", "header", "connection", "size", "full", "html", "value", "headers", "template", "end", "type", "common", "content", "reply"], "preferencesInstance": ["preffeesinstance", "prefeesinstance", "prefiesinstance", "preffeesClient", "prefirmsClient", "preferencesClient", "prefirmsInstance", "prefeesClient", "prefiesClient", "prefiesInstance", "prefeesInstance", "preffeesInstance", "preferencesinstance", "prefferencesClient", "prefirmsinstance", "prefferencesInstance", "prefferencesinstance"]}}
{"id1": "19739421", "id2": "16719805", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": [" UnknownOptionception", "UnknownOptionsError", "UnknownOptionsException", "UnknownOptionsception", "UnknownOperationException", "UnknownParameterError", "UnknownOperationError", "UnknownOperationception", "UnknownOptionception", " UnknownOptionsError", "UnknownParameterException", " UnknownOptionError", "UnknownOptionError", " UnknownOptionsException", " UnknownOptionsception", "UnknownParameterception"], "cmdLineParser": ["mdlineBuilder", "mdLRunner", "cmdEntryParser", "cmdEntryMaster", "cmdlineHelper", "cmdServicearser", "commandlineReader", "cmdStringReader", "mdLineRunner", "cmdServiceParser", "cmdLarser", "cmdSiteWriter", "cmdStringparser", "cmdStringBuilder", "mdlinearser", "mdLineBuilder", "cmdBlockparser", "cmdlineBuilder", "cmdBlockarser", "cmdFileReader", "mdLineParser", "cmdLinParser", "cmdByteMaster", "commandLineReader", "cmdFileParser", "mdLarser", "cmdEntryarser", "commandLineParser", "cmdLineReader", " cmdLarser", "cmdLinMaster", "cmdLineHelper", "cmdLMaster", "cmdSiteParser", "mdLinearser", "cmdlineparser", "cmdLineparser", "commandLineMaster", " cmdLParser", "cmdlinearser", "mdLJar", "commandlineJar", "cmdLineRunner", "cmdFilearser", "mdLineWriter", " cmdLJar", "mdLineReader", "mdLineparser", "cmdBlockMaster", "cmdBlockBuilder", "cmdLBuilder", "mdLReader", "cmdStringHelper", "cmdByteParser", "cmdStringMaster", "cmdLinReader", "mdlineWriter", " cmdLinearser", "cmdEntryJar", "mdLParser", "cmdSiteparser", "cmdlineWriter", "cmdlineMaster", "cmdBlockWriter", "cmdStringParser", "cmdLineJar", "commandlineMaster", "cmdLJar", "cmdlineReader", "mdLineJar", "cmdFileJar", "cmdlineParser", "cmdByteWriter", "cmdStringRunner", "cmdlineJar", "mdLineHelper", "mdlineJar", "cmdLRunner", "cmdServiceJar", "cmdSiteJar", "cmdBlockParser", "cmdLinJar", "cmdLineMaster", "commandlineParser", "cmdStringWriter", "mdlineMaster", "cmdStringarser", "mdLHelper", "commandLineJar", " cmdLineMaster", "cmdLparser", "cmdLReader", "cmdLParser", "cmdLineWriter", " cmdLMaster", "cmdStringJar", "cmdFileMaster", "cmdBlockJar", "cmdServiceMaster", "cmdByteJar", "cmdLineBuilder", "cmdFileRunner", "cmdLHelper", "mdLineMaster", "cmdLinearser", "mdlineParser", " cmdLineJar", "mdlineparser"], "formatOption": ["FormatOperation", "typeParameter", "printfOpt", "formatOperation", " formatElement", "FormatOption", " formatVariable", " formatOperation", "FormatElement", "FormatOpt", " formatOpt", "lengthOpt", "formatVariable", "formatOpt", "lengthParameter", "printfOperation", "lengthOption", "formatParameter", "lengthVariable", "printfOption", "typeOption", "printfElement", "typeOpt", "typeVariable", "formatElement", " formatParameter"], "outputEncodingOption": ["outputCasingOptions", "outputCodingOperation", "outputEncodingOptions", "outputEncordingParameter", "outputEncodingParameter", "outputEncordingOpt", "outputEncodingOpt", "outputCasingOption", "outputCodingOptions", "outputCasingOpt", "outputEncoderOperation", "outputEncitingOpt", "outputEncasingOpt", "outputCodingOption", "outputEncitingOperation", "outputEncoderOption", "outputEncordingOperation", "outputEncasingOption", "outputCasingOperation", "outputCasingParameter", "outputCodingOpt", "outputEncordingOptions", "outputEncoderParameter", "outputEncasingParameter", "outputEncitingOption", "outputEncodingOperation", "outputCodingParameter", "outputEncitingOptions", "outputEncoderOpt", "outputEncordingOption", "outputEncasingOptions", "outputEncasingOperation"], "inputEncodingOption": ["inputChodingOpt", "inputEncodedFunction", "inputChasingOption", "inputEncasingFunction", "inputEncodingOpt", "inputEncasingOpt", "inputChodingFunction", "inputEncasingOption", "inputEncodingOperation", "inputEncachingOpt", "inputChasingOperation", "inputEncoderOperation", "inputChachingOption", "inputEncodedOperation", "inputEncachingOperation", "inputEncoderOption", "inputEncoderOpt", "inputChasingFunction", "inputChodingOperation", "inputChachingOperation", "inputChodingOption", "inputEncodingFunction", "inputEncasingOperation", "inputEncoderFunction", "inputEncachingOption", "inputChachingOpt", "inputEncodedOption"], "format": ["letter", "string", "output", "option", "filename", "version", "place", "html", "api", "host", "quality", "layout", "sort", "Format", "pattern", "alpha", "form", "filter", "at", "type", "value", "target", "cat", "feature", "config", "file", "term", "export", "size", "language", "ant", "style", "plugin", "title", "template", "name", "pretty", "writer", "prefix", "service", "unit", "atter", "command", "printf", "attribute", "f", "scale", "transform", "license"], "outputEncoding": ["outputDecoder", "outputEncoring", " outputEngoder", "outputOctoring", "outputDecoding", " outputEngoding", "outputEncining", "outputEngording", "outputOctoder", "outputChaching", " outputEncining", "outputEntaping", "outputEncording", "outputEngaching", "outputEncryption", "outputChording", "outputChoder", "outputEnaping", " outputEngording", "outputSequoder", "outputSequoding", "inputEncoder", "outputCompasing", "inputChoring", "inputEncasing", "outputEnining", "outputEntasing", "outputCompoding", "inputChording", "outputChaping", "outputOctoding", "inputChoder", " outputEncoder", "outputOctasing", "outputencoding", "outputChoding", "outputDecasing", "inputChasing", "outputDecording", "inputEncryption", "outputEncaching", "outputEncaping", " outputEncaching", "outputChasing", "outputChoring", "outputEnasing", "outputEncoder", " outputEntining", "outputCompoder", "outputEncasing", "outputEnoding", "inputEncording", "outputSequasing", "outputencording", " outputEncasing", "outputChryption", " outputEncaping", " outputEntasing", "inputEncoring", "outputencaching", "outputEntryption", "inputChryption", " outputEngaching", "outputencoder", "outputChining", "outputSequryption", "outputEngoder", "outputEntoder", " outputEntaping", "outputEntoding", "inputChoding", "outputEntining", " outputEncording", "outputEngoding", " outputEntoding", "outputCompording"], "inputEncoding": ["inputEnasing", "inputEncapping", "outputEncapping", "inputExplasting", " inputDecording", "inputEncasting", "inputEnode", "inputEncasing", "variableExplode", "variableEncode", "outputChasing", " inputEncacing", "inputChording", "inputEncacing", " inputDecoding", "outputEncoder", "inputEnoding", "inputEngapping", "inputDecording", "inputChapping", "inputChoder", "variableExplasting", "outputEncasing", "inputChasting", "inputChoding", "inputDecacing", "inputExplode", "inputEncording", "variableExploding", "inputChacing", " inputEncording", "inputEnoder", "variableEncasting", "inputEnacing", "inputExploding", "variableEncasing", " inputEncoder", "inputDecoding", "inputEnapping", "inputDecoder", "inputEngasing", "outputChoding", "inputChode", "outputChoder", " inputDecacing", "inputEnording", "inputEngoder", "outputChapping", "inputChasing", "variableEncoding", " inputDecoder", "inputEncode", "inputEnasting", "variableExplasing", "inputEngoding", "inputEncoder", "inputExplasing"], "remainingArgs": ["regainedArgs", "RemangingArg", "RemingParts", "remingGS", "remainingargs", "remangingArgs", "remainGS", "RemingLong", "remendingArg", "RemingGS", "removingLong", "remainArgs", "remainingParameters", "resainingargs", "resainingLong", "resainArgs", "remainLong", "removingParts", "remingParts", "remendingArray", "resainedParts", "remainsArgs", "remainargs", "remainingAr", "RemainingArg", "resainingArray", "regainingGS", "RemingArgs", "remainingArray", "remingLong", "remainingLong", "remingArgs", "resainargs", "regainingArgs", "remendingArgs", "resainArray", "remangingParts", "remainArg", "resainedArg", "RemangingParts", "resainedArgs", "resainingArgs", "RemangingArgs", "regainingParameters", "resainingArg", "remainParameters", "remainAr", "remainsAr", "remainedGS", "resainingParts", "remainArray", "regainedArg", "resainedLong", "RemainingGS", "remangingParameters", "remendingargs", "remangingAr", "regainedGS", "RemainingParts", "remangingLong", "remainsParts", "RemangingAr", "remainingArg", "removingGS", "RemainingLong", "remainingGS", "remangingArg", "RemainingArgs", "remainedargs", "resainArg", "remangingGS", "remainParts", "remainedArray", "remainedParts", "remainingParts", "RemainingAr", "regainingArg", "regainedParameters", "remainedArgs", "remainedArg", "remainsArg", "removingArgs", "remainedLong", "remainedParameters"], "inputFile": [" inputDir", "InputDirectory", "localSourceFile", "InputDir", "sourceDir", "localDirectory", "inputfile", "inputSourceFile", " inputfile", "sourcePath", "sourceLine", " inputSourceFile", "sourceFile", "InputLine", "inputPath", "InputFile", " inputStream", "inputLine", "inputDir", "Inputfile", "localFile", "inputStream", "sourcefile", " inputLine", "InputSourceFile", "localDir", "sourceDirectory", "sourceStream", "InputPath", "inputDirectory", "InputStream", " inputPath", " inputDirectory"], "outputFile": [" outputMessage", "outputfile", "outputFolder", "OutputFile", "OutputHeader", "OutputFolder", " outputFolder", "OutputMessage", "outputMessage", "outputPath", "exampleStream", "productionPath", "operationFile", "operationHeader", "OutputStream", "productionMessage", " outputStream", " outputPath", "exampleFolder", "outputStream", " outputfile", "operationfile", "exampleFile", "Outputfile", "examplefile", "outputHeader", "productionFile", "OutputPath", " outputHeader", "productionfile", "operationFolder"], "out": ["info", "sum", "temp", "outer", "output", "server", "copy", "lock", "builder", "pre", "OUT", "outs", "write", "flow", "manager", "co", "line", "in", "post", "raw", "client", "session", "cache", "up", "debug", "group", "ger", "parent", "page", "log", "gen", "again", "Out", "writer", "io", "word", "dump", "screen", "prefix", "ln", "over", "obj", "err", "println", "history", "error", "list", "auto"]}}
{"id1": "21425787", "id2": "4461350", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 0, "substitutes": {"copyFile": ["CopyStream", "Copyfile", "copyFiles", " copyfile", " copyStream", "transferFile", "transferfile", " copyFiles", "transferStream", "CopyFiles", "CopyFile", "transferFiles", "copyfile", "copyStream"], "in": ["reader", "bin", "connection", "login", "data", "name", "at", "ins", "m", "ex", "min", "In", "base", "b", "inner", "again", "work", "IN", "ini", "i", "source", "image", "inc", "or", "exec", "url", "io", "inn", "c", "file", "up", "id", "index", "a", "input", "ac"], "out": ["x", "connection", "data", "name", "point", "at", "to", "p", "ex", "outs", "base", "conn", "w", "b", "output", "again", "cache", "user", "part", "writer", "off", "o", "dest", "OUT", "temp", "client", "call", "source", "inc", "exec", "object", "v", "n", "server", "io", "c", "file", "up", "prefix", "result", "target", "Out"], "sourceChannel": ["srcSocket", "sourceChan", " sourceConnection", "ourceChan", "resourceConnection", " sourceSocket", "SourceChan", " sourceStream", "targetStream", "targetchannel", "resourcechannel", "sourceConnection", "targetChannel", "srcChannel", "resourceChannel", "srcChan", "sourceStream", "resourceChan", "sourcechannel", " sourcechannel", "ourceSocket", "ourceConnection", "sourceSocket", "SourceConnection", "ourcechannel", "SourceStream", "ourceChannel", "SourceChannel", "srcConnection", "Sourcechannel", " sourceChan", "targetChan"], "destinationChannel": ["destinatedFile", "DestinationChannel", "destinatorConnection", "destationConnection", "Destinatorchannel", "destinatedConnection", "destinateConnection", "destationchannel", "DestinationStream", "destinationFile", "destationFile", "destinationStream", "Destinationchannel", "destructionChannel", "destinationConnection", "DestinationFile", "DestinatingChan", "DestinatorChannel", "DestinationConnection", "DestinatingStream", "destinatorChannel", "destinatedStream", "destinationchannel", "destinatingChannel", "destinatorChan", "DestinatorConnection", "destinatorStream", "destationChannel", "destinateChan", "DestinatorChan", "destinatingManager", "destructionConnection", "destinatedchannel", "destinationManager", "DestinatorFile", "destinatingChan", "destinatorManager", "DestinationManager", "destinationChan", "DestinatingChannel", "destinatedChan", "destinatingStream", "destinatorFile", "destinatedManager", "DestinationChan", "destinatorchannel", "destructionChan", "DestinatingManager", "destinateChannel", "destinatedChannel"]}}
{"id1": "19584877", "id2": "21348951", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2Stream", "encodeFileFromStream", "encodeFile2Stream", "encodeFileToString", "encodeFileToStream", "encodeFiletoFiles", "encodeFileFromString", "encodeFile2String", "encodeStringToFiles", "encodeStringToString", "encodeStringToStream", "encodeFiletoFile", "encodeFileToFiles", "encodeFiletoString", "encodeString2Files", "encodeString2File", "encodeFile2File", "encodeString2String", "encodeFile2Files", "encodeFileFromFile", "encodeFileFromFiles", "encodeStringToFile", "encodeFiletoStream"], "infile": ["infilename", "Infile", "inputfiles", "outfp", "inputfilename", " infp", "Infilename", "outfiles", "outfilename", "infp", "infiles", " infiles", "inputfile", "Infiles", "inputFile", "outFile", "inFile", "inputfp", " infilename", "InFile"], "outfile": ["infilename", "newfolder", "newFile", " outfilename", "newname", "Outfile", "outfp", "newfile", "outputfilename", "outputfolder", "outfolder", " outname", "Outfolder", "outfilename", " outFile", "infp", "infolder", "outname", "OutFile", "Outname", " outfolder", "outFile", "outputfile", "outputfp", " outfp"], "in": ["r", "image", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "a", "inner", "vin", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "base", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "on", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "work", "file", "line", "post", "o", "no", "exec", "base", "lib", "session", "err", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "source", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "fb", "buff", "raw", "value", "count", "uffer", "len", "iter", "url", "buf", "binary", "null", "base", "data", "type", "b", "border", "offset", "split", "wave", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "input", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "close", "end", "pass", "exec", "wait", "allow", "ride", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "respons", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "content", "failed", "response", "message", "successful", "path", "results", "modified", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "8953394", "id2": "23531898", "code1": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 1, "substitutes": {"update": ["create", "end", "write", "with", "edit", "up", "UPDATE", "run", "replace", "set", "sql", "updated", "apply", "Update", "query", "join", "select", "place", "build", "alter", "ite", "save", "database", "connection", "execute", "exec"], "statement": ["script", "storage", "ment", "sequence", "Statement", "usage", "text", "message", "use", "string", "status", "sql", "condition", "session", "state", "sn", "query", "join", "stat", "result", "commit", "mt", "response", "command", "expr", "expression", "name", "report", "data", "str", "value", "database", "timeout", "connection", "execute", "source"], "con": ["com", "log", "conv", "login", "ion", "can", "crit", "syn", "cons", "trans", "pc", "cur", "fc", "ca", "exec", "cache", "conn", "CON", "ran", "c", "cf", "cr", "rc", "m", "ci", "en", "container", "an", "commit", "xc", "client", "cc", "Con", "cas", "cm", "co", "tc", "ec", "cn", "connect", "lock", "mc", "Conn", "bc", "ctx", "connection", "uc", "db", "conf"], "do_log": ["Do_log", "do\u00b7put", "do_loc", "Do_print", "do_Log", "do_put", "do_print", "do\u00b7loc", " do_put", "do_bug", "do___put", "Do_bug", "do___log", " do_loc", "Do_Log", "do___loc", "do\u00b7log"], "s": ["j", "in", "o", "ans", "ops", "ls", "services", "ns", "l", "b", "js", "sql", "c", "r", "session", "g", "ps", "t", "d", "p", "ds", "conf", "si", "S", "os", "sb", "fs", "qs", "ins", "is", "ses", "hs", "es", "ssl", "a", "south", "h", "e", "ss", "u", "sl", "i", "n", "ks", "ts", "m", "f"]}}
{"id1": "17161805", "id2": "12417893", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"encode": ["enccode", "enccod", "encod", "recod", "Enode", "reoding", "recode", "encoder", "enscode", "encoding", "Enoder", "Enoding", "ensoder", "enscod", "enoder", "ensode", "reode", "enode", "Encode", "enoding", "Encod"], "plaintext": ["longform", "plainText", "batTEXT", " plaincontent", " plainstring", "batText", "battext", " plainText", "foreTEXT", " plainform", "plaincontent", "bodyText", " plainTEXT", "plainform", "longcontent", "foreText", "longText", "foretext", "longtext", "forestring", "bodycontent", "plainTEXT", "bodytext", "batstring", "bodyform", "plainstring"], "md": ["dd", "sha", "cmd", "meta", "metadata", "ma", "amd", " MD", "po", "hd", "mm", "um", "mad", "cd", "ms", "wd", "mp", "code", "grad", "mand", "d", "ind", "bd", "ad", "pm", "df", "sm", "mac", "gd", "od", "me", "MD", "mod", "dh", "pd", "mag", "rm", "dm", "mc", "mb", "di", "m", "rpm", "f"], "raw": ["enc", "dec", "Raw", "ghost", "ode", " Raw", "feed", "stream", "hex", "input", "serial", "alpha", "load", "local", " hex", "remote", "blocks", "array", "orig", "initial", "buffer", "pure", "ack", "custom", "rew", "original", "all", "out", "row", "micro", "block", "missing", "pack", "unsigned", "clean", "internal", "binary", "RAW", "unknown", "instance", "shared"]}}
{"id1": "15810440", "id2": "10547671", "code1": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 0, "substitutes": {"addRecipe": ["saveApplication", "setRecipe", "AddCourse", "addCourse", "setCourse", "addApplication", "AddRecipe", "setApplication", "addFood", "AddApplication", "saveCourse", "setFood", "AddFood", "saveFood", "saveRecipe"], "name": ["source", "create", "style", "filename", "table", "large", "path", "username", "ame", "config", "alias", "NAME", "home", "company", "title", "model", "plus", "family", "one", "word", "Name", "image", "none", "data", "names", "module", "comment", "old", "n", "description", "action", "class", "url", "base", "database", "search", "label", "mini", "admin", "time", "string", "connection", "size", "prefix", "full", "named", "file", "collection", "parent", "part", "version", "key", "template", "type", "common"], "instructions": ["inscription", "incriptions", "insemptories", "instruction", "instructations", "incriptures", "inscriptures", "incorrections", "insemption", "insstruction", " inscriptions", "incription", "insemptions", "inemptions", "inemptories", "injectutions", "injections", "injectures", "inemptutions", "insstructions", "instructs", "INSTRUCTion", "insstructes", "incorrectures", "INstruction", "inemptations", "inemptes", " instructures", " inscriptutions", "injection", "INSTRUCTions", "inscriptions", "inSTRUCTures", "incorrectories", "INstructions", "injects", "instructes", "inempts", "INSTRUCTures", "incorrection", " instructations", "inscriptories", " inscriptations", " instructutions", "incriptes", "insstructories", "INSTRUCTs", "inscriptutions", "instructories", "injectations", "insstructures", "injectes", "inemptures", "insemptures", "INstructs", "inSTRUCTs", "inSTRUCTion", "inemption", "instructutions", " inscriptures", "insemptes", "INstructures", "instructures", "inscriptations", "inSTRUCTions"], "categoryId": ["ategorySize", "channelSize", "CategoryId", "packageInfo", "categoryid", "channelid", "categoryCode", "channelId", "categoryType", " categoryID", "ategoryid", "CategoryInfo", "ategoryType", "currencyCode", " categoryInfo", " categoryCode", " categoryInt", "CategoryID", "categoryID", "currencyid", "categorySize", "channelType", "sectionID", "packageID", "currencyID", " categoryid", " categoryType", "categoryInt", "CategoryInt", "currencyId", "sectionid", "sectionId", "packageId", "ategoryId", "sectionCode", "packageInt", " categorySize", "categoryInfo"], "ainekset": ["aineeksette", "ainseksET", "raineeksset", "raineksets", "aineksheet", "aineksette", "aineksET", "ainscesset", "raineeksette", "aineeeksET", "ainesat", "raineeksets", "ainesset", "aineticsset", "ainesette", "aineksets", "aineeeksset", "ainsekset", "ainscesET", "aincesET", "ainnersset", "aincesset", "rainekset", "aineekset", "aineset", "ainesET", "ainewsset", "ainscesheet", "aineeksets", "ainesets", "ainseksset", "ainseksheet", "aineticsheet", "aineticsET", "ainesheet", "aineksset", "aineeksat", "ainewsET", "ainceset", "raineekset", "raineksette", "aineeksET", "aineksat", "ainewsat", "aincesheet", "raineksset", "aineeksset", "ainnerset", "aineeekset", "ainnersette", "aineeeksat", "ainsceset", "ainewset", "aineticset", "ainnersets"], "pst1": ["ppt1", "psth2", " pest0", "ppst1", "ppste0", "ppst3", "presteOne", " pstOne", "pcr2", "PstOne", "pest100", "pstr2", "Pct0", "psts0", "presteone", "pst55", " pst100", "psteone", "pste3", "pstone", "psp100", "pcr0", "pct1", "pstr0", " pcr0", "pstr1", "pmt55", " pcr2", "Pst55", "prestone", "preste2", "pcr1", "pctOne", "pct01", "ppst0", "PctOne", "pmt0", "Pst1", "Pct2", "pft2", "pct2", " pcr01", "pSTone", "preste1", "pst3", "pstsOne", "psp1", "pstr55", "pst01", "pste1", "pctone", "pmt2", "pST2", "Pst0", "prest2", "pST1", "pptOne", "pest1", "ppste1", "pspOne", "pst100", "pct55", "pmt1", "pft1", "pst0", "psth1", "pste0", " pcr1", "pftOne", "pest0", "Pct1", "Pst2", "psts100", "pestOne", "psp0", "pste2", "pptone", "prestOne", " pst0", "pcr01", "psth01", "pct0", "Pstone", "Pctone", " pest1", "pct3", "psth0", " pest100", "pSTOne", "ppste2", "ppt2", "pftone", "psteOne", "prest1", "psts1", "Pct55", " pst01", " pestOne", "ppst2", "ppste3", "pstOne"], "pst2": ["pct6", "qst2", "pv2", "psth2", "qest25", "post5", "ppr2", "pst10", "qst02", "Pct10", "ppr1", " pmt1", "pst6", "pv1", "pct5", "qst25", "pmtSecond", "pct1", "pctSecond", "pct2012", "pct02", "pct4", "psth6", " post5", "pstSecond", "psth4", "qst1", "pkt2", " psth0", "pSTTwo", "qest1", "pct10", "pkt2012", "pxt1", "pv6", "pctTwo", "Pst1", "post2", "Pct2", "pct2", "pct25", "post1", " post2", "pest02", "pstd1", "pstd4", "pst5", "Pct6", "pkttwo", "pstTwo", "pxt2", "pste1", " psth2", " psth4", "pmt2", "pST2", "pest2", "pst25", "pxttwo", "psth10", "pST1", "pcttwo", " pstTwo", " pstSecond", " psth1", "pest1", " pmt2", "pstdSecond", "pest25", "pmt1", "pst0", " postTwo", "psth1", "qest2", "pste0", "ppr02", "postTwo", "qest02", "Pct1", "Pst2", "pkt1", " pmt4", "pst4", "Pcttwo", "Pst2012", "pmt4", " post1", "Pct2012", "pste2", "pxt2012", " pst0", "pste4", "pv10", "pct0", "psttwo", "pst2012", "pST5", "pstd2", "psth0", "Psttwo", "Pst6", "pst02", " pmtSecond", "Pst10", "ppr25", " pst5", " pst4"], "rs": ["ls", "as", "ris", "cs", "rx", "ps", "s", "ars", "rr", "mr", "ers", "ds", "hs", "RC", "errors", "RS", "ws", "sr", "ras", "ros", "ks", "ms", "qs", "hr", "rd", "cr", "rl", "bs", "sl", "res", "rss", "rc", "Rs", "ins", "acks", "yr", "rys", "xs", "details", "pr", "vers", "gs", "repl", "runs", "rt", "ows", "row", "r", "results", "rh", "js", "rows", "rg"], "retVal": [" retRet", "authVal", "RetVal", "authValue", "RETTx", "RetValue", "retRet", " retValue", "returnValue", "returnRes", "retValue", "altValue", "RETVal", "retVAL", "RETRet", "returnVal", "altRes", "altRet", "Retval", " retRes", "authVAL", "retTx", "altTx", "altVal", " retval", " retVAL", "retval", "retRes", "altval", " retTx", "returnval", "RetVAL"], "id": ["p", "kid", "uid", "ref", "result", "Id", "rid", "str", "path", "cat", "f", "alias", "info", "root", "ident", "max", "count", "in", "bid", "vid", "ip", "ide", "error", "url", "num", "it", "code", "gen", "number", "index", "string", "ID", "sid", "lit", "def", "pid", "value", "version", "row", "key", "aid", "end", "type", "start", "ids", "d"], "aines": ["ginse", "ansES", "AINse", "anses", "raine", "ansences", "rainences", "ainences", "aine", "AINe", "ainsse", "raines", "ainsetics", "gines", "ainetics", "ainss", "versens", "dons", "done", "rainetics", "ainsens", "rouetics", "verses", "dones", "ainens", "ainsES", "ainse", "rainES", "versse", "AINes", "ainES", "roue", "ainsess", "rainens", "donse", "ginES", "ains", "AINess", "rains", "gine", "rainess", "verse", "ainses", "roues", "rainse", "rouse", "anse", "ainess", "ainsences"], "i": ["p", "x", "uri", "z", "c", "ni", "ai", "gi", "ii", "info", "ori", "e", "ie", "one", "l", "I", "ci", "uli", "yi", "ini", "in", "multi", "ip", "n", "bi", "iu", "io", "si", "u", "b", "it", "ti", "is", "ui", "pi", "oi", "li", "index", "j", "hi", "mi", "di", "qi", "y", "xi", "part", "fi", "t", "o", "v", "d", "phi"]}}
{"id1": "14598566", "id2": "7149578", "code1": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"copyFileByNIO": ["copyFileBynIO", "copyFileByMIP", "copyFilebynio", "copyFileByFileIF", "copyFilebynIO", "copyFileByNIP", "copyFilebynIP", "copyFileByMIF", "copyFileBynio", "copyFileByFileio", "copyFilebyNIP", "copyFileByNio", "copyFilebynIF", "copyFileByMIO", "copyFileByNIF", "copyFileBynIF", "copyFilebyNIO", "copyFileByFileIO", "copyFileBynIP", "copyFileByFileIP", "copyFilebyNIF", "copyFileByMio", "copyFilebyNio"], "in": ["image", "m", "buffer", "h", "inn", "i", "input", "copy", "id", "ex", "din", "diff", "or", "connection", "inner", "index", "resource", "io", "ini", "at", "file", "part", "x", "min", "url", "base", "login", "data", "ac", "b", "ins", "name", "bin", "In", "reader", "IN", "again", "source", "c", "inc"], "out": ["Out", "image", "client", "writer", "buffer", "p", "n", "output", "object", "copy", "ex", "cache", "to", "conn", "target", "connection", "path", "ext", "resource", "io", "dest", "file", "at", "part", "prefix", "o", "exec", "data", "b", "v", "w", "name", "external", "again", "string", "project", "outs", "source", "OUT", "c", "inc"], "sourceChannel": ["ourceQueue", "srcChannel", "SourceStream", "srcChan", "ourceChan", "sourceChan", " sourceStream", "ourcechannel", "sourceServer", "sinChan", "sinStream", "ourceStream", "innerChan", " sourceQueue", "srcQueue", "srcConnection", "ourceChannel", "targetChannel", "sourceQueue", "targetchannel", "SourceConnection", "targetChan", " sourceServer", "innerStream", "sourceStream", "sourceConnection", " sourceChan", "sinServer", " sourcechannel", "SourceChannel", " sourceConnection", "innerServer", "targetConnection", "Sourcechannel", "innerChannel", "ourceConnection", "sinChannel", "sourcechannel", "SourceChan"], "destinationChannel": ["destributionChan", "DestinationStream", "DestinationChannel", "destinatedChannel", "destributionContext", "DestinatorClient", "destinateConnection", "destionChan", "destinationContext", "destinatedStream", "destroyingConnection", "destinationClient", "DestinationConnection", "destinatorConnection", "destroyingStream", "destionClient", "DestinationContext", "destributionConnection", "destinateStream", "destributionStream", "destinationConnection", "destributionChannel", "destinatorChannel", "destinateChannel", "DestinatorContext", "DestinationClient", "destionConnection", "DestinationChan", "DestinatorConnection", "destionChannel", "destinationStream", "destinatorClient", "destributionClient", "destinatorContext", "destinatorChan", "destroyingChannel", "DestinatorChan", "destinatedContext", "DestinatorChannel", "destinatedChan", "DestinatorStream", "destinatorStream", "destinationChan"]}}
{"id1": "15971794", "id2": "2217889", "code1": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public static InputStream getResourceAsStreamIfAny(String resPath) {\n        URL url = findResource(resPath);\n        try {\n            return url == null ? null : url.openStream();\n        } catch (IOException e) {\n            ZMLog.warn(e, \" URL open Connection got an exception!\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"getWave": ["getSound", "newwave", "readWave", "newWave", "readWire", " getwave", "newSound", " getSound", "readwave", "getwave", "readSound", " getWire", "newWire", "getWire"], "url": ["File", "image", "URL", "Ur", "lr", "wave", "fr", "feed", "base", "resource", "field", "inf", "F", "Url", "ff", "fe", "ref", "http", "filename", "l", "b", "page", "string", "r", "path", "fl", "uri", "fp", "Feed", "name", "word", "host", "file", "fn", "sf", "fax", "loc", "source", "web", "f", "address"], "Word": ["File", "Time", "Content", "Term", "Path", "Field", " word", "F", "Url", "Folder", "Length", "Wire", "Line", "Function", "Frame", "Words", "wd", "Eng", "Language", "W", "string", "Work", "Text", "Name", "Letter", "Token", "Tag", "Wave", "Code", "Gender", "Dir", "Weight", "World", "Class", "Msg", "Message", "Writer", "Hack", "word", "Win", "Rule", "Feature", "Str", "Part", "words", "Stream", "Key"], "FF": ["DF", "URL", "FC", "feed", "ELF", "Field", "Client", "Fi", "F", "RC", "ff", "P", "Folder", "FS", "FW", "TF", "IP", "fd", "FH", "IFF", "FM", "fp", "FILE", "SF", "FE", "Feed", "FB", "Fax", "LL", "DC", "AF", "FL", "FP", "FD", "IF", " ff", "CC", "BB", "FA"], "url2": ["url1", "path1", "urlTwo", "URL2", "pathDB", "pathTwo", "f4", " url3", "l2", "f2", "l4", " url4", "urlDB", " urlTwo", "url4", "URLDB", " url1", "URLTwo", "l3", " urlDB", "l1", "f3", "URL1", "f1", "path2", "url3"], "stream": ["flow", "video", "field", "in", "wave", "fr", "feed", "temp", "raw", "impl", "view", "coll", "form", "w", "forward", "input", "transform", "ff", "channel", "src", "http", "stack", "output", "slice", "writer", "string", "driver", "flash", "ack", "fd", "path", "handler", "source", "io", "steam", "v", "row", "response", "loop", "client", "context", "loader", "socket", "ssl", "live", "server", "file", "roll", "sl", "reader", "thread", "pipe", "sw", "Stream", "host", "f", "draft"], "Fdel": ["fdestroy", "FiDel", "ffin", "Fdestroy", "fdel", " Fdelete", "fdelete", "Ffin", " FDel", "fDel", " Ffin", "Fidelete", "Fifin", "Fdelete", " Fdestroy", "FDel", "Fidestroy", "Fidel"], "outstream": ["outputstream", " outStream", "inreader", "outlog", "outchannel", "outputmodel", "inwriter", "inputlog", "outreader", "outputwriter", "Outform", " outreader", "Outstream", "outputchannel", "inputchannel", "inputstream", "inStream", "outmodel", " outwriter", "inputStream", "outputreader", "OutStream", "outwriter", " outfile", "inlog", "outputform", "outStream", "inmodel", "outform", "outfile", "outputlog", "outputfile", "outputStream", "instream", " outmodel", "inchannel", " outform", "Outfile"], "bwriter": ["bwriters", " breader", " bbuilder", "bbWriter", "Bwrite", "bbwrite", "Breader", "outreader", "bbwriter", "fwriter", "bbwr", "bbreader", " bwriting", "Bwriter", "bwriting", " bwrite", "outwriter", "freader", " bWriter", "bbwriting", "bwrite", "fbwrite", "bbuilder", " bwr", " bwriters", "fbWriter", "outwr", "outwriting", "bbwriters", "bWriter", "fbwriter", "fbwriters", "bwr", "fbuilder", "breader", "fwrite", "Bbuilder"], "binput": ["outstart", " binpos", "bytestop", "binpos", " binset", "biwrite", "winstart", "biset", " binstart", "bistop", "binset", "winput", "bitset", "bitwrite", "binaryset", "output", "binarylog", "sincut", "byteput", "bipos", "outwrite", "byteset", "binsplit", "libcut", "biput", "libset", "winsell", "binwrite", "bisplit", "sinput", "libput", "sinlog", "binstart", "bincut", "binlog", "binaryput", " binsell", "binsell", " binstop", "bytesplit", "outsell", " binwrite", "binarycut", " binsplit", "sinset", "liblog", "winwrite", "bitput", "binstop", "bitpos"], "len": ["enc", "lc", "num", "base", "end", "coll", "fun", "val", "lf", "pre", "lan", "ls", "count", "rev", "lon", "l", "bin", "label", "ann", "cap", "pos", "hl", "li", "split", "fl", "en", "ie", "line", "part", "Len", "lim", "elt", "le", "length", "size", "la", "ln", "data", "lt", "low", "id", "limit", "el", "sl", " lang", "n", "iter", "seq", "dl", "fin", "lin"]}}
{"id1": "1485383", "id2": "18164929", "code1": "    private void runGetAppListing() {\n        DataStorage.clearAppListings();\n        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId);\n        AppListingList appListingList;\n        try {\n            HttpRequest request = requestFactory.buildGetRequest(url);\n            request.addParser(jsonHttpParser);\n            request.readTimeout = readTimeout;\n            HttpResponse response = request.execute();\n            appListingList = response.parseAs(AppListingList.class);\n            if (appListingList != null && appListingList.appListings != null) {\n                operationStatus = true;\n                DataStorage.setAppListings(appListingList.appListings);\n            }\n            response.getContent().close();\n        } catch (IOException e) {\n            AppsMarketplacePluginLog.logError(e);\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"runGetAppListing": ["runGetApplicationlistInfo", "runGetApplicationListling", "runGetApplicationListing", "runGetAppListInfo", "runGetApplisting", "runGetAppSearchInfo", "runGetApplistInfo", "runGetApplicationListInfo", "runGetAppSupportInfo", "runGetApplistling", "runGetApplicationListings", "runGetApplicationlistling", "runGetAppSearching", "runGetAppSearchling", "runGetAppSearchings", "runGetApplicationlistings", "runGetAppSupportling", "runGetAppSupporting", "runGetApplicationlisting", "runGetAppListling", "runGetApplistings", "runGetAppSupportings", "runGetAppListings"], "url": ["image", "client", "buffer", "service", "i", "host", "proxy", "feed", "e", "route", "page", "json", "server", "address", "result", "connection", "http", "location", "URL", "resource", "path", "ssl", "build", "file", "f", "Url", "api", "base", "channel", "data", "builder", "download", "b", "l", "string", "href", "uri", "re", "source", "config"], "appListingList": ["appListingType", "appListingingGroup", "appListininglist", "appListitingData", "appListillingLibrary", "appListingLayer", "appHoldinglist", "appListingInfo", "appListningResult", "appLingList", "appListiningList", "appListningList", "appListINGL", "appListinglist", "appListingResult", "appPoolinglist", "appListingsLayer", "appListingingLibrary", "appListingMap", "appPoolingList", "appListillinglist", "appListdingList", "appListingingList", "appPooliningGroup", "appHoldingType", "appListitingResult", "appListitingEx", "appListdingLayer", "appListitinglist", "appPoolingGroup", "applistningResult", "appListitingLibrary", "appListinginglist", "appLeningList", "appListningData", "applistingResult", "appStingEx", "appPooliningList", "appListitingList", "appListninglist", "appListingData", "appListingEx", "appListdingEx", "appListingsList", "appListdingL", "appLingEx", "appStINGL", "appListeningInfo", "applistningList", "appHoldingingList", "appListgingEx", "applistingData", "appListINGEx", "appListillingType", "appListingLibrary", "appLingInfo", "appListINGLayer", "appStINGList", "appHoldingingType", "appListingsL", "appHoldingLibrary", "appListingsInfo", "appListitingType", "appHoldingingLibrary", "appListingL", "appListningEx", "appListiningGroup", "appListgingInfo", "applistingEx", "appStingList", "appHoldinginglist", "appListillingList", "appLeningMap", "appListingsEx", "applistningEx", "appListingsMap", "appListningGroup", "appLeningEx", "appListingsResult", "appLeningInfo", "applistningData", "appStingL", "applistingList", "appListINGList", "appStINGEx", "appListgingList", "appListingsData", "appStINGLayer", "appListeningEx", "appListingGroup", "appHoldingList", "appListingingType", "appListgingMap", "appListeningList", "appStingLayer", "appListeningMap", "appLingMap", "appPoolininglist"], "request": ["get", "job", "r", "next", "client", "buffer", "writer", "service", "rate", "query", "hello", "queue", "q", "transfer", "object", "use", "proxy", "input", "user", "parse", "e", "page", "json", "server", "address", "complete", "child", "result", "http", "resource", "report", "message", "xml", "build", "post", "req", "trip", "callback", "builder", "application", "method", "call", "have", "Request", "remote", "project", "command", "push", "uri", "re", "create", "condition"], "readTimeout": ["writeTime", "writeSocket", "readertimeout", " readtimeout", "readingAttempt", "writeTimeout", "readingtimeout", "readingTimeout", "readtimeout", "readingSocket", "readTime", " readSocket", " readTime", "readerTime", "readSocket", "readAttempt", "writeAttempt", "readerAttempt", "readingTime", "readerTimeout", "writetimeout"], "response": ["next", "image", "success", "error", "client", "writer", "stream", "received", "full", "output", "reply", "object", "feed", "version", "e", "page", "json", "server", "result", "connection", "http", "array", "resource", "report", "message", "Response", "resp", "api", "onse", "data", "status", "application", "wave", "document", "res", "site", "body", "respond", "generation", "re"]}}
{"id1": "300397", "id2": "536614", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrap", "readandRewrites", "readAndRewwrite", "readandrewrites", "readandRewrap", "readAndSwwrite", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readAndRebrites", "readAndRewrites", "readAndrewrites", "readandrewrite", "readandRewwrite", "readandrewrap", "readAndRebrite", "readAndSwrites", "readAndSwrite", "readAndRebrap", "readAndrewrap", "readandrewwrite", "readAndRewrap", "readandRewrite"], "inFile": ["inputFile", "outFiles", "oldFile", "loginfile", "oldFilename", "infile", "inputfile", "outfile", "loginFile", " inSourceFile", "loginFiles", "inSourceFile", "outSourceFile", "loginFilename", "inFiles", "InFiles", " infile", "InSourceFile", "oldfile", "oldFiles", "inputFiles", "outFilename", " inFilename", "inFilename", "InFile", "Infile", " inFiles", "inputFilename"], "outFile": ["processFILE", "newFile", "newStream", "Outfile", " outStream", "thisFILE", "outDir", "thisfile", "outfile", " outDir", "outStream", "outputFile", "processFile", "processPlace", "offFile", "processFilename", "outputPlace", "offFilename", " outfile", "OutStream", "newDir", "outputFILE", "outputFilename", "thisFile", "outPlace", "exFILE", "exFilename", "newfile", "exFile", "outFilename", "outputfile", "offPlace", "OutDir", "outFILE", "thisFilename", "exfile", "OutFile", "offFILE"], "iis": ["iais", "Iais", " iIs", "iiss", "Iis", "IIS", " iiss", "iiIs", "iniis", "iniiss", " iris", "iniIs", "ciris", "iniIS", "iiis", "ciIs", "iiris", "iniris", "Iiss", "iiiss", " iIS", "ciIS", "iiIS", "iIS", "iris", "ciis", "iIs", "ciiss", "ciais", " iais"], "dcmParser": ["dcrParser", " dpmPar", "dmParser", "dcmJar", "dcrPar", "DcmInstallation", "dmissionReader", "dpmPlugin", "dmissionParser", " dpmReader", "dkmParser", "dcrLoader", "dhemInstallation", " dcrReader", " dcmReader", "dmcJar", "dmissionPlugin", "dcmPar", "dpmInstallation", "dcmHandler", "dpmHandler", " dpmparser", "dmLoader", "dpmPolicy", "dpmParser", "dcmPlugin", "dmmParser", " dcmLoader", " dpmJar", "dcmLanguage", "DcmJar", "dcrPlugin", " dpmarser", " dcmparser", "dmcPar", " dcmPar", "dmcParser", " dcrPlugin", "dkmPolicy", "dpmPar", "dCMLoader", "dpmLoader", "dbmPlugin", "dCMParser", " dpmHelper", "fcmReader", "dbmParser", "dCMHandler", "fpmReader", "dcrReader", "dkmPlugin", " dcmPolicy", "fpmHandler", "fcmparser", "dpmarser", "dmmparser", " dcmarser", "dbmPolicy", "dpmLanguage", "dcrJar", "dmoduleJar", "dmoduleparser", " dpmParser", "fcmHandler", "dmcarser", "dpmReader", "dcmPolicy", "dcmLoader", "dcmHelper", " dcmJar", " dcmPlugin", " dpmPlugin", "dpmparser", "dmoduleReader", "dmPlugin", " dcmHelper", "dhemJar", "dcmarser", "fpmparser", "dbmHelper", " dpmLoader", " dpmLanguage", "dmReader", " dcrLoader", "dcmparser", " dpmPolicy", "dmissionLanguage", "dhemParser", "dmmLoader", "dmodulePlugin", "dcrarser", "fpmParser", "dCMReader", "dCMPlugin", "fcmParser", "dCMparser", " dcmLanguage", "dcmInstallation", "dmoduleParser", " dcrParser", "DcmReader", "dhemReader", "dpmHelper", "dpmJar", "dmmPlugin", "dcmReader", "DcmParser", "dkmHelper"], "ds": ["cdn", "df", "ts", "asi", "data", "iss", "vals", "eps", "s", "icks", "bs", "dd", "ins", "services", "sync", "session", "ns", "da", "Ds", "utils", "os", "sys", "cs", "ld", "ls", "ys", "di", "conn", "parts", "is", "rs", "drivers", "dds", "Db", "dr", "dc", "d", "ras", "nas", "gd", "db", "points", "qs", "js", "ws", "tes", "DS", "Os", "xs", "uds", "vs", "gs", "ays", "ps", "details", "ils", "ants", "des", "src", "amps", "ros", "dat", "ss", "pd", "ads", "tx", "ks", "dt"], "pdReader": ["hdLoader", "pdRunner", "pbReader", "hdStream", "ddRunner", "dsreader", "dsReader", "ddLoader", "pdLoader", "pdStream", "pcLoader", "xdReader", "pcReader", "dsRead", "pbRunner", "pdreader", "pcWriter", "ddStream", "ddReader", "hdreader", "xdreader", "dsLoader", "xdWriter", "pdRead", "pbLoader", "pcRead", "hdWriter", "hdRead", "xdRead", "pbStream", "hdRunner", "hdReader", "dsWriter"], "out": ["lock", "ext", "login", "data", "doc", "name", "at", "down", "outs", "ssl", "w", "err", "flow", "o", "dot", "cli", "oder", "exec", "url", "default", "null", "io", "as", "co", "exp", "over", "point", "later", "session", "auto", "to", "sys", "page", "cache", "conn", "inner", "output", "term", "her", "key", "client", "builder", "outer", "parent", "order", "group", "code", "up", "word", "result", "director", "copy", "model", "with", "part", "line", "writer", "temp", "external", "lib", "image", "inc", "store", "Out", "obj", "device", "full", "connection", "manager", "s", "dev", "array", "sync", "layer", "ex", "gen", "base", "user", "again", "img", "password", "OUT", "list", "db", "child", " in", "object", "pass", "net", "in", "file", "diff", "write"], "dcmEncParam": ["dcmEstPar", "dcmDecPart", "dcmEncParameter", "dcmEncPart", "dcmElType", "dcmEnParameter", "dcmArchParameter", "dcmEnPar", "dcmDecArg", "dcmEnType", "dcmEstParameter", "dcmEstParam", "dcmArchArg", "dcmSecPart", "dcmDecParameter", "dcmEnPart", "dcmDecType", "dcmDecParam", "dcmEncPar", "dcmSecPar", "dcmSecParam", "dcmEncArg", "dcmEncType", "dcmElPar", "dcmEstType", "dcmElParameter", "dcmDecPar", "dcmEnArg", "dcmSecType", "dcmEnParam", "dcmArchParam", "dcmElParam"], "pdWriter": ["dsWrite", "PDWriting", "dpWriter", "pdWriting", "dsReader", "hdWrite", "dpWrite", "htWriting", "PDReader", "ddWrite", "dsOutput", "hdOutput", "PDWrite", "ddReader", "dpReader", "htReader", "pdOutput", "ddWriter", "pdWrite", "htWrite", "ddOutput", "PDWriter", "htWriter", "hdWriter", "hdReader", "dsWriter", "dpWriting"]}}
{"id1": "4481712", "id2": "14464131", "code1": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"deleteObject": ["deleteObj", "removeItem", "saveItem", "saveObj", "saveDB", " deleteItem", "removeObject", "saveObject", " deleteObj", "deleteItem", "deleteDB", "removeDB", " deleteDB", "removeObj"], "id": ["url", "ip", "error", "delete", "ids", "model", "path", "sql", "string", "name", "lock", "Id", "sid", "database", "oid", "type", "i", "pid", "info", "root", "object", "parent", "query", "uri", "api", "resource", "key", "it", "in", "data", "source", "create", "ident", "uid", "ID", "f", "rid"], "conn": ["exec", "cm", "lc", "cf", "mc", "error", "client", "ca", "ai", "ann", "cache", "ou", "cb", "cur", "db", "log", "comm", "connect", "sql", "host", "core", "cr", "cp", "cms", "cmd", "lock", "c", "ci", "cc", "err", "rt", "auth", "org", "ct", "ec", "ssl", "connection", "Connection", "n", "parent", "config", "loc", "co", "nt", "enc", "nw", "cond", "sync", "dc", "orp", "pg", "h", "rc", "col", "cli", "pool", "cn", "ch", "server", "act", "coll", "pc", "con", "nc", "ac", "cat", "Conn", "serv", "conf", "ctx", "cmp", "po"], "stmt": ["stm", "tmm", " stql", "pttx", "strmi", "Stmp", " stm", " stmn", "Stmd", "Stm", " stmm", "strql", "strmn", " sttx", "stql", " stmr", " stmb", "stma", "istmt", "tmt", "dmb", "strmb", "dmt", "strtx", " stma", "stmd", " stmi", "dma", "strmm", "Stmb", "sttx", "istm", "Stma", " stmp", "Stmn", "istmr", "stmr", "strmt", "stmn", "ptql", "ptmt", "strmd", "tm", "stmi", " stmit", "Stmr", "stmm", "stmit", "istmit", "strmr", "stmp", "Stmi", "ptmn", "Stmt", "dm", "Stmm", "strm", "stmb", "strmp", " stmd", "tmn", "Stmit"], "dbConn": ["bbConnection", "dbConnection", "databaseconn", "bbconn", "databaseConnect", "dbconn", "bbConn", "bdConnect", "cbConn", "dbCon", "bdCon", " dbConnect", " dbConnection", "databaseConn", "bdConnection", "cbConnection", "cbConnect", "bdConn", "bbConnect", "databaseConnection", " dbconn", " dbCon", "dbConnect", "cbCon"], "selfConnection": ["selfReference", "thisConn", "SelfConn", "passconnection", "selfconnection", " selfConnect", " selfconnection", "selfConnect", "selfConn", "passConn", "thisconnection", "thisConnection", "SelfReference", "Selfconnection", "passConnect", "parentConnection", " selfConn", "SelfConnect", "parentconnection", " selfReference", "parentConn", "parentConnect", "passReference", "passConnection", "thisConnect", "thisReference", "SelfConnection"]}}
{"id1": "13757855", "id2": "18693224", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"process": ["resource", "create", "submit", "view", "transform", "project", "parse", "load", "run", "processing", "output", "update", "code", "path", "build", "proc", "cess", "evaluate", "handle", "Process", "request", "construct", "call", "exec", "processor"], "tpl": ["Tpp", "templates", "tml", "Tbl", "qtple", "lPL", "atpl", "psl", "itpl", " tplug", "Tplates", "ttemplate", "tmpl", "tplates", " tple", " tper", " tplate", "lml", "temPL", "atplate", "tplate", " ttemplate", "tcp", "Ttemplate", "fplug", "Tml", "lcl", "TPL", "tbl", "Tsl", " tfc", "fplate", "tipl", "latcp", " tipl", "Tpl", "atml", "stPL", "Tipl", "pipl", " tbl", "qtcp", "lplate", "tplug", "Tple", "qtpl", "atplug", "Tper", "itplates", "tsl", "temtemplate", "tfc", "tple", "qtbl", "latpl", "lpl", "fpl", "tPL", "itPL", "pPL", "tpp", " tcl", "tcl", "lper", "tmyl", "itplate", " tPL", "ppl", "latyl", "tmcp", "qtfc", " tplates", "tper", "pcl", "stpl", " tsl", " tpp", "lple", "qtyl", "tmple", "templ", "latple", "stpp", "stplate", "Tfc", "Tcl", "fml", "Tplate", "tyl", " tml"], "model": ["body", "log", "graph", "module", "Model", "config", "json", "param", "message", "media", "params", "node", "m", "doc", "result", "command", "where", "xml", "models", "language", "data", "document", "location", "project", "conf", "copy"], "packageName": ["PackageNames", "PackageName", " packagename", "groupName", "packageUrl", "modulename", "contextName", "groupUrl", "packageKey", " packageNames", "moduleUrl", "moduleKey", "contextInfo", "projectKey", "Packagename", "groupKey", "contextname", " packageInfo", "groupname", "projectName", "moduleName", "packageNames", "packagename", "projectUrl", "contextNames", "projectname", "PackageInfo", "packageInfo"], "outFileName": ["inFilePath", "outFileTime", "diffFileOnce", "OutDirNames", "outDirEnd", " outFullType", "inDirPath", "outBufferHalf", "outDirInfo", "outFileType", "outDirname", "outFullInfo", "outfileMode", "difffileInfo", "outfileOnce", "outLinename", "outDirCopy", "OUTFileHalf", " outFileInfo", "inDirEnd", "outDirTime", "diffFileInfo", "outFullType", " outFilePath", "outLineNames", "outFileOnce", "outFullTime", "outFileHalf", "outfileCopy", "OutDirName", "outRuleType", "outLineName", "outFilenameHalf", " outDirPath", "outLineOnce", "OUTBufferHalf", "outFullNames", "outFilenameCopy", "outFilesLine", "OUTBufferMode", "diffFileTime", "outFileInfo", " outFullInfo", "outDirName", "inDirCopy", "OUTBufferName", "outfileName", "difffileName", "outFileLine", "outFileEnd", " outFileTime", "OutFileName", "OutDirLine", "outFilenameName", "outFilesPath", "inFileCopy", " outDirTime", "OutFileNames", "OUTFileName", "outFileCopy", "outDirOnce", "diffFileName", "outfileTime", "outfilePath", "outFilePath", "OutDirname", "outFilename", "outBufferMode", "OUTFileNames", "OUTBufferNames", "outFilenamePath", " outFileLine", "difffileTime", "outStreamInfo", "outStreamType", "outLineInfo", " outDirName", " outFileType", "outfileInfo", "outFilenameEnd", "OutFileLine", "outFileMode", "outfileHalf", "outBufferName", "outDirLine", " outDirLine", "outFullname", "outfileEnd", "outFullPath", "outRuleInfo", "outBufferNames", "outStreamName", "OutFilename", "outRuleName", "inFileName", "outFullLine", "outfileNames", "outFilesTime", "outDirPath", "inFileEnd", "OUTFileMode", "outFilenameNames", "outFilesName", "outLineTime", "inDirName", "outDirNames", "outFullName", "outFilenameMode", "outFileNames", "outLineLine", "difffileOnce", " outFullName"], "xsltParam": ["xldVal", "xldMode", "xslicParam", "xsltparam", "xltVal", "xslpVal", "xsldVal", "xslpparam", "xslicVal", "xldParam", "xslpMode", "xslicparam", "xltparam", "xslpParam", "xsldParam", "xslicMode", "xsltMode", "xsldMode", "xsltVal", "xltParam", "xsldparam", "xldparam", "xltMode"], "artifact": ["aratifacts", "Artifact", "Artribution", "adverturation", "Artfact", "aratifact", " artribution", "arturation", "aratifest", "artfact", " artifacts", "ARTifacts", "ARTifact", "aratfact", "advertifacts", " arturation", "artifacts", "Artifest", "artribution", "Arturation", "ARTifest", "artifest", "advertifact", "ARTfact", "advertribution", "Artifacts"], "destinationPath": ["destiningpath", "distinatorName", "destinationspath", "constinationsPoint", "destiningName", "destinationsPath", "constinationWidth", "destinatedString", "restificationPoint", "destinationHandler", "datinatePath", "distributionCase", "destplingPath", "tempinationHalf", "desticationKey", "combinationHandler", "destinationPoint", "destinerPath", "desticationFile", "DestinationPart", "destiningDir", "constinationDir", "restinationHalf", "combinatorpath", "destributionDir", "desticationStep", "destinatedPoint", "distinationCase", "destinationsName", "destificationLog", "constinatorUrl", "destinationPart", "destinationStep", "destationLocation", "destificationName", "tempinatedHalf", "destinatorWidth", "destinateHalf", " destificationAuth", "destiningContext", "DestinationPoint", "constinatorWidth", "destinateDir", "destinationLocation", "destinatorContext", "constinationsPath", " destificationLog", "destinatingpath", "destinatedFile", "destationpath", "distinatorStep", "DestinatingPath", "destinatePart", "restinatorPath", "destificationLocation", "combinatorName", "tempinatedpath", "destinatedCase", "destplingUrl", "distinatorPath", "destplingLog", "destinationHalf", "DestinationText", "destributionCase", "datinationTime", "destinatorCase", "destinerContext", "destinatePoint", "destignmentCry", "restificationPath", "desticationPath", "datinationPath", "destinatepath", "tempinatedPath", "destinationCry", "constinationPoint", "destributionpath", "combinationPath", "destensionText", "destinatedDir", "combinationName", "destinatorFile", "destinatingText", "constinatorDir", "datinatepath", "destinatedKey", "DestificationName", "restificationLocation", "destignmentCase", "distinatorFile", "constinationspath", "constinationContext", "DestinatingText", "destcreationPath", "distinatorKey", "constinatorPath", "destinationName", "distinationDir", "restinationLocation", "destinateTime", "destificationPart", "destensionPath", "desticationPart", "distinatorCase", "destinateHandler", "restinationPoint", "destiationAuth", "destinatorUrl", "destificationAuth", "combinatorPath", "destinatorPath", "destplingAuth", "distinationFile", "destinationFile", "datinateTime", "destributionCry", "DestinatingPoint", "destiningPath", "destiationDir", "constinatorpath", "datinationLocation", "tempinationDir", "constinationUrl", "destinateText", "destensionPoint", "desturationHandler", "destiningPoint", "destificationDir", "destignmentPath", "destinatingPath", "tempinationPath", "desturationPath", "destinatorpath", "combinationpath", "destinationKey", "destinationpath", "constinatorContext", "destificationpath", "destinatorKey", " destinationLog", "destinateString", "datinateLocation", "destificationPoint", "destinatingLocation", "restificationpath", "destationPath", "destinationWidth", "destributionPath", "distinationPath", "destributionName", "destinatorString", "distinationKey", "destinatorCry", "tempinatedDir", "destinationAuth", "destinatingPoint", " destificationDir", "destcreationUrl", "DestificationPath", "destinerpath", "DestinationPath", "destinationLog", "destinationDir", "destplingDir", "distributionpath", "tempinationpath", "datinationpath", "destinatorHalf", "distinationStep", "destinationText", "restinatorString", "restinationPath", "distinationpath", "constinationsName", "restinationString", "destinatingName", "constinationName", "destinateName", "destiationLog", " destinationDir", "destinatorHandler", "destinatePath", "restinatorPoint", "destensionName", "destinatorTime", "distributionPath", "destinationCase", "destinatorPoint", "combinatorHandler", "desturationName", " destificationPath", "destinatorStep", "destinationsPoint", "destinatedPath", "destignmentName", "destiationPath", "distinationName", "destinationContext", "destinateLocation", "desturationpath", "destificationPath", "destinatedHalf", "destinatedStep", "DestinationName", "distributionDir", "destinatorName", "destinationTime", "destcreationWidth", " destinationAuth", "destinatorDir", "DestificationPart", "desticationName", "DestinatingName", "restinationpath", "destplingWidth", "destinatorLocation", "destationTime", "destinationString", "constinationPath", "destinatedpath", "distinatorCry", "destinationUrl", "distinationCry", "constinationpath", "destinerDir", "restinatorHalf"], "in": ["image", "input", "In", "cache", "bin", "c", "r", "IN", "t", "d", "doc", "source", "x", "min", "ins", "name", "con", "data", "ex", "reader", "i", "n", "connection", "config", "din", "inc"], "out": ["err", "log", "index", "pool", "o", "outer", "temp", "prefix", "point", "w", "write", "cli", "with", "version", "group", "up", "cache", "exec", "ne", "output", "OUT", "writer", "key", "list", "bin", "conn", "page", "post", "string", "full", "store", "session", "state", "again", "outs", "path", "free", "doc", "line", "part", "io", "result", "all", "Out", "client", "manager", "name", "sys", "dump", "user", "file", "server", "Output", "gen", "lock", "error", "ex", "comment", "str", "lib", "connection", "msg", "source", "parent", "obj", "copy"], "root": [" roots", "resources", "_", "index", "graph", "module", "options", " result", "history", "transform", "format", "json", "pattern", "Root", "cache", "roots", "cat", "r", "collection", "params", "path", "query", "node", "values", "xml", "loader", "tree", "id", "include", "modules", "instance", "results", "meta", "parent", "url"]}}
{"id1": "22411381", "id2": "14317425", "code1": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"stop": ["remove", "close", "release", "pause", "job", " Stop", "quit", "kill", "setup", "Stop", "reset", "end", "find", "run", "destroy", "save", "sleep", "next", "loop", "operation", "work", "get", "delete", "start", "status", "update", "create", "process"], "task": ["class", "temp", "resource", "master", "run", "patch", "match", "tag", "func", "component", "problem", "worker", "element", "module", "point", "server", "clean", "game", "lock", "ack", "query", "sync", "source", "load", "work", "parent", "channel", "route", "Task", "object", "device", "plugin", "test", "complete", "name", "again", "exec", "link", "this", "unit", "contract", "localhost", "process", "event", "job", "tc", "message", "act", "socket", "session", "request", "pack", "app", "question", "trace", "error", "view", "user", "slave", "table", "project", "instance", "thread", "manager", "key", "form", "type", "date", "target", "ask", "config", "data", "status", "t", "action", "call", "role", "command", "block", "tx"], "con": ["remote", "core", "tc", "Conn", "cc", "server", "resource", "CON", "cf", "clean", "cons", "lock", "ran", "rc", "c", "fc", "ctrl", "col", "Con", "co", "query", " conn", "en", "condition", "client", "sync", "cm", "session", "cp", "cache", "cas", "uc", "ion", "connection", "login", "common", "ch", "inc", "conv", "un", "ca", "config", "xc", "log", "null", "conn", "rec", "row", "ain", "coll", "exec", "ci", "cr", "ann", "db", "pc", "commit", "mc", "ctx", "sql", "bc", "ver", "can", "conf", "cn", "connect", "container", "f", "win", "re"], "s": ["ssl", "sum", "sc", "sf", "n", "sys", "fs", "sg", "ks", "ns", "c", "S", "j", "se", "l", "ins", "bs", "si", "o", "su", "is", "rs", "ws", "sb", "r", "ans", "w", "gs", "h", "p", "es", "sq", "u", "search", "submit", "south", "ls", "js", "e", "m", "rows", "ss", "sl", "a", "sql", "ses", "cs", "ds", "os", "f", "ps"], "result": ["event", "info", "sum", "server", "resource", "response", "uri", "rc", "user", "results", "res", "report", "http", "message", "json", "ge", "table", "instance", "record", "manager", "su", "ret", "session", "source", "cache", "rh", "reader", "ner", "r", "ch", "work", "data", "page", "request", "search", "row", "coll", "e", "status", "runner", "success", "db", "details", "ver", "ser", "comment", "ur", "err", "future", "successful", "Result", "error", "sr", "re", "view"], "url": ["string", "path", "base", "address", "job", "id", "uri", "feed", "http", "lr", "l", "host", "location", "URL", "key", "source", "str", "ob", "file", "route", "object", "request", "href", "ls", "e", "image", "link", "sl", "rl", "pull", "Url", "obj", "f", "hub", "loc"], "i": ["uri", "pi", "ini", "ie", "ic", "c", "ri", "o", "l", "si", "ui", "is", "in", "ii", "ori", "qi", "vi", "d", "phi", "r", "ami", "li", "ip", "h", "p", "bi", "u", "ai", "oi", "ci", "e", "io", "I", "m", "eni", "it", "iri", "xi", "gi", "di", "ib", "a", "isi", "v", "abi", "iu", "f", "cli", "esi", "api"], "b": ["string", "base", "bf", "bd", "bh", "emb", "http", "eb", "lb", "c", "cb", "o", "l", "bs", "orb", "bin", "pb", "bg", "gb", "mb", "abb", "rb", "d", "ab", "sb", "wb", "buff", "lib", "buf", "ob", "body", "fb", "p", "e", "nb", "db", "bytes", "ib", "bc", "B", "bl", "y", "br", "ba", "f"], "bb": ["buffer", "base", "BB", "bf", "feed", "bd", "ok", "eb", "cb", "obb", "gg", "bin", "pb", "key", "char", "gb", "mb", "abb", "rb", "ab", "sb", "buff", "BBC", "ob", "fb", "bi", "bn", "nb", "db", "ib", "bc", "xb", "batch", "dd", "ogg", "boot"], "ll": ["BB", "lf", "kl", "lp", "lb", "wl", "z", "lr", "l", "col", "el", "nn", "LL", "ii", "ld", "dl", "fl", "la", "lla", "lc", "len", "ell", "ql", "cl", "nl", " l", "ls", "vl", "rl", "ln", "bl", "bm", "lv"], "k": ["ak", "sk", "ko", "n", "id", "ok", "ke", "kl", "ck", "ks", "dk", "j", "o", "uk", "K", "key", "ku", "unk", "d", "tk", "pp", "q", "kk", "r", "g", "work", "kid", "p", "x", "u", "m", "kw", "ky", "kin", "ikk", "ka", "f", "kn", "ik"], "s2": ["ws2", "s02", "Stwo", " sII", "STwo", " s4", "u2", "ds4", "s20", " s02", "js10", "utwo", " s10", " s8", " s0", "wstwo", "s8", "sum2", "su02", "wsTwo", " s20", "S5", "dsII", "c02", "su2", "ws5", "js0", "s96", "su1", "sII", "s10", "c2", "S2", "ds2", "s1", " s1", "sum10", " s96", "c1", "SII", "c20", "S4", "su20", "s0", "sTwo", "stwo", "js96", "u5", "sum96", "js2", "s5", "s4", "ds8", "uTwo", "sum0", "S8"]}}
{"id1": "20855053", "id2": "742465", "code1": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"init": ["process", "connect", "loading", "load", "app", "construct", "install", "parse", "handler", "Init", "check", "register", "info", "boot", "resource", "Initialized", "build", "start", "activate", "loader", "log", "test", "it", "strap", "setup", "create", "config", "launch"], "context": ["request", "sc", "component", "obj", "tx", "ctx", "ce", "cc", "app", "parent", "e", "ex", "cf", " contexts", "or", "bc", "http", "exc", "req", "vc", "cl", "pc", "processor", "cms", "Context", "config", "c", "ec"], "classLoader": ["ClassWriter", "logPath", "objectLoad", "resourcePath", "ClassLoading", "objectLoader", " classLoading", "ClassPath", " classWriter", "logloader", "classWriter", " classloader", " classReader", "logWriter", "ClassLoad", "classPath", "resourceLoading", "classReader", "classloader", "logLoader", "ClassLoader", "classLoading", " classPath", "objectReader", "Classloader", "objectloader", "classLoad", "ClassReader", "resourceloader", "resourceLoader", " classLoad"], "urls": ["urlps", "URLches", " urllines", "resourcelines", "httpions", "sls", "URLps", "resourceions", "URLs", " urlps", "webs", "URLions", "webches", "webls", "resourcels", "urlis", "resources", "slls", "slches", "webis", "urlls", "urlions", "URLlines", "https", "resourceps", "httplines", "URLis", "urllines", "httpls", "urlches", "URLls", "slis", " urlls"], "url": ["lr", "r", "job", "image", "ball", "buffer", "sl", "ul", "element", "entry", "rl", "full", "host", "class", "object", "feed", "user", "layer", "ls", "bb", "id", "page", "coll", "server", "address", "loc", "result", "connection", "found", "http", "URL", "resource", "li", "pull", "io", "path", "ssl", "file", "link", "f", "Url", "channel", "base", "err", "gl", "loader", "b", "rel", "org", "ll", "name", "l", "browser", "string", "uri", "source"], "reader": ["r", "iterator", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "i", "feed", "ro", "input", "e", "rx", "handler", "server", "per", "or", "ler", "editor", "resource", "io", "keeper", "rr", "row", "reading", "file", "rar", "iter", "ri", "re", "loader", "er", "oder", "l", "upper", "parser", "read", "layer"], "className": ["stringType", " classDescription", "typeLine", "stringName", "lassType", "ClassPath", " classInfo", "Classname", "classString", "staticType", " classCode", "typeInfo", " classValue", "CLASSType", "classText", "stringInfo", "ClassLine", "clName", "urlName", "objectPath", "objectNumber", "clCode", "clInfo", " classString", "lassEl", " classNumber", "classLine", "urlname", " classPath", "caseDescription", "caseLine", "typeName", "clNumber", "staticname", "classDescription", "clString", "urlText", "lassBase", "classname", "clText", " classname", "classPath", " classType", "lassInfo", "classInfo", " classText", "objectname", "clBase", "staticEl", "CLASSName", "objectName", "classBase", "clname", "classType", "urlValue", "caseValue", "caseName", "typeType", "CLASSEl", "staticName", "objectString", "CLASSname", " classLine", "stringLine", "ClassString", "clValue", "classCode", "lassname", "classValue", "classEl", "lassCode", " classBase", "clPath", "lassName", "ClassValue", "classNumber", "ClassDescription", "ClassName"], "clazz": ["clclass", " cllass", "Clazz", "plade", "cluster", "class", " clclass", "clade", "Class", "glass", "gllass", "classazz", "classuster", "cllass", "pllass", "classlass", "glade", "classclass", "plazz", "glazz", "plass", "Cllass", "Clclass", "Clade", "Cluster", " cluster"]}}
{"id1": "5760649", "id2": "21092340", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "label": 1, "substitutes": {"createFile": ["CreateContent", "createContent", "CreateFolder", "saveFile", "createFolder", " createFolder", "saveContent", "createResource", "saveFolder", "saveResource", " createResource", " createContent", "CreateResource", "CreateFile"], "src": ["fp", "url", "sit", "img", "gb", "load", "proc", "path", "sl", "input", "string", "name", "s", "obj", "stream", "secure", "Source", "resources", "upload", "ruby", "files", "sel", "username", "SourceFile", "ssl", "sb", "r", "buf", "dest", "loc", "slice", "uri", "rob", "resource", "rb", "content", "rc", "href", "source", "data", "file", "fn", "sc", "rss", "txt", "cb"], "filename": ["fp", "url", "rl", "FILE", "title", "sf", "dll", "output", "metadata", "ame", "fil", "which", "ames", "ename", "path", "utf", "nil", "location", "name", "string", "length", "s", "prefix", "files", "username", "SourceFile", "route", "directory", "loader", "wb", "uri", "resource", "feat", "l", "source", "fn", "file", "txt", "Filename", "f", "acl"], "fis": [" fIS", " fiss", "fais", "fris", "cfis", "sfos", " fais", " fbs", "fIS", "sfris", "cfais", "Fris", "cfIS", "Fos", "Fbs", "Fis", "fbs", "Fiss", "sfiss", "FIS", "fiss", "cfos", "cfris", "cfbs", "Fais", " fris", "sfis"], "fos": ["FOS", "affbos", "sfos", "fOS", "foras", "sfops", "Fops", "bbos", "bis", "forOS", "sfios", " fOS", " fas", "foros", "Fos", "foris", "Fbos", "Fis", "fas", "fios", " fops", "affis", "bos", "affios", "Fios", "affos", "bios", " fios", "Fas", "fbos", "fops", "sfis"]}}
{"id1": "20929570", "id2": "23517481", "code1": "    public static String toMd5(String str) {\n        MessageDigest messageDigest = null;\n        try {\n            messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.reset();\n            messageDigest.update(str.getBytes(\"UTF-8\"));\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException caught!\");\n            System.exit(-1);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte[] byteArray = messageDigest.digest();\n        StringBuffer md5StrBuff = new StringBuffer();\n        for (int i = 0; i < byteArray.length; i++) {\n            if (Integer.toHexString(0xFF & byteArray[i]).length() == 1) md5StrBuff.append(\"0\").append(Integer.toHexString(0xFF & byteArray[i])); else md5StrBuff.append(Integer.toHexString(0xFF & byteArray[i]));\n        }\n        return md5StrBuff.toString();\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"toMd5": ["toBd512", "toMcd7", "toMm7", "toBd5", "toMmd15", "toBd7", "toMm15", "toMm5", "toMmd7", "toMmd5", "toMcd5", "toBmd15", "toMd512", "toMcd512", "toMd7", "toBmd7", "toMd15", "toMm512", "toBmd5", "toMmd512", "toBd15", "toMcd15", "toBmd512"], "str": ["txt", "temp", "fr", "pass", "stri", "kr", "string", "exp", "input", "msg", "char", "sr", "in", "STR", "tr", "conn", "err", "br", "s", "out", "arr", "url", "sp", "dr", "sec", "enc", "f", "e", "bytes", "result", "st", "data", "obj", "r", "b", "buffer", "Str", "text", "source", "name"], "messageDigest": ["messageDest", "messageDester", "messageDefest", "messageDigse", "messagedigest", " messageDEST", "messageHashester", "moredigester", "messageDigEST", "moreDigeter", "messageDefested", "MessageDigher", "Messagedigester", "moreDigester", "messageMixested", "MessagedigEST", "messageDEST", "MessageDigested", "messageUploadested", "Messagedigested", "messageDetter", "moreDigested", "Messagedigest", "MessageMarketter", " messageDigEST", "messageDefester", "messageHasheter", "messageDuster", "messagediguster", "MessageDigEST", "messageGEST", " messageDuster", "MessageMarkester", "messageMixester", "messageDigested", "messageHashest", "messageDiguster", "messagedigher", "messageDigetter", "messageGest", "MessageDigetter", "messagedigetter", "messageGester", "MessageMarkest", "messageDigher", "MessageDigse", "messagedigeter", " messageDiguster", "messageDeter", "messagedigested", "MessageDigester", "messagedigester", "messageDigeter", "messageMixest", " messageDest", "moredigested", "messageDested", " messageDester", "messageMarkest", "messageDefse", "messageMixse", "MessageDefse", "messageHashested", "moredigest", "MessageMarkher", "moredigeter", "messageGuster", "moreDigest", "messageMarkester", "MessageDefest", " messageDigester", "messageDigester", "MessageDefested", "messagedigEST", "messageUploadEST", "messageDher", "messageMarkher", "messageMarketter", "MessageDigest", "messageDse", "messageUploadest", "messageUploadester", "MessageDefester"], "byteArray": [" byteOrder", "ByteArray", "charAddress", "bitObject", "bitLength", " byteLength", " byteAddress", "resourceLength", "pixelBuffer", "doubleBuffer", "byteOrder", " bytearray", "wordArray", "byteAddress", "ByteLength", "pixelObject", "charNumber", " byteIndex", "charBuffer", "resourceIndex", "ByteNumber", "doubleArray", "bitarray", "byteNumber", " byteBuffer", "wordString", "bytearray", "pixelLength", "bitIndex", "resourceArray", "wordBuffer", "wordarray", "doubleString", "byteAmount", " byteString", "bitBuffer", "pixelArray", "byteBuffer", "charObject", "charLength", " byteNumber", " byteAmount", "resourcearray", "ByteAmount", "doublearray", "charArray", "ByteOrder", "byteString", "bitArray", "charAmount", "byteLength", "charOrder", "byteObject", "ByteBuffer", "byteIndex", "ByteAddress"], "md5StrBuff": ["md2StringRest", "md5strApp", "md2StrRest", "md2StringBuff", "md2StrBuff", "md6Strbuff", "md5TrBuffer", "md6strBuff", "md5TrText", "md2StringBuffer", "md5Stringbuff", "md2StringComp", "md6StrBuff", "md5Strbuff", "md5StringComp", "md5StrApp", "md6strbuff", "md2StringApp", "md2StrText", "md5StringBuffer", "md5StrDb", "md5TrDb", "md6StrBuffer", "md5StrComp", "md2StrComp", "md5Trbuff", "md6StrText", "md5StDb", "md6strText", "md5StringRest", "md5StringApp", "md2StrRef", "md5StringRef", "md5strText", "md5StringText", "md5StApp", "md5StBuffer", "md5strBuff", "md5StrRest", "md5TrRef", "md5strbuff", "md5StringBuff", "md5StText", "md6strBuffer", "md5StringDb", "md5TrBuff", "md5STRComp", "md5StRef", "md5StrRef", "md5StBuff", "md5STRBuffer", "md2StrBuffer", "md2StrApp", "md2StringText", "md5StComp", "md2StrDb", "md2StringRef", "md5strBuffer", "md5StrText", "md5STRRest", "md5StRest", "md2StringDb", "md5STRBuff", "md5StrBuffer"], "i": ["iu", "si", "qi", "ip", "u", "multi", "k", "ii", "c", "n", "pi", "o", "y", "d", "inner", "abi", "ci", "di", "io", "slice", "ji", "ui", "in", "ri", "length", "bi", "ie", "p", "it", "l", "part", "phi", "j", "I", "fi", "x", "index", "f", "field", "e", "oi", "li", "h", "v", "gi", "ti", "ai", "b", "xi", "id", "info", "uri", "ix", "mu", "name", "lc"]}}
{"id1": "11716816", "id2": "12171364", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    private static FrameworkFactory getFrameworkFactory() throws Exception {\n        URL url = Main.class.getClassLoader().getResource(\"META-INF/services/org.osgi.framework.launch.FrameworkFactory\");\n        if (url != null) {\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n            try {\n                for (String s = br.readLine(); s != null; s = br.readLine()) {\n                    s = s.trim();\n                    if ((s.length() > 0) && (s.charAt(0) != '#')) {\n                        return (FrameworkFactory) Class.forName(s).newInstance();\n                    }\n                }\n            } finally {\n                if (br != null) br.close();\n            }\n        }\n        throw new Exception(\"Could not find framework factory.\");\n    }\n", "label": 0, "substitutes": {"updateFile": ["updateBody", "copyBody", "upFolder", "upDirectory", "importBody", "copyFolder", "copyFile", "upFile", "importFolder", "upBody", "updateFolder", "updateDirectory", "copyDirectory", "importFile", "importDirectory"], "file": ["pe", "log", "FILE", "url", "resource", "e", "image", "parent", "b", "connection", "lock", "io", "info", "data", "single", "this", "socket", "part", "model", "f", "zip", "input", "type", "class", "source", "future", "dir", "filename", "l", "db", "files", "base", "queue", "object", "local", "cache", "load", "handler", "name", "up", "full", "File", "get", "path", "line", "current", "content", "http", "fp"], "IOException": ["Timeoutception", "DownloadProblem", "Downloadception", "TimeoutException", "DownloadException", "TimeoutProblem", "IOception", " IOception", " IOProblem", "IOProblem"], "destFile": ["flatFile", "destFull", "origTable", "destroyDir", "srcPath", " destFolder", "destFiles", "flatDir", "destFolder", "sourceFolder", "destTable", "origFile", " destinationFiles", "srcFiles", "destroyTable", " destinationFile", "destPath", " destFull", "origfile", "DestFile", "destDir", "flatFiles", "sourceFile", "Destfile", "DestPath", " destfile", "origDir", "DestDir", "DestFull", "destroyfile", " destTable", " destFiles", "sourceFiles", "srcFolder", "destfile", "srcFile", " destDir", "DestFiles", " destinationFull", "DestFolder", " destPath", "flatfile", "destroyFile", " destinationDir", "sourceDir"], "in": ["ins", "image", "In", "b", "ax", "connection", "lock", "init", "io", "this", "sync", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "cl", "s", "pass", "conn", "cin", "el", "i", "source", "win", "pull", "reader", "with", "client", "inside", "a", "l", "nin", "login", "work", "inner", "min", "r", "id", "ac", "bin", "con", "c", "err", "re", "up", "pin", "cf", "ini", "as", "again", "on", "p", "isin"], "out": ["at", "to", "ex", "writer", "url", "resource", "call", "In", "b", "n", "connection", "io", "off", "outer", "this", "sync", "outside", "inc", "socket", "channel", "output", "no", "cookie", "exp", "o", "password", "Out", "timeout", "conn", "pass", "i", "client", "nin", "co", "of", "login", "point", "outs", "user", "exec", "bin", "err", "obj", "c", "name", "option", "extra", "up", "net", "w", "OUT", "ou", "again", "lib", "ext"]}}
{"id1": "15799935", "id2": "942693", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttPartBody", "saveAttachmentPart", "saveAttPartbody", "saveAttachedBody", "saveAppensionbody", "saveAppachmentPart", "saveAppachmentFile", "saveAppensionBody", "saveAttensionFile", "saveAttPartFile", "saveAttensionBody", "saveAppensionPart", "saveAppensionFile", "saveAttensionPart", "saveAttachmentFile", "saveAppachmentBody", "saveAttachmentbody", "saveAppachmentbody", "saveAttachedPart", "saveAttPartPart", "saveAttachedFile", "saveAttachedbody", "saveAttensionbody"], "context": ["event", "translation", "input", "resource", "definition", "cf", "subject", "document", "message", "c", "version", "concept", "system", "present", "current", "driver", "host", "project", "manager", "center", "queue", "content", "client", "cms", "support", "ce", "reader", "cache", "connection", "component", "media", "Context", "collection", "config", "parent", "ca", "text", "channel", "request", "environment", "template", "coll", "kernel", "mc", "ctx", "community", "processor", "container", "contact", "state", "network", "cca", "service", "view", "front"], "part": ["event", "base", "translation", "Part", "pre", " Part", "message", "per", "place", "phase", "patch", "html", "mission", "PART", "chapter", "parts", "type", "source", "art", "connection", "Parts", "component", "media", "upload", "section", "parent", "file", "body", "channel", "pod", "object", "p", "or", "po", "name", "start", "image", "to", "area", "position", "app", "partial", "plan", "comment", " parts", "state", "block", "service", "from", "point"], "localAttachment": [" localAttment", "localAvention", "localExtacher", "LocalAttail", "LocalAttention", "localArtail", "localInstention", " localAttacement", "localAddail", "LocalAssail", " localExtacement", " localPartension", "localArtment", "LocalAttachment", "localattachment", "localAddachment", " localExtacher", "localInstension", " localExtention", "LocalAssention", " localAttrollment", "localAttachrollment", " localAttention", "localArtention", "localExtachment", "localPartachment", "localPartribution", " localAttribution", "localPartention", "localAttachribution", "localAvacement", "localInstribution", "localAssachment", "localExtention", "localAttention", "localAttacement", "localAttachacher", " localAttacher", "localAttacher", "localattment", " localAttachachment", "localAddrollment", "localattrollment", "localattention", "localAttension", "localAttachacement", " localPartribution", "localAvacher", "localAttribution", "localArtachment", "LocalAssment", "localAttail", "localAssail", "localPartension", " localPartachment", "LocalAssachment", " localAttachrollment", "localAttrollment", " localAttension", "localAttachension", "localAddention", "localAttment", " localExtachment", "localAddment", "localAttachention", "localAvachment", "localAssment", "localAttachachment", "localExtacement", " localPartention", " localAttachention", "localAssention", "LocalAttment", "localInstachment"], "accountId": ["accID", "contractid", "accountInfo", "jobId", "accId", " accountInfo", "AccountID", "contractId", "feedId", "AccountName", "feedid", "jobid", "feedID", "contactId", " accountID", "accInfo", "accid", "contractName", "contactid", " accountName", "accountID", "accountid", "jobID", "AccountId", "Accountid", "feedName", "contactName", "jobName", " accountid", "accountName", "appInfo", "appID", "appId", "appid"], "attachmentId": ["adachmentID", "attentionUrl", "attentionId", "attmissionID", "attociationID", "extachmentSource", "attachmentid", "attensionSource", "atachmentReference", "attlementId", "attmentName", "attociationUrl", "atachmentName", "attmissionId", "addachmentUrl", "attachmentReference", "attensionid", "attptionId", "attptionIndex", "addentionUrl", "attentionInfo", "extensionID", "attentionSource", "adentionID", "atociationId", "attagramId", "attachmentSource", "attptionID", "attlementName", "attentionID", "addentionID", "attachedType", "atociationID", "addachmentId", "attentionType", "attachmentName", "attachedUrl", "attptionInfo", "addachmentID", "adachmentInfo", "extensionId", "attensionID", "addentionId", "extensionid", "addachmentType", "attociationReference", "adentionId", "extensionSource", "attmissionid", "attlementReference", "adachmentIndex", "attmissionSource", "attentionIndex", "atachmentID", "attociationType", "extachmentID", "adachmentId", "attachedId", "extachmentId", "attmentReference", "atachmentId", "addentionType", "attociationName", "attachmentInfo", "adentionInfo", "attensionId", "atociationReference", "attachedID", "attachmentType", "attmentID", "attociationId", "attmentId", "extachmentid", "attlementID", "attachmentUrl", "attachmentID", "attentionid", "attagramIndex", "attagramInfo", "adentionIndex", "attagramID", "atociationName", "attachmentIndex"], "in": ["IN", "info", "pin", "i", "input", "id", "plus", "copy", "ini", "gin", "con", "slice", "inner", "as", "socket", "ins", "bin", "pass", "is", "source", "reader", "load", "up", "login", "inside", "inc", "data", "file", "p", "init", "conn", "or", "again", "image", "it", "In", "nin", "a", "pull", "url", "err", "ac", "cin", "inn", "f", "din"], "saveIn": ["savIn", "writeIN", "saveIN", "savin", "SaveIn", "saveIns", "savAs", "stageAs", "savOut", " saveIN", "aveIn", "writeIn", "stageIns", "writein", "avein", "aveOut", "stageIn", " savein", "writeOut", "savein", "SaveAs", " saveIns", "SaveIns", "SaveOut", "aveIN", " saveOut", "aveAs", "saveOut", "stageOut"], "saveAs": ["copyAs", "writeAs", "SaveIn", "Saveas", "saveas", " saveFile", "createAs", "saveFile", "openAs", "saveAS", "openAt", "writeIn", "copyIn", "writeAS", "createAS", "writeOut", "SaveAs", "copyAS", "SaveAS", "copyas", "SaveOut", "saveAt", " saveAS", " saveas", "createFile", " saveOut", "createAt", "openAS", " saveAt", "openFile", "saveOut"], "out": ["string", "path", "temp", "ex", "output", "copy", "outer", "plus", "OUT", "c", "as", "inner", "o", "outs", "s", "line", "flow", "bin", "off", "client", "sync", "at", "source", "cache", "up", "other", "default", "inc", "data", "file", "page", "null", "conn", "init", "again", "name", "exec", "Out", "io", "writer", "image", "to", "a", "ext", "err", "v", "this"], "copySize": ["openSIZE", "savesize", "saveAddress", "byteLength", "CopySize", "openSize", "opensize", "lesize", "byteAddress", "copysize", "copyTime", "leSize", "openLength", "CopyTime", "saveLength", "bytesize", " copyLength", "copyAddress", " copysize", " copyAddress", " copySIZE", "leLength", "leSIZE", "byteTime", "CopyLength", "copySIZE", "copyLength", "saveSize", " copyTime", "byteSize", "Copysize"], "contentUriString": ["contentUpiStr", "contentIristring", "contentIrisInt", "contentUiniStr", "contentUiniNumber", "contentUrisstring", "contentUuriStr", "contentUuriByte", "contentIrisStr", "contentIriByte", "contentIiString", "contentUriStr", "contentUriUnit", "contentUiniByte", "contentIrisString", "contentIriStr", "contentUridString", "contentIrisUnit", "contentIriString", "contentUrisStr", "contentUrisUnit", "contentUiByte", "contentUriNumber", "contentUridStr", "contentUuriString", "contentUpistring", "contentUristring", "contentUioInt", "contentIiByte", "contentIriNumber", "contentUioStr", "contentUrisInt", "contentUiNumber", "contentUriByte", "contentUiUnit", "contentUuriNumber", "contentUiostring", "contentIrisstring", "contentIriInt", "contentUpiInt", "contentUiStr", "contentUridUnit", "contentIiStr", "contentIiNumber", "contentUioString", "contentIriUnit", "contentUiString", "contentUpiString", "contentUriInt", "contentUrisString", "contentUiniString"], "mSize": ["mName", "cName", "pLength", "iSize", "iLength", "iName", "pName", "cSize", "pCount", "mCount", "cCount", "pSize", "iCount", "mLength", "cLength"], "mContentUri": ["mContentIric", "mContentOUris", "mResourceIric", "mResourceIri", "mContentIris", "mContentUci", "mResourceUris", "mContentUrri", "mContentOUric", "mResourceUric", "mContentUrric", "mContentUric", "mContentOUci", "mContentIci", "mResourceUci", "mContentUrris", "mResourceIris", "mResourceIci", "mContentUrci", "mResourceUri", "mContentOUri", "mContentIri", "mContentUris"], "cv": ["iq", "cu", "core", "cc", "sc", "um", "cf", "rc", "enc", "vm", "uv", "cap", "vr", "c", "fc", "ctrl", "cb", "fp", "co", "pb", "VC", "csv", "nc", "content", "vc", "cm", "cp", "lc", "cover", "auc", "uc", "buf", "sv", "conv", "ca", "xc", "av", "cd", "keep", "vs", "coll", "cr", "CV", "mc", "ctx", "bc", "nv", "v", "ov", "cs", "GV", "vp", "lv", "que", "iv", "vv", "loc"], "uri": ["string", "path", "base", "address", "i", "id", "resource", "pi", "username", "http", "uid", "ri", " URI", "location", " Uri", "query", "ui", "universal", " ur", "qi", "gb", " url", "proxy", " scheme", "data", "route", "oid", "mi", "metadata", "environment", "href", "format", "uni", "ci", "iri", "prefix", "url", "range", "attribute", "cli", "iv", "URI", "api", "point", "storage"]}}
{"id1": "8973505", "id2": "20855053", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "label": 1, "substitutes": {"writeFileType": ["writeFilesHeader", "createFileType", "writeFileHeader", "writeFILEHeader", "writeFILETypes", "writeFILEtype", "writeFiletype", "writeFilesTypes", "createFileHeader", "createFilestype", "writeFilestype", "writeFileTypes", "writePageTypes", "writePagetype", "writePageType", "createFiletype", "createFilesTypes", "createFilesHeader", "createFileTypes", "writeFilesType", "createFilesType", "writeFILEType", "writePageHeader"], "uriFile": ["URIfile", "urifile", "URIFilename", "riFiles", "uifile", "URIUrl", "uriFiles", "filenameFile", "uiFiles", "filenameFilename", "uiUrl", "URIFiles", "uriFilename", "riUrl", "filenamefile", "uiFile", "rifile", "URIFile", "riFile", "riFilename", "filenameFiles", "uriUrl"], "outputfile": ["resourcefiles", "unitfile", "outputfilename", "outputstring", "resourcefilename", "Outputfull", "inputfiles", "unitstring", " outputdir", "inputFile", "unitfilename", "outputfiles", "outputFile", "inputdir", "inputstring", " outputFile", " outputfull", "inputfull", "resourcestring", "inputfilename", "outputfull", "inputfile", "resourcefile", "unitfiles", "outputdir", "OutputFile", "Outputdir", "Outputfile"], "num": ["span", "nu", "unit", "col", "length", "count", "master", "offset", "n", "term", "amount", "inc", "limit", "no", "loop", "index", "NUM", "split", "sum", "batch", "Num", "multi", "len", "number", "coord", "mult", "con", "dim", "initial", "name", "umi", "zero", "nb", "nam", "common"], "writer": ["ee", "widget", "wr", "report", "wan", "null", "data", "writing", "socket", "written", "part", "entry", "Writer", "temp", "r", "wa", "wire", "root", "per", "wb", "wave", "page", "unit", "e", "we", "message", "wt", "server", "style", "editor", "index", "key", "type", "rw", "xml", "element", "builder", "width", "er", "worker", "walker", "object", "handler", "loader", "w", "writers", "layer", "format", "feed", "book", "master", "io", "outer", "later", "writ", "creator", "out", "wl", "function", "wrapper", "ler", "buffer", "manager", "write", "lock", "method", "session", "engine", "journal", "external", "output", "document", "ws", "source", "driver", "header", "riter", "inner", "window", "service", "office", "author"], "uri": ["component", "term", "verb", "sequence", "directory", "cli", "eni", "feature", "wiki", "token", "string", "file", "URI", "origin", "iri", "reference", "context", "ui", "query", "nor", "unit", "resource", "message", "connection", "remote", "link", "winner", "folder", "nil", "uni", "plugin", "i", "element", "metadata", "theme", "gi", "handler", "umi", "oid", "qi", "database", "prefix", "attribute", "course", "doi", "du", "route", "pi", "node", "id", "binary", "location", "picture", "hub", "collection", "http", "direction", "ori", "username", " URI", "range", "document", "href", "uid", "source", "multi", "filename", "di", "li", "mi", "base", "address", "ilo", "ri"], "counter": ["enter", "book", "page", "Counter", "server", "clock", "parent", "count", "master", "offset", "nr", "race", "info", "outer", "step", "parser", "ner", "hello", "sequence", "cookie", "loop", "entry", "creator", "meter", "result", "timer", "controller", "second", "index", "coll", "batch", "ver", "time", "instance", "i", "comment", "iter", "record", "trace", "keep", "ter", "expression", "worker", "number", "inner", "handler", "repeat", "cpu", "loader", "name", "continue", "computer", "reference", "inter", "vector", "condition", "runner", "current", "currency", "pointer", "lc", "collection", "keeper", "processor"], "reader": ["e", "rx", "rer", "riter", "io", "ner", "reading", "parser", "rar", "in", "Reader", "editor", "finder", "upper", "read", "row", "iter", "driver", "bird", "ruby", "l", "er", "rr", "lr", "inner", "stream", "ger", "worker", "r", "handler", "ir", "loader", "per", "layer", "keeper", "ler", "buffer", "oder", "feed", "ri"], "url": ["ls", "page", "text", "ssl", "resource", "image", "server", "connection", "io", "link", "blog", "channel", "www", "URL", "download", "plugin", "source", "config", "client", "li", "stream", "l", "web", "base", "user", "id", "address", "string", "file", "sl", "path", "Url", "http", "feed", "ri", "browser"], "myConnection": ["myconnection", "MyConnector", "someConnect", "MyConnection", "someReader", "myConnect", "yourConnector", " myConnector", "myConnector", "yourConn", "MyConnect", "MyConn", " myConnect", " myconnection", " myConn", "someConnection", "yourConnection", "someConn", "Myconnection", "yourconnection", "MyReader", "myConn"], "myReader": [" myRead", "myWriter", "MyWriter", "yourWriter", " myParser", "yourReader", "yourRead", "yourParser", "myParser", "myRead", "MyReader", "MyRead", "MyParser", " myWriter"], "line": ["page", "text", "pe", "LINE", "log", "lf", "message", "frame", "le", "style", "letter", "cell", "data", "link", "part", "no", "range", "entry", "du", "rule", "block", "lin", "cl", "lines", "end", "key", "inline", "row", "el", "code", "error", "element", "column", "pass", "source", "comment", "parse", "header", "l", "use", "base", "user", "point", "id", "look", "day", "string", "file", "Line", "liner", "name", "response", "word", "lc", "non", "note", "feed", "ri"], "linecount": ["Linenumber", "pagecount", "pageindex", "lineCount", " linesize", "Linecache", "linecache", " linecache", "lettercount", "lineindex", "rowcount", "pagenumber", "Linesize", "lettersize", "linenumber", "linesize", "LineCount", " lineindex", "linelen", " lineCount", " linelen", "rowcache", "rowlen", "pageCount", " linelength", "linelength", "letterlength", "Lineindex", " linenumber", "letterlen", "rowsize", "rowlength", "Linecount"], "hasOWL": [" hasOWDL", "hasODL", " hasEWl", "hasEWLA", " hasOWLA", " hasOWLM", "hasOULA", "HasOWLL", "hasEWDL", " hasEWLM", "HasEWLL", "HasEWLA", "hasOWl", "hasEWl", "hasOWSLL", "hasEFLM", "hasODLA", "hasBYL", "hasEFl", "hasOUL", "hasOULL", " hasEWL", "hasBYl", " hasOWl", "hasOWLM", " hasEWLA", " hasEWDL", "HasOWLA", "HasEWLM", " hasEWLL", "hasODLL", "hasOWSL", "hasBYDL", " hasOWLL", "hasOWSDL", "hasEWLM", "HasEWL", "hasOWSl", "hasODLM", "hasEWL", "hasEWLL", "HasOWL", "hasEFL", "hasOWLA", "hasOWLL", "hasOWDL", "hasODl", "HasOWLM", "hasBYLL", "hasEFLA", "hasOULM"], "hasRDFS": ["hasGRUFs", "hasGRDFS", "hasGRDFs", "hasXDFE", "hasRNFS", "hasXDFS", "hasCDPS", "hasRdfU", "hasCDFES", "hasRDFs", "hasRUFSU", "hasRDPAST", "hasXDPU", "hasRdfS", "hasRDPU", "hasXDPS", "hasRDFU", "hasRNFs", "hasRdfE", "hasCDPE", "hasRDPES", "hasRNFU", "hasRUFs", "hasRDFES", "hasXDPE", "hasRFs", "hasRUFS", "hasXDFs", "hasCDPs", "hasRNFE", "hasRTFE", "hasGRDFAST", "hasRUFAST", "hasRTFS", "hasRdfs", "hasRDPSU", "hasRFSU", "hasRDPS", "hasGRUFAST", "hasRFAST", "hasRDFSU", "hasRDFE", "hasCDFS", "hasCDFs", "hasGRUFS", "hasXDPs", "hasRDPE", "hasCDFE", "hasGRDFSU", "hasRTFs", "hasGRUFSU", "hasXDFU", "hasRTFES", "hasRFE", "hasRFES", "hasCDPES", "hasRDFAST", "hasRFS", "hasRDPs"], "hasRDF": ["hasUDF", "HasRRdf", "hasRUF", "hasDDF", " hasRRMF", "yesDOW", "yesRMF", "HasRdf", "hasRRDEF", "hasMRDEF", "hasUMF", " hasRMF", "yesRDP", "HasRRDF", "hasURMF", "hasSRdf", "hasRRdf", "hasROW", "hasRMF", "hasNRMF", "hasNRFD", "hasNRUF", "hasRRMF", "hasMRDP", "hasUOW", "hasRFD", "hasDMF", "yesDDF", "hasUDP", " hasRRFD", "hasRDEF", "yesDDP", "hasSRDF", " hasRFD", "yesDMF", "yesROW", "yesRDF", " hasRRUF", "HasRDP", "hasMRdf", "hasNRDF", "hasRRUF", "hasSRDEF", "hasRRDP", "HasRRDP", "hasURDF", "hasDDP", " hasRRDF", "HasRDEF", "HasRDF", "hasMRDF", "hasRRFD", "hasRRDF", "hasSRDP", " hasRUF", "hasDOW", "hasURFD", "hasURUF", "HasRRDEF", "hasRdf", "hasRDP"]}}
{"id1": "14688886", "id2": "16142024", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 0, "substitutes": {"populateResources": ["popureResources", "compureResources", "populateResource", "popractRelations", "compureResource", "populateRelations", "poputeResource", "poputeResources", "compulateResources", "compulateFiles", "popureRelations", "compureRelations", "popureResource", "poputeRelations", "compureFiles", "popureFiles", "poputeFiles", "popractResources", "compulateResource", "popractFiles", "popractResource", "compulateRelations", "populateFiles"], "templates": ["Temures", "template", "promplate", "prometers", "templateples", "templateplates", "tempplate", "typlates", "templ", "filures", "Template", "stemps", "temures", " templ", "filens", "Temens", "promplates", "tompl", "prompl", "typlate", "stemples", "templateps", "filpl", "temppl", "typs", "Temples", " temens", "Temeters", "tempplates", " temures", "tomplate", "stempl", "temens", "Temps", "typl", "Templates", "temeters", "tometers", "temps", "templatepl", "temples", "stemplates", "Templ", "tomplates", "filplates", "tempps"], "url": ["template", "address", "base", "job", "ob", "el", "e", "feed", "URL", "path", "xml", "sl", "fl", "Url", "filename", "location", "string", "name", "host", "pattern", "image", "link", "pl", "ssl", "connection", "r", "html", "route", "object", "config", "buffer", "uri", "service", "resource", "http", "href", " URL", "page", "source", "file", "l", "data", "entry", "email", "server", "channel", "download", "f", "il"], "fileName": ["FileKey", " filePart", "folderPath", "filename", " fileTime", "fileTime", " fileDir", " fileSystem", "FileString", "filePart", "fKey", "objectname", "resourcename", "fileFull", "fileString", "folderPart", " fileDirectory", "sourceInfo", "filePath", "objectName", "stringType", "Filename", "filenameString", "FileType", " fileLength", "folderName", "filenameType", "resourcePart", "sourceName", "FILESystem", "FILESync", "fName", " fileString", "modelName", "filenameFull", "fileInfo", "modelname", "fname", "objectSync", "stringDirectory", "objectTime", "foldername", "fDir", "sourcename", "filenameLength", "fileLocation", "FileDir", "modelLocation", "FILEname", " fileSync", " fileFull", "FILEName", " fileInfo", "sourceString", "FileDirectory", "fileType", "sourceLength", "resourcePath", "modelSystem", " filename", " fileType", "FileFull", "fileLength", " fileKey", "FILELocation", " filePath", "fileDir", "FileName", "stringName", "filenamename", "FILETime", "filenameName", "fileDirectory", "fileKey", "fileSync", "fileSystem", "FileInfo", "resourceName", " fileLocation"], "templateResource": ["tempRole", " templateType", "tempResource", "templateType", "copyresource", "xmlResource", "templateContainer", "eventresource", "templateUrl", "templateContent", "translationContainer", "templateRing", "plateContainer", "eventReader", "layoutRing", "layoutContent", "layoutResource", "copyUrl", "tempFile", "copyResource", "templateFile", "layoutContainer", " templateRole", "plateContent", "privateResource", "templateReader", "templateresource", "translationResource", "plateResource", "privateReader", "templateRole", "copyReader", "tempType", "translationRing", "xmlFile", "eventResource", " templateFile", "plateRing", "xmlRole", "privateresource", "privateUrl", "eventUrl", "translationContent", "xmlType"], "is": ["serv", "im", "ais", "ip", "ib", "iso", "ar", "isa", "io", "app", "has", "was", "IS", "bis", "Is", "abs", "ir", "out", "s", "cms", "ris", "isl", "ios", "iss", "os", "nis", "ori", "r", "irc", "lis", "isc", "isi", "ri", "uri", "api", "it", "iris", "its", "in", "src", "rss", "as"], "strBuff": ["brBuff", "StrBuffer", "rText", "stringGrab", "Strbuff", "strbuff", "stringBuff", "arrBuff", " strGrab", "strPref", "arrBuffer", "rbuff", "StrPref", " strText", "strBuffer", " strTab", "StrTab", " strFlow", "StrBuff", "rBuff", "brGrab", "brBuffer", "strTab", "strGrab", "strFlow", "rBuffer", "strText", " strbuff", "stringFlow", "arrTab", "stringBuffer", " strBuffer", " strPref", "arrPref", "StrText", "brFlow"], "br": ["yr", "bc", "result", "reader", "mr", "sr", "ber", "io", "arr", "brush", "nr", "div", "er", "res", "cr", "hr", "stream", "bro", "orb", "err", "bl", "Br", "Reader", "ori", "r", "b", "browser", "text", "buf", "bar", "tr", "fr", "rb", "dr", "BR", "data", "gr", " reader", "sp", "ctr", "cb"], "str": ["lc", "cl", "st", "sr", "arr", "sec", "cur", "sl", "er", "div", "string", "name", "cr", "hr", "err", "spec", "wr", "Str", "or", "type", "t", "r", "kr", "text", "tr", "STR", "enc", "star", "oct", "fr", "iter", "p", "key", "dr", "line", "stri", "data", "char", "sc", "style", "coll", "sp", "strike", "f", "pr"], "images": ["picture", "photos", "services", "objects", "ins", "png", "ages", "classes", "groups", "types", "assets", "xs", "rooms", "people", "tags", "holes", "shows", "flows", "letters", "videos", "Images", "ions", "ims", "users", "styles", "gif", "image", "jobs", "resources", "sites", "files", "words", "stars", "models", "lights", "ups", "plugins", "pieces", "boxes", "events", "bands", "media", "views", "frames", "games", "opens", "dates", "apps", "ips", "icons", "pages", "tests", "versions", "thumbnails", "quarters", "gallery", "agents", "inches", "scripts", "features"], "i": ["v", "I", "e", "app", "id", "iu", "xi", "xml", "li", "hi", "si", "mi", "format", "ie", "p", "yi", "chi", "gu", "f", "phi", "ti", "x", "Url", "u", "s", "uni", "b", "key", "http", "in", "di", "cli", "bi", "lc", "io", "_", "ini", "eni", "multi", "ij", "ii", "y", "info", "config", "slice", "uri", "it", "ji", "mu", "pi", "qi", "z", "ip", "ai", "index", "ind", "ui", "image", "ci", "this", "j", "html", "n", "diff", "add", "gi", "fi", "ni", "d"], "img": ["map", "v", "im", "png", "ani", "ng", "jpg", "tmp", "app", "exp", "arr", "sl", "input", "fb", "ext", "li", "aut", "hr", "aff", "gif", "image", "bl", "fig", "imp", "lib", "m", "small", "norm", "ie", "info", "gd", "bg", "ff", "iframe", "config", "att", "inst", "icon", "p", "data", "file", "ch", "tif", "fw", "src", "gallery", "abc", "cb", "f"], "imgProperty": ["bgPro", "cacheProperty", " imgProp", "cacheProp", "imgImage", "bgProperty", " imgPro", "bgProp", "cachePro", "imgProp", "imgPro", " imgImage", "cacheImage", "bgImage"]}}
{"id1": "14567939", "id2": "5441579", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 1, "substitutes": {"baseHash": [" generateHash", " chainFile", " chainHash", "BaseSecret", "BaseFile", "Basehash", "basehash", "BaseHash", " generateSecret", " generatehash", " chainhash", " chainSecret", " generateFile", "baseSecret", "baseFile"], "name": ["image", "hello", "n", "key", "class", "host", "object", "user", "parent", "id", "address", "ame", "alias", "path", "resource", "word", "file", "part", "NAME", "prefix", "normal", "base", "definition", "data", "type", "secret", "Name", "names", "member", "style", "string", "named", "hash", "create", "account"], "password": ["account", "words", "crypt", "key", "profile", "pattern", "input", "attribute", "sword", "phrase", "source", "diff", "padding", "Password", "code", "path", "word", "value", "wd", "prefix", "device", "pass", "security", "wallet", "data", "paste", "token", "secret", "text", "auth", "string", "stroke", "seed", "hash", "priv", "PASS", "username"], "digest": ["mdr", " digested", "signest", "mdester", " digger", "digusher", "DigEST", "digger", "mdest", "diger", "Diger", "modested", "moder", "signger", "Digest", "Digger", " diger", "Digester", " digester", "signusher", "modest", "digester", "digEST", "decest", "mdEST", "modester", "Digr", "signer", "decester", "decEST", "Digusher", " digusher", "digested", "digr", "Digested", "decr", "signester"]}}
{"id1": "20181656", "id2": "7143591", "code1": "    private int[] sortRows(int[] rows) {\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows.length - 1; j++) {\n                if (rows[j] > rows[j + 1]) {\n                    int temp = rows[j];\n                    rows[j] = rows[j + 1];\n                    rows[j + 1] = temp;\n                }\n            }\n        }\n        return rows;\n    }\n", "code2": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "label": 0, "substitutes": {"sortRows": ["sortLRow", "ortLows", "sortSlows", "sortPows", "sortSlOWS", "ortRrows", "sortLOWS", "sortProws", "sortPRow", "ortROWS", "sortSlrows", "sortLows", "ortRRow", "sortLrows", "ortLOWS", "ortLRow", "sortPOWS", "sortROWS", "ortLrows", "sortRrows", "sortSlRow", "sortRRow", "ortRows"], "rows": ["keys", "tracks", "maps", "uds", "index", "headers", "checks", "results", "pages", "docs", "ks", "vers", "slice", "posts", "result", "grid", "roads", "rank", "errors", "cases", "shows", "rs", "ids", "raw", "items", "projects", "users", "flows", "ros", "blocks", "lines", "builders", "diff", "ports", "runs", "members", "orders", "points", "roots", "ows", "grades", "ends", "models", "ips", "breaks", "row", "forms", "boards", "groups", "frames", "rss", "tests", "cells", "holes", "ss", "rooms", "array", "types", "values", "files", "relations", "fields", "rates", "right", "acks", "rules", "heads", "multi", "views", "times"], "i": ["index", "id", "pi", "ij", "ind", "c", "z", "ri", "l", "si", "ui", "ii", "ji", "phi", "li", "ip", "x", "p", "mi", "bi", "u", "ai", "ci", "I", "m", "io", "xi", "ix", "a", "ki", "b", "v", "y", "iu", "f", "ik"], "j": ["index", "job", "uj", "n", "ij", "dj", "json", "jc", "ind", "z", "o", "jl", "l", "jo", "fr", "ui", "ii", "key", "aj", "next", "qi", "ja", "ji", " dj", "d", "jan", "q", "li", "h", "x", "p", "u", "jj", "J", "js", "e", "jp", "ix", "k", "b", "y", "v", "jit", "obj", "br", "oj", "adj", "f", "ik"], "temp": ["index", " tmp", "max", "tc", "id", "n", "input", "pre", "tem", "z", "col", "Temp", "flow", "shift", "extra", "iter", "offset", "except", "cache", "diff", " Temp", "parent", "needed", "flat", "tmp", "fake", "emp", "ip", "empty", "get", "null", "test", "dev", "stable", "area", "circ", "k", "unit", "partial", "v", "err", "this", "orig", "cell"]}}
{"id1": "4593012", "id2": "5725177", "code1": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "code2": "    @Override\n    protected <T> T execute(final HttpMethod method, final String url, Parameters parameters, final Handler<T> handler) throws FoursquareException {\n        HttpURLConnection connection = null;\n        try {\n            switch(method) {\n                case GET:\n                    connection = openConnection(url.concat(\"?\").concat(formEncode(parameters)));\n                    connection.setRequestMethod(\"GET\");\n                    connection.connect();\n                    break;\n                case POST:\n                    connection = openConnection(url);\n                    connection.setRequestMethod(\"POST\");\n                    connection.setDoOutput(true);\n                    connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    connection.connect();\n                    final OutputStream out = connection.getOutputStream();\n                    out.write(formEncode(parameters).getBytes());\n                    out.flush();\n                    out.close();\n                    break;\n            }\n            final int statusCode = connection.getResponseCode();\n            if (statusCode / 100 != 2) {\n                final Error error = parseBody(connection.getErrorStream(), new ErrorHandler());\n                if (error == null) throw new FoursquareException(connection.getResponseMessage()); else if (\"error\".equals(error.getType())) throw new FoursquareException(error.getMessage()); else if (\"unauthorized\".equals(error.getType())) throw new AuthenticationException(error.getMessage()); else if (\"ratelimited\".equals(error.getType())) throw new RateLimitingException(error.getMessage()); else throw new FoursquareException(connection.getResponseMessage());\n            }\n            return parseBody(connection.getInputStream(), handler);\n        } catch (final IOException e) {\n            throw new FoursquareException(e);\n        } catch (final ParserConfigurationException e) {\n            throw new FoursquareException(e);\n        } catch (final SAXException e) {\n            throw new FoursquareException(e);\n        } finally {\n            if (connection != null) connection.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"upgradeSchema": ["upgradeCatalogMeta", "upgradeSchement", "upgradeDatabasement", "upgradingscheMeta", "upgradeCatalogma", "upgradeScheMeta", "upgradeCatalogmas", "upgradeDatabaseMeta", "upgradeschemas", "upgradeDatabasemas", "upgradingschement", "upgradeschema", "upgradingScheMeta", "upgradingschema", "upgradeCatalogment", "upgradescheMeta", "upgradingSchemas", "upgradingSchement", "upgradeSchemas", "upgradeDatabasema", "upgradingschemas", "upgradingSchema", "upgradeschement"], "stmt": ["stmsg", "STtm", "Stmt", "pmt", "estmt", "frmp", "STvt", "estmsg", " stmr", "stmp", "frmsg", "frmt", "stvt", "Stdb", " stmit", "Stnt", "stql", "Stmr", "pvt", "hmit", "hmp", "stmit", "estmp", "rmp", "ptm", "stnt", "hmt", "estm", "frm", "ftmp", "ftmit", "pm", "strnt", "STm", " stmsg", " stmp", "strmp", "stm", "strmt", " sttm", "rmr", "rmt", " stnt", " stvt", "hnt", "rql", "strmr", " stm", "strql", " stql", "sttm", "stmr", "strdb", "ftmt", "stdb", " stdb", "ftnt", "STmt"], "i": ["ini", "mi", "index", "j", "in", "o", "yi", "hei", "hi", "isi", "phi", "cli", "ii", "fi", "ix", "count", "slice", "api", "b", "info", "ui", "isu", "ami", "ri", "pi", "c", "r", "gi", "t", "abi", "k", "li", "ci", "ie", "p", "multi", "si", "ni", "xi", "I", "bi", "v", "uri", "ai", "x", "adi", "eni", "it", "ip", "start", "name", "esi", "qi", "ti", "id", "e", "iu", "vi", "u", "f", "n", "di", "ki", "oi", "zi"], "qry": ["quRY", "Qry", " qri", "qrc", "quri", "QRY", "quries", "querri", "qRY", "Qri", " qries", "Qrys", " qcr", " qRY", "querRY", "Qcr", "Qries", "qurys", " qrc", " qrys", "qrys", "qucr", "qury", "querrc", "qcr", "querry", "qri", "qurc", "qries"]}}
{"id1": "19113613", "id2": "18613870", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "save", "rm", "write", " cp", "cp", "sync", "zip", "archive", "paste", "split", "clone", "clip", "type", "download", "process", "move", "cat", "Copy", "create", "delete", "change", "load", "share", "upload", "get", "ssh", "transfer", "Cop", "put", "update", "p", "opy", "cop"], "in": ["ins", "url", "image", "In", "n", "connection", "init", "thin", "data", "this", "project", "inc", "old", "part", "f", "input", "din", "IN", "inn", "lin", "index", "plugin", "cin", "i", "kin", "win", "reader", "sin", "config", "inside", "client", "work", "a", "login", "inner", "base", "min", "id", "token", "bin", "c", "ic", "name", "diff", "pin", "get", "ini", "as", "again", "update", "on"], "out": ["at", "page", "ex", "vert", "one", "image", "resource", "call", "parent", "b", "null", "n", "connection", "remote", "init", "io", "off", "outer", "dot", "project", "this", "version", "outside", "inc", "external", "part", "output", "no", "group", "input", "block", "o", "Out", "conn", "with", "client", "self", "work", "base", "outs", "point", "user", "object", "app", "cache", "exec", "bin", "c", "v", "err", "obj", "option", "name", "net", "goal", "OUT", "up", "root", "other", "path", "x", "again", "line", "p", "ext"], "source": ["prefix", "proxy", "pe", "component", "attribute", "direction", "subject", "secret", "url", "uri", "unit", "resource", "parent", "dest", "scope", "view", "ce", "username", "project", "status", "Source", "site", "route", "family", "missing", "type", "sin", "iter", "class", "src", "size", "base", "feature", "alt", "internal", "position", "id", "ource", "name", "origin", "service", "reference", "SOURCE", "format", "secure", "force", "use", "from"], "target": ["prefix", "component", "direction", "url", "resource", "parent", "master", "dest", "null", "project", "output", "alias", "site", "route", "about", "template", "home", "cat", "top", "config", "src", "Target", "alt", "base", "point", "wrong", "address", "token", "arget", "detail", "name", "origin", "service", "reference", "root", "pattern", "host", "next", "goal", "path", "current", "value", "tail", "format", "force"], "files": ["ls", "keys", "ions", "ins", "links", "users", "obs", "jobs", "data", "assets", "f", "sections", "apps", "groups", "plugins", "features", "classes", "lines", "fs", "s", "children", "flows", "objects", "results", "docs", "tools", "images", "filename", "ports", "pages", "resources", "names", "models", "cells", "iles", "blocks", "Files", "items"], "file": ["page", "FILE", "url", "e", "resource", "ile", "uri", "parent", "le", "b", "unit", "letter", "item", "data", "single", "child", "part", "folder", "entry", "f", "it", "feed", "live", "el", "fe", "future", "dir", "directory", "filename", "l", "base", "object", "id", "local", "string", "load", "name", "entity", "binary", "per", "File", "layer", "path", "function", "current", " File", "line", "fp", "lib"], "inCh": ["InChan", "INChannel", "inCH", "InChannel", "INCH", "inch", "inChan", "outCH", " inch", "InCH", " inChan", " inCH", "outch", "Inch", "InCh", "outChan", "outChannel", " inChannel", "INChan", "inChannel", "INCh"], "outCh": ["Outch", "OutChan", "OutCH", "inCH", " outChannel", "inch", " outch", "inChan", "outCH", "OutChannel", "outputCh", "outch", "outputChan", "outChan", " outCH", "outChannel", "outputCH", "inChannel", "OutCh", "outputch"]}}
{"id1": "3731077", "id2": "19868933", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copySourceFile", "transferFiles", "importfile", "importSourceFile", "copyfile", "copyFiles", "transferfile", "transferFile", "importFiles", "copySourceFile", "transferSourceFile", " copyfile", "importFile", " copyFiles"], "from": ["source", "form", "as", "remote", "of", "about", "se", "client", "path", "c", "f", "front", "with", "before", "back", "this", "config", "at", "src", "ca", "or", "by", "data", "left", "resource", "ce", "old", "io", "original", "a", "url", "base", "name", "add", "address", "without", "origin", " form", "From", "range", "file", "part", "o", "id", "user", "start", "d"], "to": ["p", "source", "as", "top", "into", "of", "about", "output", "TO", "so", "client", "copy", "token", "at", "f", "with", "this", "point", "one", "root", "po", "too", "socket", "or", "by", "object", "location", "storage", "dest", "io", "base", "database", "name", "toc", "null", "b", "os", "until", "api", "two", "size", "To", "auto", "again", "office", "file", "temp", "t", "o", "site", "type", "parent", "target", "eto"], "parentDir": ["parentDirectory", " parentFile", "ParentFile", "currentDir", " parentFolder", "currentFile", "outFile", "rootFile", " parentdir", "currentdir", "ParentDirectory", "outFolder", "ParentDir", "outDir", "outDirectory", " parentDirectory", "parentdir", "parentFile", "parentFolder", "rootDirectory", "ParentFolder", "Parentdir", "currentFolder", "rootFolder", "rootDir"], "in": ["work", "pre", "source", "form", "init", "rec", "inn", "gin", "sync", "pin", "inner", "ac", "with", "i", "ie", "input", "l", "conn", "image", "inside", "or", "IN", "m", "con", "win", "ini", "on", "io", "isin", "arin", "url", "pc", "din", "it", "vin", "exec", "nin", "min", "rc", "ins", "cin", "plugin", "lin", "In", "fc", "inc", "again", "rin", "kin", "trial", "part", "err", "r", "login", "o", "reader", "id", "diff", "bin"], "out": ["p", "org", "call", "init", "app", "cy", "about", "ot", "output", "gin", "sync", "client", "net", "inner", "ac", "c", "at", "w", "ex", "input", "OUT", "conn", "or", "writer", "win", "other", "on", "io", "vert", "ou", "outer", "exec", "ico", "channel", "cin", "option", "Out", "plugin", "auto", "outs", "inc", "again", "off", "op", "o", "user", "bin", "co", "can"], "ic": ["IC", "cs", "xc", "uc", "sync", "iac", "c", "ac", "ai", "ix", "ex", "i", "irc", "input", "conn", "acs", "ci", "or", "loc", "ec", "io", "bc", "pc", "pic", "lc", "ik", "ico", "cus", "rc", "cc", "cin", "enc", "cl", "fc", "ics", "icc", "nic", "auto", "cu", "vc", "mc", "anc", "aic", "op", "ct", "voc", "ig", "o", "inc", "co", "dc"], "oc": ["og", "org", "cy", "oco", "xc", "uc", "c", "ac", "ocon", "aco", "oca", "wic", "i", "ca", "acs", "ci", "AC", "or", "loc", "ec", "io", "ocol", "OC", "bc", "pc", "toc", "sc", "ack", "cus", "cur", "cc", "soc", "mic", "enc", "oci", "fc", "nic", "alloc", "vc", "anc", "mc", "aic", "op", "ob", "o", "voc", "circ", "inc", "co", "can", "roc", "dc"]}}
{"id1": "8087001", "id2": "14785308", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"generateStackHashKey": ["generatestackHashString", "generateStackHeaderString", "generateStackhashKey", "generatestackHashkey", "generateStackhashkey", "generateStackhashString", "generatestackHashKey", "generateStackHashKeys", "generateStackHeaderKeys", "generateStackHashkey", "generatestackhashKey", "generateStackHeaderkey", "generatestackhashKeys", "generatestackHashKeys", "generateStackHeaderKey", "generatestackhashString", "generateStackhashKeys", "generateStackHashString", "generatestackhashkey"], "e": ["enter", "m", "pe", "ee", "ex", "est", "he", "ev", "esi", "se", "b", "n", "body", "en", "event", "this", "ie", "ec", "ele", "f", "oe", "es", "o", "d", "ace", "ae", "error", "h", "me", "el", "element", "ze", "Exception", "a", "er", "E", "r", "et", "exec", "err", "c", "t", "ea", "x", "ed", "ef", "fe", "exc", "p", "ception"], "digest": ["Diger", " Digest", "Digusher", "mdester", "mdature", "Signate", "decature", " Digested", " digher", "digature", "logester", " Digator", "Digester", "Digest", " digested", " digator", "mdested", "Digator", "logest", " digenge", "digher", "mder", " digusher", " diger", "Signature", "digate", "digge", "mdusher", " Digester", "decate", " digester", "Digenge", "Digested", "logher", "digester", "mdate", "digator", "Digher", "decester", "decest", " digge", "digenge", "diger", "Signest", "digested", "mdest", "digusher", "Digge", "mdenge", "Signester", "logge"], "hash": ["text", "ash", "array", "message", "image", "build", "b", "sha", "body", "rh", "dot", "data", "bh", "ph", "dig", "f", "her", "result", "hex", "sum", "h", "key", "code", "total", "kh", "ashes", "header", "base", "mac", "hed", "string", "v", "history", "ha", "Hash", "sh", "value"], "rtn": ["gtn", "rdb", "vrnn", "retns", "RTne", "retb", "RTns", "gtb", "vrne", "retN", "rtc", "RTc", "rtb", "RTnin", "ntpn", "rtN", "ntN", "RTN", "rtns", "rdN", "ntn", "ntc", "latne", "vrns", "txn", "ortnn", "vrN", "gtN", "RTn", "ntb", "ortn", "latns", "RTb", "rtnn", "ortN", "retn", "RTpn", "latn", "rtpn", "latN", "rdn", "ntnin", "rtne", "gtpn", "txN", "rdns", "rtnin", "txnin", "RTnn", "txc", "ortne", "vrn"]}}
{"id1": "18731843", "id2": "20190303", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"doBody": [" doBytes", "handleFile", "handleBody", "DoResponse", "doBytes", "DoFile", "handleResponse", "doResponse", "DoBody", " doFile", "doFile", "handleBytes", "DoBytes", " doResponse"], "req": ["ref", "rx", "rec", "download", "config", "info", "this", "reg", "rr", "src", "conn", "serv", "qt", "qq", "q", "data", "resource", "proc", "requ", "spec", "obj", "query", "res", "rss", "respond", "fr", "jp", "comp", "def", "request", "r", "err", "crit", "cgi", "reader", "rh", "sem", "Request", "report", "http"], "resp": ["p", "pre", "ref", "ret", "result", "rec", "re", "cache", "download", "bb", "rr", "serv", "pos", "exc", "val", "data", "prot", "Resp", "job", "b", "proc", "Response", "obj", "rep", "res", "api", "sp", "inv", "respond", "jp", "respons", "comp", "html", "request", "part", "err", "response", "r", "rev", "cb", "cmp", "report", "reply"], "bis": ["phis", "uds", "mis", "tis", "ris", "bh", "sb", "bits", "obb", "bb", "fb", "bas", "sis", "ori", "iss", "ubis", "sin", "abi", "bian", "lis", "bid", "bps", "binary", "alis", "bi", "isin", "ses", "pins", "b", "os", "obi", "los", "usb", "is", "oris", "bs", "rots", "obos", "ais", "ios", "atis", "lins", "iris", "nis", "obs", "boot", "bin", "ois", "bes"], "bos": ["phis", "tis", "uds", "bh", "bits", "opus", "bones", "obb", "bris", "bas", "mos", "bo", "oops", "ubis", "antis", "bott", "abi", "obo", "bps", "bi", "ros", "bin", "obi", "os", "oks", "los", "oS", "zos", "oros", "bs", "zo", "fits", "obos", "las", "oos", "ios", "aos", "lol", "lins", "osa", "obs", "osi", "boot", "oses", "ois", "bes", "ops"]}}
{"id1": "14783950", "id2": "10218878", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressedWithSax", "compressedWithZip", "compresswithJar", "compresswithSax", "compressedUsingJar", "compressInSax", "compressUsingZip", "compressUsingJar", "compressUsingSax", "compressedUsingSax", "compressWithSax", "compressInJar", "compressWithJar", "compressInZip", "compressedWithJar", "compressedUsingZip", "compresswithZip"], "fileList": ["inputCollection", "FileString", "modelStream", "ziplist", "zipList", "fileString", "filelist", "fileEx", "fileSet", "inputList", "modelCollection", "wordList", " fileString", "FileStream", "modelEx", "zipName", "fileCollection", "modelList", "zipSet", "wordStream", " fileChain", "stringChain", " fileSet", "stringlist", "wordName", "fileChain", "FileSet", "FileList", " filelist", " fileEx", "FileChain", "stringName", " fileCollection", "inputStream", "fileStream", "FileName", " fileStream", "stringList", "wordString", "Filelist", "inputEx"], "zipFileName": ["zipFullDir", "folderFilename", "archiveDirDir", "folderGlobalPath", "zipGlobalNames", "zipPackageName", "archiveDirPath", "zipFilename", "folderGlobalname", "zipFileNames", "zipFullName", "zipFullPath", "zipFilePath", "zipDirDir", "zipGlobalName", "zipDirPath", "zipDirNames", "archiveFileDir", "folderFilePath", "folderFileName", "zipFileDir", "archiveFilePath", "zipGlobalPath", "archiveDirName", "zipFullname", "zipPackageDir", "zipGlobalname", "folderFileNames", "zipDirname", "folderGlobalNames", "zipDirName", "zipFullNames", "zipPackagePath", "archiveFileName", "folderGlobalName"], "fos": ["infaos", "fosh", "afis", "flis", "Faos", "FoS", "afoS", "afos", "afaos", "infoS", "Fosh", " fosh", "foS", "Fis", "infos", "flosh", "Fos", "faos", "flos", "infis"], "zos": ["lol", "webkit", "fits", "ZA", "cos", "zy", "bes", "budget", "bos", "outs", "zz", "gz", "os", "lins", "kos", "zl", "loop", "zag", "css", "rez", "zip", "oses", "ZI", "bag", "onz", "zon", "iframe", "fi", "jas", "tz", "zers", "nz", "abi", "packs", "uz", "closure", "z", "spin", "zer", "zb", "zx", "bis", "zik", "zzy", "zen", "zi", "LOS", "osi", "ozo", "jobs", "seconds", "inos", "zar", "zes", "ros", "es", "zan", "chini", "phi", "zo", "obb", "ses", "dos"], "iter": ["er", "f", "loc", "keep", "ener", "it", "ator", "gener", "inse", "slice", "el", "upper", "sort", "set", "ie", "is", "iner", "liter", "inner", "walker", "former", "fer", "ite", "e", "err", "fr", "iz", "ter", "izer", "test", "list", "i", "ner", "parse", "inc", "oper", "outer", "chain", "order", "next", "enter", "iterator", "ir", "ser", "finder", "http", "itter", "file", "Iterator", "index", "cher", "Iter", "coll", "inter", "ip", "end"], "fileName": ["FilePath", "FileString", " fileType", "fileType", "fullPath", "simplePath", "FileFull", "fileString", "FileType", "fName", "localPath", "simpleName", "FileInfo", "fileOpen", " fileInfo", " fileOpen", "fileData", " fileString", "FileLine", "fileLine", " filePart", "currentName", "pageString", "filePart", " fileUrl", "Filename", "fullOpen", "FilePart", "filenameInfo", " filePath", "currentUrl", " fileFull", "pageType", "pagename", "filenamename", "filenameFull", "localPart", "FileUrl", " fileData", "fileUrl", "filePath", "fileInfo", "filename", "fPart", " fileLine", "simpleOpen", "currentname", "fullName", "fileFull", "fname", "FileData", "fLine", "FileName", "localname", "pageName", "localName", "filenameName", "currentData", " filename"], "ind": ["x", "loc", "pt", "pend", "j", "div", "ix", "ld", "mid", "vert", "val", "end", "fr", "bind", "pull", "Ind", "d", "i", "count", "ci", "cond", "z", "inc", "ded", "wind", "mind", "eff", "ord", "ii", "inn", "in", "id", "index", "pos", "len", "rib", "dir", "nd", "length", "ad", "start", "IND"], "shortName": [" shortname", "ShortName", "fullPath", "fullname", "longName", "ShortString", " shortString", "ShortPath", "shortPath", " shortPath", "longPath", "smallPart", " shortLine", "shortLine", "longPart", "Shortname", "fullLine", "smallPath", "smallName", "ShortPart", "shortPart", "fullName", "smallname", "longname", "shortString", "longLine", "fullString", "shortname"], "fis": ["fiss", " fris", "cfos", "afis", "fisa", "gisa", "pris", "cfris", " fisa", "cfiss", "gios", "pisa", "gis", "afiss", "afos", "pis", "Fis", "pios", "Fiss", "cfs", " fiss", "afris", " fs", "fios", "Fs", "fris", "Fos", " fios", "gris", "cfis", "fs"], "buf": ["bin", "cur", "cb", "bd", "seq", "data", "loc", "ff", "bu", "batch", "lim", "buff", "bh", "rc", "feat", "bl", "bb", "b", "vec", "box", "br", "bytes", "done", "bp", "bag", "la", "rb", "buffer", "uc", "lb", "ba", "v", "Buff", "cv", "pb", "grab", "wb", "fd", "uf", "queue", "bf", "fb", "bc", "tmp"], "bytesRead": ["wordsUse", "flowsLength", "wordsWrite", " bytesUse", "bytesLength", "bytesSkip", "secondsWrite", " bytesSkip", "bitsWrite", "flowsNeed", "secondsRead", "bytesWrite", "wordsRead", " bytesWrite", "bitsRead", "tesRead", "bitsUse", "bytesNeed", "wordsLength", " bytesNeed", "bitsLoad", "tesLoad", "tesWrite", "secondsNeed", "flowsRead", " bytesLoad", "bitsLength", " bytesLength", "secondsLength", "bytesUse", "bytesLoad", "tesSkip", "flowsWrite", "bitsSkip"]}}
{"id1": "3584508", "id2": "5138455", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": [" downloadresource", " copyresource", " downloadUrl", "copyFile", " copyUrl", "copyresource", "copyUrl", "transferUrl", " downloadResource", " copyFile", "transferResource", "transferresource", " downloadFile", "transferFile"], "url": ["ls", "page", "uri", "ssl", "resource", "image", "server", "connection", "loc", "remote", "data", "f", "www", "URL", "ref", "bel", "download", "xml", "source", "src", "stream", "l", "lr", "web", "base", "r", "object", "id", "address", "string", "ource", "file", "loader", "re", "name", "sl", "host", "path", "Url", "http", "feed"], "input": ["request", "ssl", "resource", "image", "connection", "form", "act", "data", "this", "session", "inc", "socket", "in", "f", "audio", "index", "error", "reader", "accept", "out", "inf", "temp", "instance", "i", "source", "xml", "api", "config", "pull", "element", "qa", "progress", "stream", "l", "ack", "parse", "inner", "base", "client", "Input", "cache", "address", "exec", "bin", "file", "load", "upload", "binary", "get", "context", "current", "plus", "buffer", "but", "active", "http", "feed", "bb", "open"], "output": ["log", "writer", "console", "default", "unit", "resource", "write", "image", "flow", "copy", "connection", "outer", "data", "socket", "external", "application", "document", "result", "out", "source", "Output", "config", "network", "stream", "target", "web", "queue", "control", "object", "cache", "address", "file", "other", "binary", "ou", "layer", "environment", "response", "operation", "current", "put", "buffer", "production"], "b": ["buf", "k", "m", "p", "e", "n", "fb", "bit", "lb", "bc", "sb", "f", "bs", "pb", "d", "rb", "batch", "cb", "mb", "h", "bf", "B", "i", "a", "l", "db", "base", "bar", "r", "br", "v", "bin", "c", "file", "be", "ob", "binary", "bi", "x", "buffer", "ab", "abs", "nb", "line", "bb"]}}
{"id1": "21491791", "id2": "338852", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public static void sort(float norm_abst[]) {\n        float temp;\n        for (int i = 0; i < 7; i++) {\n            for (int j = 0; j < 7; j++) {\n                if (norm_abst[j] > norm_abst[j + 1]) {\n                    temp = norm_abst[j];\n                    norm_abst[j] = norm_abst[j + 1];\n                    norm_abst[j + 1] = temp;\n                }\n            }\n        }\n        printFixed(norm_abst[0]);\n        print(\" \");\n        printFixed(norm_abst[1]);\n        print(\" \");\n        printFixed(norm_abst[2]);\n        print(\" \");\n        printFixed(norm_abst[3]);\n        print(\" \");\n        printFixed(norm_abst[4]);\n        print(\" \");\n        printFixed(norm_abst[5]);\n        print(\" \");\n        printFixed(norm_abst[6]);\n        print(\" \");\n        printFixed(norm_abst[7]);\n        print(\"\\n\");\n    }\n", "label": 0, "substitutes": {"run": ["unit", "log", "create", "func", "worker", "process", "code", "apply", "running", "fork", "work", "job", "build", "all", "loop", "command", "start", "app", "spawn", "test", "runner", "call", "Run", "execute", "exec", "invoke"], "input": ["image", "flow", "index", "in", "resource", "raw", "feed", "storage", "view", "stream", "inner", "form", "audio", "Input", "worker", "active", "entry", "up", "text", "reading", "parser", "conn", "read", "driver", "initial", "state", "readable", "work", "control", "io", "out", "client", "context", "loader", "internal", "request", "data", "file", "user", "iterator", "instance", "connection", "config", "source", "address"], "output": ["writing", "image", "letter", "log", "written", "unit", "generated", "resource", "index", "temp", "outer", "end", "office", "write", "target", "text", "cache", "filename", "queue", "later", "environment", "object", "page", "application", "exit", "path", "job", "writers", "control", "console", "out", "response", "network", "Writer", "operation", "Output", "file", "data", "document", "user", "put", "web", "connection", "config", "source", "parent"], "reader": ["image", "slave", "in", "resource", "system", "view", "stream", "rer", "inner", "audio", "entry", "worker", "parser", "reading", "read", "driver", "builder", "ri", "r", "oder", "handler", "er", "author", "io", "row", "client", "context", "ner", "manager", "riter", "loader", "request", "peer", "wrapper", "server", "Reader", "source", "book", "owner", "rator"], "writer": ["writing", "her", "written", "wb", "outer", "office", "inner", "w", "write", "player", "wan", "entry", "worker", "wer", "ws", "engine", "builder", "driver", "ew", "r", "creator", "wa", "wr", "work", "er", "writers", "author", "wire", "nw", "out", "ner", "manager", "riter", "Writer", "word", "request", "ter", "wrapper", "data", "war", "maker", "rw", "writ", "or", "connection", "editor"], "pump": ["pamp", "prump", "Pumper", "camp", "ppump", "Pump", "dmp", "pdump", "ppumps", "humper", "dumps", "prdump", "pram", "Pdump", " pumping", " pam", "mump", "Pam", "prumper", "Pmp", " pmp", "Pumps", "hprint", " pamp", " pdump", "cumper", "pam", "Pprint", "Pumping", "pumping", "hump", "cump", "pumper", "dump", "pmp", "Pamp", "mprint", "ppumping", "mumps", " pumps", " pumper", "ppumper", "mumper", "pumps", "cumping", "humps", "pprint", "dumper"], "counter": ["num", "repeat", "index", "ver", "lr", "outer", "walker", "offset", "continue", "current", "inner", "step", "sequence", "order", "meter", "ener", "entry", "worker", "inter", "consumer", "version", "master", "count", "ger", "now", "race", "page", "builder", "code", "clock", "starter", "r", "collection", "rew", "author", "er", "hello", "Counter", "result", "pointer", "progress", "currency", "number", "row", "loop", "layer", "ner", "cookie", "loader", "trace", "ception", "runner", "keep", "ter", "server", "seed", "const", "instance", "second", "keeper", "center", "timer", "zero", "comment", "enter", "parent", "url", "processor"], "buffer": ["base", "resource", "entry", "channel", "text", "message", "queue", "uf", "page", "buf", "position", "buff", "uffer", "layer", "length", "loader", "server", "data", "file", "document", "reference", "port", "limit", "binary", "iter", "batch", "source", "Buffer", "url", "header", "address"], "off": ["flow", "o", "offs", "end", "offset", "of", "inner", "art", "head", "open", "ff", "Offset", "offer", "ref", "less", "area", "info", "ui", "now", "auto", "left", "set", "ord", "pos", "OFF", "fail", "opt", "addr", "out", "own", "start", "low", "on", "down", "oa", "unknown", "Off", "eno"], "len": ["body", "log", "lc", "in", "end", "lit", "val", "lf", "fin", "lan", "ref", "count", "ler", "lon", "den", "l", "bin", "ld", "pos", "fd", "li", "fl", "en", "line", "Len", "width", "lim", "all", "elt", "layer", "length", "size", "name", "ln", "on", "ll", "lt", "gen", "limit", "lock", "el", "n", "lib", "loc", "url", "lin"], "rd": ["dd", "nd", "dr", "lr", "fr", "rx", "ud", "val", "rid", "xd", "rt", "RD", "RR", "adr", "ld", " prod", " r", "rod", "ord", "rf", "r", "rc", "fd", "d", "ind", "db", "rob", "ds", "rand", "red", "rr", "nr", "rh", "raid", "ra", "rs", "hr", "rn", "rm", "rss", "rb", "rw", "rl", "ru", "cr", "dra"]}}
{"id1": "9261777", "id2": "4750967", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"source": ["zip", "string", "path", "address", "original", "index", "sin", "input", "id", "resource", "uri", "spec", "token", "Source", "element", "copy", "site", "slice", "project", "inner", "result", "dest", "se", "query", "info", "sort", "in", "SOURCE", "session", "use", "rule", "seed", "proxy", "target", "scope", "shared", "sample", "parent", "data", "text", "src", "file", "flat", "options", "config", "request", "size", "empty", "null", "style", "view", "start", "template", "force", "name", "image", "prefix", "sl", "secure", "strip", "url", "base", "unit", "parse", "comment", "missing", "ource", "service", "single"], "destination": ["distination", "Destignment", "dependination", "destinating", "homeignment", " destipping", "coordination", "Desturation", "databaseination", "Destinate", "Destinating", "databaseinated", "domuration", " destignment", "databaseinations", " destension", "destension", " destinate", "distipping", "dominated", " destinated", "destipping", "homeination", "distinated", "destinated", " destinator", "Destination", "Destinated", "distension", "homeinator", "Destinator", " destinating", "dependipping", "desturation", "dependension", "dependinated", "coordinating", "domination", "destinate", "destinator", "databaseuration", "homeinated", "coordinator", "Destinations", "destinations", "coordinate", "destignment", "dominations"], "is": ["zip", "info", "bis", "sin", "close", "i", "iss", "id", "serv", "fs", "IS", "lis", "isa", "ie", "Is", "act", "ic", "as", "ri", "se", "ins", "bs", "abs", "s", "ois", "ui", "in", "ori", "ii", "isl", "ops", "ais", "ar", "ob", "isc", "ir", "out", "ens", "nis", "src", "ip", "get", "es", "iso", "init", "or", "ai", "ris", "ci", "obs", "oss", "io", "eni", "ics", "iris", "ios", "us", "ib", "isi", "sis", "are", "was", "osi", "esi", "api", "cos", "mis"], "os": ["ou", "mos", "i", "oses", "sys", "Os", "fs", "op", "acs", "ks", "oa", "oise", "as", "dos", "OS", "o", "socket", "s", "bs", "ori", "ies", "so", "ros", "bos", "ops", "ais", "nos", "ob", "ens", "out", "ends", "es", "oes", "ose", "or", "vs", "ls", "aos", "obs", "js", "oss", "io", "ot", "pos", "ss", "ios", "us", "oS", "ds", "los", "ol", "ow", "osi", "boot", "cos"], "buffer": ["string", "address", "base", "border", "Buffer", "uffer", "feed", "copy", "server", "sequence", "slice", "limit", "result", "number", "read", "iter", "queue", "reader", "binary", "seed", "buff", "value", "buf", "wave", "data", "channel", "page", "size", "bb", "null", "header", "image", "writer", "layer", "position", "url", "bytes", "flush", "b", "reference", "padding", "pad", "transfer", "batch"], "length": ["index", "string", "total", "address", "id", "duration", "feed", "lower", "division", "lock", "character", "slice", "power", "sequence", "end", "limit", "number", "volume", "l", "match", "line", "quote", "weight", "split", "last", "offset", "key", "part", "type", "reader", "load", "value", "len", "Length", "ob", "section", "level", "data", "object", "size", "get", "row", "style", "start", "ring", "full", "strip", "position", "of", "url", "partial", "shape", "distance", "left", "range", "count", "age", "block", "width", "code", "point", "depth"]}}
{"id1": "659316", "id2": "14191679", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"argv": ["paramb", "argsf", " argver", "argumentver", "argf", " argl", "paramV", "argumentc", " argf", "argsv", "argl", "paramv", "argver", "Argve", "interV", "ArgV", "interl", "paraml", "argc", "Argl", " argV", "Argver", "Argv", "argumentve", "interc", "argb", " argb", "Argc", " argve", "argsl", "interv", "Argb", "argve", "argumentv", "argsc", "argV", "Argf", " argc"], "sources": ["psources", "fors", "tource", "vesores", "tources", "sesences", "statources", "issource", "statigs", "sores", "fource", "sresources", "fides", "sigs", "psource", "issources", "vesigs", "vesources", " sors", " sides", "sences", "tresources", "issides", "sesores", "statences", "sors", "issors", "psresources", "psides", "sesources", "fources", "fresources", "sides", "statores", "sesigs", "vesences", "tides"], "targets": ["tagnencies", "taxlets", "targends", " taxes", "targens", " taxends", "Targens", "tampels", " targens", "toket", "Targels", "tiges", "taxens", "tanglets", "taxets", "Tangets", "tagnets", "taxends", "taxels", "Tanglets", "targes", "tokets", "tagnet", "tagnens", "tangends", "tigens", "Tangens", "tamplets", " taxens", "tampets", "tangens", "tanges", "targels", " targes", " tokens", "targencies", "tokens", "Targlets", "tangets", " tokets", "tigets", "targlets", "tigends", "Targets", "taxes", " targends", "tanget", " taxets", "tampens", "tangels", "Tangels", " toket", " tokencies", "tokencies", " targencies", "tangencies"], "srclen": ["srCLength", "rscelEN", "srcelEN", "srplen", "rsclens", "srploen", "rsclEN", "srseln", "srctoen", " srcloen", "srselen", "srclens", "srClens", "srCln", "srClen", "srceln", "srselens", "rsclen", "srpleno", " srclength", " srploen", "rsceln", "rscelen", " srplength", "srclEN", "srClEN", "srcten", "srctength", "srcleno", "srCLen", "rscelens", " srcleno", "srcln", "srplength", "srcelen", "srselEN", " srpleno", "rscln", "srclength", " srplen", "srcteno", "srcelens", "srcloen", "srCLoen", "srCLeno"], "source": ["create", "remote", "copy", "cache", "uri", "current", "out", "client", "path", "config", "s", "use", "view", "seed", "event", "component", "model", "link", "driver", "ources", "input", "src", "ource", "image", "SOURCE", "single", "get", "Source", "in", "service", "resource", "proxy", "force", "self", "dest", "url", "sl", "secure", "rc", "scope", "channel", "size", "stream", "ssl", "slice", "id", "reader", "unit", "type", "parent", "start"], "tgt": ["tnt", " tgz", "hret", " tret", " tgs", " tgh", " tkt", "Targ", "Tkt", "Tch", "hnt", "bitarg", "hgz", "lret", "rkt", "ptgt", "Tgs", "tkt", "hgt", "tgz", "bitgt", "biticket", " tbuster", "tch", " tch", "tret", "targ", "rgt", "ticket", "lgz", "tgh", " targ", " tnt", "ptbuster", "Tgt", "lbuster", "rch", "Ticket", "larg", "lnt", "lgt", " ticket", "ptnt", "ptarg", "Tgh", "bitgh", "tbuster", "tgs", "rgs"], "target": ["match", "remote", "result", "output", "goal", "out", "port", "client", "path", "session", "current", "download", "point", "cross", "archive", "event", "component", "master", "tail", "driver", "nt", "slave", "view", "to", "arget", "conn", "project", "manager", "image", "service", "object", "Target", "resource", "director", "open", "force", "dest", "io", "core", "next", "url", "base", "null", "it", "child", "connection", "external", "channel", "handler", "plugin", "mount", "route", "unit", "parent", "member", "rel"], "deletes": ["deises", "delouts", "dedates", " dedates", "downdates", "degrades", "delises", "kesouts", "kesleted", "Deires", "desletes", "exletes", "desists", "disires", "disists", "desles", "exlete", "deles", "downletes", " deleted", "exdates", " deouts", "disletes", "deouts", "Deles", " degrades", "deleted", "delletes", "kesises", "exgrades", "disles", " deises", "Deists", "kesletes", "delleted", "Deletes", "downgrades", "desires", "deires", "deists", "delete", " delete", "downlete"], "del": ["local", "copy", "se", "dec", "clean", "update", "download", "model", "d", "de", "bl", "skip", "down", "install", "data", "nl", "dl", "up", "base", "name", "add", "null", "change", "Del", "sel", "fl", "delay", "neg", "lock", "coll", "el", "ll", "fail", "ul", "def", "file", "pull", "syn", "err", "remove", "dir", "diff", "id", "get", "Delete", "delete", " Del", " delete", "rel"]}}
{"id1": "17522011", "id2": "11556231", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "label": 0, "substitutes": {"read": ["reader", "READ", "open", "readable", "data", "get", "Read", "create", "type", "play", "send", "load", "find", "reads", "class", "add", "check", "include", "work", "parse", "build", "run", "select", "use", "connect", "feed", "process", "exec", "eval", "default", "reading", "resource", "input", "print", "report", "resources", "invoke", "write", "start"], "classLoader": ["resourceLoader", "ClassReader", "ClassPath", "resourceReader", " classPath", "classLoad", "resourceLoading", "fileDir", " classLoad", "ClassLoading", "classPath", "fileLoad", "ClassLoader", " classloader", " classDir", " classLoading", "classLoading", "filePath", "ClassDir", "resourceloader", "fileLoader", "fileloader", "ClassLoad", "classReader", " classReader", "classDir", "classloader", "Classloader"], "name": ["x", "connection", "active", "ame", "data", "type", "str", "class", "base", "part", "time", "size", "old", "alias", "root", "key", "address", "comment", "image", "child", "value", "large", "path", "parent", "filename", "default", "names", "n", "Name", "pass", "code", "null", "no", "file", "id", "word", "prefix", "search", "resource", "named", "home", "none", "string", "NAME"], "all": ["active", "full", "app", "f", "al", "at", "batch", "allow", "auto", "sync", "array", "partial", "any", "not", "only", "one", "local", "sort", "ann", "part", "ALL", "am", "with", "left", "l", "and", "each", "alls", "this", "call", "list", "All", "process", "attribute", "pass", "global", "both", "total", "named", "none", "alpha", "apply"], "sm": ["bm", "gm", "sl", "su", "sam", "si", "sn", "rm", "m", "sk", "em", "Sm", "im", "ama", "asm", "om", "imm", "sv", "hm", "wm", "zip", "vm", "ym", "smith", "service", "source", "sp", "mo", "api", "SM", "tm", "sw", "sum", "spe", "sa", "sy", "mm", "sr", "sb", "cm", "sf", "ss", "fm", "ms", "sym", "sim", "nm", "so", "km", "serv", "sh"], "enu": ["anun", " ennu", "Enu", "anus", "ennus", "venu", "ENu", "munU", "Enus", "enc", "encu", " enus", "venus", "enou", "ENus", "Ennu", "munu", "enU", "ennnu", "munus", "Enou", "enun", "venc", "ENc", "Encu", "ENou", "ennu", "venou", "Enun", "anu", "enncu", "anU", "munun", "EnU", "Enc", " encu", "enus"], "url": ["job", "connection", "sl", "f", "loc", "ur", "layer", "web", "download", "str", "ll", "base", "ls", "ssl", "page", "loader", "plug", "zip", "l", "r", "key", "address", "pull", "Url", "i", "URL", "source", "image", "path", "li", "server", "uri", "browser", "http", "in", "file", "id", "impl", "resource", "rel", "string"], "is": ["app", "ais", "Is", "iss", "isl", "si", "it", "ri", "ins", "p", "info", "ori", "has", "cms", "web", "os", "im", "ie", "isa", "IS", "ls", "isc", "abs", "inner", "was", "ops", "ar", "its", "i", "mis", "init", "image", "api", "or", "js", "ois", "vs", "close", "bis", "ir", "uri", "ii", "http", "ris", "as", "io", "iso", "id", "in", "iris", "ic", "act", "are", "es", "us", "ios", "lis", "esi", "serv", "ip", "ignore", "il", "isi"], "s": ["sl", "su", "f", "sg", "ts", "si", "rows", "ds", "g", "ins", "session", "m", "services", "sets", "sc", "p", "als", "se", "ns", "results", "ips", "outs", "os", "ows", "ssl", "ls", "ans", "u", "w", "abs", "ies", "les", "sv", "l", "r", "rs", "e", "o", "its", "lines", "strings", "ments", "d", "i", "S", "storage", "ws", "ings", "js", "spec", "h", "cs", "comments", "gs", "n", "ps", "details", "ions", "c", "es", "ss", "sf", "sb", "ches", "ms", "string", "ks", "ses"]}}
{"id1": "9996334", "id2": "4468255", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"generateToken": ["generationToken", "generATETokens", "generationSecret", "generATEKey", "generatedSecret", "generATESecret", "generationTokens", " GenerateTokens", "generateSecret", "generateTokens", "generatedToken", " GenerATETokens", "generATEToken", " GenerATESecret", " GenerateKey", " GenerateSecret", "generatedTokens", " GenerATEToken", " GenerateToken", "generationKey", "generateKey", " GenerATEKey", "generatedKey"], "code": ["text", "source", "message", "buffer", "ode", "token", "str", "output", "cache", "script", "c", "config", "info", "hash", "state", "input", "data", "mac", "next", "name", "password", "address", "hex", "Code", "body", "string", "header", "tag", "prefix", "codes", "cod", "value", "key", "id", "content", "coded"], "md": ["mand", "mm", "mp", "mod", "amd", "f", "hash", "wd", "dig", "cmd", "dm", "po", "ds", "mb", "meta", "ind", "mg", "m", "metadata", "ad", "mac", "editor", "grad", "rm", "sm", "ms", "kg", "pd", "sha", "gd", " MD", "od", "dd", "mo", "cm", "mt", "hd", "cd", "MD", "mc", "ma", "df", "mu", "mag", "pm", "d", "bd"], "bytes": ["parts", "bles", "Bytes", "units", "words", "output", "lines", "bits", "ips", "s", "buf", "seconds", "groups", "les", "data", "strings", "binary", "bps", "vs", "values", "pieces", "b", "objects", "files", "zip", "bs", "address", "body", "string", "codes", "outs", "es", "tes", "classes", "boot", "blocks", "bin"]}}
{"id1": "6188784", "id2": "4750967", "code1": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "to", " transfer", " cp", "cmp", "cp", "lock", "sync", " copying", "zip", "map", "split", "clone", "clip", "download", "move", "Copy", "create", " Copy", "change", "file", "transfer", "Cop", "put", "p", "cop"], "source": ["ins", "unit", "resource", "parent", "connection", "remote", "sync", "ie", "Source", "site", "input", "route", "ources", "i", "iter", "sin", "src", "reader", "stream", "target", "inner", "base", "slice", "id", "cache", "ource", "file", "start", "name", "origin", "up", "SOURCE", "down", "path", "use", "from"], "dest": ["exit", "style", "Dest", "destroy", "flat", "thin", "die", "later", "folder", "result", "d", "done", "comb", "test", " destination", "home", "temp", "src", "dir", "tmp", "target", "delete", "coord", "de", "which", "desc", "bin", "dist", "sup", "dc", "down", "wb", "cont", "orig", "img"], "in": ["into", "m", "include", "ins", "url", "resource", "image", "In", "parent", "n", "connection", "thin", "init", "inc", "socket", "ie", "gin", "f", "it", "input", "din", "IN", "inn", "s", "conn", "cin", "plugin", "i", "win", "sin", "reader", "src", "client", "inside", "nin", "issue", "pull", "login", "work", "inner", "base", "min", "r", "id", "ac", "pc", "bin", "err", "c", "con", "file", "name", "up", "pin", "ini", "as", "plus", "again", "isin"], "out": ["at", "prefix", "ex", "writer", "vert", "write", "one", "plain", "call", "parent", "n", "connection", "io", "outer", "off", "this", "sync", "outside", "socket", "not", "channel", "output", "no", "part", "exp", "o", "password", "Out", "timeout", "conn", "our", "cat", "i", "client", "inner", "outs", "id", "exec", "bin", "file", "err", "obj", "name", "option", "other", "extra", "up", "net", "ou", "OUT", "w", "pool", "down", "buffer", "again", "lib", "ext"], "size": ["ize", "unit", "e", "length", "count", "izes", "offset", "n", "speed", "loc", "en", "empty", "depth", "si", "scale", "sync", "shape", "mode", "SIZE", "sum", "sec", "seek", "small", "bytes", "end", "time", "flush", "add", "max", "width", "ice", "sized", "capacity", "len", "number", "any", "send", "address", "Size", "start", "name", "order", "clear", "x", "content", "transfer", "iz", "close", "export", "open"], "buf": ["cv", "uf", "uc", "b", "cmp", "fb", "data", "Buffer", "bc", "map", "bag", "coll", "BU", "rb", "bytes", "cb", "cas", "bf", "pkg", "bd", "src", "buff", "ff", "len", "fam", "ba", "br", "bin", "la", "ctx", "vec", "ha", "cf", "ra", "buffer", "box", "seq", "feat"]}}
{"id1": "5274228", "id2": "23310397", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "label": 0, "substitutes": {"put": ["create", "cache", "output", "client", "parse", "st", "Put", "update", "PUT", "build", "data", "resource", "format", "transform", "add", "UT", "transfer", "post", "operation", "string", "patch", "write", "submit", "replace", "file", "pull", "get"], "resourceID": ["serviceIDs", "responseKey", "resourceId", "serviceId", "objectIDs", "ResourceURL", "responseID", "responseURL", "objectId", "resourceid", "resourceURL", "objectid", "resourceIDs", "resourceKey", "ResourceID", "responseId", "Resourceid", "requestId", "ResourceId", "objectID", "ResourceKey", "serviceID", "requestURL", "serviceid", "requestID", "ResourceIDs", "requestKey"], "headersMap": [" headersFile", "httpMap", "httpSet", "headersSet", "ersFile", "headersFile", "headerSet", "httpArray", "httpList", " headersSet", "headerList", "headerFile", "headerMap", "ersArray", "headerArray", "ersMap", "ersList"], "httpClient": ["HttpClient", "httpsClient", "ttpClient", "httpContext", " httpContext", "phpCall", "httpConnection", "httpsPut", " httpCall", "ttpConnection", "httpsBase", "HttpContext", " httpConnection", "httpServer", "httpsConnection", "HttpPut", "httpCall", "httpsServer", "httpCase", "httpBase", "ttpPut", "HttpServer", "HttpCase", "phpClient", " httpCase", " httpBase", "phpCase", "ttpBase", "HttpCall", " httpServer", "httpsContext", "phpPut"], "httpPut": ["HttpClient", "HttpPush", "phpPush", "phpSplit", "httpsClient", "phpGet", "viewPUT", " httpGet", "viewPut", " httpPUT", "phpAdd", " httpWrite", "httpsPut", "httpsPUT", "httpDo", "webPush", "httpGet", "httpsSplit", "webPut", "httpSplit", "httpPush", "httpsAdd", "HttpDo", "HttpPut", "internalPut", " httpAdd", "Httpput", "httpWrite", "internalGet", "internalPush", "httpput", "internalWrite", " httpPush", "httpAdd", "phpWrite", "webPUT", "httpsPush", "HttpPUT", "HttpGet", "httpsput", "httpPUT", "viewPush", "httpsGet", "viewput", " httpSplit", " httpDo", "httpsDo", "webGet", "phpPut"], "headersList": ["driversMap", " headersL", "headersSet", "ersL", "headerSet", " headersSet", "driversL", "headerList", "headerMap", "ersArray", "headerArray", "driversArray", "ersList", "headersL", "headerL", "driversList", "ersSet"], "iterator": ["vector", "sequence", "init", "set", "starter", "inner", "basic", "finder", "instance", "ter", "driver", "processor", "ie", "pointer", "gener", "loader", "walker", "writer", "done", "started", "later", "multi", "operator", "division", "next", "Iterator", "interstitial", "runner", "outer", "random", "Iter", "ator", "append", "li", "former", "size", "handler", "engine", "stream", "kick", "parser", "iter", "creator", "eni", "loop", "collection", "start", "step", "slice", "entry", "end", "reader", "inter", "oper", "ski", "adder"], "headersArray": ["filesAr", "headsList", "filesArray", "headsLength", "ersAr", " headersAr", "hersAr", "filesMap", " headersHash", "headsArray", "headersLength", " headersLength", "ersArray", "hersList", "ersMap", "hersArray", "filesHash", "headersHash", "ersHash", "hersLength", "headsAr", "headersAr"], "fields": ["FIELD", "types", "lines", "json", "field", "keys", "dates", "data", "errors", "format", "values", "params", "files", "zip", "body", "region", "prefix", "codes", "details", "Field", "properties", "dir", "comments", "pattern", "rows", "content"], "occiHeaders": ["occiBuilders", "occiBuilderers", "ocsiHeadlers", "ocsiBufflers", "occiHostlers", "occiBuffers", "ocsiHeaders", "occiHoster", "occiBuffer", "ocsiHeader", "ocsiBuffer", "occiBufflers", "occiHosterers", "occiHeader", "occiHeadlers", "occiHeaderers", "occiBuilder", "ocsiHeaderers", "ocsiBufferers", "occiBufferers", "occiHosters", "occiBuildlers", "ocsiBuffers"], "H": ["Hop", "F", "J", "HC", "L", "HT", "Header", "Length", "HR", "HS", "HTTP", "TH", "M", "I", "SH", "N", "B", "OH", "NH", "G", "W", "X", "C", "Index", "HH", "R", "DH", "HE", "HM", "T", "EH", "V", "ID", "HI", "K", "MH", "D", "Q", "Handler", "CH", "HB", "Y", "U", "S", "rh", "P", "Head"], "header": ["message", "bridge", "result", "buffer", "token", "Header", "feature", "cover", "inner", "frame", "f", "info", "back", "head", "ter", "event", "extra", "cher", "driver", "per", "ler", "ker", "manager", " request", "writer", "definition", "service", "consumer", "builder", "metadata", "later", "comment", "document", "outer", "server", "player", "dr", "string", "rule", "holder", "former", "detail", "handler", "layer", "second", "block", "value", "file", "request", "row", "key", "er", "response", "her", "entry", "reader", "liner", "http"], "statusLine": ["responseLine", "statusBody", "StatusLine", "statusFile", "StatusText", "StatusFile", "StatusString", " statusBody", " statusText", " statusString", "StatusCode", "responseFile", "responseText", "StatusBody", " statusFile", "errorLine", "statusString", "statusText", "errorCode", "errorBody", "responseCode", "errorString"], "httpResponse": ["Httpresponse", "httpresponse", "HttpEnvironment", "ttpResult", " httpPage", "HttpBlock", "statusBody", " httpEnvironment", "statusResponse", "httpResp", "HttpBody", "statusResult", "actualResponse", " httpResult", "httpsRequest", " httpBody", "actualresponse", "actualLine", "HttpLine", "httpBlock", "ttpResponse", "HttpStatus", " httpResp", "httpPage", "httpsPage", "httpsResponse", " httpStatus", "statusBlock", " httpRequest", " httpLine", "ttpResp", "httpResult", "HttpResponse", "templateResponse", "HttpPage", "httpRequest", "templateLine", "httpLine", "httpsEnvironment", "actualRequest", "httpStatus", "httpsBody", "httpEnvironment", " httpresponse", "HttpResp", "httpsResult", "HttpResult", "httpBody", "ttpRequest", "HttpRequest", "templateStatus", " httpBlock", "templateResp"], "statusCode": [" statusType", "StatusCount", "responseLine", " statuscode", "StatusLine", "errorType", "StatusType", "StatusData", "StatusText", "statusData", " StatusLine", " statusCount", "responseType", "StatusCode", "resultcode", "responseText", " StatusData", "statuscode", "errorText", "resultCode", "statusType", " StatusCode", "statusCount", "errorLine", "resultCount", " StatusType", "statusText", "resultLine", " statusData", "errorCode", "responseCode", "Statuscode"]}}
{"id1": "16388708", "id2": "18613870", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "17856064", "id2": "3053403", "code1": "    public static PersistencyParameters parse(String unitName) {\n        URL[] persistenceUnits;\n        try {\n            persistenceUnits = Classpath.search(\"META-INF/\", \"persistence.xml\");\n        } catch (IOException e) {\n            throw new Error(e);\n        }\n        Set classes = new HashSet();\n        for (int i = 0; i < persistenceUnits.length; i++) {\n            URL url = persistenceUnits[i];\n            try {\n                nu.xom.Builder b = new nu.xom.Builder(false);\n                Document d = b.build(url.openStream());\n                Nodes unitNodes = d.getRootElement().query(\"//p:persistence-unit\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                for (int j = 0; j < unitNodes.size(); j++) {\n                    Node unitNode = unitNodes.get(j);\n                    Element unitElt = ((Element) unitNode);\n                    String uName = unitElt.getAttributeValue(\"name\");\n                    if (!uName.equals(unitName)) continue;\n                    {\n                        PersistencyParameters parameters = new PersistencyParameters();\n                        Nodes classNodes = unitElt.query(\"//p:property\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                        for (int k = 0; k < classNodes.size(); k++) {\n                            Node classNode = classNodes.get(k);\n                            if (!(classNode instanceof Element)) continue;\n                            Element classElt = (Element) classNode;\n                            String elementName = classElt.getAttribute(\"name\").getValue();\n                            if (elementName.equals(\"eclipselink.jdbc.url\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setJdbcUrl(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.user\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBUserName(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.password\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBPassword(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.driver\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBDriverClassName(elementValue);\n                            }\n                        }\n                        return parameters;\n                    }\n                }\n            } catch (Exception x) {\n                x.printStackTrace();\n                throw new Error(x);\n            }\n        }\n        return null;\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "label": 0, "substitutes": {"parse": [" structure", " start", " load", " analyze", " parsing", " resolve", " process", " extract", " pars", " inspect", " constructor", " parsed", " validate", " discover", " scan", " assemble", " check", " params", " read", " compile", " parser", " execute", " install", " ls", " test", " analyse"], "unitName": ["uiValue", "unitsNames", "Unitname", "uiType", "Unit1", "unitsName", "machineValue", " unitType", "units1", "unit1", "machineName", "unitValue", "unitPath", "unitsname", " unitname", "machineType", " unitPath", "machinePath", "UnitName", "UnitNames", "uiName", "unitNames", " unit1", "unitname", "unitType", " unitValue", " unitNames", "uiPath"], "persistenceUnits": ["persistanceUnitit", "persistenceClites", "persistenceOperits", "persistanceUnunits", "persistenceUnunits", "persistanceUnITS", "persistanceUnites", "persistanceClITS", "persistenceUnitITS", "persistanceUnitits", "persistenceunits", "persistenceClITS", "persistenceLogists", "persistenceununits", "persistanceUnitodes", "persistenceUNITS", "persistenceUnitodes", "persistenceUites", "persistenceUnititions", "persistenceUNitions", "persistanceClits", "persistenceUnitits", "persistenceUnitions", "persistanceUnitists", "persistenceUnitunits", "persistenceUNites", "persistenceUnites", "persistanceUnitions", "persistanceUnitites", "persistenceUnists", "persistenceUNodes", "persistenceClitions", "persistenceUnodes", "persistenceLogunits", "persistanceUnit", "persistenceClits", "persistenceOperites", "persistenceOperodes", "persistenceunists", "persistenceLogits", "persistenceunites", "persistenceUNit", "persistenceUnitit", "persistenceUNits", "persistanceUnodes", "persistenceUnITS", "persistanceUnitunits", "persistenceLogites", "persistenceUnit", "persistenceUits", "persistanceClitions", "persistanceClites", "persistenceUnitites", "persistenceOperit", "persistanceUnits", "persistanceUnitITS", "persistanceUnists", "persistenceUit", "persistenceUITS", "persistenceUnitists"], "classes": [" configurations", " constants", " interfaces", "ps", " suites", " protocols", " groups", "es", "groups", "result", " class", "set", " models", " packages", " instances", "results", "class", "properties", " sources", "Class", "resources", " assignments", " formulas", "names", " tests", "params", " Classes", "services"], "i": ["p", "u", "z", "uri", "n", "fi", "ori", "info", "si", "ie", "in", "f", "ni", "index", "ci", "iu", "oi", "ji", "multi", "y", "li", "di", "l", "mi", "ip", "pi", "xi", "hi", "eni", "yi", "id", "ti", "v", "gi", "ix", "I", "ai", "phi", "ini", "ii", "ui", "x", "bi", "qi", "ri"], "url": ["ls", "ur", "uri", "ssl", "resource", "image", "server", "connection", "io", "data", "username", "link", "in", "entry", "f", "route", "URL", "href", "xml", "element", "plugin", "source", "api", "config", "filename", "l", "web", "base", "user", "address", "string", "file", "name", "service", "up", "sl", "path", "Url", "location", "http"], "b": ["m", "p", "e", "build", "n", "fb", "bt", "bh", "Builder", "bc", "verb", "sb", "f", "bis", "pb", "o", "rb", "cb", "B", "builder", "bd", "library", "a", "l", "db", "base", "r", "br", "v", "c", "obj", "gb", "be", "ob", "lib", "wb", "hub", "ab", "eb", "bs", "bb"], "d": ["fd", "ds", "m", "u", "dos", "e", "g", "n", "dot", "data", "md", "dd", "f", "dat", " D", "s", "xml", "dl", "dm", "dir", "pd", "di", "l", "db", "r", "D", "id", "c", "dc", "t", "did", "dom", "director", "p", "dt", "df"], "unitNodes": [" unitNideos", "unitnoded", "unitSnodes", "unitNoms", "unitSnode", " unitNoded", "unitNeodes", "unitnobs", " unitNoms", "unitDodes", " unitNurs", " unitNubes", " unitnodes", "unitNubes", "unitNurs", "unitnideos", "unitSnoded", "unitNeode", "unitnurs", " unitNobs", "unitNeoms", " unitnurs", "unitNideos", "unitnodes", "unitnubes", "unitRenoms", "unitDurs", "unitRenobs", " unitnoms", "unitNobs", "unitNeoded", "unitSnoms", "unitNoded", "unitRenubes", " unitnoded", "unitnoms", "unitDideos", "unitnode", "unitRenodes", " unitnode", " unitnideos"], "j": ["ij", "jen", "js", "u", "fr", "z", "g", "n", "kj", "je", "jc", "ie", "syn", "f", "ni", "it", "jj", "jet", "ja", "jit", "ch", "dj", "job", "uj", "key", "aj", "ji", "J", "h", "jo", "y", "section", "l", "bj", "br", "v", "obj", "jl", "ii", "qi", "json", "jp", "note", "q", "p"], "unitNode": ["connectionElement", "tunElement", "connectionPath", "UnitNode", "tunNode", " unitN", "unitsName", " unitElement", "unitPath", "UnitPath", "connectionNode", " unitPath", "tunnode", "unitsnode", "unitN", "tunName", "UnitN", "connectionN", "unitElement", "unitsElement", "unitsNode", "unitnode", " unitnode", "UnitElement"], "unitElt": ["unitOlt", " unitELT", "unitEsld", "unitNlt", "unitUxt", "elementElt", " unitExt", "unitEld", "unitEselt", "unitUler", "unitExt", "elementEslet", "elementEld", "elementEselt", " unitUlt", " unitEler", "unitOelt", "unitNelt", " unitOlt", " unitOLT", "unitGeld", "unitext", " unitUler", "unitIlem", "uniteelt", " unitOld", "unitELT", "unitNld", "unitElem", "elementEslt", "unitelt", "unitIxt", "unitGeLT", "unitEslet", "unitOlet", "unitIlt", "unitOld", "unitUlem", "uniteler", "unitEslt", "elementEelt", " unitOelt", "unitGelt", "unitEler", "unitelet", " unitUlem", "unitUlt", "elementElet", " unitUxt", "unitEelt", "unitNLT", "unitIler", "uniteld", "unitElet", " unitEelt", " unitEld", "unitOLT", " unitElem", "unitelem", "unitGeelt", "elementEsld"], "uName": ["uNode", " uNode", "duNode", "uPath", "suValue", "suName", "unitValue", " uname", "unitPath", "uValue", " uValue", " uPath", "duValue", "duNames", "uNames", "uname", "unitNames", "suname", "suPath", "unitname", " uNames", "duName"], "parameters": ["paramParameters", "paramels", "aramels", "arameters", "pams", "pareters", "prometer", "pumers", "paramsels", "parumers", "paramumers", "prometers", "perseters", "peters", "paramseters", "paramseter", "promels", "arameter", "paramsParameters", "aramParameters", "promParameters", "pels", "params", "parameter", "paramams", "persams", "persumers", "persels", "parels"], "classNodes": ["classCode", "Classnode", "ClassNode", "classEodes", "classEanks", "classCoded", "classClements", "classCodes", "classnoded", "fieldNodes", "Classnodes", "classEoded", "classSode", "fieldNinodes", "classNeoded", "fieldNinode", "classVobs", "ClassNanks", "classNinodes", " classClements", "classVode", "classSnlements", "classnanks", "fieldNODE", " classNlements", "classNeodes", "classnode", "ClassNoded", "ClassNodes", "Classnoded", "classSnode", "classnodes", "fieldNobs", "classVodes", "Classnanks", "classNinode", "classVODE", "classSobs", "classNoded", "classNanks", "classSnodes", "classNelements", "classSODE", " classCode", "classNobs", "classNinobs", "classNinODE", "classEode", "fieldNinODE", "classNlements", "classNODE", "fieldNinobs", " classNoded", " classCodes", "fieldNode", "classSodes", "classSnoded", "classNeode", " classCoded"], "k": ["ks", "ky", "kr", "K", "dk", "kat", "z", "kid", "ku", "g", "ok", "n", "ki", "ek", "km", "kick", "f", "ck", "ch", "ko", "kn", "key", "h", "y", "work", "kk", "kw", "ad", "r", "id", "v", "unk", "c", "ke", "w", "sk", "q", "p", "ik"], "classNode": [" classFile", " className", "Classnode", " classSource", "ClassNode", "configSource", "busFile", "ClassFile", "fileNode", " classnode", "classFile", "fileTree", "configName", "baseTree", "className", "baseRoot", "busNs", "ClassNs", "classnode", "elementElement", "classRoot", " classNs", "elementTree", "classElement", "elementNode", "classNs", "configNode", "fileElement", "elementRoot", "fileRoot", "baseNode", " classElement", "busnode", "classTree", "busNode", "baseElement", "classSource", "configElement", "elementSource"], "classElt": ["classOlt", "classeld", "elementeelt", "elementElt", "ClassElem", "classYelt", "ClassExt", "elementEld", "elementext", "classUlem", "classOxt", "classelt", "classYlem", "classXler", "classEld", "ClassEld", "classext", "classEelt", "classXelt", "classeelt", "ClassOxt", "ClassXelt", "classelem", "classElem", "Classelem", "ClassXld", "classYler", "classYlt", "classXxt", "Classeelt", "classXLT", "ClassElt", "ClassELT", "classUlt", "ClassEler", "elementEelt", "elementeld", "ClassXlt", "ClassOld", "classUld", "Classeld", "Classelt", "classeLT", "ClassEelt", "elementExt", "classOld", "classOler", "classUelt", "ClassOlt", "ClassOler", "classYld", "classEler", "classUxt", "elementelt", "ClassXLT", "classYxt", "classELT", "classXlt", "classXld", "classExt"], "elementName": ["typeFamily", "elementPath", "typeAnn", "typeApp", "layerFamily", "moduleValue", "typeName", "elementAnn", "sectionFace", "className", "elementFace", "layerAnn", "layerApp", "sectionName", " elementFamily", "articleFamily", "sectionFamily", "elementFamily", " elementname", "elementApp", "articleAnn", "stringName", "classValue", "moduleName", "stringFamily", "articleName", " elementFace", "modulePath", "layerName", "classPath", "elementname", "stringFace", "articleApp", " elementPath", "modulename", "classname"], "elementValue": ["stylevalue", "optionValue", "styleText", "elementString", "elementVal", "objectString", "objectValue", "entryText", " elementVal", "Elementvalue", "optionVal", "objectvalue", "optionString", "objectVal", "entryVal", "entryvalue", "ElementVal", "memberText", "styleValue", "memberVALUE", "styleVALUE", "ElementVALUE", "optionvalue", "elementvalue", "memberVal", " elementVALUE", "ElementValue", "ElementString", "entryVALUE", "memberValue", "elementVALUE", " elementText", "elementText", "ElementText", "entryValue"]}}
{"id1": "6371607", "id2": "4164833", "code1": "    public void removeRealm(final List<Integer> realmIds) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"realm.remove\"));\n                    Iterator<Integer> iter = realmIds.iterator();\n                    int realmId;\n                    while (iter.hasNext()) {\n                        realmId = iter.next();\n                        psImpl.setInt(1, realmId);\n                        psImpl.executeUpdate();\n                        cmDB.removeRealm(realmId);\n                    }\n                }\n            });\n            connection.commit();\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                }\n            }\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 0, "substitutes": {"removeRealm": ["removeLocalM", "removeLocalam", "removeRealme", "removeRelms", "removerealme", "removeRealM", "removeBroadm", "removeLocalms", "delRealm", "removeRelam", "delBroadM", "delRealM", "deleteRealam", "delRealms", "removeScheme", "deleterealM", "removeRelm", "deleteRealm", "removerealM", "removeBroadms", "removeSchem", "removeBroadme", "deleteRealms", "removeLocalm", "deleterealms", "removeRealam", "removerealms", "delBroadms", "removeBroadM", "removeRelM", "removeRealms", "removerealam", "deleterealam", "deleterealm", "removerealm", "removeSchems", "delBroadme", "delRealme", "delBroadm", "removeScheM", "deleteRealM"], "realmIds": ["realmRefs", "realMPathids", "realMIds", "realmIDls", "realMIdls", "realmIDList", "realmRefids", "realmInts", "realmRefls", "realmRefList", "realMPathes", "realmIdos", "realMIdList", "realmIntids", "realmIdList", "realMByIdls", "realmByIds", "realmByIdList", "realMIdes", "realmByIdls", "realmRefes", "realmPathids", "realmByIdes", "realMByIdes", "realmIntes", "realMPathos", "realmIdes", "realMByIdList", "realmPathes", "realMByIds", "realmIDs", "realmIdls", "realmPaths", "realmIntos", "realMPaths", "realmRefos", "realmIDes", "realMIdos", "realmPathos", "realmIdids", "realMIdids"], "psImpl": ["csImpl", " psIter", "epsIter", "cssImpl", "qsimpl", "csimpl", " psimpl", "epsHelper", "dsImpl", " psHelper", "cssExpl", "dsHelper", "psHelper", "psimpl", "dsimpl", "qsHelper", "qsImpl", "psIter", " psExpl", "epsimpl", "cssimpl", "epsImpl", "cssIter", "epsExpl", "csHelper", "psExpl"], "iter": ["ite", "index", "upper", "i", "itter", "outer", "cer", "entry", "ie", "inter", "inner", "end", "limit", "walker", "ter", "gener", "el", "line", "sort", "in", "ler", "next", "loop", "er", "izer", "reader", "ner", "inc", "ir", "page", "ator", "iterator", "Iter", "init", "coll", "e", "it", "cher", "parse", "err", "apper", "finder", "former", "list", "enter", "loc"], "realmId": [" realmnHash", "realmOffset", "realmnOffset", "RealmsID", " realmHash", "realmcId", "realmnId", "realmePath", "ironmaId", "RealmName", "realmrId", "realmName", "realdmConfig", "realmInt", "realmPath", "realmsName", "workmNum", "realmeId", "realmid", "ironmRef", "realmConfig", "ironmID", " realmOffset", "realmID", "realdmId", "workmId", "workfID", "realmNum", " realmnConfig", "workfid", "realmnHash", "RealmID", "realmeName", "realrmId", "realmsId", " realmnId", "ironmId", "ironmaRef", "realmHash", "realmrid", "realrmID", "ironmaInt", "workfNum", "realarmPath", "realamid", "RealmPath", "RealmId", "realmRef", "realmcID", "ironmaID", "realfid", "realmrOffset", "workfId", "realfId", "realarmID", "workmid", "realmsPath", "realrmInt", "realmrID", "realmsID", "realmcRef", "realmeID", "realmaID", "realarmId", "realmrHash", "realmaInt", "realdmOffset", "RealmsId", "realarmName", "realmrNum", "realdmHash", "realmaRef", "ironmInt", "realamNum", " realmConfig", "RealmsName", "realfNum", "realmcInt", "workmID", " realmnOffset", "realfID", "RealmsPath", "realrmRef", "realmnConfig", "realamId", "realmaId", "realmrConfig", "realamID"]}}
{"id1": "6304373", "id2": "5676111", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrtemFiles", "uploadOrDeleteMediaOrtemplates", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrMemplates", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrtempl"], "action": ["next", "error", "what", "service", "flash", "element", "flow", "view", "version", "parent", "environment", "section", "module", "state", "format", "ACTION", "resource", "ction", "operation", "change", "function", "step", "now", "part", "active", "url", "actions", "api", "type", "test", "activity", "status", "controller", "call", "method", "activation", "name", "site", "plugin", "style", "commit", "Action", "item", "lock", "act", "event", "effect"], "object": ["request", "ject", "image", "auto", "email", "service", "obj", "element", "full", "host", "class", "oid", "instance", "version", "parent", "environment", "office", "directory", "address", "objects", "group", "module", "target", "not", "resource", "zone", "thread", "function", "now", "edit", "part", "url", "letter", "o", "none", "mode", "model", "system", "subject", "article", "number", "document", "node", "project", "string", "lock", "event", "current", "self"], "numElements": [" numelement", "numGelement", "numEllements", "numelements", "numElem", "numGeodes", "numGelem", "numGelements", " numEodes", " numeodes", " numElem", "numEodes", "numEllem", "numEllement", " numelements", "numeodes", " numelem", "numelem", "numelement", "numElodes"], "req": ["next", "gr", "r", "obj", "ctx", "g", "msg", "html", "use", "load", "ro", "parent", "module", "report", "params", "xml", "conf", "resp", "mr", "util", "base", "update", "builder", "err", "log", "res", "verb", "usr"], "session": ["request", "image", "client", "h", "service", "ctx", "flash", "use", "context", "scope", "global", "instance", "sa", "cache", "Session", "state", "result", "connection", "http", "container", "response", "resource", "manager", "thread", "security", "system", "temp", "local", "token", "test", "ESSION", "subject", "document", "browser", "site", "lock", "event", "ession", "person", "shared", "sp"], "ftp": ["ttp", "ftP", "ttP", " ftcp", "FTc", " ftc", "ftcp", "FTcp", "ftc", "FTP", "ttcp", "ttc", "FTp", " ftP"], "user": ["image", "account", "db", "error", "client", "self", "match", "creator", "User", "html", "full", "author", "class", "profile", "use", "view", "USER", "comment", "used", "bug", "e", "ee", "parent", "page", "rule", "home", "per", "info", "group", "module", "result", "state", "connection", "ver", "path", "post", "mail", "url", "this", "pass", "base", "data", "type", "system", "log", "er", "users", "other", "admin", "record", "name", "auth", "browser", "by", "member", "custom", "facebook", "string", "project", "usa", "hash", "usr", "lock", "current", "person", "shared", "config", "username"], "links": ["items", "image", "details", "email", "styles", "flash", "html", "tree", "Link", "headers", "lines", "posts", "Links", "images", "results", "members", "mail", "link", "url", "pages", "actions", "base", "log", "groups", "linked", "ids", "mails", "menu"], "folders": ["anchors", "filers", "anchages", "handries", "anchers", "handers", "filors", "handages", "foldors", "filages", "anchries", "foldries", "handors", "foldages", "filries"], "folder": ["email", "level", "upload", "element", "layout", "scope", "slice", "theme", "layer", "future", "enter", "id", "directory", "archive", "picture", "address", "home", "division", "connection", "location", "region", "path", "resource", "editor", "zone", "ignore", "fold", "dir", "area", "url", "device", "letter", "zip", "flat", "license", "append", "database", "Folder", "document", "volume", "plugin", "project", "two", "network", "sample", "menu", "command", "uri", "source", "filename"], "server": ["account", "localhost", "client", "email", "service", "host", "socket", "master", "version", "slave", "enter", "page", "erver", "directory", "port", "address", "connection", "location", "inner", "resource", "ssl", "manager", "value", "peer", "url", "engine", "device", "scale", "system", "type", "database", "token", "status", "node", "Server", "site", "reader", "string", "remote", "seed", "network", "uri", "ser", "outer", "source", "filename", "username"], "login": ["blog", "account", "blank", "email", "service", "access", "pin", "label", "profile", "socket", "layout", "consumer", "basic", "picture", "cookie", "info", "group", "connection", "path", "resource", "Login", "ssl", "mail", "config", "url", "pass", "skin", "log", "database", "users", "shell", "status", "secret", "name", "auth", "site", "plugin", "string", "network", "bridge", "sudo", "lock", "journal", "machine", "filename", "username"], "password": ["timeout", "email", "access", "worker", "profile", "pattern", "ass", "username", "basic", "slave", "photo", "directory", "sword", "picture", "mask", "phrase", "cookie", "alias", "padding", "Password", "strip", "connection", "division", "word", "PASS", "manager", "pass", "security", "token", "secret", "database", " passwords", "language", "name", "auth", "volume", "plugin", "string", "column", "sudo", "device", "filename", "account"], "fileTransferFolder": ["FileTransferTheme", "fileUploadServer", "fileAccessTheme", "fileImportDirectory", "fileTransferServer", "fileUploadTheme", "fileUploadFolder", "fileTransferDirectory", "mediaTransferfolder", "fileTransferfolder", "FileTransferfolder", "mediaUploadServer", "fileTransformFolder", "FileUploadPath", "fileAccessfolder", "FileUploadfolder", "FileTransferFolder", "fileAccessFolder", "fileTransformfolder", "fileTransferTheme", "FileUploadFolder", "fileTransformTheme", "fileImportFolder", "fileAccessPath", "fileUploadDirectory", "fileTransformPath", "mediaTransferFolder", "FileUploadTheme", "FileTransferPath", "mediaTransferServer", "fileUploadPath", "fileUploadfolder", "fileImportServer", "mediaTransferDirectory", "fileImportfolder", "mediaUploadfolder", "mediaUploadFolder", "mediaUploadDirectory", "fileTransferPath"], "liveFolder": ["Livefolder", " liveDirectory", "livefolder", "LiveLocation", "liveLocation", "Previewfolder", "PreviewFolder", "LiveDirectory", "LiveFolder", " liveLocation", " livefolder", "liveDirectory", "PreviewDirectory", "PreviewLocation"], "servers": ["servServer", " serServer", "serServer", "servations", "serations", "Serations", "Servers", "servls", "serls", " serls", " serations", "Serls", "servvers", "SerServer"], "message": ["request", "image", "error", "details", "buffer", "mess", "email", "flash", "element", "msg", "summary", "page", "address", "module", "content", "array", "response", "resource", "path", " messages", "Message", "manager", "description", "mail", "url", "update", "log", "status", "application", "document", "member", "body", "string", "header", "menu"]}}
{"id1": "804637", "id2": "22552318", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readandrewrites", "readAndRewwrite", "readAndSwwrite", "readAndrewrites", "readAndRebrite", "readAndRebrap", "readAndRebrites", "readandrewrap", "readandRewwrite", "readAndSwrites", "readandRewrites", "readAndRewrap", "readAndrewrap", "readAndrewwrite", "readAndrewrite", "readAndRebwrite", "readAndSwrite", "readandrewrite", "readandRewrap", "readandrewwrite", "readAndSwrap", "readAndRewrites", "readandRewrite"], "inFile": ["Infile", " inFilename", "loginFiles", "inSourceFile", "loginFile", "loginFilename", "oldFiles", "loginfile", "outFilename", "outFiles", "inFilename", "oldFile", "outfile", "outSourceFile", "InSourceFile", " infile", " inFiles", "InFiles", "oldfile", "inputfile", "infile", "inputFiles", "inputFilename", "inputFile", "oldFilename", "InFile", "inFiles", " inSourceFile"], "outFile": ["processFILE", "newFile", "newDir", "OutDir", "outStream", "outputFILE", "processPlace", "outputFile", "processFile", "outputFilename", "offPlace", "Outfile", " outDir", " outfile", "offFilename", "newfile", "thisfile", "outFILE", " outStream", "outfile", "processFilename", "exFile", "thisFILE", "outPlace", "thisFilename", "newStream", "offFILE", "OutFile", "outDir", "offFile", "outputPlace", "exfile", "exFilename", "thisFile", "exFILE", "outputfile", "OutStream", "outFilename"], "iis": [" iris", " iIs", "Iis", "iiis", "ciIs", "iiIS", "iniIs", "iIs", "iiIs", "iniIS", "ciris", "ciais", " iIS", "iiiss", "ciis", "iniris", "iris", "iniiss", " iiss", "Iais", "iIS", "iiss", "iniis", " iais", "Iiss", "iais", "ciiss", "ciIS", "iiris", "IIS"], "dcmParser": ["dpmPlugin", "dCMparser", "dmPlugin", "dmoduleParser", " dcmparser", "dpmarser", " dpmarser", "fcmParser", "dmmParser", " dcmPar", "dcmPar", "dpmparser", "dmcarser", "dpmJar", "dCMHandler", " dcmReader", "dmodulePlugin", "dkmHelper", " dpmPolicy", "DcmParser", "DcmJar", "dmoduleReader", "dbmParser", "dpmPar", "fpmParser", " dpmHelper", " dcmLanguage", "dcmLoader", "dkmParser", "fcmHandler", "dbmPolicy", "dcmarser", "dhemInstallation", "dhemReader", " dpmLanguage", "DcmReader", "DcmInstallation", "dcrPlugin", "dmmLoader", "dcmPlugin", "dpmInstallation", "dcrReader", " dcmJar", "fpmHandler", " dcrPlugin", "dcrJar", "dpmReader", "dbmPlugin", " dpmParser", "dmcPar", "dmcJar", " dcmHelper", "dcrParser", "dmLoader", "dcmparser", "dmissionReader", "dpmLoader", "dhemParser", "dmmparser", "dmissionLanguage", "fcmReader", "dcrLoader", " dpmJar", "dCMLoader", " dpmReader", " dpmPar", "dmoduleJar", "dmissionPlugin", " dcrReader", " dcmarser", "dCMReader", "dpmLanguage", "fpmparser", "dcmInstallation", "dmmPlugin", "dcmLanguage", "dpmHelper", "dcrPar", " dpmparser", "dkmPolicy", " dpmPlugin", "dkmPlugin", "dmissionParser", "fpmReader", "dCMParser", " dcrParser", "dmoduleparser", "dmReader", "dbmHelper", "dhemJar", " dpmLoader", "dCMPlugin", "dmParser", "dcmHelper", "dcmReader", "dcmPolicy", "dpmHandler", "dcrarser", " dcmPlugin", " dcmLoader", "dmcParser", "dcmHandler", " dcrLoader", "dpmParser", "dcmJar", "fcmparser", " dcmPolicy", "dpmPolicy"], "ds": ["vals", "db", "os", "ils", "details", "points", "tx", "sync", "qs", "src", "is", "Db", "bs", "s", "dd", "cs", "asi", "rs", "xs", "ls", "ns", "nas", "pd", "ros", "dds", "conn", "DS", "ks", "dr", "iss", "ads", "dc", "tes", "services", "ants", "ras", "dt", "df", "cdn", "gd", "ts", "icks", "ays", "des", "data", "session", "eps", "drivers", "ins", "ys", "di", "vs", "utils", "amps", "ss", "d", "js", "ps", "gs", "ld", "parts", "sys", "da", "Os", "ws", "dat", "uds", "Ds"], "pdReader": ["dsLoader", "ddReader", "hdRead", "dsWriter", "pdRead", "pdreader", "pdStream", "pbReader", "hdLoader", "ddRunner", "pcReader", "hdReader", "dsreader", "xdWriter", "pbLoader", "pcLoader", "xdReader", "xdRead", "pbStream", "pdLoader", "pbRunner", "ddLoader", "hdRunner", "pcWriter", "xdreader", "pdRunner", "ddStream", "dsRead", "hdStream", "pcRead", "hdWriter", "dsReader", "hdreader"], "out": ["Out", "image", "sync", "flow", "key", "s", "parent", "ex", "conn", "to", "word", "at", "director", "store", "base", "builder", "oder", "w", "name", "outs", "OUT", "db", "client", "full", "user", "page", "cache", "diff", "array", "inner", "io", "file", "part", "down", "dot", "err", "over", "net", "again", "as", "lock", "external", "inc", "auto", "in", "writer", "output", "order", "object", "copy", "cli", "child", "result", "ext", "ssl", "line", "manager", "url", "lib", "o", "null", "pass", "doc", "password", "point", "outer", "dev", "layer", "up", "device", "term", "obj", "default", "write", "group", "code", "connection", "exp", "later", "img", "exec", "login", "session", "data", "temp", "model", "with", "her", "co", "list", " in", "sys", "gen"], "dcmEncParam": ["dcmDecParameter", "dcmArchParameter", "dcmArchArg", "dcmEncPar", "dcmSecParam", "dcmArchParam", "dcmElPar", "dcmSecPar", "dcmEnPart", "dcmElParameter", "dcmEncType", "dcmEncParameter", "dcmEstParam", "dcmEncArg", "dcmDecPar", "dcmEstParameter", "dcmEnArg", "dcmEstType", "dcmElParam", "dcmElType", "dcmDecPart", "dcmDecParam", "dcmSecType", "dcmEnType", "dcmEstPar", "dcmSecPart", "dcmEnPar", "dcmDecArg", "dcmDecType", "dcmEncPart", "dcmEnParameter", "dcmEnParam"], "pdWriter": ["ddWrite", "ddReader", "ddOutput", "dpWrite", "dsWriter", "PDWriting", "pdOutput", "hdWrite", "PDWrite", "dpReader", "dpWriting", "dsWrite", "hdReader", "PDReader", "htReader", "dsOutput", "PDWriter", "pdWrite", "pdWriting", "htWriting", "ddWriter", "htWrite", "htWriter", "hdWriter", "dsReader", "dpWriter", "hdOutput"]}}
{"id1": "13122204", "id2": "21063400", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unpackProject", "unpackFile", "Unzipmodel", "unzipFile", "unpatchProject", "UnzipModel", "unpackmodel", "unpatchmodel", "UnarchiveProject", "unpackModel", "UnzipFile", "unzipmodel", "unzipProject", "UnarchiveFile", "unpatchModel", "Unarchivemodel", "unpatchFile", "unarchivemodel", "unarchiveFile", "unarchiveProject", "unarchiveModel", "UnarchiveModel", "UnzipProject"], "filename": ["username", "fits", "loc", "f", "name", "File", "database", "download", "fil", "SourceFile", "nil", "model", "kl", "Filename", "files", "txt", "jet", "l", "fn", "source", "path", "url", "uri", "file", "folder", "title", "module", "src", "fd", "utf", "FILE", "bf", "fp", "directory", "location", "string", "il"], "tempdir": ["temdir", "Tempfolder", "tmpdirectory", "tempDIR", "Tempdirectory", " tempDIR", "tempfolder", "temdirectory", " tempDir", "temfolder", "tempDir", " tempfolder", "tempdirectory", "tmpfolder", "tempath", "TempDir", " tempdirectory", "tmppath", " temppath", "temDir", "TempDIR", "temppath", "Tempdir", "tmpDIR", "tmpDir", "tmpdir"], "dest": ["prop", "nt", "cdn", "loc", "opt", "sup", "later", "session", "handler", "st", "cont", "sync", "comb", "gen", "proc", "log", "di", "die", "walker", "output", "inner", "txt", "done", "zip", "trans", "export", "dist", "temp", "std", "dc", "test", "source", "builder", " Dest", "delete", "ui", "exit", "walk", "transfer", "store", "default", "flat", "file", "wb", "transform", "folder", "src", "Dest", "result", "target", "dir", "dat", "usr", "home", "de", "desc", "obj", "tar", "tmp", "rest"], "fis": ["fid", "fiss", "fisa", " fid", "flisa", "fsisa", "filebis", "flis", "flbis", "fsbis", "filei", "fileisa", "fileiss", "fi", "fileis", " fi", "fliss", "fbis", "lid", "li", " fiss", "fsis", "fsiss", "liss", "lis", "fileid"], "BUFFER": ["MAFIX", "BOFFER", "BOFER", "UPVER", " BUVER", "BOPER", "BUFF", "BOFIX", " BUFF", "TAFFER", " BUFIX", "CUVER", "UPFF", " BUVEN", " BUUCK", "BUVER", "SAFFER", "CUUCK", "UPVEN", "BUVEN", "BUFIX", "BUPER", "UPFFER", " BUFER", "SAPER", "MAFFER", "TAPER", "TAVER", "CUFFER", "BUFER", "SAVER", "CUVEN", "CUFF", "MAPER", "CUPER", "BUUCK", " BUPER", "SAUCK", "MAFER", "TAUCK"], "zis": ["ji", "zins", " zbis", "zisa", "yis", "Zis", " zi", " zii", "Zas", "xis", "zii", " zin", "zas", "ziss", "zin", "zipis", "yisa", " ziss", "yIS", "zipin", "xists", "Zisa", " zIS", " zins", "xos", "xii", " zas", "zipIS", " zos", "zipisa", "dis", "jis", "zipins", "jists", "dbis", "xi", "dii", " zisa", "zIS", "zi", " zists", "xiss", "diss", "zists", "Zins", "zipas", "yin", "zbis", "xbis", "zos", "jos"], "entry": ["nt", "reader", "connection", "si", "name", "archive", "ries", "ident", "info", "ge", "se", "ie", "rc", "match", "lc", "Entry", "part", "inner", "je", "her", "zip", "ace", "line", "e", "la", "row", "cat", "pack", "image", "feed", "inc", "or", "source", "spec", "next", "enter", "iterator", "li", "server", "pe", "jo", "file", "ce", "way", "module", "valid", "id", "porter", "ry", "result", "cel", "record", "ou", "ent", "de", "end", "element"], "count": ["iter", "f", "name", "_", "current", "allow", "type", "low", "counter", "ind", "base", "log", "add", "part", "b", "size", "time", "weight", "cache", "line", "val", "max", "e", "writer", "key", "buffer", "list", "Count", "cond", "i", "limit", "feed", "use", "next", "sum", "number", "code", "read", "core", "c", "in", "file", "id", "index", "pos", "len", "last", "coll", "length", "write", "start", "end"], "data": ["reader", "name", "batch", "body", "array", "info", "load", "str", "zero", "base", "format", "shift", "size", "bytes", "content", "la", "d", "buffer", "block", "image", "pack", "feed", "media", "value", "next", "number", "raw", "read", "DATA", "pos", "index", "len", "message", "a", "id", "result", "dat", "input", "record", "length", "alpha", "write", "start"], "fos": ["xoes", "afis", " foes", "bOS", "afops", "xoos", "bos", " foos", "fOS", " fOS", "xops", "afos", "foes", "dfops", "fops", "xos", "afOS", "bis", "dfos", "bops", "dfoos", "foos", " fops", "dfoes"]}}
{"id1": "14303294", "id2": "16556717", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getserverHash", "getSecureHash", " getServerSalt", "getSessionSHA", "getSessionAddress", "getSecureAddress", "getSecureSalt", " getServerSHA", "getserverSalt", "getSessionHash", " getSecureSHA", "getServerAddress", "getserverSHA", " getSecureAddress", "getServerSalt", "getserverAddress", "getSecureSHA", " getSecureSalt", "getServerSHA", " getSecureHash", " getServerAddress", "getSessionSalt"], "passwordHash": ["Passwordhash", "PasswordCode", "passwordSalt", "privatehash", " PasswordCode", " passwordPassword", "privateSalt", " passwordCode", "privateHash", "passwordPass", " passwordhash", " PasswordHash", "PasswordPass", "privatePassword", " passwordSalt", "PasswordPassword", "passwordhash", "passwordCode", " PasswordPass", "PasswordHash", " passwordPass", "passwordPassword"], "PasswordSalt": ["PASS256", " passwordSecret", "passwordSalt", "PasswordSecret", " Password256", " PasswordSecret", " PasswordPassword", " passwordPassword", "password256", "PASSSalt", "PASSPassword", "passwordSecret", " PasswordHash", " passwordSalt", "PasswordPassword", "PASSHash", "PasswordHash", "Password256", "passwordPassword"], "hash": ["address", "url", "result", "base", "sha", "error", "dig", "ash", "cache", "change", "check", "Hash", "log", "row", "string", "kh", "image", "hex", "build", "auth", "code", "crypt", "html", "user", "number", "block", "update", "message", "array", "buffer", "her", "key", "content", "h", "copy", "search", "mac", "sh", "data", "pool", "work", "password", "value", "sum", "size", "ha", "response"], "digest": [" digested", "hashest", "integall", "hashener", " digusher", "signest", " digher", "Digger", "digall", "mdest", "signger", "signher", " digester", "digester", " digall", "digusher", "integested", "digher", "generall", "integester", "Digusher", "hasher", "Digher", "digested", "mdested", "Diger", "Digester", "integest", "hashester", "signester", "diger", "Digest", " diger", "mdusher", "digger", "signer", "Digested", "Digener", "generester", " digener", " digger", "generested", "generest", "digener", "mdester"]}}
{"id1": "4593012", "id2": "21930714", "code1": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "code2": "    @Test\n    public void testSpeedyShareUpload() throws Exception {\n        request.setUrl(\"http://www.speedyshare.com/upload.php\");\n        request.setFile(\"fileup0\", file);\n        HttpResponse response = httpClient.execute(request);\n        assertTrue(response.is2xxSuccess());\n        assertTrue(response.getResponseHeaders().size() > 0);\n        String body = IOUtils.toString(response.getResponseBody());\n        assertTrue(body.contains(\"Download link\"));\n        assertTrue(body.contains(\"Delete password\"));\n        response.close();\n    }\n", "label": 0, "substitutes": {"upgradeSchema": ["upgradeSchement", "upgradeCatalogment", "upgradeCatalogMeta", "upgradingschement", "upgradingschemas", "upgradeDatabaseMeta", "upgradeschement", "upgradingSchema", "upgradeCatalogmas", "upgradeSchemas", "upgradingSchemas", "upgradeScheMeta", "upgradeschemas", "upgradescheMeta", "upgradeDatabasema", "upgradeDatabasemas", "upgradeCatalogma", "upgradeschema", "upgradingSchement", "upgradingschema", "upgradingscheMeta", "upgradeDatabasement", "upgradingScheMeta"], "stmt": ["strmr", "stvt", "estmp", "estm", "pmt", "estmt", "strnt", "STvt", "estmsg", "hnt", "sttm", "stql", " stmp", " stmsg", "Stnt", "rql", "ftmp", "STmt", "STtm", " stql", "Stdb", "stmr", "rmt", "pvt", "hmit", " stmit", "ftmit", "rmr", "hmp", " sttm", "stdb", "Stmt", "rmp", "frm", "stmsg", "frmsg", " stm", "Stmr", "ftnt", "strmt", "hmt", "frmp", "stm", " stnt", " stmr", "STm", "ptm", "ftmt", "stmp", " stvt", "stnt", "frmt", "stmit", "strql", "strmp", "pm", " stdb", "strdb"], "i": ["p", "x", "hei", "uri", "c", "ni", "ai", "f", "gi", "ii", "info", "ix", "isu", "e", "ie", "vi", "I", "k", "count", "ci", "yi", "abi", "ini", "in", "ami", "multi", "ip", "iu", "bi", "n", "si", "name", "u", "b", "it", "ui", "pi", "oi", "isi", "li", "index", "j", "api", "ki", "mi", "di", "qi", "eni", "xi", "start", "fi", "cli", "t", "slice", "r", "id", "o", "zi", "adi", "v", "esi", "ri", "ti", "hi", "phi"], "qry": ["qrc", " qcr", "quri", "qrys", "qri", "qurc", " qRY", " qrc", "querRY", "Qry", "QRY", "qucr", "qries", "qurys", "Qri", " qries", "querrc", "qury", "querry", "Qrys", "quries", " qrys", "quRY", "qcr", "Qries", "qRY", "Qcr", " qri", "querri"]}}
{"id1": "12349563", "id2": "22611968", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"resourceExists": [" fileexistence", " resourceexits", " resourceexists", " resourceAbses", " resourceExistence", " resourceAbsists", " fileexits", " resourceCompits", " fileExistence", " resourceCompes", " fileExists", " resourceCompistence", " resourceExits", " fileExits", " resourceCompists", " fileExes", " fileexists", " fileexes", " resourceExes", " resourceAbsits", " resourceAbsistence", " resourceexistence", " resourceexes"], "location": ["connection", "localhost", "region", "loc", "data", "name", "point", "layout", "type", "remote", "language", "reference", "operation", "layer", "info", "local", "base", "position", "description", "content", "href", "LOC", "shape", "collection", "address", "pointer", "source", "image", "provided", "path", "response", "filename", "object", "uri", "server", "route", "file", "folder", "message", "Location", "resource", "target", "host", "home", "length", "directory", "area", "string", "node"], "url": ["connection", "open", "sl", "f", "loc", "fl", "web", "base", "ll", "ssl", "blog", "page", "b", "user", "zip", "l", "r", "address", "Url", "i", "URL", "lib", "build", "source", "image", "api", "path", "config", "server", "uri", "io", "http", "c", "file", "impl", "resource", "www", "host", "string", "obj"], "cxn": ["cxxp", "Cuxn", "cxxn", "cuxns", "cdsn", "Cuxns", "crexp", "Cxp", "Cxns", "cexns", " crexn", " crexg", " crexp", "cxns", "Cxn", "crexg", "cuxp", "cexg", "cexcon", "cexp", "cdscon", "cdsp", "crexn", " cxcon", "Cuxp", "cxxne", "cxg", "cuxn", " cxg", "cxxns", " crexcon", "Cxne", " cxp", "cuxne", "cxcon", "cxne", "cexne", "cxp", "crexcon", "cexn", "cdsg", "Cuxne"], "is": ["x", "app", "ens", "ais", "Is", "iss", "get", "isl", "it", "cos", "does", "s", "oss", "bs", "stream", "ori", "info", "has", "web", "cms", "os", "im", "isa", "IS", "isc", "abs", "was", "internet", "ar", "its", "i", "init", "api", "or", "js", "nis", "next", "close", "ui", "bis", "ois", "ir", "uri", "ris", "http", "in", "as", "iso", "id", "iris", "src", "es", "ai", "out", "us", "ios", "ms", "lis", "ip", "fs", "ob", "isi"], "byteBuffer": ["byteBuff", "ByteArray", "ByteBuffer", "ByteBB", " byteBuff", "bitBB", "bitBuffer", "ByteBuff", "bitBuff", "byteArray", " byteLength", "ByteLength", "byteLength", "bitArray", " byteArray", "bitLength", " byteBB", "byteBB"]}}
{"id1": "9257487", "id2": "21488518", "code1": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "code2": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": ["copyFile", "copyResource", " downloadFiles", "DownloadFile", "Downloadfile", "copyFiles", "copyfile", " downloadfile", " downloadResource", "DownloadFiles", "DownloadResource", "downloadResource", "downloadFiles", "downloadfile"], "from": ["From", "html", "src", "form", "host", "user", "route", "address", "module", "or", "connection", "code", "a", "path", "resource", "at", "file", "part", "link", "f", "prefix", "base", "data", "with", "range", "name", "by", "remote", "project", "as", "folder", "uri", "about", "source"], "to": ["os", "too", "flo", "output", "socket", "route", "office", "po", "To", "address", "target", "or", "location", "TO", "path", "resource", "io", "file", "storage", "prot", "prefix", "o", "eto", "until", "base", "temp", "with", "download", "range", "token", "so", "name", "remote", "as", "addr", "uri", "about", "source", "repl"], "pm": ["mm", "m", "prem", "p", "pp", "prom", "dem", "pa", "cp", "wm", "gp", "po", "PM", "monitor", "meter", "fm", "vm", "um", "bm", "rm", "lp", "cm", "pool", "pb", "pi", "mr", "sm", "dm", "jp", "im", "wp", "mi", "em", "pc", "sem", "tm", "mp", "rpm", "pro", "gm", "px", "pl", "pt", "pr", "sp"], "out": ["Out", "timeout", "client", "writer", "self", "obj", "sync", "i", "output", "socket", "input", "write", "copy", "parent", "cli", "connection", "inner", "ext", "io", "line", "file", "o", "exec", "login", "err", "temp", "log", "w", "net", "bin", "In", "OUT", "as", "string", "again", "reader", "outs", "outer", "cmd", "source", "up", "inc"], "url": ["image", "client", "fr", "sl", "i", "socket", "el", "impl", "fl", "www", "server", "bel", "open", "loc", "connection", "http", "fb", "URL", "resource", "ssl", "con", "file", "f", "Url", "lib", "channel", "base", "zip", "download", "log", "b", "er", "org", "ll", "l", "web", "ur", "uri", "source", "c"], "conn": ["client", "connect", "Conn", "p", "sync", "ctx", "n", "g", "apt", "cp", "socket", "cn", "lc", "ci", "coll", "open", "ann", "connection", "nc", "dc", "http", "cur", "cm", "ssl", "con", "pub", "en", "f", "ch", "enc", "close", "exec", "conv", "b", "l", "mc", "cms", "Connection", "lock", "act", "cb", "c"], "in": ["r", "client", "n", "inn", "stream", "isin", "i", "is", "socket", "s", "init", "cin", "impl", "input", "din", "lin", "connection", "inner", "io", "nin", "ssl", "ini", "con", "file", "inside", "f", "exec", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "again", "lock", "win", "source", "c", "inc"], "buffer": ["position", "bytes", "size", "batch", "shape", "queue", "feed", "slice", "input", "reference", "write", "bb", "Buffer", "limit", "cache", "address", "source", "result", "padding", "message", "buff", "raw", "row", "uffer", "iter", "buf", "binary", "null", "base", "data", "b", "offset", "wave", "memory", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["get", "ind", "ask", "connect", "rate", "size", "ok", "sync", "Read", "block", "current", "old", "transfer", "use", "feed", "load", "input", "slice", "write", "parse", "reads", "check", "run", "open", "seek", "index", "READ", "io", "se", "sleep", "readable", "work", "send", "count", "reading", "fill", "find", "lex", "raw", "start", "iter", "x", "f", "close", "end", "pass", "exec", "k", "download", "b", "wait", "allow", "ride", "text", "number", "skip", "reader", "play", "loop", "add", " write", "create", "length", "select"]}}
{"id1": "4501356", "id2": "665420", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"calculateProfileDiffDigest": ["calculateProfilediffdigr", "calculateProfilediffdigHash", "calculateProfileDiffCodr", "calculateProfilediffdigests", "calculateProfileDiffdigHash", "calculateProfilediffdigest", "calculateProfileDiffdigests", "calculateProfileDiffDigests", "calculateProfileDiffdigr", "calculateProfilediffDigest", "calculateProfileDiffCodHash", "calculateProfileDiffDigr", "calculateProfileDiffMDHash", "calculateProfileDiffdigest", "calculateProfileDiffCodest", "calculateProfilediffDigHash", "calculateProfileDiffDigHash", "calculateProfileDiffMDr", "calculateProfileDiffCodests", "calculateProfileDiffMDests", "calculateProfilediffDigr", "calculateProfileDiffMDest", "calculateProfilediffDigests"], "profileDiff": ["familyInfo", "profDiff", "summaryInf", "messagediff", "summaryInfo", "profileEdit", "profileInfo", "profInfo", "familyEdit", "summaryEdit", "imageDie", "familyDiff", " profileDust", "profilediff", "styleInfo", " profilediff", " profileInfo", "messageDiff", "messageInfo", "settingsDelta", "pictureDiff", " profileDelta", "pictureInfo", " profileInf", " profileName", "imageDelta", "settingsDiff", "imageDiff", "profileDust", " profileDie", "messagePath", "settingsDie", "summaryDiff", " profileEdit", "familyInf", "profileDelta", "styleName", "profileInf", "settingsDust", "picturediff", "imageDust", "profilePath", "pictureName", "profPath", "styleDiff", "profdiff", "profileName", "stylediff", "profileDie", " profilePath"], "normaliseWhitespace": ["normaliseWitesSpace", "normaliseWhipspaces", "normaliseWhipsspace", "normaliseWhitespaced", "normaliseWhicksspace", "normaliseWhpacesspace", "normaliseWpacesspace", "normaliseWitesspace", "normaliseWhickspaces", "normaliseWhitesspace", "normaliseWhpacepace", "normaliseWhpacespaces", "normaliseWhpaceSpace", "normaliseWpacespaced", "normaliseWhickspaced", "normaliseWhickspace", "normaliseWhpacespace", "normaliseWhitesSpace", "normaliseWhipespace", "normaliseWhipespaced", "normaliseWitespaces", "normaliseWhpacepaces", "normaliseWhipspace", "normaliseWitespaced", "normaliseWpacesSpace", "normaliseWpacespace", "normaliseWpacespaces", "normaliseWhitespaces", "normaliseWhipesspace", "normaliseWhpacesSpace", "normaliseWhipsSpace", "normaliseWhipespaces", "normaliseWitespace", "normaliseWhpacespaced"], "md": ["msg", "meta", "df", "bd", "f", "mag", "mg", "cd", "rm", "sd", "wd", "ds", "mad", "dd", "m", "ma", " MD", "mt", "me", "dig", "b", "mb", "mac", "cmd", "dm", "d", "MD", "gd", "db", "hash", "amd", "mp", "metadata", "mm", "pm", "message", "sha", "bf", "diff", "mc", "pd", "mand", "hd", "od", "Cmd", "editor"]}}
{"id1": "14819747", "id2": "3514286", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"debug": ["db", "enabled", "error", " DEBUG", "progress", "details", "console", "display", "help", "develop", "trace", "print", "comment", "bug", "ger", "cache", "reg", "module", " debugger", "show", "development", "real", "date", "file", "root", "build", "store", "active", "depth", "production", "die", "doc", "err", "log", " Debug", "test", "tag", "status", "admin", "quiet", "export", "github", " debugging", "plugin", "remote", "enable", "DEBUG", "play", "dev", "dump", "Debug", "config"], "prologFile": ["PrologFile", "prologfile", " prologfile", "proLogfile", "propathDir", " proLogFile", "ProLogString", "propathSourceFile", "probaseFiles", "proversionPath", "proversionSourceFile", "roLogSource", "ProLogfile", " problogfile", "prologFull", " prologFiles", "rologfile", "defblogDir", "proconfigfile", "proconfigFile", "proversionFILE", " prologHeader", "procatfile", "defblogSourceFile", "prologString", "prollFile", "deflogPath", "proLogStream", "prologHeader", " problogSourceFile", "proLogString", "propathFile", "defLogSourceFile", "rologSource", "proflowFile", "rologFile", "proflowSourceFile", "problogSourceFile", " prologFull", "problogDir", "proconfigSourceFile", "prollPath", "proversionFile", "prolexFile", "prologDir", "deflogFile", "rologPath", "proLogFull", "prolexfile", "prologFiles", "ProLogFile", "proconfigPath", "probaseFile", "proLogFile", "deflogfile", "Prologfile", "PrologString", "prolangFile", "proflowDir", " prologStream", " prologSourceFile", "proLogPath", "proflowfile", "proLogFILE", "proLogFiles", "prolangFull", "prologSourceFile", " proLogFiles", "defLogFILE", "roLogPath", "prologSource", "prolangSourceFile", "defblogfile", "deflogDir", "propathfile", "probaseHeader", "ProLogModule", "proconfigFILE", "deflogFILE", "roLogFile", "prolexString", "defblogFile", "prolangfile", " problogFile", "probaseStream", "proLogSourceFile", "prologFILE", "prologStream", "proconfigModule", "PrologModule", "prologModule", "prollSource", "defLogPath", "deflogSourceFile", "roLogfile", "problogHeader", "problogFiles", "proLogModule", "problogFile", "prologPath", "procatFile", "prolexModule", "problogStream", " proLogHeader", "proLogHeader", "defLogFile", "proLogSource", "problogfile", "procatSource", "proconfigString", " proLogStream", "procatPath", "prollfile", " problogFull", "problogFull"], "targetFile": ["targetDir", "targetDirectory", "outputPath", "outputFile", "sourcefile", "outputDir", "targetPath", "targetfile", " targetfile", "sourceFile", "sourcePath", " targetDirectory", "sourceDirectory", "targetFiles", "TargetDirectory", "sourceDir", "Targetfile", "TargetDir", " targetFiles", "TargetPath", "outputfile", "TargetFiles", "TargetFile", "sourceFiles"], "source": ["position", "template", "buffer", "service", "term", "sl", "src", "i", "class", "view", "comment", "use", "scope", "input", "slice", "proxy", "parse", "id", "json", "stack", "target", "result", "format", "content", "message", "resource", "description", "file", "Source", "str", "options", "unit", "model", "session", "data", "type", "zip", "SOURCE", "text", "language", "name", "style", "body", "string", "uri", "ource", "config"], "myParser": [" myReader", "yourParser", "MyJar", " myJar", "MyParser", "yourJar", "yourProgram", "myJar", "MyProgram", "myReader", "yourReader", "MyReader"], "myProgram": ["yourMath", "yourPlan", "MYprogram", "MyParser", "MYParser", "yourProgram", "myMath", " myprogram", "yourprogram", "MyProgram", "theParser", " myPlan", "theMath", "MyPlan", "theProgram", "myPlan", "Myprogram", " myMath", "yourParser", "theprogram", "MYProgram", "myprogram"], "myVisitor": [" myvisIT", "myVisitors", "MyVisulator", "mySignitors", "myVisIT", " myvisitors", "myDesignIT", "myDesignit", "myvisit", "myExitors", "myVISitable", "myVisulator", "myExiter", " myVisitable", " myvisit", "myAuditable", "myVisitit", "myvisiter", "Myvisitors", "myAudit", "MyVisiter", "myvisitor", "myVisititor", "myvisitable", "mySignitor", "myVisiter", "MyVisitor", "myvisulator", "myVISitor", "myDesignitable", "myvisIT", "myVisititable", "mySignulator", "myAuditor", "MyVisitors", " myvisitable", "myDesignitor", " myVisitors", "Myvisiter", " myVisIT", "myAuditors", "myExitor", "Myvisitor", "mySigniter", "myExulator", "Myvisulator", "myVisititors", "myVISit", " myvisitor", "myVisitable", "myVisit", "myvisitors", " myVisit", "myVISIT"], "adapterLayer": ["adviceFactory", "acaptersFactory", "acapterFactory", "acapterContainer", "adapterFactory", "acapterLayer", "acapterBuffer", "acaptersBuffer", "adptionInfo", "adaptersContainer", "adviceLanguage", "adviceInfo", "admissionContainer", "admissionLanguage", "adptionBuffer", "adviceLayer", "acapterInfo", "adviceBuffer", "adapterInfo", "admissionLayer", "adaptersLanguage", "adviceContainer", "adapterBuffer", "acaptersInfo", "acaptersLanguage", "adapterLanguage", "adaptersFactory", "acaptersLayer", "adaptersLayer", "adapterContainer", "acapterLanguage", "adaptersInfo", "adaptersBuffer", "acaptersContainer", "adptionFactory", "adptionLayer"], "classLoader": ["classPath", "ClassPath", "staticDir", "ClassDir", "classDir", "staticLoader", "classloader", " classDir", "ClassLoader", "staticPath", "staticloader", " classPath", " classloader", "Classloader"], "adapterWriter": ["adAdapterReader", "adapterReader", "attapterWriter", "adAdapterwriter", "adaptersReader", "adapterWrite", "attapterwriter", "adapterwriter", "adapterswriter", "adaptersWriter", "adaptersWrite", "admissionWrite", "attaptersReader", "attaptersWriter", "attapterswriter", "adAdapterWriter", "admissionReader", "attapterReader", "attaptersWrite", "adAdapterWrite", "admissionWriter", "admissionwriter", "attapterWrite"], "annotationGenerator": ["annotationgenators", "annnotationGenoder", "annotationGeneroder", "annotationGcer", "annotationGenerators", "annotationgenator", "annotationGator", "annotationgenoder", "annotationGenoder", "annnotationGenerators", "annotationGenator", "annnotationGenerator", "annnotationGenator", "annnotationGeneroder", "annotationGoder", "annnotationGenercer", "annotationGenercer", "annotationGencer", "annnotationGencer", "annotationgencer", "annnotationGenators", "annotationGenators", "annotationGators"], "out": ["Out", "error", "in", "sync", "obj", "query", "n", "flow", "output", "pre", "print", "chain", "user", "parent", "copy", "cli", "page", "server", "cache", "conn", "group", "diff", "state", "code", "array", "io", "line", "raw", "post", "down", "store", "prefix", "temp", "err", "log", "bar", "v", "net", "OUT", "again", "list", "point", "sys", "outer", "outs", "lock", "gen", "cmd", "dump", "up"]}}
{"id1": "300397", "id2": "1188100", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "339517", "id2": "19096138", "code1": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getClassFile": ["getSourceCode", "getCodeFile", "createCodeFile", "createClassFile", "getClassFiles", "createCodeCode", "createCodeFiles", "getSourceLoader", "createClassLoader", "createClassCode", "createCodeLoader", "getCacheFiles", "getSourceFile", "getCodeCode", "getClassLoader", "getCacheCode", "getCodeFiles", "getCacheLoader", "createClassFiles", "getSourceFiles", "getCacheFile", "getClassCode", "getCodeLoader"], "name": ["ame", "NAME", "prefix", "uri", "default", "resource", "parent", "n", "connection", "info", "data", "this", "part", "definition", "str", "named", "key", "type", "pass", "i", "class", "source", "Name", "config", "size", "filename", "base", "object", "id", "address", "names", "string", "file", "loader", "path", "request"], "url": ["ls", "page", "uri", "ssl", "resource", "ll", "server", "image", "b", "connection", "io", "this", "f", "rule", "URL", "el", "instance", "i", "class", "source", "reader", "config", "rl", "l", "base", "resources", "user", "r", "found", "id", "string", "file", "loader", "service", "sl", "host", "Url", "http", "feed", "open"], "in": ["ex", "ins", "ssl", "resource", "image", "In", "b", "ax", "n", "init", "data", "inc", "socket", "f", "gin", "input", "din", "IN", "lin", "inas", "inn", "read", "out", "s", "i", "is", "win", "source", "reader", "rin", "inside", "nin", "stream", "login", "inner", "r", "id", "token", "ac", "bin", "con", "err", "ini", "as", "again", "isin"]}}
{"id1": "838844", "id2": "19206412", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["oconverted", "subversion", "unverted", "unversion", "converted", "CONverted", " deconverted", "subverted", "Convert", "CONception", "unception", "subvert", " deconversion", "Conversion", "CONvert", "oconverting", "Converting", "Converted", "Conception", "CONverting", "conception", "conversion", "oconvert", "subverting", "converting", " deconverting", "unvert", "oconversion", " deconvert", "CONversion"], "src": ["attr", "source", "ref", "filename", "video", "sb", "fp", "uri", "secure", "st", "path", "username", "feat", "load", "download", "config", "s", "back", "buf", "component", "gz", "input", "ource", "inst", "sin", "loc", "RC", "req", "Source", "sys", "prot", "resource", "img", "storage", "sth", "url", "tmp", "name", "stage", "proc", "spec", "code", "obj", "sel", "sc", "rl", "sit", "supp", "scene", "SourceFile", "rc", "upload", "string", "fn", "rb", "gb", "dist", "stream", "cpp", "impl", "sn", "file", "Dest", "ssl", "slice", "href", "reader", "ctx", "cb", "cmp"], "dest": ["disk", "source", "path", " destination", "home", "txt", "img", "class", "tmp", "null", "cont", "obj", "dist", "dat", "fn", "di", "orig", "test", "std", "temp", "lib", "Dest", "dir", "bin", " dst", "target", "dc"], "in": ["source", "as", "ps", "inn", "pin", "f", "pass", "ex", "i", "input", "inas", "val", "IN", "data", "ini", "win", "n", "up", "isin", "a", "io", "inf", "din", "is", "ins", "stream", "In", "inc", "file", "r", "t", "err", "login", "reader", "bin", "d", "doc"], "p": ["lp", "pre", "tp", "ps", "fp", "py", "c", "f", "np", "s", "wp", "per", "i", "e", "pb", "po", "l", "bp", "m", "pg", "cop", "pa", "g", "v", "pc", "b", "pe", "pd", "pi", "sp", "j", "h", "cp", "pr", "jp", "parser", "part", "t", "pp", "op", "r", "o", "pm", "d", "P"], "ds": ["ts", "ups", "s", "DS", "hs", "ans", "ipes", "ded", "dds", "ins", "xs", "ns", "d", "ays", "dos", "ps", "words", "sync", "styles", "ys", "groups", "data", "da", "des", "rs", "ths", " ps", "os", "utils", "pd", "icks", "dist", "els", "models", "points", "sts", "scripts", "plugins", "js", "db", "cons", "posts", "ls", "parts", "tools", "cs", "ss", "lines", "dm", "vals", "sys", "ges", "ks", "qs", "docs", "ants", "bs", "nas", "amps", "Ds", "di", "dd", " props", "gs", "ads", "ils", " sd", "lp", "uds", "tests", "eps", "services", "dates", "dl", "vs", "dt", "dat", "gd", "ld", " DS", "dp", "df", "obs", "dc"], "format": ["source", "nat", "form", "style", "filename", "fp", "table", "path", "language", "feat", "frame", "config", "f", "at", "model", "data", "magic", "record", "act", "class", "url", "name", "spec", "Format", "host", "fd", "function", "letter", "api", "tag", "string", "struct", "sche", "fn", "prefix", "handler", "plugin", "scale", "filter", "parser", "file", "version", "part", "t", "template", "atter", "layout", "unit", "type", "ant", "pattern"], "hasPixelData": ["hasPixelSize", "haspixeldata", "hasByteData", "haspixelData", "hasByteStyle", "showsByteDATA", "hasPictureSize", "hasPixelStyle", "hasPixelDATA", "haspixelSize", "showsPixelDATA", "hasPictureData", "showsPixelData", "hasBytedata", "showsPixeldata", " hasPixelSize", "showsPixelStyle", "hasPixeldata", "hasByteSize", "hasByteDATA", "showsByteStyle", "showsBytedata", "hasPicturedata", " hasPixeldata", "showsByteData"], "inflate": ["infloated", "infolode", "insvenode", "insflode", "infface", "inFlation", "insvenATE", "insvenating", "invenating", "inadequode", "inadequATE", "insflATE", "Inflation", "infloation", "invenATE", "insflate", "infolate", "inflode", "inflATE", "invenate", "invenode", "inflace", "Inflate", "inFlace", "inadequating", "inadequate", "inFlate", "InFlate", "infolATE", "infolating", "InFlace", "inffated", "insflating", "inFlated", "infloace", "infloate", "inflated", "inflation", "InFlated", "inffate", "inflating", "inffation", "insvenate", "InFlation", "Inflated", "Inflace"], "pxlen": ["pcln", "xplength", "pglen", "txln", "pnglen", "fxpos", "fxlen", "mxpos", "xpcount", "pxlength", "mxdata", "pxln", "pxpos", "ppl", "campos", "mxlen", "txlen", "fxdata", "pxcount", "mxlength", "axlon", "pclin", "pgLen", "txlin", "xplen", "axlen", "axlin", "pxlin", "mxsize", "pxdata", "pxlon", "pclen", "axln", "pgden", "mxln", "pxsize", "pngsize", "camdata", "txlon", "pnglength", "pngcount", "camlen", "ppLen", "fxLen", "xpsize", "mxcount", "fxln", "camln", "fxl", "pxLen", "pplen", "pgl", "pclon", "pxl", "ppden", "pxden", "fxden"], "out": ["work", "group", "copy", "cache", "output", "re", "session", "point", "pad", "store", "page", "state", "dump", "OUT", "conn", "line", "sys", "io", "up", "v", "log", "server", "gen", "obj", "post", "query", "list", "lock", "Out", "outs", "again", "lib", "step", "cli", "err", "inter", "user", "parent", "error", "co"]}}
{"id1": "9275622", "id2": "5061606", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["moveFolder", "copyFiles", " copyfile", "copyFolder", "transferFile", "transferFolder", "moveFiles", "transferfile", " copyFiles", " copyFolder", "transferFiles", "movefile", "copyfile", "moveFile"], "_file1": ["_files1", "_files01", "_File2", "_fileone", "_resourceOne", "_mail2", "_file0", "_resource1", "_fFirst", "_resourceone", "_zip1", "_zipFirst", "_fileOne", "_zipOne", "_file01", "_fone", "_fOne", "_File0", "_f1", "_mail1", "_File01", "_mail0", "_File1", "_mail01", "_zipone", "_files2", "_files0", "_resourceFirst", "_fileFirst"], "_file2": ["_files4", "_filesecond", "_Filesecond", "_File5", "_File2", "jfile1", "_file4", " _filesTwo", " _files3", "jmodelsecond", "_model1", "_model5", "_file5", "_modelsecond", "_files3", "_file3", "jfile5", "_play2", "jfilesecond", " _file3", "_playTwo", "jmodel1", "jmodel5", "_play1", "_model2", "_playsecond", "_filesTwo", "_fileTwo", "_File1", "_play5", " _files4", "_files2", "_play4", " _file4", " _fileTwo", "jfile2", "_play3", "jmodel2", " _files2"], "fis": ["fiss", "infiss", "lfais", "lfi", "afis", "cfos", " fris", "afais", "cfiss", "lfis", "cfas", "Fils", " fais", "infils", "afiss", "fi", "Fas", "Fis", " fi", "fils", "infos", "Fiss", "fas", " fiss", "afi", " fils", "lfiss", "Fos", "fris", "Fris", "fais", "cfis", "cfris", "infis", " fas"], "fos": ["infaos", "Fo", "fus", "infus", "Foos", "Foses", "foses", "infios", "feos", "floes", "goses", "Fus", "info", " foos", "fOS", "flis", "infros", "gis", "Faos", "Fros", " fus", "gos", "feoses", "foes", "pis", "Fios", "Fis", "infoos", "infos", "fros", "poes", " faos", "pOS", "feus", "fios", "Fos", "pos", "feis", "foos", " fo", "flOS", " fios", "los", "lis", "faos", "lOS", "flos", "fo", " fros", "loes", "gus"], "canalFuente": ["canalBuence", "canalCraencia", "canaledBuje", "canaledBuze", "canalKuze", "canallBuente", "canallFuente", "canalBuento", "canalFuze", "canalsBuence", "canaledBuente", "canalSuente", "canalFuento", "canallBuence", "canalsFuente", "canalBuente", "canalBuje", "canalSuje", "canalFUje", "canaledFuente", "canalSuestro", "canaledFuestro", "canallFuze", "canalsFuence", "canalsBuento", "canalFUestro", "canalFuencia", "canalKuence", "canalsFuencia", "canalFUente", "canalBuencia", "canaledBuestro", "canaledFuje", "canalKuento", "canalsFuento", "canalFuje", "canallBuze", "canallFuence", "canalsBuencia", "canaledFuze", "canalBuestro", "canallFuencia", "canalKuente", "canalKuencia", "canalFuence", "canalFUencia", "canalSuze", "canalCraence", "canalsBuente", "canalFUze", "canalCraente", "canalCraento", "canalFUence", "canalBuze", "canallBuencia", "canalFuestro"]}}
{"id1": "7891509", "id2": "7927042", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    private void loadDynamically(File result, String extraPath) {\n        URL url = null;\n        InputStream is = null;\n        FileOutputStream fos = null;\n        try {\n            url = new URL(homeServerUrl + extraPath);\n            is = url.openStream();\n            fos = new FileOutputStream(result);\n            byte[] buff = new byte[8192];\n            int nbRead;\n            while ((nbRead = is.read(buff)) > 0) fos.write(buff, 0, nbRead);\n        } catch (IOException e) {\n            throw new StellariumException(\"Cannot dynamically load \" + result + \" from \" + url);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"pageAddress": ["urlAddress", "PageAddress", "pageUrl", "PageName", " pageLocation", "urlLocation", "Pageaddress", "siteAddress", "urladdress", "siteUrl", "resourceaddress", "resourceAddress", "resourceUrl", "pageaddress", "pageLocation", " pageUrl", " pageName", "urlUrl", "siteName", "pageName", "PageUrl", "siteLocation", "PageLocation", "resourceLocation"], "url": ["resource", "string", "channel", "host", "http", "service", "URL", "feed", "open", "this", "Url", "client", "object", "user", "address", "browser", "l", "connection", "base", "out", "ls", "element", "server", "loader", "sl", "f", "i", "image", "socket", "page", "ssl", "bb", "reader", "data", "r", "b", "plugin", "web", "uri", "stream", "source", "file"], "in": ["resource", "In", "token", "line", "again", "ini", "c", "IN", "rec", "din", "inner", "bin", "input", "as", "ins", "client", "impl", "min", "conn", "inn", "into", "err", "kin", "l", "isin", "init", "s", "win", "out", "gin", "read", "f", "inside", "i", "nin", "socket", "login", "ssl", "reader", "data", "r", "b", "inc", "id", "buffer", "stream", "source", "file"], "inputLine": ["InputLine", "selectFile", "rawLine", "imageCell", "pageline", "pageUrl", "InputCell", "pageString", "inputFile", "inputContent", " inputL", " inputPage", " inputline", " inputContent", " inputFile", "pageLine", "inputString", "selectPage", "rawFile", " inputString", "inputUrl", "inputL", " inputUrl", "rawString", "selectLine", "imageFile", "imageLine", "imageL", "inputline", "InputFile", " inputCell", "inputPage", "rawPage", "rawUrl", "rawContent", "rawline", "InputL", "selectContent", "inputCell"]}}
{"id1": "9872346", "id2": "20011285", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["readExternaldocument", "loadLocaldocument", "readLocalDocuments", "readExternalDocument", "readRemoteDocuments", "readExternalDocuments", "loadLocalDocuments", "readLocalDocument", "loadRemotedocument", "readLocaldocument", "loadRemoteDocuments", "loadRemoteDocument", "loadLocalDocument", "readServerDocuments", "readServerDocument", "readRemotedocument", "readServerdocument"], "url": ["source", "org", "remote", "position", "filename", "uri", "client", " URL", "path", "username", "Url", "load", "download", "config", "f", "store", "page", "link", "l", "socket", "image", "loc", "service", "location", "email", "resource", "www", "base", "name", "lc", "server", "host", "URL", "rl", "address", "sl", "string", "channel", "ur", "layer", "ll", "file", "version", "ssl", "feed", "entry", "user", "xml", "http"], "validate": ["verated", "Valating", "Valate", "validating", " validated", "Valation", "verate", "validated", " validation", "verating", " validating", "Valated", "validation", "veration"], "document": ["text", "source", "message", "result", "video", "media", "expression", "output", "port", "dict", "language", "session", "degree", "f", "system", "model", "page", "view", "word", "project", "ocument", "image", "material", "design", "data", "record", "object", "resource", "metadata", "location", "node", "service", "valid", "database", "graph", "null", "Document", "function", "index", "container", "office", "value", "collection", "request", "df", "response", " documentation", "parent", "xml", "doc", "content", "application"], "factory": ["infuture", "hiller", "affactory", "diller", "fsactory", "fade", " fFactory", "pixture", "fsFactory", "duture", "sfluent", "pluent", "dade", "biller", "fFactory", "sfactory", "bluent", "efixture", "Factory", "Folver", "sfixture", "efactory", "fsiller", "pault", "efiller", "fault", "pactory", "bactory", "fluent", "filler", "hactory", "folver", "affixture", "dactory", "infade", "infactory", "Filler", "infiller", "future", "FFactory", "sfault", "hade", " folver", "affault", "huture", "piller", "fixture", "bixture", "fsolver", " filler", "efluent", "affluent"], "connection": ["relation", "position", "cache", "uri", "current", "client", "out", "connected", "port", "session", "translation", "c", "union", "config", "system", "info", "Connection", "use", "link", "driver", "socket", "conn", "image", "default", "application", "condition", "writer", "con", "service", "resource", "builder", "proxy", "open", "communication", "io", "connect", "database", "character", "server", "password", "function", "index", "container", "channel", "handler", "wrapper", "creator", "version", "collection", "response", "reader", "common", "user", "section", "error", "context", "http"], "stream": ["source", "form", "result", "sw", "video", "media", "output", "out", "client", "path", "translation", "load", "f", "system", "model", "view", "per", "input", "trans", "image", "or", "data", "writer", "loader", "object", "resource", "transform", "io", "cont", "server", "sc", "sl", "body", "container", "upload", "Stream", "string", "channel", "stack", "handler", "coll", "raw", "file", "version", "row", "response", "feed", "entry", "reader", "v", "context"]}}
{"id1": "6742637", "id2": "14450108", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"findExtensions": ["findextensions", "findDistension", "getextends", "findextends", "getExtensions", "getExtends", "findExtension", "getExtension", "findDistends", "getextension", "findDistensions", "findAppends", "findAppension", "findextension", "getextensions", "findExtends", "findAppensions"], "url": ["ls", "source", "org", "remote", "result", "buffer", "re", "uri", "gl", "path", "Url", "load", "config", "f", "ver", "bb", "page", "il", "link", "l", "src", "image", "loc", "data", "web", "service", "resource", "location", "io", "base", "name", "bel", "log", "server", "URL", "rl", "zip", "address", "api", "ch", "sl", "rc", "connection", "fr", "ur", "cl", "lr", "ul", "element", "impl", "coll", "html", "file", "bug", "pull", "err", "r", "ssl", "feed", "id", "entry", "rel", "http"], "extensions": ["intps", "fensions", "exensions", "Extension", "fends", "intension", "appensions", "fps", "Extencies", "intends", "xtension", "xtends", "extension", "appencies", "exras", "extras", "appras", "fension", "extps", "extencies", "exension", "xtps", "exencies", "exends", "Extras", "intensions", "exps", "xtensions", "Extensions", "appension"], "res": ["rem", "ris", "ret", "result", "ps", "re", "out", "ver", "rr", "mr", "ex", "rest", "RE", "vals", "resp", "req", "resource", "RS", "rs", "ras", "ros", "RES", "os", "ries", "hr", "is", "gr", "ch", "rc", "Rs", "rss", "rus", "fr", "pres", "details", "vers", "raw", "rez", "resolution", "rex", "ress", "Res", "es", "request", "r", "results", "response", "err", "rev", "rh", "js", "rows", "http"], "prop": ["p", "attr", "ref", "app", "style", "result", "property", "ps", "fp", "mp", "feature", "feat", "f", "config", "info", "fb", "point", "Prop", "pb", "project", "pos", "val", "data", "resource", "class", "base", "tmp", "b", "proc", "ext", "obj", "pac", "priv", "api", "term", "j", "exp", "cp", "option", "comp", "pr", "lit", "def", "properties", "pro", "key", "part", "op", "opt"], "msg": ["text", "me", "og", "message", "eg", "ug", "str", "s", "info", "title", "cmd", "sg", "agg", "rag", "cfg", "ko", "mb", "mg", "loc", "req", "m", "format", "bf", "g", "log", "ms", "reason", "Msg", "ext", "kg", "printf", "mid", "bg", "gr", "gm", "db", "string", "tag", "mn", "mt", "gs", "urg", "err", "comm", "mag", "error", "status"]}}
{"id1": "21308543", "id2": "12172485", "code1": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", " copiedContent", " copyStream", "copyStream", "transferContent", " copyFiles", "copyContent", " copiedFile", "transferStream", "transferFiles", " copiedStream", " copyContent", "transferFile", " copiedFiles"], "src": ["inf", "sin", "loc", "remote", "slice", "sc", "stream", "inst", "download", "rc", "feat", "ource", "ls", "img", "href", "rs", "ruby", "dest", "rb", "this", "source", "image", "js", "project", "path", "filename", "attr", "url", "code", "uri", "server", "core", "sit", "http", "sci", "scene", "upload", "sel", "resource", "input", "string", "media"], "target": ["nt", "director", "loc", "name", "it", "master", "arget", "effect", "remote", "type", "reference", "secure", "to", "top", "prot", "base", "fat", "text", "output", "goal", "content", "writer", "eth", "dest", "temp", "external", "source", "port", "project", "path", "parent", "large", "object", "next", "url", "Target", "resource", "out", "result", "compatible", "rel", "arg", "tx"], "ic": ["icc", "pic", "iac", "ici", "loc", "it", "ct", "irc", "cin", "enc", "ics", "aic", "ec", "pc", "rc", "ix", "lc", "cci", "isc", "acl", "ico", "i", "ci", "cc", "vc", "inc", "nic", "exec", "ik", "IC", "xc", "ick", "cl", "voc", "mic", "io", "cit", "c", "sci", "aci", "ai", "mc", "ac", "fc", "ip", "bc", "ib"], "oc": ["abc", "pic", "AC", "arc", "loc", "org", "toc", "iv", "alloc", "sc", "irc", "oca", "enc", "ec", "pc", "rc", "cs", "bb", "isc", "roc", "output", "o", "oci", "ci", "cc", "vc", "uc", "anc", "nic", "exec", "xc", "other", "voc", "mic", "OC", "io", "c", "ocr", "co", "acs", "ocol", "soc", "aco", "mc", "ac", "ace", "bc", "fc"]}}
{"id1": "4562786", "id2": "3767903", "code1": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"GetResponse": ["ReadReply", "Readresponse", "CheckReply", "CheckResult", "GetResult", " GetResult", " Getresponse", "Checkresponse", "CheckResponse", " GetReply", "GetReply", "ReadResponse", "Getresponse", "ReadResult"], "url": ["image", "URL", "service", "resource", "base", "coll", "Url", "http", "l", "api", "object", "page", "string", "c", "path", "org", "uri", "build", "client", "il", "ur", "ssl", "proxy", "loc", "server", "user", "file", "gl", "ob", "u", "sl", "str", "rl", "el", "or", "connection", "config", "host", "web", "f", "address"], "content": ["body", "err", "method", "lc", "resource", "Content", "section", "temp", "feed", "cont", "raw", "continue", "json", "load", "message", "text", "output", "full", "page", "left", "string", "code", "status", "c", "array", "job", "result", "cover", " Content", "response", "report", "name", "clean", "fully", "request", "data", "value", "description", "comment", "empty", "results", "res", "complete", "connection", "source", "header", "address"], "conn": ["enc", "conv", "nt", "coll", "dc", "cli", "nc", "open", "cur", "rt", "Connection", "http", "ca", "exec", "sync", "ch", "cb", "cat", "ann", "act", "c", "cf", "cr", "ct", "g", "rc", "ci", "p", "en", "cmp", "org", "client", "cc", "pub", "auth", "comm", "close", "init", "ssl", "col", "co", "con", "h", "cn", "loc", "ec", "oa", "connect", "adj", "Conn", "n", "ctx", "cp", "connection", "config", "db"], "br": ["err", "dr", "fr", "coll", "bl", "arr", "src", "ler", "yr", "bridge", "ch", "bb", "b", "cb", "pr", "ctr", "buf", "r", "ber", "gr", "tr", "bro", "bd", "div", "result", "Br", "BR", "mr", "ner", "hr", "bar", "sr", "data", "browser", "str", "reader", "rb", "bc", "bh", "ar", "cr", "obj"], "line": ["body", "letter", "link", "err", "lc", "fr", "feed", "section", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "message", "Line", "key", "l", "page", "string", "code", "c", "r", "pass", "part", "result", "record", "number", "response", "row", "le", "character", "ip", "name", "word", "data", "file", "include", "cell", "e", "char", "str", "comment", "reader", "i", "sl", "source", "cr", "f", "lin"]}}
{"id1": "20375440", "id2": "7087108", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "srcFile": ["srcFiles", " srcDir", "sourcefile", "sourceFiles", "destDir", "destfile", "srcDir", "destFiles", "srcfile", " srcPath", "sourceFile", " srcFiles", "sourcePath", "sourceDir", "srcPath", " srcfile", "rcFile", "rcFiles", "rcPath", "rcfile"], "destFile": ["tempFile", "DestPlace", "destPlace", " destPath", "targetPlace", "DestFile", "Destfile", "destfile", "targetfile", "destFiles", "restPlace", "tempfile", "DestPath", " destfile", "destPath", "targetFiles", "restFiles", "tempPath", "restfile", "tempFiles", "DestFiles", "targetFile", "restFile", " destFiles"], "src": ["in", "sc", "client", "self", "sl", "ctx", "upload", "sec", "stat", "stream", "sync", "rc", "func", "bs", "impl", "slice", "input", "rs", "construct", "RC", "sb", "conn", "loc", "source", "rb", "inst", "cur", "ssl", "img", "proc", "gb", "sup", "dist", "config", "start", "secure", "sr", "sel", "url", "req", "conv", "sq", "loader", "reader", "sys", "cmp", "ser", "ws", "sub", "cb", "ources"], "dest": ["writer", "de", " Dest", "obj", "stream", "cp", "output", "class", "tmp", "comb", "std", "opt", "slave", "thin", "home", "Dest", "ui", "target", "result", "dc", "wh", "desc", "path", "ssl", "img", "proc", "out", "cdn", "sup", "ds", "dist", "end", "dir", "this", "wb", "null", "rest", "des", "div", "temp", "trans", "test", "transform", "d", "destroy", "usr", "dev", "ws", "dat", "source"], "buffer": ["request", "position", "writer", "bytes", "size", "batch", "capacity", "block", "queue", "key", "transfer", "feed", "input", "slice", "layer", "reference", "write", "copy", "Buffer", "limit", "cache", "address", "info", "result", "message", "buff", "raw", "value", "row", "uffer", "iter", "buf", "channel", "null", "base", "data", "b", "offset", "number", "wave", "memory", "bin", "reader", "string", "header", "flush", "source", "length"], "read": ["get", "ind", "ip", "next", "connect", "level", "size", "shape", "sync", "ok", "n", "Read", "block", "i", "key", "default", "use", "feed", "load", "input", "slice", "write", "parse", "copy", "id", "limit", "reads", "check", "run", "open", "seek", "index", "pick", "READ", "not", "show", "sleep", "se", "work", "send", "count", "reading", "find", "fill", "raw", "build", "start", "x", "end", "iter", "close", "no", "pass", "exec", "k", "data", "b", "wait", "number", "ride", "allow", "text", "skip", "reader", "d", "play", "add", "create", "length", "select"]}}
{"id1": "2642914", "id2": "20735941", "code1": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"addFileToTarGz": ["addFileToTargx", "addFileToTarGarzi", "addFileToZipGszip", "addFileToTarGszip", "addFileToTarGx", "addFileToTargzi", "addFileToTarGuz", "addFileToTarGzi", "addFileToTarGgz", "addFileToTarggz", "addFileToZipGarx", "addFileToTargzip", "addFileToZipGarzip", "addFileToTarGarx", "addFileToZipGsz", "addFileToTarGux", "addFileToTargz", "addFileToZipGzi", "addFileToTarGarzip", "addFileToZipGszi", "addFileToTarGuzi", "addFileToZipGsgz", "addFileToTarGsgz", "addFileToZipGgz", "addFileToZipGarzi", "addFileToTarGarz", "addFileToTarGzip", "addFileToTarGuzip", "addFileToZipGz", "addFileToZipGzip", "addFileToTarGszi", "addFileToTarGargz", "addFileToZipGx", "addFileToZipGarz", "addFileToTarGsz"], "taro": ["Tro", "Taro", "tabo", " tabo", "ptabo", "thaco", "Targo", "Tara", "thoro", "Tamar", "tharo", "fara", " taco", "tamar", "ptaro", "atro", "atoran", "staro", "targo", " too", "taron", "stro", "staco", "Tabo", "faco", " tara", "Too", "Toro", "tara", "toro", "stamar", "tero", "taco", "ptaron", "atargo", "Toran", "storo", "loran", "ptargo", "thamar", "Taco", "laro", "fargo", "lro", "toran", "Taron", "faro", "stoo", " tro", "ptaco", "ataro", "Tero", "too", "largo", "stero", " tero", " taron", "tro", " targo"], "path": ["folder", "resource", "root", "route", "string", "c", "cache", "Path", "pointer", "str", "log", "key", "from", "object", "dir", "fn", "loc", "p", "url", "location", "ath", "filename", "image", "directory", "type", "data", "PATH", "id", "pattern", "parent", "uri", "source", "text", "name", "file", "ref"], "base": ["resource", "root", "ase", "string", "cache", "site", "http", "area", "core", "api", "key", "from", "absolute", "dir", "address", "Base", "store", "p", "default", "part", "prefix", "server", "url", "index", "bas", "home", "pre", "start", "relative", "type", "b", "bf", "id", "parent", "uri", "buffer", "back", "name", "file", "extra"], "f": ["fa", "df", "ref", "fe", "F", "fc", "of", "g", "c", "n", "m", "sf", "d", "fo", "fx", "aff", "self", "raf", "fd", "feed", "this", "cf", "framework", "fold", "fn", "p", "fs", "l", "tf", "s", "w", "j", "url", "fac", "flat", "af", "e", "i", "h", "fp", "fen", "v", "file", "inf", "found", "r", "b", "fb", "t", "bf", "lf", "form", "fr", "rf"], "entryName": ["elementType", "fileName", "entryType", "fileType", "fileTime", "EntryName", " entryPath", "EntryTime", " entryname", "archivename", "elementName", "elementTime", "entryname", "archiveSize", "archiveName", "elementPath", "resourceSize", "resourcename", " entrySize", "filePath", "resourcePath", "entrySize", " entryTime", "entryTime", " entryType", "EntryPath", "EntryType", "archivePath", "entryPath", "resourceName"], "goIn": ["poOut", "goIN", "GOin", "GoIN", "goIns", "goin", "poIns", "GoIns", "loin", "loIN", "gaIns", "coin", "GOOut", "coIns", "coIn", "gaIN", "GOIn", "loIns", "coOut", "goOut", "gaIn", "Goin", "gain", "loIn", "poIN", "GOIN", "GoIn", "poIn", "GOIns", "poin"], "tarEntry": ["TarEntry", "zipFile", "zipEntry", "zipInfo", "tarEnt", " Tarentry", "zipEnt", "tarFile", "rarInfo", "Tarentry", "rarEnt", " TarEntry", " tarentry", " tarInfo", "tarentry", "tarElement", "rarEntry", " tarEnt", "tarInfo", " tarFile", "rarFile", "TarElement", " tarElement", " TarElement"], "children": ["pages", "many", "packages", "each", "words", "well", "father", "current", "parents", "opens", "values", "far", "open", "feed", "ools", "files", "ins", "members", "content", "plugins", "loc", "bars", "roots", "all", "ales", "jobs", "when", "ren", "balls", "scenes", "kids", "other", "ports", "pool", "blocks", "ul", "iblings", "h", "Children", "output", "data", "sub", "parent", "web", "pes", "name", "which", "rows"], "child": ["entry", "ch", "row", "root", "or", "pull", "cloud", "slave", "and", "c", "channel", "hel", "comment", "layer", "feed", "key", "in", "client", "count", "build", "l", "connection", "shell", "server", "per", "pool", "code", "i", "lib", "Child", "draft", "page", "data", "cel", "id", "job", "parent", "kid", "leaf", "name", "file"]}}
{"id1": "12146394", "id2": "9996334", "code1": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "code2": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "label": 1, "substitutes": {"md5Crypt": ["MD2crypt", "md4Hash", "md2Hash", "md2Crypt", "md6Hash", "MD2Hash", "MD2Key", "md2Key", "MD5Crypt", "MD5Hash", "md4Key", "md4Crypt", "md6Crypt", "md4crypt", "md5Key", "md6Key", "md2crypt", "md5crypt", "MD2Crypt", "md6crypt", "MD5crypt", "md5Hash", "MD5Key"], "key": ["x", "source", "text", "message", "cookie", "cache", "k", "image", "money", "ip", "air", "core", "base", "name", "code", "power", "zip", "time", "rule", "size", "cer", "y", "temp", "any", "type", "go", "char", "copy", "token", "ace", "sync", "shift", "this", "hash", "use", "seed", "phrase", "root", "word", "none", "data", "magic", "req", "other", "kw", "here", "self", "password", "id", "user", "parent", "order", "pair", "secret", "kid", "call", "cy", "fee", "point", "state", "input", "year", "cert", "ce", "ke", "blow", "number", "proof", "string", "element", "value", "version", "KEY", "my", "no", "length", "wire", "empty", "ask", "date", "material", "kh", "m", "service", "server", "transfer", "ch", "list", "scope", "connection", "lock", "ee", "full", "trust", "row", "ssl", "sign", "carry", "Key"], "salt": ["asalt", "sodium", "southift", "southALT", " sodium", "svort", "asal", "southart", "sval", "osalt", "sessecret", "sesALT", "southalt", "sass", "sal", " ssecret", "sift", "sesalt", "seskey", "asALT", "sesol", "sol", "ssol", "Sal", "osul", "ssALT", "Sodium", "sesort", "assecret", "sesart", " skey", "skey", " sol", "sesift", "southsecret", " sift", "ssass", "SALT", "Salt", "southodium", "sart", " sart", "sALT", " sass", "sort", "osALT", "svalt", "sesal", "osift", " sALT", "svALT", "sesul", "sul", "sesass", "ssecret", "Ssecret", "ssalt"], "_md": ["Newdm", "_key", "_mand", "copycmd", "_mb", "localmd", "localcmd", " _key", "__dm", " _dm", "_dm", "Newcmd", "Newmd", "\u00a0mand", "\u00a0mode", "_cmd", "copydm", "copymd", "\u00a0dm", "_mg", "Newamd", " _cmd", "copykey", " _amd", "_MD", " _nm", " _MD", "_db", "__md", "\u00a0cmd", "_m", " _db", "__amd", "_nm", "_amd", "_mode", "\u00a0md", " _m", "__cmd", "\u00a0nm", "localmb", "localmg", "\u00a0m"], "md2": [" md02", "amd4", "cmd02", "md32", "md4", "md62", "cmd3", "md5", "hdTwo", "MD4", "cmd1", " md1", "amd32", "cmd2", "MD2", " mdTwo", " md5", "cmd4", "amd2", "amd62", " md62", "MD5", "cmd5", "cmd62", "hd62", "MD62", " md32", "amdTwo", " md4", "md1", "hd2", "md02", "hd32", "amd02", "mdTwo", "MD3", "MD1"], "abyFinal": ["saySpecial", "andyFinal", "Babyfinal", "sayInitial", "amyFinal", "BabyFinal", "BabyFinish", "abiesFull", "abyLast", "BabyFull", "abyTotal", "sayFinal", "aberfinal", "abySuccess", "andyLast", "aberInitial", "abiesSuccess", "abyResult", "BabyLast", "butLast", "rayLast", "abiesFinal", "andyInitial", "babyTotal", "babyInitial", "abeFinal", "abeLast", "abySpecial", "babyLast", "amySuccess", "abyfinal", "butInitial", "andyTotal", "amySpecial", "aberFinal", "amyResult", "butFinal", "babyfinal", "andyfinal", "babySpecial", "abeFinish", "rayInitial", "abyFinish", "babyFinal", "babyResult", "abiesResult", "amyInitial", "babySuccess", "aberTotal", "abyFull", "rayFinal", "abiesLast", "abeFull", "abyInitial", "abiesFinish"], "n": ["p", "x", "gn", "span", "inn", "byn", "net", "z", "br", "c", "ni", "f", "yn", "all", "not", "len", "np", "nt", "l", "conn", "k", "none", "N", "nor", "nan", "m", "ner", "ne", "g", "nn", "a", "on", "name", "don", "num", "b", "nb", "number", "na", "nu", "min", "nc", "fn", "pn", "mn", "ng", "nw", "en", "un", "sn", "ns", "y", "cn", "ny", "syn", "t", "non", "dn", "adj", "o", "r", "network", "v", "node", "d", "no"], "j": ["p", "x", "ij", "z", "c", "ni", "jl", "bj", "ii", "dj", "ie", "l", "I", "k", "aj", "ci", "ind", "yi", "q", "ne", "io", "si", "v", "jj", "b", "u", "num", "ja", "ji", "jc", "li", "index", "fr", "di", "qi", "jp", "y", "xi", "adj", "uj", "o", "J", "section", "js", "d"], "i": ["p", "ani", "c", "ni", "ai", "gi", "ii", "e", "ie", "I", "ci", "yi", "ini", "chi", "multi", "iu", "bi", "io", "si", "mini", "ui", "pi", "ji", "ki", "li", "index", "oi", "mi", "di", "qi", "gu", "eni", "y", "xi", "fi", "ali", "mu", "o", "zi", "ri", "ti", "phi"], "sbPasswd": ["sfPasswords", "cbPassword", "sbCrWD", "sbPassw", "sfPassw", "bbParrc", "bbParwd", "bbParword", "cbParphrase", "rbCrw", "sbParwords", "rbPassWD", "cbParwd", "sbCrrc", "cbPassw", "rbCrwd", "sfSecretwd", "sbPassWD", "sbCrwords", "bbPassw", "sbSecretwords", "sbPassrc", "cbParw", "sfSecretword", "sbPassphrase", "sfPasswd", "sbParwd", "sbFailphrase", "sbCrwd", "bbPassword", "sbParrc", "cbPasswd", "rbPassw", "sbPasswords", "sfSecretw", "sbSecretwd", "sbFailw", "sbParWD", "bbPasswd", "sbCrw", "sfSecretwords", "sbParword", "bbPassrc", "sbPassword", "sbParphrase", "cbPassphrase", "cbParword", "rbCrWD", "sbParw", "rbPasswd", "rbPassword", "sbSecretw", "sbCrword", "sbSecretword", "sbFailwd", "bbParw", "sbFailword", "rbCrword", "sfPassword"], "md3": ["md03", "mand3", " md53", "md53", "mand15", "mand23", "cmd3", "md512", "cmd1", " md1", "mdthree", "mag512", "cmd23", "amd15", "amd23", "amd512", "amd3", "cmd2", "MD2", "amdthree", " md23", "md23", "ms3", "mag15", "MD23", "MD53", " md03", " mdthree", "cmd53", "mand512", "md1", "mdthird", "mag23", "amd03", "msthird", "md15", " mdthird", "mag3", "amdthird", "msthree", "MD3", "ms03", "MD1"]}}
{"id1": "4593011", "id2": "19147281", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"loadDDL": ["LoadCDE", "loadDDE", "loadODL", "LoadDDLL", "loadSDLL", "loadCDML", "loadSDE", "loadODLL", "loadCDL", "loadODML", "LoadDDML", "loadSDML", "LoadDDE", "loadDDLL", "loadODE", "LoadDDL", "LoadCDL", "LoadCDLL", "LoadCDML", "loadSDL", "loadDDML", "loadCDLL", "loadCDE"], "stmt": ["stm", "constm", "Stmd", " stm", " stmn", "Stmp", " sttr", " stgr", "sttt", "Stm", "STtr", "Sttt", "rm", "estmt", "rdb", "rmt", "rmd", "tmt", "constmt", "esttt", "tmd", "STmp", "estmd", "strgr", "Stdb", "stmd", " stdb", "constmn", "Stmb", " sttt", "estm", "tdb", "Stmn", "estmp", "stmr", "STmb", "strmt", "stpr", "stmn", "STgr", "tm", "STpr", "sttr", "Stmr", " stpr", "STmr", "constdb", "stmp", "Stmt", "STmt", "strpr", "stgr", "strtr", "stmb", "estmr", "estmb", " stmd", "stdb"], "qry": ["quri", "qries", "equry", " qury", "Qries", "quries", "qurys", "qrys", "eqRY", "Qry", "qRY", " qrys", "quury", "qury", "qri", " qri", " qries", "quRY", "eqry", " qRY", "Qri", "Qrys", "eqrys"], "q": ["v", "k", " p", "e", "id", "requ", "request", " query", "queue", "c", "Q", " sq", "t", "sq", "i", "r", "dq", "ql", "b", "iq", "n", "query", "config", "qq", " req", "qu", "p", "key", "qa", "ch", "qs", "eq", "qt", "d", "req", "quant", "quest", "select", "f"]}}
{"id1": "19912848", "id2": "3806532", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.getRealFile(), name);\n        LOGGER.debug(\"PUT?? - real file: \" + this.getRealFile() + \",name: \" + name);\n        if (isOwner) {\n            if (!\".request\".equals(name) && !\".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            } else {\n                if (ServerConfiguration.isDynamicSEL()) {\n                } else {\n                }\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n            }\n            return factory.resolveFile(this.host, dest);\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "149935", "id2": "2668634", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["oconversion", "CONversion", "oconverting", " deconverted", "CONverting", " deconvert", "conception", "CONception", " deconverting", "unverted", "subversion", "CONverted", "Conception", " deconversion", "oconvert", "unversion", "converted", "unception", "subvert", "conversion", "Convert", "unvert", "Converted", "subverted", "subverting", "converting", "oconverted", "Converting", "Conversion", "CONvert"], "src": ["video", "resource", "storage", "config", "stream", "Source", "impl", "gz", "RC", "input", "download", "feat", "req", "ref", "load", "back", "filename", "slice", "href", "cb", "prot", "url", "string", "code", "buf", "gb", "spec", "dist", "cpp", "rc", "stage", "sn", "path", "st", "sc", "cmp", "upload", "ource", "uri", "sb", "proc", "SourceFile", "sin", "img", "fp", "supp", "attr", "sit", "secure", "tmp", "name", "ssl", "Dest", "sel", "sys", "component", "file", "fn", "inst", "username", "sth", "reader", "rb", "rl", "ctx", "scene", "loc", "source", "obj", "s"], "dest": [" destination", "temp", "cont", "dc", "dat", "target", "bin", "home", "null", "txt", "class", "orig", "lib", "dist", "path", " dst", "img", "dir", "std", "tmp", "test", "Dest", "fn", "di", "source", "obj", "disk"], "in": ["ini", "err", "login", "stream", "inn", "inf", "val", "input", "In", "up", "bin", "pin", "r", "IN", "ps", "t", "pass", "d", "doc", "source", "io", "ins", "is", "as", "inas", "a", "data", "isin", "file", "ex", "i", "reader", "win", "n", "din", "f", "inc"], "p": ["np", "j", "o", "po", "pre", "py", "P", "pc", "cop", "parser", "l", "b", "jp", "pr", "bp", "lp", "pi", "pp", "sp", "pe", "c", "r", "wp", "g", "ps", "t", "pa", "d", "op", "pg", "part", "pm", "v", "fp", "pb", "h", "tp", "pd", "e", "i", "per", "cp", "m", "f", "s"], "ds": ["ths", "dp", "vals", "ls", "services", "ads", "ld", "lp", "groups", "dt", " ps", "os", "ins", "icks", "nas", "ts", "dates", "scripts", "s", "dc", "dat", "Ds", "points", "els", "sync", "tools", "ipes", "xs", "obs", "sts", "d", "ils", "dds", "hs", "gs", "docs", "sys", "pd", "dm", "ss", "dl", "des", "posts", " DS", "utils", "cons", "lines", "ns", "ges", "da", "tests", "ays", "dist", " props", "eps", "cs", "df", "uds", "gd", "qs", "ys", "data", "ded", "ks", "words", "di", "db", "parts", "dd", "ants", "vs", "amps", "ans", "DS", "dos", "plugins", "styles", "js", "ps", "rs", "ups", "models", "bs", " sd"], "format": ["letter", "model", "unit", "nat", "plugin", "prefix", "form", "function", "pattern", "at", "feat", "filter", "version", "parser", "atter", "filename", "sche", "api", "table", "Format", "struct", "style", "string", "class", "scale", "act", "spec", "t", "fd", "path", "handler", "ant", "template", "source", "type", "record", "part", "frame", "fp", "name", "language", "host", "data", "file", "layout", "fn", "magic", "config", "tag", "f", "url"], "hasPixelData": ["hasPixelStyle", "haspixeldata", "showsByteDATA", "hasByteStyle", " hasPixelSize", "hasByteDATA", "showsPixelDATA", "hasPixelDATA", "hasPictureSize", "hasPixeldata", "hasByteData", "hasPixelSize", "showsPixelData", "haspixelData", "hasPicturedata", "showsByteData", "hasByteSize", "showsByteStyle", "haspixelSize", "showsPixeldata", "showsBytedata", "showsPixelStyle", "hasBytedata", "hasPictureData", " hasPixeldata"], "inflate": ["inadequode", "infloation", "inadequATE", "InFlace", "infloace", "Inflation", "inflation", "InFlate", "Inflated", "inflode", "infolode", "insflating", "invenate", "insvenate", "infolate", "Inflate", "infolATE", "infolating", "InFlated", "insvenATE", "invenating", "inFlace", "inflace", "insflode", "invenode", "inadequating", "insvenating", "inffate", "InFlation", "insflate", "inffation", "invenATE", "infloated", "inffated", "inflating", "inFlate", "Inflace", "insflATE", "infface", "infloate", "inFlated", "inadequate", "insvenode", "inflated", "inflATE", "inFlation"], "pxlen": ["pxden", "pxdata", "mxlen", "campos", "pxln", "mxln", "pxlon", "camln", "mxcount", "pxlin", "pngsize", "xplength", "fxln", "xpsize", "pgden", "ppl", "pplen", "fxden", "pxsize", "pxcount", "fxpos", "axlin", "pclon", "ppLen", "pnglength", "txlon", "pnglen", "pxl", "mxlength", "xplen", "xpcount", "axlen", "txlin", "txln", "pxpos", "ppden", "mxdata", "pglen", "pgLen", "mxpos", "pxlength", "fxl", "pclen", "pgl", "camlen", "pclin", "camdata", "axln", "txlen", "pcln", "fxLen", "pxLen", "mxsize", "fxdata", "pngcount", "fxlen", "axlon"], "out": ["re", "err", "log", "point", "step", "cli", "inter", "up", "group", "cache", "output", "OUT", "list", "conn", "post", "page", "pad", "store", "session", "state", "again", "outs", "work", "query", "line", "io", "v", "Out", "co", "dump", "sys", "server", "user", "gen", "lock", "error", "lib", "parent", "obj", "copy"]}}
{"id1": "8973505", "id2": "23677142", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "\tpublic static void BubbleSortShort2(short[] num) {\n\t\tint last_exchange;\n\t\tint right_border = num.length - 1;\n\t\tdo {\n\t\t\tlast_exchange = 0;\n\t\t\tfor (int j = 0; j < num.length - 1; j++) {\n\t\t\t\tif (num[j] > num[j + 1])\n\t\t\t\t{\n\t\t\t\t\tshort temp = num[j];\n\t\t\t\t\tnum[j] = num[j + 1];\n\t\t\t\t\tnum[j + 1] = temp;\n\t\t\t\t\tlast_exchange = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tright_border = last_exchange;\n\t\t} while (right_border > 0);\n\t}\n", "label": 0, "substitutes": {"writeFileType": ["createFiletype", "writeFILETypes", "createFilesHeader", "writePagetype", "writeFileHeader", "createFilesTypes", "writeFileTypes", "writePageHeader", "writeFilestype", "createFileType", "createFileTypes", "writeFILEHeader", "writeFILEType", "createFileHeader", "writeFilesTypes", "createFilestype", "writeFILEtype", "writeFiletype", "writeFilesHeader", "writeFilesType", "writePageType", "createFilesType", "writePageTypes"], "uriFile": ["riFile", "urifile", "uiUrl", "uriFiles", "URIFiles", "uifile", "riFiles", "riFilename", "uiFiles", "URIfile", "URIFilename", "uriUrl", "filenameFile", "URIFile", "filenameFiles", "filenamefile", "filenameFilename", "riUrl", "uiFile", "rifile", "URIUrl", "uriFilename"], "outputfile": ["Outputfull", "inputfilename", "outputfull", "inputFile", "inputdir", "outputdir", "Outputdir", "resourcefilename", "unitfiles", "outputstring", "outputFile", "OutputFile", "unitstring", "Outputfile", "inputfiles", " outputdir", " outputfull", "inputstring", "inputfile", " outputFile", "unitfile", "resourcefile", "outputfilename", "outputfiles", "resourcefiles", "unitfilename", "resourcestring", "inputfull"], "num": ["span", "nb", "amount", "multi", "n", "zero", "initial", "col", "limit", "mult", "master", "sum", "con", "number", "NUM", "coord", "umi", "length", "no", "count", "unit", "Num", "batch", "index", "len", "split", "term", "nam", "inc", "offset", "nu", "dim", "loop", "name", "common"], "writer": ["we", "wt", "function", "manager", "Writer", "engine", "book", "w", "out", "socket", "writing", "write", "wl", "entry", "external", "ler", "walker", "outer", "report", "io", "feed", "header", "wire", "element", "office", "per", "editor", "page", "output", "data", "written", "null", "message", "master", "wb", "later", "root", "writ", "xml", "ee", "driver", "creator", "er", "document", "part", "wan", "ws", "index", "rw", "worker", "journal", "author", "type", "r", "lock", "width", "temp", "riter", "window", "writers", "method", "inner", "service", "layer", "wave", "wa", "key", "object", "handler", "unit", "server", "loader", "e", "session", "wrapper", "format", "widget", "wr", "style", "buffer", "source", "builder"], "uri": ["resource", "route", "http", "winner", "database", "umi", "address", "prefix", "location", "eni", "gi", "collection", "file", "username", "href", "uid", "sequence", "nor", "verb", "URI", "connection", " URI", "element", "link", "ori", "filename", "iri", "direction", "mi", "term", "picture", "message", "course", "folder", "attribute", "multi", "oid", "pi", "node", "di", "document", "query", "component", "cli", "doi", "li", "range", "id", "binary", "uni", "origin", "reference", "wiki", "token", "qi", "string", "ilo", "context", "ui", "ri", "theme", "unit", "handler", "base", "du", "i", "hub", "feature", "remote", "nil", "directory", "plugin", "metadata", "source"], "counter": ["entry", "computer", "ver", "current", "instance", "step", "ter", "vector", "inter", "pointer", "expression", "currency", "comment", "inner", "condition", "master", "continue", "trace", "time", "cpu", "outer", "ner", "sequence", "number", "enter", "second", "repeat", "nr", "Counter", "creator", "keeper", "handler", "count", "book", "batch", "cookie", "hello", "coll", "server", "clock", "loader", "name", "index", "processor", "iter", "controller", "i", "worker", "record", "page", "result", "runner", "meter", "parser", "timer", "loop", "info", "parent", "offset", "collection", "race", "keep", "lc", "reference"], "reader": ["row", "riter", "ger", "ir", "reading", "upper", "oder", "ruby", "inner", "ler", "layer", "io", "ner", "feed", "driver", "in", "ri", "keeper", "er", "handler", "lr", "bird", "l", "loader", "read", "Reader", "rer", "per", "iter", "e", "worker", "editor", "finder", "rr", "r", "rx", "parser", "rar", "stream", "buffer"], "url": ["resource", "string", "channel", "blog", "http", "www", "URL", "path", "io", "feed", "Url", "ri", "client", "user", "download", "address", "browser", "l", "connection", "base", "ls", "server", "config", "sl", "link", "li", "image", "page", "ssl", "plugin", "id", "web", "stream", "text", "source", "file"], "myConnection": ["Myconnection", "someConn", " myconnection", "someConnection", "myconnection", "myConnector", " myConn", "myConn", "yourconnection", "MyConnect", " myConnect", "MyConnection", "yourConnection", "MyConnector", " myConnector", "MyConn", "yourConn", "someReader", "myConnect", "yourConnector", "MyReader", "someConnect"], "myReader": ["MyParser", " myRead", "MyWriter", "myParser", "MyReader", "yourWriter", "MyRead", "myRead", "myWriter", "yourParser", " myWriter", " myParser", "yourRead", "yourReader"], "line": ["inline", "look", "entry", "row", "pass", "day", "use", "string", "note", "lines", "word", "LINE", "comment", "le", "Line", "response", "log", "feed", "key", "cl", "ri", "user", "no", "letter", "header", "frame", "rule", "liner", "part", "base", "l", "lin", "cell", "pe", "element", "du", "non", "link", "code", "el", "page", "range", "error", "data", "parse", "style", "point", "id", "message", "lf", "source", "text", "block", "column", "name", "file", "lc", "end"], "linecount": ["pageindex", "rowcache", "letterlength", " linelength", "rowlength", "rowlen", "rowcount", " linecache", "linelength", "Linecount", "linenumber", "LineCount", "linesize", " linenumber", "linecache", "Linesize", "linelen", "letterlen", "Linecache", "lettercount", " lineindex", "lineCount", "pagecount", " lineCount", "pagenumber", " linelen", "Linenumber", "Lineindex", "lineindex", " linesize", "rowsize", "lettersize", "pageCount"], "hasOWL": ["hasOWl", "hasOWLA", "hasEWLL", " hasEWLM", "HasEWLA", " hasOWLA", "hasOULA", "HasOWLM", "hasODL", "hasBYLL", "hasEFLM", " hasOWLL", "hasEFl", "hasOUL", "hasBYl", "HasOWLL", "hasODLL", "hasODLA", "hasOWSL", " hasOWLM", "HasOWLA", "hasOULL", " hasEWDL", "hasEFLA", "hasEWLA", "hasOWLL", "hasEWL", "hasOWSl", "HasEWL", "hasODLM", " hasEWLA", "hasEWl", "hasOULM", "hasBYDL", "hasODl", " hasOWl", "HasEWLM", " hasEWL", "hasOWDL", "HasOWL", "hasBYL", "hasOWLM", " hasEWLL", "hasOWSLL", "HasEWLL", "hasEWLM", "hasOWSDL", "hasEWDL", " hasEWl", "hasEFL", " hasOWDL"], "hasRDFS": ["hasXDPE", "hasRNFU", "hasCDFE", "hasRdfS", "hasRDFs", "hasGRUFS", "hasRNFs", "hasXDFE", "hasCDFs", "hasRDFAST", "hasRTFE", "hasRdfE", "hasRdfs", "hasGRDFSU", "hasRDPE", "hasGRUFs", "hasRDFU", "hasRDPs", "hasXDFS", "hasRFES", "hasCDPs", "hasRDPSU", "hasCDPE", "hasXDFs", "hasRTFES", "hasRDFE", "hasGRDFAST", "hasGRUFSU", "hasXDPU", "hasRUFs", "hasXDPs", "hasRFE", "hasCDPES", "hasRUFAST", "hasCDFS", "hasRNFS", "hasRUFSU", "hasRDPS", "hasRdfU", "hasRTFS", "hasGRDFS", "hasRNFE", "hasRFSU", "hasRDPES", "hasCDFES", "hasRFS", "hasRFs", "hasGRDFs", "hasRDFSU", "hasRDPAST", "hasRDPU", "hasRFAST", "hasXDPS", "hasRTFs", "hasCDPS", "hasRDFES", "hasXDFU", "hasRUFS", "hasGRUFAST"], "hasRDF": ["hasUOW", "hasUDP", "hasMRDEF", "hasSRDP", " hasRRUF", "hasRMF", "hasNRMF", "yesROW", "hasSRDF", "hasRUF", "hasNRUF", "hasRRDP", "hasDDP", "hasMRDP", "hasRRDEF", "hasURMF", "HasRRDP", "hasUMF", "HasRDP", "hasRRdf", "hasROW", "hasUDF", "yesDMF", "hasNRFD", " hasRMF", "HasRRDF", "hasRdf", " hasRUF", "HasRDEF", "yesDOW", " hasRFD", "hasURDF", "hasSRdf", "hasRRUF", "yesDDF", "hasSRDEF", "hasURUF", "hasMRdf", "hasMRDF", " hasRRFD", "hasRRDF", "yesRDF", "hasURFD", "yesRMF", "yesRDP", "HasRRDEF", "HasRdf", " hasRRMF", " hasRRDF", "hasRFD", "hasDMF", "HasRDF", "hasRDEF", "HasRRdf", "hasDOW", "hasDDF", "hasRDP", "hasRRFD", "hasRRMF", "hasNRDF", "yesDDP"]}}
{"id1": "21488868", "id2": "4593012", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFiletoString", "encodeFile2File", "encodeString2File", "encodeFiletoStream", "encodeFiletoFile", "encodeStringToString", "encodeFileToString", "encodeFileToStream", "encodeStringToFiles", "encodeStringToFile", "encodeFile2Files", "encodeString2String", "encodeFileFromFiles", "encodeFileFromString", "encodeStringToStream", "encodeFileFromStream", "encodeString2Stream", "encodeString2Files", "encodeFileToFiles", "encodeFile2String", "encodeFile2Stream", "encodeFiletoFiles", "encodeFileFromFile"], "infile": [" infp", "inputfilename", "infp", "inputFile", "outfiles", " infiles", "Infilename", "inputfp", "inputfiles", "outfilename", "Infile", "outfp", " infilename", "InFile", "inFile", "inputfile", "Infiles", "outFile", "infiles", "infilename"], "outfile": [" outname", "OutFile", "outfolder", "infp", "newFile", "Outname", "newname", "outname", " outFile", "newfolder", "outfilename", "outfp", " outfilename", " outfolder", "Outfile", "outputfp", "Outfolder", "newfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", " outfp", "infilename"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "base", "rin", "gin", "thin", "inside", "i", "nin", "a", "image", "socket", "sin", "login", "reader", "data", "vin", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "exit", "again", "line", "cache", "o", "ex", "inner", "bin", "Out", "copy", "outer", "io", "outs", "co", "post", "sync", "on", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "source", "client", "one", "file"], "buffer": ["seed", "cache", "uffer", "limit", "padding", "input", "layer", "wave", "feed", "buf", "slice", "queue", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "len", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "fb", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "input", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "close", "connect", "check", "reader", " copy", "parse", "write", "next", "se", "raw", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "respons", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "fast", "right", "path", "open", "Success", "modified", "ceed", "primary", "first", "warning", "construct", "content", "ccess", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "error", "data", "follow", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "21224967", "id2": "12869602", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"crear": [" crea", " Creas", "generar", " Crear", "genera", "Creare", "Creas", "Crear", " creare", " Crea", " creas", " Creare", "generare", "Crea", "generas"], "result": ["match", "message", "ret", "out", "length", "feature", "mark", "ver", "date", "status", "event", "page", "success", "count", "cash", "default", "found", "record", "comment", "force", "up", "valid", "limit", "currency", "die", "counter", "number", "function", "grade", "res", "db", "Result", "score", "ure", "value", "df", "err", "response", "results", "sign", "diff", "entry", "rate", "type", "user", "error", "order"], "sql": ["fp", "sync", "session", "script", " SQL", "update", "ql", "seed", "cmd", "serv", "conn", "install", "q", "pg", "where", "dl", "comment", "statement", "up", "action", "job", "url", "base", "SQL", "log", "database", "params", "setup", "exec", "printf", "zip", "query", "sl", "string", "fn", "repl", "sq", "plan", "ssl", "join", "db", "select"], "connection": ["p", "relation", "position", "cache", "table", "client", "connected", "session", "c", "union", "config", "environment", "system", "tc", "Connection", "event", "driver", "socket", "conn", "manager", "condition", "loc", "writer", "con", "pg", "proxy", "which", "communication", "statement", "connect", "document", "error", "database", "log", "bc", "graph", "server", "function", "query", "index", "container", "cond", "lock", "engine", "BC", "collection", "Exception", "ctx", "ion", "section", "db", "context", "application"], "ps": ["p", "pre", "eps", "cs", "pt", "ss", "ups", "ppa", "ips", "po", "pse", "ds", "pos", "hs", "conn", "pps", "pg", "proxy", "PS", "vs", "gres", "cop", "pa", "ks", "pc", "os", "pe", "qs", "proc", "params", "Ps", "query", "bs", "pd", "sp", "ins", "cp", "pr", "jp", "gs", "settings", "ns", "pers", "properties", "changes", "pp", "ports", "posts", "ops"]}}
{"id1": "22977189", "id2": "18613870", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"in": ["re", "err", "ini", "image", "login", "this", "gin", "inner", "inn", "input", "In", "up", "bin", "b", "url", "read", "c", "r", "IN", "g", "again", "pass", "er", "plus", "source", "nin", "cin", "min", "ins", "is", "as", "lin", "init", "inside", "con", "ln", "isin", "data", "id", "i", "win", "reader", "n", "din", "f", "socket", "inc"], "out": ["flow", "temp", "window", "list", "page", "again", "query", "strip", "block", "name", "file", "call", "comment", "connection", "parent", "f", "editor", "s", "log", "pool", "o", "outer", "this", "point", "flush", "write", "cache", "sync", "output", "OUT", "password", "bin", "b", "conn", "r", "outs", "io", "Out", "app", "init", "server", "user", "error", "copy", "err", "prefix", "self", "inner", "at", "object", "client", "off", "ext", "data", "ex", "default", "inc", "exec", "obj", "raw", "w", "plain", "up", "key", "writer", "part", "as", "a", "word", "n"], "line": ["rule", "letter", "log", "link", "lc", "unit", "feed", "end", "content", "lf", "write", "cl", "lines", "inline", "entry", "LINE", "text", "message", "Line", "key", "column", "l", "page", "style", "string", "code", "c", "pe", "pass", "next", "row", "character", "block", "name", "word", "data", "file", "id", "cell", "char", "header", "lock", "str", "comment", "i", "sl", "value", "source", "f", "url", "lin"]}}
{"id1": "21488518", "id2": "18782385", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "label": 1, "substitutes": {"createNew": ["openOpen", "newOpen", "resourceNew", "createResource", "resourceOpen", "resourceCopy", "createCopy", "newResource", "newNew", "newCopy", "openCopy", "resourceResource", "createOpen", "openResource", "openNew"], "name": ["full", "office", "connection", "x", "missing", "ext", "ame", "data", "current", "self", "type", "non", "one", "label", "class", "base", "ix", "model", "part", "time", "size", "content", "old", "alias", "member", "e", "key", "ename", "address", "client", "comment", "style", "common", "image", "value", "anc", "large", "path", "parent", "filename", "url", "ui", "names", "Name", "n", "number", "code", "no", "default", "file", "folder", "id", "title", "prefix", "word", "search", "on", "resource", "named", "directory", "none", "string", "NAME", "end", "username"], "in": ["reader", "bin", "connection", "login", "data", "slice", "ins", "In", "inner", "size", "win", "din", "work", "IN", "plus", "ini", "buffer", "i", "source", "image", "init", "inc", "exec", "read", "raw", "pass", "thin", "up", "file", "id", "len", "src", "resource", "input", "record", "con", "diff"], "length": ["offset", "sequence", "type", "body", "Length", "timeout", "load", "ength", "time", "size", "bytes", "content", "line", "password", "buffer", "count", "padding", "limit", "path", "filename", "url", "width", "level", "number", "duration", "id", "len"], "contentType": ["ContentLength", "resourceType", " contentPath", "resourceLength", "ContentPath", "ContentType", "resourcetype", " contentLength", "contenttype", "contentPath", "Contenttype", "resourcePath", " contenttype", "contentLength"], "dest": ["prop", "trip", "cdn", "sup", "opt", "later", "tif", " destination", "cont", "destroy", "gz", "comb", "orig", "desc", "output", "conf", "txt", "img", "done", "zip", "trans", "dist", "temp", "dc", "d", "source", "parent", "config", "store", "route", "thin", "flat", "wb", "folder", "transform", "src", "Dest", "upload", "result", "target", "dir", "home", "tx", "de", "tmp"], "out": ["lock", "bin", "connection", "ext", "f", "data", "socket", "channel", "pool", "sync", "ex", "outs", "gz", "log", "copy", "page", "conn", "cache", "again", "output", "img", "zip", "cmd", "line", "writer", "err", "password", "o", "client", "flush", "OUT", "temp", "this", "buffer", "source", "image", "path", "exec", "object", "parent", "url", "view", "server", "null", "io", "file", "up", "result", "resource", "exp", "Out", "obj"], "request": ["job", "open", "ext", "get", "complete", "type", "remote", "QUEST", "reference", "quest", "wheel", "xml", "base", "req", "user", "instance", "query", "respect", "rer", "client", "external", "buffer", "call", "child", "path", "response", "object", "project", "Request", "url", "config", "transfer", "friend", "store", "route", "pe", "rate", "upload", "resource", "input", "claim", "directory", "report", "forward", "re", "access", "use"]}}
{"id1": "14047629", "id2": "9398454", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"source": ["ource", "exec", "fp", "result", "processor", "reader", "status", "project", "parse", "transfer", "load", "proxy", "proc", "path", "request", "remote", "input", "session", "target", "out", "cp", "stream", "inner", "image", "Source", "comp", "info", "connection", "class", "text", "object", "parent", "config", "ources", "loader", "buffer", "service", "resource", "content", "document", "in", "file", "server", "src", "SOURCE"], "process": ["exec", "result", "processor", "master", "share", "cess", "console", "system", "job", "project", "call", "status", "output", "use", "port", "app", "command", "progress", "proc", "worker", "path", "index", "target", "python", "machine", "session", "node", "thread", "image", "method", "pid", "class", "object", "parent", "program", "task", "pipe", "press", "the", "post", "parser", "display", "resource", "p", "copy", "document", "file", "processing", "work", "loop", "Process", "script", "open", "run"], "processStdOut": ["processStdinOut", "processSTdinOUT", "processSTdOut", "processStdOutput", "processSTdinOut", "processStdOUT", "processStdinOUT", "processStDOUT", "processStDObj", "processStdinObj", "processSttObj", "processStDOut", "processStdObj", "processStDOutput", "processSttOutput", "processSTdinObj", "processSTdOUT", "processSttOut", "processSttOUT", "processSTdObj", "processSTdinOutput", "processSTdOutput", "processStdinOutput"], "processStdIn": ["processStdinOut", "processStrdIn", "processSttin", "processStsin", "processSttInput", "processStrdIns", "processStsIn", "processStbin", "processStbIns", "processSttIN", "processStdIN", "processStrdInput", "processStrtIn", "processStbIn", "processStdInput", "processStdin", "processSttIn", "processStsInput", "processStrdin", "processStsIns", "processStbIN", "processStrtIns", "processSttOut", "processStdinIn", "processStbOut", "processStrtInput", "processStbInput", "processStdinIN", "processStdIns", "processSttIns", "processStrtin", "processStdinin"]}}
{"id1": "14783950", "id2": "9096314", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"compressWithZip": ["compressWithJar", "compressedWithJar", "compresswithSax", "compressedUsingJar", "compressInSax", "compressUsingJar", "compressedUsingSax", "compresswithJar", "compressInZip", "compressedUsingZip", "compressUsingZip", "compresswithZip", "compressUsingSax", "compressedWithZip", "compressedWithSax", "compressWithSax", "compressInJar"], "fileList": ["FileChain", "ziplist", "wordString", "fileStream", "modelList", " fileChain", "Filelist", "stringList", "modelStream", "stringChain", "zipSet", "modelEx", "FileName", "FileSet", "stringName", " fileCollection", "inputEx", "inputStream", " fileSet", "modelCollection", "fileChain", "fileEx", "inputList", " fileStream", "stringlist", "FileString", " fileString", "zipList", "fileCollection", "wordName", "fileString", " fileEx", "FileStream", "zipName", "inputCollection", " filelist", "FileList", "wordList", "fileSet", "wordStream", "filelist"], "zipFileName": ["archiveFileDir", "zipFileNames", "folderGlobalPath", "zipFullNames", "zipFilePath", "archiveDirName", "folderGlobalName", "zipPackageDir", "archiveFilePath", "zipFullname", "zipGlobalPath", "zipDirName", "folderGlobalname", "zipGlobalNames", "zipPackageName", "zipGlobalname", "folderFilePath", "zipFullPath", "folderFileName", "zipDirNames", "archiveDirPath", "archiveFileName", "zipFilename", "archiveDirDir", "zipFullName", "folderGlobalNames", "zipGlobalName", "zipPackagePath", "zipFullDir", "folderFileNames", "folderFilename", "zipFileDir", "zipDirDir", "zipDirname", "zipDirPath"], "fos": ["afaos", " fosh", "flis", "afos", "infis", "Fosh", "Fos", "foS", "Fis", "flosh", "afis", "fosh", "infaos", "afoS", "infoS", "infos", "FoS", "flos", "faos", "Faos"], "zos": ["z", "osi", "outs", "zzy", "onz", "ZA", "zar", "kos", "zip", "seconds", "bis", "zers", "spin", "chini", "es", "zon", "budget", "tz", "uz", "jobs", "zen", "zes", "os", "ses", "bag", "zl", "phi", "webkit", "bos", "zan", "dos", "zer", "iframe", "zo", "ozo", "zi", "LOS", "fits", "lins", "oses", "css", "zx", "nz", "zz", "fi", "zag", "rez", "abi", "cos", "inos", "jas", "zb", "ZI", "gz", "loop", "packs", "bes", "zik", "closure", "obb", "ros", "lol", "zy"], "iter": ["ser", "oper", "test", "ip", "chain", "ter", "upper", "itter", "enter", "parse", "finder", "el", "e", "ator", "inc", "sort", "cher", "index", "er", "former", "keep", "iz", "ir", "end", "inner", "liter", "set", "err", "next", "order", "iner", "Iterator", "ie", "i", "ite", "fer", "loc", "list", "walker", "gener", "ner", "inse", "outer", "slice", "fr", "it", "iterator", "is", "http", "file", "izer", "Iter", "coll", "inter", "f", "ener"], "fileName": ["FileType", " filePart", "FileLine", "fPart", "currentname", "localname", "localPart", "FileUrl", " filePath", "currentData", "localPath", "pageName", "filenameInfo", " fileUrl", "filename", "FileName", "currentUrl", "currentName", "fileOpen", "pagename", "fileLine", "filenamename", " fileFull", "fileData", " fileOpen", "simpleOpen", "filenameName", "fName", " fileData", " fileInfo", "fullPath", "fullOpen", "FileString", "filePart", "fileType", " fileString", "FilePath", "filenameFull", "FilePart", "fileInfo", "fLine", "fileFull", "fullName", "fileString", " filename", "FileFull", " fileLine", " fileType", "fname", "simplePath", "simpleName", "filePath", "FileInfo", "localName", "pageString", "FileData", "fileUrl", "pageType", "Filename"], "ind": ["bind", "mind", "z", "id", "inc", "Ind", "x", "index", "div", "val", "pt", "start", "length", "ded", "pend", "end", "rib", "ci", "len", "ii", "j", "i", "count", "eff", "pull", "loc", "ord", "cond", "fr", "ad", "inn", "wind", "ix", "nd", "in", "vert", "ld", "dir", "mid", "pos", "IND", "d"], "shortName": ["ShortPath", "smallName", "longName", "ShortPart", "fullLine", "smallname", "shortPart", "longPart", "smallPart", "longname", "smallPath", "shortname", "fullString", "fullname", "longPath", " shortString", "fullPath", " shortname", " shortLine", "ShortString", "fullName", "shortString", "Shortname", "shortPath", " shortPath", "longLine", "shortLine", "ShortName"], "fis": [" fiss", "fris", "cfis", "gisa", "afos", "Fos", " fisa", "Fis", "fios", "afis", "cfiss", "pis", "Fiss", "gios", "pris", "Fs", " fios", "fs", "gris", "fiss", " fs", "afiss", "cfos", "gis", "afris", "cfris", "cfs", "pisa", " fris", "pios", "fisa"], "buf": ["vec", "uf", "bc", "v", "uc", "bb", "bin", "tmp", "br", "bd", "cv", "bp", "cur", "fb", "ba", "seq", "queue", "bl", "bag", "box", "batch", "Buff", "lb", "b", "grab", "ff", "loc", "wb", "buffer", "done", "la", "bytes", "rb", "fd", "feat", "rc", "data", "pb", "bh", "bf", "lim", "cb", "buff", "bu"], "bytesRead": [" bytesSkip", "flowsLength", "bitsSkip", "secondsRead", "tesSkip", "secondsNeed", "secondsWrite", "wordsRead", "bitsRead", "secondsLength", "flowsRead", "flowsNeed", "tesWrite", "wordsWrite", "bytesSkip", " bytesUse", " bytesWrite", "bytesWrite", "bytesLength", " bytesLength", "flowsWrite", "bitsLoad", "bitsWrite", "tesLoad", "wordsUse", " bytesNeed", "bytesUse", "tesRead", " bytesLoad", "wordsLength", "bytesNeed", "bitsUse", "bytesLoad", "bitsLength"]}}
{"id1": "4118412", "id2": "19109981", "code1": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"compress": ["ompressed", "comression", "compose", "comressed", "compressor", "Compression", "comress", "suppression", "Compress", "omppose", "compression", "compressing", " comprypt", "Compressor", "comppose", "Compressing", "Comppose", "Compressed", "ompression", " compressed", " compressing", "Comprypt", "comressing", "suppressor", "suppress", "suppressed", "comressor", "comrypt", "ompress", "compressed", "comprypt"], "outputFile": ["outputDirectory", "targetDir", " outputFolder", " outputLine", "OutputDirectory", "OutputF", "targetFolder", "outputPath", "externalPath", "outputDir", "externalDirectory", "inputF", "targetPath", " outputF", "inputFolder", "outputLine", "OutputLine", "OutputFiles", "inputLine", " outputDirectory", "Outputfile", "outputFolder", "outputF", " outputfile", "outputFiles", "externalFile", "OutputDir", "OutputFile", "OutputPath", "inputDirectory", "OutputFolder", " outputDir", "inputFile", "inputDir", " outputPath", " outputFiles", "outputfile", "targetFile", "externalfile", "inputPath"], "inputFiles": ["InputFile", "inputFile", " inputfiles", "outputFiles", " inputFile", "inputfiles", "Inputfiles", "InputFiles", "outputfiles"], "log": ["job", "db", "blog", "console", "stat", "entry", "up", "key", "output", "print", "trace", "feed", "user", "bug", "write", "cli", "ex", "cache", "per", "info", "or", "http", "exp", "path", "report", "low", "io", "xml", "pool", "debug", "row", "crit", "lex", "Log", "url", "exec", "base", "model", "zip", "temp", "pe", "put", "spec", "w", "tag", "cl", "net", "l", "LOG", "og", "pro", "pot", "lock", "pl", "config"], "absPath": ["resStream", "atsAuth", "apspath", "absParent", "atsPath", "absolutepath", "httpPath", "absolutePath", "httpDir", "atspath", "respath", "resDir", "bspath", "resPath", "abAuth", "abPath", "AbsPath", "abpath", "AbsStream", "absPo", "absStream", "apiPath", "apiDir", "bsPath", "bsParent", "labpath", "absolutePo", "bsHome", "abDirectory", "absoluteParent", "labParent", "Abspath", "abTime", "absDirectory", "absoluteDirectory", "atsPo", "httppath", "atsDir", "abspath", "absDir", "labPath", "AbsDir", "abDir", "apipath", "absAuth", "absoluteDir", "apsTime", "apsAuth", "AbsDirectory", " absStream", "absHome", "atsTime", "apsPath", "labHome", "absoluteHome", "abPo", " abspath", "absTime", " absDir"], "out": ["Out", "plain", "client", "writer", "sync", "obj", "off", "output", "socket", "app", "parent", "cli", "ex", "cache", "conn", "plus", "sum", "a", "inner", "ext", "io", "conf", "at", "work", "part", "prefix", "o", "serv", "this", "exec", "base", "err", "loader", "b", "w", "net", "bin", "In", "OUT", "again", "reader", "outs", "outer", "up", "inc"], "buffer": ["pad", "timeout", "writer", "bytes", "size", "shape", "batch", "block", "queue", "transfer", "feed", "slice", "input", "reference", "page", "limit", "Buffer", "cache", "phrase", "stack", "source", "padding", "buff", "uffer", "iter", "url", "buf", "binary", "channel", "base", "data", "border", "offset", "split", "wave", "memory", "reader", "header", "seed", "read", "layer", "length"], "readBytes": ["readByte", " readPages", "ReadBlocks", "inCount", " readByte", "writeCount", "readBlocks", " readParts", "writebytes", " readbytes", "writeByte", "readbytes", "ReadCount", "writeBlocks", "readCount", "ReadPages", "inBytes", "readParts", "ReadParts", "ReadByte", " readBlocks", "inPages", " readCount", "ReadBytes", "writeParts", "inbytes", "Readbytes", "writeBytes", "readPages"], "file": ["lf", " feed", "entry", "files", "key", "queue", "object", "el", "feed", "comment", "input", "slice", " message", "route", " path", "directory", "File", "rule", " directory", "fe", "source", "child", " input", "http", "path", "fp", "word", " File", " entry", " source", "FILE", "ile", "part", "work", "line", "dir", "f", "url", "letter", "unit", "base", "model", "type", "fil", "cl", " module", "name", "l", " url", "style", " files", "string", " f", "folder", "uri", " filename", "layer", "filename"], "in": ["r", "image", "pin", "n", "inn", "gin", "isin", "stream", "i", "is", "socket", "s", "init", "cin", "input", "id", "ex", "sin", "din", "lin", "a", "inner", "nin", "con", "ini", "kin", "part", "f", "pass", "login", "data", "err", "b", "ins", "bin", "In", "l", "reader", "IN", "again", "win", "up", "ac", "inc"], "normalSize": [" normalHeight", "smallSize", "normalInfo", "normalLength", "NormalHeight", "NormalPosition", "normLen", "NormalInfo", " normalWidth", "normalsize", "NormalSize", "normalTime", "normSize", "smallPosition", "normalNumber", "originalLen", " normalsize", " normalInfo", "NormalTime", "smallInfo", "normLength", "NormalWidth", " normalLen", "normalHeight", "NormalNumber", "originalsize", "normalLen", "normTime", "normWidth", "originalSize", " normalNumber", "normalPosition", "normNumber", " normalLength", " normalPosition", "normsize", "originalLength", "smallHeight", " normalTime", "normalWidth"], "builder": ["job", "r", "writer", "creator", "worker", "block", "entry", "bug", "slave", "e", "office", "sb", "info", "result", "builders", "hub", "inner", "editor", "later", "xml", "keeper", "angler", "manager", "building", "row", "build", "iter", "f", "this", "wrapper", "loader", "b", "er", "runner", "built", "driver", "l", "processor", "bean", "utils", "reader", "parser", "bridge", "outer", "Builder", "layer"], "process": ["job", "image", "large", "p", "worker", "script", "cess", "console", "cp", "output", "object", "use", "app", "e", "cache", "run", "program", "result", "handle", "share", "path", "resource", "proc", "thread", "build", "exec", "session", "task", "pm", "status", "processing", "method", "call", "node", "processor", "project", "commit", "command", "cmp", "Process", "sp"], "minSize": ["initOffset", "MinCount", "minOffset", "MinOffset", "normalLength", "minLength", "MinSize", "minWidth", " minOffset", "MinLength", "minCount", "initWidth", "normalCount", "initSize", " minWidth", "MinWidth", " minCount", " minLength", "initCount"], "diff": ["error", "equal", "progress", " difference", "size", "pos", "def", "flow", "same", "default", "multi", "version", "bug", "between", "mix", "fail", "iff", "low", "ref", "message", "change", "dist", "part", "f", "update", "scale", "div", "missing", "err", "range", "rel", "comp", "split", "changed", "frac", "remote", "Diff", "different", "distance", "extra", "cmp", "add", "neg", "shift"], "percentage": ["advantgrade", "spage", " percentency", "spce", "advantant", " percentile", " percentgrade", " percentant", "Percentant", "spile", "Percentce", " percentce", "Percentage", "percentgrade", "percentency", "Percentile", "spacity", "Percentacity", "Percentency", "percentant", "advantage", "percentile", "percentacity", " percentacity", "Percentgrade", "advantency", "percentce"], "diffSize": ["errorCount", "errorLen", "differentSize", "differentLen", "DiffCount", "differentCount", "diffLen", " diffsize", "Diffsize", "errorSize", "diffCount", "diffsize", "DiffSize", "differentsize", "DiffLen"]}}
{"id1": "12537270", "id2": "12490144", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    private void createJCoPluginProject(IProgressMonitor monitor, String sourceFileName, String pluginName) throws CoreException, IOException {\n        monitor.subTask(MessageFormat.format(Messages.ProjectGenerator_CreatePluginTaskDescription, pluginName));\n        final Map<String, byte[]> files = readArchiveFile(sourceFileName);\n        monitor.worked(10);\n        IProject project = workspaceRoot.getProject(pluginName);\n        if (project.exists()) {\n            project.delete(true, true, new SubProgressMonitor(monitor, 5));\n        } else {\n            monitor.worked(5);\n        }\n        project.create(new SubProgressMonitor(monitor, 5));\n        project.open(new SubProgressMonitor(monitor, 5));\n        IProjectDescription description = project.getDescription();\n        description.setNatureIds(new String[] { JavaCore.NATURE_ID, PLUGIN_NATURE_ID });\n        project.setDescription(description, new SubProgressMonitor(monitor, 5));\n        IJavaProject javaProject = JavaCore.create(project);\n        IFolder binDir = project.getFolder(\"bin\");\n        IPath binPath = binDir.getFullPath();\n        javaProject.setOutputLocation(binPath, new SubProgressMonitor(monitor, 5));\n        project.getFolder(\"jni\").create(true, true, new SubProgressMonitor(monitor, 5));\n        project.getFile(\"sapjco3.jar\").create(new ByteArrayInputStream(files.get(\"sapjco3.jar\")), true, new SubProgressMonitor(monitor, 10));\n        IFolder metaInfFolder = project.getFolder(\"META-INF\");\n        metaInfFolder.create(true, true, new SubProgressMonitor(monitor, 5));\n        StringBuilder manifest = new StringBuilder();\n        manifest.append(\"Manifest-Version: 1.0\\n\");\n        manifest.append(\"Bundle-ManifestVersion: 2\\n\");\n        manifest.append(\"Bundle-Name: SAP Java Connector v3\\n\");\n        manifest.append(MessageFormat.format(\"Bundle-SymbolicName: {0}\\n\", pluginName));\n        manifest.append(\"Bundle-Version: 7.11.0\\n\");\n        manifest.append(\"Bundle-ClassPath: bin/,\\n\");\n        manifest.append(\" sapjco3.jar,\\n\");\n        manifest.append(\" jni/\\n\");\n        manifest.append(\"Bundle-Vendor: SAP AG, Walldorf (packaged using RCER)\\n\");\n        manifest.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n        manifest.append(\"Export-Package: com.sap.conn.jco,\\n\");\n        manifest.append(\" com.sap.conn.jco.ext,\\n\");\n        manifest.append(\" com.sap.conn.jco.monitor,\\n\");\n        manifest.append(\" com.sap.conn.jco.rt,\\n\");\n        manifest.append(\" com.sap.conn.jco.server\\n\");\n        manifest.append(\"Bundle-ActivationPolicy: lazy\\n\");\n        writeTextFile(monitor, manifest, metaInfFolder.getFile(\"MANIFEST.MF\"));\n        final IPath jcoPath = new Path(MessageFormat.format(\"/{0}/sapjco3.jar\", pluginName));\n        IClasspathEntry jcoEntry = JavaCore.newLibraryEntry(jcoPath, Path.EMPTY, Path.EMPTY, true);\n        final IPath jniPath = new Path(MessageFormat.format(\"/{0}/jni\", pluginName));\n        IClasspathEntry jniEntry = JavaCore.newLibraryEntry(jniPath, Path.EMPTY, Path.EMPTY, true);\n        javaProject.setRawClasspath(new IClasspathEntry[] { jcoEntry, jniEntry }, new SubProgressMonitor(monitor, 5));\n        StringBuilder buildProperties = new StringBuilder();\n        buildProperties.append(\"bin.includes = META-INF/,\\\\\\n\");\n        buildProperties.append(\"               sapjco3.jar,\\\\\\n\");\n        buildProperties.append(\"               jni/,\\\\\\n\");\n        buildProperties.append(\"               .\\n\");\n        writeTextFile(monitor, buildProperties, project.getFile(\"build.properties\"));\n        exportableBundles.add(modelManager.findModel(project));\n    }\n", "label": 0, "substitutes": {"parse": ["ize", "raw", "ract", "format", "scan", "patch", "open", "match", "load", "parser", "process", "update", "read", "apply", "split", "se", "build", "Parser", "see", "xml", "report", "pack", "ge", "eval", "arse", " analyse"], "link": ["linked", "image", "html", "URL", "base", "Link", "ink", "match", "inline", "links", "text", "message", "http", "load", "local", "add", "l", "href", "info", "page", "like", "string", "style", "route", "tag", "path", "li", "lang", "line", "type", "rel", "uri", "bug", "xml", "name", "location", "word", "loc", "ln", "data", "file", "id", "e", "lock", "connection", "msg", "source", "address"], "conn": ["enc", "err", "apt", "dr", "cmd", "nt", "config", "pt", "dc", "nc", "pc", "open", "ctrl", "rt", "Connection", "ca", "rec", "ch", "ann", "act", "c", "r", "Config", "ct", "rc", "db", "ci", "er", "p", "io", "ai", "out", "client", "cc", "socket", "ssl", "col", "ac", "con", "cn", "rn", "connect", "Conn", "mc", "n", "ctx", "cp", "connection", "loc", "cr", "pg"], "rd": ["dd", "nd", "dr", "lr", "fr", "rx", "dc", "rog", "rid", "xd", "rt", "RD", "RR", "adr", "ld", "wd", "rg", "r", "rc", "fd", "bd", "ds", "rr", "rh", "ra", "rs", "hr", "sr", "RM", "rn", "rm", "RS", "rss", "rl", "rw", "rb", "reader", "ru", "dra"], "kit": ["kin", "plugin", "base", "nt", "feed", "site", "sci", "ku", "w", "format", "et", "py", "bot", "net", "rt", "kat", "tk", "ut", "api", "b", "ui", "info", "cat", "auto", "tools", "pit", "Kit", "kt", "ct", "wt", "spec", "t", "k", "p", "io", "pot", "os", "sit", "util", "bug", "fit", "loader", "tool", "init", "h", "qt", "browser", "reader", "rot", "lib", "config", "ki", "cr", "f"], "doc": ["Doc", "body", "dec", "de", "html", "base", "in", "dr", "fr", "tt", "DOC", "config", "root", "coll", "dc", "val", "po", "open", "mm", "pc", "text", "http", "ref", "api", "info", "page", "pos", "dom", "d", "div", "out", "dir", "bug", "xml", "pub", "md", "ac", "docs", "loc", "msg", "data", "file", "document", "mc", "tx", "desc", "bc", "di", "m", "tag", "db", "f"], "url": ["image", "log", "html", "URL", "base", "resource", "lr", "www", "feed", "service", "config", "download", "Url", "hub", "http", "src", "github", "href", "l", "page", "cdn", "path", "org", "uri", "pull", "blog", "bug", "util", "xml", "ur", "name", "location", "ssl", "host", "server", "file", "ll", "gl", "sl", "rl", "el", "connection", "loc", "source", "f", "address"], "it": ["IT", "its", "in", "nt", "end", "lit", "et", "edit", "mit", "l", "info", "pit", "r", "t", "ic", "st", "split", "ait", "ci", "p", "stat", "se", "v", "ip", "sit", "ite", "iz", "init", "iti", "id", "iterator", " It", "It", "iter", "or", "you", "dit"], "elem": ["Elements", "elev", "eelement", "selement", "oelement", "selem", "pelement", "eade", "eelem", "Elem", "eler", "seject", "selements", "elements", "element", "Eject", "oelev", " nelem", "eelements", "Elev", "Eler", "peler", "eeject", "pelem", " Eler", "eject", "Element", " nelement", "oelem", " neade", " neler", " Element", "oeler", "pelev", " Elem", " Eade", "Eade"], "s": ["o", "service", "submit", "sch", "ops", "ls", "services", "details", "ns", "sync", "b", "ws", "scope", "js", "string", "set", "c", "r", "spec", "session", "g", "xs", "t", "ps", "params", "d", "ds", "p", "si", "S", "se", "sb", "v", "sv", "attr", "os", "fs", "ses", "rs", "es", "ssl", "a", "gs", "h", "server", "e", "sf", "sym", "u", "sl", "ss", "n", "sets", "ts", "m", "strings", "f", "parts"], "lnk": ["lnks", "nlky", "nnku", "olnke", "gnky", "knK", "dlk", "dlf", "linke", "knk", "lenky", "dlke", "dnf", "gnok", "nlkh", "nlok", "nnk", "lnkr", "lnf", "olnK", "nlk", "nnky", "dlok", "dnk", "nlf", "nlks", "lnke", "linf", "lenke", "gnk", "lenks", "olnkr", "lnK", "olnk", "lenku", "gnke", "lnkh", "dnke", "lnku", "dlky", "lnky", "dlkr", "nnke", "dnky", "nlke", "nlK", "knke", "linky", "olnf", "dnkr", "lnok", "knkh", "dnku", "lenk", "olnkh", "dlks"], "j": ["z", "aj", "index", "jc", "o", "fr", "kj", "syn", "jl", "ii", "ne", "key", "ch", "info", "jp", "js", "pr", "pos", "uj", "g", "ind", "li", "job", "ie", "note", "p", "m", "part", "ni", "si", "ja", "x", "ji", "dj", "y", "jj", "name", "oj", "a", "qi", "jo", "J", "adj", "im", "ij", "n", "br", "obj"], "urlLink": ["urllink", "URLLink", "strLink", " urlLine", "UrlRel", "UrlPath", "urlPath", "filePath", "strLine", "URLRel", "urlUrl", " urllink", "resourcelink", "URLPage", "resourceLink", " urlUrl", " urlPage", "urlRel", "URLUrl", "fileHub", "urlLine", "urlHub", "UrlLink", "urlPage", "strlink", "resourceConnect", "UrlUrl", " urlRel", " urlConnect", "fileUrl", "fileLink", "urlConnect", "strConnect", "resourceLine", "UrlHub", " urlPath", "UrlPage", " urlHub"], "str": ["enc", "dec", "err", "dr", "fr", "spr", "kr", "coll", "inner", "arr", "obj", "text", "l", "STR", "b", "ctr", "js", "pr", "string", "txt", "sp", "r", "pass", "t", "tr", "wr", "strip", "st", "stri", "line", "div", "elt", "name", "hr", "ext", "sr", "sta", "data", "inst", "char", "Str", "sl", "res", "n", "br", "cr", "f"], "i": ["ini", "mi", "index", "o", "in", "yi", "oi", "chi", "uli", "hi", "phi", "ii", "ix", "fi", "slice", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "abi", "li", "ci", "p", "en", "multi", "si", "ni", "xi", "bi", "v", "x", "ai", "ji", "io", "eni", "y", "ip", "uri", "init", "ori", "qi", "ti", "id", "e", "iu", "f", "u", "vi", "n", "di", "m", "I", "zi"], "skip": [" dup", "fast", "stop", " scan", "scan", "special", "active", "add", "replace", "jump", " bypass", " skipped", " exclude", "sp", " skipping", "Skip", "cmp", "loop", " duplicate", " repeat", "ips", "error", "empty", "complete", "iter", "append", "copy"]}}
{"id1": "6304373", "id2": "8788371", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrtempl", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrtemplates", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrtemFiles", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrMemplates"], "action": ["event", "error", "resource", "element", "lock", "now", "site", "act", "version", "ction", "activation", "flow", "active", "next", "ACTION", "what", "part", "type", "operation", "activity", "item", "section", "parent", "flash", "environment", "style", "plugin", "format", "test", "effect", "name", "change", "status", "controller", "function", "call", "commit", "actions", "url", "Action", "state", "step", "method", "module", "service", "api", "view"], "object": ["directory", "article", "event", "string", "address", "class", "node", "letter", "self", "resource", "lock", "ject", "now", "subject", "document", "version", "project", "system", "current", "mode", "o", "instance", "number", "host", "thread", "zone", "part", "email", "not", "target", "module", "model", "group", "none", "parent", "objects", "oid", "environment", "request", "edit", "image", "function", "full", "url", "obj", "office", "element", "service", "auto"], "numElements": [" numElem", "numEllement", "numEllem", "numelem", "numelement", " numEodes", "numEllements", "numGelement", "numGelements", "numeodes", "numGeodes", " numeodes", " numelement", "numelements", "numElem", " numelem", "numEodes", "numGelem", "numElodes", " numelements"], "req": ["base", "builder", "report", "res", "html", "ro", "mr", "usr", "util", "next", "params", "use", "load", "resp", "r", "g", "parent", "log", "verb", "msg", "gr", "ctx", "update", "conf", "err", "obj", "xml", "module"], "session": ["event", "ession", "temp", "resource", "response", "token", "lock", "http", "site", "document", "subject", "system", "result", "instance", "global", "thread", "manager", "security", "client", "sa", "cache", "use", "connection", "browser", "scope", "shared", "local", "request", "flash", "h", "context", "Session", "test", "image", "person", "ctx", "ESSION", "sp", "container", "state", "service"], "ftp": ["FTp", " ftcp", "ftcp", "FTP", "ftP", "ftc", "ttc", " ftP", "ttP", " ftc", "FTc", "FTcp", "ttp", "ttcp"], "user": ["string", "info", "path", "base", "class", "self", "ee", "username", "lock", "by", "mail", "USER", "profile", "author", "per", "User", "project", "result", "system", "account", "html", "admin", "current", "match", "record", "pass", "usr", "post", "er", "client", "type", "use", "users", "rule", "member", "facebook", "connection", "browser", "module", "other", "group", "shared", "config", "data", "used", "parent", "usa", "page", "log", "creator", "name", "e", "image", "home", "db", "person", "full", "ver", "url", "bug", "auth", "comment", "state", "error", "custom", "this", "hash", "view"], "links": ["base", "headers", "Link", "pages", "results", "mail", "posts", "html", "styles", "ids", "linked", "items", "email", "lines", "members", "images", "flash", "log", "groups", "Links", "tree", "image", "link", "details", "actions", "mails", "url", "menu"], "folders": ["anchers", "anchors", "handries", "filors", "handers", "filages", "filers", "handages", "filries", "foldages", "anchries", "handors", "foldries", "anchages", "foldors"], "folder": ["directory", "zip", "path", "letter", "address", "editor", "uri", "resource", "id", "division", "document", "filename", "slice", "project", "volume", "location", "layout", "zone", "database", "two", "picture", "email", "fold", "source", "dir", "connection", "scope", "upload", "sample", "level", "archive", "flat", "region", "ignore", "append", "device", "plugin", "home", "area", "theme", "layer", "url", "future", "Folder", "command", "network", "menu", "element", "license", "enter"], "server": ["directory", "string", "remote", "ssl", "address", "node", "resource", "uri", "username", "outer", "token", "master", "Server", "site", "filename", "version", "socket", "slave", "system", "inner", "account", "location", "host", "manager", "database", "client", "email", "type", "source", "reader", "seed", "connection", "value", "page", "device", "status", "port", "erver", "url", "ser", "localhost", "peer", "network", "scale", "engine", "service", "enter"], "login": ["string", "path", "info", "pin", "ssl", "resource", "skin", "username", "lock", "sudo", "mail", "site", "bridge", "filename", "profile", "socket", "account", "shell", "layout", "pass", "database", "picture", "email", "users", "connection", "Login", "group", "machine", "config", "journal", "log", "plugin", "name", "status", "blank", "blog", "label", "access", "url", "auth", "secret", "consumer", "cookie", "network", "basic", "service"], "password": ["directory", "string", "token", "username", "mask", "timeout", "sudo", "division", "filename", "profile", "slave", "volume", "account", "manager", "pass", "database", "pattern", " passwords", "picture", "security", "Password", "email", "PASS", "connection", "alias", "sword", "language", "device", "plugin", "name", "ass", "word", "worker", "access", "strip", "photo", "secret", "auth", "cookie", "padding", "basic", "phrase", "column"], "fileTransferFolder": ["fileTransferPath", "FileUploadfolder", "mediaTransferFolder", "fileUploadTheme", "fileImportFolder", "fileAccessFolder", "fileImportServer", "fileUploadPath", "fileTransferfolder", "mediaUploadServer", "fileTransformPath", "FileTransferPath", "fileUploadServer", "fileTransferServer", "mediaUploadfolder", "FileTransferTheme", "FileUploadFolder", "fileTransformfolder", "fileUploadfolder", "fileTransferTheme", "mediaTransferfolder", "FileUploadPath", "mediaUploadDirectory", "FileUploadTheme", "fileUploadDirectory", "fileImportfolder", "fileUploadFolder", "mediaTransferDirectory", "fileImportDirectory", "fileTransferDirectory", "fileAccessfolder", "FileTransferfolder", "fileAccessPath", "fileTransformFolder", "fileAccessTheme", "FileTransferFolder", "mediaUploadFolder", "fileTransformTheme", "mediaTransferServer"], "liveFolder": ["PreviewLocation", " liveDirectory", "PreviewFolder", "Livefolder", "PreviewDirectory", "Previewfolder", "livefolder", "LiveLocation", "LiveFolder", "LiveDirectory", " livefolder", "liveDirectory", "liveLocation", " liveLocation"], "servers": ["serServer", "servations", " serls", "serls", "servServer", "Serations", "SerServer", " serations", "Servers", "serations", "servls", " serServer", "servvers", "Serls"], "message": ["string", "path", "address", "buffer", "mess", " messages", "response", "resource", "mail", "document", "description", "manager", "content", "email", "member", "module", "application", "body", "page", "request", "flash", "Message", "log", "msg", "header", "status", "image", "array", "details", "url", "update", "summary", "error", "element", "menu"]}}
{"id1": "13852596", "id2": "8024375", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"execute": ["register", "create", " invoke", "submit", "Exec", "ute", "parse", "load", "run", "process", "code", "apply", "all", "evaluate", "handle", " perform", "start", "report", "test", "server", "transfer", "call", "exec", "install", "copy", "invoke"], "resources": ["rings", "archives", "resource", "objects", "types", "locks", "chains", "stores", "rates", "workers", "flows", "plugins", "services", "maps", "ids", "rules", "thumbnails", "events", "roots", "files", "apps", "projects", "params", "groups", "images", "Resources", "works", "writers", "relations", "ions", "cells", "issues", "items", "series", "reports", "users", "models", "features", "pages", "stars", "classes", "results", "strings", "scripts"], "i": ["ini", "j", "o", "hi", "isi", "phi", "iri", "cli", "ii", "ir", "mu", "l", "info", "ui", "we", "ami", "ri", "pi", "gi", "ic", "abi", "li", "k", "ci", "ie", "p", "ani", "multi", "xi", "si", "io", "bi", "I", "uri", "v", "ai", "eni", "wei", "ip", "is", "ori", "esi", "h", "ti", "qi", "id", "e", "iu", "vi", "f", "u", "di", "oi", "s"], "classFile": ["CLASSFile", "sessionfile", " classClass", " classfile", "ClassEntry", "classGlobal", "packFile", "ClassGlobal", "classUrl", "staticLine", "serviceLine", " classStream", "lassFile", "classDirectory", "CLASSPage", "customEntry", "objectFile", " classFilename", "sessionFactory", "ClassFilename", "CLASSFiles", "serviceFILE", "staticFILE", " classDir", "finalfile", "finalFILE", " classFILE", " classLine", "fileLine", "CLASSLoader", "fileFiles", "ruleFilename", "classPage", "ClassDir", "sessionFile", "ClassFile", "sessionEntry", "CLASSEntry", "classFILE", "ruleLine", "objectFiles", " classFactory", "staticfile", "CLASSUrl", "CLASSfile", "classLine", "classImage", "packEntry", "ruleFiles", "classStream", "ClassPage", "fileFile", "classesPath", "classPath", "objectfile", "basefile", "servicefile", "classEntry", "sessionFiles", "ClassLine", " classPage", " classPath", "lassClass", "classesfile", "filefile", " classLoader", "packfile", "ClassFactory", "classfile", "packFILE", "ClassClass", "baseFILE", "serviceFile", "customFiles", "ClassDirectory", "classesFile", "CLASSFILE", "baseFile", "CLASSDirectory", " classEntry", "Classfile", "objectDir", "finalFile", "fileImage", " classGlobal", "classFactory", "classClass", "CLASSLine", "classFiles", "classLoader", "classesFiles", "lassFiles", "ClassFiles", "ruleFile", "ClassStream", "connectionfile", "staticFile", "ClassFILE", "customFile", "connectionFile", "ClassPath", "finalUrl", "sessionFILE", " classFiles", "classFilename", "CLASSImage", "customFILE", "connectionFiles", "lassGlobal", "fileDirectory", "classDir", "ClassImage", "connectionStream", "fileLoader", "baseUrl"], "inputStream": ["outputstream", "childStream", "inputContext", "binaryStreamer", "importStreamer", "outputSw", "outputContext", "importStream", "inputstream", "binarySteam", "binaryFile", "InputSteam", "InputFile", "importSteam", "InputSw", "InputStreamer", "uploadStream", "outputSteam", "childReader", "inputSw", "initstream", "outputReader", "initStream", "initSteam", " inputSteam", "rawSteam", "uploadstream", "activeSteam", "inputFile", "rawStreamer", "inputSteam", " inputFile", " inputReader", "activestream", "rawStream", "importstream", "activeStream", "inputStreamer", " inputContext", " inputStreamer", "inputReader", "InputStream", "uploadSw", "childstream", "outputStreamer", "initStreamer", "uploadFile", " inputstream", "childContext", "rawFile", "Inputstream", "outputFile", "activeStreamer", "binaryStream"], "reader": ["re", "right", "dr", "resource", "draft", "system", "rx", "stream", "rer", "inner", "arser", "owner", "input", "entry", "worker", "http", "parser", "ler", "reading", "rar", "key", "sync", "ger", "copy", "read", "driver", "builder", "ri", "buffer", "rc", "oder", "reflect", "handler", "er", "writers", "author", "io", "rr", "row", "director", "layer", "client", "ner", "context", "manager", "riter", "loader", "report", "Writer", "request", "wrapper", "server", "war", "seed", "Reader", "per", "shared", "keeper", "iter", "or", "source", "book", "ee", "editor"], "oldSize": ["OldName", "OldLength", "prevSize", "prevName", "prevLength", " oldSc", "oldLength", "oldName", "OldSize", " oldName", "oldSc", " oldLength", "prevSc", "OldSc"], "writer": ["writing", "her", "written", "index", "draft", "resource", "service", "child", "walker", "inner", "dc", "w", "format", "write", "player", "worker", "parser", "ler", "widget", "wer", "object", "builder", "driver", "engine", "read", "string", "r", "element", "creator", "buffer", "wr", "token", "oder", "handler", "er", "writers", "author", "winner", "io", "wire", "row", "director", "ner", "manager", "riter", "Writer", "loader", "report", "word", "wrapper", "data", "war", "document", "e", "Reader", "rw", "writ", "iter", "maker", "ee", "editor"], "b": ["base", "br", "eb", "ba", "w", "l", "bin", "bb", "object", "null", "c", "r", "buffer", "g", "d", "fb", "k", "be", "bd", "p", "boot", "db", "lb", "B", "orb", "pb", "bar", "a", "h", "binary", "ob", "e", "emb", "u", "abc", "rb", "m", "f", "ab"], "outputStream": ["outputstream", "OutputSteam", " outputSteam", "dataSteam", "inputView", "outputView", "OutputStream", "inputstream", "protectedstream", "protectedStreamer", "outputContainer", "outstream", "dataStreamer", " outputContainer", "outputSteam", " outputStreamer", "outStreamer", "inputSteam", "outSteam", "outStream", "Outputstream", "inputStreamer", "OutputView", "inputContainer", " outputstream", "outputStreamer", " outputView", "dataStream", "dataContainer", "OutputStreamer", "protectedStream", "protectedSteam"], "injectedClasses": ["injectedClasss", "injectedclassies", "injectedClassies", "injectedWrities", "injectionClassies", "injectedclasses", "injectedclasss", "injectionclasses", "injectedClassites", "injectedProjects", "injectionclassites", "injectionclassies", "injectionClassites", "injectionclasss", "injectedWritites", "injectedWrites", "injectedProjectites", "injectionClasss", "injectedProjecties", "injectedclassites", "injectedWrits", "injectionClasses", "injectedProjectes"], "newSize": [" newLength", "newFontSize", "NewLength", " newStorage", "newLength", "finalSize", "newStorage", "NewStorage", "NewFontSize", "finalStorage", "finalLength", "finalFontSize", " newFontSize", "NewSize"]}}
{"id1": "3252116", "id2": "3187685", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMAC3", "getMAC512", "getMD512", " getMD3", " getMD4", "getMD4", " getSHA3", "getMAC5", "getMP5", " getSHA4", " getSHA512", "getMD3", "getMP512", " getSHA5", " getMD512", "getSHA512", "getSHA5", "getMP4", "getMP3", "getSHA4", "getSHA3", "getMAC4"], "source": ["body", "base", "service", "resource", "SOURCE", "this", "stream", "Source", "content", "input", "target", "src", "text", "slice", "output", "password", "object", "string", "code", "sp", "from", "buffer", "ource", "result", "uri", "dest", "fp", "secret", "data", "file", "document", "e", "sl", "security", "connection", "config", "parent", "f", "url"], "s": ["its", "ops", "ls", "services", "ns", "ends", "als", "b", "bytes", "js", "ws", "string", "r", "g", "ps", "t", "rows", "d", "p", "ds", "si", "S", "os", "sb", "sg", "series", "fs", "ins", "is", "ses", "rs", "es", "bis", "ssl", "gs", "ings", "h", "e", "sym", "ss", "sl", "results", "n", "sets", "ts", "m", "strings", "f"], "hexDigits": ["hexdigitives", "hexdigings", " hexDigings", "tempSignites", "hashFormits", "hexdigats", "hexSignings", "hexDigats", "hexSignals", "tempDigals", "hexdigases", "hexSignitives", "hexdigits", " hexDigases", "hashDigists", "hexEdites", "hexdigites", "tempSignists", "tempDigits", "hexEdits", "hexEdals", "hexFormats", "hexDigings", "hexFormitives", "hexdigit", "hexSignits", "hexdigists", "hexFormists", "hexSignases", "tempDigites", "hexSignats", "hexDigites", "tempSignits", "hexdigals", "hexEdists", "hexDigit", "hexDigases", "tempDigists", "hexSignit", "hashDigits", "hexSignites", "hexFormits", "hexDigals", "tempSignals", "hashFormists", "hexDigists", "hashDigitives", " hexDigit", "hexDigitives", "hashDigats", "hexSignists", "hashFormitives", "hashFormats"], "md": ["dd", "nm", "mi", "sha", "mail", "cmd", "meta", "am", "dc", "dig", "amd", "ma", "um", " MD", "metadata", "hd", "mm", "mad", "mu", "cd", "wd", "mp", "vd", "mand", "bf", "bd", "pm", "df", "sm", "mg", "mac", "mt", "cm", "MD", "pd", "mag", "rm", "dm", "mc", "em", "mb", "di", "m", "rpm", "f"], "tmp": ["np", "base", "temp", "storage", "config", "pre", "area", "api", "now", "cb", "mp", "sup", "extra", "pad", "bp", "txt", "array", " temp", "sp", "buf", "buff", "pp", "params", "buffer", "cpp", "wp", "fb", "p", "cmp", "pointer", "v", "dest", "proc", "img", "bt", "app", "test", "ppo", "data", "seed", "append", "stuff", "rb", "meta", "obj"], "str": ["enc", "err", "dec", "unit", "j", "dr", "fr", "temp", "hex", "inner", "arr", "cur", "exp", "text", "sec", "exec", " substr", "STR", "ctr", "pr", "style", "string", "code", "pos", "sp", "txt", "r", "spec", "tr", "st", "stri", "dict", "doc", "div", "part", "v", "cs", "hr", "sr", "data", "char", "Str", "ss", "sl", "iter", "br", " sp", "cr", "obj"], "k": ["ek", "j", "o", "q", "ak", "unk", "ku", "sk", "w", "kid", "kat", "key", "b", "ch", "kk", "c", "g", "d", "ok", "kick", "ck", "p", "work", "v", "x", "y", "kw", "mk", "K", "ko", "dk", "id", "e", "u", "n", "ks", "ki", "f"], "i": ["z", "ini", "j", "index", "in", "chi", "oi", "hi", "phi", "ii", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "t", "abi", "li", "d", "ci", "p", "shift", "multi", "si", "io", "xi", "bi", "uri", "v", "x", "ai", "it", "ji", "y", "ip", "a", "ti", "qi", "e", "iu", "u", "f", "n", "di", "m", "I"], "byte0": ["byte2", " byte5", "word5", "pixel0", "word0", "number00", " byte6", "pixelk", "byte6", "byte1", "word1", "numberk", " byte00", " byte1", "letter00", " byte2", "letterk", "byte5", "pixel5", "number2", "number6", "pixel00", "letter2", "pixel6", "word2", "letter0", "number0", "number1", "bytek", "number5", "pixel2", "byte00"]}}
{"id1": "20247400", "id2": "1798720", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "label": 1, "substitutes": {"in": ["In", "pass", "token", "again", "n", "c", "IN", "din", "inner", "bin", "input", "con", "this", "ins", "inn", "p", "l", "part", "isin", "s", "win", "connection", "gin", "config", "f", "i", "nin", "a", "image", "socket", "h", "login", "reader", "diff", "data", "r", "b", "inc", "parent", "stream", "client", "source"], "out": ["temp", "group", "window", "line", "again", "cache", "channel", "word", "ex", "o", "call", "exp", "str", "comment", "inner", "Out", "msg", "log", "outer", "io", "list", "sys", "user", "conn", "err", "print", "up", "connection", "w", "prefix", "exec", "server", "pool", "dump", "i", "off", "image", "socket", "writer", "page", "v", "ext", "output", "error", "write", "obj", "OUT", "r", "debug", "style", "inc", "lock", "source", "client", "console", "name", "file", "flow"], "buffer": ["slave", "window", "channel", "cache", "context", "uffer", "limit", "bin", "pause", "input", "abi", "layer", "wave", "feed", "buf", "queue", "slice", "pad", "length", "header", "count", "batch", "document", "base", "server", "config", "size", "loader", "read", "Buffer", "f", "iter", "bar", "writer", "border", "transfer", "result", "reference", "output", "reader", "data", "null", "b", "fb", "buff", "flush", "offset", "binary", "source", "flow"]}}
{"id1": "13757855", "id2": "22993368", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"process": ["call", "create", "output", "parse", "path", "load", "processing", "update", "construct", "view", "processor", "project", "build", "evaluate", "resource", "transform", "proc", "code", "exec", "Process", "submit", "request", "cess", "handle", "run"], "tpl": [" tplates", " tper", "atplug", "qtcp", "tplate", "tcp", "itpl", "tbl", "tper", "Tper", "pPL", "stpp", "Tplates", "tcl", "ttemplate", "qtfc", "tsl", "qtple", " tcl", "tfc", "qtyl", " tfc", "Tpp", "Tplate", "stpl", "qtpl", "Tpl", "itplate", "tplates", "atplate", "ppl", "lple", " tbl", "Tple", "templates", "atml", "templ", "latcp", "itPL", "fplate", " tple", "temPL", "Tcl", "stplate", " tPL", "Tipl", " tsl", "itplates", "tmpl", "lper", "lplate", " tplug", "Tbl", "tml", "tmyl", " ttemplate", "qtbl", "TPL", "pipl", " tml", "psl", "latyl", "lml", "fpl", "pcl", "lPL", "tpp", "temtemplate", "tmcp", " tpp", "tplug", "latpl", "tPL", "lpl", "Tsl", " tplate", "tyl", "Ttemplate", "Tml", "Tfc", "latple", "atpl", "lcl", "stPL", "tmple", "fml", " tipl", "tipl", "fplug", "tple"], "model": ["message", "result", "media", "copy", "json", "language", "config", "param", "command", "project", "Model", "data", "m", "module", "location", "where", "node", "document", "log", "graph", "params", "conf", "body", "models", "xml", "doc"], "packageName": ["PackageName", "groupUrl", "PackageNames", "packageInfo", "projectKey", "contextName", "groupname", "projectname", "modulename", "projectName", "packageUrl", "contextInfo", "contextname", "moduleName", "moduleUrl", "contextNames", " packageNames", "packageNames", " packagename", " packageInfo", "moduleKey", "groupName", "groupKey", "packageKey", "packagename", "projectUrl", "PackageInfo", "Packagename"], "outFileName": ["OutFileName", "inDirEnd", "outfileOnce", " outDirLine", "outFilenameMode", "outFilenamePath", "outFullname", "outDirEnd", "outFileInfo", "outFileOnce", "outfileEnd", "outDirLine", "difffileName", "difffileTime", "outFullTime", " outDirPath", "outStreamInfo", "outStreamType", "outBufferName", "OUTBufferName", "outDirname", "OUTFileMode", "inDirCopy", "diffFileName", "inDirPath", "outFullInfo", " outFilePath", "OUTFileNames", " outFullType", "OUTBufferNames", "outFullPath", "outBufferHalf", "OutFilename", "OUTFileName", " outFileType", "outfileName", " outFullName", "outFileMode", "outBufferNames", "outfileHalf", "outFileNames", "outFilenameCopy", "outLineTime", "outFileTime", "outFilesTime", "diffFileTime", "outBufferMode", "outFilenameEnd", "outRuleName", "outLineInfo", "outRuleInfo", "outFullNames", " outFileLine", "OutDirLine", "outfileCopy", "outFilename", "outLinename", "outfileNames", "inFilePath", "outStreamName", "OutDirNames", " outDirName", "outFilesName", "OutFileNames", "outDirName", "OUTBufferHalf", "difffileOnce", "outFileType", "outFilenameHalf", "difffileInfo", "OUTFileHalf", "outLineLine", "outFullName", "diffFileInfo", "outFilenameName", "outRuleType", "outFileCopy", "outFileHalf", "outLineNames", "OutFileLine", "outfileInfo", "diffFileOnce", "outfilePath", " outDirTime", "outDirInfo", "OUTBufferMode", "outFilesPath", "outDirTime", "OutDirName", "outFileEnd", " outFileTime", "outLineOnce", "outDirCopy", "outfileMode", " outFullInfo", "outLineName", "outFilesLine", "inFileEnd", "OutDirname", "outFullType", "inDirName", "outDirPath", "inFileCopy", "outDirOnce", "outDirNames", "outFilePath", " outFileInfo", "outFileLine", "inFileName", "outFilenameNames", "outfileTime", "outFullLine"], "xsltParam": ["xldMode", "xslpParam", "xsltVal", "xslicVal", "xslicparam", "xldparam", "xsldparam", "xsldVal", "xslpVal", "xltMode", "xslicParam", "xsltparam", "xltVal", "xslicMode", "xslpMode", "xldParam", "xsltMode", "xsldParam", "xslpparam", "xsldMode", "xltParam", "xldVal", "xltparam"], "artifact": ["ARTifest", "Arturation", "aratfact", "ARTifacts", "aratifacts", " artribution", " arturation", "Artifact", "advertifacts", "Artfact", "artfact", " artifacts", "aratifest", "aratifact", "advertribution", "Artifest", "arturation", "advertifact", "artifacts", "artifest", "ARTfact", "ARTifact", "Artifacts", "Artribution", "artribution", "adverturation"], "destinationPath": ["distinatorKey", "destiationLog", "DestinatingPoint", "destinationAuth", "destinateDir", "datinatePath", "destinatorLocation", "restificationLocation", "destificationPoint", "constinationWidth", "constinationPath", "destinationString", "distinationFile", "desturationHandler", " destificationLog", "destificationPart", "destributionDir", "destificationName", "DestinationText", "tempinatedPath", "distinationCase", "destinatingLocation", "DestinationPart", "datinateLocation", "destationTime", "tempinationDir", "distributionDir", "restinationpath", "destinationLocation", "desticationName", "constinatorDir", "desticationFile", "destinatedPath", "DestinationName", "DestificationPath", "destinateLocation", "destinatorStep", "destiationDir", "destinateTime", "restinationString", "tempinationPath", "destinatorFile", "destinatedDir", "tempinationpath", "destinationsPath", "destplingAuth", "destplingPath", "tempinationHalf", "destinatedPoint", "combinatorPath", "destcreationUrl", "destinatePath", "tempinatedpath", "destributionName", "destplingDir", "destinatorKey", "destignmentPath", "destinationName", "constinationsName", "destinationFile", "destinatedFile", "destensionPoint", "destificationpath", "restinatorPath", "destinationHandler", "constinatorContext", "restinationPoint", "destinatingpath", "distinatorPath", "DestinationPath", "desticationKey", "desticationStep", "destplingWidth", "combinatorName", "distinationpath", "constinationName", "destinationTime", "destinatingName", "destinatingText", "restinatorPoint", "datinationLocation", "distinationName", "constinatorUrl", "destinationPart", "destributionCase", "destinatorPath", " destificationDir", "destinationHalf", "destinationDir", "destinationsPoint", "destinatingPoint", "distinatorStep", "DestinatingText", "restificationPoint", "constinationPoint", "destinationKey", "distinatorName", "destationPath", "destinatorCase", "destificationPath", "destificationLog", "destplingUrl", "distinationCry", "combinationHandler", "destinationpath", "destinatePoint", "distinatorCase", "desticationPart", "destinatorString", "DestinatingName", "destinatorContext", "destinatedHalf", "destinatePart", "restinatorString", "destinationCase", "destinatorName", "destinerContext", "destinateHandler", "destiationPath", "combinationPath", "destificationDir", "destributionPath", "restificationpath", "constinationpath", "destinatorHandler", "DestinationPoint", "distinationDir", "destensionPath", "destiningPoint", "combinatorpath", "destinationStep", "destinateString", "destinerpath", "constinationsPath", "distributionPath", "distinationStep", "destinatorHalf", "destationLocation", " destificationAuth", "constinationDir", "destributionpath", "desturationName", "constinatorPath", "destcreationPath", "destiningPath", "DestinatingPath", "destensionText", "destinateText", "constinatorWidth", "destinatorPoint", "destiningpath", "desturationpath", "destinerPath", "combinationName", "destinatedCase", "destinerDir", "destinatedString", "destinatorCry", "destensionName", "destiningContext", "DestificationPart", "destinatorTime", "destignmentCry", "destinationCry", "destationpath", "distinationKey", "distinatorFile", "constinatorpath", "destinationText", " destinationLog", "datinateTime", "destinationPoint", "restinationHalf", "constinationspath", "restinationLocation", "destinationWidth", "datinationTime", "destplingLog", "desturationPath", "destinatorpath", "datinatepath", "distinationPath", "datinationpath", "destinatedpath", "constinationsPoint", "destinatorDir", "destinatingPath", "destributionCry", "destiationAuth", "destiningDir", "destificationAuth", "combinatorHandler", "combinationpath", "destignmentCase", "destinationContext", "destinatorUrl", "distributionCase", "destinatorWidth", "destinateHalf", "constinationContext", "desticationPath", "destcreationWidth", "DestificationName", "tempinatedHalf", "destinationsName", "destiningName", "tempinatedDir", "restinationPath", " destificationPath", "restificationPath", "destificationLocation", " destinationAuth", "destinatedKey", "destinationUrl", "datinationPath", "destignmentName", "destinationLog", "distinatorCry", "destinatepath", "restinatorHalf", "distributionpath", " destinationDir", "destinatedStep", "constinationUrl", "destinateName", "destinationspath"], "in": ["x", "source", "cache", "c", "config", "ex", "i", "input", "image", "IN", "data", "con", "n", "bin", "name", "min", "ins", "connection", "In", "inc", "r", "t", "reader", "din", "d", "doc"], "out": ["source", "group", "result", "copy", "cache", "output", "str", "client", "path", "session", "point", "with", "store", "page", "state", "w", "ex", "all", "manager", "OUT", "dump", "line", "conn", "writer", "sys", "comment", "ne", "io", "up", "log", "name", "outer", "server", "gen", "obj", "post", "msg", "exec", "pool", "index", "list", "string", "connection", "free", "lock", "prefix", "Out", "write", "full", "outs", "again", "Output", "file", "lib", "temp", "version", "part", "err", "cli", "key", "o", "user", "parent", "bin", "error", "doc"], "root": ["history", " roots", "cache", "json", "path", "instance", "cat", "options", "tree", "meta", "xml", "resources", "loader", "module", "format", "Root", "transform", "values", "url", "graph", "params", "modules", "query", "index", "_", "collection", "include", "r", "results", "id", "parent", "node", "pattern", "roots", " result"]}}
{"id1": "3375724", "id2": "9687813", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" importarEmissoresDosTitulasf", " importarEmissoresDosTitulasFe", " importarEmissoresDosTitulosf", " importarEmissoresDosTitULosPF", " importarEmissoresDosTitularF", " importarEmissoresDosTitulosPF", " importarEmissoresDosTituloFe", " importarEmissoresDosTituloF", " importarEmissoresDosTitularFe", " importarEmissoresDosTitulasF", " importarEmissoresDosTitULoFe", " importarEmissoresDosTitularf", " importarEmissoresDosTitulosF", " importarEmissoresDosTitULoPF", " importarEmissoresDosTitularPF", " importarEmissoresDosTitulosFe", " importarEmissoresDosTituloPF", " importarEmissoresDosTitULosF", " importarEmissoresDosTitulof", " importarEmissoresDosTitULoF", " importarEmissoresDosTitULosf", " importarEmissoresDosTitULof", " importarEmissoresDosTitulasPF", " importarEmissoresDosTitULosFe"], "pArquivoTXT": ["pArquivoDXT", "pArquivaTxt", "pArquivoFEMP", "pArquivoTTP", "pArquivoFxt", "pArquivDBT", "pArquivDXT", "pArquivoOTEMP", "pArquivaTEXT", "pArquivoBxt", "pArquivoLBT", "pArquivaFEXT", "pArquivoBXT", "pArquivaFTP", "pArquivoBEMP", "pArquivoTLS", "pArquivoTEMP", "pArquivTLS", "pArquivaFxt", "pArquivoLXT", "pArquivoQxt", "pArquivoQXT", "pArquivaFEMP", "pArquivoOTTP", "pArquivoFTP", "pArquivoDEXT", "pArquivoLxt", "pArquivoOTxt", "pArquivoBLS", "pArquivoTBT", "pArquivDxt", "pArquivaTEMP", "pArquivoLLS", "pArquivaTTP", "pArquivoQEXT", "pArquivoDLS", "pArquivoFEXT", "pArquivoQBT", "pArquivoDBT", "pArquivoTxt", "pArquivoFBT", "pArquivoFXT", "pArquivaTBT", "pArquivoTEXT", "pArquivaFBT", "pArquivoDxt", "pArquivTXT", "pArquivoBTP", "pArquivTBT", "pArquivDLS", "pArquivTxt", "pArquivoOTXT", "pArquivaFXT", "pArquivaTXT", "pArquivoBBT"], "pAndamento": [" pOrementO", " pOrementos", " pAndmentO", " pOrementoo", " pAndemento", " pAndmentos", " pAndamentO", " pAndementO", " pAndentiono", " pAndementoo", " pAndamentos", " pOramentO", " pAndentionos", " pAndmentoo", " pAndementos", " pOremento", " pAndamentoo", " pOramento", " pAndmento", " pOramentoo", " pAndentionoo", " pAndentionO", " pOramentos"], "numeroDoRegistro": ["numeroDoRegestro", "numeroDoregistro", "numeroDoRegiftorno", "numeroDoRegestrano", "numeroDoRegpectros", "numeroDoregestros", "numeroDoRegiftros", "numeroDoRegestorno", "numeroDoRegpectrano", "numeroDoregistros", "numeroDoregestorno", "numeroDoRegiftrano", "numeroDoregistrano", "numeroDoRegpectro", "numeroDoRegestros", "numeroDoRegiftro", "numeroDoRegpectorno", "numeroDoregistorno", "numeroDoregestro", "numeroDoRegistrano", "numeroDoRegistorno", "numeroDoRegistros", "numeroDoregestrano"], "in": ["ini", "err", "kin", " out", "login", "config", "inn", "scan", "cl", "with", "In", "slice", "l", "b", "bin", "c", " IN", "r", "IN", "session", "g", "again", "t", "query", "nin", "part", "conf", "cin", "out", "ins", "is", "ner", "con", "ln", "span", "rin", "data", "ex", "reader", "i", "n", "connection", "m", "inc", "f", "url", "s"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicioDestaco", "stmtLimpezaInicialDestania", "stmtLimpezaInicioCombario", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialCombination", "stmtLimpezaInicialDestario", "stmtLimpezaInicialDesino", "stmtLimpezaInicioDestario", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialCombania", "stmtLimpezaInicialDesaco", "stmtLimpezaInicioDestao", "stmtLimpezaInicialdestaco", "stmtLimpezaInicioCombaco", "stmtLimpezaInicialDestination", "stmtLimpezaInicialCombino", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialDesao", "stmtLimpezaInicioCombao", "stmtLimpezaInicialCombario", "stmtLimpezaInicialdestao", "stmtLimpezaInicioDestino", "stmtLimpezaInicialCombao", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialDestaco", "stmtLimpezaInicialDestao", "stmtLimpezaIniciaDestania", "stmtLimpezaInicialDesario", "stmtLimpezaInicialdestania", "stmtLimpezaInicialdestino", "stmtLimpezaInicialdestario", "stmtLimpezaInicialdestination", "stmtLimpezaInicioCombino"], "sql": ["err", "body", "log", "sol", "cmd", "setup", "html", "nl", "lua", "json", "ls", "SQL", "details", "zip", "http", "filename", "software", "liquid", "l", "shell", "csv", "string", "spec", " SQL", "params", "sn", "query", "kl", "select", "stat", "result", "ql", "sg", "sv", "sb", "eps", "sq", "expr", "where", "QL", "util", "statement", "ssl", "socket", "term", "sys", "search", "data", "id", "fn", "seed", "layout", "sf", "description", "sl", "comment", "rl", "el", "dl", "msg", "acl", "db", "install", "url", "s"], "stmtDestino": ["stmtCampino", "stmDestino", "stmtDistinos", "stmtDestinos", "stmCampaco", "stmdDestin", "stmtdestin", "stmCampania", "stmtDistino", "stmCampino", "stmdDestorno", "stmtDistaco", "stmtdestaco", "stmdDestino", "stmtDestin", "stmtDestaco", "stmCamporno", "stmtDestania", "stmtDestorno", "stmtDistorno", "stmtCampania", "stmdDestinos", "stmtCamporno", "stmtdestania", "stmtdestino", "stmDestaco", "stmDestania", "stmtDistin", "stmtdestinos", "stmtDistania", "stmDestorno", "stmtCampaco", "stmtdestorno"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABOCALSHOU", "TAMANHO_DO_CABECALCO", "TAMANHO_DO_CABECALSHOU", "TAMANHO_DO_CABECULHOU", "TAMANHO_DO_CABECALHOU", "TAMANHO_DO_CABOCALHO", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECALSCO", "TAMANHO_DO_CABOCALCO", "TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABISCALHO", "TAMANHO_DO_CABECALLHOU", "TAMANHO_DO_CABISCALLHO", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABISCALLHI", "TAMANHO_DO_CABOCALSCO", "TAMANHO_DO_CABOCALSHO", "TAMANHO_DO_CABECALLCO", "TAMANHO_DO_CABECALSHO", "TAMANHO_DO_CABECARHOU", "TAMANHO_DO_CABOCALHOU", "TAMANHO_DO_CABISCALHI", "TAMANHO_DO_CABISCALLHOU", "TAMANHO_DO_CABISCALHOU", "TAMANHO_DO_CABECARCO", "TAMANHO_DO_CABECALSHI"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPE__DO", "TAMANHO_DO_RODAPJDO", "TAMANHO_DO_RODAPEECPO", "TAMANHO_DO_RODAPE_TO", "TAMANHO_DO_RODAPE__do", "TAMANHO_DO_RODAPJdo", "TAMANHO_DO_RODAP_TO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAPEJPO", "TAMANHO_DO_RODAPEJdo", "TAMANHO_DO_RODAPEECDO", "TAMANHO_DO_RODAPEJTO", "TAMANHO_DO_RODAPE_PO", "TAMANHO_DO_RODAP_PO", "TAMANHO_DO_RODAPEECDo", "TAMANHO_DO_RODAPJPO", "TAMANHO_DO_RODAPJDo", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPE__TO", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE__Do", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPJTO"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADANDOJ", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADADOPS_", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADosAD", "TAMANHO_DOS_METADADIESJ", "TAMANHO_DOS_METADADOS___", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADADOAD", "TAMANHO_DOS_METADADOSJ", "TAMANHO_DOS_METADANDOAD", "TAMANHO_DOS_METADANDOS___", "TAMANHO_DOS_METADADOTSAD", "TAMANHO_DOS_METADANDO_", "TAMANHO_DOS_METADADOPS___", "TAMANHO_DOS_METADADIES_", "TAMANHO_DOS_METADADOJ", "TAMANHO_DOS_METADANDOS_", "TAMANHO_DOS_METADADOSAD", "TAMANHO_DOS_METADANDO___", "TAMANHO_DOS_METADADOTS_", "TAMANHO_DOS_METADADOPSJ", "TAMANHO_DOS_METADADO___", "TAMANHO_DOS_METADADIES___", "TAMANHO_DOS_METADANDOSJ", "TAMANHO_DOS_METADANDOSAD"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_PORPRECIES", "TAMANHO_MEDIO_PORPREGES", "TAMANHO_MEDIO_POR_RECAS", "TAMANHO_MEDIO_PORPREGIC", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_PORPRECAS", "TAMANHO_MEDIO_POR_GAS", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_PORPREGAS", "TAMANHO_MEDIO_PORPREGIT", "TAMANHO_MEDIO_POR_REGIT", "TAMANHO_MEDIO_PORPRegES", "TAMANHO_MEDIO_POR_GIES", "TAMANHO_MEDIO_POR_REGAS", "TAMANHO_MEDIO_PORPRegIT", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_POR_EGIS", "TAMANHO_MEDIO_POR_GIC", "TAMANHO_MEDIO_POR_GIS", "TAMANHO_MEDIO_POR_RegIT", "TAMANHO_MEDIO_POR_EGES", "TAMANHO_MEDIO_PORPRegIS", "TAMANHO_MEDIO_POR_EGIES", "TAMANHO_MEDIO_POR_REGIES", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_PORPRECIC", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_PORPREGIES", "TAMANHO_MEDIO_PORPRegIES", "TAMANHO_MEDIO_POR_EGIT", "TAMANHO_MEDIO_POR_RECIES", "TAMANHO_MEDIO_PORPRECIS", "TAMANHO_MEDIO_POR_RegAS", "TAMANHO_MEDIO_PORPREGIS", "TAMANHO_MEDIO_POR_RegIES"], "tamanhoDosArquivos": ["tamanhoDosArquivalo", "tamanhoDosArQUivlos", "tamanhoDosArquervlos", "tamanhoDosArqIVos", "tamanhoDosArquIVoes", "tamanhoDosArQUivo", "tamanhoDosArquievo", "tamanhoDosArqivos", "tamanhoDosArQUervo", "tamanhoDosArquervo", "tamanhoDosArquievOs", "tamanhoDosArquivo", "tamanhoDosArQUervOs", "tamanhoDosArquIVo", "tamanhoDosArquIVos", "tamanhoDosArqIVlos", "tamanhoDosArquivalos", "tamanhoDosArQUervlos", "tamanhoDosArquervos", "tamanhoDosArquivOs", "tamanhoDosArquievlos", "tamanhoDosArquivallos", "tamanhoDosArquievos", "tamanhoDosArquIVlos", "tamanhoDosArqIVoes", "tamanhoDosArquivlos", "tamanhoDosArQUervos", "tamanhoDosArqIVo", "tamanhoDosArQUivos", "tamanhoDosArqivo", "tamanhoDosArquervoes", "tamanhoDosArQUivOs", "tamanhoDosArquivoes", "tamanhoDosArqivoes", "tamanhoDosArquervOs", "tamanhoDosArquivaloes", "tamanhoDosArqivlos", "tamanhoDosArquIVOs"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimante", "quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstimmante", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstipante", "quantidadeDeRegistrosEstivante", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstivado"], "registro": [" registulo", "regestro", " regestro", " regestros", "registulo", "regastro", "regastration", " registros", " registration", "registration", " regestulo", " regestration", "regestros", "regestration", "registros", "regustros", "regustration", "regastulo", "regestulo", "regustro", "regustulo", "regastros"], "campos": [" campas", "CampOS", "campOS", " casos", "campas", "Campos", " caso", " casOS", "Campo", " campo", "campo", " casas", "Campas", " campOS"]}}
{"id1": "13946197", "id2": "14691829", "code1": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 1, "substitutes": {"transformByMD5": [" transformWithM3", " transformByMD4", " transformWithM5", " transformWithMD3", " transformByM4", " transformWithMD4", " transformByMSecret", " transformByMC3", " transformByMC4", " transformByMD3", " transformWithMDSecret", " transformByM5", " transformBymd4", " transformBymdSecret", " transformWithMD5", " transformWithMSecret", " transformByMC5", " transformByM3", " transformWithM4", " transformByMCSecret", " transformBymd3", " transformByMDSecret", " transformBymd5"], "password": ["resource", "attribute", "token", "username", "sword", "string", "channel", "word", "secret", "Password", "PASS", "wallet", "path", "params", " passwords", "auth", "database", "email", "wd", "user", "object", "address", "p", " Password", "connection", "device", "prefix", "phrase", "config", "filename", "hash", "login", "data", "account", "message", "pattern", "source", "crypt", "text", "name", "padding"], "md5": ["mand2", "mdql", "mand5", "MD2", "amd512", "MD5", "material5", " MD3", "MDql", "MDfive", "mand55", " mddown", "mdok", "MDok", "mddown", "md2", " MD45", "mandse", "materialfive", "MDdown", " mdok", "material2", "md4", " md4", "mdse", " md2", " MD5", " mdse", "amd3", " mdfive", "mand45", " MDdown", " MD4", "mand4", " mdql", "md55", " MDok", " MD55", "md512", "mand3", " md512", "MDse", "MD512", "MD3", "amd2", " md55", "md3", "md45", "mdfive", "materialql", "amd5", " md3", " md45"], "output": ["property", "resource", "exit", "full", "string", "word", "o", "secret", "character", "response", "input", "outer", "display", "sequence", "queue", "letter", "address", "unit", "generation", "document", "out", "prefix", "config", "complete", "array", "foo", "hidden", "image", "format", "dot", "page", "result", "data", "write", "written", "style", "beta", "target", "message", "offset", "buffer", "generated", "text", "console", "reason", "width", "Output", "reference"], "bufferPass": ["bufferLink", "bufLink", "bufferScan", "bufComp", "bufferComp", " bufferCopy", "bufPack", " bufferFeed", "bufferPack", " bufferLink", "bufferpass", "BufferFeed", "BufferLink", "bufLine", "bufPass", "bufferCopy", "BufferPass", " bufferLine", "bufPush", "ufferCopy", "bufferPush", "ufferFeed", "bufScan", " bufferPack", "bufFeed", "BufferComp", "bufpass", " bufferpass", "ufferPass", "ufferPush", "Bufferpass", "ufferPack", " bufferComp", " bufferScan", "ufferLine", "bufferFeed", "bufCopy", "bufferLine", "ufferScan", " bufferPush"], "b": [" eb", "line", "u", "B", "k", "c", "n", "ob", "bs", "y", "d", "be", " a", "ab", "orb", "eb", "bi", "p", "br", "abb", "lb", "l", "bl", "w", "base", "s", "url", "x", "sb", "f", "e", "i", "a", "h", "cb", "bytes", "v", "bb", "obj", "r", "fb", "t", "ba", "null", "bf", "binary", "buffer", "wb", "body", "rb", "db"]}}
{"id1": "14609912", "id2": "7118860", "code1": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 0, "substitutes": {"lastModified": ["lastmodification", "lastMerIFIED", "nextMODified", "lastModached", "lastMODified", "nextMODification", "lastMerached", "nextMODIFIED", "lastmodified", "nextModification", "lastModification", "nextModified", "lastMODification", "lastmodIFIED", "lastMerification", "nextModached", "lastmodached", "lastModIFIED", "nextMODached", "nextModIFIED", "lastMODIFIED", "lastMODached", "lastMerified"], "url": ["image", "client", "sl", "obj", "host", "object", "ls", "id", "page", "server", "address", "open", "loc", "connection", "location", "http", "URL", "resource", "path", "ssl", "file", "str", "secure", "link", "Url", "base", "data", "org", "https", "ll", "name", "l", "browser", "string", "href", "uri", "source", "config", "www"], "conn": ["client", "connect", "Conn", "obj", "ctx", "n", "sync", "cp", "rc", "cn", "nt", "ci", "cache", "coll", "cb", "open", "loc", "ann", "connection", "nc", "http", "cm", "ssl", "con", "conf", "ch", "enc", "col", "exec", "serv", "conv", "ac", "rt", "ct", "l", "Connection", "act", "config", "c"]}}
{"id1": "13563706", "id2": "19096138", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", " doPut", "didGET", "handleget", "handleGet", "didGet", "didPut", "didget", " doget", "handlePut", "handleGET", "doPut", "doget", "doGET"], "request": ["image", "model", "method", "resource", "create", "view", "current", "event", "Response", "input", "req", "message", "queue", "remote", "info", "QUEST", "object", "application", "string", "buffer", "query", "Request", "p", "type", "attribute", "result", "frame", "client", "xml", "report", "server", "user", "data", "document", "instance", "complete", "connection", "config", "url"], "response": ["re", "onse", "image", "model", "body", "pool", "service", "resource", "index", "feed", "site", "view", "Response", "json", "reason", "http", "message", "output", "respond", "writer", "api", "object", "application", "status", "resp", "subject", "wa", "collection", "query", "result", "client", "report", "server", "document", " Response", "error", "description", "results", "res", "connection", "location", "reply", "header"], "selectedPage": ["selectionButton", "selectionHour", " selectedLine", "selectedAction", "lectedHour", "lectedSite", " selectedFile", "electedLine", "namedPage", " selectedSite", "selectedItem", "selectedHour", "selectedButton", "selectionFile", " selectedItem", "namedLine", "lectedAction", " selectedButton", "electedButton", "selectedSite", "electedPage", "lectedLine", "selectionPage", "lectedPage", "selectionpage", "selectedFile", "namedpage", " selectedpage", "namedSite", "selectedpage", "lectedFile", "lectedItem", "electedpage", "lectedpage", "lectedButton", " selectedHour", "selectedLine", "selectionItem", " selectedAction", "selectionAction", "selectionLine", "namedFile"], "page": ["model", "unit", "resource", "ice", "je", "phone", "channel", "queue", "display", "p", "result", "number", "block", "article", "ge", "layout", "per", "connection", "parent", "f", "html", "pool", "child", "account", "point", "po", "cache", "handler", "record", "ip", "peer", "language", "server", "user", "document", "instance", "plugin", "pg", "module", "change", "office", " Page", "fe", "sp", "position", "node", "type", "row", "client", "me", "photo", "Page", "port", "location", "menu", "address", "rule", "image", "section", "site", "view", "age", "message", "pp", "route", "item", "pl", "proxy", "profile", "project", "url"], "portalRequest": ["portalOrder", " portalResponse", "portallingResponse", "portpalAccess", "portugalResponse", "portallServer", "portailResponse", "portelResponse", "portalQuery", "portalAccess", "PortortalPage", "portpalPage", " portalPage", "PortortalRequest", "portallingCommand", "portALResponse", "portialQuery", "portortalAccess", " portalQuery", "portalEvent", "PortalCommand", "PortortalOrder", "PortalRequest", "portpalRequest", "portortalPage", "PortalPage", "portallingPage", "portialPage", "portalResponse", "portialRequest", "portallResponse", " portialRequest", "portelPage", "portailRequest", "PortalResponse", "portALRequest", "portugalUser", "portelCommand", "PortalEvent", " portialQuery", "PortalOrder", "portALEvent", "PortortalResponse", "portialResponse", "portortalOrder", "PortortalUser", "PortalAccess", "portugalOrder", "portbalQuery", "portbalResponse", " portialPage", "portALUser", "portortalRequest", "portortalResponse", "portalPage", "portalUser", "portelRequest", "portortalCommand", "portallingRequest", "portallRequest", "portbalPage", "portallingAccess", "portelQuery", "PortalServer", "PortortalCommand", "PortortalServer", "PortortalAccess", "PortalUser", "portortalEvent", "portailOrder", "portugalEvent", "portailUser", "portpalResponse", "portallUser", "portalCommand", " portialResponse", "portortalServer", "portbalRequest", "PortortalEvent", "portugalServer", "portugalRequest", "portalServer", "portortalUser"], "pageProp": [" pageStr", "pageprop", "PageProp", "agePro", "pluginprop", "pageProperty", "projectPro", "parentProp", "ageprop", "pluginProp", "pageStr", "PageStr", "peerStr", "parentPro", "peerPro", "parentProperty", "parentObj", "pagePro", "projectProperty", "projectprop", "resourceProperty", "resourcePro", " pageProperty", "resourceProp", "PageProperty", "pluginPro", "PageObj", "PagePro", " pagePro", "ageProperty", "resourceprop", "ageProp", "peerProperty", "projectProp", "pageObj", " pageObj", "Pageprop", "pluginProperty", "peerProp"], "possiblePage": ["possibleLine", "PossibilityPages", "patchedLine", "PossiblyLine", "pablePages", "possibilitypage", "puredPage", "possiblyPages", "PossibilityPage", "pablePage", "permanentPage", "patchingPage", "PossiblyOrder", "possibleGroup", "possiblyGroup", "patchedPage", "Possibilitypage", "possiblyOrder", "possibilityPage", "possibleOrder", "possibilityLine", "patchedOrder", "possiblypage", "possiblePages", "Possiblepage", "PossiblePage", "possibleItem", "possiblyItem", "PossibleLine", "PossibleItem", "patchingpage", "PossiblyPage", "permanentLine", "pablepage", "PossibleGroup", "puredItem", "PossiblePages", "PossiblyGroup", "permanentpage", "possiblyPage", "patchingItem", "PossiblyItem", "permanentOrder", "pableLine", "puredpage", "PossibilityLine", "possiblyLine", "patchingGroup", "puredGroup", "PossibleOrder", "patchedpage", "Possiblypage", "possiblepage", "possibilityPages"], "property": ["resource", "section", "config", "prefix", "integer", "duration", "function", "key", "properties", "label", "notation", "table", "Property", "object", "string", "class", "set", "future", "binding", "t", "p", "type", "attribute", "result", "entity", "number", "prop", "layer", "character", "expression", "name", "term", "uration", "operator", "language", "perties", "data", "binary", " Property", "variable", "value", "feature", "maximum", "profile", "project", "f", "header", "address"], "referer": ["Referer", "redrer", "Refre", "Refere", "fere", " refeline", "referers", "afferer", " refiner", "defender", " refre", "refrer", "affere", "redeline", " refrer", " referers", "rederer", " refere", "Refrer", "deferer", "defere", "defber", "defrer", "reerer", "Refender", "Refiner", "Referers", "reiner", " referen", "diffrer", "refender", "refber", "rerer", " refender", "ferers", "referen", "afferen", "diffender", "diffiner", "Referen", "reere", "redber", " refber", "Refeline", "refre", "refeline", "refiner", "frer", "differer", "ferer", "refere", "Refber", "rere", "affrer"], "e": ["err", "de", "o", "eme", "this", "event", "fe", "message", "E", "null", "element", "ed", "d", "er", "ea", "p", "ie", "type", "se", "see", "me", "es", "ception", "a", "ae", "esi", "f", "error", "i", "one", "or", "ele", "exc", "ee"]}}
{"id1": "19113613", "id2": "8150996", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"copy": ["save", "get", "archive", "rm", "create", "put", "type", "change", "sync", "p", "download", "opy", "move", "load", "Cop", "share", "zip", "clip", "cop", "paste", "cat", "Copy", "process", "delete", "update", "transfer", "ssh", "split", "clone", "upload", "replace", "cp", " cp", "write"], "in": ["reader", "bin", "connection", "login", "f", "data", "sin", "name", "get", "ins", "pin", "cin", "min", "In", "base", "plugin", "inside", "kin", "part", "inner", "again", "win", "old", "din", "work", "IN", "client", "this", "ini", "i", "image", "init", "inc", "project", "url", "update", "config", "n", "thin", "inn", "c", "as", "id", "index", "a", "ic", "lin", "on", "input", "token", "diff"], "out": ["x", "connection", "bin", "app", "ext", "outside", "name", "point", "self", "version", "at", "remote", "p", "ex", "outs", "one", "base", "page", "conn", "b", "again", "output", "cache", "vert", "goal", "part", "user", "line", "work", "root", "err", "dot", "o", "off", "client", "OUT", "this", "external", "call", "block", "image", "init", "inc", "project", "path", "exec", "object", "parent", "outer", "v", "other", "no", "n", "group", "null", "io", "net", "c", "up", "resource", "input", "with", "Out", "obj", "option"], "source": ["feature", "missing", "iter", "sin", "alt", "family", "name", "force", "origin", "type", "reference", "from", "secure", "base", "direction", "ource", "position", "component", "class", "status", "format", "size", "SOURCE", "dest", "subject", "secret", "service", "proxy", "project", "parent", "url", "attribute", "view", "uri", "unit", "route", "pe", "scope", "ce", "id", "prefix", "src", "resource", "Source", "internal", "use", "username", "site"], "target": ["wrong", "alt", "current", "name", "point", "force", "origin", "master", "arget", "reference", "detail", "top", "direction", "base", "format", "component", "output", "goal", "alias", "root", "dest", "address", "service", "cat", "template", "value", "project", "path", "parent", "pattern", "next", "url", "tail", "config", "route", "null", "Target", "prefix", "src", "resource", "about", "host", "token", "home", "site"], "files": ["pages", "f", "images", "data", "sections", "blocks", "s", "ins", "groups", "results", "Files", "cells", "items", "ls", "models", "obs", "features", "flows", "apps", "tools", "lines", "assets", "objects", "filename", "iles", "classes", "names", "ions", "keys", "jobs", "ports", "links", "users", "plugins", "resources", "docs", "fs", "children"], "file": ["le", "f", "data", "current", "name", "it", "File", "el", "layer", " File", "load", "fe", "local", "letter", "base", "binary", "per", "future", "page", "part", "b", "entity", "l", "line", "single", "e", "lib", "entry", "live", "child", "ile", "feed", "path", "filename", "object", "parent", "url", "uri", "unit", "folder", "id", "function", "item", "FILE", "resource", "dir", "fp", "directory", "string"], "inCh": ["INChannel", "INChan", " inChannel", "outCH", "InChan", "inch", "InCh", " inChan", "INCh", "outch", " inch", "Inch", "outChan", "inChannel", "INCH", "InCH", "inChan", " inCH", "outChannel", "InChannel", "inCH"], "outCh": ["outputCh", "outputChan", "outCH", "OutCh", "inch", "OutChan", "outch", "outChan", " outChannel", "inChannel", "Outch", "OutChannel", "inChan", "outputch", " outch", "outputCH", "outChannel", "inCH", " outCH", "OutCH"]}}
{"id1": "10504714", "id2": "771802", "code1": "    private MediaWikiResult getFromUri(String url) throws OntologyServiceException {\n        try {\n            logger.info(\"getting \" + url);\n            HttpURLConnection connection = (java.net.HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"OntoCat-\" + Math.random());\n            BufferedInputStream bin = new BufferedInputStream(connection.getInputStream());\n            JAXBContext jaxbContext = JAXBContext.newInstance(\"uk.ac.ebi.ontocat.mediawiki.jaxb\");\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            return (MediaWikiResult) unmarshaller.unmarshal(bin);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new OntologyServiceException(e);\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 0, "substitutes": {"getFromUri": ["getFromUuri", "getFromURuri", "getFromUUrl", "getfromPUri", "getfromPURI", "getfromPUuri", "getfromURI", "getFromURUrl", "getFromRuUrl", "getFromPUuri", "getFromPURI", "getfromUuri", "getFromPUUrl", "getFromURRI", "getFromURri", "getFromRuRI", "getFromPUri", "getfromPUUrl", "getfromUri", "getFromRuuri", "getFromURI", "getfromUUrl", "getFromRuri"], "url": ["image", "rule", "URL", "base", "email", "resource", "lr", "feed", "www", "download", "Url", "ls", "http", "src", "filename", "href", "l", "info", "full", "page", "string", "ri", "buffer", "route", "path", "source", "type", "result", "uri", "build", "layer", "ur", "name", "ssl", "request", "proxy", "language", "server", "data", "ll", "host", "file", "id", "username", "str", "sl", "i", "loc", "location", "address"], "connection": ["image", "j", "index", "in", "service", "section", "ion", "function", "which", "channel", "Connection", "http", "use", "password", "b", "conn", "writer", "object", "application", "c", "position", "condition", "collection", "relation", "handler", "translation", "part", "io", "uri", "network", "number", "response", "client", "character", "context", "socket", "communication", "proxy", "con", "server", " Connection", "connect", "i", "database", "bc", "connected", "config", "db", "directory"], "bin": ["body", "base", "in", "login", "inner", "inn", "input", "bot", "channel", "ban", "bon", "src", "bit", "brain", "output", "b", "bb", "ruby", "conn", "ran", "spin", "pin", "border", "buffer", "abi", "container", "bi", "sin", "bis", "bn", "bean", "data", "file", "binary", "database", "win", "bc", "lib", "din", "plugin", "socket"], "jaxbContext": ["japbSupport", "jaxfSupport", "jaxaText", "jaxacontext", "jjbText", "jaxfbContext", "jaxaContext", "jaxecontext", "japbcontext", "jaxfChannel", "jjbcontext", "japbText", "jaxfbText", "jaxeSupport", "jaxfbcontext", "jaxpChannel", "jaxbSupport", "jaxfbChannel", "japacontext", "jaxaSupport", "japaSupport", "jjfcontext", "jaxpContext", "jaxbcontext", "japaText", "jjfChannel", "jjbChannel", "japaContext", "jaxpcontext", "jjfContext", "jaxfcontext", "jjfText", "japbContext", "jaxfText", "jaxbChannel", "jaxeText", "jaxfContext", "jaxeContext", "jjbContext", "jaxbText", "jaxpText"], "unmarshaller": ["unmarshallER", "unmarshallingender", "unmarshaliner", "unmarshaler", "unmarshalletter", "unmarshdaletter", "unmarshallsiner", "unmarshALLiner", "unmarshullender", "unmarshdalender", "unmarshdaler", "unmarshallers", "unmarshallsER", "unmarshallser", "unmarshALLER", "unmarshallingetter", "unmarshalER", "unmarshalleder", "unmarshallingeder", "unmarshallsers", "unmarshulletter", "unmarshallender", "unmarshALLers", "unmarshallinger", "unmarshulleder", "unmarshalers", "unmarshdaleder", "unmarshALLer", "unmarshalliner", "unmarshuller"]}}
{"id1": "20995534", "id2": "4164833", "code1": "    private static Properties loadPropertiesFromClasspath(String path) {\n        Enumeration<URL> locations;\n        Properties props = new Properties();\n        try {\n            locations = Thread.currentThread().getContextClassLoader().getResources(path);\n            while (locations.hasMoreElements()) {\n                URL url = locations.nextElement();\n                InputStream in = url.openStream();\n                props.load(in);\n                in.close();\n                logger.config(\"Load properties from \" + url);\n            }\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"load properties from classpath \\\"\" + path + \"\\\" failed\", e);\n        }\n        return props;\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 0, "substitutes": {"loadPropertiesFromClasspath": ["loadPropertiesFromClassfile", "loadPropertiesFromSubfile", "loadPropertiesFromSubloader", "loadPropertiesfromClasspath", "loadPropertiesfromclassfile", "loadPropertiesFromclassloader", "loadPropertiesfromclassname", "loadPropertiesfromclassloader", "loadPropertiesfromClassfile", "loadPropertiesFromClassloader", "loadPropertiesfromClassname", "loadPropertiesFromSubpath", "loadPropertiesfromclasspath", "loadPropertiesFromclassname", "loadPropertiesfromClassloader", "loadPropertiesFromclasspath", "loadPropertiesFromclassfile", "loadPropertiesFromClassname", "loadPropertiesFromSubname"], "path": ["enc", "log", "method", "base", "resource", "Path", "prefix", "root", "content", "pattern", "text", "filename", "key", "properties", "full", "object", "PATH", "string", "c", "route", "work", "handler", "p", "template", "type", "source", "part", "pointer", "uri", "ath", "prop", "dir", "context", "xml", "loader", "name", "request", "host", "id", "data", "level", "value", "error", "config", "location", "parent"], "locations": [" locors", "LOCions", " locator", "slibraries", "slations", "locibraries", "slator", "sllements", "operators", " location", "Lococations", "lococations", "operibraries", "Loclements", " locators", "Locations", "LOCATIONS", "locATIONS", "locator", "slation", "Locator", "slators", "locators", "colions", "locions", "LOCations", " locATIONS", "slATIONS", "LOCation", "colATIONS", "operations", "loclements", "locors", "operation", " lococations", "LOCocations", "LOCors", "LocATIONS", "colations", " locibraries", "Location", "Locors", "location", "Locions", " loclements", "colation"], "props": ["peperties", "ppp", "pospp", "produps", "pbros", " propp", " probs", "protros", "suppps", "supppps", " procs", "producs", "properties", " propps", "posps", "procs", "posbs", "pebs", "suppperties", "pps", "produpps", "pbps", "peros", "pbbs", "protbs", "propps", "pbs", "posperties", "produperties", "pperties", "probs", "protps", " properties", "propp", "proros", "protperties", "pbperties", "peps", "suppcs"], "url": ["err", "URL", "resource", "base", "feed", "lr", "coll", "Url", "ls", "obj", "entry", "http", "src", "key", "l", "b", "href", "string", "class", "element", "r", "bel", "route", "source", "ource", "rel", "org", "uri", "out", "layer", "name", "ssl", "user", "file", "ll", "ob", "e", "id", "gl", "el", "sl", "str", "rl", "i", "connection", "loc", "location", "f", "address"], "in": ["ini", "err", "image", "resource", "login", "serv", "impl", "stream", "gin", "inner", "inn", "input", "din", "In", "src", "bin", "conn", "c", "r", "IN", "again", "ic", "source", "nin", "io", "it", "out", "ins", "is", "into", "as", "socket", "init", "a", "ac", "con", "data", "file", "isin", "id", "ex", "i", "reader", "n", "connection", "config", "inc", "f", "lin", "s"]}}
{"id1": "19050432", "id2": "9096319", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["openNestedResources", "openParamedresource", "openNnamedResource", "openParamingURI", "openParamedResources", "openNamingResources", "openNestedResource", "openNestedresource", "openParamingResources", "openNestedURI", "openNnamedURI", "openNamedURI", "openNnamedResources", "openNnamedresource", "openParamedResource", "openNamedresource", "openNamingresource", "openNamingResource", "openNamedResources", "openParamedURI", "openParamingresource", "openParamingResource", "openNamingURI"], "name": ["size", "n", "full", "key", "class", "old", "version", "sea", "parent", "id", "address", "ame", "info", "path", "resource", "word", "value", "file", "str", "part", "NAME", "url", "prefix", "base", "definition", "data", "type", "Name", "names", "string", "named", "uri", "source", "filename", "username"], "in": ["get", "r", "pin", "ic", "inn", "gin", "i", "socket", "cin", "input", "thin", "din", "edIn", "val", "conn", "result", "connection", "inner", "resource", "vin", "nin", "out", "con", "rin", "kin", "ini", " out", "rec", "fc", "f", "url", "login", "data", "err", "b", "token", "oin", "ins", "pc", "bin", "In", "reader", "IN", "as", "again", "win", "source", "ac", "inc"], "propsURL": [" propsSSL", "perrsURL", "propsUR", "proopsLL", "prodsUrl", "procsurl", "prosUrl", " prodsurl", "prolsURI", "probsLL", " propsLL", "prodsCL", "prosURI", "prorsUrl", "proportsUrl", " prodsURI", "pronsLL", "proportsURL", " proportsLL", "proopsurl", "prosLL", "probsURL", " propsUR", "prodsLL", "pronsUR", "progsURI", "perpsURL", "proportsSSL", " proportsELF", "ProsUrl", "proppsUR", "proppsUrl", " prolsSSL", "prorsURL", "probsUL", "propsurl", " propsCL", " prodsCL", " propsUrl", "perpsFile", "propsELF", "prodsURL", "proppsLL", "perpsurl", "propdsURL", "perrsurl", "proportsurl", "propsUrl", "prorsFile", "propsCL", "prosUL", "pronsURL", "proopsURL", "prodsURI", " proportsURL", "prodsUR", "prodsSSL", "propsUL", "procsURL", " proportsUR", " propsUL", " prolsURI", "PropsSSL", "prosURL", "propsSSL", "proopsCL", " prolsurl", "prodsFile", "prolsSSL", "progsURL", "progsurl", "procsURI", "proportsUL", "propsFile", "proopsELF", "proportsURI", "progsCL", "proppsURL", "procsUrl", "protsURL", "procsSSL", " proportsUrl", "PropsUrl", "proopsUR", "perrsFile", "PropsURL", "prorsELF", "PropsURI", " propsurl", " propsELF", "ProsSSL", "proopsURI", "proportsELF", "protsurl", "propdsLL", "propsLL", "ProsURI", "protsFile", "proopsUrl", "pronsUrl", "prolsurl", "proportsLL", "probsUrl", "prorsurl", "prolsURL", " propsURI", "proportsUR", " proportsUL", " prolsURL", " prodsURL", "prorsUR", "propdsUrl", "propsURI", "ProsURL", "prosSSL", "prodsurl", "propdsUR"], "urlConn": [" urlCmd", "urlCod", " urlConnect", " urlconn", "httpContext", " urlConf", "sslCod", "fileCmd", "urlCond", "sslconn", "httpConn", "sslCond", "fileConnect", "httpconn", "urlConnect", "urlCmd", "urlContext", "URLConf", "sslConn", " urlCod", "URLContext", "httpConf", "URLConnect", "fileConn", "sslConnect", "fileCond", "httpCod", "URLConn", "sslCmd", "urlconn", "urlConf", "httpConnect", " urlCond", " urlContext"], "httpURL": ["apiUrl", "HttpML", "apiURL", "httpsurl", "autourl", "httpsSSL", "httpsURI", "apiUR", "autoUrl", "autoURL", " httpURI", " httpML", "HttpUR", "autoSSL", "httpUrl", "httpSSL", " httpUrl", "HttpURL", " httpSSL", "httpURI", "apiML", "HttpUrl", "httpUR", " httpurl", "httpML", "httpsUR", "HttpURI", "httpsURL", " httpUR", "httpsUrl", "httpurl"], "hdrVal": [" hheaderStr", "hheaderStr", "hndDef", "hhrDef", "hDRval", "hrcBu", "hdValues", "hhrValues", "hhrval", "hdrValue", "hhrBu", " hheaderValue", "hDRValues", "hdrBu", "hdval", "HdrVal", "hDRVal", "hheaderVol", "hdrval", "HhrValues", "hdrStr", "hrVal", "hhrVal", "HdrBu", " hdrValue", " hheaderVal", "hrcDef", "hdrValues", "HdrValues", "hreqStr", "hheaderValue", "HhrBu", "hheaderVal", " hdrVol", "HhrValue", "hreqValue", "HdrValue", "HhrDef", "Hdrval", "hdrDef", "hreqVol", "hreqVal", "hhrValue", "hrValue", "hrcValue", "hrStr", " hheaderVol", "hdVal", " hdrStr", "hdValue", "HdrDef", "hrVol", "hndBu", "hndVal", "Hhrval", "hDRValue", "HhrVal", "hrcVal", "hdrVol", "hndValue"], "code": ["category", "expected", "error", "success", "rate", "level", "one", "ie", "go", "msg", "key", "ce", "rc", "cc", "comment", "class", "version", "cat", "e", "ode", "id", "core", "rule", "const", "check", "fail", "info", "result", "state", "content", "desc", "reason", "message", "coded", "response", "grade", "index", "see", "codes", "zone", "line", "value", "count", "ge", "url", "no", "zip", "mode", "data", "type", "pe", "charge", "ack", "xx", "test", "status", "number", "text", "pc", "co", "age", "string", "score", "Code", "cod", "header", "c", "ec"]}}
{"id1": "23273706", "id2": "17773263", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 0, "substitutes": {"getProjectTreeData": ["getProjectTreeInfo", "getprojecttreeInfo", "getProjecttreeDATA", "getProjectDocumentData", "getProjectPageDATA", "getprojectTreeData", "getProjectDocumentMeta", "getProjecttreeInfo", "getProjectPageData", "getprojecttreeDATA", "getProjectPageMeta", "getprojecttreeMeta", "getProjectDocumentInfo", "getprojectTreeMeta", "getProjectTreeMeta", "getProjectTreeDATA", "getProjecttreeData", "getProjectPageInfo", "getProjectDocumentDATA", "getProjecttreeMeta", "getprojectTreeInfo", "getprojecttreeData", "getprojectTreeDATA"], "treeData": ["TreeList", "contentInfo", "TreeArray", "TreeData", "treeArray", "monkeyData", "monkeyDec", "reeText", "treeDec", "contentText", " treeInfo", "treeText", "bodyDat", "storyDat", "reeDat", "reeInfo", "treeDat", "monkeyArray", "reeList", " treeDat", "storyData", " treeDec", "storyDec", "storyArray", "contentData", "contentDat", "reeArray", "bodyList", "bodyData", "reeString", " treeArray", "reeData", " treeText", "treeList", " treeString", " treeList", "bodyString", "TreeString", "treeString", "TreeInfo", "monkeyDat", "treeInfo"], "filename": ["figure", "whatever", "uri", "fp", "ppa", "path", "username", "kl", "wav", "title", "ername", "fil", "txt", "sheet", "data", "folder", "location", "metadata", "dll", "journal", "framework", "directory", "FILE", "url", "database", "name", "tmp", "kn", "kj", "fd", "files", "password", "dylib", "SourceFile", "upload", "string", "fn", "prefix", "Filename", "file", "nil", "jpg", "xml"], "urlString": [" urlURL", "URLString", "addressStr", "URLURL", "URLstring", "urlStr", "addressString", "URLStr", "addressURL", "urlUrl", "locationUrl", " urlstring", "urlURL", "locationString", "URLUrl", "urlstring", " urlUrl", "addressstring", "locationStr", "locationstring", " urlStr"], "urldata": ["urlledATA", "URldat", "urlledata", "urlledta", "urlfat", " urLDdata", " urLDta", "urldat", "urLDat", "urleddata", "urledATA", "urllata", "urledta", " urldATA", "urledata", "urLDta", " urLDATA", "URlddata", "urLData", "urldATA", "URlfata", "URlfat", " urldta", " urLData", "urlldata", "urlfATA", "urlfata", "urlfdata", "urllat", "urldta", "URlfATA", "URldata", "urLDATA", "urllATA", "URldATA", "urlleddata", " urlddata", "urlddata", "urLDdata", "URlfdata"], "factory": ["cFactory", " fault", "confFactory", " fFactory", "conflier", "confiller", "liller", "cflier", "fuild", "ciller", "lactory", "fFactory", "ufactory", "luild", "cault", "cfFactory", "pFactory", "ufuild", "cfiller", "flier", " flier", "lictionary", " fictionary", "pault", "ufictionary", "fault", "pactory", "filler", "confactory", " fuild", "ufiller", "piller", "cfactory", "cactory", "fictionary", " filler"], "parser": ["p", "lp", "arser", "util", "uri", "se", "json", "parse", "instance", "s", "driver", "root", "l", "manager", "loader", "writer", "ph", "Parser", "builder", "pdf", "ger", "up", "b", "utils", "monkey", "fruit", "api", "string", "jack", "handler", "plugin", "auto", "t", "er", "r", "reader", "parent", "xml", "raf", "library", "http"], "u": ["p", "uni", "uv", "util", "su", "uri", "uf", "us", "c", "plug", " ur", "eu", "s", "l", "tu", "ru", "yu", "io", "iu", "url", "ou", "b", "ui", "nu", "ur", "ul", "lu", "universal", "cu", "hu", "uu", "U", "o", "d", "http"], "is": ["p", "mis", "as", "ris", "init", "uri", "IS", "isa", "us", "ai", "info", "s", "its", "ori", "isu", "iss", "are", "ie", "Is", "serv", "or", "iso", "gets", "in", "ib", "lis", "ir", "ip", "io", "ar", "it", "fs", "ui", "isl", "pi", "api", "ais", "ios", "es", "abs", "iris", "obs", "ob", "bis", "has", "ri", "ops", "http"], "os": ["OS", "ops", "as", "dos", "ps", "so", "oss", "us", "bos", "s", "oes", "ens", "pos", "or", "iso", "ose", "gets", "sys", "ol", "oa", "opens", "io", "ros", "ms", "cos", "los", "fs", "bs", "fits", "oos", "ios", "aos", "ils", "es", "obs", "Os", "o", "ob", "osi", "bis", "oses", "http"], "iBufSize": ["iBufsize", "iBbufsize", "iBlfLength", "iBbufSize", "iByteufLength", "iBytebufSize", "iLlfLength", "iBytebufLength", "iByteufsize", "iLlfSt", "iBbufLength", "iByteufSize", "iBufLength", "iLufSt", "iLlfSize", "iBuffLen", "iLufSize", "iBbufLen", "iBlfsize", "iBufferSt", "iBufferSize", "iBuffLength", "iLlfsize", "iBlfLen", "iBuffersize", "iBytebufLen", "iBuffSt", "iLufLength", "iBytebufsize", "iBuffsize", "iBufSt", "iBuffSize", "iByteufLen", "iBufLen", "iBlfSt", "iLufsize", "iBufferLength", "iBlfSize"], "inBuf": ["inBluf", " inFbuf", "inbuf", " inFaf", "inDuff", "inBunk", "inFuf", "inFuff", "inDbuf", "outBuffub", "outBuffump", "inBump", "outBump", "inCbuf", "inCunk", " inBuff", "inBlunk", " inBaf", "inCuf", " inBump", "inPluf", "outBuf", "outBuffbuf", "inBuffuf", "inPlump", "inDuf", "inBub", "inDaf", " inBunk", " inCunk", " inCuf", "outBbuf", "inbub", "inBuffump", " inCbuf", "inCuff", " inCump", "inPlunk", "inFaf", "inBbuf", "inbump", "inFbuf", "outBuffuf", "inBuff", "inBuffbuf", "inBlbuf", " inFuff", "inbbuf", "inBlub", "inBuffub", "inBaf", "inCaf", "inBlump", "outBub", "inPlbuf", "inCump", " inFuf", " inBbuf"], "iNumRead": ["pNumberRead", "inumWritten", "qiNumREAD", "iChanBuild", "qiNumread", "pNumberWritten", "iValREAD", "iNumread", "inumread", "iLenRead", "iNumREAD", "iNumberBuild", "pNumberread", "pNumWritten", "iLenWritten", "iFatWritten", "inumWrite", " iFatWritten", "iChanREAD", "qiValread", " iFatRead", "pNumRead", "iNumWritten", "iNumberWrite", "iValRead", "iFatRead", " iNumWrite", "inumRead", "iValBuild", "iNumberread", "qiValREAD", "qiValBuild", " iFatWrite", "pNumread", "iNumberREAD", "iValread", "iNumberWritten", "qiNumBuild", "iChanRead", "qiNumRead", "iFatWrite", "iNumberRead", "iChanread", "pNumWrite", "iNumWrite", "qiValRead", "iLenWrite", " iNumWritten", "pNumberWrite", "iNumBuild"], "f": ["p", "F", "fp", "uf", "c", "s", "e", "l", "ff", "m", "n", "g", "io", "b", "fd", "fs", "fe", "j", "h", "fn", "fr", "fa", "handler", "rf", "full", "fc", "file", "df", "t", "r", "fi", "sf", "o", "feed", "v", "d"], "inputstream": ["Inputsw", " inputsw", "Inputchannel", " inputchannel", "outputchannel", "Inputstream", "contentStream", "InputStream", " inputStream", "inputsystem", "contentsw", "contentstream", "outputStream", "Inputsystem", "inputsw", "outputstream", "inputStream", "contentsystem", " inputsystem", "inputchannel"], "document": ["p", "source", "DOM", "media", "output", "language", "info", "page", "e", "l", "tree", "project", "ocument", "xml", "data", " documents", "m", "record", "object", "context", "director", "n", "directory", "window", "null", "docs", "Document", "Documents", "container", "list", "html", "dom", "office", "file", "collection", "t", "response", " documentation", "parent", "node", "d", "doc", "content"], "nodelist": ["nodedestyle", "nodemark", "nodestate", "nodata", "anodedeme", " nodesels", "nondestate", "nodedestate", "nodedeme", "snodseline", "NODelist", "nonedelist", "nozette", " nodesename", "Nodelist", "nozelist", "nODesh", "nodeeme", "snodselist", "nozename", "nodels", "snodsette", "nODelist", "nodette", "Nodestyle", "nodeestate", "nODeline", "nodedemark", "nodesename", "nODestyle", "anodedata", "anodestate", "snodslist", "nodedelist", "nondeme", " nodename", "nodeme", "snodlist", "nodesh", "nodestyle", "Nodemark", "anodelist", "snodelist", "Nodesh", "nonedette", "nodlist", "nodeline", "NODesh", "nodesels", "nozemark", "NODemark", "nondelist", "nondata", "nodedette", "snodette", "nozels", "nodeelist", " nodeselist", "nODette", "anodeme", "nodseline", "nodedlist", "nodsette", " nodette", " nodels", "nodedeline", "anodedestate", "nozestyle", " nodesette", "nodslist", "nodename", "nodeata", "nodedesh", "anodata", "nodeselist", "nODlist", "nodselist", "nozesh", "nonedels", "nonedename", "NODestyle", "nODemark", "nodedata", "anodedelist", "nodesette", "snodeline"], "num": ["Num", "dim", "uni", "init", "span", "uri", "net", "np", "len", "nom", "lim", "max", "pos", "count", "norm", "loc", "m", "NUM", "con", "total", "multi", "n", "zero", "col", "um", "nb", "nr", "number", "nu", "index", "om", "mon", "div", "comb", "ul", "tri", "sum", "en", "nam", "dom", "umi", "temp", "part", "mu", "unit", "inc", "node", "mult"], "i": ["p", "x", "uri", "c", "ai", "info", "ii", "gi", "ori", "ix", "ie", "d", "l", "I", "ci", "yi", "m", "chi", "in", "ini", "multi", "ip", "iu", "g", "io", "bi", "si", "a", "b", "col", "it", "iv", "ui", "ik", "pi", "oi", "ji", "j", "li", "index", "isi", "hi", "mi", "di", "qi", "eni", "y", "xi", "part", "fi", "cli", "mu", "slice", "id", "o", "v", "start", "ri", "ti", "phi"]}}
{"id1": "20623709", "id2": "9413074", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "label": 0, "substitutes": {"split": ["share", "run", "cmp", "join", "execute", "append", "copy", "Split", "open", "match", "add", "process", "sync", "archive", "build", "part", "init", "exec", "delete", "set", "format", "start", "transfer", "diff", "parse", "update", "sort"], "targetDirectory": ["targetFile", "targetFolder", "destDir", " targetFolder", " targetPath", "masterDatabase", "TargetDir", "TargetDirectory", "outputFile", "currentDirectory", "TargetFolder", "destFile", "targetPath", "masterDirectory", " targetFile", "currentDir", "baseDir", " targetRoot", "basePath", "baseFolder", "TargetDatabase", "outputFolder", "masterPath", "destDirectory", "TargetFile", "outputDirectory", " targetDir", "TargetPath", "baseFile", "currentRoot", "targetRoot", "currentPath", "destFolder", "targetDatabase", "outputDir", "baseDatabase", "TargetRoot", "currentFolder", "masterDir", "targetDir", "baseDirectory"], "prefix": ["folder", "timeout", "resource", "temp", "txt", "root", "username", "string", "cache", "append", "path", "fixed", "patch", "sequence", "number", "queue", "first", " suffix", "unit", "template", "base", "fix", "domain", "config", "index", "pre", "filename", "format", "resolution", "fp", "FIX", "directory", "type", "prot", "offset", "uri", "ix", "pattern", "name", "Pref", "padding"], "maxUnitBases": ["maxUnitChase", "maxUnitChasing", "maxunitAliasing", "maxUnitQuease", "maxUnitAliues", "maxunitBaches", "maxUnitEases", "maxunitBails", "maxunitAliues", "maxUnitAliasing", "maxUnitBues", "maxUnitQueasing", "maxunitBase", "maxUnitPlase", "maxUnitEaches", "maxUnitChases", "maxUnitPlaches", "maxUnitBasing", "maxunitAliails", "maxunitAliases", "maxunitBues", "maxunitBases", "maxUnitAliails", "maxUnitEase", "maxUnitBails", "maxUnitEails", "maxUnitBase", "maxunitAliase", "maxUnitAliases", "maxunitBasing", "maxUnitQueues", "maxUnitBaches", "maxUnitQueases", "maxUnitPlases", "maxUnitAliase", "maxUnitPlails", "maxUnitAliaches", "maxUnitChues", "maxunitAliaches"], "maxUnitEntries": ["maxUnitOrdry", "maxUnitEntryries", "maxUnitOrdrys", "maxUnitEntry", "maxUnitEnties", "maxUnitErry", "maxUnitErrations", "maxUnitErines", "maxLineEntries", "maxUnitCountries", "maxUnitEntrys", "maxUnitEntures", "maxUnitOrdries", "maxLineOrdines", "maxUnitIntresses", "maxUnitCountines", "maxUnitEntrations", "maxUnitCountrations", "maxLineOrdries", "maxUnitEntryrys", "maxunitEntryrys", "maxLineEntry", "maxUnitOrdrations", "maxunitEntries", "maxUnitEntryresses", "maxLineOrdrations", "maxUnitOrdines", "maxUnitAddures", "maxUnitIntrys", "maxLineEntrations", "maxunitEntrys", "maxUnitIntries", "maxunitEntresses", "maxUnitInties", "maxunitEntryresses", "maxUnitAddresses", "maxUnitCountry", "maxUnitEntines", "maxUnitErries", "maxLineOrdry", "maxUnitAddry", "maxUnitAddries", "maxUnitEntryures", "maxunitEnties", "maxunitEntryries", "maxUnitOrdresses", "maxLineEntines", "maxUnitEntresses", "maxUnitEntryies", "maxUnitOrdies", "maxUnitEntryry", "maxunitEntryies"], "fis": ["Fiss", " fisc", "forIs", "vIs", "foriss", "fisc", " fIs", "fIs", " fiss", "fris", "forris", "vis", "forisc", "foris", " fris", "fisa", " fai", "Fis", "forisa", "fai", "forai", "vai", "Fris", "fiss", "visa", "Fisc", " fisa"], "fci": ["vco", "fii", "vci", " foci", "efcos", "Fci", "vcos", "efci", "Fai", "Foci", "hcos", "dci", "efco", "hai", "fcos", "Fii", "dco", "dii", "hci", "Fis", " fai", "Fco", "bai", "fai", "foci", "efai", "hco", "bis", "vai", "doci", "bco", " fii", "bci"], "fos": ["infoes", "fsos", "ifos", "fo", "ifo", "fso", "fios", " fcos", "infos", "fscos", "ifios", "infis", " fios", " fo", "tos", "foes", "fcos", "infoss", "Fis", "ifcos", "fsios", "Fos", "Foss", "toes", "Foes", "tis", "foss", "toss"], "fco": ["fileico", "Fico", "fbo", "hgo", "fileco", "Fci", "lcos", "lco", "lci", " fcos", "Fbo", " fico", "fico", "fgo", "dcos", "hcos", "dro", "dci", "filebo", " fro", "fcos", "dco", "hci", "lgo", "lro", " fgo", "Fco", "hco", "fro", "fileci", " fbo"], "buffer": ["resource", "timeout", "entry", "window", "position", "channel", "cache", "zero", "capacity", "context", "request", "view", "uffer", "expression", "comment", "bin", "pause", "response", "copy", "input", "layer", "texture", "feed", "buf", "queue", "pad", "length", "header", "translation", "batch", "document", "base", "device", "rate", "scale", "server", "size", "loader", "bc", "Buffer", "iter", "bar", "read", "callback", "image", "writer", "border", "transfer", "memory", "result", "reader", "counter", "data", "null", "buff", "flush", "message", "offset", "binary", "info", "block", "source", "reference"], "currentBasesCount": ["currentBaseCount", "currentBasesCounter", "currentChasecount", "currentBasesNum", "currentBaseCounter", "currentChaseCount", "currentChasesNum", "currentBatchesNum", "currentBasingNum", "currentBasingCount", "currentBatchescount", "currentChasescount", "currentBasingcount", "currentChaseNum", "currentBasescount", "currentBatchesCounter", "currentBasingCounter", "currentChasesCounter", "currentBasecount", "currentBatchesCount", "currentBaseNum", "currentChasesCount", "currentChaseCounter"], "currentEntriesCount": ["currentEntriesOffset", "currentEntrasOffset", "currentEntrasCount", "currentEntursLimit", "currentEntriesSize", "currentAdduresSize", "currentAddriesLimit", "currentEntrasSize", "currentEnturesOffset", "currentAddriesOffset", "currentEnturesSize", "currentEntriesLimit", "currentEntrasLimit", "currentAdduresCount", "currentEntursOffset", "currentAdduresOffset", "currentAddriesCount", "currentEntursCount", "currentEnturesCount", "currentAddriesSize", "currentAdduresLimit", "currentEnturesLimit", "currentEntursSize"], "targetCount": ["targetSize", "patternCount", "argetcount", "patterncount", "TargetSize", "TargetSum", "patternSize", "argetSize", "patternSum", "targetcount", "targetSum", "argetSum", "argetCount", "TargetCount", "Targetcount"], "fastaChannel": ["fastasContext", "fastanChannel", "fastanContext", " fastaColumn", "fastasBuffer", "fastAColumn", "fastaColumn", "fastaContext", "fastaContainer", " fastAContext", " fastAContainer", " fastaContext", " fastaContainer", "fastABuffer", "fastasChannel", " fastABuffer", " fastAColumn", "fastanContainer", "fastAContainer", "fastasConnection", "fastAConnection", "fastasColumn", "fastasContainer", "fastaqChannel", "fastaqBuffer", "fastAChannel", " fastAConnection", "fastaConnection", " fastaConnection", " fastAChannel", "fastAContext", "fastaqColumn", "fastanBuffer", "fastaqConnection"], "totalSeqCount": ["totalSeQcount", "totalSeuxcount", "totalSeQNum", "totalSeQCounter", "totalSeQCount", "totalQueQcount", "totalSeqscount", "totalQueQCounter", "totalQueqCount", "totalQueqcount", "totalQueqNum", "totalQueqCounter", "totalSeqcount", "totalSeuxCount", "totalSeqsCounter", "totalSeuxCounter", "totalSeuxNum", "totalSeqNum", "totalSeqsNum", "totalSeqsCount", "totalSeqCounter", "totalQueQCount", "totalQueQNum"], "totalResiduesCount": ["totalResqueuresCount", "totalResiduationNum", "totalResidurescount", "totalResiduingNum", "totalResqueuesNum", "totalResiduescount", "totalResiduesSize", "totalResiduresCount", "totalResiduationcount", "totalResqueuesSize", "totalResqueuresNum", "totalResiduingSize", "totalResqueurescount", "totalResiduationCount", "totalResiduingCount", "totalResiduresSize", "totalResqueuesCount", "totalResqueuresSize", "totalResiduresNum", "totalResiduationSize", "totalResqueuescount", "totalResiduesNum", "totalResiduingcount"], "prevTime": ["prevSize", "PrevFile", "prevValue", " prevValue", " prevFile", "prevFile", "PrevValue", "commitSize", "PrevSize", "commitFile", "commitTime", "PrevTime", " prevSize", "commitValue"], "fastaFileSize": ["fastasFileLength", "fastaBufferSize", "fastaFilesSize", "fastAFileAddress", "fastasFileAddress", "fastasFileName", "fastaHeaderSize", "fastasHeaderLength", "fastaFileName", "fastaBlockSize", "fastaLineLength", "fastaFilesAddress", "fastaBlockLength", "fastaLineCount", "fastaHeaderAddress", "fastaFileCount", "fastaLineAddress", "fastaBlockAddress", "fastaBlockCount", "fastAFileCount", "fastaHeaderLength", "fastasHeaderSize", "fastaPageSize", "fastaBufferAddress", "fastABufferAddress", "fastaFileLength", "fastasFileSize", "fastaFileAddress", "fastaHeaderName", "fastaPageLength", "fastaFilesName", "fastABufferSize", "fastasHeaderName", "fastaLineSize", "fastaFilesLength", "fastABufferCount", "fastaBufferLength", "fastaPageAddress", "fastAFileLength", "fastABufferLength", "fastaBufferCount", "fastAFileSize", "fastasHeaderAddress", "fastaPageName"], "fastaFileReadOffset": ["fastaFileLoadLength", "fastaFileLengthOff", "fastaFilesReadOffset", "fastaDirectoryReadOff", "fastaFilesReadLength", "fastaFileLoadoffset", "fastaFilesWriteOffset", "fastaBufferReadLength", "fastaFileReadAmount", "fastaFilesReadOff", "fastaFileStartOffset", "fastaFileStartOff", "fastaFilereadLength", "fastaFileRunoffset", "fastaDirectoryWriteOffset", "fastaDirectoryWriteEntry", "fastaFileLengthAmount", "fastaFileStartEntry", "fastaFileWriteEntry", "fastaDirectoryWriteOff", "fastaFileRunOffset", "fastaDirectoryReadOffset", "fastaFilesWriteoffset", "fastaFilereadOff", "fastaFileReadoffset", "fastaBufferReadAmount", "fastaFileRunEntry", "fastaBufferWriteOffset", "fastaFileReadEntry", "fastaFileWriteLength", "fastaBufferReadoffset", "fastaDirectoryReadEntry", "fastaFilereadoffset", "fastaFileWriteOff", "fastaFileLengthOffset", "fastaFileWriteAmount", "fastaFileReadLength", "fastaFileRunOff", "fastaFilesReadoffset", "fastaFilesWriteOff", "fastaDirectoryWriteoffset", "fastaFilesWriteLength", "fastaBufferWriteLength", "fastaBufferWriteAmount", "fastaFileWriteOffset", "fastaFileLengthoffset", "fastaFileStartoffset", "fastaBufferWriteoffset", "fastaFileLoadAmount", "fastaFilereadOffset", "fastaBufferReadOffset", "fastaDirectoryReadoffset", "fastaFileLengthLength", "fastaFileReadOff", "fastaFileWriteoffset", "fastaFileLoadOffset"], "partitionStartOffset": ["partitionStopOrder", "partitionStopOffset", "partitionStopOff", "partitionsStartOrder", "partitionEndOrder", "partitionBufferOffset", "partitionStartOrder", "partitionEndOff", "partitionsStartRange", "partitionEndRange", "partitionStartRange", "partitionBufferOff", "partitionStopRange", "partitionsStartOffset", "partitionsEndOrder", "partitionsEndOffset", "partitionsEndOff", "partitionsEndRange", "partitionBufferOrder", "partitionStartOff", "partitionsStartOff", "partitionBufferRange"], "bufferSize": ["queueSize", "BufferSize", " bufferType", "processC", "queueCount", "bufferType", "bufferC", "bufferSIZE", " bufferSIZE", "BufferCount", "BufferSIZE", "processSize", "processSIZE", "BufferC", "bufferCount", " bufferC", " bufferCount", "processType", "BufferType"], "fastaBuffer": ["fastaPtr", "FastaBuffer", "fastaaBuffer", "fastanChannel", "fastasStream", "FastaPtr", "fastAQueue", "fastasBuffer", " fastAQueue", " fastAFile", "fastaContainer", "fastanBuff", " fastaBuff", "fastAPtr", "FastasBuffer", " fastaContainer", "fastasFile", " fastasBuffer", "FastasBuff", "fastanPtr", " fastABuff", " fastasContainer", "fastABuff", "fastaceBuff", "fastasQueue", "fastABuffer", "fastasChannel", "fastanStream", "fastAFile", "FastaBuff", " fastaQueue", "fastaFile", "fastasBuff", "FastasStream", " fastasFile", " fastABuffer", "fastanContainer", "fastasPtr", " fastaFile", "fastanQueue", "fastanFile", "FastaChannel", "fastAContainer", "fastaBuff", "FastasPtr", "fastaaPtr", "fastaQueue", "fastaceChannel", "fastasContainer", "fastaceBuffer", "fastaaBuff", "FastasChannel", "FastaStream", "fastaStream", "fastaaStream", "fastAChannel", " fastAChannel", "fastacePtr", "fastanBuffer", " fastasChannel"], "fastaReadState": ["fastasReaderMode", "fastaFileState", "fastaFileMode", "fastaReaderState", "fastasReaderstate", "fastaReadingstate", "fastasReaderType", "fastasReadMode", "fastaReaderstate", "fastaReadMode", "fastaReadingMode", "fastaReaderType", "fastaFilestate", "fastaReadingState", "fastaReadstate", "fastaFileType", "fastaReadType", "fastasReadType", "fastaReaderMode", "fastasReaderState", "fastasReadstate", "fastaReadingType", "fastasReadState"], "nBytes": [" nFrames", "NParts", "obytes", "nByte", "lenFrames", "NByte", "pBytes", "pParts", "pbytes", "lenFiles", " nByte", "oBytes", " nParts", "Nbytes", "oFiles", "lenbytes", "nParts", "pByte", "numFrames", "lenBytes", "numBytes", "oParts", "NFiles", "numbytes", "nFiles", " nbytes", "nFrames", "NBytes", " nFiles", "numFiles", "nbytes"]}}
{"id1": "5998352", "id2": "755203", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testStandardTee": ["teststandardMae", "testStandardMae", "testStandardBeed", "teststandardMee", "testStandardTae", "testStandardBees", "testStandardFees", "testStandardFee", "testStandardMee", "testStandardBae", "teststandardTae", "teststandardMeed", "testStandardMeed", "testStandardTeed", "testStandardTees", "testStandardMees", "teststandardTees", "teststandardMees", "teststandardTee", "testStandardBee", "teststandardTeed", "testStandardFae", "testStandardFeed"], "reference": ["external", "address", "test", "pair", "url", "description", "primary", "re", "output", "proxy", "relative", "path", "request", "index", "distance", "target", "pointer", "location", "name", "string", "sequence", "filename", "binary", "archive", "memory", "length", "prefix", "c", "order", "database", "code", "format", "type", "connection", "report", "forward", "ference", "number", "directory", "Reference", "see", "REF", "hello", "specified", "message", "buffer", "attribute", "resource", "version", "uri", "copy", " Reference", "single", "document", "compatible", "server", "remote", "ref", "variable", "References", "rice", "collection", "relation"], "source": ["ource", "url", "result", "reader", "output", "e", "view", "io", "proxy", "input", "target", "temp", "string", "context", "driver", "Source", "fe", "code", "writer", "i", "ie", "r", "g", "connection", "object", "text", "parent", "config", "slice", "table", "buffer", "iter", "service", "resource", "copy", "se", "server", "ref", "src", "ce", "SOURCE"], "destination1": ["constinator1", "constination1", "destinator01", "DestinateOne", "destension0", "constinator01", "destension1", "destentionOnce", "destinate01", "destention1", "destaration0", "destributionOne", "destinateOnce", "destinator1", "destinatorOne", "DestinateOnce", "destinator2", "Destination1", "destinationOnce", "destination0", "DestinationOne", "destinationsOne", "Destension0", "destination01", "destinatorOnce", "destribution0", "destinate2", "Destension1", "Destinate1", "destinations2", "constinationOne", "destinations01", "destribution1", "destensionOne", "DestensionOne", "constination2", "Destination0", "constination01", "destentionOne", "constinatorOne", "destinationOne", "constinator2", "destarationOne", "destinateOne", "DestinationOnce", "destinations1", "destaration1", "destinate1"], "destination2": ["desticationSecond", "destication8", "coordinationSecond", "destignment2", "destationtwo", "descinationsSecond", "destication22", "descination02", "descination1", "destinations02", "Destinate4", "destination02", "destignment1", "destribution8", "destignmentSecond", "destinating4", "destribution22", "destribution2", "coordination8", "destication2", "destinate8", "destributionSecond", "destinationtwo", "destinate22", "destination22", "Destination4", "Destination1", "coordinate2", "destation1", "destinationsSecond", "destinatetwo", "destinatingtwo", "descinations1", "coordinate8", "destinateSecond", "destinationSecond", "Destinatetwo", "coordination22", "descinationSecond", "destinate2", "destation4", "Destinate1", "destinations2", "destination4", "Destination2", "destinate02", "descinations2", "destinating1", "coordination2", "coordinate22", "destinate4", "Destinate2", "destinating2", "Destinationtwo", "descination2", "destination8", "coordinateSecond", "descinations02", "destation2", "destignment02", "destinations1", "destinate1"], "tee": ["cec", "teae", "lei", "eeec", "ettef", "tec", " tei", " teae", "lef", "tei", "eeffe", "eee", "teea", "chei", "chef", "leec", "teee", "eeee", "sef", "etteee", "leffe", "lee", "TEea", "chepe", "chee", " teee", "seee", "TEe", " tec", " teffe", "TEee", "see", "ceee", "etteae", "seae", "lepe", "TEc", "tepe", "tef", "teec", "ettee", "cee", " tef", "teffe", "ceea", "leee", " tepe", " teec", " teea"]}}
{"id1": "11484416", "id2": "4686922", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"moveFile": ["moveDirectory", "moveFiles", " movedFile", " movePath", "movePath", " moveDirectory", " movedPath", "MovePath", "MoveFile", "MoveDirectory", " movedFiles", "MoveFiles", " movedDirectory", " moveFiles"], "orig": ["folder", "temp", "ctr", "exe", "raid", "proxy", "bin", "imag", "Orig", "old", "copy", "raf", "transform", "prev", "org", "buf", "dest", "impl", "coord", "original", "archive", "loc", "build", "comb", "frame", "init", "base", "tmp", "coll", "array", "f", "iter", "bas", "real", "ori", "home", "internal", "image", "remote", "ext", "img", "obj", "id", "info", "source", "src", "rb", "file", "origin"], "target": ["resource", "temp", " Target", "external", "project", "join", "current", "copy", "path", "manager", "platform", "match", "force", "this", "dest", "arget", "compatible", "object", "original", "ret", "archive", "template", "build", "it", "base", "replace", "tmp", "f", "eth", "auto", "format", "Target", "to", "remote", "result", "nt", "next", "reference", "t", "prot", "parent", "source", "master", "origin"], "buffer": ["resource", "position", "cache", "request", "uffer", "padding", "bin", "input", "copy", "layer", "wave", "feed", "sequence", "buf", "queue", "slice", "length", "content", "repeat", "address", "header", "batch", "frame", "base", "url", "read", "Buffer", "iter", "code", "bytes", "transfer", "result", "bb", "data", "write", "raw", "null", "b", "stack", "buff", "message", "source", "binary", "block", "file", "reference"], "bread": ["fe", "robe", "fee", "raft", "brew", "zip", "zero", "bat", "piece", "wen", "broken", "str", "buck", "abi", "beat", "bare", "feed", "key", "fle", "die", "bn", "design", "num", "cook", "div", "length", "inn", "bee", "eb", "good", "batch", "grain", "fine", "hello", "choice", "rib", "ffe", "wake", "circ", "fred", "bc", "fed", "fen", "four", "meal", "bb", "rub", "ble", "food", "fall", "fif", "web", "knife", "loop", "sleep", "cake", "width", "rows"], "fis": ["afIs", "lfis", "qos", "fxisa", "afis", "fxis", "his", "lfos", "qiss", "fils", " fIs", "qis", "fIs", " fiss", "ufos", "lfIs", "ufiss", "afiss", "ufis", "hIs", "fisa", "lfiss", " fils", "qils", "hisa", "afos", "fxIs", "fiss", " fisa", "hos", "ufils", "fxos"], "fos": ["Fros", "Foses", "flens", "flos", "fose", "gos", " foses", "infos", " fose", "gis", "infois", "goss", "faos", "Fors", "flors", "fros", "floses", "flose", "fens", "flois", "infors", "Fose", "flaos", "Fis", "Fois", "infaos", "foses", "Fos", "fois", "Foss", "Faos", " fros", " foss", "fors", "foss", " fens", "gros", "Fens"]}}
{"id1": "20623709", "id2": "20190303", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"split": ["Split", "append", "copy", "build", "cmp", "init", "sync", "part", "archive", "set", "sort", "run", "process", "add", "parse", "delete", "match", "exec", "share", "start", "diff", "transfer", "format", "update", "execute", "open", "join"], "targetDirectory": ["destFile", "targetFolder", "masterPath", "currentFolder", " targetDir", "targetDatabase", "currentRoot", "TargetDatabase", "targetDir", "targetPath", "baseDirectory", "destFolder", " targetRoot", "baseDir", "TargetRoot", "TargetFile", "outputFile", "destDir", "currentDir", "TargetDir", "outputDirectory", "TargetPath", "TargetDirectory", "targetFile", "currentPath", "currentDirectory", "outputDir", " targetPath", "outputFolder", "masterDir", "TargetFolder", "destDirectory", "masterDirectory", "baseDatabase", " targetFolder", "basePath", "masterDatabase", "baseFile", " targetFile", "baseFolder", "targetRoot"], "prefix": ["prot", "padding", "uri", "unit", "resource", "txt", "append", "offset", "username", "FIX", "sequence", "folder", "index", "template", "timeout", "type", "temp", "config", "directory", "filename", "number", "base", "queue", "cache", "string", "patch", " suffix", "name", "resolution", "ix", "fix", "pre", "domain", "root", "pattern", "path", "fixed", "first", "format", "fp", "Pref"], "maxUnitBases": ["maxUnitEases", "maxUnitAliases", "maxUnitChase", "maxUnitBase", "maxunitAliases", "maxUnitEaches", "maxUnitQueases", "maxunitAliasing", "maxunitAliails", "maxUnitQueasing", "maxUnitAliase", "maxUnitAliasing", "maxUnitChues", "maxUnitAliues", "maxUnitAliails", "maxunitBaches", "maxUnitBaches", "maxUnitEails", "maxUnitPlases", "maxunitBues", "maxUnitAliaches", "maxunitBases", "maxUnitPlase", "maxunitAliaches", "maxUnitBails", "maxunitAliase", "maxunitAliues", "maxUnitPlaches", "maxunitBase", "maxUnitBues", "maxunitBasing", "maxUnitEase", "maxUnitChasing", "maxUnitQueues", "maxUnitBasing", "maxUnitPlails", "maxunitBails", "maxUnitChases", "maxUnitQuease"], "maxUnitEntries": ["maxLineEntrations", "maxUnitEnties", "maxUnitEntryry", "maxLineOrdrations", "maxUnitAddresses", "maxUnitEntryures", "maxUnitOrdines", "maxUnitErries", "maxUnitEntryresses", "maxUnitIntresses", "maxunitEntries", "maxUnitEntryies", "maxUnitInties", "maxunitEnties", "maxLineEntines", "maxUnitEntines", "maxUnitEntryrys", "maxUnitOrdies", "maxunitEntrys", "maxUnitIntries", "maxLineOrdries", "maxLineEntry", "maxUnitCountries", "maxUnitAddries", "maxUnitEntry", "maxunitEntresses", "maxUnitErry", "maxUnitEntrations", "maxunitEntryresses", "maxUnitOrdrys", "maxUnitCountrations", "maxUnitEntresses", "maxUnitEntrys", "maxLineOrdry", "maxLineOrdines", "maxUnitOrdry", "maxUnitErines", "maxUnitAddures", "maxUnitOrdries", "maxUnitErrations", "maxunitEntryries", "maxUnitEntures", "maxLineEntries", "maxUnitOrdresses", "maxunitEntryies", "maxUnitOrdrations", "maxUnitCountry", "maxUnitIntrys", "maxunitEntryrys", "maxUnitEntryries", "maxUnitAddry", "maxUnitCountines"], "fis": ["forisa", "visa", "foris", "forai", " fiss", "foriss", "fisa", "Fris", "fris", "Fisc", "fai", " fIs", "Fiss", " fris", " fisa", "vai", "forIs", "fisc", "forisc", "forris", " fai", "fIs", "fiss", "vis", " fisc", "vIs", "Fis"], "fci": ["hci", "vcos", "efai", " fii", "fai", "dci", "dii", "hcos", "efco", "bis", "bco", "vai", "Fai", "vco", "Fci", "dco", "efcos", "hai", " foci", "bci", " fai", "foci", "bai", "vci", "Foci", "Fii", "Fco", "fii", "doci", "efci", "fcos", "Fis", "hco"], "fos": ["tis", "fo", "fso", "fscos", "Fos", "infos", "ifo", "Foss", "ifcos", "fsios", "infoss", "toss", "fios", " fo", " fcos", "ifios", "fsos", "tos", "infis", "ifos", "foss", "Foes", "foes", " fios", "infoes", "toes", "fcos", "Fis"], "fco": ["hgo", "dcos", "fileico", "Fbo", "Fico", " fro", "fro", "hci", " fgo", "fbo", "dro", "hcos", "filebo", "fileci", "dci", "fgo", "Fci", "dco", "fico", " fico", "fileco", " fbo", "lro", "lgo", " fcos", "lcos", "lco", "Fco", "fcos", "lci", "hco"], "buffer": ["border", "buf", "request", "pad", "writer", "resource", "message", "server", "image", "length", "copy", "null", "offset", "view", "info", "data", "scale", "Buffer", "bc", "channel", "entry", "document", "result", "input", "translation", "batch", "read", "timeout", "texture", "comment", "iter", "memory", "reader", "flush", "size", "header", "source", "buff", "expression", "capacity", "base", "bar", "queue", "position", "cache", "counter", "bin", "window", "loader", "binary", "reference", "device", "pause", "layer", "response", "uffer", "transfer", "context", "zero", "feed", "block", "callback", "rate"], "currentBasesCount": ["currentBasescount", "currentBasesNum", "currentBatchescount", "currentChasesCounter", "currentChasesNum", "currentBatchesCounter", "currentChasesCount", "currentBaseCount", "currentBaseCounter", "currentChasecount", "currentBasesCounter", "currentBasingCounter", "currentBasecount", "currentBasingNum", "currentChasescount", "currentBatchesCount", "currentBaseNum", "currentBatchesNum", "currentChaseCounter", "currentBasingcount", "currentChaseNum", "currentBasingCount", "currentChaseCount"], "currentEntriesCount": ["currentEntursOffset", "currentEntriesOffset", "currentEntursLimit", "currentAddriesOffset", "currentEntriesSize", "currentEnturesOffset", "currentEntrasCount", "currentEntursCount", "currentEntrasLimit", "currentAddriesLimit", "currentAdduresCount", "currentEnturesCount", "currentEntrasOffset", "currentAdduresOffset", "currentAdduresSize", "currentEntrasSize", "currentAdduresLimit", "currentEntursSize", "currentEnturesSize", "currentEnturesLimit", "currentAddriesSize", "currentEntriesLimit", "currentAddriesCount"], "targetCount": ["targetSum", "patternSize", "targetcount", "patternCount", "TargetSize", "TargetSum", "argetSum", "argetcount", "patterncount", "Targetcount", "patternSum", "argetSize", "TargetCount", "argetCount", "targetSize"], "fastaChannel": ["fastasChannel", "fastasContext", "fastaqBuffer", "fastasContainer", "fastanContext", "fastasConnection", " fastaContext", " fastABuffer", "fastaqConnection", "fastaConnection", "fastasBuffer", "fastAConnection", "fastaqColumn", " fastAColumn", "fastaqChannel", "fastaContainer", "fastanBuffer", "fastABuffer", " fastAConnection", "fastaColumn", "fastAContext", " fastaConnection", "fastAChannel", " fastAChannel", " fastaColumn", "fastAContainer", " fastAContext", " fastAContainer", " fastaContainer", "fastanChannel", "fastasColumn", "fastanContainer", "fastaContext", "fastAColumn"], "totalSeqCount": ["totalSeqCounter", "totalQueqCount", "totalQueQNum", "totalSeuxNum", "totalSeQCount", "totalQueQcount", "totalSeqcount", "totalSeqsCounter", "totalSeQCounter", "totalSeQcount", "totalQueQCounter", "totalQueqcount", "totalQueqNum", "totalSeuxcount", "totalSeuxCount", "totalQueqCounter", "totalSeuxCounter", "totalSeqNum", "totalSeQNum", "totalSeqsCount", "totalSeqsNum", "totalQueQCount", "totalSeqscount"], "totalResiduesCount": ["totalResiduingNum", "totalResiduesSize", "totalResiduescount", "totalResqueuesNum", "totalResiduingCount", "totalResqueuescount", "totalResqueuresNum", "totalResiduationSize", "totalResqueurescount", "totalResiduationNum", "totalResiduresNum", "totalResiduationCount", "totalResiduationcount", "totalResiduingcount", "totalResqueuresSize", "totalResidurescount", "totalResiduresCount", "totalResiduesNum", "totalResqueuesSize", "totalResqueuresCount", "totalResqueuesCount", "totalResiduingSize", "totalResiduresSize"], "prevTime": ["PrevSize", "PrevValue", "commitSize", "commitFile", " prevSize", "PrevTime", "commitValue", " prevFile", "PrevFile", "prevFile", "commitTime", "prevValue", " prevValue", "prevSize"], "fastaFileSize": ["fastaBlockLength", "fastaBlockCount", "fastaPageAddress", "fastABufferAddress", "fastAFileSize", "fastaHeaderLength", "fastasFileSize", "fastAFileLength", "fastaLineCount", "fastAFileAddress", "fastaHeaderAddress", "fastAFileCount", "fastABufferLength", "fastaBlockSize", "fastaFilesLength", "fastaBufferSize", "fastaFileAddress", "fastasFileAddress", "fastaHeaderName", "fastasHeaderSize", "fastaHeaderSize", "fastaPageName", "fastaLineLength", "fastaFileName", "fastaBufferAddress", "fastaBlockAddress", "fastaFilesSize", "fastasHeaderLength", "fastaLineAddress", "fastasHeaderAddress", "fastaLineSize", "fastABufferSize", "fastABufferCount", "fastaFilesName", "fastasFileLength", "fastaBufferCount", "fastaFileLength", "fastaPageSize", "fastasHeaderName", "fastaBufferLength", "fastaFilesAddress", "fastasFileName", "fastaPageLength", "fastaFileCount"], "fastaFileReadOffset": ["fastaFileWriteAmount", "fastaFileRunEntry", "fastaDirectoryWriteOffset", "fastaDirectoryReadOffset", "fastaFileWriteoffset", "fastaFileLoadAmount", "fastaBufferReadOffset", "fastaBufferReadoffset", "fastaFilesWriteLength", "fastaFileStartOff", "fastaFileRunoffset", "fastaFileReadoffset", "fastaFileReadLength", "fastaFileLengthLength", "fastaFilesReadoffset", "fastaFileWriteEntry", "fastaFilesReadOffset", "fastaFileLoadoffset", "fastaBufferReadAmount", "fastaBufferWriteOffset", "fastaFileReadOff", "fastaBufferWriteoffset", "fastaFileWriteOff", "fastaDirectoryReadEntry", "fastaFilesReadLength", "fastaFilesWriteoffset", "fastaDirectoryWriteOff", "fastaFileRunOff", "fastaBufferReadLength", "fastaFileLengthOffset", "fastaFileWriteOffset", "fastaFilereadoffset", "fastaFilereadLength", "fastaFileLoadOffset", "fastaFilesWriteOff", "fastaFileWriteLength", "fastaFileStartoffset", "fastaDirectoryWriteEntry", "fastaFileStartOffset", "fastaFileReadAmount", "fastaDirectoryReadoffset", "fastaDirectoryReadOff", "fastaFilereadOffset", "fastaFileLengthoffset", "fastaFileLoadLength", "fastaFileRunOffset", "fastaFilesReadOff", "fastaFileReadEntry", "fastaFilesWriteOffset", "fastaDirectoryWriteoffset", "fastaFileLengthOff", "fastaFileStartEntry", "fastaBufferWriteAmount", "fastaFileLengthAmount", "fastaFilereadOff", "fastaBufferWriteLength"], "partitionStartOffset": ["partitionsStartRange", "partitionEndOff", "partitionBufferOff", "partitionStartOff", "partitionsStartOrder", "partitionsEndOff", "partitionStopRange", "partitionBufferOrder", "partitionEndRange", "partitionsEndRange", "partitionsStartOffset", "partitionStopOrder", "partitionBufferRange", "partitionEndOrder", "partitionStopOff", "partitionStartOrder", "partitionStartRange", "partitionsEndOffset", "partitionsStartOff", "partitionBufferOffset", "partitionStopOffset", "partitionsEndOrder"], "bufferSize": ["BufferC", " bufferSIZE", "bufferC", "processC", "BufferSIZE", "processSIZE", "queueSize", "bufferType", "BufferSize", "BufferCount", "BufferType", " bufferCount", "bufferSIZE", "bufferCount", "processType", "queueCount", " bufferType", "processSize", " bufferC"], "fastaBuffer": ["fastasChannel", "FastaBuff", " fastABuff", " fastaBuff", "fastasContainer", "fastasPtr", "fastaaPtr", "fastanFile", "FastasPtr", "FastaStream", "fastAQueue", "fastasFile", "FastaBuffer", " fastasChannel", "fastaQueue", " fastABuffer", "fastaFile", " fastaFile", "fastaStream", "fastAFile", "fastaaBuff", "fastasBuffer", "FastasChannel", "fastanPtr", " fastAQueue", "fastanQueue", "fastaPtr", " fastAFile", "fastaceBuff", "fastaceChannel", "fastaContainer", "fastaaBuffer", "FastaPtr", "fastanBuffer", "FastasBuff", "fastABuffer", "fastasStream", "FastasBuffer", "fastAPtr", " fastasFile", " fastasContainer", "fastAChannel", " fastAChannel", "fastanStream", "fastasBuff", "fastaceBuffer", " fastasBuffer", "fastAContainer", "fastasQueue", "FastasStream", "fastaBuff", " fastaContainer", "fastanChannel", "fastABuff", "fastanBuff", "FastaChannel", "fastaaStream", "fastanContainer", "fastacePtr", " fastaQueue"], "fastaReadState": ["fastasReadstate", "fastasReaderState", "fastaReaderstate", "fastasReaderMode", "fastaReadstate", "fastaReadingState", "fastaReaderState", "fastaReadMode", "fastasReadType", "fastaFileMode", "fastasReadMode", "fastaFileState", "fastaReadingType", "fastasReaderType", "fastaReadType", "fastaReaderMode", "fastasReadState", "fastaFileType", "fastaFilestate", "fastaReaderType", "fastasReaderstate", "fastaReadingstate", "fastaReadingMode"], "nBytes": ["nFrames", " nParts", "obytes", "pbytes", "numFrames", "nFiles", " nFiles", "oParts", "pBytes", "numBytes", "NBytes", "oBytes", "NParts", " nbytes", "lenFrames", "lenbytes", "oFiles", "NByte", " nFrames", "pParts", "Nbytes", "lenFiles", "pByte", "nByte", "nbytes", " nByte", "NFiles", "nParts", "numbytes", "lenBytes", "numFiles"]}}
{"id1": "21152728", "id2": "1097147", "code1": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"authenticate": ["Authenticate", "authication", " authenticated", "authicating", " authentication", " authenticating", "authicate", "authenticating", "Authentication", "Authenticated", "authentication", "Authenticating", "authenticated", "authicated"], "module": ["method", "class", "base", "address", "input", "server", "course", "element", "resource", "pin", " Module", "entry", "vm", "lock", "site", "message", "project", "table", "py", "mode", "instance", "modules", "mission", "manager", "query", "domain", "Module", "cm", "rule", "member", "connection", "component", "pm", "model", "str", "scope", "config", "data", "file", "require", "object", "mi", "device", "conn", "plugin", "msg", "name", "header", "m", "io", "chain", "prefix", "role", "ctx", " modules", "unit", "script", "mod", "service"], "rand": ["push", "max", "sum", "gd", "round", "token", "rc", "rage", " random", "han", "ro", "in", "pattern", "alpha", "Rand", "gram", "rot", "chance", "bird", "seed", "min", "r", "out", "nd", "rar", "gen", "conn", "init", "raid", "grad", "bot", "auth", "NG", "reg", "range", "random", "right", "ng", "pad", "crypt", "dd", "re", "winner"], "challenge": ["passge", " challge", "chalenge", "challise", "chalise", "passenge", "buckchall", "buckonge", "chge", "challaine", "Challonge", "passise", "schege", " challonge", "chaine", "chalge", "Challise", "scheaine", "chenge", "scheise", "Challchall", "challchall", "buckenge", "scheenge", "challenges", "Challenge", "Challaine", "challonge", "buckge", "Challge", "chise", "passenges", "chalenges", "scheenges", " challchall", "challge"], "b64": [" b4", "mb16", "base62", "bb16", "b4", "mb4", " bbl", "mb64", " b36", "basebl", "base64", "b58", "base36", "base58", "B64", "mb58", "b16", "bb36", "base48", "xb62", "B4", "xb64", "xb48", " b48", " b16", "B16", "bb64", "bb58", " b62", "B58", " b58", "bbl", "b62", "base16", "b36", "b48", "xbbl"], "reply": ["remote", "string", "info", "address", "base", "buffer", "server", "reason", "replace", "uri", "reset", "id", "report", "http", "entry", "message", "py", "result", "answer", "write", "query", "queue", "next", "sync", "part", "back", "resp", "connection", "ridge", "Reply", "data", "body", "text", "out", " replies", "route", "request", "rr", "template", "related", "frame", "link", "prefix", "received", "service", "respond", "Response", "secret", "comment", "parse", "range", "repl", "error", "voice", "notice"], "user": ["string", "address", "pin", "id", "resource", "token", "username", "server", "entry", "lock", "replace", "by", "author", "USER", "character", "project", "uid", "User", "result", "per", "account", "profile", "match", "host", "write", "query", "manager", "pass", "key", "using", "password", "client", "allow", "type", "use", "source", "users", "cover", "proxy", "session", "date", "rule", "login", "open", "parent", "data", "text", "used", "route", "out", "request", "object", "device", "plugin", "creator", "name", "force", "word", "full", "person", "role", "service", "ver", "url", "bug", "secret", "me", "comment", "consumer", "error", "field", "valid"], "response": ["string", "respons", "address", "server", "resource", "uri", "output", "token", "message", "description", "version", "json", "profile", "result", "answer", "account", "host", "password", "session", "resp", "connection", "model", "data", "body", "request", "object", "format", "header", "status", "url", "respond", "Response", "secret", "error", "service", "api"], "secrets": ["secredits", "SECret", "secards", "SECurs", " secredits", "Secards", "regurs", "secures", "securs", "securityures", "regards", "regrets", "SECures", "regret", "Secrets", "SECrets", "subrets", "securityurs", "SECards", "Secredits", "Securs", "subret", "securityret", "subredits", "secret", "Secures", "securityrets", " secret", "Secret"], "md4": ["md6", "mc6", "MDfour", " md44", "mc5", "madfour", "md5", "mad2", "md04", "mad256", "mc4", "sha4", "mcfour", "MD04", " mdfour", "mad04", "shafour", " md256", "md2", "MD6", " MD6", "sha6", " md6", "sha2", " MD4", " md5", "md256", " md04", " MDfour", "MD2", " md2", "MD4", " MD2", "mad4", "sha5", "md44", "MD44", "sha44", "MD256", "mdfour", "sha04"], "line": ["letter", "string", "lo", "server", "lf", "lock", "entry", "message", "profile", "LINE", "end", "l", "shell", "look", "record", "pass", "sync", "part", "rule", "lines", "lc", "value", "model", "str", "data", "file", "body", "text", "out", "cl", "page", "object", "le", "log", "row", "inline", "style", "name", "header", "frame", "status", "link", "strip", "url", "pe", "parse", "lin", "Line", "comment", "range", "block", "error", "definition", "code", "cell"], "passwd": ["passWD", "pWD", "pw", "passpass", "passwordpass", "asswd", "Passwd", "PassWD", "ppass", "passpassword", "assw", "password", "Passpass", "passw", "Password", "Passpassword", " passpass", "passwordpassword", "pwd", "passwordword", "asspass", "passwordwd", " password", "Passw", " passpassword", "assWD"], "hash": ["base", "sum", "her", "id", "server", "version", "kh", "hex", "Hash", "html", "match", "tag", "ash", "key", "cache", "rh", "cover", "sha", "value", "build", "body", "check", "h", "object", "flash", "style", "header", "image", "hed", "array", "ha", "url", "sh", "secret", "shadow", "sign", "block"]}}
{"id1": "21010945", "id2": "4938100", "code1": "    private static List runITQLQuery(String itqlQuery) throws Exception {\n        String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\");\n        String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery;\n        logger.debug(\"url for risearch query: \" + url);\n        URL urlObject = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) urlObject.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        logger.debug(\"response code: \" + con.getResponseCode());\n        if (con.getResponseCode() != 200 && con.getResponseCode() != 302) {\n            throw new FedoraAccessException(\"Could not access the risearch service at url: \" + url);\n        }\n        ArrayList arrayList = new ArrayList();\n        String inputLine;\n        int counter = 0;\n        while ((inputLine = br.readLine()) != null) {\n            logger.debug(\"reading line:\" + inputLine);\n            if (inputLine.indexOf(\"<html>\") >= 0) {\n                logger.error(\"problem quering the relationship\");\n                throw new Exception(\"Problem querying relationships; probably a bad ITQL query:\" + itqlQuery);\n            }\n            if (counter >= 1 && inputLine.indexOf(\"/\") >= 0 && inputLine.trim().length() > 0) {\n                logger.debug(\"adding line:\" + inputLine);\n                inputLine = inputLine.substring(inputLine.indexOf(\"/\") + 1);\n                arrayList.add(inputLine);\n                logger.debug(\"found relationship to item: \" + inputLine);\n            }\n            counter++;\n        }\n        br.close();\n        logger.debug(\"num relationships found: \" + arrayList.size());\n        return arrayList;\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"runITQLQuery": ["runItQLquery", "runITQLString", "runITQQuery", "runITQRequest", "runITqlString", "runITqlRequest", "runITSQLRequest", "runItQLQuery", "runITQString", "runITQLquery", "runItqlRequest", "runITSQLString", "runITqlQuery", "runItqlString", "runItQLRequest", "runITQquery", "runITqlquery", "runItQLString", "runItqlquery", "runITSQLQuery", "runITSQLquery", "runITQLRequest", "runItqlQuery"], "itqlQuery": ["itsqlRequest", "itsqlStatement", "ItqlString", "itsqlCommand", "itqlCommand", "itsqlquery", "itqlquery", "itQLRequest", "ItqlCommand", "itsqlQuery", "itwlRequest", "itwlquery", "itwlCommand", "itqlString", "ItsqlRequest", "itQLString", "pitSQLQu", "ItqlQuery", "itSQLQu", "ItqlStatement", "itSQLquery", "ItqlRequest", "Itsqlquery", "pitSQLString", "itSQLString", "pitqlQu", "ItsqlQuery", "itqlQu", "ItsqlString", "itQLQuery", "itsqlString", "itwlQuery", "itSQLStatement", "pitSQLquery", "pitqlString", "itqlStatement", "itSQLQuery", "ItsqlCommand", "pitqlQuery", "pitSQLQuery", "itQLquery", "itQLCommand", "ItsqlStatement", "Itqlquery", "itsqlQu", "pitqlquery", "itQLQu", "itqlRequest", "itQLStatement"], "escapedItqlQuery": ["escapedItQLString", "escapedItqlString", "escapedItqRequest", "escapedItqString", "escapedITqlquery", "escapeditqlRequest", "escapedItqlquery", "escapedItQLQu", "escapedItsqlString", "escapedItsqlQu", "escapeditqlString", "escapedITqlQuery", "escapeditqlquery", "escapedItQLquery", "escapedItqQu", "escapedITsqlRequest", "escapedItqlRequest", "escapedItsqlRequest", "escapedItqquery", "escapeditQLQuery", "escapedITsqlquery", "escapedItqlQu", "escapedItsqlquery", "escapeditqlQuery", "escapedItqQuery", "escapedITqlQu", "escapedItQLRequest", "escapeditQLRequest", "escapedITsqlQu", "escapeditQLString", "escapedItsqlQuery", "escapedITqlRequest", "escapedItQLQuery", "escapeditQLquery", "escapedITsqlQuery"], "url": ["resource", "route", "string", "host", "href", "method", "request", "xml", "http", "service", "www", "response", "URL", "path", "ll", "ur", "feed", "Url", "email", "download", "impl", "rl", "address", "build", "lr", "loc", "l", "rule", "connection", "base", "server", "location", "coll", "config", "sl", "f", " URL", "q", "el", "image", "page", "ssl", "html", "obj", "id", "pattern", "uri", "buffer", "large", "org", "name", "file", "lc"], "urlObject": ["urlNumber", "URLOb", "UrlURL", "UrlObject", "urlObj", "Urlobject", "URLObject", "URLobject", "UrlObj", " urlURL", "urlobject", "httpURL", "httpNumber", "httpObject", " urlOb", " urlobject", "UrlNumber", "UrlOb", "httpObj", "urlOb", "urlURL", " urlObj", " urlNumber"], "con": ["ch", "ctrl", "pc", "ver", "fc", "cm", "acon", "c", "Connection", "http", "cons", "Conn", "inner", "func", "conv", "core", " connection", " CON", "xc", "can", "open", "co", "Connect", "cf", "ct", "bn", "client", "ran", "conn", "min", "cr", "cl", "connection", "part", "rc", "cn", "ocon", "exec", "coll", "syn", "bc", "fac", "enc", "non", "CON", "Con", "uc", "close", "res", "obj", "en", "conf", "nc", "ec", " conn", "sub", "connect", "inc", "un", "dec"], "br": ["Br", "ch", "ctr", "bh", "ver", "fore", "grab", "ob", " reader", "cm", "http", "str", "fin", "response", "io", "sr", "buf", "bro", "BR", "tr", "conn", "bridge", "gr", "cro", "er", "mr", "lr", "p", "cr", "err", "browser", "bl", "rc", "arr", "dr", "fac", "bc", "Reader", "bar", "res", "result", "runner", "reader", "output", "data", "hr", "obj", "r", "b", "buffer", "stream", "form", "rb", "fr"], "arrayList": [" arrayGroup", "elementList", "arrayArray", " arrayChain", " arrayTree", "inputGroup", "elementChain", "inputArray", " arrayArray", "areaChain", "elementTree", " arrayClient", "arrayTree", "inputClient", "arrayClient", "arrayGroup", "areaGroup", "areaClient", "arrayChain", "inputList", "elementArray", "areaArray", "areaList", "areaTree"], "inputLine": ["imageline", "currentLine", "interfaceFile", "rawL", " inputline", "issueLINE", "inputString", "currentline", "issueBlock", "currentString", "imageLINE", "outputPage", "imageDir", "InputLetter", "InputBlock", "inputBlock", "inputline", "inputLetter", "InputPage", "inFile", "InputLu", "InputString", "uploadline", "workFile", "Inputline", "inputFile", "uploadLin", " inputFile", " inputString", "inputL", " inputLINE", "currentFile", "imageL", "inputList", "inputPage", "interfaceLu", "rawBlock", " inputLin", "inline", "workLine", " inputList", "uploadPage", "currentBlock", " inputL", "imageLin", "inL", "inputLu", "InputFile", "imageList", "inputLINE", "workline", "qaL", "rawPage", "rawline", "qaFile", "inputLin", "InputLine", "rawLine", " inputDir", " inputLetter", " inputPage", "outputline", "currentL", "uploadLine", "imageBlock", " inputLu", "rawLin", "imageLine", "qaLine", "interfaceline", "issueLine", "issueList", " inputBlock", "inputDir", "qaLetter", "inLine", "InputL", "outputLin", "outputLine", "interfaceLine", "InputDir"], "counter": ["entry", "ctr", "ctrl", "ver", "cmp", "function", "c", "instance", "ter", "step", "cache", "inter", "currency", "cover", "inner", "continue", "trace", "time", "sum", "outer", "key", "number", "num", "cre", "second", "repeat", "child", "Counter", "nr", "handler", "count", "default", "server", "cur", "rew", "loader", "processor", "index", "field", "code", "controller", "i", "stop", "center", "result", "page", "type", "stack", "pattern", "offset", "loop", "info", "parent", "race", "name", "lc"]}}
{"id1": "6190356", "id2": "21182766", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldmd512", " hashPasswordForOldmd4", " hashPasswordForNewM4", " hashPasswordForOldmd3", " hashPasswordForOldMC512", " hashPasswordForOldMC5", " hashPasswordForOldMD512", " hashPasswordForNewMD4", " hashPasswordForOldM4", " hashPasswordForOldM5", " hashPasswordForNewMD512", " hashPasswordForOldMD4", " hashPasswordForOldMD3", " hashPasswordForOldM512", " hashPasswordForNewMD5", " hashPasswordForNewMD3", " hashPasswordForOldmd5", " hashPasswordForNewM512", " hashPasswordForNewM5", " hashPasswordForOldMC3", " hashPasswordForOldMC4", " hashPasswordForNewM3", " hashPasswordForOldM3"], "password": ["account", "pad", "buffer", "words", "p", "crypt", "key", "pattern", "input", "sword", "phrase", "address", "result", "padding", "Password", "code", "content", "array", "path", "message", "word", "value", "wd", "pass", "wallet", "data", "token", "secret", "text", " passwords", "name", "auth", "string", "seed", " Password", "encrypted", "hash", "PASS", "username"], "md": ["km", "mm", "mac", "mo", "clean", "ind", "m", "Cmd", "dig", "grad", "pg", "managed", "pd", "metadata", "um", "cd", "ma", "od", "dc", "rm", "amd", "mb", "nm", "df", "wd", "gd", "mand", "bd", "f", "dm", "pm", "mt", "MD", "di", "mp", "mc", "hd", "mag", "mod", "d", "rpm", "vd", "am", "meta", "cmd", "dd", " MD", "vm", "hm"], "messageDigest": ["messageDester", " messageDigEST", "messageAddse", "messageDEST", "messageDest", "messagedigester", " messageModester", "messageDigester", "messageDse", "messagedigEST", " messageDigester", "MessageDigEST", "MessageModse", "MessageModEST", "messageAddester", "MessageDigest", "messageDigEST", " messageModEST", "MessageAddester", "messageModests", "MessageModester", "messageAddEST", "MessageAddse", "messagedigse", "MessageDigse", "messageAddest", "MessageModest", "messageDigests", " messageModests", "messageAddests", "messageDigse", "messagedigests", " messageDigests", " messageModest", "messageModse", "messageModEST", "messagedigest", "MessageAddEST", "MessageAddest", "messageModest", "MessageDigester", "messageModester"], "hexString": ["tempFile", " hexArray", "stringService", "octArray", "transformStr", "hashSection", " hexStr", "sumStr", "octStr", "tempFunction", "hexstring", "crossstring", "tempStr", "hexArray", " hexSection", " hexService", " hexFile", "hexFunction", "stringArray", "transformString", "hexSection", "crossStr", "hexFile", " hexFunction", "stringString", "sumString", "hashService", "transformArray", "hashString", "transformBuffer", " hexBuffer", "sumstring", "crossString", "hashArray", "hexBuffer", "stringSection", "hexStr", " hexstring", "sumFile", "hexService", "octBuffer", "tempString", "crossFunction", "tempstring", "octString"], "i": ["r", "ai", "ip", "m", "h", "p", "j", "n", "s", "multi", "fi", "ix", "slice", "e", "phi", "id", "ci", "t", "ui", "info", "length", "a", "index", "li", "ii", "io", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "b", "v", "ji", "oi", "di", "l", "d", "si", "qi", "uri", "I", "c"], "hex": ["ip", "h", "batch", "hello", "alpha", "bit", "full", "host", "form", "pattern", "default", "character", "serial", "nexus", "ex", "sex", "cache", "json", "cookie", "hack", "result", "format", "http", "exp", "path", "zero", "orig", "rh", "buff", "pack", "digit", "raw", "lit", "str", "pex", "oct", "letter", "binary", "none", "null", "data", "temp", "rex", "char", "comp", "transform", "text", "he", "pixel", "string", "utf", "hash", " Hex", "cmp", "shift", "length"]}}
{"id1": "1133123", "id2": "7458833", "code1": "            @Override\n            protected Reader openConnection(URL url) throws IOException {\n                try {\n                    if (limit != null) {\n                        limit.acquirePermit();\n                    }\n                    return super.openConnection(url);\n                } catch (InterruptedException e) {\n                    throw new IOException(e);\n                }\n            }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"openConnection": ["createChannel", "closeConn", "openConnector", "OpenConnect", "closeConnect", "createConnector", "OpenConnector", "OpenConn", "closeConnector", "openChannel", "openConnect", "OpenChannel", "closeChannel", "createConnect", "createConn", "OpenConnection", "createConnection", "openConn", "closeConnection"], "url": ["source", "buffer", "uri", "str", "path", "Url", "config", "f", "this", "link", "options", "l", "image", "loc", "data", "service", "object", "location", "resource", "proxy", "limit", "base", "name", "log", "bel", "null", "server", "host", "URL", "address", "sl", "connection", "channel", "el", "ll", "iter", "file", "ssl", "id", "http"]}}
{"id1": "14764852", "id2": "20100809", "code1": "    public HttpResponse<E> doRequest(HttpMethods method, HttpHeader[] headers, boolean auth, URI target, BlipMessagePart body) throws HttpRequestException {\n        HttpRequest<E> con = createConnection(method, target);\n        if (defaultHeaders != null) {\n            putHeaders(con, defaultHeaders);\n        }\n        if (headers != null) {\n            putHeaders(con, headers);\n        }\n        try {\n            if (auth && authStrategy != null) {\n                authStrategy.perform(con);\n            }\n            if (body != null) {\n                bodyGenerator.writeBody(con, body);\n            }\n            HttpResponse<E> res = execute(con);\n            return res;\n        } catch (IOException e) {\n            throw new HttpRequestException(\"Error executing request\", e);\n        }\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doRequest": ["DoResponse", "DoOperation", "runRequest", "doOperation", " doOperation", "doResponse", "doQuery", "DoQuery", "DoRequest", "runResponse", " doResponse", "runQuery", " doQuery", "runOperation"], "method": ["text", "source", "attr", "message", "mode", "uri", "port", "client", "METHOD", "path", "session", "head", "view", "project", "process", "record", "object", "resource", "format", "module", "transform", "class", "url", "subject", "name", "host", "header", "connection", "stream", "cl", "tr", "version", "request", "route", "crit", "ssl", "sign", "type", "Method", "content", "http"], "headers": ["frames", "relations", "workers", "types", "parts", "words", "writers", "lines", "ppers", "agents", "keys", "head", "ers", "ters", "groups", "options", "heads", "limits", "vals", "breakers", "caps", "resources", "names", "parents", "strings", "authors", "checks", "values", "qs", "boxes", "drivers", "params", "files", "docs", "members", "features", "header", "fields", "codes", "settings", "tails", "users", "properties", "blocks"], "auth": ["token", "authent", "port", "anon", "ac", "author", "config", "home", "info", "head", "pass", "uth", "conn", "aut", "act", "host", "password", "stat", "secure", "api", "guard", "oct", "upload", "header", "Auth", "arch", "lock", "enc", "acl", "auto", "ant", "block", "ssl", "art", "user", "parent", "type", "cb", "att", "http"], "target": ["source", "remote", "result", "uri", "current", "client", "port", "path", "root", "owner", "arget", "manager", "object", "Target", "resource", "location", "proxy", "next", "url", "base", "subject", "server", "host", "address", "ARGET", "connection", "external", "request", "route", "response", "href", "template", "parent", "context", "reply"], "body": ["text", "secret", "source", "message", " payload", "buffer", "media", "output", "port", "Body", "load", "config", "view", " bodies", "pass", " content", "one", "ODY", "odies", "data", " Body", "object", "resource", "binary", "proxy", "comment", "storage", "other", " object", " data", "url", "log", "b", "reason", "params", "code", "query", "connection", "header", "h", "lock", "stream", "full", "block", "file", "part", "response", "ob", " message", "plain", "db", " response", "content", "reply"], "con": ["xc", "uc", "client", "cf", "clean", "c", "ac", "cat", "ocon", "ca", "conn", "an", "cas", "connect", "pc", "ann", "conv", "col", "cos", "fac", "exec", "ran", "cr", "Con", "conf", "ch", "cur", "rc", "connection", "fn", "ain", "fa", "cond", "cp", "enc", "cons", "cm", "cl", "fc", "en", "un", "dom", "cn", "mc", "request", "crit", "CON", "ct", "co", "can", "dc"], "res": ["parts", "ret", "result", "ps", "cs", "re", "arr", "out", "s", "vals", "val", "resp", "data", "des", "req", "rs", "vs", "RES", "os", "qs", "params", "obj", "bs", "rep", "pres", "details", "resolution", "Res", "es", "pers", "r", "results", "err", "rel", "response", "js", "cons", "content"]}}
{"id1": "17786231", "id2": "21642215", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    private int addIDs(PeakListRow row, String name) {\n        {\n            BufferedReader in = null;\n            try {\n                String urlName = \"http://gmd.mpimp-golm.mpg.de/search.aspx?query=\" + name;\n                URL url = new URL(urlName);\n                in = new BufferedReader(new InputStreamReader(url.openStream()));\n                String inputLine, score = \"0\";\n                while ((inputLine = in.readLine()) != null) {\n                    String metaboliteID = \"\";\n                    if (inputLine.contains(\"href=\\\"Metabolites/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Metabolites/\") + 18, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Metabolites/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"Analytes/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"Analytes/\") + 15, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/Analytes/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    } else if (inputLine.contains(\"href=\\\"ReferenceSubstances/\")) {\n                        String[] dataScore = inputLine.split(\"</td><td>\");\n                        score = dataScore[0].substring(dataScore[0].indexOf(\"<td>\") + 4);\n                        metaboliteID = inputLine.substring(inputLine.indexOf(\"href=\\\"ReferenceSubstances/\") + 26, inputLine.indexOf(\"aspx\\\">\") + 4);\n                        urlName = \"http://gmd.mpimp-golm.mpg.de/ReferenceSubstances/\" + metaboliteID;\n                        inputLine = in.readLine();\n                        inputLine = in.readLine();\n                        String[] data = inputLine.split(\"</td><td>\");\n                        String molecularWeight = data[data.length - 1].replaceAll(\"&nbsp;\", \"\");\n                        row.setVar(GCGCColumnName.MOLWEIGHT.getSetFunctionName(), molecularWeight);\n                        break;\n                    }\n                }\n                in.close();\n                urlName = searchMetabolite(urlName);\n                if (urlName != null && urlName.contains(\".aspx\")) {\n                    url = new URL(urlName);\n                    in = new BufferedReader(new InputStreamReader(url.openStream()));\n                    while ((inputLine = in.readLine()) != null) {\n                        if (inputLine.contains(\"<meta http-equiv=\\\"keywords\\\" content=\")) {\n                            String line = inputLine.substring(inputLine.indexOf(\"<meta http-equiv=\\\"keywords\\\" content=\") + 37, inputLine.indexOf(\"\\\" /></head>\"));\n                            String[] names = line.split(\", \");\n                            for (String id : names) {\n                                if (id.contains(\"PubChem\")) {\n                                    id = id.substring(id.indexOf(\"PubChem\") + 8);\n                                    String pubChem = (String) row.getVar(GCGCColumnName.PUBCHEM.getGetFunctionName());\n                                    if (pubChem.length() == 0) {\n                                        pubChem += id;\n                                    } else {\n                                        pubChem += \", \" + id;\n                                    }\n                                    row.setVar(GCGCColumnName.PUBCHEM.getSetFunctionName(), pubChem);\n                                } else if (id.contains(\"ChEBI\")) {\n                                    id = id.substring(id.indexOf(\"ChEBI:\") + 6);\n                                    row.setVar(GCGCColumnName.ChEBI.getSetFunctionName(), id);\n                                } else if (id.contains(\"KEGG\")) {\n                                    id = id.substring(id.indexOf(\"KEGG:\") + 6);\n                                    row.setVar(GCGCColumnName.KEGG.getSetFunctionName(), id);\n                                } else if (id.contains(\"CAS\")) {\n                                    id = id.substring(id.indexOf(\"CAS:\") + 5);\n                                    row.setVar(GCGCColumnName.CAS2.getSetFunctionName(), id);\n                                } else if (id.contains(\"ChemSpider\") || id.contains(\"MAPMAN\") || id.contains(\"Beilstein:\")) {\n                                } else {\n                                    String synonym = (String) row.getVar(GCGCColumnName.SYNONYM.getGetFunctionName());\n                                    if (synonym.length() == 0) {\n                                        synonym += id;\n                                    } else {\n                                        synonym += \" // \" + id;\n                                    }\n                                    synonym = synonym.replaceAll(\"&amp;#39;\", \"'\");\n                                    row.setVar(GCGCColumnName.SYNONYM.getSetFunctionName(), synonym);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    in.close();\n                }\n                return Integer.parseInt(score);\n            } catch (IOException ex) {\n                Logger.getLogger(GetGolmIDsTask.class.getName()).log(Level.SEVERE, null, ex);\n                return 0;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": [" downloadStream", "downloadStream", "copyfile", "copyFile", "transferfile", "copyFiles", "transferFile", "copyStream", "transferStream", " downloadFiles", "downloadFiles", " downloadfile", "transferFiles", "downloadfile"], "downloadUrl": ["updateurl", "outputLine", "outputurl", "updateLine", "transferFile", "downloadURL", "transferurl", "updateUrl", "downloadLine", "transferURL", "outputUrl", "updateURL", " downloadURL", "downloadurl", "outputURL", " downloadLine", " downloadurl", "updateFile", "transferUrl"], "destinationFile": ["destporaryFiles", "destigrationFILE", "destoutputString", "DestinatingFILE", "destoutputImage", "destinatedFILE", "destinatedFile", "destigrationFile", "destporaryString", "destinatingFile", "DestinationFile", "DestinatingString", "destinatingFilename", "destinatingImage", "destporaryImage", "destigrationFiles", "DestinatingFiles", "destigrationFilename", "DestinationFILE", "DestinatingFilename", "DestinatingFile", "DestinationString", "DestinatingImage", "destinatingString", "destoutputFile", "destinatingFILE", "destinatedFilename", "destporaryFile", "destinationImage", "destinationFILE", "destinationFilename", "destoutputFiles", "destinationString", "DestinationImage", "destinatingFiles", "DestinationFiles", "DestinationFilename", "destinationFiles", "destinatedFiles"], "client": ["proxy", "url", "uri", "resource", "server", "call", "parent", "connection", "force", "remote", "ce", "method", "project", "session", "channel", "application", "connect", "cl", "conn", "plugin", "api", "config", "bird", "cli", "contact", "self", "Client", "queue", "cache", "https", "con", "c", "handler", "app", "service", "per", "cher", "get", "query", "http", "request"], "httpGet": ["HttpCreate", "ttpCall", "httpCall", "ttpSend", " httpSend", "ttpCreate", "resourcePut", "httpSend", "ttpGet", "HttpCall", "resourceCall", "httpPut", "resourceget", "HttpGet", " httpPut", "Httpget", "resourceGet", "HttpPut", " httpCall", " httpget", "httpCreate", "httpget", " httpCreate", "HttpSend"], "outputFile": ["outputFiles", "referencePath", "writeFile", "referenceFile", "targetDir", "writeStream", "inputFile", " outputPath", " outputDirectory", "targetFiles", " outputfile", "outputDirectory", "outfile", "outStream", "writePath", "outputPath", "referencefile", "targetFile", "inputDirectory", "inputDir", " outputFiles", "referenceStream", "targetDirectory", "outputDir", "outPath", "outFile", "inputFiles", " outputDir", "writefile", "outputfile"], "outputStream": ["inputSteam", "inputWriter", "outputStreamer", " outputSteam", " outputForm", "logWriter", "inputFile", "outputForm", "responseFile", "inputStreamer", "inputForm", "responseStream", "responseSteam", "outputWriter", " outputWriter", "logSteam", "logStream", "OutputWriter", " outputStreamer", "responseWriter", "OutputForm", "OutputStream", "OutputSteam", "outputSteam", "logStreamer", "OutputFile"], "response": ["resp", "respond", "report", "resource", "message", "image", "server", "Response", "connection", "body", "event", "data", "version", "session", "output", "application", "status", "document", "result", "reply", "error", "api", "queue", "object", "handler", "success", "relation", "json", "query", "generation", "collection", "http", "feed", "request", "ception", "received"], "entity": ["pe", "component", "attribute", "ity", "url", "unit", "resource", "e", "image", "server", "message", "volume", "body", "connection", "Entity", "item", "ce", "event", "data", "ie", "channel", "output", "model", "document", "entry", "result", "status", "application", "coll", "translation", "ent", "el", "xml", "instance", "element", "issue", "metadata", "source", "api", "media", "comment", "agent", " identity", "node", "object", "id", "cache", "email", "file", "machine", "service", "environment", "json", "content", "state", "collection"], "inputStream": ["downloadLength", "inputChannel", "inputSteam", " inputSteam", "InputLength", "childSteam", "audioSteam", "InputFile", "InputChannel", "outputStreamer", "outputstream", "selectFile", "inputFile", "childStream", "audiostream", "inputStreamer", "audioStream", "downloadSteam", "selectSteam", "inputLength", " inputStreamer", "Inputstream", "InputStreamer", "downloadstream", "childChannel", "audioStreamer", " inputFile", "childStreamer", " inputLength", " inputBuffer", "selectStream", "downloadStream", "outputSteam", "InputBuffer", "InputSteam", "inputBuffer", "outputChannel", "outputBuffer", "inputstream", " inputstream", "selectStreamer", "InputStream", " inputChannel"], "callback": ["proxy", "closure", "url", "CB", "message", "resource", "call", "connection", "Callback", "cell", "event", "fb", "back", "data", "sync", "func", "result", "batch", "clone", "cb", "band", "code", "cc", "plugin", "consumer", "future", "config", "ff", "backs", "cache", "handler", "loader", "behavior", "function", "wrapper", "state", "buffer", "collection", "processor"], "copiedLength": ["copiedlength", "copippedLength", "copodedWidth", "copyiedWidth", "copedBytes", "copodedSize", "copyingLength", "copyingCount", "copedSize", "copiedCount", "copyiedSize", "copyippedWidth", "copedLength", "copyinglength", "copixedBytes", "copiedBytes", "copyiedCount", "copyippedLength", "copodedLength", "copyingWidth", "copyiedLength", "copixedCount", "copyedLength", "copodedlength", "copyingSize", "copyiedlength", "copyiedBytes", "copippedlength", "copyingBytes", "copixedSize", "copixedLength", "copiedSize", "copedCount", "copyippedlength", "copippedWidth", "copippedSize", "copiedWidth", "copyedBytes", "copyedSize", "copyippedSize", "copyedCount"], "percentage": ["Percentance", "percentile", "Percentade", " percentages", "milade", " Percentages", " Percentance", "percentaged", " Percentile", "percentages", "milance", " percentance", "percentance", " percentade", " percentaged", "Percentaged", "milage", "Percentages", " Percentage", "Percentile", "percentade", " percentile", "milaged", "Percentage"]}}
{"id1": "11477906", "id2": "13499897", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadApplicationsettings", "getdefaultsettings", "loadDefaultsettings", "loadDefaultConfiguration", "getdefaultConfiguration", "getDefaultsettings", "loadApplicationConfiguration", "loaddefaultParameters", "getDefaultParameters", "loadDefaultParameters", "getDefaultSettings", "loadGlobalsettings", "loaddefaultSettings", "loaddefaultConfiguration", "getdefaultSettings", "getDefaultConfiguration", "loaddefaultsettings", "loadApplicationParameters", "getdefaultParameters", "loadApplicationSettings", "loadGlobalParameters", "loadGlobalSettings", "loadGlobalConfiguration"], "configFileName": ["configFilesName", "configFilenameLocation", "configFilesType", "configFileLocation", "configPlaceLocation", "configPlaceName", "ConfigModuleUrl", "ConfigFileString", "configPlaceString", "configFullUrl", "configFullString", "configModuleName", "configFileTime", "configModuleLocation", "fileFileLocation", "fileFILEName", "configFilesTime", "configFILETime", "ConfigModuleLocation", "configFILELocation", "configFILEName", "ConfigModuleName", "configModuleUrl", "configPlaceUrl", "configFilesLocation", "configFilenameType", "configFileType", "fileFILELocation", "configFileString", "ConfigModuleString", "configFilenameName", "configFilenameTime", "ConfigFileLocation", "configFullName", "ConfigFileUrl", "ConfigFileName", "configFullLocation", "fileFileTime", "fileFILEType", "fileFILETime", "configFileUrl", "fileFileType", "configModuleString", "fileFileName", "configFILEType"], "in": ["r", "m", "pin", "n", "inn", "stream", "is", "i", "socket", "init", "cin", "input", "id", "din", "conn", "plus", "diff", "a", "inner", "resource", "pull", "nin", "ssl", "con", "ini", "work", "config", "inside", "f", "url", "this", "pass", "base", "login", "data", "err", "log", "it", "ins", "pc", "bin", "In", "reader", "IN", "as", "again", "read", "source", "up", "inc"], "out": ["Out", "image", "timeout", "client", "writer", "error", "sync", "obj", "off", "one", "all", "output", "socket", "object", "view", "default", "s", "ou", "user", "instance", " back", "write", "copy", "parent", "version", "ex", "server", "t", "conn", "to", " file", "able", "connection", "exp", "ext", "io", "file", "config", " output", "f", "prefix", "o", "null", "exec", "lib", "set", "this", "data", "err", "log", "it", "net", "name", "bin", "password", "OUT", "string", "again", "and", "d", "point", "outs", "back", "up", "c", "inc"]}}
{"id1": "9109613", "id2": "20920051", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fileCopy": ["fileUpload", "folderTransfer", "foldercopy", "Filecopy", "fileTransfer", "folderUpload", "FileTransfer", " fileTransfer", " fileUpload", "folderCopy", "filecopy", "FileUpload", "FileCopy", " filecopy"], "from_name": ["fromTheword", " from_no", " from_space", "fromametime", "from_size", "from__Name", " from_key", "from_Name", "from_no", "fromTheName", "from_time", "fromFullname", "fromqName", "fromFullName", "from__name", " from_alias", "fromqname", "from_path", " from_Name", "from_address", "from_image", "from_alias", "from_filename", " from__alias", "fromFulladdress", " from_time", "from_key", " from__Name", " from_size", "fromThename", " from_image", " from__name", "from_word", " from__address", "fromameno", "from__alias", " from_path", "fromamename", "fromThespace", " from_filename", "fromqpath", " from_address", "fromameName", " from_resource", "from__address", "from_resource", "fromqfilename", "from_space", "fromFullalias", " from_word"], "to_name": ["To_common", "tokname", "to_path", "to_Name", "to_file", "to_names", "To_Name", "from_path", "to_common", "tokcommon", "from_names", "to_key", " to_file", "To_name", "tokName", "from_Name", " to_key"], "fromFile": ["asFile", "FromFile", "oneFile", "fromFolder", "oneDir", "FromLine", "onePage", " fromDirectory", " fromFunction", "sourcePage", "fromPage", "fromFiles", "onefile", "ofFolder", "fromPackage", "oneFunction", "FromFolder", "connectionFile", "autoPage", " fromPage", "toLine", "fromLine", "fromfile", "FromDir", "tofile", "oneModel", " fromFactory", "asFiles", "fromDir", " fromPackage", "oneFolder", "ofFile", " fromFolder", "fromLibrary", " fromFiles", "asfile", "fromModel", "sourceFile", "sourceLibrary", "autoFile", "asFactory", "Fromfile", "FromPage", "FromModel", "connectionPackage", "FromLibrary", " fromfile", " fromModel", "FromDirectory", "connectionfile", "sourceDirectory", "toFactory", "fromFactory", " fromLine", " fromDir", "autoFolder", "FromFiles", "ofPackage", "FromFunction", "connectionFolder", "fromDirectory", "toFiles", "fromFunction", "offile", "autofile", " fromLibrary", "toFunction"], "toFile": [" toFolder", "soPage", "fromFiles", "toLine", "ofTable", "targetfile", "tempFile", " toSourceFile", "toLibrary", "ToPlace", " toPage", "targetSourceFile", " toFunction", "ToDirectory", "toFiles", "nofile", "toPlace", "toFunction", "ofDir", "baseTable", " toFactory", "targetFolder", "noFile", "toTable", "TOPage", "coFile", "baseDir", "TOFile", "aDir", "targetPage", " toFiles", "sofile", "targetFactory", "soLibrary", "TOPlace", " toLine", " toTable", " toDirectory", "targetDir", "basefile", "targetFile", "noLibrary", "tempFolder", "fromDir", "afile", "Tofile", "ToLibrary", "toDir", "cofile", "toPage", "ToPage", "fromDirectory", "offile", "coFunction", "tempFactory", "toFolder", "toDirectory", "ToDir", "aFile", "targetPlace", "ToLine", " tofile", "fromPage", "fromLine", "noPage", "ToFiles", "fromfile", "tofile", "soFile", "ofFile", "ToFactory", "ToFile", "toSourceFile", "ToSourceFile", "aFiles", "ToFunction", "baseFile", "toFactory", " toDir", "tempfile", "coDirectory", "TODir"], "parent": ["address", "test", "pa", "port", "id", "inc", "path", "div", "session", "location", "name", "section", "g", "null", "directory", "option", "api", "p", "col", "data", "file", "server", "full", "Parent", "part", "pr", "complete", "client", "child", "term", "remote", "patch", "string", "or", "pe", "class", "user", "shape", "rule", "guard", "key", "page", "pool", "ac", "lc", "paren", "current", "valid", "pt", "parents", "large", "loc", "resource", "content", "search", "source", "home", "url", "master", "ip", "region", "exp", "owner", "out", "type", "connection", "root", "par", "any", "point", "line", "and", "manager"], "dir": ["url", "dec", "ver", "rel", "dep", "Dir", "exp", "dict", "inc", "container", "cur", "db", "path", "folder", "div", "keep", "name", "out", "ir", "lock", "doc", "lib", "build", "or", "r", "def", "root", "class", "directory", "attr", "rec", "DIR", "per", "loc", "block", "iter", "dc", "dis", "wd", "fd", "mod", "dr", "di", "col", "file", "dist", "d", "director", "coll", "die", "dev", "group", "cat", "home", "manager", "f"], "from": ["cm", "url", "de", "base", "ra", "client", "clean", "bean", "vol", "parse", "left", "e", "view", "ou", "io", "module", "when", "old", "one", "auto", "name", "conn", "out", "cr", "stream", "range", "start", "c", "link", "this", "self", "normal", "or", "component", "connection", "user", "so", "empty", "o", "with", "query", "per", "hand", "without", "flo", "fr", "wh", "api", "add", "by", "form", "get", "in", "who", "source", "channel", "file", "se", "ch", "low", "From", "con", "part", "can", "ce", "po"], "to": ["su", "two", "be", "eto", "base", "ver", "token", "cache", "output", "port", "io", "proxy", "not", "db", "one", "fb", "TO", "target", "auto", "out", "name", "on", "top", "no", "again", "tom", "or", "via", "type", "connection", "go", "b", "object", "To", "so", "o", "see", "co", "with", "sync", "flo", "office", "will", "api", "by", "plus", "copy", "store", "page", "http", "source", "op", "file", "too", "tto", "about", "until", "size", "fat", "pi", "po"], "buffer": ["Buffer", "address", "position", "result", "header", "uffer", "reader", "cache", "transfer", "feed", "vector", "available", "total", "default", "row", "border", "length", "string", "binary", "seed", "memory", "queue", "character", "read", "layer", "duration", "reference", "batch", "shape", "buf", "number", "null", "block", "padding", "table", "message", "iter", "resource", "bytes", "flush", "document", "page", "data", "channel", "server", "variable", "device", "value", "comment", "buff", "texture"], "bytes_read": ["classesavavailable", "bytesESSreceived", " bytes_load", "bytesavavailable", "classes_READ", "bytes___READ", "bytes_READ", "classes_available", "classesavview", " bytes_written", "lines_received", "classes_read", "lines_read", "bytesavview", "bytesavread", "classes_view", "bytesESSput", "bytes_available", "bytesESSread", "bytes_load", "lines_written", "bytes_received", " bytes_write", "bytes_put", "bytes_write", "bytes___view", "bytesavREAD", "bytesESSwritten", "bytes_written", "bytesayput", "lines_put", "bytes___read", "classesavREAD", "classesavread", "bytesayreceived", "bytesayread", "bytes_view", "bytesaywritten", "bytes___available"]}}
{"id1": "160739", "id2": "17580775", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "label": 0, "substitutes": {"createOutputStream": [" createOutputSteam", " createIOStream", " createInputSteam", " createByteFile", " createOutputFile", " createByteSteam", " createInputReader", " createIOSteam", " createByteReader", " createOutputReader", "createInputFile", " createInputFile", "createInputStream", " createIOFile", " createInputStream", "createOutputFile", "createInputSteam", " createByteStream", "createOutputReader", " createIOReader", "createOutputSteam", "createInputReader"], "inFile": ["outfile", "sourceFiles", "inputFile", "insfile", "sourcefile", "insFiles", "outFiles", "incStream", "inputStream", "infile", "inputFiles", "inStream", "sourceFile", "outStream", "insFile", "insStream", "incFiles", "inFiles", "inputfile", "incFile", "sourceStream", "incfile"], "outFile": ["outfile", "targetFile", "inDir", "workDir", "outDirectory", "workingFile", "inputFile", "outDir", "infile", "workingDirectory", " outDirectory", "workingfile", "workfile", "workTime", "workFile", "inTime", "outStream", "inputDir", "inputfile", "outTime", "inputTime", " outfile", "workingStream", " outStream", "targetfile", "targetDirectory", "targetStream"], "k_blockSize": ["k_byteLen", "k_blocksLength", "k_lineSize", "k_lockSize", "k_bitInfo", "k_blockCount", "k_blocksSize", "k_lockLen", "k_lockLength", "k_blockLength", "k_byteLength", "k_byteInfo", "k_lineCount", "k_blocksLen", "k_BlockCode", "k_byteCount", "k_BlockCount", "k_bitSize", "k_byteCode", "k_lineInfo", "k_lockCode", "k_byteSize", "k_blockCode", "k_blocksCount", "k_BlockSize", "k_BlockLength", "k_lockCount", "k_blockLen", "k_blockInfo", "k_bitCount"], "byteCount": ["blockSize", "byteSize", " byteSize", " byteLength", "byteLen", "blockCount", " bytecount", "Bytecount", "byteSum", "characterSize", "ByteLength", "flushcount", "blockLength", "flushLength", "ByteCount", "characterCount", "flushSize", "characterLen", " byteSum", "flushCount", "ByteSize", "ByteLen", "ByteSum", "characterLength", "byteLength", " byteLen", "blockSum", "bytecount"], "buf": ["background", "brace", "bh", "vec", "alloc", "cas", "append", "cv", "fd", "ctx", "feed", "queue", "la", "seq", "ucc", "loc", "batch", "bag", "base", "rc", "cmd", "tmp", "exc", "config", "Buffer", "len", "uf", "cap", "bytes", "cb", "border", "result", "img", "data", "feat", "Buff", "b", "fb", "buff", "flush", "bf", "buffer", "font", "src", "rb"], "ofp": ["OFnp", "Ofc", "Ofl", "Oft", "afl", "fort", "OFtp", "OFc", "afnp", "ofl", "forp", "afp", "Ofp", "Oftp", "afc", "ofnp", "Ofnp", "fortp", "ofc", "oft", "forc", "OFp", "OFl", "OFt", "oftp"], "zos": ["ses", "osi", "z", "iffs", "obb", "zig", "tz", "liquid", "obs", "webkit", "oda", "zyk", "gz", "zb", "soon", "zh", "zon", "nz", "robe", "js", "bs", "css", "zin", "cfg", "fits", "zn", "utils", "lol", "dylib", "zy", "oses", "zer", "zik", "rons", "zes", "za", "zona", "inos", "enos", "abi", "os", "outs", "packs", "iframe", "ZA", "oS", "los", "ls", "zx", "ops", "jas", "cos", "zar", "ws", "ZI", "zi", "lins", "forge", "owicz", "budget", "zers", "ozo", "ossus", "zen", "zip", "rez", "bitcoin", "bos", "zag", "nox", "bes", "uz", "zo", "ros", "hz", "ogl", "kos", "zl", "core", "modules"], "osw": ["osx", "isd", "eshell", "bswo", "bsws", "isnow", "eswd", "bws", "lsw", "ossd", "bx", "osssw", "esfw", "osd", "osswd", " osww", " osow", "esnow", "oswo", " osfw", "ishell", "isw", "esww", "osshell", "lsws", "esy", "isy", "ossy", "esow", "ossww", "esd", "oswd", "iswd", "ossow", "bwo", "bsx", "osfw", "ossnow", "ossfw", "oshell", "osww", "esw", "ossw", "osws", "osy", "osnow", "issw", "lsx", "essw", "lswo", "bsw", "osow"], "bw": ["bbew", "bz", "bbz", "ebW", "ebwe", "abwd", "owa", "lbwh", "lwa", "bws", "bwe", "lsw", "Bws", " bws", "lx", "ow", " bwa", "bx", "lbx", " bz", "fx", "bbws", "bwd", "fwh", "bbw", "bwa", "bbaw", "Bew", "lbsw", "Bw", "lw", "fbwd", " baw", "abwe", "owu", "oaw", "fw", " bew", "lbz", "bwu", "ebw", "bbwa", "ebwd", "bbwu", "abw", "lbwa", "lbws", "bwh", "Bwa", "lbw", "bew", "bbwh", " bwu", "bW", "fbw", "fbW", "baw", "fwa", "lbr", "fsw", "fbwe", "abW", " bwh", "fr", "bsw"], "zot": ["Ziot", "aziot", "Zot", "zori", "jot", "azit", "zerita", " zor", "zor", "jos", "jori", "zerit", "zeros", "zerott", "azor", "Zit", "zita", "jit", "ziot", "Zor", " ziot", "Zita", "azot", "Zott", "zerori", "zott", "zerot", "azita", " zori", "azott"], "ifp": [" ifc", "Ifc", "Ifi", "ifl", "ifb", "ifi", "ifc", " iff", "IFf", "IFp", " ifi", "ipl", "IFc", " ifb", "Iff", "IFb", "ipp", " ifl", "iff", "Ifp", "ipb", "IFi", "ipc", "IFl"], "zis": ["zits", "ziss", " zais", "zeip", "zais", "zip", "zeiss", "xIS", "zib", "jis", "zenis", "Ziss", "zipits", "zipis", " zits", " zisi", "zenIS", "zipip", "Zip", "jit", "xib", "zenais", "xisi", "xis", "xais", "xits", "Zits", "jisi", " zIS", "Zis", " zib", "zenib", "zeis", "zisi", "jits", "zipiss", "xit", "zIS", "zeits"], "isr": ["irr", "ISr", " issr", "ISrc", "ISsr", "irrb", "irpr", "isrb", "rispr", "irrc", "ispr", "risrc", "ISrb", "isrs", "isscr", "ISrs", "IScr", "risr", "ISpr", " isrs", "issrs", "isssr", "risrb", " iscr", "iscr", "issr", "isrc"], "br": ["Br", "ch", "ctr", "bh", "HR", "kr", "ob", "obl", "ocr", "str", " fr", "shr", "ber", "obi", "yr", "sr", "bro", "BR", "div", "bsp", "tr", "gr", " BR", "bp", "cro", "mr", "lr", "browser", "bl", "ibl", "err", "rib", " dr", "ibr", "arr", "sp", " Br", "bc", "bar", "img", "hr", "r", "b", "rs", "body", "rb", "fr"], "zit": [" zic", "zits", "zic", "jic", "zeitter", "zipith", "zipIT", "zip", " zip", "jita", "zenits", "jIT", "zeit", "zipit", "zeIT", "zenit", "zipits", " zits", "zIT", "ji", "zipip", "jite", "zita", "jit", " zith", "xic", "zeith", "zitter", "xith", "zith", "jith", "zenitter", "jip", " zite", "zenith", "zipita", "jits", "zite", "zi", "zipite", "xi", "xit", "zeita", "zipitter", " zi", "zeits"]}}
{"id1": "9275622", "id2": "22264586", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", "copyFolder", "movefile", " copyFolder", "moveFolder", "transferFolder", "transferFiles", "moveFiles", " copyfile", "moveFile", "transferFile", "copyfile", " copyFiles"], "_file1": ["_fileone", "_files01", "_files2", "_zipOne", "_zipFirst", "_File0", "_mail1", "_mail01", "_fileFirst", "_resourceOne", "_resourceone", "_fFirst", "_files0", "_fOne", "_fone", "_files1", "_File2", "_zipone", "_f1", "_mail2", "_File1", "_file01", "_mail0", "_resource1", "_File01", "_file0", "_resourceFirst", "_fileOne", "_zip1"], "_file2": [" _files4", "_play4", "_Filesecond", " _fileTwo", "_files2", "_playsecond", "_files4", "_file3", "_files3", "jmodel2", "_modelsecond", "_file5", "_play3", " _file4", "_play5", " _file3", " _filesTwo", "jfile5", "_File5", "jfile1", "jmodelsecond", " _files3", "_play1", " _files2", "_model2", "_File2", "_play2", "_fileTwo", "_File1", "_filesTwo", "_file4", "jfilesecond", "_model1", "_filesecond", "jmodel1", "jmodel5", "_playTwo", "_model5", "jfile2"], "fis": [" fiss", "fais", "cfis", "fris", "cfas", " fais", "lfais", "infis", "lfi", " fi", "Fris", "infiss", " fas", "Fos", "infils", "fils", "Fis", "fas", " fils", "afis", "cfiss", "afi", "lfis", "Fiss", "Fils", "lfiss", "Fas", "fiss", "afiss", "fi", "cfos", "cfris", "afais", "infos", " fris"], "fos": ["foes", "Fo", "feus", "infus", "gus", "fus", "gos", "infios", "Fros", "flis", "poes", "fOS", "feis", "Foos", "feos", " foos", "Fus", "Foses", " faos", "feoses", "Fos", "Fis", "fros", " fo", "infoos", "fios", "pis", "lOS", "info", "Fios", "infaos", "flOS", "floes", "lis", " fus", " fios", "infos", "goses", "los", "loes", "fo", "pOS", "infros", "gis", "flos", "foses", "pos", " fros", "faos", "Faos", "foos"], "canalFuente": ["canalFUente", "canaledFuze", "canalFuento", "canallBuence", "canallFuencia", "canalsBuencia", "canalFuze", "canaledBuze", "canaledBuente", "canallFuze", "canalSuestro", "canalFuence", "canalBuence", "canalFUze", "canalKuente", "canalKuento", "canalsBuence", "canalFUencia", "canalFuestro", "canallBuencia", "canalsBuento", "canalKuence", "canaledFuje", "canalFUestro", "canalCraencia", "canalBuze", "canaledFuestro", "canallFuence", "canalSuze", "canalsFuence", "canalFUje", "canaledFuente", "canalsFuencia", "canalBuje", "canalCraente", "canalBuento", "canalSuje", "canalsFuente", "canalBuente", "canalsFuento", "canaledBuje", "canalFuencia", "canalCraence", "canalKuencia", "canalCraento", "canallBuze", "canalKuze", "canallBuente", "canalBuestro", "canaledBuestro", "canalBuencia", "canallFuente", "canalFUence", "canalFuje", "canalSuente", "canalsBuente"]}}
{"id1": "20091126", "id2": "6403868", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"copy": ["exec", "call", "output", "transfer", "zip", "io", "Copy", "proxy", "put", "cp", "archive", "write", "upload", "Cop", "type", "cop", "join", "over", "p", "source", "process", "up", "file", "download", "cat", "open", "paste", "cmp"], "in": ["url", "base", "ins", "reader", "IN", "login", "bin", "id", "inc", "old", "index", "input", "ic", "In", "name", "inner", "image", "m", "or", "a", "i", "connection", "b", "again", "config", "query", "diff", "buffer", "min", "l", "data", "work", "file", "source", "lin", "ac", "part", "f"], "out": ["exec", "external", "v", "url", "result", "base", "OUT", "outs", "cache", "call", "output", "exp", "io", "x", "default", "target", "dot", "ext", "string", "name", "image", "write", "prefix", "off", "err", "c", "Out", "plain", "a", "i", "ex", "again", "parent", "object", "o", "buffer", "array", "p", "content", "point", "page", "data", "source", "file", "server", "channel", "value", "comment", "temp"], "inChannel": ["inClient", " inButton", "inputChan", " inchannel", "insChannel", "inChan", " inClient", "iniStream", "inputGate", "outChan", "winStream", "INClient", "inchannel", "outchannel", "outStream", "iniChan", "outButton", "inputStream", "inputchannel", "winchannel", " inStream", "INChan", "inGate", "INchannel", "winChannel", "inStream", "INChannel", " inChan", "INGate", "winChan", "iniChannel", "INStream", "insStream", "iniGate", "insClient", "inputButton", "inButton", "inputChannel", "INButton", "insChan"], "outChannel": ["inClient", "outClient", "outsChan", "outputStream", "Outchannel", "outputChan", "outContext", " outConnection", "outsChannel", "inChan", " outChan", "OutStream", "outputClient", "outputchannel", " outContext", "outChan", "inchannel", "outchannel", "outputChannel", "outStream", "OutClient", "outConnection", "outsConnection", "inStream", "outsStream", " outStream", "OutContext", "inConnection", " outchannel", "OutChan", "OutChannel", "inContext"]}}
{"id1": "20623709", "id2": "20991673", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "label": 0, "substitutes": {"split": ["open", "archive", "sync", "sort", "set", "match", "add", "copy", "format", "part", "share", "cmp", "parse", "build", "init", "run", "process", "exec", "Split", "delete", "update", "transfer", "diff", "join", "append", "execute", "start"], "targetDirectory": ["targetRoot", "targetFile", " targetRoot", " targetFolder", "destDir", "masterDir", "baseFile", "outputFile", "currentRoot", " targetFile", "targetDatabase", "masterDatabase", "TargetDir", "targetDir", "outputDir", "currentFolder", " targetPath", "basePath", "baseDatabase", "currentPath", "masterDirectory", "TargetDirectory", "TargetDatabase", "baseFolder", "TargetRoot", "baseDir", "TargetFolder", "targetPath", "destFile", " targetDir", "TargetPath", "destFolder", "masterPath", "TargetFile", "baseDirectory", "currentDir", "outputFolder", "currentDirectory", "outputDirectory", "destDirectory", "targetFolder"], "prefix": ["offset", "FIX", "sequence", "fixed", "name", "type", "first", " suffix", "timeout", "base", "ix", "prot", "format", "resolution", "cache", "Pref", "domain", "txt", "pre", "root", "patch", "temp", "padding", "template", "path", "filename", "pattern", "config", "number", "uri", "unit", "folder", "fix", "index", "resource", "queue", "append", "fp", "directory", "string", "username"], "maxUnitBases": ["maxUnitAliases", "maxUnitEaches", "maxunitBails", "maxunitBaches", "maxUnitChasing", "maxUnitChase", "maxUnitQueasing", "maxUnitAliails", "maxunitAliasing", "maxunitAliues", "maxUnitAliase", "maxunitAliaches", "maxunitAliase", "maxUnitQueues", "maxUnitEails", "maxUnitPlases", "maxUnitEase", "maxunitBues", "maxUnitQueases", "maxUnitPlaches", "maxUnitPlails", "maxUnitQuease", "maxUnitChases", "maxUnitBaches", "maxUnitAliaches", "maxUnitPlase", "maxUnitEases", "maxunitAliails", "maxUnitChues", "maxUnitBues", "maxUnitAliues", "maxUnitBasing", "maxunitBases", "maxunitBase", "maxunitBasing", "maxUnitBails", "maxunitAliases", "maxUnitBase", "maxUnitAliasing"], "maxUnitEntries": ["maxUnitIntrys", "maxUnitOrdries", "maxUnitEntryies", "maxUnitOrdry", "maxUnitAddry", "maxUnitCountrations", "maxUnitOrdies", "maxUnitEntryresses", "maxUnitEntines", "maxUnitCountry", "maxUnitEntrys", "maxunitEntryrys", "maxLineEntries", "maxLineOrdrations", "maxUnitEntures", "maxunitEntries", "maxunitEnties", "maxUnitEntry", "maxUnitAddresses", "maxLineOrdry", "maxUnitIntries", "maxUnitIntresses", "maxUnitAddries", "maxUnitEnties", "maxunitEntryies", "maxUnitEntrations", "maxUnitEntresses", "maxUnitEntryures", "maxUnitErry", "maxLineEntrations", "maxUnitOrdresses", "maxunitEntryresses", "maxLineOrdines", "maxUnitCountines", "maxUnitEntryrys", "maxunitEntrys", "maxUnitCountries", "maxUnitOrdrys", "maxUnitAddures", "maxLineOrdries", "maxUnitOrdrations", "maxUnitErries", "maxLineEntry", "maxUnitInties", "maxLineEntines", "maxUnitOrdines", "maxUnitEntryries", "maxUnitErines", "maxUnitEntryry", "maxUnitErrations", "maxunitEntryries", "maxunitEntresses"], "fis": [" fai", "fiss", "forisc", " fris", "fisa", " fisa", "foriss", "fai", "forris", "forai", "forIs", "fIs", "vis", " fIs", "Fis", "vIs", "forisa", " fisc", "vai", "Fiss", "visa", " fiss", "foris", "fris", "Fris", "Fisc", "fisc"], "fci": ["Fco", "Fci", "efci", "bai", " fai", "fii", "vci", "hco", "Foci", "fai", "bci", "foci", "hai", " fii", "Fis", "efai", "hci", "Fai", "vai", "fcos", "dci", "bis", "dii", "hcos", "efco", "efcos", "bco", "Fii", "vcos", "vco", "dco", "doci", " foci"], "fos": ["fscos", "ifios", " fcos", "ifo", "fsos", "fsios", "fso", "ifos", "Foes", "foes", "infoss", "toes", "Fis", "infoes", "infos", "fcos", "Foss", "foss", "tis", "tos", "toss", "fios", "Fos", " fo", " fios", "fo", "infis", "ifcos"], "fco": ["Fco", "Fci", "dcos", "hco", "fbo", " fcos", "hgo", "fgo", "fileico", " fico", "lci", "lro", "fileci", "lcos", "fro", "hci", " fbo", "Fico", "fcos", "dci", "fico", "hcos", "lgo", "dro", "Fbo", "filebo", "dco", "fileco", "lco", " fgo", " fro"], "buffer": ["offset", "bin", "border", "reader", "uffer", "iter", "data", "texture", "scale", "channel", "batch", "reference", "layer", "buff", "info", "Buffer", "timeout", "zero", "counter", "binary", "base", "expression", "position", "copy", "cache", "loader", "size", "callback", "writer", "capacity", "translation", "flush", "bar", "entry", "block", "comment", "image", "feed", "source", "request", "response", "context", "transfer", "document", "server", "pause", "view", "null", "rate", "read", "memory", "message", "queue", "resource", "header", "result", "pad", "length", "window", "input", "bc", "device", "buf"], "currentBasesCount": ["currentBatchesNum", "currentChasesCounter", "currentChaseNum", "currentBasesNum", "currentChaseCounter", "currentBaseCounter", "currentChaseCount", "currentChasecount", "currentBasescount", "currentChasesCount", "currentBatchescount", "currentBasingCount", "currentBasingcount", "currentBaseNum", "currentBaseCount", "currentBasingCounter", "currentBatchesCount", "currentBatchesCounter", "currentBasingNum", "currentChasesNum", "currentBasecount", "currentBasesCounter", "currentChasescount"], "currentEntriesCount": ["currentEntursSize", "currentAddriesCount", "currentEntursCount", "currentEntriesSize", "currentAdduresSize", "currentAdduresLimit", "currentEntrasCount", "currentAdduresOffset", "currentAdduresCount", "currentEnturesCount", "currentAddriesSize", "currentEntriesOffset", "currentEntrasSize", "currentEnturesLimit", "currentEntrasLimit", "currentEntursLimit", "currentEntrasOffset", "currentAddriesOffset", "currentEnturesSize", "currentEntriesLimit", "currentAddriesLimit", "currentEntursOffset", "currentEnturesOffset"], "targetCount": ["TargetSum", "argetSize", "patterncount", "patternSize", "argetcount", "TargetSize", "targetcount", "targetSize", "argetSum", "patternCount", "argetCount", "TargetCount", "targetSum", "patternSum", "Targetcount"], "fastaChannel": ["fastasColumn", "fastanContainer", "fastaqColumn", "fastaqConnection", "fastaContext", " fastABuffer", " fastaContainer", " fastaConnection", "fastAConnection", " fastaContext", "fastaqChannel", "fastAContext", "fastasContext", "fastasConnection", "fastaContainer", "fastABuffer", "fastanBuffer", " fastAColumn", "fastasBuffer", " fastAContainer", "fastanContext", "fastAContainer", "fastaqBuffer", " fastAChannel", " fastAContext", "fastAColumn", "fastaConnection", "fastaColumn", "fastAChannel", "fastanChannel", "fastasContainer", " fastAConnection", " fastaColumn", "fastasChannel"], "totalSeqCount": ["totalSeqCounter", "totalQueqcount", "totalSeQCount", "totalQueQcount", "totalSeqcount", "totalSeqsCounter", "totalSeQcount", "totalSeqsCount", "totalSeuxcount", "totalQueQCount", "totalSeqscount", "totalSeuxCount", "totalSeqNum", "totalQueQNum", "totalSeQCounter", "totalSeuxNum", "totalSeuxCounter", "totalQueqCount", "totalQueqNum", "totalQueqCounter", "totalSeQNum", "totalQueQCounter", "totalSeqsNum"], "totalResiduesCount": ["totalResiduingSize", "totalResiduationcount", "totalResiduesNum", "totalResiduingNum", "totalResiduresSize", "totalResiduresCount", "totalResiduationSize", "totalResiduingcount", "totalResiduingCount", "totalResqueurescount", "totalResqueuresCount", "totalResqueuesCount", "totalResqueuescount", "totalResiduescount", "totalResiduationCount", "totalResqueuesSize", "totalResiduesSize", "totalResiduationNum", "totalResidurescount", "totalResiduresNum", "totalResqueuresNum", "totalResqueuesNum", "totalResqueuresSize"], "prevTime": ["PrevFile", " prevFile", "prevFile", " prevValue", " prevSize", "PrevValue", "commitTime", "PrevSize", "PrevTime", "prevSize", "commitFile", "commitSize", "commitValue", "prevValue"], "fastaFileSize": ["fastasFileName", "fastAFileCount", "fastaPageName", "fastaLineLength", "fastaPageAddress", "fastaFilesSize", "fastaBufferCount", "fastaFilesAddress", "fastABufferSize", "fastAFileAddress", "fastaHeaderAddress", "fastABufferCount", "fastaLineCount", "fastaBlockLength", "fastasFileSize", "fastaPageSize", "fastasHeaderSize", "fastasFileAddress", "fastaHeaderSize", "fastABufferAddress", "fastaFileAddress", "fastaFileName", "fastaFileCount", "fastasHeaderLength", "fastaBlockSize", "fastaFilesLength", "fastaFileLength", "fastaHeaderName", "fastaBlockAddress", "fastaBufferAddress", "fastaPageLength", "fastABufferLength", "fastaBufferSize", "fastaLineAddress", "fastasFileLength", "fastaHeaderLength", "fastasHeaderAddress", "fastaLineSize", "fastAFileSize", "fastaBlockCount", "fastAFileLength", "fastaFilesName", "fastasHeaderName", "fastaBufferLength"], "fastaFileReadOffset": ["fastaFileWriteOff", "fastaFileWriteoffset", "fastaBufferReadAmount", "fastaDirectoryWriteOff", "fastaFileLoadLength", "fastaFileRunoffset", "fastaFilesReadoffset", "fastaFilereadOff", "fastaFilesWriteOffset", "fastaFilereadoffset", "fastaBufferWriteOffset", "fastaFilereadOffset", "fastaBufferWriteoffset", "fastaFileStartOff", "fastaBufferReadoffset", "fastaFileLengthoffset", "fastaFileReadAmount", "fastaFileLoadOffset", "fastaDirectoryWriteOffset", "fastaFileRunEntry", "fastaDirectoryReadOff", "fastaFilesReadOff", "fastaDirectoryReadOffset", "fastaFilereadLength", "fastaFileReadoffset", "fastaFileRunOff", "fastaFileReadEntry", "fastaFilesReadOffset", "fastaFileStartoffset", "fastaFilesWriteoffset", "fastaFileReadOff", "fastaDirectoryReadEntry", "fastaFileWriteOffset", "fastaFilesWriteOff", "fastaDirectoryWriteoffset", "fastaDirectoryReadoffset", "fastaFileWriteEntry", "fastaFileRunOffset", "fastaFileLoadoffset", "fastaFileLengthOffset", "fastaDirectoryWriteEntry", "fastaBufferReadLength", "fastaFileLengthAmount", "fastaFileWriteAmount", "fastaFileStartOffset", "fastaFileStartEntry", "fastaFileReadLength", "fastaFilesWriteLength", "fastaBufferReadOffset", "fastaFileWriteLength", "fastaFileLengthOff", "fastaBufferWriteAmount", "fastaFileLoadAmount", "fastaBufferWriteLength", "fastaFilesReadLength", "fastaFileLengthLength"], "partitionStartOffset": ["partitionStopOrder", "partitionBufferOffset", "partitionStartOff", "partitionStopOffset", "partitionEndOff", "partitionsEndOffset", "partitionBufferOrder", "partitionBufferRange", "partitionEndOrder", "partitionsStartOff", "partitionsStartOrder", "partitionStartOrder", "partitionsStartRange", "partitionEndRange", "partitionsEndRange", "partitionsEndOrder", "partitionsEndOff", "partitionStopOff", "partitionBufferOff", "partitionStartRange", "partitionStopRange", "partitionsStartOffset"], "bufferSize": ["processSize", "processSIZE", "bufferCount", " bufferCount", " bufferSIZE", "BufferC", " bufferType", "processType", " bufferC", "BufferSize", "BufferCount", "queueCount", "bufferType", "bufferC", "BufferType", "queueSize", "bufferSIZE", "processC", "BufferSIZE"], "fastaBuffer": ["fastaceBuffer", "fastanContainer", " fastasContainer", "fastAFile", " fastasFile", "fastaQueue", "fastanFile", "fastacePtr", "fastaPtr", "fastasBuff", "FastasBuff", "FastasPtr", "fastaaStream", " fastABuffer", " fastaContainer", " fastAFile", "fastasFile", "FastaStream", "fastaStream", "FastasBuffer", "fastaaBuffer", "FastaChannel", " fastaFile", "fastaContainer", " fastasBuffer", "fastaFile", "fastanBuffer", " fastasChannel", "FastaBuffer", "fastanBuff", "fastaaPtr", "fastasBuffer", "FastasStream", "fastaceBuff", "fastaaBuff", "fastasQueue", "fastaBuff", "fastAContainer", " fastAChannel", "fastaceChannel", "fastanQueue", " fastaQueue", "fastAQueue", "fastasStream", " fastAQueue", "fastABuff", " fastaBuff", "FastaPtr", "FastaBuff", "fastanPtr", "fastAChannel", "fastanChannel", "fastasContainer", "fastasPtr", "fastanStream", "fastAPtr", "FastasChannel", " fastABuff", "fastABuffer", "fastasChannel"], "fastaReadState": ["fastaReadingMode", "fastaReadstate", "fastaReadType", "fastaReaderstate", "fastaFileState", "fastaReadingState", "fastaFileMode", "fastaReaderMode", "fastaFilestate", "fastaFileType", "fastasReadState", "fastaReadingstate", "fastaReaderType", "fastaReaderState", "fastaReadingType", "fastasReaderState", "fastasReaderMode", "fastasReaderstate", "fastasReadType", "fastaReadMode", "fastasReadstate", "fastasReadMode", "fastasReaderType"], "nBytes": ["oParts", "lenFrames", "NBytes", "pByte", " nByte", "oBytes", "lenBytes", "pBytes", "NByte", "pbytes", " nbytes", "obytes", "numBytes", "numbytes", "oFiles", "pParts", "nFiles", " nFrames", "numFiles", "lenFiles", "numFrames", "nbytes", "Nbytes", "nFrames", " nParts", "nParts", "NParts", "NFiles", "nByte", " nFiles", "lenbytes"]}}
{"id1": "14877116", "id2": "15465293", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"Usage:  URLDumper <URL> <file>\");\n            System.exit(1);\n        }\n        String location = args[0];\n        String file = args[1];\n        URL url = new URL(location);\n        FileOutputStream fos = new FileOutputStream(file);\n        byte[] bytes = new byte[4096];\n        InputStream is = url.openStream();\n        int read;\n        while ((read = is.read(bytes)) != -1) {\n            fos.write(bytes, 0, read);\n        }\n        is.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"cpFile": [" copyfile", " copyFiles", "Copyfile", "cpCode", " cpFiles", "cpfile", " cpCode", " cpfile", "CopyFiles", " copyCode", "CopyCode", " copyFile", "CopyFile", "cpFiles"], "source": ["resource", "scene", "route", "subject", "use", "token", "seed", "project", "zip", "string", "current", "site", "host", "context", "Source", "view", "table", "channel", "service", "scope", "self", "node", "ource", "path", "from", "force", "slice", "this", "dest", "database", "ce", "object", "archive", "unit", "template", "grade", "connection", "base", "document", "element", "server", "url", "component", "config", "iter", "SOURCE", "start", "image", "Target", "remote", "se", "directory", "secure", "ources", "type", "null", "parent", "stream", "client", "name", "file", "reference"], "target": ["folder", "resource", "root", "route", "token", "external", "owner", "project", "global", "current", "host", "site", "table", "proxy", "service", "self", "copy", "transform", "ource", "path", "force", "tail", "sync", "dest", "arget", "database", "download", "client", "object", "content", "origin", "boot", "archive", "alias", "it", "connection", "base", "port", "server", "url", "component", "config", "other", "iter", "director", "home", "top", "format", "Target", "to", "remote", "result", "next", "reference", "nt", "type", "range", "output", "null", "parent", "master", "name", "tor", "file", "template"], "replace": ["inline", "root", "share", "route", "align", "use", "rm", "include", "append", "reply", "fill", "cover", "remove", "copy", "same", "protect", "match", "move", "only", "force", "add", "sync", "place", "compatible", "repeat", "re", "store", "insert", "rel", "flash", "placed", "delete", "complete", "array", "other", "allow", "hide", "split", "repl", "apply", "change", "range", "reset", "follow", "write", "multiple", "update", "stall"], "bufferSize": ["queueSize", "byteSize", "queueCount", " buffersize", "byteLen", "serversize", "bufferLen", "bufferSIZE", " bufferSIZE", "queueLen", "queuesize", " bufferLen", "bytesize", "flushSize", "buffersize", "flushSIZE", "serverSIZE", "bufferCount", "flushLen", "serverLen", " bufferCount", "serverSize", "flushsize", "byteCount"], "src": ["resource", "sh", "zip", "rec", "Source", "ruby", "proxy", "input", "copy", "ource", "ctx", "inst", "sc", "sr", "sys", "dest", "sync", "rt", "in", "archive", "fn", "loc", "flash", "proc", "gb", "reflect", "rc", "tmp", "server", "cur", "url", "bc", "sl", "sb", "gz", "start", "socket", "cb", "result", "RC", "ssl", "secure", "ser", "ources", "obj", "req", "sub", "stream", "sel", "rb", "sq"], "tarn": ["etarn", " tarm", "yern", "taran", "ttron", "tharo", "etreen", "yaran", "tarm", "taro", "thern", " tern", "Tarm", "wtarm", "tron", "ttaron", "Treen", " tron", "yarn", "taron", "ttaro", "etann", "ntaron", " taur", "ttarp", " treen", "taur", "wtern", "tarp", " tann", "ttarn", "Tann", "tann", "ntarn", "Trn", "trn", "tern", "thaur", " trn", "wtaran", "Taran", "Tron", "treen", "Tarn", "tharn", "wtarn", "ttaur", "ttrn", "etaran", "ttarm", "ntann", " taran", "yarm", "ttann", " taron", "ntarp", " tarp", " taro", "ttern"], "tardir": ["tardsdir", "tildiri", "sardir", "Tartir", "Tardiri", "Tardir", "tildart", "tildar", "Tartar", "Tardirs", "sardirt", "tartirt", "tardar", "tarpirt", "tartiri", "tardsar", "sardsar", "tardire", "tartir", "tarddir", "tardsire", "tardsir", "tartart", "sardsir", "sardsirt", "Tartirs", "tarpar", "Tardar", "Tartart", "tarart", "sardire", "sardar", "tarpir", "tardart", "tarpire", "tariri", "tardedpath", "tartire", "tartar", "Tardart", "Tartiri", "tartpath", "tardedirs", "tarar", "tardiri", "tardeddir", "tardpath", "tardedir", "tardsirt", "tardspath", "tardirt", "tarir", "Tartdir", "tartdir", "tardirs", "sardsire", "tildir", "Tartpath", "Tarddir", "tartirs", "tardsirs", "Tardpath"], "n": [" i", "nb", "pn", "u", "nw", "N", "k", "c", "g", "m", "o", "d", "na", "dn", "z", "norm", "none", "number", "nn", "in", "num", "min", "nor", "conn", "fn", "p", "l", "ng", "cn", "j", "mn", "coll", "sn", "x", "e", "ns", "nl", "i", "ni", "rn", "ne", "v", "nt", "en", "nc", "nu", "ln", "un"], "tar": ["temp", "large", "cloud", "war", "cat", "sh", "zip", "ca", "ray", "safe", "raf", "sum", "copy", "shr", "tg", "shape", "tan", "di", "box", "sr", "dest", "skip", "tr", "cro", "archive", "ra", "trans", "flash", "cr", "tf", "tif", "csv", "tmp", "ar", "dr", "cos", "gz", "tc", "transfer", "test", "sv", "pack", "jar", "rar", "car", "buffer", "par", "Tar", "file"], "bytes": ["pages", "reads", "Bytes", "classes", "words", "bs", "bps", "resources", "lines", "ones", "values", "eps", "io", "bits", "outs", "bles", "os", "objects", "files", "boot", "seconds", "tes", "steps", "nets", "pieces", "cells", "out", "vs", "ls", "ops", "keys", "blocks", "frames", "vals", "data", "runs", "items", "ipes", "b", "ps", "es", "les", "rows"], "readn": ["findne", "findlen", "findN", " readlen", "Readn", "writelen", "ReadN", "writeno", "passN", "readne", " readne", "writen", "readl", "passno", " readN", "Readlen", "readlen", "writeN", "readns", "runl", "writens", "runno", "readno", "runlen", "passns", "runn", " readl", "Readl", "runns", "runN", "readN", "writene", "passn", "findn"]}}
{"id1": "6840241", "id2": "14865947", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"copy": ["mop", "server", "Copy", "cmp", "slave", "system", "clip", "write", "clone", "loop", "sync", "cop", "type", "load", "cover", "proxy", "open", "share", "ip", "size", "io", "image", "create", "process", "opy", "transfer", "download"], "source": ["sin", "address", "handler", "i", "input", "server", "resource", "Source", "ie", "slice", "slave", "inner", "result", "se", "si", "ources", "SOURCE", "iter", "session", "use", "reader", "proxy", "seed", "connection", "target", "parent", "data", "channel", "src", "size", "iterator", "null", "start", "e", "image", "this", "stream", "sp", "wrapper", "rice", "ink", "ource", "service", "from"], "sink": ["outsigh", "Sinker", "Source", "pinker", "dsinker", "outsinker", "asink", "dsource", "partsINK", "pink", "sider", "tource", "asigh", "SINK", "pource", "tink", "outsink", "Sink", "outsource", "sinker", "tider", "partsource", "sINK", " sinker", "pINK", "asinker", " sigh", "tinker", "dsink", "asource", "partsinker", "dsider", "partsink", "sigh", "pider"]}}
{"id1": "21425787", "id2": "23531898", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFile", " copyStream", "CopyFiles", " copyFiles", "copyfile", " copyfile", "CopyStream", "transferfile", "copyFiles", "Copyfile", "transferStream", "copyStream", "transferFiles", "transferFile"], "in": ["at", "m", "ex", "ins", "url", "image", "In", "b", "connection", "io", "data", "inc", "input", "IN", "index", "inn", "i", "source", "reader", "a", "work", "login", "inner", "base", "min", "id", "ac", "exec", "bin", "file", "c", "name", "up", "ini", "or", "again"], "out": ["at", "to", "prefix", "ex", "writer", "server", "call", "dest", "b", "n", "connection", "io", "off", "data", "inc", "part", "output", "result", "o", "Out", "conn", "temp", "source", "client", "target", "point", "outs", "base", "user", "object", "cache", "exec", "v", "c", "file", "name", "up", "w", "OUT", "x", "again", "p"], "sourceChannel": ["ourceChannel", "resourceConnection", "ourcechannel", " sourceSocket", " sourcechannel", "ourceSocket", "srcChan", "sourceSocket", "targetChannel", "targetStream", "srcSocket", "sourcechannel", " sourceStream", " sourceConnection", "srcConnection", "SourceConnection", "Sourcechannel", "targetChan", "targetchannel", "SourceStream", "srcChannel", "resourcechannel", "ourceChan", "SourceChan", "SourceChannel", "sourceConnection", "resourceChannel", "resourceChan", "sourceChan", "sourceStream", " sourceChan", "ourceConnection"], "destinationChannel": ["destinationChan", "DestinationConnection", "destinatorchannel", "DestinatingChannel", "destinatingManager", "destinationManager", "destinatorStream", "destinatingChannel", "DestinatorChannel", "destinatedConnection", "destructionChannel", "destationConnection", "DestinatingStream", "destinatedFile", "destinateConnection", "DestinatorChan", "DestinationChannel", "destinatingChan", "destationChannel", "destinationConnection", "DestinatingManager", "DestinationFile", "destinateChan", "destinatedStream", "DestinationChan", "destinatedchannel", "destinatorChannel", "DestinatorConnection", "destinatedChan", "destructionConnection", "destationchannel", "destructionChan", "destinationchannel", "destinatorFile", "destinatingStream", "DestinationStream", "destinatedManager", "DestinatorFile", "destinatorManager", "destinationStream", "destinatedChannel", "DestinationManager", "destinateChannel", "destinationFile", "destinatorChan", "destationFile", "DestinatingChan", "Destinatorchannel", "Destinationchannel", "destinatorConnection"]}}
{"id1": "7044153", "id2": "810342", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"sendExceptionToServer": ["sendExceptionWithserver", "sendExceptiontoHost", "sendExceptiontoServer", "sendExceptionWithServer", "sendErrorToserver", "sendExceptionToService", "sendExceptionAsHost", "sendExceptionAsserver", "sendErrorToService", "sendErrortoHost", "sendExceptionAsService", "sendExceptionToserver", "sendExceptionWithHost", "sendErrortoService", "sendErrortoserver", "sendErrorToServer", "sendErrorToHost", "sendExceptionAsServer", "sendExceptionToHost", "sendErrortoServer", "sendExceptiontoService", "sendExceptiontoserver", "sendExceptionWithService"], "server": ["email", "base", "erver", "ssl", "Server", "conf", "domain", "root", "client", "address", "test", "proxy", "service", "db", "port", "ser", "null", "http", " host", "prefix", "header", "host", "addr", "serv", "ip", "json"], "ex": ["x", "full", "su", "ext", "Ex", "ception", "error", "rupt", "aux", "nex", "rex", "event", "str", "Exc", "hex", "log", "class", "status", "base", " exc", "throw", "sex", "export", "err", "ax", "exc", "e", "temp", "acer", "pex", "lex", "example", "exec", "exit", "cl", "except", "fail", "con", "res", "Exception", "def", "exp", "none", "re", "ace", "tx", "obj", "EX"], "config": ["connection", "app", "cb", "ext", "Conf", "options", "settings", "proc", "rc", "log", "base", "text", "conf", "cmd", "bug", "etc", "client", "address", "console", "service", "cfg", "Configuration", "file", "Config", "json"], "prob": ["pebe", "peb", "Probe", "pebs", "Proj", "Probs", " probs", "probe", "proj", "Prob", "probs", " probe", " proj", "pej"], "dataSB": ["dataBL", "uiEl", "execBB", "offLB", "pSB", "innerLB", "DataFB", "errorBB", "contentsb", "nosb", "codeEB", "uiSB", "noSB", "workBB", "eventSB", "strLB", " dataEB", "controlBL", "dataRB", "datasb", "ifsb", "postLB", "ifSL", "postSB", "fileSB", "fullLB", " dataLB", "DataBL", "innersb", "cachesb", "filesb", " dataFB", "errorEB", "datLB", "DataBB", "contentLB", "cacheSB", "datSB", "codeSB", " dataBB", "execBL", "errorPB", "responseLB", "errorSL", "responseSB", "ifLB", "codeLB", "DataLB", "cacheLB", "controlsb", " dataBL", "eventSL", "execLB", "dataBs", "offsb", "fullBB", "DataSL", "DataHL", "DataOB", "loadBB", "datBB", "noSL", "codeRB", "fullBL", "loadSB", "Datasb", "dataOB", "loadsb", "defaultBB", "dataFB", "offSB", "dataEB", "datOB", "responseBL", "offBB", "uiLB", "eventLB", "defaultSB", "codeMB", "dataBB", "eventBB", "workSB", "loadLB", "codeHL", "contentOB", "codeBB", "postsb", "workPB", "innerSB", " dataPB", "fileLB", "DataRB", "errorOB", "strsb", "controlLB", "postSL", "dataSL", "DataSB", "defaultLB", "errorLB", "errorsb", "execsb", "pLB", " dataBs", " dataEl", " dataRB", " dataOB", "dataHL", "innerSL", "offSL", "DataMB", "noLB", "defaultsb", "dataLB", "controlBB", "ifSB", "fileSL", "errorSB", "pBs", " dataMB", "dataEl", "contentSB", "codesb", "codeBs", "codeFB", "codeEl", "strSB", " datasb", "controlSB", "responseBB", " dataHL", "execSB", "psb", " dataSL", "cacheBL", "dataPB", "workSL", "strSL", "dataMB", "fullSB"], "trace": ["trip", "profile", "data", "tri", "scale", "error", "type", "ctr", "span", "string", "array", "stack", "info", "xml", "log", "ptr", "cache", "r", "bug", "trans", "err", "e", "flow", "bean", "address", "temp", "race", "track", "buffer", "test", "atter", "t", " debug", " tracing", "details", "shadow", " traced", "message", "debug", "tr", "result", "out", "cover", "fake", "report", "ace", "tx", " traces", "strip", "runner", "ray"]}}
{"id1": "13783898", "id2": "19739421", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeFileToStream", "encodeFileFromStream", "encodeFiletoFiles", "encodeString2File", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFile", "encodeFileFromString", "encodeStringToString", "encodeFileFromFiles", "encodeFiletoStream", "encodeFile2String", "encodeFileFromFile", "encodeStringToStream", "encodeString2String", "encodeString2Files", "encodeString2Stream", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFileToString", "encodeFile2Files", "encodeFile2File"], "infile": ["infp", " infiles", "InFile", "Infilename", "inputfiles", "inputFile", "Infiles", "outfp", "outfilename", "inFile", "inputfp", "infiles", "Infile", "infilename", "inputfilename", "inputfile", "outfiles", "outFile", " infp", " infilename"], "outfile": ["infp", " outfilename", "outputfilename", " outfolder", "outputfolder", "outputfp", "newfile", "outname", "outfp", " outFile", "outfilename", " outname", "Outfolder", "Outname", " outfp", "outfolder", "infilename", "newfolder", "newFile", "infolder", "outFile", "Outfile", "newname", "OutFile", "outputfile"], "in": ["into", "m", "ins", "image", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "vin", "din", "IN", "inn", "inas", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "base", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "source", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "err", "obj", "name", "up", "net", "ou", "OUT", "or", "again", "line", "on", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "fb", "data", "Buffer", "raw", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "len", "base", "slice", "queue", "address", "cache", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "input", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "close", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "respons", "func", "winner", " Success", "model", "status", "follow", "result", "primary", "fail", "valid", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "modified", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "14882263", "id2": "14502142", "code1": "    private void UploadActionPerformed(ActionEvent evt) {\n        JFileChooser chooser = new JFileChooser();\n        FileNameExtensionFilter filter = new FileNameExtensionFilter(\"*.jpg\", \"jpg\");\n        chooser.setFileFilter(filter);\n        File dir = new File(System.getProperty(\"user.home\"));\n        chooser.setCurrentDirectory(dir);\n        Component parent = null;\n        int returnVal = chooser.showOpenDialog(parent);\n        if (returnVal == JFileChooser.APPROVE_OPTION) {\n            UserStatus.setText(\"Bitte warten\");\n        }\n        try {\n            Pic.setVisible(false);\n            FTPClient client = new FTPClient();\n            client.connect(\"showus.de\");\n            client.login(\"web2\", \"kcinnay88\");\n            client.enterLocalActiveMode();\n            client.setFileTransferMode(FTPClient.BINARY_FILE_TYPE);\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            int reply = client.getReplyCode();\n            System.out.println(\"Connect returned: \" + reply);\n            FileInputStream in = new FileInputStream(chooser.getSelectedFile().getAbsolutePath());\n            System.out.println(\"Uploading File\");\n            client.storeFile(\"/html/Applet/user/\" + Config.id + \".jpg\", in);\n            client.logout();\n            in.close();\n            System.out.println(\"done\");\n            UserStatus.setText(\"Upload fertig, Bild wird aktuallisiert\");\n        } catch (SocketException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            UserStatus.setText(\"Fehler beim Upload\");\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"UploadActionPerformed": ["UploadActionReformed", "UploadButtonOccumed", "UploadButtonOccformed", "UploadActionReuted", "UploadActionOccuted", "UploadActionOccumed", "UploadActionEnformed", "UploadButtonPeruted", "UploadButtonPerced", "UploadButtonPerumed", "UploadActionOccformed", "UploadActionEnuted", "UploadActionOccced", "UploadActionReumed", "UploadActionPeruted", "UploadButtonOccced", "UploadActionPerumed", "UploadButtonPerformed", "UploadActionReced", "UploadActionEnced", "UploadActionEnumed", "UploadActionPerced", "UploadButtonOccuted"], "evt": [" evtf", " Evt", "Evt", " avertf", " evte", " Evtf", "Evts", " Evte", " evts", " averts", " averte", "Evtf", " Evts", " avert", "Evte"], "chooser": ["closen", "choiner", "dialcho", "comboser", "chooe", "choosen", "Choosed", "dialosen", "joosen", "combosed", "coosed", "dialose", "coiner", "dialoser", "compo", "promosite", "promosen", "joose", "closed", "Chooser", "promose", "closer", "joosed", "chocho", "choo", "choosing", "choosite", "joosing", "Choose", "compose", "joo", "cooser", "jooser", "joiner", "coosite", "promoe", "cooe", "combose", "coose", "composer", "Choosite", "Choosing", "promo", "Chocho", "promoser", "closing", "choose", "composen", "combiner", "Chooe", "Choosen", "choosed", "compcho"], "filter": ["fl", "url", "sf", "b", "form", "lock", "atter", "flat", "acl", "method", "search", "limit", "model", "f", "map", "finder", "sort", "type", "plugin", "class", "config", "fil", "ff", "self", "user", "object", "match", "cache", "handler", "file", "name", "list", "Filter", "aff", "pattern", "path", "query", "format", "force", "ext"], "dir": ["fd", "log", "direction", "url", "uri", "conf", "loc", "lock", "DIR", "info", "data", "store", "project", "part", "folder", "f", " directory", "zip", "area", "dat", "type", "out", "home", "pkg", "source", "config", "directory", "db", "base", "user", "id", "cache", "handler", "file", "ir", "dist", "name", "loader", "root", "path", "Dir", "doc"], "parent": ["page", "component", "url", "menu", "resource", "image", "Parent", "child", "port", "part", "channel", "folder", "document", "editor", "parents", "pid", "container", "home", "instance", "section", "directory", "self", "ip", "point", "user", "object", "id", "div", "handler", "file", "name", "root", "path", "location", "current", "p"], "returnVal": ["returnval", "continueValue", "errorVal", " returnObj", "continueval", "errorval", "errorValue", "continueVal", "errorVol", "returnObj", "returnValue", "returnVol", "ReturnVol", " returnVol", "ReturnObj", "ReturnValue", "Returnval", "ReturnVal", "continueObj", " returnval", " returnValue"], "client": ["proxy", "friend", "request", "console", "ssl", "default", "standard", "server", "call", "core", "complete", "simple", "connection", "force", "remote", "google", "ce", "cell", "session", "phone", "socket", "cloud", "external", "channel", "connect", "quit", "cl", "end", "out", "conn", "plugin", "i", "cm", "api", "config", "cli", "web", "use", "ip", "Client", "pi", "base", "user", "util", "co", "queue", "local", "cache", "https", "pc", "con", "c", "file", "contact", "app", "help", "service", "grid", "net", "per", "get", "clean", "contract", "secure", "close", "http", "custom", "p", "open"], "reply": ["resp", "req", "exit", "respond", "uri", "message", "write", "count", "connection", "reason", "rc", "like", "info", "back", "msg", "link", "sync", "status", "result", "mode", "answer", "ise", "error", "code", "action", "parse", "xxxxxxxx", "ply", "rr", "send", "id", "err", " replied", "repl", " replies", "next", "response", " response", "query", "state", "Reply", "close", "post", "ry"], "in": ["rec", "ex", "ins", "resource", "image", "In", "ax", "n", "tin", "io", "data", "inc", "socket", "f", "gin", "input", "din", "IN", "inn", "out", "conn", "i", "is", "source", "reader", "nin", "l", "stream", "login", "inner", "min", "r", "id", "ac", "pc", "bin", "file", "con", "ic", "fc", "up", "pin", "ini", "again", "cgi", "on", "p", "serv"]}}
{"id1": "23215235", "id2": "8801436", "code1": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"readFile": ["readFiles", "readContent", " readContent", " readFiles", "loadContent", "importZip", "loadZip", "importFiles", "importContent", "importFile", "readZip", "loadFile", " readZip", "loadFiles"], "url": ["page", "uri", "ssl", "resource", "image", "server", "connection", "io", "data", "link", "f", "zip", "input", "str", "URL", "job", "download", "xml", "source", "class", "reader", "config", "client", "filename", "l", "stream", "base", "user", "object", "address", "file", "name", "loader", "service", "sl", "host", "bug", "path", "Url", "location", " URL", "buffer", "http", "feed", "browser"], "IOException": ["IPException", "IOInterface", "TimeoutException", "IPInterface", " IOInterface", "TimeoutInterface"], "ParserConfigurationException": ["InvalidConfigAPE", "ParserDefinitionException", "ParserDefinitionAPE", "ParserConstructionEX", "ParserConstructionException", "ParserConfigEX", "ParserConfigAPE", "InvalidConfigurationEX", "InvalidConfigurationAPE", "ParserConfigurationEX", "ParserConstructionAPE", "ParserConfigException", "InvalidConfigEX", "ParserConfigurationAPE", "InvalidConfigException", "InvalidConfigurationException", "ParserDefinitionEX"], "SAXException": [" SAXception", "SAFEException", "SAXception", " SAXPception", "SAXPception", "SAFEception", "SAXPException", "SAXMception", "SAXMException", " SAXPException"], "zipFileName": ["zipFileDirectory", "zipFolderPath", "zipFolderType", "zipFolderName", "archiveFileDirectory", "zipDirDirectory", "zipFileType", "archiveFileName", "archiveFilePath", "archiveFileType", "archiveFilesType", "zipFilesDirectory", "archiveFilesDirectory", "zipFilesType", "zipFolderDirectory", "zipFilesName", "zipDirName", "zipDirPath", "zipFilePath", "zipFilesPath", "archiveFilesPath", "zipDirType", "archiveFilesName"], "urlConnection": ["URLChannel", "URLconnection", "webChannel", "fileManager", "inputConn", "webconnection", "urlResponse", "inputPool", "urlManager", "httpPool", "webConnection", "URLConnection", "inputConnection", "fileConn", "webResponse", "urlConn", "urlChannel", "urlPool", "URLResponse", "urlconnection", "httpManager", " urlChannel", "filePool", "httpConnection", "inputManager", "fileConnection", " urlconnection", " urlResponse", "httpConn"], "inputStream": ["InputSession", "outputStream", "inputChannel", "urlFeed", "outputContext", "InputFile", "InputChannel", "urlFile", "outputstream", "inputFile", " inputContext", "inputFeed", "urlSession", "InputContext", "inputContext", "Inputstream", " inputFeed", "inputSession", " inputSession", " inputFile", "InputFeed", "urlStream", "inputstream", "outputChannel", " inputstream", "InputStream", " inputChannel"]}}
{"id1": "17999474", "id2": "8754809", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipasfile", "getZipAtFile", "getZipAsDir", "getTempAsfile", "getTempAsFile", "getZipAtfile", "getTempAsPlace", "getTempAsDir", "getZipAtDir", "getZipasPlace", "getZipasDir", "getZipAsPlace", "getZipAtPlace", "getZipAsfile", "getZipasFile"], "digOb": ["signOb", " digob", "signObject", " digObject", "digOl", "dimOb", " digObj", "signob", " digOl", "signOB", "dimObject", "DigObj", "Digob", "ditob", "dimObj", "DigObject", "signObj", "DigOl", "digOB", "digObj", "ditOB", "ditObject", "DigOb", "ditOb", "digob", " digOB", "dimOl", "digObject"], "folderName": [" foldername", "foldPath", " folderDir", "foldName", "fileName", "foldername", "FolderName", "folderPath", "foldname", "packagePath", "packagename", "packageName", "foldInfo", "folderDir", "FolderPath", "FolderDir", "filePath", "fileInfo", "filename", "FolderInfo", " folderPath", "folderInfo", "Foldername", "packageDir"], "tmpFolder": ["tempDirectory", " temporaryManager", "tempManager", "tmpManager", "mpfolder", "tempfolder", "mpFolder", "tempDir", " temporaryFolder", "mpDir", "tmpfolder", " tmpDir", " tmpDirectory", "mpDirectory", " temporaryfolder", " tmpfolder", "tempFolder", "tmpDirectory", " tmpManager", "tmpDir", " temporaryDirectory"], "zip": ["pipe", "lock", "job", "sl", "f", "archive", "ze", "slice", "py", "seed", "install", "p", "download", "gz", "jar", "xml", "ie", "copy", "wrap", "clip", "cop", "bag", "flow", "temp", "zone", "proxy", "lib", "source", "pack", "lex", "z", "feed", "cf", "ulp", "url", " zipper", "io", "flat", "file", "folder", "ce", "ress", "upload", "ipped", "fp", " ZIP", "Zip", "json", "ip", "ignore", "tmp", "pkg"], "out": ["connection", "f", "socket", "sync", "info", "ex", "outs", "download", "gz", "gen", "os", "plain", "base", "log", "is", "copy", "page", "conn", "cache", "again", "output", "user", "loader", "box", "writer", "line", "err", "flow", "o", "client", "flush", "OUT", "temp", "this", "cli", "source", "z", "child", "path", "parent", "object", "url", "null", "io", "in", "file", "a", "upload", "result", "Out", "write", "obj"]}}
{"id1": "19739421", "id2": "3187685", "code1": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"UnknownOptionException": [" UnknownOptionsError", "UnknownOperationError", "UnknownParameterException", " UnknownOptionsception", " UnknownOptionsException", "UnknownOptionsError", "UnknownOperationException", "UnknownOptionsException", " UnknownOptionError", "UnknownOptionception", "UnknownParameterError", "UnknownOperationception", "UnknownOptionError", "UnknownOptionsception", " UnknownOptionception", "UnknownParameterception"], "cmdLineParser": ["cmdSiteparser", "cmdLinearser", "cmdSiteParser", " cmdLineMaster", "cmdLineJar", " cmdLinearser", "cmdLinMaster", "mdLineParser", "cmdStringMaster", "mdLineHelper", "cmdBlockParser", "cmdStringBuilder", "cmdServiceJar", "mdlinearser", "mdLParser", "cmdStringJar", "cmdlineReader", "cmdStringWriter", "cmdLineWriter", "commandlineMaster", "cmdLMaster", "cmdLineReader", "cmdEntryarser", "cmdLBuilder", "cmdLJar", "mdLineReader", "cmdBlockBuilder", "cmdSiteWriter", "cmdLHelper", "commandlineReader", "cmdlinearser", "cmdFileJar", "cmdEntryMaster", "cmdlineWriter", "mdLineWriter", "cmdBlockarser", "cmdlineJar", "cmdStringHelper", "cmdLineRunner", "cmdStringarser", "commandLineMaster", "cmdServicearser", "cmdlineparser", "cmdBlockparser", "mdLineBuilder", "cmdServiceMaster", "cmdFileReader", "mdLinearser", "cmdBlockMaster", "cmdLinReader", "mdLHelper", "cmdLineMaster", "cmdStringParser", "commandLineParser", "commandLineJar", "cmdByteMaster", "mdlineParser", " cmdLMaster", "cmdlineMaster", " cmdLineJar", "cmdStringRunner", "cmdByteJar", "mdLineJar", "cmdFileRunner", "mdlineparser", " cmdLJar", "mdLarser", "mdlineBuilder", "commandlineParser", "cmdStringReader", "cmdFileMaster", "cmdByteParser", "mdlineMaster", "mdLReader", "cmdLineparser", "cmdEntryParser", "cmdLinParser", "cmdLineBuilder", "cmdBlockWriter", " cmdLParser", "cmdFileParser", "mdLJar", "cmdlineParser", "mdlineJar", "cmdLparser", "cmdStringparser", "commandLineReader", " cmdLarser", "mdLineMaster", "cmdEntryJar", "cmdLinJar", "mdLineparser", "cmdlineBuilder", "cmdFilearser", "cmdBlockJar", "mdlineWriter", "cmdLineHelper", "mdLRunner", "cmdLarser", "cmdLReader", "cmdlineHelper", "mdLineRunner", "commandlineJar", "cmdSiteJar", "cmdLParser", "cmdByteWriter", "cmdLRunner", "cmdServiceParser"], "formatOption": [" formatElement", "lengthVariable", "lengthOption", "FormatOption", "FormatOpt", "printfElement", "printfOperation", "formatOpt", "formatParameter", "FormatOperation", "FormatElement", "formatOperation", "printfOption", " formatParameter", "lengthOpt", "typeOpt", "formatElement", " formatOpt", "lengthParameter", "typeParameter", "printfOpt", " formatOperation", "formatVariable", " formatVariable", "typeOption", "typeVariable"], "outputEncodingOption": ["outputEncasingOpt", "outputEncasingParameter", "outputEncodingOperation", "outputEncordingOption", "outputCasingParameter", "outputEncitingOperation", "outputEncordingOptions", "outputCasingOpt", "outputCodingOptions", "outputEncoderParameter", "outputEncordingOpt", "outputEncodingParameter", "outputEncitingOpt", "outputCodingOpt", "outputEncodingOpt", "outputCodingOperation", "outputCasingOperation", "outputEncordingOperation", "outputEncasingOperation", "outputEncoderOperation", "outputEncoderOption", "outputEncordingParameter", "outputEncodingOptions", "outputCodingParameter", "outputCodingOption", "outputEncitingOptions", "outputEncasingOptions", "outputEncoderOpt", "outputEncasingOption", "outputCasingOptions", "outputEncitingOption", "outputCasingOption"], "inputEncodingOption": ["inputChodingOpt", "inputChachingOption", "inputEncodedOption", "inputEncoderOperation", "inputChachingOperation", "inputEncasingOpt", "inputEncoderOption", "inputChodingOperation", "inputEncodingFunction", "inputEncasingOption", "inputEncodingOperation", "inputEncoderOpt", "inputEncasingFunction", "inputEncodedFunction", "inputChodingFunction", "inputEncodingOpt", "inputChachingOpt", "inputChasingOperation", "inputEncachingOperation", "inputEncoderFunction", "inputChasingFunction", "inputChodingOption", "inputChasingOption", "inputEncachingOpt", "inputEncodedOperation", "inputEncachingOption", "inputEncasingOperation"], "format": ["filter", "at", "prefix", "attribute", "writer", "unit", "html", "style", "term", "form", "letter", "atter", "version", "scale", "title", "output", "f", "template", "sort", "type", "plugin", "cat", "api", "config", "quality", "size", "filename", "license", "target", "command", "transform", "place", "feature", "language", "string", "layout", "file", "alpha", "Format", "option", "name", "service", "printf", "pattern", "host", "ant", "value", "pretty", "export"], "outputEncoding": ["outputOctoding", "inputEncryption", "outputCompasing", "inputChasing", "outputEntryption", "outputChaping", "outputChoder", "outputChaching", "outputOctoring", "outputencoder", "outputencoding", " outputEntining", "outputOctasing", "outputDecoding", "inputChryption", "outputCompoding", "outputEngording", "outputEncaping", "inputChoding", "inputChoring", "outputDecording", "inputEncoring", "inputEncoder", "outputencaching", " outputEncoder", "outputChining", "outputChryption", "outputSequoding", "outputCompoder", "outputEngoder", " outputEncining", "outputEntoding", "outputEncording", "outputEncoder", "outputEntoder", " outputEncaping", "outputEntasing", "outputEncoring", "outputEntining", " outputEntoding", " outputEncaching", "outputencording", "outputEnaping", "outputEngaching", "outputSequoder", "outputEncryption", "outputSequryption", " outputEngaching", "outputCompording", "outputChoding", " outputEngoding", " outputEncasing", "outputEnasing", "outputEncaching", "inputChoder", "outputEnining", "inputEncasing", "outputEncasing", " outputEntasing", "outputDecoder", " outputEngoder", " outputEncording", " outputEngording", "outputEngoding", "outputChoring", "outputChording", "outputChasing", " outputEntaping", "inputChording", "outputSequasing", "outputDecasing", "inputEncording", "outputOctoder", "outputEncining", "outputEntaping", "outputEnoding"], "inputEncoding": ["inputEnoder", "inputExplasing", " inputDecoder", "inputEnacing", "variableExplasting", "inputChoding", "variableExplode", "variableEncode", "inputExploding", "inputEnording", "inputEngoding", "inputChacing", "inputEncasting", "inputChasting", "inputEngoder", "inputDecacing", " inputDecording", "inputChasing", "variableExplasing", "inputChode", "inputEnasting", "inputEngasing", "inputEncoder", "inputEncacing", "outputEncasing", "inputDecoding", "inputEncode", "outputChoder", "outputChasing", "inputExplode", "inputExplasting", " inputDecacing", "inputChording", "outputChoding", "inputEngapping", " inputDecoding", "inputEncording", "outputChapping", "inputDecording", "inputEnasing", "inputEnode", "outputEncoder", "inputEncapping", "inputChoder", "variableExploding", "inputDecoder", "variableEncasting", "variableEncasing", "inputEnoding", " inputEncording", "inputEncasing", "outputEncapping", "inputChapping", " inputEncacing", "inputEnapping", " inputEncoder", "variableEncoding"], "remainingArgs": ["remainArgs", "remendingArg", "RemingLong", "RemingParts", "regainingGS", "remangingGS", "remainedGS", "remangingLong", "remainArg", "remangingParts", "resainargs", "remainParameters", "resainedLong", "resainedArg", "remingParts", "remainedArray", "remangingArgs", "RemangingParts", "remainsArg", "remainLong", "RemingArgs", "remainedParameters", "RemangingAr", "remainedParts", "remainingArg", "remainingLong", "RemainingLong", "remainargs", "remainedargs", "remainsAr", "remainingArray", "RemainingArg", "regainedGS", "resainArray", "remainAr", "regainingArg", "RemainingParts", "remainedArg", "resainingLong", "remainedLong", "resainingArray", "remainingAr", "regainingParameters", "remainingParts", "resainArgs", "remainingargs", "removingParts", "remangingArg", "remingArgs", "remainingParameters", "remainsArgs", "remainedArgs", "RemangingArg", "remangingAr", "regainedArg", "remingLong", "remendingArray", "remainGS", "remangingParameters", "remendingargs", "regainingArgs", "remainsParts", "removingArgs", "resainArg", "RemainingGS", "removingGS", "resainingArgs", "resainingParts", "RemainingArgs", "resainingArg", "remainingGS", "regainedArgs", "removingLong", "regainedParameters", "RemangingArgs", "remingGS", "resainedArgs", "remendingArgs", "resainedParts", "remainParts", "resainingargs", "RemingGS", "remainArray", "RemainingAr"], "inputFile": [" inputfile", "InputFile", "localDirectory", "localFile", "InputDir", " inputDir", "sourceDirectory", "InputLine", "sourceLine", "inputSourceFile", "InputSourceFile", "sourceFile", "inputStream", "sourcefile", "inputPath", " inputPath", " inputDirectory", " inputStream", "localDir", "inputDirectory", "inputDir", "localSourceFile", "InputDirectory", "inputfile", "sourcePath", "inputLine", " inputLine", "sourceDir", "sourceStream", "InputPath", " inputSourceFile", "InputStream", "Inputfile"], "outputFile": ["OutputPath", "outputStream", "examplefile", "exampleFile", " outputFolder", "operationfile", "operationHeader", "outputMessage", " outputPath", "operationFolder", "OutputFolder", " outputMessage", " outputfile", "OutputHeader", "exampleFolder", "productionfile", "outputPath", "OutputStream", "productionMessage", "outputFolder", "productionFile", " outputStream", "operationFile", " outputHeader", "OutputFile", "exampleStream", "OutputMessage", "productionPath", "Outputfile", "outputfile", "outputHeader"], "out": ["prefix", "page", "gen", "log", "writer", "ln", "flow", "write", "server", "parent", "copy", "debug", "lock", "io", "outer", "info", "session", "raw", "group", "output", "in", "sum", "Out", "error", "temp", "builder", "client", "co", "dump", "ger", "outs", "over", "cache", "screen", "history", "err", "obj", "println", "list", "up", "pre", "OUT", "auto", "line", "word", "again", "manager", "post"]}}
{"id1": "20091126", "id2": "17190057", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "label": 0, "substitutes": {"copy": ["zip", "Copy", "cmp", "output", "join", "write", "cop", "type", "cp", "source", "up", "proxy", "cat", "upload", "open", "file", "archive", "Cop", "put", "p", "exec", "io", "call", "over", "paste", "process", "transfer", "download"], "in": ["IN", "index", "base", "buffer", "i", "input", "id", "ic", "inner", "l", "ins", "bin", "query", "part", "reader", "source", "login", "min", "old", "diff", "connection", "inc", "work", "data", "file", "config", "or", "again", "name", "m", "image", "In", "a", "url", "lin", "b", "ac", "f"], "out": ["string", "base", "buffer", "temp", "i", "ex", "output", "server", "plain", "OUT", "c", "result", "outs", "o", "off", "write", "content", "source", "cache", "dot", "value", "target", "default", "parent", "data", "file", "channel", "page", "object", "x", "p", "again", "name", "exec", "Out", "image", "io", "exp", "array", "call", "prefix", "a", "url", "ext", "comment", "v", "err", "external", "point"], "inChannel": ["inputChannel", "INchannel", "iniChannel", "inStream", " inchannel", "inputchannel", " inClient", "winChan", "INGate", "inchannel", "inButton", "inputChan", "iniStream", "INChan", "INClient", "outStream", "iniChan", "outchannel", "outChan", "inChan", " inButton", "INButton", "insClient", "insStream", "inputStream", "outButton", "insChannel", "INStream", "winChannel", "winchannel", "INChannel", " inStream", "inClient", " inChan", "insChan", "winStream", "inputGate", "iniGate", "inputButton", "inGate"], "outChannel": [" outContext", "OutStream", "inStream", "outsStream", "OutChannel", "inchannel", "outContext", " outConnection", "OutChan", "outStream", "inContext", "outchannel", "outChan", "outsChan", "inChan", "outputStream", "OutContext", "OutClient", "outClient", "outputchannel", "outsChannel", "outputChannel", "outConnection", "Outchannel", "outputClient", "outputChan", "inConnection", "inClient", "outsConnection", " outStream", " outchannel", " outChan"]}}
{"id1": "20365090", "id2": "7372311", "code1": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 0, "substitutes": {"execute": [" poll", " future", " work", " pull", " parse", " await", " transfer", " resolve", " async", " open", " flush", " dispatch", " produce", " feed", " refresh", " current", " serve", " fulfill", " perform", " prepare", " initialize", " generate", " end", " proceed", " go", " exec", " ping", " handle", " finish"], "forwardResponse": ["forwardServer", "wardRequest", "publicRequest", "publicResponse", "wardResp", " forwardAnswer", " backwardServer", " backwardRequest", " forwardServer", "wardresponse", " forwardResp", "publicServer", " forwardRequest", "ForwardRequest", "forwardresponse", "Forwardresponse", "forwardView", "forwardRequest", "wardView", " backwardResponse", " forwardresponse", "forwardAnswer", "ForwardResponse", "publicAnswer", "forwardResp", " forwardView", " backwardAnswer", "ForwardView", "wardResponse", "ForwardResp"], "fetchSizeLimit": ["fatchLengthLim", "fetchSizeRange", "fetchLimitGlobal", "faitLimitLock", "fetchsizeLim", "fetchLengthRange", "fetchRangeLimit", "faitSizeBlock", "fatchLengthPosition", "fetchCountRange", "fetchLimitRange", "fetchLengthUnit", "fatchSizeLimited", "fetchCountBlock", "fetchLengthLim", "fatchSizeLimit", "fetchRangePage", "fetchsizeLock", "fatchSizePosition", "fetchSizeUnit", "fetchLengthBlock", "fetchLimitPosition", "faitLimitGlobal", "fatchLengthLock", "fushCountPage", "fetchSizePosition", "faitSizeLimit", "fushSizeUnit", "faitSizeLock", "fetchsizeLimited", "faitLimitLimit", "fatchSizeBlock", "fetchCountLimit", "fetchLengthLock", "fatchSizeLock", "fushSizePage", "fetchsizeBlock", "fetchLengthPosition", "fetchLimitLock", "fetchsizeGlobal", "faitSizeGlobal", "fetchSizeLim", "fetchSizeLimited", "fetchSizeBlock", "fetchRangeUnit", "faitLimitBlock", "fatchSizeLim", "fetchLimitLimit", "fushSizeLimit", "fetchSizeLock", "fetchLimitBlock", "fatchLengthLimit", "fetchLengthGlobal", "fushCountLimit", "fatchLengthLimited", "fetchsizeLimit", "fetchLengthPage", "fatchSizeRange", "fushCountUnit", "fetchSizePage", "fetchCountPosition", "fushCountRange", "fatchLengthRange", "fetchRangeRange", "fetchLengthLimit", "fatchLengthBlock", "fetchCountUnit", "fetchCountPage", "fetchSizeGlobal", "fetchLengthLimited", "fushSizeRange"], "lastContentRange": [" lastSizeRange", "lastCharacterRange", "lastContentRow", "lastMessageResource", "lastContentLine", "latestContentRow", " lastContentArea", " lastHeaderRegion", "latestFileRange", " lastContentInfo", "LastMessageResource", " lastContentResource", "lastMessageSpace", "lastReadRegion", "lastCharacterRegion", "lastHeaderResource", "lastVersionrange", "lastResourceRow", "lastCurrentLine", "lastCharacterOrigin", " lastContentRow", "lastFileRow", "lastMessageRow", "latestContentRange", " lastContentOrigin", " lastReadInfo", "lastVersionRange", "lastCurrentSpace", "lastReadResource", "lastResourceRange", "lastHeaderRange", "latestContentResource", "lastContentInfo", "lastCharacterRow", "LastContentLine", " lastContentrange", "lastResourceRegion", "lastResourcerange", " lastHeaderOrigin", " lastContentSpace", "latestFileResource", "lastContentSpace", "lastSizeRange", "lastResourceSpace", "lastReadRow", "LastContentResource", "lastContentRegion", "lastSizeRegion", "lastResourceArea", " lastSizeArea", "lastSizeSpace", " lastSizeSpace", "lastSizeArea", "lastReadrange", "lastReadSpace", "lastReadRange", "LastContentRange", "LastContentSpace", "lastVersionResource", " lastReadrange", "LastMessageSpace", "lastCurrentRange", " lastSizeRegion", "latestFileRow", "lastFileResource", "lastResourceResource", " lastReadRange", "lastContentResource", "lastHeaderRegion", " lastContentRegion", " lastHeaderRange", "LastMessageLine", "lastHeaderSpace", "lastMessageRange", "lastVersionInfo", "lastReadArea", " lastReadResource", "lastHeaderLine", "lastHeaderRow", "lastResourceInfo", "lastContentrange", "lastHeaderOrigin", " lastHeaderRow", "lastContentOrigin", "LastMessageRange", "lastMessageLine", "lastReadInfo", "lastCurrentResource", "lastResourceOrigin", "lastContentArea", "lastFileRange"], "old": ["val", "from", "string", "original", "base", "past", "list", "add", "now", "OLD", "slice", "current", "inner", "older", "later", "l", "el", "existing", "ld", "last", "la", "form", "client", "part", "less", "after", "expected", "before", "Old", " Old", "diff", "common", "other", "build", "small", "file", "local", "object", "ant", "ore", "format", "or", "plugin", "folder", "normal", "to", "full", "low", "update", "ext", "obj", "future", "and", "prev", "handle", "element", "orig", "arrow", "front"], "sendSize": ["sentLength", "transferRange", "sendSIZE", "drawLength", " sendLen", "writeRange", "endLength", "endSIZE", " sendTime", "sendLength", "loadSize", "forceSIZE", " sendLength", "loadSIZE", "transferSize", "SendStorage", " sendSIZE", "updateSIZE", "endTime", "forceSize", "drawLimit", "sentLimit", "SendSize", "transferLength", "sendOffset", "sendRange", " sendLimit", " sendStorage", "forceLength", "sendLimit", "writeLength", "sendStorage", "pushSIZE", "updateLen", "endEnd", "sendTime", "drawSize", "loadTime", " sendEnd", "SendEnd", "sendEnd", "sentSize", "forceTime", "updateSize", "pushLen", "transferOffset", "loadOffset", "sendLen", "pushTime", "endStorage", "updateLimit", "endLimit", "pushLimit", "endSize", "drawSIZE", "writeSize", "pushLength", "loadRange", "loadLength", "SendLength", "sentSIZE", "writeOffset", "pushSize"]}}
{"id1": "15051083", "id2": "7633336", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    private JSONObject executeHttpGet(String uri) throws Exception {\n        HttpGet req = new HttpGet(uri);\n        HttpClient client = new DefaultHttpClient();\n        HttpResponse resLogin = client.execute(req);\n        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));\n        StringBuilder sb = new StringBuilder();\n        String s = null;\n        while ((s = r.readLine()) != null) {\n            sb.append(s);\n        }\n        return new JSONObject(sb.toString());\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getmessageDigests", "getmessageDigature", "getmessageDigest", "getmessagedigest", "getMessagedigester", "getMessageDesignature", "getMessageHashature", "getmessageDigester", "getMessageDigester", "getMessageDesignester", "getmessagedigature", "getMessageHashester", "getMessagedigature", "getMessageHashests", "getMessageDigature", "getMessagedigests", "getMessageDesignests", "getMessagedigest", "getMessageHashest", "getmessagedigester", "getmessagedigests", "getMessageDigests", "getMessageDesignest"], "digest": ["Digester", "signester", "hexex", "hexests", "DigEST", "Diger", "sandesting", " Digeter", " Dighed", " digeter", " Diger", " Digester", "signest", "Digex", " digested", " diger", "dighed", "hexEST", "Dighed", "signiter", "digex", " digEST", "signested", "Digests", " digger", "feedested", "digester", "signesting", "greatiter", "Digeter", " Digest", "digested", "digests", "sandest", "digger", "greatester", "sandester", "Digesting", "Digest", " digex", " dighed", "digeter", "sandested", "diger", " Digger", "Digger", " digester", "Digiter", "greatest", "greatested", "feedester", "hexest", " digests", "Digested", "feedest", "digiter", "digEST", "digesting"], "node": ["event", "remote", " Node", "root", "address", "index", "path", "self", "n", "resource", "server", "uri", "document", " nodes", "Node", "instance", "location", "child", "global", "one", "source", " parent", "connection", "module", "component", "config", "parent", "route", "entity", "local", "object", "name", "internal", " child", "ode", " namespace", " source", "network", " annotation", "odes", "element", "point"], "external": ["remote", "ex", "n", "resource", "outer", "secondary", "intern", "ternal", "instance", "account", "global", " External", "outside", "client", "source", "binary", "target", "international", "out", "export", "https", "local", "object", "environment", " remote", "multiple", " global", "External", "internal", "name", "e", "tern", "Intern", "reference", "network", " foreign", "foreign", "element"], "messageDigest": ["messageModested", " messageDigger", "messageMarkest", " messageDigesting", " messageHashest", "messageDigger", "MessageDigester", "messageDigenge", "messageDesignested", "messageDesignger", "messageDested", "messageHashesting", "messagedigest", "messagedigester", "messageDigester", "MessageSignenge", "messageHashester", " messageHashesting", "messageHashested", " messageDigester", "MessageSignested", "messageMarkested", "MessageDigested", "messageSignenge", "messageDigesting", " messageDesignested", "MessageSignest", "messageModester", "messageDest", "messageModest", "messageMarkester", " messageHashested", "messageDigested", " messageDesignester", " messageDigested", "messageSignester", "messageDester", "messagedigger", "messagedigested", "MessageSignester", "messageMarkenge", " messageHashester", "messageSignested", "messageModesting", "messageDenge", "MessageDigest", " messageDesignger", "messageDesignester", "messageDesignest", "messageSignest", "messageDesignesting", "MessageDigenge", "messageHashest", " messageDesignest"]}}
{"id1": "1485383", "id2": "7044685", "code1": "    private void runGetAppListing() {\n        DataStorage.clearAppListings();\n        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId);\n        AppListingList appListingList;\n        try {\n            HttpRequest request = requestFactory.buildGetRequest(url);\n            request.addParser(jsonHttpParser);\n            request.readTimeout = readTimeout;\n            HttpResponse response = request.execute();\n            appListingList = response.parseAs(AppListingList.class);\n            if (appListingList != null && appListingList.appListings != null) {\n                operationStatus = true;\n                DataStorage.setAppListings(appListingList.appListings);\n            }\n            response.getContent().close();\n        } catch (IOException e) {\n            AppsMarketplacePluginLog.logError(e);\n        }\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 0, "substitutes": {"runGetAppListing": ["runGetApplicationlistings", "runGetApplicationListling", "runGetApplistling", "runGetApplistings", "runGetAppListings", "runGetApplistInfo", "runGetAppListling", "runGetAppSearchling", "runGetAppSupportInfo", "runGetAppSupporting", "runGetApplicationlisting", "runGetApplicationListings", "runGetAppSupportling", "runGetApplicationListInfo", "runGetAppSearching", "runGetApplisting", "runGetAppSearchings", "runGetAppSearchInfo", "runGetAppListInfo", "runGetApplicationlistling", "runGetApplicationlistInfo", "runGetApplicationListing", "runGetAppSupportings"], "url": ["resource", "route", "string", "channel", "href", "host", "http", "proxy", "service", "URL", "path", "api", "feed", "Url", "json", "download", "address", "build", "l", "connection", "base", "server", "location", "config", "f", "e", "i", "image", "page", "result", "ssl", "data", "b", "uri", "buffer", "client", "source", "re", "builder", "file"], "appListingList": ["appListininglist", "appListingsL", "appListingL", "appListgingList", "appListningEx", "appListningGroup", "appListeningInfo", "appListINGList", "appListitingEx", "appListingsList", "appListdingLayer", "appListitinglist", "appListingsData", "appListdingList", "appListningData", "appListINGL", "appPoolinglist", "appListingLayer", "appListingGroup", "appStingList", "appListingingType", "appListillingType", "appListeningMap", "appListninglist", "applistingEx", "appHoldinginglist", "appListeningList", "appStingLayer", "appListgingInfo", "appHoldingingType", "appLingInfo", "appListningList", "appLeningEx", "appHoldingingList", "appListingsMap", "appStINGEx", "appListgingEx", "appListingingGroup", "applistningData", "applistingList", "appHoldingType", "appListdingEx", "appLeningInfo", "appStingL", "appListitingType", "appPooliningList", "appListingsResult", "appListingEx", "appListingData", "applistingData", "appListitingResult", "appPoolininglist", "appListillingList", "appStingEx", "appStINGList", "appLingEx", "appPooliningGroup", "appLingList", "appStINGLayer", "appListitingLibrary", "appHoldingingLibrary", "appListINGLayer", "appListitingData", "appListiningGroup", "appLingMap", "appStINGL", "appListingType", "appListiningList", "appListningResult", "applistningList", "appListinginglist", "appListingLibrary", "appListingResult", "appListingsLayer", "appListinglist", "appHoldingLibrary", "appListingingList", "appListingsEx", "appPoolingList", "applistningResult", "applistningEx", "applistingResult", "appHoldinglist", "appLeningMap", "appListillingLibrary", "appListillinglist", "appHoldingList", "appListingsInfo", "appListingInfo", "appLeningList", "appListingMap", "appListgingMap", "appListINGEx", "appListeningEx", "appPoolingGroup", "appListingingLibrary", "appListdingL", "appListitingList"], "request": ["resource", "application", "use", "project", "push", "xml", "call", "Request", "method", "http", "service", "condition", "proxy", "input", "report", "have", "queue", "post", "json", "object", "child", "address", "user", "build", "command", "hello", "rate", "server", "query", "get", "complete", "e", "trip", "q", "callback", "writer", "transfer", "result", "page", "next", "remote", "parse", "req", "r", "job", "message", "uri", "buffer", "client", "re", "builder", "create"], "readTimeout": [" readSocket", "readingSocket", "writetimeout", "readingtimeout", "readSocket", "writeTime", "readTime", "writeSocket", "readtimeout", "readAttempt", " readTime", "readertimeout", "writeTimeout", "readingTimeout", "readerTimeout", " readtimeout", "readerTime", "readerAttempt", "readingTime", "readingAttempt", "writeAttempt"], "response": ["Response", "resource", "application", "status", "full", "respond", "site", "reply", "http", "version", "report", "api", "wave", "feed", "onse", "json", "object", "resp", "connection", "generation", "document", "server", "array", "e", "success", "received", "image", "writer", "res", "result", "page", "next", "output", "error", "data", "message", "stream", "client", "body", "re"]}}
{"id1": "20588811", "id2": "15904772", "code1": "    public void run() {\n        long time = System.currentTimeMillis();\n        logger.info(\"Version: \" + version);\n        String hostname = properties.getProperty(\"mercuriushost\");\n        String protocol = properties.getProperty(\"mercuriusprotocol\");\n        String port = properties.getProperty(\"mercuriusport\");\n        String path = properties.getProperty(\"mercuriuspath\");\n        String action = properties.getProperty(\"mercuriusaction\");\n        logger.info(\"Getting Timex Data --- \" + getTimeDifferent(time));\n        String xml = timexfrmk.getUnsynchedSessionsXMLFormat();\n        logger.info(\"Done getting Timex Data --- \" + getTimeDifferent(time));\n        if (timexfrmk.getSessionCount() > 0) {\n            try {\n                logger.info(\"Sending Timex Data to Mercurius --- \" + getTimeDifferent(time));\n                String data = URLEncoder.encode(\"action\", \"UTF-8\") + \"=\" + URLEncoder.encode(action, \"UTF-8\");\n                data += \"&\" + URLEncoder.encode(\"data\", \"UTF-8\") + \"=\" + URLEncoder.encode(xml, \"UTF-8\");\n                if (isAdminFeedKeySet()) {\n                    data += \"&\" + URLEncoder.encode(\"adminfeedkey\", \"UTF-8\") + \"=\" + URLEncoder.encode(adminfeedkey, \"UTF-8\");\n                    logger.debug(\"Using adminfeedkey to authenticate\");\n                } else {\n                    Authenticator.setDefault(new CustomAuthenticator(user, password));\n                    logger.debug(\"Using user/pwd to authenticate\");\n                }\n                String u = protocol + \"://\" + hostname + \":\" + port + path;\n                logger.debug(\"Posting xml data to: \" + u);\n                URL url = new URL(u);\n                URLConnection conn = url.openConnection();\n                conn.setRequestProperty(\"User-Agent\", \"TimexMercurius/\" + version);\n                conn.setDoOutput(true);\n                OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                wr.write(data);\n                wr.flush();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                StringBuffer s = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    s.append(line);\n                }\n                if (s.length() > 0) {\n                    logger.debug(s.toString());\n                    if (s.toString().indexOf(\"Result:\") != -1) {\n                        logger.info(s.toString().substring(s.toString().indexOf(\"Result:\")));\n                        if (s.toString().indexOf(\"Result: Successful\") != -1) {\n                            timexfrmk.updateSessionsStatus();\n                        }\n                    } else {\n                        logger.error(s.toString());\n                    }\n                } else {\n                    logger.info(\"No data returned\");\n                }\n                wr.close();\n                rd.close();\n            } catch (MalformedURLException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (IOException e) {\n                logger.error(e);\n                logger.trace(e, e);\n            } catch (Exception e) {\n                logger.error(e);\n                logger.trace(e, e);\n            }\n        } else {\n            logger.info(\"There is nothing to send.  Everything has already been synchronized\");\n        }\n        timexfrmk.close();\n        logger.info(\"Done!!! Total Time: \" + getTimeDifferent(time));\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 0, "substitutes": {"run": ["Run", "execute", "process", "client", " Run", " test", "unit", "build", "up", "app", "running", "release", "install", "exec", "server", "work", "system", "worker", "start", " running", "runner", "test", "loop", "update", "sleep", "create"], "time": ["timeout", "temp", "stage", "etime", "ip", "times", "im", "cache", "current", "hour", "request", "volume", "depth", "version", "service", "money", "right", "year", "micro", "length", "content", "mode", "count", "age", "up", "rate", "server", "work", "clock", "size", "now", "name", "date", "TIME", "value", "home", "space", "image", "start", "tim", "counter", "ime", "type", "timer", "info", "loop", "message", "sleep", "Time", "later", "file"], "hostname": [" hostNAME", "hostcode", "addresscode", "portNAME", "addressn", " hostn", "hostn", " hostline", "addressname", " hostcode", "Hostpath", "hostpath", "hostline", "portline", "Hostname", "localhostNAME", "Hostn", "addresspath", "localhostline", "localhostname", "Hostcode", "portname", " hostpath", "hostNAME"], "protocol": ["extocol", "Prototype", "propolution", "propocol", "resourceocol", "Protport", "scheport", "resourceotype", "protport", "extport", "scheocol", "propport", "propotype", "scheotype", "tocol", "resourcename", "extotype", "tport", "protolution", "extname", "scheolution", "resourceport", "tname", "Protolution", "Protocol", "prototype", "protname", "totype"], "port": ["username", "ip", "host", "method", "table", "secret", "limit", "service", "phone", "key", "length", "user", "address", "Port", "profile", "server", "name", "ports", "pool", "value", "password", "type", "PORT", "point", "target", "plugin", "uri", "version", "file"], "path": ["resource", "route", "string", "host", "Path", "method", "secret", "version", "api", "key", "user", "dir", "location", "config", "session", "code", "ath", "password", "home", "image", "format", "filter", "type", "id", "pattern", "uri", "text", "name", "file"], "action": ["resource", "stage", "token", "function", "act", "step", "method", "call", "view", "script", "service", "input", "auth", "active", "user", "ack", "agent", "event", "actions", "query", "Action", "session", "image", "format", "filter", "error", "type", "style", "plugin", "account", "info", "activity", "file", "sort"], "xml": ["txt", "mail", "application", "ml", "description", "zip", "string", "mx", "context", "http", "www", "response", "log", "feed", "files", "ww", "json", "email", "doc", "events", "content", "plex", "ez", "document", "event", "model", "X", "work", "x", "config", " XML", "office", "php", "ws", "code", "value", "image", "example", "tx", "html", "output", "ql", "message", "info", "update", "stream", "text", "body", "form", "name", "file"], "data": ["resource", "entry", "token", "media", "function", "send", "description", "string", "dat", "results", "method", "request", "str", "http", "response", "input", "api", "open", "feed", "empty", "key", "post", "auth", "json", "database", "download", "content", "object", "batch", "connection", "document", "actions", "DATA", "complete", "array", "session", "dump", "i", "image", "format", "to", "record", "result", "change", "next", "output", "message", "info", "update", "stream", "text", "body", "one", "file"], "u": ["bu", "us", "uu", "n", "c", "ru", "o", "universal", "uid", "U", "ur", "ue", "ui", "uv", "cu", "user", "p", "up", "l", "ut", "f", "uno", "e", "su", "i", "ul", "a", "uc", "h", "hu", "v", "ou", "tu", "b", "nu", "uri", "uni", "lu", "un"], "url": ["resource", "n", "channel", "host", "http", "service", "www", "response", "URL", "ll", "api", "open", "Url", "download", "user", "p", "browser", "l", "connection", "base", "server", "config", "sl", "f", "page", "ssl", "fl", "r", "b", "web", "uri", "client", "file"], "conn": ["ch", "serv", "ob", "n", "c", "Connection", "channel", "act", "http", "oa", "Conn", "ann", "conv", "ctx", "con", "api", "open", "util", "p", "l", "connection", "net", "cn", "rc", "cp", "exec", "server", "f", "enc", "cli", "connect", "h", "socket", "cb", "ssl", "ai", "obj", "b", "en", "comm", "nc", "info", "ec", "client"]}}
{"id1": "20735941", "id2": "14450108", "code1": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"getFile": ["openfile", "openFile", "openFiles", "createfile", "createFile", "createResource", "getResource", "newResource", "newFiles", "getfile", "getFiles", "openResource", "newFile", "newfile", "createFiles"], "home": ["first", "base", "project", "family", "path", "folder", "log", "include", "default", "owner", "host", "location", "name", "domain", "hub", "this", " HOME", "build", "HOME", "Home", "user", "root", "library", "directory", "parent", "class", "join", "bar", "www", "back", "resource", "plus", "h", "search", "store", "server", "dir", "up", "house", "f"], "fileName": ["FileType", " filePart", "fullPart", "remotePath", " filePath", "fileNum", " fileUrl", "filename", "FileName", "remoteName", "singleName", "fullname", "remoteUrl", "urlname", "singlename", "resourceUrl", " fileNum", "urlName", "fullPath", "filePart", "fileType", "FilePath", "FileNum", "FilePart", "urlPath", "singlePath", "fullName", "resourcePath", " filename", " fileType", "urlNum", "filePath", "fileUrl", "singleType", "resourceName", "Filename"], "file": ["fp", "FILE", "base", "job", "place", "local", "output", "e", "use", "el", "feed", "zip", "current", "child", "model", "db", "path", "folder", "log", "function", "money", "filename", "name", "play", "image", "lock", "ile", "fe", "plain", "run", "lib", "or", "File", "type", "live", "connection", "class", "user", "object", "parent", "rule", "handler", "table", "buffer", "uri", "resource", "it", "get", "http", "store", "l", "line", "source", "work", "up", "data", "dir", "letter", "full", "part", "f", "le", "be"], "url": ["ource", "address", "base", "job", "bb", "ob", "el", "feed", "io", "URL", "zip", "path", "log", "sl", "Url", "host", "location", "string", "name", "ls", "conn", "image", "lib", "org", "ssl", "i", "r", "connection", "b", "object", "rule", "www", "pull", "loc", "socket", "ur", "fr", "uri", "service", "api", "resource", "lr", "http", "l", "source", "server", "data", "page", "download", "coll", "impl", "web", "rl", "f", "il"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "e", "io", "inc", "isin", "ini", "input", "In", "s", "stream", "inner", "image", "c", "a", "i", "r", "b", "n", "again", "pull", "socket", "resource", "inn", "plus", "is", "into", "l", "data", "line", "up", "source", "inside", "init", "lin", "ac", "as", "f"], "out": ["net", "exec", "flow", "base", "OUT", "client", "outs", "IN", "output", "bin", "exp", "io", "inc", "conn", "ext", "In", "inner", "to", "write", "err", "this", "Out", "plain", "writer", "i", "b", "again", "object", "ex", "o", "null", "co", "socket", "sync", "resource", "copy", "is", "line", "data", "source", "up", "init", "serv"]}}
{"id1": "15500892", "id2": "18164929", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandGID", "getRandomGuid", "getRandomIGuid", "getRandGUID", "getRandGuid", "getRandomUID", "getRandUuid", "getRandomGCuid", "getRandomIGUID", "getRandomGCid", "getRandomGid", "getRandomGID", "getRandUUID", "getRandUid", "getRandomIGID", "getRandomUUID", "getRandomUuid", "getRandUID", "getRandomUid", "getRandGid", "getRandomGCID", "getRandomIGid", "getRandomGCUID"], "secure": ["active", "https", "secondary", "force", "depth", "session", "allow", "remote", "seed", "encrypted", "exclusive", "timeout", "smart", "ssl", "require", "zip", "deep", "random", "pure", "sensitive", "secret", "external", "proxy", " insecure", "service", "sec", "confirmed", "config", "server", "protect", "weak", "Secure", "ce", "unsigned", "sr", "debug", "safe", "host", "security", "use", "stable"], "md5": ["md2", " MD2", "md500", " md500", " md3", "cmd512", "MDql", "MD5", "MD500", " md512", "MD11", "MD512", "md512", " MD500", "md11", " mdql", "cmdql", " MD11", " md2", "MD2", " MD3", "mdql", " MD5", "cmd5", "cmd3", " md11", "md3", "MD3"], "sbValueBeforeMD5": ["sbValueAfterMS95", "sbValueBeforeMD3", "sbValueBeforeMC5", "sbValueAfterMS55", "sbValueBeforeMP1", "sbValueBeforeD65", "sbValueAfterMP3", "sbValueAfterMD95", "sbValueAfterMS65", "sbValueBeforeMP3", "sbValueAfterMS5", "sbValueBeforemd25", "sbValueBeforeAMD3", "sbValueBeforeMAC0", "sbValueBeforeMS95", "sbValueBeforemd3", "sbValueBeforemd375", "sbValueBeforeDER1", "sbValueGivenMD375", "sbValueBeforeAMD5", "sbValueBeforeDER20", "sbValueBeforeMS512", "sbValueBeforeSHA1", "sbValueBeforeMP7", "sbValueBeforeMS375", "sbValueBeforeDER55", "sbValueBeforeMD55", "sbValueBeforeMI5", "sbValueBeforeD5", "sbValueBeforeMAC55", "sbValueBeforeMS20", "sbValueGivenmd512", "sbValueGivenmd3", "sbValueAfterMD20", "sbValueBeforeMS5", "sbValueBeforemd95", "sbValuebeforeMD005", "sbValueBeforeMD75", "sbValueBeforeDER005", "sbValueAfterMD7", "sbValueBeforeSHA5", "sbValueAfterMS75", "sbValueBeforeMS7", "sbValueBeforeMD7", "sbValueAfterMD0", "sbValueBeforeMI3", "sbValueAfterMS25", "sbValueBeforeMR25", "sbValueBeforeDER5", "sbValueAfterMD25", "sbValueBeforeAMD1", "sbValueBeforeMS75", "sbValuebeforeSD5", "sbValueBeforeSD005", "sbValueAfterMP1", "sbValueAfterMP7", "sbValueAfterMS0", "sbValueAfterMS20", "sbValueBeforeAMD20", "sbValueBeforeMS25", "sbValuebeforeSD20", "sbValueAfterMS1", "sbValueAfterMD1", "sbValueBeforeMD20", "sbValueBeforeMD1", "sbValueBeforeMD95", "sbValueBeforeDER0", "sbValueBeforemd65", "sbValuebeforeMD5", "sbValueBeforeMS65", "sbValueBeforeMI20", "sbValueBeforeMS55", "sbValueGivenMD3", "sbValueBeforeMI1", "sbValueAfterMD75", "sbValueBeforeMS0", "sbValueBeforeMAC5", "sbValueBeforeMI7", "sbValuebeforeSD005", "sbValueBeforeSD1", "sbValueBeforeMD0", "sbValueGivenMD512", "sbValueBeforeDER3", "sbValueBeforeD3", "sbValueAfterMP5", "sbValueBeforeD75", "sbValueBeforeMD512", "sbValueGivenmd5", "sbValueBeforeSD20", "sbValueAfterMD55", "sbValueBeforeMD25", "sbValuebeforeSD1", "sbValueAfterMD3", "sbValueBeforeMD65", "sbValueGivenmd375", "sbValueBeforemd75", "sbValuebeforeMD20", "sbValueGivenMD5", "sbValueAfterMD65", "sbValueBeforeMP5", "sbValueBeforeMD005", "sbValueBeforemd5", "sbValueBeforeMS3", "sbValueAfterMS3", "sbValueBeforeMD375", "sbValueBeforeSHA20", "sbValueBeforeMAC3", "sbValueAfterMD5", "sbValueBeforeMC3", "sbValueBeforeMS1", "sbValuebeforeMD1", "sbValueBeforeMR95", "sbValueBeforeMC375", "sbValueBeforeMC512", "sbValueBeforemd512", "sbValueBeforeMR3", "sbValueBeforeSD5", "sbValueBeforeSHA005", "sbValueBeforeMR5"], "time": ["offset", "etime", "loc", "name", "version", "times", "depth", "error", "type", "slice", "cost", "seed", "mode", "tim", "timeout", "event", "counter", "Time", "user", "size", "clock", "year", "TIME", "work", "random", "tz", "race", "count", "money", "value", "ime", "speed", "date", "rate", "duration", "delay", "id", "timer", "hour", "host", "length", "start"], "rand": ["rh", "rol", "reg", "version", "depth", "q", "risk", "error", "type", "range", "seed", "clean", "rank", "min", "gen", "winner", "bot", "rc", "rule", "rage", "mid", "win", "cr", "r", "root", "year", "raid", "max", "chance", "random", "lang", "rr", "Rand", "count", "serial", "order", "round", "ng", "rate", "delay", "id", "ro", "index", "right", "res", "pick", "alpha", "bit"], "valueBeforeMD5": ["valueBeforeMP53", "valueBeforeMD85", "valueBeforeMC3", "valueAfterAMD53", "valueBeforeMP2", "valueBeforeMD3", "valueBeforemd3", "valueBeforeMP5", "valueInsideMD3", "valueBeforeMC5", "valueBeforeMP3", "valueBeforeMD53", "valueAfterMD53", "valueInsideMD2", "valueInsideMD85", "valueBeforeAMD3", "valueBeforemd5", "valueBeforeAMD5", "valueBeforemd85", "valueBeforeAMD53", "valueAfterAMD5", "valueBeforeMC2", "valueBeforeMD2", "valueAfterMD3", "valueBeforeMC85", "valueAfterAMD3", "valueBeforeAMD2", "valueInsideMD5", "valueAfterMD2", "valueBeforemd2", "valueAfterAMD2"], "array": ["feature", "app", "error", "data", "vector", "archive", "batch", "allow", "arr", "range", "Array", "audio", "database", "pair", "any", "binary", "expression", "sample", "cache", "instance", "section", "collection", "shape", "angle", "address", "row", "list", "storage", "image", "value", "api", "arrow", "air", "object", "our", "number", "view", "function", "message", "result", "record", "integer", "area", "string", "element", "ray"], "sb": ["SB", " SB", "BB", "bm", "cb", "sl", "ob", "sg", "nn", "si", "lp", "bj", "gb", "s", "sbm", "bs", "sth", "bt", "eb", "lab", "bh", "xb", "bl", "binary", "kb", "bb", "rob", "mb", "sv", "bp", "ruby", "rb", "sq", "buffer", "abb", "lb", "stab", "zb", "lr", "sa", "pb", "ab", "wb", "nb", "src", "bsp", "bf", "sf", "orb", "usb", "obb", "fb", "bc", "ib", "buf"], "j": ["x", "job", "ji", "ij", "f", "y", "jj", "bj", "q", "g", "p", "k", "ie", "pr", "jp", "br", "num", "part", "l", "aj", "ja", "e", "key", "o", "dy", "d", "i", "z", "ch", "js", "J", "v", "li", "code", "n", "ii", "uj", "c", "jo", "index", "jl", "adj", "out", "length", "obj", "end"], "b": ["x", "be", "bin", "BB", "job", "cb", "f", "y", "bit", "bs", "p", "k", "eb", "binary", "bb", "bi", "B", "br", "mb", "l", "bug", "e", "bc", "rb", "d", "i", "bar", "db", "lb", "n", "ab", "c", "pb", "a", "bf", "orb", "fb", "nb", "ib", "ob"], "valueAfterMD5": ["valueBeforeMD7", "valueAfterMP3", "valueAfterVM7", "valueAfterMP5", "valueBeforeMP2", "valueBeforeMD3", "valueBeforeMP5", "valueAfterMD7", "valueBeforeMP3", "valueBeforeMP7", "valueAfterVM5", "valueAfterMP7", "valueAfterAMD5", "valueAfterVM2", "valueBeforeMD2", "valueAfterMD3", "valueAfterAMD3", "valueAfterVM3", "valueAfterMD2", "valueAfterMP2", "valueAfterAMD7", "valueAfterAMD2"]}}
{"id1": "1798720", "id2": "15645004", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"save": ["change", "apply", "transfer", "load", "make", "archive", "setup", "upload", "build", "release", "report", "transform", "Save", "install", "update", "pack", "copy", "store", "data", "process", "move", "stage", "saving", "create", "dump", "open", "clone"], "packageName": ["modulePath", " packagePart", "moduleName", "sourcename", "pluginName", "moduleInfo", "directoryPath", " packagePath", "packagePart", " packagename", "sourceName", "packageInfo", "packagename", "directoryname", "sourcePath", "directoryName", " packageNames", "PackagePath", "PackageName", "directoryInfo", "packageNames", "directoryDir", "directoryPart", "pluginDir", "pluginPart", "PackageDir", "directoryNames", "pluginPath", "packagePath", " packageInfo", "moduleDir", "PackageNames", "sourceDir", "PackageInfo"], "fileContents": ["getContents", "getNames", "FileContent", "imageNames", " fileHours", "imageParts", " fileContent", "ileContents", "fileSources", " fileTextures", "FileContents", "ileNames", "fileContent", "ileTextures", " fileSources", "imageContents", "FileSources", "fileParts", "fileHours", "imageHours", "fileTextures", "FileTextures", "ileSources", "FileNames", "FileHours", "getParts", "getContent", "FileParts", " fileParts"], "fileNames": ["fileTypes", "FileTypes", "fNumbers", "pagenames", "viewTypes", "pageNames", "filenames", "playName", "FileName", "fullContents", "FileContents", "fTypes", "pageTypes", "playContents", "logNames", " fileName", "fName", "logName", "fullNames", "fNames", " filenames", "logTypes", "fullTypes", "fullName", "logContents", "viewnames", "FileNames", "viewNames", "playNames", " fileTypes", "fileNumbers", "fileName", "FileNumbers", " fileNumbers"], "dirBase": ["directoryBased", "packageRoot", "folderBase", "directoryBase", "DirDir", "modulebase", " dirbase", "Dirbase", "dirRoot", "DirKit", " dirRoot", "dirBased", "directoryKit", "moduleBased", "packageBase", " dirPath", "directorybase", "dirbase", "dirDir", "dirPath", "packagebase", "DirBase", "directoryDir", "folderBased", "DirRoot", "moduleKit", "folderbase", "DirPath", "packagePath", "moduleDir", "folderDir", "dirKit", "moduleBase"], "packageDir": ["modulePath", "folderBase", "directoryFolder", " packagePath", "directoryPath", "directoryUrl", "PackageDirectory", "folderPath", "packageDirectory", "packageFolder", "parentFile", "directoryFile", "parentDir", "packageBase", "PackageFile", "PackagePath", "directoryDirectory", " packageBase", "directoryDir", "packageUrl", " packageUrl", "PackageDir", " packageFile", "packagePath", "packageLib", " packageFolder", "folderLib", "moduleDir", "moduleLib", "parentUrl", " packageDirectory", "folderDir", "parentFolder", "packageFile", " packageLib", "moduleBase"], "created": ["result", "controlled", "edited", "required", "established", "needed", "formed", "updated", "left", "found", "activated", "path", "creator", "paid", "Created", "true", "released", "creation", " Created", "made", "aaaa", "generated", "failed", "added", "confirmed", "used", "null", "icated", "produced", "existent", "loaded", "raised", "founded", "owned", " existed", "create", "were", "successful", "worked", "authorized", "called", "ed"], "currentPath": ["newPath", "CurrentDirectory", "newpath", "currentLocation", "CurrentPath", "currentPage", "newLocation", "CurrentRoot", " currentLocation", "CurrentPage", " currentRoot", "currentlypath", "Currentpath", "currentlyDirectory", " currentPage", "currentDirectory", "currentRoot", "currentlyPath", " currentpath", "currentlyPage", "newRoot", "CurrentLocation", " currentDirectory", "currentpath"], "i": ["qi", "v", "z", "k", "ip", "ai", "ti", "I", "e", "id", "io", "current", "iu", "xi", "x", "ini", "index", "eni", "start", "name", "ui", "li", "u", "hi", "inner", "s", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "j", "ie", "info", "ori", "b", "n", "bi", "zi", "slice", "isi", "ri", "uri", "p", "gi", "ix", "it", "h", "fi", "key", "di", "oi", "me", "init", "d", "yi", "ji", "part", "mu", "f", "pi"], "file": ["fp", "base", "place", "feed", "io", "child", "path", "folder", "log", "filename", "out", "name", "s", "play", "ile", "files", "fe", "or", "File", "pe", "b", "rule", "per", "il", "ul", "uri", "resource", "http", "l", "source", "work", "up", "dir", "entry", "letter", "data", "full", "unit", "book", "f", "le"], "fos": ["foes", "ufos", " fosh", "Fou", "vops", "flou", "flis", " fis", "voes", "fou", "flops", " fob", "Fops", "Fosh", "Fos", "ofosh", "Fis", "ofos", " fo", "flosh", "cfob", " fops", "ufob", "fios", "Foes", "Fios", "fosh", "vios", "ufoes", "ufo", "fis", "cfo", " fios", "vos", "ofou", "fo", "cfoes", "cfos", "fops", "flos", " foes", "ofops", "fob"], "fileSrc": ["fileDrs", "fileDrec", "fileSsrc", "fileSrec", "fileAsrec", "FileSrc", "fileAsource", "fileNRC", " fileSrs", "fileDrc", "fileSrs", "fileAsRC", " fileDRC", "fileAssrc", " fileSsrc", "FileSource", "FileDRC", "fileSource", "FileDrec", " fileDsrc", " fileDrs", "fileAsrc", "fileSRC", "fileAsrs", "FileSRC", "fileNrs", "fileDource", " fileSRC", "fileNsrc", "fileDRC", "fileNrc", "FileDrc", "FileSrec", "FileDource", " fileDrc", "fileDsrc"], "fileDst": ["fileDsc", "FileSsc", "FileFst", "fileSsrc", "fileEnsc", "FileSrc", "fileSst", "fileFST", "fileDrc", "fileEnST", "fileNsc", "FileDST", "FileDsc", "fileSST", "fileFst", "FileFST", "fileDaysc", "fileDayrc", "FileDst", "fileFrc", "FileFsc", "fileDST", "fileNst", "FileFrc", "fileNsrc", "fileNrc", "FileDrc", "FileSst", "fileEnrc", "FileDsrc", "FileSsrc", "fileSsc", "fileFsc", "fileDayst", "fileDaysrc", "fileEnst", "fileDsrc"], "reader": ["audio", "builder", "re", "e", "right", "io", "rr", "worker", "rer", "ler", "row", "er", "stream", "driver", "inner", "editor", "read", "Reader", "keeper", "or", "layer", "r", "report", "rx", "handler", "oder", "per", "loader", "ner", "ri", "parser", "iter", "buffer", "rc", "data", "entry", "ro", "ry", "server", "rar", "director", "reading", "book", "author"], "writer": ["ger", "wa", "written", "wire", "master", "maker", "writ", "builder", "w", "output", "e", "war", "worker", "ws", "ler", "er", "out", "inner", "driver", "word", "write", "rw", "widget", "wr", "editor", "words", "element", "Writer", "riter", "r", "connection", "player", "o", "with", "handler", "per", "walker", "socket", "loader", "outer", "parser", "buffer", "message", "office", "wrapper", "key", "document", "writers", "data", "entry", "server", "width", "sheet", "work", "value", "later", "book", "author", "writing"], "line": ["url", "lc", "header", "error", "column", "job", "str", "id", "feed", "model", "log", "le", "ge", "row", "string", "name", "end", "Line", "response", "lines", "word", "cr", "write", "link", "character", "code", "LINE", "look", "type", "connection", "definition", "text", "object", "rule", "block", "sync", "cle", "message", "buffer", "key", "jo", "lf", "page", "data", "lin", "entry", "source", "l", "letter", "char", "style", "inline", "pass", "part", "unit", "comment", "item", "cell", "stroke"]}}
{"id1": "530882", "id2": "2668634", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandRewrap", "readAndRewrap", "readAndRewrites", "readAndrewwrite", "readAndRebrap", "readAndRebrites", "readandrewrites", "readandrewrite", "readAndRebrite", "readAndRewwrite", "readAndSwrap", "readAndRebwrite", "readandRewwrite", "readAndrewrite", "readAndrewrites", "readandRewrites", "readAndSwrites", "readAndSwwrite", "readandrewrap", "readandRewrite", "readAndSwrite", "readandrewwrite", "readAndrewrap"], "inFile": ["loginfile", "outFiles", "oldFiles", "oldFile", "loginFilename", "inputFile", "outSourceFile", " infile", "loginFiles", "loginFile", "InFile", " inFilename", "oldfile", "inSourceFile", "oldFilename", " inSourceFile", "inFiles", "inputfile", "InSourceFile", "inputFilename", "outFilename", "outfile", "infile", "InFiles", " inFiles", "inputFiles", "Infile", "inFilename"], "outFile": ["outFILE", "newStream", " outDir", "processFile", "processPlace", "exfile", "exFile", "Outfile", " outfile", "outputFilename", " outStream", "offPlace", "thisFILE", "newfile", "thisfile", "thisFile", "processFilename", "outDir", "outputPlace", "outPlace", "newDir", "processFILE", "outputfile", "OutDir", "offFile", "exFilename", "outputFILE", "OutStream", "OutFile", "outFilename", "newFile", "outputFile", "outfile", "offFilename", "thisFilename", "outStream", "offFILE", "exFILE"], "iis": ["Iis", " iIS", "iniIs", " iris", " iais", "ciais", "ciis", "iniris", "ciris", " iIs", "iIS", "ciiss", "ciIs", "IIS", "iais", "iiis", "iiiss", "Iais", "iniiss", " iiss", "ciIS", "iniIS", "iiIS", "iiIs", "iIs", "iris", "iniis", "Iiss", "iiss", "iiris"], "dcmParser": ["dcrLoader", "dcrReader", "dkmHelper", "dpmParser", "dbmPlugin", "dcmPlugin", "fpmReader", "dcmarser", "dbmParser", " dpmLoader", "fcmparser", "dCMParser", "dmoduleparser", "dCMHandler", "dcrJar", "dmReader", "fcmParser", " dpmJar", "dpmJar", "DcmReader", " dpmLanguage", "dcrPar", "fpmparser", " dcrReader", " dcrPlugin", " dcmLoader", "dcmJar", "dmmLoader", "dkmParser", "dcmparser", "dcrParser", "fpmHandler", "dpmLoader", "dhemReader", " dcmReader", "dhemJar", "dpmHandler", "dmmPlugin", "dpmPlugin", " dcmPolicy", "dmissionReader", " dcmLanguage", "dkmPlugin", " dpmarser", "dmissionLanguage", "dpmarser", "dmLoader", "dcmLoader", "dcmReader", " dpmPar", "dCMReader", "DcmJar", "dkmPolicy", "dhemParser", " dpmPlugin", "fcmReader", "dbmHelper", "dCMLoader", "fcmHandler", " dpmPolicy", "dmodulePlugin", "dpmInstallation", "dmParser", "dpmPolicy", "dmissionPlugin", "dbmPolicy", "DcmParser", " dpmParser", " dcmparser", " dpmReader", "dmoduleReader", "dcrPlugin", "dhemInstallation", "dpmHelper", "dcmLanguage", "dpmPar", " dpmparser", "dpmparser", "dcmPolicy", "dmcarser", " dcrLoader", "dmoduleParser", " dcmPar", " dcmJar", "dcmPar", "dmoduleJar", "dcmInstallation", "dpmLanguage", " dpmHelper", "dmcPar", "dmcParser", "dcmHandler", "dcrarser", "dcmHelper", "fpmParser", "dmmParser", " dcmPlugin", "dCMparser", "dmmparser", "DcmInstallation", "dmcJar", "dmPlugin", " dcrParser", " dcmHelper", "dmissionParser", "dpmReader", "dCMPlugin", " dcmarser"], "ds": ["ls", "uds", "parts", "ays", "eps", "cs", "ps", "ts", "ss", "sync", "session", "asi", "ys", "Db", "s", "DS", "iss", "js", "services", "src", "vals", "tx", "cdn", "conn", "data", "des", "da", "sys", "rs", "vs", "ras", "ws", "ros", "ks", "os", "qs", "utils", "dt", "drivers", "ants", "is", "bs", "pd", "icks", "dat", "gd", "dr", "dds", "nas", "ins", "amps", "points", "Ds", "di", "dd", "xs", "ld", "details", "gs", "ads", "ns", "ils", "df", "tes", "Os", "db", "d", "dc"], "pdReader": ["pbStream", "xdRead", "hdReader", "pcLoader", "pdStream", "dsLoader", "ddRunner", "xdReader", "ddLoader", "xdWriter", "hdStream", "hdWriter", "hdRead", "hdreader", "pcRead", "pdreader", "dsreader", "xdreader", "pcReader", "pbLoader", "dsWriter", "dsReader", "hdRunner", "dsRead", "ddReader", "pbReader", "pdLoader", "ddStream", "pdRunner", "pcWriter", "hdLoader", "pbRunner", "pdRead"], "out": ["cache", "session", "at", "s", "w", "to", "image", "down", "default", "builder", "director", "url", "base", "name", "null", "ext", "code", "write", "temp", "key", "group", "as", "result", "copy", "sync", "client", "with", "model", "word", "conn", "OUT", "data", "writer", "object", "img", "up", "io", "obj", "password", "term", "over", "dev", "layer", "auto", "outs", "lib", "cli", "her", "diff", "user", "parent", "db", "order", "output", "point", "line", "sys", "later", "array", "outer", "gen", "external", "exp", "Out", "login", "o", "inc", "doc", "flow", "dot", "net", "inner", "store", "page", "pass", "ex", "manager", "oder", "in", "device", "exec", "child", "list", "connection", "lock", "full", "again", "file", "part", "ssl", "err", " in", "co"], "dcmEncParam": ["dcmEstParameter", "dcmElType", "dcmEncPar", "dcmDecPar", "dcmSecParam", "dcmEstPar", "dcmDecArg", "dcmEstParam", "dcmArchParam", "dcmArchArg", "dcmEnParameter", "dcmEnType", "dcmEncArg", "dcmElPar", "dcmDecParam", "dcmSecPart", "dcmEncPart", "dcmEncType", "dcmElParam", "dcmArchParameter", "dcmEnParam", "dcmEnPart", "dcmDecPart", "dcmDecParameter", "dcmElParameter", "dcmSecType", "dcmEnArg", "dcmSecPar", "dcmEncParameter", "dcmEnPar", "dcmDecType", "dcmEstType"], "pdWriter": ["hdReader", "PDWriting", "htWrite", "pdWrite", "ddWriter", "PDWrite", "PDWriter", "htWriting", "dpWrite", "dpWriting", "htWriter", "dpWriter", "pdWriting", "hdWriter", "hdOutput", "pdOutput", "dpReader", "htReader", "dsWrite", "hdWrite", "dsOutput", "dsWriter", "ddReader", "ddWrite", "ddOutput", "dsReader", "PDReader"]}}
{"id1": "19050432", "id2": "17286898", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "                public void run() {\n                    BufferedReader reader = null;\n                    String message = null;\n                    int messageStyle = SWT.ICON_WARNING;\n                    try {\n                        URL url = new URL(Version.LATEST_VERSION_URL);\n                        URLConnection conn = url.openConnection();\n                        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                        String latestVersion = reader.readLine();\n                        latestVersion = latestVersion.substring(latestVersion.indexOf(' ') + 1);\n                        if (!Version.getVersion().equals(latestVersion)) {\n                            message = Labels.getLabel(\"text.version.old\");\n                            message = message.replaceFirst(\"%LATEST\", latestVersion);\n                            message = message.replaceFirst(\"%VERSION\", Version.getVersion());\n                            messageStyle = SWT.ICON_QUESTION | SWT.YES | SWT.NO;\n                        } else {\n                            message = Labels.getLabel(\"text.version.latest\");\n                            messageStyle = SWT.ICON_INFORMATION;\n                        }\n                    } catch (Exception e) {\n                        message = Labels.getLabel(\"exception.UserErrorException.version.latestFailed\");\n                        Logger.getLogger(getClass().getName()).log(Level.WARNING, message, e);\n                    } finally {\n                        try {\n                            if (reader != null) reader.close();\n                        } catch (IOException e) {\n                        }\n                        final String messageToShow = message;\n                        final int messageStyleToShow = messageStyle;\n                        Display.getDefault().asyncExec(new Runnable() {\n\n                            public void run() {\n                                statusBar.setStatusText(null);\n                                MessageBox messageBox = new MessageBox(statusBar.getShell(), messageStyleToShow);\n                                messageBox.setText(Version.getFullName());\n                                messageBox.setMessage(messageToShow);\n                                if (messageBox.open() == SWT.YES) {\n                                    BrowserLauncher.openURL(Version.DOWNLOAD_URL);\n                                }\n                            }\n                        });\n                    }\n                }\n", "label": 0, "substitutes": {"openNamedResource": ["openNamedresource", "openNamingresource", "openParamedResources", "openNestedURI", "openNestedresource", "openParamedResource", "openNamingURI", "openNnamedresource", "openParamingResource", "openParamedURI", "openNamingResource", "openNamedURI", "openParamingresource", "openNamingResources", "openNamedResources", "openNnamedResources", "openNnamedResource", "openNestedResource", "openNestedResources", "openParamedresource", "openParamingResources", "openNnamedURI", "openParamingURI"], "name": ["base", "resource", "NAME", "prefix", "version", "filename", "key", "info", "full", "string", "class", "ame", "definition", "path", "Name", "type", "part", "uri", "named", "size", "word", "id", "file", "data", "sea", "username", "names", "str", "value", "old", "n", "source", "parent", "url", "address"], "in": ["kin", "err", "ini", "resource", "login", " out", "inner", "inn", "gin", "val", "input", "din", "In", "pc", "fc", "rec", "bin", "conn", "b", "pin", "r", "IN", "again", "token", "ic", "oin", "source", "nin", "edIn", "result", "cin", "out", "ins", "as", "socket", "ac", "thin", "con", "data", "rin", "i", "reader", "win", "get", "vin", "connection", "inc", "f", "url"], "propsURL": ["proopsURL", "probsUL", "perrsFile", "ProsUrl", "perrsurl", "prolsURI", "protsFile", "proopsUR", " propsurl", "PropsURL", "prodsURL", "propsURI", "propdsUrl", "perrsURL", "PropsUrl", "protsURL", "propsCL", "prosUL", "proppsLL", " propsUL", "prodsSSL", "proppsUR", "pronsLL", " prodsURL", "ProsSSL", "prorsUrl", "proppsUrl", "propsELF", "propsLL", "pronsUR", "proportsURL", "prolsurl", "propsFile", "probsUrl", "proportsurl", "prorsUR", "prorsurl", " propsSSL", " prodsurl", "progsurl", "protsurl", "progsURI", "propsurl", " propsURI", "prosUrl", "proportsURI", "prodsURI", "prorsURL", " prodsCL", " proportsUL", "propdsLL", " propsUR", "procsSSL", " proportsUrl", "procsURI", "perpsURL", "prosURI", "PropsSSL", " propsELF", "prorsFile", "propsSSL", "prodsLL", "PropsURI", "ProsURI", "proppsURL", " prolsURI", "proopsLL", "proportsLL", "prorsELF", " prolsURL", "prodsFile", "prodsCL", " propsLL", "probsLL", "perpsurl", "propsUrl", " proportsELF", " prolsurl", "prosURL", "prodsUrl", "procsurl", "prodsurl", "prolsURL", "proportsUrl", "propdsUR", "perpsFile", "procsURL", "proportsUL", "proopsUrl", "proportsELF", "pronsUrl", " prodsURI", "propsUL", "prodsUR", "prosLL", " proportsLL", "proopsURI", " propsUrl", "probsURL", "pronsURL", " proportsURL", "proportsUR", " proportsUR", "progsCL", "propsUR", "propdsURL", "proopsurl", "prolsSSL", "proopsELF", " prolsSSL", "proopsCL", "progsURL", "procsUrl", "prosSSL", " propsCL", "ProsURL", "proportsSSL"], "urlConn": [" urlCond", "sslCond", "urlconn", "URLContext", "URLConnect", "URLConn", "httpConf", "urlContext", "urlConf", "fileCmd", "urlCond", "sslConn", "fileConnect", "fileConn", "fileCond", "httpConn", "httpContext", "sslCod", "httpConnect", " urlCod", " urlConnect", "URLConf", "urlCmd", " urlContext", " urlConf", " urlconn", "sslCmd", " urlCmd", "urlConnect", "httpconn", "httpCod", "sslconn", "urlCod", "sslConnect"], "httpURL": ["HttpML", "httpsURI", " httpurl", "autoSSL", "HttpUR", "autoURL", "autourl", "apiUrl", "autoUrl", "HttpURI", "httpurl", "httpsUR", " httpUrl", "apiURL", "httpsSSL", " httpUR", " httpML", "httpsURL", "apiML", "httpURI", "httpsurl", "HttpUrl", "httpML", "apiUR", " httpSSL", "HttpURL", "httpUrl", " httpURI", "httpsUrl", "httpSSL", "httpUR"], "hdrVal": ["hheaderVol", "hndDef", "hdval", "hndVal", "hreqStr", "hrValue", "hdrval", "hheaderStr", "hdrStr", "hhrDef", "hhrBu", " hheaderStr", "HdrBu", "hreqVal", "hheaderVal", "HhrDef", "Hhrval", " hdrStr", " hheaderValue", "hDRValues", "hdrValue", "HdrDef", "hdVal", "hrStr", "hrcValue", "HdrVal", " hdrVol", "hrVol", "HhrValue", "hdrDef", "hhrval", "hdrValues", "hrcDef", "HhrVal", "hndValue", "hdrVol", "Hdrval", "hDRVal", "hdValues", "hreqVol", " hheaderVol", "hdValue", "hhrValues", "hrcBu", "hndBu", "hheaderValue", "HdrValue", "hdrBu", "hrcVal", " hheaderVal", "hhrValue", "hDRval", "hreqValue", "HdrValues", "hhrVal", "hDRValue", "HhrValues", "HhrBu", "hrVal", " hdrValue"], "code": ["rule", "index", "ode", "coded", "codes", "content", "check", "grade", "expected", "pc", "version", "reason", "age", "zip", "message", "count", "text", "mode", "key", "rate", "info", "charge", "cat", "status", "string", "c", "pe", "class", "ack", "state", "core", "rc", "cod", "success", "ie", "type", "line", "result", "fail", "Code", "number", "ce", "response", "xx", "cc", "see", "zone", "test", "co", "ge", "data", "id", "score", "const", "e", "category", "level", "go", "comment", "desc", "error", "one", "value", "no", "ec", "msg", "url", "header"]}}
{"id1": "14324112", "id2": "16556717", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"innerProcess": ["innerprocess", " outerAccept", " outerprocess", " outerMethod", " innerprocess", " outerProcess", "innerAccept", " innerMethod", "middleProcess", "middleprocess", " innerAccept", "middleMethod", "middleAccept", "innerMethod"], "curi": ["biri", "buri", "CURI", "Cri", "ldirectory", "Ciri", "requiri", "fri", "ucuri", "cturi", "cdirectory", "ciri", " cURI", "cacheuri", "Curi", "nuri", "furi", "cacheui", "fcri", "ucURI", " cuid", " cuni", "ucuni", " cdirectory", "ctiri", " cri", "nURI", "Cdu", "lcouri", "cuid", "fcURI", "Cui", "cURI", "fui", "uciri", "cacheURI", "firi", "lcURI", "lcuri", "ctuid", " cdu", "lcri", " cui", "requuri", " ciri", "cri", "couri", "lcui", "lciri", "fcumi", "cumi", "cdu", "ctURI", "requumi", " couri", "cachedu", "bURI", "fURI", "bdirectory", "luid", "cui", "lURI", "fcuri", "numi", "liri", "funi", "luri", "nri", " cumi", "cuni", "lri", "requuni", "luni", "Couri", "lumi"], "maxsize": [" maxSize", "defaultize", "minsize", "totalize", "MAXname", "totalSize", "MAXsize", "maxscale", "Maxize", " maxname", "totalsize", "minaddress", "maxaddress", "lastSize", "defaultsize", "totalscale", " maxscale", "lastaddress", "MaxSize", "Maxname", "MAXSize", "minSize", " maxaddress", "maxSIZE", "lastsize", "defaultSize", "axize", "Maxscale", "axSize", "Maxsize", " maxize", "maxize", "maxSize", "maxname", " maxSIZE", "MAXSIZE", "MaxSIZE", "axsize"], "regexpr": ["perepr", "rerexpr", "reqor", "rerePR", "rexpp", "replexPr", "rerePr", "refplexpp", "rentaxpr", "regexpect", "pegexexpr", "pereexpr", "REgexr", "perePr", "replexpr", "requpr", "replaypt", "reuxpr", "resexPr", "replexpp", "replexpl", "resexps", "regexor", "equPr", "egexps", "rentaxexpr", "replexexpr", "rerexps", "regexps", "replaypr", "replayr", "REgexpt", "rentaxPR", "rexpr", "equps", "regexPR", "regexpt", "refgexpp", "refgexpl", "rerepr", "regexpl", "REgexpr", "REqr", "refgexpr", "refplexpl", "rerexpect", "reqpt", "regexpp", "refplexpr", "resexpect", "reqpr", "reuxpl", "refgexPr", "pegexpr", "reuxPr", "regexexpr", "pegexPR", "replayor", "perePR", "egexPr", "rexpl", "refplexPr", "REqpr", "REqpt", "REqor", "rerexPr", "egexpr", "resexpr", "REgexor", "regexr", "reqr", "reuxpp", "pegexPr", "rexPr", "rentaxPr", "equpect", "egexpect", "rereexpr", "regexPr", "requps", "equpr", "requpect", "replexPR", "requPr"], "cs": ["ls", "TS", "ps", "ts", "cache", "str", "sync", "cf", "c", "tc", "GC", "ca", "ds", "acs", "ci", "rs", "ce", "ras", "ec", "cells", "cas", "ces", "ks", "pc", "ms", "cos", "lc", "qs", "spec", "cr", "fs", "sc", "acts", "bs", "cks", "ch", "cus", "cc", "ins", "acks", "cp", "ches", "cl", "coll", "cm", "gs", "ics", "Cs", "ences", "ns", "css", "mc", "cn", "CS", "ctx", "js", "cms", "cons", "wcs"], "digest": ["signusher", "Digusher", "Digester", " digher", "DigEST", "digEST", " digusher", "digusher", "Diger", "returngest", "shaher", "returnEST", "returnest", "shaEST", "shaer", "signEST", "diggest", " digEST", "diger", "signester", " diger", "Digest", " diggest", "Diggest", "digester", "returnester", "shaest", " digester", "signest", "digher", "Digher"], "s": ["p", "ls", "su", "ps", "summary", "sb", "ss", "str", "lines", "sync", "session", "c", "f", "w", "i", "groups", "l", "services", "single", "strings", "ws", "cells", "n", "g", "si", "ms", "u", "b", "params", "sl", "states", "h", "string", "details", "sets", "ns", "r", "t", "o", "sv", "S", "v", "js", "d"], "m": ["p", "text", "im", "mm", "f", "i", "M", "dm", "l", "imm", "fm", "nm", "mac", "n", "g", "v", "rm", "sm", "ms", "b", "um", "gm", "tm", "h", "machine", "mi", "bm", "arm", "cm", "mo", "am", "wm", "mc", "r", "t", "ym", "pm", "d"]}}
{"id1": "22441244", "id2": "1180878", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"send": ["text", "message", "create", "set", "parse", "build", "from", "reply", "open", "export", "execute", "add", "sent", "transfer", "post", "exec", "address", "append", "Send", "write", "submit", "end", "get", "start", "delete", "mail"], "hsession": ["hession", "hesess", "openssession", "hsess", "hsSession", "hhessions", "hhort", "HSsession", "hSession", "hesort", "hsort", "hmSession", "hesession", "hsessions", "opensess", "hmsession", "hhess", "HSessions", "hmessions", "hessession", "opensession", "opensort", "opensessions", "hessions", "hmession", "opensSession", "HSSession", "hssession", "hhsession", "hhSession", "hhession", "HSession"], "session": ["message", "cache", "client", "port", "essions", "ession", "state", "event", "manager", "project", "proxy", "resource", "chat", "document", "class", "mail", "security", "server", "host", "sl", "connection", "parent", "response", "site", "Session", "context", "application"], "repositoryName": ["reposicationName", "reposositoryEmail", "reposessionEmail", "repositoryEmail", "reposicationFamily", "repoositoryNAME", "repositiveEmail", "repositoryPath", "repositoryNAME", "repoitoryEmail", "reposicationAddress", "repoositoryEmail", "repoitoryNAME", "repositiveName", "repoitoryPath", "reposositoryAddress", "reposicleName", "repositoryFamily", "repositiveNAME", "reposositoryFamily", "repoitoryFamily", "reposositoryName", "reposicleFamily", "reposessionNAME", "reposessionName", "repositivePath", "repoositoryFamily", "repoositoryName", "repoositoryAddress", "reposicleAddress", "reposositoryPath", "repoositoryPath", "reposicationEmail", "repositoryAddress", "repoitoryAddress", "repoitoryName", "reposicleEmail", "reposositoryNAME", "reposessionPath"], "ideIdint": ["ideInn", "ideidInt", "ideInints", "ideAuthints", "ideInfoint", "ideNameout", "ideTimeInt", "ideInInt", "IDEidint", "IDENamenumber", "ideAuthInt", "IDEIdints", "ideidint", "IDENameInt", "ideIdn", "IDEIdn", "IDEIdInt", "IDEidInt", "ideidn", "ideIdout", "ideNameint", "ideTimenumber", "ideInfonumber", "IDEidints", "ideAuthint", "ideInfoInt", "ideNameInt", "IDENameout", "ideIdints", "ideTimeint", "ideInint", "IDENameint", "ideNamenumber", "IDEIdnumber", "ideIdInt", "IDEidn", "IDEIdint", "ideIdnumber", "IDEIdout", "ideidints", "ideAuthn", "ideInfoout", "ideTimeout"], "to": ["account", "source", "contact", "message", "top", "about", "summary", "token", "TO", "client", "phone", "uri", "with", "company", "title", "options", "po", "by", "from", "location", "name", "mail", "sub", "address", "target", "prefix", "tel", "To", "settings", "office", "response", "template", "site", "mobile", "reply"], "cc": ["account", "contact", "cs", "phone", "client", "uc", "cf", "ac", "c", "company", "tc", "card", "ca", "ci", "from", "ce", "comment", "ec", "lc", "CC", "cr", "code", "sc", "password", "address", "cus", "rc", "nc", "cl", "cca", "cn", "ct", "ck", "cb", "dc"], "bcc": ["pce", "bbrc", " bck", "abcc", "brc", "abce", "fck", "bbck", "bc", "pc", " bc", "pck", "abck", " bce", "fc", "bbcc", "bce", " brc", "pcc", "frc", "bck", "bbc", "fcc", "abc"], "subject": ["message", "method", "filename", "uri", "phone", "username", "author", "head", "title", "state", "object", "format", "reply", "comment", "description", "reason", "host", "sub", "header", "prefix", "ject", "Subject", "request", "template", "response", "content", "mail"], "body": ["text", "source", "secret", "message", "normal", "style", "summary", "media", "pod", "length", "Body", "empty", "inner", "view", "pass", "how", "tree", "line", "data", "left", "resource", "money", "object", "comment", "description", "shell", "url", "base", "name", "reason", "code", "bound", "password", "function", "zip", "header", "string", "connection", "lock", "plain", "wrapper", "html", "part", "template", "response", "foot", "content"], "attachments": ["Attachments", "messings", "messents", "embedment", "embedments", "messment", "messments", "attachings", "Attachents", "embedents", "embedings", "attachents", "Attachings", "Attachment"], "isHtml": [" isChtml", "isChhtml", "isWhtml", "isHive", "isChive", "isWhive", "isHahtml", "isChtml", " isHttp", "isPhttp", "isPhtml", " isWhail", "isChttp", " isChttp", "isHttp", " isHive", "isHaail", " isWhive", " isWhhtml", " isChhtml", "isCail", " isChail", "isChail", "isWhhtml", "isHhtml", " isHail", " isWhtml", "isHatml", "isHattp", "isWhail", "isCive", "isPhail", "isCtml", "isPhhtml", " isHhtml", "isHail"], "charset": ["chARSete", "charsET", "charsetting", "chasesET", "chearsetting", "CharsET", "Charset", "charseting", "Charsetting", "chansetter", "chasesetting", "chacksET", "charsets", "cheansET", "chackset", "cheansete", "chanspace", "chasetter", "chearspace", "chashesET", "chasET", "chasheset", "chearset", "chaseting", "Charsets", "charsete", "chaspace", "chARSetting", "chaseseting", "chARSet", "chasetting", "chanset", "chansetting", "chearsetter", "charspace", "chasets", "Charseting", "chansET", "chansete", "chARSets", "cheanspace", "chearsete", "chaset", "chacksetting", "chaseset", "cheansetter", "chashespace", "cheanset", "cheansetting", "chARSeting", "chearsET", "chARSET", "charsetter", "chacksete", "chashesetter"], "headers": ["types", " recipients", "writers", "lines", " emails", "ers", "content", "options", "groups", "errors", "names", "strings", "metadata", "authors", "params", " messages", "files", "header", " cookies", "settings", "mails", "users", "properties", "classes", "comments", "status"], "priority": ["secret", " recipients", "mode", "phone", "length", "language", "author", "date", "title", "state", "level", " title", "comment", "class", "security", "reason", "code", "theme", "lang", "quote", "prefix", "queue", "template", "comments", " severity", "status", "reply"], "email": ["account", "text", "contact", "message", "create", "result", "business", "output", "international", "generic", "username", "update", "info", "lex", "model", "event", "view", "e", "note", "enter", "line", "oe", "default", "install", "data", "example", "service", "object", "print", "export", "online", "document", "url", "em", "name", "base", "core", "server", "article", "ext", "password", "zip", "entity", "address", "letter", "external", "element", "el", "Email", "engine", "fax", "auto", "en", "html", "test", "office", "ssl", "template", "response", "liner", "gmail", "ilo", "pm", "xml", "mail"], "user": ["account", "me", "uid", "role", "token", "client", "username", "author", "info", "model", "use", "person", "e", "friend", "USER", "unknown", "data", "object", "resource", "consumer", "ip", "character", "name", "string", "connection", "profile", "plugin", "creator", "users", "er", "member", "id", "type", "people", "mobile", "User"], "identity": ["authentization", "publicITY", "authoronymous", "authentifier", "identITY", "ethnicication", "publicity", "idication", "IdentITY", "authentity", "electricentity", "IDENTities", "personentity", "publiciciary", "identonymous", "authorities", "authentITY", "personifier", "ethnicentity", "identifier", "personITY", "ethnicifier", "electriconymous", "idity", "idization", "installity", "authority", "entityization", "electricity", "authorifier", "IDENTentity", "ethnicITY", "electricITY", "authorentity", "Idententity", "identities", "idententity", "IDENTity", "idifier", "entityonymous", "personity", "identication", "identiciary", "installonymous", "installITY", "authentication", "Identities", "authorication", "ethniciciary", "identization", "authorITY", "publicentity", "authoriciary", "ethnicity", "idonymous", "authentonymous", "IDENTITY", "Identity", "entityifier", "entityity", "installentity", "idITY"], "_returnPath": ["_returnHalf", " _returnHalf", "_relationId", "_resultHalf", "_backPart", "_returnpath", "_inputNode", "_correctId", " _backPath", "_correctDirectory", "_backName", "_relationPath", "_correctPath", " _backPart", "_returnId", "_returnText", "_backHalf", "_responsepath", "_returnUrl", "_replyPart", " _returnUrl", "_returnType", "_returnMid", "_replyPath", " _returnName", "_successId", "_backPath", "_displayNode", "_replyUrl", "_displayMid", "_successDirectory", "_responseType", "_returnPart", "_responsePath", "_returnDirectory", "_inputMid", "_resultTo", "_relationText", "_backTo", "_replyNode", "_backpath", "_relationDirectory", "_replyMid", "_returnTo", "_addType", "_addPath", " _backTo", "_resultName", "_returnNode", "_returnName", " _backName", "_successText", "_displayPart", " _backUrl", " _returnPart", " _backHalf", "_resultPath", "_backUrl", "_displayPath", "_addpath", "_inputUrl", "_backType", "_correctText", " _returnTo", "_inputPath", "_displayUrl", "_successPath"], "_from": ["placefor", " _owner", "_for", " _source", "blockto", "_who", "_with", "workto", "_From", "blockfrom", "placeowner", " _error", " _for", "_source", "existingowner", " _with", "blockerror", "_owner", "blockFrom", "workfrom", "placeto", "existingto", "_error", "workwho", " _From", "existingfor", "placefrom", "worksource", "existingfrom", " _who"], "_replyTo": ["_returnFrom", "_replyOf", "_commentTO", "_commentOf", "_commentFrom", "_addTo", "_reasonFrom", "_addPoint", "_respondAddress", "_respondTO", " _replyTO", "_commentTo", "_closeTo", "_respondTo", "_replyTO", "_closeFrom", "_reasonTO", "_replyAddress", " _replyFrom", "_addAddress", "_returnAddress", "_respondPoint", " _returnTO", "_returnTo", "_returnOf", "_closeOf", " _returnFrom", "_addFrom", "_reasonTo", "_returnTO", "_respondFrom", "_replyFrom", "_returnPoint", "_replyUrl", " _returnTo", "_replyPoint", "_returnUrl", "_respondUrl", " _replyUrl", "_closeTO", "_reasonUrl", " _returnUrl"], "_to": ["_about", "Jfrom", "Jtarget", " _about", "_target", "Jabout", " _target", "Jto"], "_cc": ["_cf", " _cd", " _ce", "_cd", "_ce", " _cf"], "_bcc": ["_sbcc", "_bcs", " _abcc", "_rbcs", " _bce", "_bce", " _bc", "_abce", "_rbc", "_sbc", " _abc", "_sbce", "_bc", "_abcs", "_abcc", "_sbcs", "_abc", "_rbce", "_rbcc", " _abce", " _bcs", " _abcs"]}}
{"id1": "12537270", "id2": "8665321", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    public Vector<String> getNetworkServersIPs(String netaddress) {\n        Vector<String> result = new Vector<String>();\n        boolean serverline = false;\n        String line;\n        String[] splitline;\n        try {\n            URL url = new URL(netaddress);\n            URLConnection connection = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                if ((serverline) && line.startsWith(\";\")) {\n                    serverline = false;\n                }\n                if (serverline) {\n                    splitline = line.split(\":\");\n                    result.add(splitline[1]);\n                }\n                if (line.startsWith(\"!SERVERS\")) {\n                    serverline = true;\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n", "label": 0, "substitutes": {"parse": ["apply", "load", "raw", "xml", "ge", "patch", " analyse", "eval", "build", "read", "format", "report", "Parser", "scan", "see", "ract", "arse", "update", "pack", "parser", "ize", "match", "process", "se", "split", "open"], "link": ["address", "base", "rel", "local", "linked", "e", "id", "URL", "load", "path", "xml", "location", "string", "name", "li", "ln", "word", "bug", "image", "lock", "like", "type", "info", "html", "connection", "route", "text", "tag", "loc", "Link", "message", "uri", "lang", "add", "links", "http", "href", "l", "line", "source", "data", "file", "page", "match", "style", "inline", "ink", "msg"], "conn": ["mc", "rn", "ai", "ca", "client", "ann", "io", "db", "pt", "er", "connect", "Config", "out", "cr", "cp", "cmd", "c", "ci", "err", "cc", "rt", "ct", "ssl", "connection", "r", "Connection", "apt", "n", "rec", "config", "loc", "socket", "nt", "enc", "dc", "p", "pg", "dr", "rc", "col", "cn", "ch", "act", "pc", "con", "nc", "ac", "Conn", "open", "ctrl", "ctx"], "rd": ["rn", "ra", "reader", "rh", "sr", "rm", "rog", "bd", "rr", "RR", "hr", "rw", "RS", "rt", "dd", "dra", "r", "rg", "rx", "RD", "fr", "ds", "ru", "lr", "dc", "rb", "wd", "nd", "fd", "dr", "rc", "RM", "xd", "ld", "adr", "rss", "rl", "rs", "rid"], "kit": ["net", "wt", "sit", "k", "base", "reader", "util", "w", "fit", "site", "feed", "io", "tools", "pot", "plugin", "py", "ku", "auto", "ui", "cr", "bug", "spec", "bot", "pit", "rt", "kt", "os", "lib", "sci", "format", "t", "ct", "info", "et", "b", "browser", "ut", "rot", "ki", "config", "nt", "Kit", "loader", "api", "p", "tk", "h", "kat", "init", "kin", "qt", "cat", "f", "tool"], "doc": ["md", "bc", "de", "base", "mc", "dec", "tt", "db", "docs", "xml", "tx", "val", "div", "out", "bug", "Doc", "m", "info", "html", "root", "desc", "text", "body", "tag", "config", "loc", "mm", "pub", "fr", "dc", "api", "dom", "document", "http", "dr", "di", "in", "data", "page", "file", "dir", "ref", "d", "coll", "pc", "pos", "ac", "DOC", "open", "f", "msg", "po"], "url": ["address", "base", "util", "el", "feed", "URL", "path", "xml", "log", "sl", "Url", "host", "location", "name", "gl", "bug", "image", "hub", "org", "ssl", "connection", "html", "ll", "cdn", "www", "pull", "loc", "config", "ur", "uri", "lr", "resource", "service", "http", "href", "l", "github", "source", "file", "server", "page", "download", "src", "rl", "blog", "f"], "it": ["v", "lit", "sit", "ip", "st", "stat", "id", "iti", "ic", "iz", "end", "mit", "ci", "It", "pit", "or", "you", "t", "ite", "r", "info", "et", "edit", "nt", "iter", " It", "p", "its", "iterator", "dit", "l", "in", "se", "init", "IT", "split", "ait"], "elem": ["Eade", " neade", "oeler", " nelem", "oelem", "Elem", "oelement", "Element", " Eler", " neler", "Elev", "Eler", "oelev", "eelem", "eelements", "eelement", " Element", "pelem", "eler", " Elem", "seject", "eject", "selements", "Elements", "element", "eeject", "elev", "elements", "pelement", "selem", "selement", "eade", "pelev", " Eade", "peler", "Eject", " nelement"], "s": ["v", "services", "sv", "sch", "params", "scope", "xs", "e", "sets", "ts", "rs", "ws", "sl", "es", "session", "ns", "string", "u", "ls", "c", "set", "spec", "si", "ses", "os", "strings", "m", "t", "ssl", "a", "sb", "r", "g", "b", "js", "n", "ops", "attr", "o", "ps", "sym", "S", "sync", "ds", "fs", "service", "p", "parts", "h", "submit", "se", "server", "d", "details", "ss", "sf", "f", "gs"], "lnk": ["olnkh", "knK", "nnk", "nlok", "lnky", "gnky", "lnks", "linke", "lenke", "gnok", "lnkh", "lenk", "dlks", "lnK", "olnk", "nnke", "nlf", "nlkh", "knkh", "olnf", "dlke", "dnk", "dlok", "linky", "nlks", "dnky", "gnk", "dlky", "olnK", "olnkr", "nlK", "nlke", "dnf", "dnku", "lnkr", "dlf", "knke", "lenks", "linf", "lnf", "olnke", "dnke", "lenky", "nnky", "nlky", "lnke", "dnkr", "gnke", "knk", "dlkr", "lenku", "lnku", "lnok", "nnku", "nlk", "dlk"], "j": ["qi", "jp", "J", "z", "uj", "im", "syn", "ja", "job", "br", "jc", "kj", "x", "index", "name", "note", "obj", "ind", "li", "si", "ij", "adj", "aj", "ii", "y", "oj", "m", "ie", "info", "a", "g", "js", "n", "o", "dj", "fr", "p", "key", "jo", "jl", "ch", "ni", "pos", "ne", "ji", "part", "jj", "pr"], "urlLink": ["urlUrl", "UrlLink", "URLPage", "UrlRel", "urlConnect", "urllink", " urlLine", "resourceConnect", " urlConnect", "strlink", "URLLink", "UrlPath", "resourceLink", "UrlHub", "strLine", "urlRel", " urllink", "urlPage", "resourcelink", "strLink", "URLUrl", " urlUrl", "resourceLine", " urlHub", "fileHub", "UrlPage", " urlPage", "fileLink", "UrlUrl", "urlPath", "strConnect", "URLRel", "urlHub", "filePath", "fileUrl", " urlPath", "urlLine", " urlRel"], "str": ["st", "dec", "sr", "br", "sta", "arr", "spr", "sl", "div", "res", "string", "name", "cr", "hr", "inner", "ext", "obj", "err", "wr", "Str", "t", "r", "b", "js", "text", "n", "kr", "tr", "STR", "enc", "inst", "strip", "fr", "dr", "line", "l", "data", "char", "stri", "elt", "txt", "coll", "pass", "sp", "ctr", "f", "pr"], "i": ["qi", "v", "ip", "ai", "ti", "vi", "I", "uli", "e", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "li", "u", "ui", "hi", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "m", "en", "ori", "info", "b", "n", "o", "zi", "bi", "slice", "ri", "uri", "p", "ix", "gi", "fi", "abi", "in", "di", "oi", "l", "init", "ni", "yi", "chi", "ji", "mu", "f", "pi"], "skip": ["complete", "error", "special", "fast", "replace", " bypass", " skipped", " skipping", "jump", " repeat", "active", "scan", "empty", " exclude", "stop", " duplicate", "iter", "Skip", "add", " scan", "copy", "ips", "append", "loop", " dup", "sp", "cmp"]}}
{"id1": "2518655", "id2": "8801436", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fnOut": ["fpOutput", "fnEx", "lsOutput", "fnIn", "FNOut", "lsOut", "FNIn", "FNOutput", "lsOUT", " fnOUT", "fpEx", "fpOUT", "FNEx", " fnFile", "fnOutput", " fnIn", "fnOUT", "fnFile", "fpFile", " fnOutput", " fnEx", "fpOut", "fpIn", "lsFile"], "writer": ["fd", "widget", "wr", "write", "server", "outer", "writing", "parser", "socket", "writ", "output", "entry", "winner", "editor", "Writer", "key", "out", "ws", "temp", "nw", "builder", "driver", "reader", "war", "riter", "a", "work", "er", "worker", "inner", "usher", "walker", "r", "wa", "handler", "file", "wire", "loader", "w", "per", "writers", "layer", "ler", "word", "buffer", "director"], "i": ["k", "m", "u", "z", "uri", "e", "j", "b", "n", "fi", "ori", "io", "si", "ie", "part", "f", "o", "index", "ci", "h", "type", "s", "iu", "oi", "key", "abi", "ji", "multi", "li", "di", "mi", "ip", "pi", "hi", "xi", "eni", "id", "ti", "v", "gi", "c", "ri", "I", "ai", "ix", "phi", "chi", "ii", "ui", "x", "bi", "ini", "qi", "strength", "p"], "fInput": ["fFormat", " fFormat", "sfinput", "finput", "sfFormat", " fOutput", "fSource", " finput", "fileinput", "fileFormat", "fileInput", "fileSource", "sfInput", "fOutput", "sfSource", "sfOutput", "fileOutput", " fSource"], "in": ["ln", "ins", "In", "b", "n", "connection", "scan", "init", "data", "version", "ner", "reading", "inc", "socket", "f", "gin", "input", "vin", "din", "IN", "inn", "lin", "inas", "out", "s", "conn", "cin", "sin", "kin", "rin", "reader", "win", "inside", "nin", "login", "inner", "min", "id", "bin", "c", "pin", "ini", "again", "line", "isin"]}}
{"id1": "12428013", "id2": "414258", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"polishOff": [" synchronipeOn", " synchroniceOffline", " synchronishingOffline", " polishingOn", " synchronishingOn", " synchroniceDown", " polishingOffline", " synchronishingOff", " synchronipeOff", " synchronishOn", " synchronishOff", " polishOn", " synchronipeDown", " synchronishDown", " polishDown", " synchroniceOn", " polishingDown", " synchronipeOffline", " synchroniceOff", " synchronishOffline", " synchronishingDown", " polishOffline", " polishingOff"], "monitor": ["cm", "oper", "processor", "master", "mc", "stat", "mor", "client", "status", "controller", "pm", "port", "progress", "container", "cher", "log", "function", "conn", "core", "thread", "state", "driver", "umi", "callback", "image", "sm", "widget", "mon", "m", "or", "reason", "component", "duration", "username", "report", "counter", "method", "number", "watch", "object", "program", "directory", "body", "handler", "config", "loader", "period", "update", "message", "timeout", "condition", "meter", "consumer", "don", "match", "clock", "member", "dm", "annot", "timer", "unit", "runner", "control", "manager", "Monitor", "module"], "from": ["actor", "address", "url", "false", "base", "vol", "left", "id", "ou", "path", "owner", "remote", "host", "start", "name", "string", "contact", "range", "action", "prefix", "code", "org", "or", "small", "username", "at", "type", "connection", "component", "user", "route", "front", "with", "back", "loc", "uri", "attribute", "resource", "add", "by", "form", "who", "source", "channel", "server", "since", "email", "From", "about", "origin", "part", "size", "ce"], "to": ["su", "two", "address", "url", "eto", "base", "token", "site", "left", "io", "remote", "TO", "target", "location", "name", "out", "top", "range", "prefix", "database", "toc", "type", "repl", "info", "go", "connection", "user", "To", "so", "o", "with", "dest", "table", "uri", "version", "resource", "by", "key", "into", "source", "server", "file", "pos", "ref", "about", "value", "full", "until", "reply", "size", "po"], "renameTo": ["relameTo", "relenameUrl", "reageTO", "renseTo", "renalto", "renamelTo", "renseFor", "renAMEUrl", "renributeTo", "renAMEToken", "reameTO", "renewTarget", "renAMETo", "renageToken", "renenameUrl", "renamelOf", "renAMETarget", " RenAMEWill", " RenameFor", "renamelFor", "rennameTarget", "reageto", "renseTO", "renokeUrl", "renokeOf", "renameUrl", "renokeTO", "renokeFor", "relenameTo", "renameFor", "rennameTo", "renseOf", "relameto", "relameFrom", "renenameto", " RenameOf", "renameto", "relameTarget", "renamTarget", " RenAMETo", "renameFrom", "renamWill", "renenameTarget", "renameToken", "relalFrom", "reameTo", "renributeWill", "renoketo", " renAMETo", "relalTo", "renageTO", "renenameTo", " renameTarget", "renalTo", "renalFrom", "renalTarget", " RenseOf", "rennameto", " RenseFor", " renAMEFrom", "relameUrl", "renAMETO", "rennameFrom", "renewTo", "renageto", "renAMEFrom", "renalTO", "relalto", "reameToken", "renageTo", "relenameto", "renameWill", "reameto", " RenAMEFor", "renameTarget", "relalTarget", "renamFor", "reageTo", "renameOf", "renokeFrom", "renributeTarget", "renAMEto", "reageToken", " RenAMETarget", " RenameTarget", " RenameWill", "relenameFrom", "renalToken", "renributeFor", "renameTO", "renAMEWill", " RenseTo", "renenameFrom", " RenseTO", " renAMETarget", "renewFrom", "renokeTo", "renamelTO", " RenameTo", " RenameTO", "renamTo", "renAMEFor", " renameFrom"], "ftpClient": ["ftpCommunity", "ftpChannel", "ftcpChannel", " ftapiCloud", " fttpClient", "ctcpServer", " ftlClient", "ftmClient", " ftpoCenter", "ftcpResource", " ftiServer", " ftiClient", " ftpCloud", "ftpsContainer", "aftpStream", "ftbCan", " ftpiChannel", " ftapiClient", "ftfClient", "ftlCommunity", "ftpcClient", "ftcpCenter", "fttpStream", "ctpChannel", " ftpoClient", " ftapiHelper", " ftpContainer", " ftpclient", "ftfCenter", "ftpclient", "ftpcCommunity", " fttpContainer", " ftpiServer", "ftoHost", "ftpiServer", "ftcpCommunity", "ftfCloud", "fticlient", "ftcGuest", "ftlConnection", "ftoCan", "ctcpResource", " ftpChannel", "ftpoCenter", "ftcpCloud", "ftlCenter", "ftpiClient", "ctpResource", "ftpcServer", " ftpHelper", "ftcServer", "ftpGuest", "ftpcHelper", "ftfpCloud", "ftpiHost", "ftpsControl", "ftcpGuest", "ftbHost", "ftfpChannel", "ftpsClient", " ftpGuest", " ftoCan", "ftapiServer", " fttpClass", "ftcpClient", " ftnServer", "ftnHost", "afttClient", " ftpHost", "ftfpResource", "ctpServer", "ftcClient", "ftmResource", " ftnHost", " ftiGuest", "fttpHost", "ftfpServer", "afttStream", "ftiGuest", " ftlCommunity", "ftcpConnection", "ftcpHost", "ftpoCloud", "ftcpServer", "fttpContainer", "ftpoClient", "ftpsClass", " ftoServer", "fttpClass", " ftpServer", "ftfpClient", "fttpControl", " ftpConnection", "ftpResource", "ftpcControl", "ftmChannel", " ftapiServer", "ftpConnection", " ftpClass", "aftpClient", "ftapiHelper", " ftpControl", " ftpiHost", " ftnClient", "ctcpClient", "ftpHost", "ftfpCenter", "ftbServer", "ftpcClass", " ftpCenter", "ftmServer", "ftbrClient", "ftapiClient", "ftnServer", " fticlient", "ftpCloud", "fttClient", "ctcpChannel", "ftcpHelper", "ftoClient", "ftiClient", "ftiServer", "ftbClient", "fttStream", "ftbrStream", "ftoServer", " ftpCommunity", "ftcclient", "ftnClient", "ftpClass", "ftpcContainer", " ftpCan", "ftpcCloud", "fttpCan", "ftpStream", " ftoHost", " ftpiClient", "fttpChannel", "ftpiChannel", "fttpClient", " ftlConnection", "ftpServer", "ctpClient", "ftcpclient", "fttpServer", "ftpcConnection", " fttpControl", "ftpHelper", "ftpContainer", " ftpoCloud", " ftlCenter", "ftpCan", "ftapiCloud", "ftpCenter", "ftlClient", "ftpcCenter", " ftoClient", "ftpControl"], "ftpHolder": ["ftpWather", "fttpChard", "ftpWholder", "ftpcWolder", "ftphander", "fttpChander", "ftphholder", "ftphold", "ftpSholder", "fttpHook", "ftpChard", "ftpWolder", "ftpWorkather", "ftpcHather", "ftpHander", "ftpholder", "ftpShander", "ftpcHold", "ftpShard", "ftpShook", "ftpHook", "ftpWorkholder", "ftpcWather", "ftpHholder", "fttpHolder", "ftpCholder", "ftpcWholder", "ftpHather", "ftphather", "ftpHold", "fttpHander", "ftpChook", "ftpWorkolder", "ftpHard", "ftpChander", "fttpChook", "fttpCholder", "ftpcHolder", "ftpWorkold", "ftpWold", "fttpHard", "ftphard", "ftphook", "ftpcWold", "ftpcHholder"], "iter": ["ser", "oper", "result", "ipper", "iv", "ip", "ver", "collect", "ter", "chain", "reader", "itter", "enter", "finder", "e", "id", "ator", "inc", "skip", "cher", "index", "er", "former", "keep", "ir", "end", "inner", "set", "next", "err", "Iterator", "or", "ite", "i", "info", "over", "loc", "list", "walker", "gener", "ner", "outer", "it", "iterator", "its", "http", "in", "entry", "file", "izer", "init", "Iter", "limit", "coll", "size", "inter", "f", "ener"], "element": ["air", "ele", "e", "section", "empty", "option", "attribute", "document", "data", "article", "letter", "server", "coll", "value", "atom", "part", "header", "token", "child", "Element", "folder", "environment", "er", "input", "action", "or", "event", "component", "et", "definition", "number", "object", "key", "page", "match", "activity", "comment", "item", "cell", "result", "reader", "el", "container", "inner", "entity", "editor", "layer", "parent", "per", "resource", "content", "email", "variable", "member", "module", "output", "owner", "plugin", "node", "ee", "next", "this", "expression", "type", "connection", "text", "service", "optional", "line", "entry", "style", "instance"]}}
{"id1": "6625074", "id2": "2936678", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"SHA1": ["SHAOne", "SHA256", "sha256", "SHA384", "HA1", " SHA384", "HA384", " SHAOne", "HA256", "shaOne", "sha1", " SHA256", "sha384", "HAOne"], "text": ["template", "test", " Text", "token", "str", "output", "transfer", "path", "font", "input", "pattern", "string", "name", "out", "obj", "context", "ext", "struct", "word", "image", "hex", "plain", "code", "editor", "format", "class", "object", "config", "message", "buffer", "bytes", "content", "translation", "Text", "in", "data", "letter", "source", "password", "contract", "value", "txt", "TEXT"], "sha1hash": ["ha1hex", "shaOnetext", "sha1cap", "ha2Hash", "shaOneHash", "sha2cap", "sha81cap", "sha81Hash", "sha256password", "sha1text", "sha256text", "sha2hex", "SHA1hash", "sha81log", "sha6cap", "SHA2Hash", "sha_hash", "sha_Hash", "sha6Hash", "SHA1Hash", "sha1Hash", "sha256hash", "sha2log", "SHA1log", "SHA1cap", "ha1sum", "SHA2cap", "ha2hex", "sha81hash", "sha2sum", "sha2hash", "sha_hex", "ha2hash", "SHA1password", "sha1sum", "ha1hash", "SHA1text", "sha6hash", "sha_sum", "sha1log", "shaOnepassword", "sha2Hash", "ha1Hash", "sha1password", "ha2sum", "SHA2hash", "SHA2log", "sha1hex", "shaOnehash", "sha6log", "sha256Hash"], "md": ["MD", "hash", "de", "cf", "mc", "sha", "ms", "dig", "gb", "metadata", "rm", "pm", "bd", "amd", "df", "mo", "meta", "um", "mb", "mt", "cmd", "hd", "pkg", "sm", "rpm", "editor", "m", "dd", " MD", "od", "mm", "ma", "ad", "pd", "cd", "wd", "nd", "mac", "hm", "ld", "d", "mag", "nm", "vd", "dm", "f", "mp"]}}
{"id1": "7981642", "id2": "5049453", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"update": ["h", "save", "up", "key", "delete", "init", "user", "Update", "write", "copy", "address", "check", "register", "replace", "apply", "updated", "sum", "UPDATE", "change", "send", "edit", "build", "post", "end", "url", "exec", "set", "login", "data", "u", "append", "put", "text", "auth", "password", "and", "setup", "insert", "push", "add", "sign", "create", "config"], "mail": ["Email", "gmail", "ip", "m", "hello", "fax", "msg", "html", "ul", "label", "host", "phone", "old", "view", "proxy", "user", "id", "office", "server", "address", "md", "group", "dial", "message", "xml", "date", "value", "file", "dir", "ge", "url", "alt", "login", "model", "zip", "contact", "local", "text", "name", "company", "mails", "password", "string", "front", "folder", "uri", "lock", "gal", "Mail", "source", "who", "username"], "email": ["Email", "gmail", "ip", "eu", "ail", "note", "n", "fax", "element", "hello", "old", "class", "phone", "cn", "el", "host", "enter", "id", "office", "online", "archive", "server", "address", "md", "home", "inet", "info", "dn", "li", "message", "xml", "line", "description", "wd", "cdn", "file", "dir", "en", "url", "alt", "login", "zip", "model", "nick", "log", "text", "name", "mails", "password", "folder", "addr", "uri", "Mail", "username"], "pwd": [" pws", "ppwd", "hwa", " pwa", "Pwt", "Ppass", "ppass", "cpws", "ppwh", "hwd", "Pwa", " pwt", "pppass", " ppassword", "cpWD", "Pwd", "hWD", "pws", "pppassword", "Pwh", "Pws", "pwt", " ppass", " pwh", "pwa", "cpwd", "hpass", " pWD", "Ppassword", "pWD", "pwh", "cpwt", "PWD", "ppassword"], "firstname": ["lastnames", "lastuser", "lastkey", "newname", "caseemail", " firstemail", "caseName", " firstName", "newnames", " firstuser", " firstpass", "lastName", "firstpass", "firstuser", "lastpass", "casename", "firstkey", " firstkey", " firstnames", "casepass", "hostkey", "firstnames", "firstName", "hostname", "hostemail", "newuser", "firstemail", "lastemail", "hostName"], "lastname": [" lastn", "lastnames", "fullName", "fullday", "lastn", "lastday", "secondkey", "secondName", "firstday", "fulln", "lastName", "firstkey", "firstn", " lastday", " lastkey", " lastaddress", " lastName", "firstnames", "firstName", "secondaddress", "firstaddress", "fullnames", "secondname", "fullname", "lastkey", " lastnames", "lastaddress"], "connection": ["db", "sc", "client", "connect", "ca", "Conn", "h", "m", "creator", "relation", "cc", "object", "management", "context", "lc", "cf", "handler", "directory", "server", "conn", "bc", "nc", "graph", "index", "response", "pool", "manager", "con", "function", "connected", "this", "session", "system", "b", "database", "application", " Connection", "document", "di", "ion", "communication", "Connection", "config", "c", "condition"], "attrs": ["attributes", "Attars", " attRS", "atRS", "attr", " attr", "atps", "addributes", "atributes", "addRs", "atacts", "Attrs", "addRS", "addks", "matrs", "attps", "attks", "attRS", " attRs", "attars", " attars", "matps", "Attras", "Attr", "Attps", "addps", "atars", "matars", "attacts", "atrs", "matributes", " attks", "Attributes", " attps", " attributes", "addras", "atr", "attras", "attRs", "atks", "addars", "addr", "atras", "addrs", "Attacts", "AttRs", " attacts"], "sha": ["ha", "mac", "mm", "la", "ca", "h", " SHA", "lambda", "alpha", "asha", "pa", "sche", "ga", "eta", "pg", "ya", "sa", "md", "sh", "alias", "ma", "sum", "va", "a", "acl", "ema", "SHA", "pi", "sm", "base", "ami", "HA", "wa", "ka", "volume", "hi", "shi", "password", "si", "ua", "meta", "da", "na"], "digest": [" digested", "mdester", "tagester", "modests", "DigEST", "mdgest", "mdest", "digcode", " digests", "Digcode", "diggest", "Diged", "digests", "modEST", " digEST", "Digest", "tagested", "Digester", " digester", "modest", "Digests", "digester", " digcode", "digEST", "moded", " diggest", "mdested", "tagest", "diged", " diged", "digested", "Diggest", "Digested", "tagcode"], "hash": ["mac", "ha", "image", "match", "h", "dig", "ag", "html", "ash", "block", "key", "user", "version", "json", "sh", "code", "sum", "array", "message", "rh", "raw", "value", "Hash", "cover", "build", "bh", "url", "enc", "base", "her", "secret", "auth", "bin", "password", "body", "kh", "hed", "hex"], "ctx": ["fw", "sc", "client", "ca", "cas", "ck", "tx", "cci", "cp", "rc", "cc", "cn", "cs", "context", "cr", "pkg", "lc", "cf", "ci", "cb", "conn", "loc", "cu", "bc", " cx", "cca", "cm", "xc", " c", "qa", "tc", " rc", "ctrl", "hw", "conv", "vc", "sq", "jp", "cv", " conn", "cl", "ct", "pc", "anc", "mc", " cs", " context", "cmp", "Context", "config", "c"], "newName": ["NewAddress", "oldname", "NewName", " newEmail", "oldEmail", "NewEmail", "newname", " newAddress", "oldAddress", " newname", "newEmail", "Newname", "newAddress"], "oldName": ["oldPath", "OldAddress", "origPath", "oldHome", " oldname", "OldName", "origEmail", "newHome", " oldPath", "oldEmail", "oldAddress", "newEmail", "origname", "newAddress", "oldname", "OldPath", " oldHome", " oldEmail", "OldHome", "OldEmail", " oldAddress", "Oldname", "origName"]}}
{"id1": "21979714", "id2": "22114133", "code1": "    @ActionMethod\n    public void list() throws IOException {\n        final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/list?version=1000\");\n        final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n        con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n        final InputStream in = con.getInputStream();\n        final byte[] buf = new byte[4096];\n        textArea.setText(\"\");\n        for (int bytesRead; (bytesRead = in.read(buf)) != -1; ) {\n            textArea.append(new String(buf, 0, bytesRead));\n        }\n    }\n", "code2": "    @Override\n    public void actionPerformed(ActionEvent e) {\n        String cmd = e.getActionCommand();\n        boolean askRestart = false;\n        if (cmd == null) return;\n        if (cmd.equals(\"GRAPHVIZ\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"GRAPHVIZ\", \"\");\n                graphVizPath.setText(\"\");\n                owner.mToolsAuxGraphviz.setEnabled(false);\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"GRAPHVIZ\", filename);\n            graphVizPath.setText(filename);\n            owner.mToolsAuxGraphviz.setEnabled(true);\n        }\n        if (cmd.equals(\"IMAGEMAGICK\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"exe\"));\n            chooser.setDialogTitle(\"Open exe file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", \"\");\n                imageMagickPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"IMAGEMAGICK\", filename);\n            imageMagickPath.setText(filename);\n        }\n        if (cmd.equals(\"FINFAMILY.XLS\")) {\n            JFileChooser chooser = new JFileChooser();\n            chooser.setFileFilter(new fi.kaila.suku.util.SettingFilter(\"xls\"));\n            chooser.setDialogTitle(\"Open xls file\");\n            if (chooser.showOpenDialog(owner) != JFileChooser.APPROVE_OPTION) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            File f = chooser.getSelectedFile();\n            if (f == null) {\n                return;\n            }\n            String filename = f.getAbsolutePath();\n            if (filename == null || filename.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", \"\");\n                excelPath.setText(\"\");\n                return;\n            }\n            Suku.kontroller.putPref(owner, \"FINFAMILY.XLS\", filename);\n            excelPath.setText(filename);\n            missingKeys = checkForMissingNames(filename);\n        }\n        if (cmd.equals(Resurses.OK)) {\n            String newPath = Suku.kontroller.getPref(owner, \"FINFAMILY.XLS\", \"\");\n            if (!newPath.equals(exPath)) {\n                askRestart = true;\n                Suku.setFinFamilyXls(newPath);\n            }\n            String input = (String) serverUrl.getSelectedItem();\n            if (input == null) {\n                input = \"\";\n            }\n            if (input.isEmpty()) {\n                Suku.kontroller.putPref(owner, \"SERVERURL\", \"\");\n                if (!originUrl.isEmpty()) {\n                    askRestart = true;\n                }\n            } else {\n                URL url;\n                String resp = null;\n                try {\n                    url = new URL(input + \"SukuServlet\");\n                    HttpURLConnection uc = (HttpURLConnection) url.openConnection();\n                    int resu = uc.getResponseCode();\n                    if (resu == 200) {\n                        byte buff[] = new byte[1024];\n                        InputStream in = uc.getInputStream();\n                        int len = in.read(buff);\n                        resp = new String(buff, 0, len);\n                        uc.disconnect();\n                    }\n                } catch (Exception e1) {\n                    e1.printStackTrace();\n                }\n                if (resp != null && resp.toLowerCase().startsWith(\"finfamily\")) {\n                    Suku.kontroller.putPref(owner, \"SERVERURL\", input);\n                    if (!input.equals(originUrl)) {\n                        askRestart = true;\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(this, Resurses.getString(\"SERVER_ERROR\"), Resurses.getString(Resurses.SUKU), JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            int newLoca = loca.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.LOCALE, locas[newLoca]);\n            if (!originLanguage.equals(locas[newLoca])) {\n                askRestart = true;\n            }\n            int newLang = repolang.getSelectedIndex();\n            if (newLang >= 0) {\n                Suku.kontroller.putPref(owner, Resurses.REPOLANG, Suku.getRepoLanguage(newLang, true));\n                Resurses.setLanguage(Suku.getRepoLanguage(newLang, true));\n            }\n            int imageScaler = imageScaling.getSelectedIndex();\n            Suku.kontroller.putPref(owner, \"SCALE_IMAGE\", \"\" + imageScaler);\n            owner.setImageScalerIndex(imageScaler);\n            int seleId = defaultCountryCode.getSelectedIndex();\n            if (seleId >= 0) {\n                selectedCc = ccodes[seleId];\n            }\n            try {\n                Resurses.setDefaultCountry(selectedCc);\n            } catch (SukuException e1) {\n                owner.setStatus(e1.getMessage());\n            }\n            int newDateIndex = dateFormat.getSelectedIndex();\n            Suku.kontroller.putPref(owner, Resurses.DATEFORMAT, dateCodes[newDateIndex]);\n            Resurses.setDateFormat(dateCodes[newDateIndex]);\n            Utils.resetSukuModel();\n            boolean openStreetMap = useOpenStreetMap.isSelected();\n            Suku.kontroller.putPref(owner, \"USE_OPEN_STREETMAP\", \"\" + openStreetMap);\n            String fntSize = dbFontSize.getText();\n            Suku.kontroller.putPref(owner, \"DB_VIEW_FONTSIZE\", fntSize);\n            String lf = lfNames[lookAndFeel.getSelectedIndex()];\n            Suku.kontroller.putPref(owner, \"LOOK_AND_FEEL\", lf);\n            int lfIdx = -1;\n            for (int i = 0; i < lafInfo.length; i++) {\n                if (lafInfo[i].getName().equalsIgnoreCase(lf)) {\n                    lfIdx = i;\n                    break;\n                }\n            }\n            try {\n                if (lfIdx < 0) {\n                    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n                } else {\n                    UIManager.setLookAndFeel(lafInfo[lfIdx].getClassName());\n                }\n                SwingUtilities.updateComponentTreeUI(owner);\n            } catch (Exception e1) {\n                logger.log(Level.WARNING, \"look_and_feel\", e1);\n            }\n            setVisible(false);\n            if (askRestart) {\n                if (missingKeys != null && !missingKeys.isEmpty()) {\n                    SukuPad pad = new SukuPad(this, missingKeys);\n                    pad.setVisible(true);\n                }\n                JOptionPane.showMessageDialog(this, Resurses.getString(\"RESTART_FINFAMILY\"), Resurses.getString(Resurses.SUKU), JOptionPane.INFORMATION_MESSAGE);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"list": ["index", "info", "find", "query", "read", "sort", "split", "sync", "LIST", "load", "show", "export", "check", "request", "get", "search", "delete", "test", "start", "ls", "ping", "pull", "parse", "print", "download", "stop"], "url": ["string", "path", "ssl", "base", "server", "uri", "resource", "lock", "entry", "http", "l", "host", "URL", "fl", "client", "connection", "build", "ob", "config", "file", "cl", "web", "page", "bb", "ll", "log", "conn", "ls", " URL", "blog", "sl", "rl", "pull", "Url", "www", "bug", "ur", "ul", "f", "org", "api"], "con": ["close", "Conn", "ex", "fa", "CON", "cf", "rc", "cons", "ran", "on", "http", "c", "fc", "ctrl", "sub", "run", "fn", "Con", "co", "func", "en", "ec", "client", "cm", "part", "cp", "an", "lc", "uc", "connection", "login", "ch", "open", "conv", "un", "ca", "cl", "xc", "fac", "conn", "exec", "ann", "pc", "ln", "ver", "bc", "com", "can", "ctx", "conf", "connect", "cn", "f", "cur"], "in": ["IN", "i", "input", "ex", "n", "ini", "c", "inner", "as", "socket", "sub", "ins", "bin", "is", "client", "reader", "login", "min", "r", "inc", "data", "vin", "out", "rin", "file", "conn", "rec", "again", "m", "In", "a", "stream", "lin", "b", "conf", "inn", "f", "win", "this", "re"], "buf": ["base", "buffer", "Buffer", "bf", "bd", "bh", "rc", "cb", "grab", "abs", "bin", "ff", "func", "pb", "uf", "la", "bag", "utf", "bu", "cv", "rb", "ab", "cas", "wb", "uc", "buff", "sb", "aka", "data", "conv", "tmp", "src", "fb", "exc", "bb", "vec", "db", "bytes", "bc", "Buff", "bp", "seq", "b", "br", "fab", "batch", "cur", "orig"], "bytesRead": ["byteLength", "tesLength", "wordsLength", " bytesWritten", "bytesFound", "wordsFound", "bytesFind", "BytesRead", "BytesWrite", "byteRead", "stringsLoad", "wordsRead", "tesRead", "bytesLength", "bytesWritten", "bytesread", " bytesLoad", " bytesFound", "BytesLoad", "bytesLoad", "BytesLength", " bytesFind", " bytesread", "tesFound", "stringsFind", "byteWritten", "BytesFind", "byteWrite", "BytesWritten", "stringsRead", " bytesWrite", " bytesLength", "bytesWrite", "tesread", "wordsread", "stringsWritten"]}}
{"id1": "18374598", "id2": "471804", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"download": ["pull", "external", "string", "copy", "open", "archive", "Download", "release", " Download", "install", "setup", "upload", "exec", "url", "get", "load", "loader", "dump", "filename", "transfer", "output", "diff", "data", "write", "update", "name", "file"], "a": ["an", "action", "fa", "aux", "u", "ua", "za", "c", "string", "m", "qa", "ca", "access", "asa", "oa", "area", "A", "input", "na", "da", "about", "as", "cha", "au", "api", "at", "aa", "wa", "sa", "la", "ppa", "ac", "ada", "ad", "aaa", "alpha", "audio", "l", "ha", "amp", "s", "base", "ea", "pa", "url", "addr", "ga", "aw", "ast", "ma", "array", "sta", "af", "e", "am", "i", "auto", "tta", "ae", "data", "r", "b", "t", "ba", "ata", "ab", "va", "name", "art", "file"], "p": ["ap", "ping", "dp", "ip", "u", "c", "pr", "pi", "py", "m", "y", "op", "o", "d", "pat", "after", "api", "np", "pp", "bp", "tp", "l", "part", "w", "pos", "pe", "cp", "pa", "j", "sp", "x", "e", "i", "pre", "q", "start", "h", "fp", "v", "P", "jp", "po", "b", "t"], "td": ["fa", "dc", "det", "txt", "fr", "pc", "pd", "fc", "od", "th", "pb", "dat", "table", "sf", "d", "dl", "aff", "fd", "bd", "pt", "TD", "rt", "cf", "ppa", "ht", "tr", "tn", "hd", "dd", "ld", "ff", "tf", "tif", "cd", "gb", "ud", "dh", "tmp", "dt", "sb", "nd", "af", "fm", "fp", "tl", "file", "elt", "sd", "b", "fb", "t", "lf", "tt", "rd", "buff", "bt", "db", "tc"], "f": ["fa", "df", "fe", "F", "fc", "u", "of", "function", "g", "c", "m", "full", "o", "sf", "d", "fo", "fx", "aff", "fast", "fd", "feed", "cf", "fam", "fold", "handler", "fn", "fs", "l", "ff", "tf", "fw", "base", "w", "j", "fi", "flat", "e", "fm", "i", "uf", "xf", "h", "fp", "fen", "v", "file", "fl", "r", "b", "fb", "t", "bf", "lf", "info", "buffer", "form", "fr", "rf"], "total": ["temp", "done", "local", "percent", "Total", "full", "otal", "current", "sum", "cost", "partial", "post", "doc", "active", "json", "length", "num", "count", "valid", "reported", "scale", "quant", "normal", "base", "all", "upload", "server", "max", "complete", "now", "serial", "set", "ok", "used", "start", "finished", "nt", "next", "error", "last", "info", "parent", "available", "recent"], "progress": ["rss", "resource", "Progress", "done", "status", "c", "current", "step", "rec", "dist", "path", "cost", "partial", "np", "process", "number", "skip", "active", "length", "summary", "num", "content", "conn", "roll", "count", "err", "grade", "resp", "running", "scale", "coll", "wait", "complete", "bar", "xp", "success", "next", "error", "vance", "width", "recent"], "in": ["In", "again", "c", "ini", "IN", "cin", "o", "din", "inner", "bin", "input", "as", "con", "io", "pin", "ins", "ac", "inn", "ie", "kin", "l", "isin", "init", "win", "lin", "url", "gin", "i", "nin", "socket", "v", "login", "reader", "data", "vin", "r", "b", "inc", "source", "stream"], "out": ["ch", "line", "again", "full", "c", "cache", "o", "ex", "call", "inner", "bin", "Out", "log", "io", "outs", "co", "ins", "conn", "fn", "err", "up", "w", "s", "exec", "url", "code", "off", "callback", "to", "extra", "cb", "v", "ext", "output", "error", "data", "obj", "b", "inc", "conf", "parent", "buffer", "update", "client", "file", "flow"], "buf": ["grab", "bh", "auc", "cv", "area", "bin", "box", "queue", "pad", "cf", "seq", "bp", "header", "loc", "br", "bag", "ff", "rc", "cmd", "tmp", "bc", "uno", "pkg", "uf", "cap", "callback", "uc", "bytes", "fp", "cb", "v", "border", "data", "raw", "feat", "Buff", "b", "fb", "buff", "ba", "bf", "buffer", "wb", "rb", "padding"], "n": ["nb", "nit", "not", "u", "N", "g", "m", "current", "c", "o", "d", "node", "dn", "np", "z", "none", "number", "nn", "network", "skip", "num", "length", "no", "nr", "min", "nor", "count", "fn", "br", "l", "ng", "net", "w", "pos", "cn", "j", "coll", "sn", "x", "non", "e", "len", "ns", "i", "rn", "ne", "v", "error", "r", "b", "en", "nc", "un"], "percentage": ["variity", "poundure", "latay", "Percentage", "variide", "metay", " percentages", "percentay", "Percentager", "percentile", "metages", "metage", "latide", "variage", "percentrage", "parage", "percentager", "percentity", "poundages", "latage", "Percenture", "compide", "pardages", "Percentages", "poundage", "metile", "pardure", "pardability", "metency", " percentile", "poundability", "pardage", "missay", "variile", "parages", "percentability", "voltage", "missile", "missrage", "Percentency", "compage", "metrage", "percenture", "percentages", "variay", "Percentability", "varirage", " percentency", "voltile", "percentide", "parile", "voltager", "percentency", "compity", "Percentile", "compay", "latity", "parager", "missage", "voltages"], "tmpPercentage": ["cppPercentrage", "tmppercentile", "tempPercentages", "tmpComple", "tmppercentay", "tmpPassrage", "cppPercentment", "tmpHalfency", "temppercentages", "tmpPassay", "tmpPercentile", "tmpPercentle", "tmppercentment", "cpppercentrage", "tmppercentages", "tmppercentency", "tmppercentrage", "temppercentle", "tmpPercentment", "tmpPassment", "tmpPassile", "ptypercentag", "cppPercentay", "tmppercentle", "tmpPercentency", "tmpPercentrage", "tmpPercentay", "ptypercentage", "tmpMagnment", "tmppercentag", "tmpHalfage", "temppercentency", "ptypercentency", "tmpCompages", "tmpPercentag", "tmpPassency", "ptyPercentage", "tmpCompency", "temppercentage", "tmpMagnrage", "cpppercentay", "ptyPercentency", "tempPercentency", "tmpPercentages", "ptypercentile", "tmpHalfag", "tmpPassage", "tempPercentle", "tmppercentage", "tmpMagnay", "tmpPassag", "tmpCompage", "cpppercentment", "tmpMagnage", "ptyPercentile", "tmpHalfile", "tempPercentage", "cpppercentage", "cppPercentage", "ptyPercentag"], "size": ["sized", "ize", "external", "fee", "send", "speed", "clean", "c", "capacity", "sum", "time", "empty", "length", "content", "address", "unit", "count", "loc", "SIZE", "grade", "scale", "rc", "small", "width", "sn", "max", "sec", "e", "code", "len", "i", "ne", "error", "Size", "data", "esc", "offset", "name", "core"], "checksum": ["timesig", " checksal", "checkme", " checksam", " checksig", "cksam", "cksums", "timessum", "getsumm", " checksme", "getssum", "checksums", "cksum", " Checksme", "timesum", " checkssum", "getsam", "checkum", " checksums", "cksumm", " checksumm", "checksumm", "timesums", " Checksal", "cksig", "checksig", "checksam", "checksal", "checkssum", " Checkssum", "checksme", "checkal", "ckssum", "getsum", " Checksum"]}}
{"id1": "9081749", "id2": "3756429", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["encryption", "Encryption", "decryption", "esccrypt", "Encrypt", "deccrypt", "Encipher", "decrypt", "enccrypt", "encipher", "escrypt", "Enccrypt", "decipher", "escryption", "escipher"], "password": ["pass", "root", "mask", "token", "username", "words", "seed", "sword", "project", "description", "string", "cache", "css", "word", "secret", "Password", "PASS", "wallet", "params", "key", "this", " passwords", "auth", "database", "email", "wd", "pad", "user", "address", "crypt", "weight", "command", "prefix", "phrase", "array", "python", "value", "strip", "image", "data", "picture", "null", "account", "pattern", "parser", "buffer", "message", "text", "parent", "name", "encrypted", "padding"], "encryptType": ["encPTtype", "encriptType", "acryptionTyp", "encryptKey", "ecipherKey", "encryptTypes", "ecryptClass", "acryptionTypes", "encryptionTyp", "ecryptKey", "encertKey", "eciphertype", "encryptionTypes", "ecryptType", "encrypttype", "encertClass", "acryptTypes", "encryptionType", "encipherKey", "encruptType", "encruptTypes", "encryptiontype", "acrypttype", "encerttype", "encruptTyp", "acryptiontype", "encertType", "acryptType", "acryptTyp", "encriptTypes", "encryptClass", "encPTClass", "encryptTyp", "encPTKey", "encrupttype", "ecipherType", "acryptionType", "encriptTyp", "ecrypttype", "encripttype", "encipherClass", "ecipherClass", "encipherType", "encPTType", "enciphertype"], "md": ["df", "mb", "mp", "pd", "hed", "pm", "od", "mand", "rm", "mac", "Cmd", "m", "um", " MD", "d", "hm", "di", "MD", "bd", "hd", "dd", "mc", "cd", "mod", "cmd", "dh", "mag", "f", "gd", "dm", "der", "nm", "amd", "rpm", "dig", "mm", "metadata", "vd", "mad", "grad", "mt", "mo"], "hash": ["body", "hed", "sh", "full", "mac", "cache", "Hash", "fill", "str", "sha", "sum", "how", "log", "search", "hex", "key", "char", "bit", "number", "ashes", "header", "kh", "bug", "build", "count", "print", "flash", "ha", "part", "base", "url", "query", "throw", "ash", "array", "index", "code", "len", "value", "her", "image", "check", "dot", "handle", "html", "h", "memory", "diff", "filter", "data", "error", "digit", "style", "id", "message", "hard", "chip", "ver", "block", "version"], "hexString": ["rawArray", "alphString", " hexFile", "alphFile", "hashString", "pixelFile", "squareString", "squareField", "pixelBuffer", "hexLine", "hexstring", "rawFile", "blackstring", "hexFile", "alphLine", "blackLine", "rawString", "hexSet", "pixelstring", "squareSet", "blackFile", " hexstring", "hashFile", "hashstring", "alphstring", "squareArray", " hexSet", "hexField", "zipString", "blackString", " hexLine", " hexBuffer", "hexArray", " hexArray", "hexBuffer", "zipSet", "pixelString", " hexField", "rawstring", "hashArray", "zipArray", "zipField", "rawBuffer"], "i": ["temp", "si", "qi", "ip", "u", "multi", "n", "ii", "c", "ini", "pi", "o", "abi", "ci", "di", "io", "slice", "ji", "ui", "length", "ri", "bi", "count", "ie", "p", "it", "l", "phi", "s", "j", "I", "x", "index", "f", "e", "oi", "li", "off", "start", "h", "v", "gi", "ti", "data", "ai", "r", "b", "xi", "id", "info", "uri", "ix", "end"]}}
{"id1": "10214218", "id2": "2398448", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void handleURL() throws JspException, IOException {\n        Map in_map = prepareInputMap();\n        String in_str = JSONTransformer.serialize(in_map);\n        byte[] input = in_str.getBytes(\"UTF-8\");\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        conn.setRequestMethod(\"POST\");\n        conn.setDoOutput(true);\n        conn.setDoInput(true);\n        conn.setUseCaches(false);\n        conn.connect();\n        OutputStream os = conn.getOutputStream();\n        os.write(input);\n        os.close();\n        InputStream is = conn.getInputStream();\n        InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n        StringBuffer s_buf = new StringBuffer();\n        char[] tmp_buf = new char[1024];\n        int count;\n        while ((count = reader.read(tmp_buf)) != -1) {\n            if (count == 0) continue;\n            s_buf.append(tmp_buf, 0, count);\n        }\n        reader.close();\n        Map out_map = null;\n        try {\n            out_map = JSONTransformer.parseObject(s_buf.toString());\n        } catch (ParseException e) {\n            returnErrorResult(e.getMessage());\n        }\n        handleResultMap(out_map);\n    }\n", "label": 0, "substitutes": {"encrypt": ["enrypt", " encress", "deccrypt", "enress", "decrypt", "decress", "enccrypt", "encipher", " enccrypt", "decipher", " encipher", "enipher", "encress"], "plaintext": [" plaintxt", "battxt", "plainText", "plainstruct", "maintext", "battext", "mainsource", "batsource", "anytxt", " plainText", "batText", " plainstruct", "plainsource", " plainsource", "plaintxt", "anystruct", "anytext", "mainText", "anyText", "mainstruct", "batstruct"], "md": ["mb", "mg", "mp", "pd", "mage", "pm", "od", "ms", "mand", "cm", "mac", "Cmd", "m", "em", "pg", "sm", " MD", "d", "sha", "hm", "MD", "bd", "key", "meta", "wd", "ad", "dd", "ld", "mc", "mod", "cmd", "dh", "dr", "mag", "ma", "am", "arm", "dm", "nm", "amd", "data", "dig", "kg", "mm", "metadata", "message", "mad", "mt", "mu", "db", "mo"], "raw": ["row", "words", "full", "clean", "instance", "initial", "unknown", "input", "wave", "feed", "hex", "buf", "none", " RAW", "content", "original", "ack", "good", "ng", "rc", "rew", "load", "array", "enc", "Raw", "serial", "wrapper", "image", "bytes", "unsigned", "data", "null", "pack", "RAW", "binary", "buffer", "text", "block", "message", "dec"], "hash": ["hed", "sh", "mac", "cache", "Hash", "rh", "secret", "ruby", "sha", "response", "sum", "abi", "log", " hex", "hex", "key", "ashes", "header", "kh", "alpha", "ha", "base", "url", "ash", "array", "code", "her", "image", "h", "html", "data", "id", "message", "block", "version"]}}
{"id1": "21488868", "id2": "23510383", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2File", "encodeFileFromStream", "encodeFileFromString", "encodeStringToStream", "encodeString2Files", "encodeFiletoStream", "encodeFiletoString", "encodeStringToFiles", "encodeFiletoFiles", "encodeFiletoFile", "encodeFileFromFiles", "encodeFileFromFile", "encodeString2Stream", "encodeStringToString", "encodeFileToString", "encodeFile2String", "encodeString2String", "encodeFile2File", "encodeFile2Stream", "encodeFileToFiles", "encodeStringToFile", "encodeFile2Files", "encodeFileToStream"], "infile": [" infilename", "infiles", "Infilename", "outFile", "inputfile", "outfiles", "inFile", "InFile", "inputfilename", " infiles", " infp", "inputFile", "outfilename", "outfp", "Infiles", "inputfiles", "infp", "inputfp", "infilename", "Infile"], "outfile": ["newfolder", "outname", "outFile", " outFile", "outputfp", "outputfilename", " outfilename", "Outname", "outfolder", "outputfolder", " outfp", "Outfolder", "newfile", "newname", " outfolder", "infolder", "newFile", "outfilename", "outfp", "outputfile", "OutFile", "infp", " outname", "infilename", "Outfile"], "in": ["re", "err", "ini", "image", "base", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "vin", "m", "din", "socket", "inc", "s"], "out": ["err", "ou", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "In", "obj", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "outs", "work", "job", "source", "line", "io", "Out", "client", "off", "name", "co", "on", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "count", "cache", "slice", "queue", "b", "bytes", "bb", "null", "buf", "buff", "border", "padding", "fb", "split", "uffer", "type", "result", "len", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "input", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "close", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "model", "method", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "respons", "open", "better", "message", "growth", "modified", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "16511008", "id2": "7761195", "code1": "    public ProgramProfilingMessageSymbol createNewProfilingMessageSymbol(int configID, int programMessageSymbolID) throws AdaptationException {\n        ProgramProfilingMessageSymbol profilingMessageSymbol = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProgramProfilingMessageSymbols\" + \"(projectDeploymentConfigurationID, programMessageSymbolID)\" + \" VALUES (\" + configID + \", \" + programMessageSymbolID + \")\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProgramProfilingMessageSymbols WHERE \" + \"projectDeploymentConfigurationID = \" + configID + \" AND \" + \"programMessageSymbolID           = \" + programMessageSymbolID;\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create program profiling message \" + \"symbol failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            profilingMessageSymbol = getProfilingMessageSymbol(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProfilingMessageSymbol\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return profilingMessageSymbol;\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-512\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"createNewProfilingMessageSymbol": ["createNewProfilingMsgSymmb", "createNewProfilingMessageSymmbol", "createNewProfilingMsgSyletter", "createNewProfilingMessageSymmb", "createNewProfilingMessageSymletter", "createNewProfilingMessageSyletter", "createNewProfilingMsgSymletter", "createNewProfilingMessageYmbol", "createNewProfilingMessageCymb", "createNewProfilingMsgSymmbol", "createNewProfilingMsgSymbol", "createNewProfilingMessageCymbol", "createNewProfilingMessageYmb", "createNewProfilingMessageCyletter", "createNewProfilingMessageSymb", "createNewProfilingMsgSymb", "createNewProfilingMessageYletter"], "configID": ["ConfigURL", " configId", "ConfigID", " configURL", "ConfigUID", "projectURL", "ConfigId", " configION", "projectId", "configId", "configION", " configUID", "projectION", "configUID", "ConfigION", "projectUID", "projectID", "configURL"], "programMessageSymbolID": ["programMessageSyncmbolID", "programMessageSyncmbolId", "programMessageSyntaxID", "programMessageSymbId", "programMessageSychid", "programMessageSyncmbid", "programMessageSyncmbolIP", "programMessageSyntaxName", "programMessageSyncmbId", "programMessageSymbolid", "programMessageSyncmbolid", "programMessageSyymID", "programMessageSyklName", "programMessageSymbolId", "programMessageSyncmbID", "programMessageSyymName", "programMessageSymbName", "programMessageSymbolName", "programMessageSyncmbIP", "programMessageSyklID", "programMessageSyncmbolName", "programMessageSyntaxId", "programMessageSymbIP", "programMessageSyymId", "programMessageSymbid", "programMessageSyncmbName", "programMessageSyklId", "programMessageSymbID", "programMessageSychId", "programMessageSyntaxid", "programMessageSychID", "programMessageSyymIP", "programMessageSymbolIP"], "profilingMessageSymbol": ["profilingMessageSynPart", "profilingFileSymmbol", "profilingMessageTyPart", "profilingMessageYletter", "profilingFileSymb", "profilingMessageSymb", "profilingMessageSymmb", "profilingFileSymbol", "profilingFileSymmb", "profilingFileSyletter", "profilingMessageCymb", "profilingMessageYmbol", "profilingMessageSymletter", "profilingMessageCyletter", "profilingMessageSynmb", "profilingMessageSymPart", "profilingApplicationSyletter", "profilingApplicationSymmb", "profilingMessageSyletter", "profilingApplicationSymbol", "profilingApplicationSymb", "profilingMessageSyPart", "profilingFileSymletter", "profilingMessageCymbol", "profilingApplicationSymletter", "profilingFileSymPart", "profilingMessageSymmbol", "profilingMessageTymbol", "profilingApplicationSymmbol", "profilingMessageSynmbol", "profilingFileSyPart", "profilingMessageTymb", "profilingMessageYmb"], "connection": ["directory", "Connection", "index", "server", "response", "lock", "document", "con", "c", "connected", "communication", "table", "result", "socket", "driver", "pool", "relation", "si", "manager", "database", "condition", "password", "client", "session", "use", "cache", "cond", "ion", "application", "collection", "section", "config", "machine", "channel", "environment", "log", "context", "conn", "image", "function", "db", "ctx", "sql", "bc", "position", "unit", "connect", "command", "state", "error", "engine", " Connection", "ongo"], "statement": ["directory", "Connection", "string", "agent", "execute", "response", "timeout", "lock", "report", "usage", "message", "document", "table", "library", "result", "ma", "se", "volume", "relation", "si", "pass", "database", "joined", "condition", "ment", "expression", "part", "session", "stat", "mt", "use", "str", "collection", "section", "parser", "out", "study", "conn", "Query", "Statement", "Session", "writer", "function", "commit", "db", "sql", "position", "unit", "comment", "parse", "summary", "connect", "command", "state", "error", "storage"], "resultSet": ["ResultGen", "ResultS", "resultSplit", "resultsSet", "resultsGen", "resultsSource", "dataSet", "resultS", "replySet", " resultS", "resultList", " resultSource", "resultType", " resultType", "resultLine", "resultSource", "replySplit", "ResultLine", "responseRow", " resultGen", "dataList", "dataLine", "responseSet", "ResultSplit", " resultLine", "dataSource", "rowS", "rowSource", "dataRow", "ResultType", "responseList", " resultSplit", "replyList", "rowSet", "rowType", "resultRow", "ResultSource", "resultGen", " resultList", "replyLine", "dataGen", "ResultList", "ResultRow", "ResultSet"], "query": ["index", "reason", "string", "root", "execute", "id", "uri", "lock", "timeout", "report", "message", "description", "table", "result", "join", "qu", "qs", " Query", "eries", "o", "database", "key", "condition", "select", "expression", "filter", "type", "rule", "q", "value", "str", "feature", "ql", "work", "go", "request", "search", "sq", "style", "Query", "name", "send", "function", "call", "sql", "update", "comment", "parse", "question", "command", "scan", "script", "error", "module", "code"], "msg": ["rag", "reason", "pkg", "id", "cmp", "lang", "rr", "op", "var", "sg", "map", "message", "cap", "ge", "ma", "html", "tag", "dr", "mr", "ms", "bg", "bag", "cm", "mt", "doc", "fg", "ug", "str", "g", "md", "ger", "cmd", "text", "gs", "sim", "exc", "agg", "log", "ag", "gen", "Message", "format", "title", "desc", "name", "m", "gr", "status", "e", "gor", "db", "og", "nm", "mn", "comm", "err", "mg", "gm", "error", "phrase", "tool", "cfg", "Msg", "loc"]}}
{"id1": "19584877", "id2": "6840241", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToStream", "encodeFiletoStream", "encodeString2Stream", "encodeFiletoFile", "encodeStringToString", "encodeString2String", "encodeFileToStream", "encodeFileToString", "encodeFileFromFiles", "encodeFile2Files", "encodeStringToFiles", "encodeFile2String", "encodeStringToFile", "encodeFileFromString", "encodeString2Files", "encodeFileFromFile", "encodeFiletoString", "encodeFile2Stream", "encodeFileToFiles", "encodeFiletoFiles", "encodeString2File", "encodeFile2File", "encodeFileFromStream"], "infile": ["inputFile", "inputfilename", "Infiles", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "outfiles", "infp", "inputfp", "outfp", " infilename", " infp", " infiles", "infiles", "Infilename", "InFile", "Infile", "inFile"], "outfile": ["newFile", "outputfilename", "Outfile", "outfilename", "infilename", "outFile", "Outfolder", " outfp", " outfilename", "infp", "newfolder", "outname", "outfp", " outname", " outFile", "Outname", " outfolder", "outputfp", "newname", "newfile", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "vin", "base", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "image", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "copy", "conn", "cache", "again", "output", "inner", "writer", "work", "line", "err", "off", "client", "o", "OUT", "lib", "source", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "post", "io", "net", "file", "up", "co", "on", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "len", "queue", "input", "result", "length", "write", "fb", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "close", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "input", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "modified", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "respons", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "9275622", "id2": "22977189", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["moveFolder", "copyFiles", " copyfile", "copyFolder", "transferFile", "transferFolder", "moveFiles", "transferfile", " copyFiles", " copyFolder", "transferFiles", "movefile", "copyfile", "moveFile"], "_file1": ["_files1", "_files01", "_File2", "_fileone", "_resourceOne", "_mail2", "_file0", "_resource1", "_fFirst", "_resourceone", "_zip1", "_zipFirst", "_fileOne", "_zipOne", "_file01", "_fone", "_fOne", "_File0", "_f1", "_mail1", "_File01", "_mail0", "_File1", "_mail01", "_zipone", "_files2", "_files0", "_resourceFirst", "_fileFirst"], "_file2": ["_files4", "_filesecond", "_Filesecond", "_File5", "_File2", "jfile1", "_file4", " _filesTwo", " _files3", "jmodelsecond", "_model1", "_model5", "_file5", "_modelsecond", "_files3", "_file3", "jfile5", "_play2", "jfilesecond", " _file3", "_playTwo", "jmodel1", "jmodel5", "_play1", "_model2", "_playsecond", "_filesTwo", "_fileTwo", "_File1", "_play5", " _files4", "_files2", "_play4", " _file4", " _fileTwo", "jfile2", "_play3", "jmodel2", " _files2"], "fis": ["fiss", "infiss", "lfais", "lfi", "afis", "cfos", " fris", "afais", "cfiss", "lfis", "cfas", "Fils", " fais", "infils", "afiss", "fi", "Fas", "Fis", " fi", "fils", "infos", "Fiss", "fas", " fiss", "afi", " fils", "lfiss", "Fos", "fris", "Fris", "fais", "cfis", "cfris", "infis", " fas"], "fos": ["infaos", "Fo", "fus", "infus", "Foos", "Foses", "foses", "infios", "feos", "floes", "goses", "Fus", "info", " foos", "fOS", "flis", "infros", "gis", "Faos", "Fros", " fus", "gos", "feoses", "foes", "pis", "Fios", "Fis", "infoos", "infos", "fros", "poes", " faos", "pOS", "feus", "fios", "Fos", "pos", "feis", "foos", " fo", "flOS", " fios", "los", "lis", "faos", "lOS", "flos", "fo", " fros", "loes", "gus"], "canalFuente": ["canalBuence", "canalCraencia", "canaledBuje", "canaledBuze", "canalKuze", "canallBuente", "canallFuente", "canalBuento", "canalFuze", "canalsBuence", "canaledBuente", "canalSuente", "canalFuento", "canallBuence", "canalsFuente", "canalBuente", "canalBuje", "canalSuje", "canalFUje", "canaledFuente", "canalSuestro", "canaledFuestro", "canallFuze", "canalsFuence", "canalsBuento", "canalFUestro", "canalFuencia", "canalKuence", "canalsFuencia", "canalFUente", "canalBuencia", "canaledBuestro", "canaledFuje", "canalKuento", "canalsFuento", "canalFuje", "canallBuze", "canallFuence", "canalsBuencia", "canaledFuze", "canalBuestro", "canallFuencia", "canalKuente", "canalKuencia", "canalFuence", "canalFUencia", "canalSuze", "canalCraence", "canalsBuente", "canalFUze", "canalCraente", "canalCraento", "canalFUence", "canalBuze", "canallBuencia", "canalFuestro"]}}
{"id1": "3801655", "id2": "15580610", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"helper": ["workp", "scheper", "workmer", "helpler", "schepherd", "Helper", "harper", "sher", "helppherd", "harpherd", "scheHelper", "heller", "helpherd", "heler", "Heler", "helHelper", "shper", "harler", "worker", "Help", "workper", "shp", "helpper", "shmer", "help", "helmer", "scheler", "helpHelper", "harHelper", "Helmer"], "dataset": ["Dataset", "datrasets", "metasheet", " DatASet", "datasset", "datassets", "Datasets", "datASheet", "DatasET", "metasET", "datAset", " DatasET", "datAsets", "datapsET", "datAsheet", "datastets", "DatASeter", "datapsheet", "datacheet", "datasert", "datastet", " Datasheet", "datASet", "datasets", "DatASet", "datasteter", "datraseter", "datacert", "datrasET", "datacet", "metasert", "datASets", "datapset", " DatASheet", "metaset", " DatASets", " Datasets", " DatASET", "Dataseter", "datapsert", " Dataset", "datassert", "dataseter", "DatASET", "datASeter", "metassert", "DatASets", "datastET", "datasET", "datassET", "datAsET", "metassheet", "datASET", "datasheet", "metassET", "datassheet", "datraset", "metasset", "datacET"], "zip": ["java", "z", "pack", "ssl", "se", "copy", "system", "lock", "flat", "io", "data", "zone", "folder", "py", "f", "wrap", "tar", "loop", "archive", "bag", "split", "out", "code", "jar", "xml", "sea", "plugin", "parse", "dir", "directory", "pkg", "source", "ip", "Zip", "pdf", "slice", "pipe", "handler", "file", "gz", "window", "service", "binary", "sl", "bug", "git", "secure", "p"], "entries": [" entlines", "entents", "entlections", "ntries", "intries", " entities", "ntents", "iterents", "entities", "contry", "itries", "entryents", "itry", "entrees", "entrys", "contries", "entrylements", "contrys", "itents", "infries", "ENTrees", "iterries", "ntry", "ENTries", "contents", "entsries", "deents", "itrys", "inflines", "intlines", "intlements", "intities", "entryries", "entslections", "ENTrants", "ntrys", "delements", "infities", "inflections", "entlements", "deries", "entsrees", "ENTlections", " entlements", "inflements", "infrants", "entrants", "entlines", "entsrants", "infrees", "iterlements"], "performance": ["book", " u", "unit", " writers", "Unit", "stats", "ul", " ratio", "each", "it", " suite", "union", " split", " Units", "its", " unit", " units", "work", "slave", "units", "exec", " group", "U", " output", "runner", "ui", "rank", "util", " Unit", " result"], "index": ["page", "unit", "write", "length", "count", "offset", "Index", "num", "depth", "limit", "pos", "key", "type", "i", "iter", "number", "position", "id", "name", "order", "path", "x", "value", "level", "head"], "entry": ["pe", "install", "uri", "e", "write", "server", "se", "style", "connection", "cell", "info", "data", "child", "si", "ie", "part", "in", "folder", "it", "her", "result", "input", "route", "archive", "nt", "key", "row", "Entry", "element", "xml", "cel", "add", "record", "section", "parse", "stream", "inner", "r", "file", "obj", "service", "pattern", "or", "lc", "office", "feed", "export", "post", "ry"], "temp": ["partial", "original", "txt", "copy", "parent", "dest", "lock", "tc", "flat", "empty", "porary", "data", "single", "store", "io", "session", "part", "Temp", "output", "folder", "wrap", "f", "input", "archive", "valid", "storage", "template", "test", "out", "cel", "config", "iter", "directory", "tmp", "thread", "base", "table", "stable", "local", "cache", "pipe", "layout", "file", "binary", "w", "full", "ctx", "fake", "context", "path", "clean", "office", " temporary", "emp", "tem", "http", "p"], "writer": ["wave", "log", "wr", "write", "server", "io", "outer", "engine", "writing", "written", "output", "editor", "Writer", "feed", "key", "out", "player", "wer", "ws", "rw", "builder", "iter", "driver", "war", "element", "riter", "sw", "er", "worker", "stream", "inner", "r", "holder", "handler", "file", "wire", "loader", "w", "per", "writers", "layer", "wrapper", "ler", "or", "author", "manager"], "reader": ["write", "server", "rer", "ser", "io", "ner", "rar", "reading", "f", "Reader", "input", "editor", "upper", "element", "i", "builder", "iter", "driver", "stream", "er", "ter", "worker", "inner", "rr", "r", "handler", "file", "loader", "per", "wrapper", "ler", "or", "iterator", "oder", "http", "feed", "ri", "ry"], "buffer": ["wave", "buf", "write", "message", "resource", "server", "length", "null", "offset", "data", "Buffer", "sequence", "limit", "channel", "document", "result", "input", "batch", "bytes", "row", "source", "iter", "memory", "flush", "header", "size", "buff", "seed", "capacity", "queue", "position", "slice", "table", "address", "character", "initial", "binary", "device", "reference", "layer", "uffer", "transfer", "feed"], "read": ["save", "available", "book", "text", "k", "play", "default", "write", "report", "se", "length", "build", "count", "view", "g", "copy", "data", "child", "allow", "reading", "sync", "old", "raw", "ride", "connect", "check", "reads", "input", "READ", "Read", "run", "seek", "type", "end", "fill", "download", "process", "pass", "add", "parse", "print", "config", "size", "max", "work", "use", "iter", "ad", "send", "ind", "id", "skip", "load", "exec", "start", "find", "select", "wait", "next", "get", "x", "current", "close", "sleep", "eval", "feed", "open", "readable", "create"], "outfile": [" outfilename", " outf", "infile", " outdata", "instream", "outfilename", "indata", " outFile", "againdir", "logfilename", "outdir", "inFile", "outline", "inline", "inf", "Outline", "againline", "indir", "Outdir", "logdata", "againfile", "logfile", "infilename", "outdata", "outf", " outline", "logFile", "Outf", "outstream", "outFile", "Outstream", "Outfile", "againstream", " outstream"], "line": ["filter", "page", "text", "LINE", "log", "url", "frame", "lf", "le", "style", "letter", "item", "cell", "data", "link", "sync", "on", "range", "status", "str", "end", "split", "lin", "strip", "lines", "error", "inline", "type", "val", "job", "code", "pass", "el", "column", "band", "comment", "row", "parse", "cle", "section", "header", "side", "l", "ip", "object", "look", "string", "file", "Line", "name", "sel", "word", "ine", "block"], "parser": ["book", "angler", "lp", "server", "system", "par", "umper", "data", "test", "type", "plugin", "xml", "class", "builder", "parse", "driver", "plan", "er", "worker", "r", "string", "handler", "params", "loader", "Parser", "pattern", "per", "cher", "function", "pool", "wrapper", "ler", "oder", "manager", "p", "processor", "arser"], "list": ["filter", "array", "lp", "parent", "best", "info", "lists", "data", "part", "group", "member", "all", "right", "result", "map", "set", "LIST", "and", "val", "out", "test", "type", "plan", "li", "l", "er", "listed", "can", "base", "table", "r", "match", "v", "other", "left", "get", "pool", "chain", "collection", "p", "join"], "rule": ["pe", "ee", "style", "rol", "item", "ul", "event", "data", "group", "range", "model", "field", "str", "val", "row", "dict", "plugin", "class", "parse", "record", "rl", "li", "header", "er", "lr", "tree", "base", "table", "r", "match", "ule", "service", "rules", "per", "function", "layer", "Rule", "ri", "rate"], "measure": ["Measures", "speasured", "feasuring", "measured", "measuring", "feasures", "Measured", "Measuring", "speasuring", "feasure", "measures", "Measure", "feasured", "speasures", "speasure"]}}
{"id1": "20310134", "id2": "16142024", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "CopyChannel", "transferFile", "CopyFile", " copyfile", "Copyfile", " copyChannel", "copyFiles", "copyfile", "CopyFiles", "transferChannel", "copyChannel"], "in": ["image", "index", "base", "login", "config", "inner", "inn", "input", "In", "l", "bin", "c", "IN", "buffer", "again", "ic", "work", "query", "source", "io", "diff", "min", "ins", "as", "name", "id", "file", "data", "lock", "ex", "i", "reader", "m", "inc", "url", "lin"], "out": ["image", "base", "o", "resource", "prefix", "point", "w", "write", "plain", "cache", "output", "OUT", "b", "conn", "writer", "page", "string", "c", "external", "again", "outs", "p", "io", "v", "x", "img", "Out", "off", "name", "ext", "server", "user", "file", "call", "ex", "dot", "n", "default", "connection", "exec"], "inChannel": ["inConnection", "outchannel", "binChan", "loginChan", "insChan", "loginStream", "inChan", "inStream", "inGate", " inchannel", "InChan", "inputStream", "binChannel", "iniGate", "binGate", "INStream", "inputChannel", "inQueue", "loginChannel", "loginchannel", "inputConnection", " inChan", "outChan", "iniChannel", "iniStream", "InQueue", " inQueue", "inputChan", "INchannel", "INConnection", "iniChan", "outStream", "Inchannel", "InGate", "binchannel", "InStream", "INChan", "outQueue", "insStream", "InChannel", "insConnection", "INChannel", "inchannel", "binStream", "insChannel"], "outChannel": ["inConnection", " outChar", " outStream", "netChan", "outchannel", "outChar", "netStream", "OutConnection", "outputchannel", "netChannel", "inChan", "inStream", "netGate", "inGate", " outchannel", "outputGate", "ouChannel", "ouGate", "Outchannel", "outputChan", "outGate", "outChan", "outputChannel", " outChan", "outStream", "outputChar", "OutChannel", " outGate", "inChar", "ouChan", "outputStream", "ouchannel", " outConnection", "inchannel", "OutChan", "outConnection"]}}
{"id1": "22441244", "id2": "8953394", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    private void update(String statement, SyrupConnection con, boolean do_log) throws Exception {\n        Statement s = null;\n        try {\n            s = con.createStatement();\n            s.executeUpdate(statement);\n            con.commit();\n        } catch (Throwable e) {\n            if (do_log) {\n                logger.log(Level.INFO, \"Update failed. Transaction is rolled back\", e);\n            }\n            con.rollback();\n        }\n    }\n", "label": 0, "substitutes": {"send": ["text", "sent", "message", "write", "append", "build", "set", "reply", "end", "add", "create", "parse", "delete", "export", "address", "exec", "submit", "start", "Send", "get", "transfer", "mail", "execute", "from", "open", "post"], "hsession": ["hsess", "hmessions", "hessions", "HSession", "opensessions", "hmsession", "hsSession", "opensess", "hhessions", "HSSession", "hsort", "hhort", "hesess", "hSession", "hmession", "hhSession", "hesort", "hessession", "hssession", "hmSession", "hsessions", "opensSession", "opensort", "hhession", "hesession", "opensession", "openssession", "HSsession", "hhsession", "HSessions", "hession", "hhess"], "session": ["proxy", "Session", "message", "resource", "server", "parent", "connection", "event", "project", "port", "chat", "application", "document", "site", "class", "ession", "client", "cache", "security", "essions", "host", "sl", "context", "response", "mail", "state", "manager"], "repositoryName": ["reposositoryAddress", "repoositoryEmail", "repositoryPath", "repoositoryPath", "repoitoryAddress", "reposessionName", "repoitoryEmail", "reposicleAddress", "reposicationAddress", "repoositoryFamily", "repositiveNAME", "reposessionNAME", "repositoryNAME", "reposicationFamily", "repositoryAddress", "repoositoryNAME", "repositoryFamily", "repoositoryAddress", "repoitoryName", "repositiveName", "reposicleName", "repositiveEmail", "repositivePath", "reposicleEmail", "reposessionPath", "reposositoryPath", "reposositoryNAME", "reposositoryFamily", "reposicationEmail", "reposicationName", "repoositoryName", "reposositoryEmail", "repoitoryPath", "reposicleFamily", "reposessionEmail", "repoitoryNAME", "reposositoryName", "repoitoryFamily", "repositoryEmail"], "ideIdint": ["IDEIdInt", "ideidn", "IDEIdn", "ideNamenumber", "IDEIdints", "ideInn", "IDEidn", "IDENameInt", "IDEidints", "ideTimeout", "IDEIdint", "ideAuthInt", "ideInint", "ideAuthint", "ideIdInt", "ideIdints", "IDEIdout", "IDENamenumber", "ideIdn", "ideNameInt", "ideNameint", "ideInfonumber", "ideInInt", "ideInfoInt", "IDEIdnumber", "ideIdout", "ideTimeInt", "ideInfoout", "ideIdnumber", "IDENameout", "ideNameout", "IDENameint", "IDEidint", "ideAuthn", "ideInints", "ideidInt", "ideTimeint", "ideAuthints", "ideidints", "ideTimenumber", "IDEidInt", "ideInfoint", "ideidint"], "to": ["prefix", "mobile", "uri", "message", "summary", "options", "phone", "title", "site", "about", "reply", "tel", "template", "settings", "source", "TO", "top", "client", "with", "contact", "sub", "target", "company", "address", "token", "account", "po", "name", "by", "location", "response", "mail", "office", "To", "from"], "cc": ["ct", "cn", "uc", "rc", "tc", "ce", "phone", "ec", "ck", "password", "cl", "nc", "ci", "cb", "code", "cca", "comment", "client", "contact", "cus", "company", "sc", "CC", "ac", "account", "address", "c", "card", "dc", "cf", "lc", "cs", "ca", "cr", "from"], "bcc": ["bbrc", "pce", "bce", "pcc", "pck", "bc", " brc", " bc", " bck", "bbc", "abcc", "bbcc", " bce", "abck", "abce", "pc", "frc", "abc", "fcc", "fc", "brc", "fck", "bck", "bbck"], "subject": ["prefix", "description", "uri", "message", "reason", "method", "username", "phone", "title", "Subject", "reply", "template", "comment", "header", "filename", "sub", "object", "host", "response", "mail", "state", "author", "format", "content", "ject", "head", "request"], "body": ["text", "description", "url", "message", "resource", "money", "plain", "html", "length", "style", "view", "connection", "summary", "reason", "lock", "foot", "empty", "data", "shell", "part", "how", "zip", "password", "template", "code", "pass", "comment", "source", "bound", "header", "media", "tree", "pod", "base", "inner", "object", "string", "name", "left", "function", "response", "normal", "wrapper", "content", "line", "secret", "Body"], "attachments": ["embedings", "Attachments", "attachings", "embedents", "attachents", "embedment", "messments", "Attachents", "messings", "Attachings", "Attachment", "embedments", "messents", "messment"], "isHtml": ["isWhtml", "isWhhtml", "isPhail", "isChail", "isHive", "isWhive", "isHattp", "isCail", "isHttp", " isWhive", " isChhtml", "isChtml", "isHaail", "isHahtml", "isHatml", "isChhtml", " isWhhtml", " isHive", "isCive", "isPhttp", "isPhtml", "isHail", " isChtml", " isHhtml", "isPhhtml", " isChail", " isWhtml", "isChive", "isHhtml", "isChttp", " isWhail", " isChttp", "isWhail", " isHttp", " isHail", "isCtml"], "charset": ["chearspace", "chARSeting", "chanset", "chasets", "chasET", "Charseting", "chARSet", "cheansetter", "chansET", "Charsetting", "cheansetting", "chARSetting", "chasetting", "charsets", "chansetter", "chashesET", "chacksete", "chaseset", "chacksetting", "cheanspace", "chaspace", "chasesetting", "charspace", "chaseseting", "chanspace", "chansete", "chansetting", "CharsET", "charsetting", "chearsete", "cheanset", "cheansET", "Charset", "chearsetting", "chacksET", "charsete", "chearsET", "chasetter", "chasesET", "charsetter", "chARSET", "cheansete", "chaseting", "chashesetter", "chARSets", "chashespace", "chaset", "chasheset", "chearset", "chARSete", "charsET", "charseting", "chearsetter", "Charsets", "chackset"], "headers": [" recipients", "users", "options", " messages", "status", "groups", "comments", "classes", "lines", "settings", " emails", "metadata", "properties", "header", "files", "names", "mails", "errors", " cookies", "ers", "params", "types", "writers", "authors", "content", "strings"], "priority": [" severity", "prefix", "length", " recipients", "quote", "reason", "phone", "title", "status", "mode", "comments", "reply", "template", "date", "code", "comment", "theme", "class", "queue", "language", "security", "state", "level", "author", "lang", " title", "secret"], "email": ["enter", "business", "text", "url", "ssl", "default", "message", "e", "server", "install", "html", "example", "core", "view", "letter", "en", "lex", "event", "info", "data", "username", "international", "engine", "online", "external", "output", "model", "document", "oe", "result", "fax", "zip", "password", "template", "test", "el", "element", "xml", "create", "article", "print", "contact", "base", "object", "address", "account", "ilo", "liner", "name", "Email", "service", "entity", "em", "generic", "pm", "auto", "response", "mail", "office", "note", "update", "line", "export", "ext", "gmail"], "user": ["User", "mobile", "people", "role", "e", "USER", "resource", "connection", "users", "info", "data", "username", "profile", "member", "model", "creator", "me", "type", "plugin", "uid", "consumer", "client", "er", "ip", "object", "id", "token", "account", "string", "character", "name", "unknown", "author", "use", "friend", "person"], "identity": ["authentication", "ethnicifier", "ethnicentity", "authentity", "Identity", "identITY", "ethnicity", "authorITY", "idonymous", "authentization", "authentITY", "personITY", "electricITY", "authorication", "IDENTITY", "authorifier", "idententity", "personity", "installonymous", "entityity", "identization", "IDENTities", "electricity", "IDENTentity", "Identities", "entityifier", "installITY", "authentifier", "idITY", "publicity", "identication", "IdentITY", "publicITY", "authentonymous", "installity", "authoronymous", "Idententity", "IDENTity", "entityonymous", "authority", "personentity", "identonymous", "idization", "electricentity", "idifier", "entityization", "publiciciary", "electriconymous", "identifier", "ethnicITY", "installentity", "ethnicication", "authorities", "identiciary", "identities", "authoriciary", "idication", "personifier", "ethniciciary", "publicentity", "authorentity", "idity"], "_returnPath": ["_returnPart", "_replyNode", " _returnUrl", "_replyPath", " _returnName", "_addpath", "_successText", "_resultPath", "_resultName", "_responsePath", "_returnMid", " _backTo", "_backHalf", "_correctPath", " _backPath", "_returnHalf", "_returnUrl", "_addType", "_backTo", "_displayNode", "_displayPath", "_replyPart", "_returnName", "_returnId", "_resultTo", "_backpath", " _backName", "_backType", "_displayPart", "_correctId", "_returnDirectory", "_inputUrl", "_resultHalf", "_relationDirectory", " _returnPart", "_successId", "_backName", "_backPath", "_relationText", "_relationId", "_relationPath", "_returnNode", "_responseType", "_returnpath", "_correctDirectory", "_displayUrl", "_backUrl", " _returnTo", "_inputPath", "_correctText", " _backHalf", " _backUrl", "_successPath", "_backPart", "_displayMid", "_responsepath", "_returnText", "_replyUrl", "_returnType", "_addPath", "_returnTo", " _returnHalf", "_inputNode", "_inputMid", "_successDirectory", " _backPart", "_replyMid"], "_from": ["placeowner", "placeto", "_source", "existingfrom", "workfrom", "blockfrom", "existingto", "blockto", " _source", " _owner", "existingfor", " _who", "workto", "existingowner", " _error", "_for", "_error", "worksource", "placefrom", "_with", "_owner", "_From", " _for", "blockFrom", "workwho", " _From", "_who", "blockerror", "placefor", " _with"], "_replyTo": ["_replyPoint", "_returnUrl", "_reasonTo", " _replyFrom", "_respondTo", "_respondAddress", " _returnUrl", "_respondUrl", "_commentTo", "_replyOf", "_returnAddress", " _returnFrom", "_closeTO", " _replyUrl", "_respondPoint", "_respondFrom", "_reasonUrl", "_returnPoint", "_commentOf", "_addTo", "_returnOf", "_replyAddress", "_addFrom", "_replyUrl", " _returnTO", "_returnTo", "_reasonFrom", "_commentTO", "_addPoint", "_addAddress", "_returnTO", "_closeFrom", "_commentFrom", " _replyTO", "_replyFrom", "_reasonTO", "_respondTO", "_closeTo", "_replyTO", "_closeOf", " _returnTo", "_returnFrom"], "_to": ["Jabout", "_about", " _about", "Jtarget", "Jfrom", "Jto", " _target", "_target"], "_cc": ["_cd", "_ce", " _ce", " _cd", "_cf", " _cf"], "_bcc": [" _bc", "_rbcc", "_abce", "_sbcs", "_bc", "_rbcs", "_rbc", "_bce", "_abcs", " _abc", " _bce", "_abcc", "_abc", "_rbce", "_bcs", "_sbc", " _abce", "_sbce", " _abcc", "_sbcc", " _bcs", " _abcs"]}}
{"id1": "5682569", "id2": "9398454", "code1": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "code2": "    private static RemoteFile getRemoteFile(String url) {\n        long size = 0;\n        String realUrl = \"\";\n        try {\n            HttpURLConnection conn = (HttpURLConnection) (new URL(url)).openConnection();\n            size = conn.getContentLength();\n            realUrl = conn.getURL().toString();\n            conn.disconnect();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        RemoteFile rf = new RemoteFile(size, realUrl);\n        return rf;\n    }\n", "label": 0, "substitutes": {"metodo1": [" utando1", " metando3", " utodo3", " metodo2", " utodo2", " utando2", " utando8", " metato8", " metango2", " metato1", " metodo3", " metodo8", " metando1", " metango3", " utodo8", " metato2", " metando8", " utodo1", " utando3", " metando2", " metango1", " metato3", " metango8"], "temp": ["offset", "iter", "alt", "f", "current", "data", "mag", "Temp", "modified", "mini", "type", "stable", "emp", "p", "partial", "j", "clean", "status", "lc", "cache", "txt", "tem", "pre", "font", "dest", "test", "count", "source", "z", "t", "parent", "v", "default", "level", "tmp", "empty", "null", "flat", "c", "index", "prefix", "tc", "cel", "cut", "diff", "result", "fake", "length"], "flagDesordenado": ["flagDesordencad", "flagDesordernada", "flagDesordeniano", "flagDesORDENad", "flagDesordinato", "flagDesordennada", "flagDesordienado", "flagDesORDenano", "flagDesordencada", "flagDesORDENano", "flagDesideredenar", "flagDesordinado", "flagDesordernar", "flagDesordencado", "flagDesordeniado", "flagDesordeniada", "flagDesordienada", "flagDesordienad", "flagDesordeniad", "flagDesordenido", "flagDesordernad", "flagDesordainar", "flagDesordinaban", "flagDesordenar", "flagDesordeniido", "flagDesordinada", "flagDesordainado", "flagDesordainada", "flagDesordenano", "flagDesordeniaban", "flagDesordienato", "flagDesideredenado", "flagDesideredainar", "flagDesordenaban", "flagDesordainido", "flagDesordeniato", "flagDesordernato", "flagDesideredenido", "flagDesordenada", "flagDesordernido", "flagDesordennado", "flagDesordencano", "flagDesORDENada", "flagDesORDenad", "flagDesORDenada", "flagDesordenato", "flagDesordenad", "flagDesordernado", "flagDesideredainada", "flagDesordeniar", "flagDesideredenada", "flagDesordENada", "flagDesORDenado", "flagDesordennato", "flagDesordENad", "flagDesordENado", "flagDesORDENado", "flagDesordennaban", "flagDesideredainido", "flagDesordENano", "flagDesideredainado"], "i": ["x", "ji", "f", "data", "si", "it", "start", "ti", "ri", "mini", "slice", "j", "p", "info", "pi", "k", "load", "ix", "hi", "lc", "I", "bi", "u", "b", "di", "multi", "part", "qi", "l", "left", "e", "key", "ini", "abi", "source", "ci", "init", "image", "cli", "api", "list", "xi", "oi", "v", "ui", "mi", "li", "n", "uri", "ii", "io", "c", "ni", "id", "index", "iu", "chi", "mu", "eni", "ai", "gi", "phi", "diff", "ip", "site"], "tabla": ["tabela", "cellla", "abla", "cellna", "tagela", " tablo", "tagula", "tablela", "tableela", "tagla", "Tablas", " tabula", "tabula", "abula", " taba", "tabna", "cellela", "tablo", "Tabula", "tablelas", "Tablo", "Tabla", "taglas", "Taba", "tablas", "ablas", " tabna", " tablas", "abela", " tabela", "Tabela", "tagna", "taga", "taba", "cellula", "tablea", "taglo", "ablo"]}}
{"id1": "2168610", "id2": "1508930", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"update": ["ite", "event", "where", "index", "address", "id", "resource", "response", "replace", "timeout", "UPDATE", "add", "lock", "http", "message", "version", "current", "end", "result", "run", "patch", "set", "draw", "instance", "write", "save", "grade", "database", "updated", "sync", "handle", "use", "load", "up", "date", "connection", "diff", "value", "build", "open", "config", "inc", "text", "check", "Update", "get", "put", "delete", "insert", "complete", "edit", "name", "change", "fill", "status", "send", "apply", "family", "pull", "position", "bug", "unit", "create", "future", "range", "state", "width", "error", "view"], "o": ["ou", "online", "n", "od", "oa", "c", "mo", " O", "bo", "co", "ono", "oo", "one", "so", "ion", "connection", " object", "ob", "none", "oid", "object", "p", "conn", "or", "oi", "po", "e", "m", "t", "ao", "k", "O", "obj", "os", "f", "office", "oe"], "contact": ["event", "info", "address", "cc", "ace", "feed", "choice", "cmp", "entry", "report", "character", "act", "project", "concept", "result", "account", "cart", "match", "relation", "co", "company", "content", "form", "client", "sync", "email", "lc", "date", "connection", "charge", "model", "collection", "work", "config", "phone", "check", " Contact", "object", "control", "campaign", "lead", "product", "coll", "front", "call", "fax", "contract", "connect", "f", "office", "conference", "communication", "Contact", "point", "cell"], "pst": ["lpsh", " psc", " post", "wpsh", "Pct", "psh", "prost", "wptd", "spst", "epcr", "preste", "prST", "psp", "pste", "spct", "Pdd", "Psp", "lpST", " pcr", " psp", "preut", "pdd", " psts", "opst", "prste", "post", "Post", "prest", "wpcr", "Pcr", "pct", "psts", "lpsts", "psl", "prdd", "pstd", " pste", "spste", "opsts", " put", "pcr", "prsp", "PST", "prsc", "prect", "Psc", " pdd", "psc", "wpst", "epST", "pST", "Pst", "prtd", "lpcr", "lptd", "opste", "Pste", " ptd", "prsts", "prsl", "lpsta", "lpst", "opct", "pssl", "prsta", "psta", "sput", "prcr", "epst", "Psts", " psh", " pct", "epsts", "pssts", "prst", "psst", "put", "ptd", " psta", " pST", "prct", " psl"]}}
{"id1": "3558512", "id2": "812803", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialze", "finalze", "Serialize", " serialze", "erialize", "Serialized", "erialze", "Serialization", "Serialify", "serialze", " serialization", "serializable", "erialization", "normalify", "normalized", "finalize", "normalze", "serialify", "finalized", "finalify", "erializable", "Serializable", "serialized", "serialization", "normalize", " serializable"], "out": ["exec", "OUT", "png", "outs", "cache", "client", "w", "gen", "output", "bin", "io", "raw", "filename", "name", "string", "obj", "conn", "archive", "image", "err", "Out", "writer", "i", "report", "a", "ex", "parent", "o", "loader", "buffer", "content", "copy", "page", "data", "pool", "file", "up", "source", "server", "dump", "temp"], "parser": ["test", "processor", "base", "master", "reader", "system", "cache", "builder", "parse", "php", "lp", "tt", "worker", "xml", "plugin", "arser", "er", "seed", "cp", "pkg", "upload", "writer", "pe", "Parser", "class", "parent", "handler", "pillar", "per", "loader", "p", "wrapper", "copy", "file", "up", "server", "instance", "rar", "pp", "ss", "as", "txt", "manager"], "on_disk": ["onJdemand", "onnetfile", "onnetspace", "off_space", "off_delete", "onbootlock", "on_lock", "onbookdelete", "off_lock", "on_file", "off_drive", "onjspace", "off_storage", "onbootdrive", "onJdrive", "onbootdisk", "on_drive", "onJlock", "onjdrive", "onJdisk", "onbootstorage", "off_demand", "onbookdrive", "off_disk", "onjfile", "onbookdisk", "on_storage", "onnetdemand", "onjdisk", "on_demand", "onnetdisk", "on_delete", "onnetdrive", "on_space", "off_file"], "in": ["ins", "thin", "din", "reader", "IN", "login", "bin", "inc", "ini", "input", "In", "conn", "inner", "stream", "c", "inas", "ax", "i", "connection", "info", "r", "again", "o", "socket", "win", "inn", "min", "pin", "copy", "data", "lin", "file", "source", "kin", "rin", "pass", "con", "ac", "as", "f"]}}
{"id1": "15018553", "id2": "14878593", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["decrypt", "decipher", "secipher", "Encrypt", "secrypt", "encryption", "enccrypt", "encipher", "seccrypt", "Enccrypt", "Encipher", "Encryption", "decryption", "secryption", "deccrypt"], "text": ["font", "txt", "message", "image", " Text", "length", "struct", "connection", "letter", "method", "data", "sequence", "output", "input", "str", "hex", "password", "template", "bytes", "key", "test", "code", "class", "source", "config", "seed", "number", "TEXT", "object", "address", "token", "string", "name", "binary", "pattern", "path", "transfer", "word", "content", "buffer", "ext", "contract", "secret", "Text"], "md": ["m", "rm", "hd", " MD", "Cmd", "message", "mp", "cmp", "cmd", "dr", "pg", "sha", "data", "mo", "dig", "dd", "hash", "mc", "mag", "d", "od", "meta", "me", "ms", "mb", "wd", "amd", "mg", "dm", "bd", "pkg", "metadata", "cm", "pd", "MD", "hm", "mn", "mi", "db", "ad", "mac", "mand", "mm", "ma", "sm", "gb", "am", "ld", "mk", "pm", "em", "mt", "mod", "df"], "md5hash": ["md25Hash", " md4sum", " md5sum", "md4Hash", "md6Hash", "md4sum", "MD512key", "md512key", "MD5hash", "md5Hash", "md5block", "md512hash", "MD512hash", "md7hash", "MD5hex", "md2sum", "md7block", "md5hex", "md6hash", "md4block", "md7Hash", "md256key", "md6hex", "md4hash", "md25log", "md4log", " md4hash", " md5log", "md2block", "md5log", "md256hash", "md2hash", "md6log", "md25sum", "md5sum", "md25hash", " md4block", "MD5key", "md7sum", "md512hex", "MD512hex", "md256hex", "md5key", " md5Hash", " md5block", "md6sum", "md6key", " md4log", "md2Hash", " md4Hash"]}}
{"id1": "3631989", "id2": "5989666", "code1": "    public void run() {\n        URL url;\n        try {\n            url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((str = in.readLine()) != null) {\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private String postXml(String url, String soapAction, String xml) {\n        try {\n            URLConnection conn = new URL(url).openConnection();\n            if (conn instanceof HttpURLConnection) {\n                HttpURLConnection hConn = (HttpURLConnection) conn;\n                hConn.setRequestMethod(\"POST\");\n            }\n            conn.setConnectTimeout(this.connectionTimeout);\n            conn.setReadTimeout(this.connectionTimeout);\n            conn.setRequestProperty(\"Content-Type\", \"text/xml; charset=utf-8\");\n            conn.setRequestProperty(\"Accept\", \"application/soap+xml, text/*\");\n            if (soapAction != null) {\n                conn.setRequestProperty(\"SOAPAction\", soapAction);\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter out = new OutputStreamWriter(conn.getOutputStream());\n            out.write(xml);\n            out.close();\n            BufferedReader resp = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            StringBuilder buf = new StringBuilder();\n            String str;\n            while ((str = resp.readLine()) != null) {\n                buf.append(str);\n            }\n            return buf.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"run": ["exit", "running", "unit", "report", "server", "background", "build", "Run", "init", "output", "loop", " runs", "Main", "test", "process", "foo", "work", " execute", " Run", "exec", "start", " test", "runner", "execute", " running"], "url": ["ur", "page", "fr", "uri", "resource", "image", "server", "e", "ll", "ssl", "cert", "connection", "il", "org", "data", "link", "socket", "blog", "f", "rule", "URL", "www", "bel", "out", "el", "i", "source", "api", "l", "web", "github", "stream", "base", "address", "file", "name", "re", "ob", "up", "sl", "host", "plug", "path", "Url", "hub", "buffer", "http", "feed", "bb", "open", "ball", "browser"], "in": ["into", "ins", "ssl", "e", "fr", "fin", "In", "b", "connection", "init", "io", "fb", "inc", "f", "gin", "impl", "input", "din", "IN", "inn", "lin", "read", "out", "s", "conn", "i", "is", "kin", "reader", "inside", "nin", "stream", "l", "login", "inner", "r", "bin", "err", "file", "con", "ini", "again", "line", "isin"], "str": ["text", "Str", "fr", "arr", "st", "body", "data", "raw", "part", "entry", "status", "ch", "code", "comment", "source", "header", "inner", "r", "br", "string", "exec", "err", "obj", "start", "name", "content", "line", "doc", "char"]}}
{"id1": "2936678", "id2": "15500892", "code1": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getUniqueKey": ["getStringLink", "getuniqueLink", "makeUniqueLink", "makeuniquekey", "makeuniqueLink", "getUniqueHash", "getuniqueKey", "getUniquekey", "getPrimarykey", "getUniqueLink", "getStringHash", "getStringKey", "getPrimaryLink", "makeUniquekey", "makeuniqueKey", "makeuniqueHash", "getPrimaryHash", "getuniqueHash", "makeUniqueHash", "getuniquekey", "makeUniqueKey", "getStringkey", "getPrimaryKey"], "digest": ["longested", "Digester", "DigEST", "dested", "genit", "dest", " digested", "longEST", "digit", "dests", "uuester", "Digests", "Digid", "genEST", "digester", "digests", "digested", "Digit", "dester", "Digest", "uuest", "longest", "uuid", "uuEST", "digid", " digEST", " digester", "genest", " digests", "Digested", "longester", " digit", " digid", "digEST"], "md": ["ud", "gd", "mag", "bd", "df", "od", "Cmd", "amd", "mo", "med", "ma", "meta", "wd", "MD", "dc", " MD", "ld", "sm", "ad", "rpm", "gb", "mb", "mt", "dh", "mac", "d", "mp", "hd", "pm", "pd", "sd", "de", "mm", " dd", "nd", "metadata", "cd", "gen", "dig", "m", "hm", "km", "dm", "grad", "mand", "mc", "nm", "alg", "mn", "v", "vd", "mg", "mad", "cmd", "dd", "hash"], "timeVal": ["rateValue", "rateVal", "TimeBu", "rateBu", "TimeVal", "timeBu", "timeSeries", "TIMEVal", "timeValue", "TimeValue", " timeValue", "timeval", " timeSeries", "rateLen", "TIMEValue", "timeLen", "TimeLen", "TimeSeries", "TIMESeries", "TIMEval", " timeLen", " timeval", " timeBu", "Timeval"], "localHost": ["remotehost", "LocalAddress", "remotePort", "LocalHost", " localMac", " localPort", "remoteMac", " localhost", "LocalPort", "privateAddress", "privatePort", "localAddress", "remoteAddress", "localMac", "remoteHost", "Localhost", "localPort", "localhost", "LocalMac", " localAddress", "privateHost", "privatehost"], "randVal": ["RandBu", "randomStr", " randLen", "randomval", "randStr", "RandomLen", "randval", "randValue", "RandStr", "randomLen", " randValue", " randStr", "Randomval", "RandomValue", "randomVal", "RandomVal", "RandValue", "randomValue", "RandVal", "randLen", "randomBu", " randBu", "randBu", " randval"], "val": ["string", "base", "sel", "temp", "id", "vol", "enc", "res", "ind", "ref", "result", "el", "ret", "key", "gb", "valid", "pr", "live", "value", "buf", "pm", "data", "vals", "x", "format", "test", "msg", "dev", "addr", "az", "grad", "db", "sl", "rev", "values", "update", "abc", "unit", "seq", "v", "reg", "range", "bl", "Val", "pt", "VAL", "eval", "loc"]}}
{"id1": "15797402", "id2": "19322946", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupType_FullSearch_MatchingWordInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupType/cluster\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":29055,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":29056,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29065,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":29066,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29069,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":29070,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29095,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":29096,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":21013,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Sensor Cluster\\\",\\\"icon\\\":\\\"54_03\\\"},{\\\"itemTypeID\\\":21014,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":32241,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Drive Cluster EDF-285\\\",\\\"icon\\\":\\\"24_11\\\"},{\\\"itemTypeID\\\":5279,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"F-23 Reciprocal Sensor Cluster Link\\\",\\\"icon\\\":\\\"03_09\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11534,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":17340,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11536,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":17333,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11535,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":17345,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6218,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6222,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected LADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6226,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6230,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Multi-Frequency Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6234,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected RADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":7895,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7893,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7914,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7896,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Omni Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7892,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Radar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11537,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":17336,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Gravimetric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6241,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed LADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Magnetometric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6239,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Multi-Frequency Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6225,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed RADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":20238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20244,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20250,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20260,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20240,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20246,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20252,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20262,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":21722,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Sleeper Nanite Cluster\\\",\\\"icon\\\":\\\"55_15\\\"},{\\\"itemTypeID\\\":20242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20248,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20254,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20264,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"parse": [" transform", "wrap", "processing", "pc", "scan", " rewrite", "request", "view", "xml", "http", "cover", "service", "transform", "report", "patch", "process", " split", "print", " parsing", "rate", "replace", " parser", "fork", "Parser", " serve", "load", "read", "php", " analyse", "arse", "set", "worker", "split", " dispatch", "handle", "apply", "se", " convert", "save", "raw", " process", "pack", "parser"], "stream": ["resource", "temp", "draw", "channel", "view", "http", "inner", "src", "input", "response", "down", "feed", "in", "download", "content", "iterator", "sample", "video", "document", "Stream", "upload", "server", "url", "load", "loader", "read", "image", "through", "writer", "handle", "remote", "reader", "data", "raw", "stack", "message", "source", "client", "form", "file"], "handler": ["application", "function", "channel", "host", "pointer", "phase", "service", "response", "layer", "manager", "ctx", "di", "driver", "hand", "Handler", "default", "connection", "base", "event", "server", "loader", "processor", "controller", "wrapper", "writer", "format", "handle", "h", "reader", "data", "handled", "parser", "info", "parent", "client", "collection", "monitor"], "metadata": ["property", "resource", "attribute", "subject", "map", "management", "mx", "m", "xml", "state", "manager", "ctx", "params", "di", "meta", "database", "json", "properties", "content", "header", "runtime", "document", "metry", "connection", "storage", "component", "config", "processor", "adata", "material", "directory", "managed", "data", "mi", "mon", "md", "module", "plugin", "parser", "message", "info", "mt", "uri", "source", "collection", "met", "monitor", "template"], "context": ["resource", "txt", "entry", " Context", "subject", "cmp", "instance", "Context", "environment", "method", "request", "xml", "proxy", "scope", "concept", "manager", "ctx", "content", " contexts", "object", "translation", "command", "document", "mc", "connection", "element", "event", "component", "system", "config", "processor", "tx", "reader", "data", "kernel", "message", "parent", "text", "collection"], "name": ["Name", "names", "resource", "action", "large", "route", "class", "full", "n", "string", "m", "word", "call", "version", "comment", "named", "old", "time", "path", "label", "search", "api", "key", "none", "sync", "in", "active", "on", "no", "object", "address", "child", "missing", "default", "part", "base", "connection", "prefix", "model", "url", "work", "size", "code", "filename", "image", "ame", "NAME", "type", "data", "null", "id", "message", "job", "source", "alias", "file", "common"], "out": ["resource", "temp", "window", "line", "again", "instance", "channel", "o", "ex", "ray", "exp", "bin", "Out", "copy", "path", "manager", "io", "outs", "sync", "in", "object", "conn", "child", "user", "err", "connection", "server", "url", "cos", "pool", "image", "lib", "socket", "writer", "plain", "result", "page", "ext", "output", "data", "obj", "OUT", "null", "flush", "source", "client", "builder", "file", "extra"]}}
{"id1": "6379126", "id2": "15757836", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    private int[] sort(int n) {\n        int[] mas = new int[n];\n        Random rand = new Random();\n        for (int i = 0; i < n; i++) {\n            mas[i] = rand.nextInt(10) + 1;\n        }\n        boolean t = true;\n        int tmp = 0;\n        while (t) {\n            t = false;\n            for (int i = 0; i < mas.length - 1; i++) {\n                if (mas[i] > mas[i + 1]) {\n                    tmp = mas[i];\n                    mas[i] = mas[i + 1];\n                    mas[i + 1] = tmp;\n                    t = true;\n                }\n            }\n        }\n        return mas;\n    }\n", "label": 0, "substitutes": {"gerarTutorialPage": ["riarTourpage", "riarTutorialElement", "riarTravisElement", "riarTravisDir", "riartutorialDir", "riarTourElement", "riarTravisPage", "riarTutorialpage", "riartourpage", "riarTutorialPage", "riartutorialPage", "riartourElement", "riarTinyPage", "riarTinyDir", "riartutorialElement", "riartourDir", "riartourPage", "riarTourDir", "riarTravispage", "riarTourPage", "riartutorialpage", "riarTinypage", "riarTutorialDir", "riarTinyElement"], "indexDir": ["indexTier", "includeDir", "zipDIR", "zipDir", "indexJar", "includeJar", "IndexJar", "IndexDIR", "indexDIR", "includeTier", "zipTier", "includeDIR", "IndexDir", "IndexTier", "zipJar"], "cssDir": ["gzDir", "javascriptDar", "CSSDar", "cssDIR", "catsDir", "piecesDie", "codesDoc", "piecesDIR", "piecesD", "codesDir", "fontDie", "cssDie", "cssUrl", "gzDirectory", "ssDirectory", "fontDir", "javascriptDir", "CSSUrl", "CSSDb", "cssLen", "fontD", "cssD", "catsDoc", "ssUrl", "javascriptDb", "cssDoc", "ssDIR", "cssDar", "gzUrl", "cssDb", "javascriptDIR", "piecesDir", "gzDIR", "fontDIR", "catsLen", "CSSDir", "CSSDirectory", "ssDb", "ssDie", "ssDir", "cssDirectory", "CSSLen", "CSSDoc", "codesLen", "ssD", "ssDar", "CSSDIR"], "capDir": ["apsVol", "apsDir", "casDirectory", "casDir", "apsDirectory", "capDirectory", "CapVol", "casdir", "capVol", "capdir", "CapDirectory", "apsdir", "casVol", "Capdir", "CapDir"], "licDir": ["lifDoc", "licDoc", "volDoc", "volDir", "voldir", "lifdir", "lifManager", "libdir", "libDoc", "volManager", "licdir", "licManager", "lifDir", "libDir", "libManager"], "midDir": ["casTier", "middir", "midTier", "limTier", "mindDIR", "casDir", "limDIR", "mindTier", "casdir", "mindDir", "limDir", "casDIR", "minddir", "limdir", "midDIR"], "filesDir": ["filesDIR", " filesPos", "stylesDir", "opensDirectory", "locksDir", "videosFolder", "pagesPos", "stylesDur", "locksDirectory", "FilesDir", "filesDur", "imagesDirectory", "imagesFolder", "locksDur", "pagesDir", "filesDirectory", "filesFolder", "opensDir", "videosFile", "FilesDirectory", "imagesDir", "pagesVol", "stylesDirectory", "locksDIR", "filesPos", "opensDur", "stylesDIR", "ballsVol", "imagesFile", "FilesFile", "ballsPos", "filesFile", " filesVol", "ballsDir", "videosDirectory", "FilesFolder", "opensDIR", "filesVol"], "videosDir": ["imagesDb", "viewsDirectory", "videosUrl", "videoDir", "videoUrl", " videosDb", "videosFile", "imagesDir", " videosUrl", "videoDirectory", "viewsUrl", " videosFile", "videosDb", "videoFile", " videosDirectory", "videosDirectory", "viewsDir", "viewsFile", "videoDb"], "imagensDir": ["imgensFile", "imagersDIR", "imagersDir", "imagenJar", "imgentsDir", "imagersFile", "imgentsFile", "imagenciesDIR", "imgensDIR", "imagenDir", "imagersJar", "imagentsJar", "imagenciesDir", " imagensDirectory", "imagersDirectory", "imagentsDir", "imagentsFile", "imagentsDirectory", "imagenciesDirectory", "imgensDir", "imgentsDIR", "imgentsDirectory", "imagensJar", " imagersJar", "imagensDIR", "imgensDirectory", " imagensFile", "imagensFile", "imagensDirectory", " imagersFile", " imagensJar", " imagersDirectory", "imagentsDIR", "imagenDirectory", " imagersDir", "imagenFile", "imagenciesFile"], "local": ["active", "lock", "localhost", " Local", "standard", "specified", "loc", "name", "data", "current", "present", "util", "where", "basic", "self", "remote", "input", "p", "partial", "personal", "state", "shared", "base", "log", "part", "user", "inner", "conf", "managed", "LOC", "l", "back", "temp", "defined", "d", "relative", "request", "path", "serial", "pal", "small", "tmp", "pass", "http", "Local", "file", "global", "prefix", "valid", "same", "Location", "upload", "safe", "dir", "initial", "total", "home", "directory", "location", "available", "internal", "json", "username"], "srcCss1": ["srcCcss4", "srcCfgPre", "srcCse1", "srcCcss0", "srcCass1", "srcCcss11", "srcCse2", "srcCpe2", "srcPcssPre", "srcCrss2", "srcPss81", "srcPcss81", "srcCrss3", "srcRss81", "srcRss2", "srcCse11", "srcPss4", "srcCcss1", "srcRss1", "srcCfg2", "srcCass0", "srcPss2", "srcCcss81", "srcCcssPre", "srcCss81", "srcCrss1", "srcCrss81", "srcPcss1", "srcCass11", "srcRss0", "srcCss11", "srcPssPre", "srcPcss3", "srcPss3", "srcCpe4", "srcCass3", "srcCfg4", "srcCfg1", "srcCass81", "srcCss0", "srcRcss11", "srcPss1", "srcCpe1", "srcRcss1", "srcRcss0", "srcCcss2", "srcPcss2", "srcRss11", "srcRcss2", "srcCrss11", "srcCcss3", "srcCass2", "srcCpePre", "srcRcss81", "srcCse0", "srcCssPre", "srcPcss4"], "destCss1": ["destCxx2", "destPssCard", "destPcss1", "destCfg0", "destCrss2", "destCcss1", "destCcss2", "destPcss0", "destCcss0", "destCrss81", "destCcss81", "destCass3", "destCfg2", "destPcssCard", "destCass1", "destCassCard", "destCcss3", "destPcss2", "destCxxCard", "destCss0", "destCss81", "destCxx1", "destCxx3", "destCrss1", "destCfg3", "destPss81", "destCass2", "destPcss81", "destPcss3", "destPss3", "destCcssCard", "destPss0", "destPss1", "destCrss0", "destPss2", "destCssCard", "destCass81", "destCrss3", "destCfg1"], "srcCss2": ["srcUss1", "srcCcss4", "srcCfgL", "srcChessTwo", "srcChess1", "srcCass1", "srcCrss2", "srcCrss3", "srcPssL", "srcPcssL", "srcCssL", "srcUcss1", "srcCcss1", "srcCssB", "srcUcssB", "srcCass4", "srcUssTwo", "srcCfg2", "srcCcss52", "srcCss27", "srcPss2", "srcAccss52", "srcCross52", "srcCross4", "srcAcss1", "srcCrss27", "srcCfg3", "srcCrss1", "srcPcss27", "srcCssTwo", "srcPcss1", "srcPcss3", "srcCcssB", "srcPss3", "srcCng27", "srcCng1", "srcAcss4", "srcCfg1", "srcCross2", "srcChessB", "srcPss1", "srcAcss2", "srcCass52", "srcCcssTwo", "srcCng2", "srcCss52", "srcCcss2", "srcPcss2", "srcAccss2", "srcCfgB", "srcCcss27", "srcCrssL", "srcCcss3", "srcCcssL", "srcUss2", "srcCass2", "srcPss27", "srcUcss2", "srcAccss4", "srcUcssTwo", "srcAccss1", "srcUssB", "srcCross1", "srcCfgTwo", "srcAcss52", "srcChess2"], "destCss2": ["destCest1", "destNcss4", "destCcss32", "destCest3", "destCcss4", "destCcss72", "destCss32", "destNcss2", "destCcss1", "destCcss2", "destNcss3", "destCfg2", "destNss32", "destCess2", "destNssB", "destNcss32", "destCcss3", "destCfg4", "destNss4", "destCess32", "destNss2", "destCfgB", "destCfg3", "destCess1", "destNcss1", "destNss3", "destCest2", "destNss1", "destCess4", "destCssB", "destNcssB", "destCss72", "destCestB", "destNss72", "destNcss72", "destCfg72", "destCess72", "destCcssB", "destCfg1", "destCfg32"], "srcCss3": ["srcScss15", "srcCcss4", "srcCcssThird", "srcCshThird", "srcCstyle2", "srcScss3", "srcRcss4", "srcRss1", "srcCcss183", "srcCstyle15", "srcCfg3", "srcCcss6", "srcRss183", "srcCsh2", "srcCfg4", "srcCfg1", "srcScstyle93", "srcCrssAND", "srcPss6", "srcCass1", "srcPcss6", "srcRss2", "srcScss93", "srcRcss183", "srcPcssAND", "srcRcssThird", "srcClass15", "srcScstyle2", "srcCcss1", "srcPss2", "srcCstyle93", "srcPcss3", "srcClass93", "srcRcss1", "srcClass3", "srcCcssAND", "srcRcss2", "srcCsh183", "srcCsh3", "srcClass2", "srcCsl3", "srcCssAND", "srcCrss3", "srcPssAND", "srcRcss3", "srcCssThird", "srcRssThird", "srcRss3", "srcCcss2", "srcPcss2", "srcCass2", "srcCstyle6", "srcScss2", "srcCsl2", "srcCstyle3", "srcCrss2", "srcCss93", "srcCslThird", "srcCcss15", "srcRss4", "srcCass4", "srcCfg2", "srcCrss6", "srcCsl183", "srcScstyle3", "srcPss3", "srcCass3", "srcCss15", "srcCcss3", "srcCstyleAND", "srcCss183", "srcCcss93", "srcScstyle15"], "destCss3": ["destScrss6", "destCja6", "destCross03", "destNcss2", "destCrss2", "destCcss2", "destCstyle43", "destCss183", "destCrss6", "destScss2", "destPcss03", "destCcss53", "destCstyle03", "destNcss3", "destCass3", "destCja3", "destCja2", "destCcss3", "destScss6", "destCss03", "destCstyle2", "destCcss6", "destScss183", "destCcss183", "destScrss2", "destPcss2", "destNss2", "destNcss43", "destPss53", "destPcss53", "destNss3", "destCss43", "destCcss43", "destPss03", "destNss43", "destCass2", "destCstyle53", "destScrss183", "destCcss03", "destPcss3", "destPss3", "destCross2", "destScrss3", "destCross3", "destCross53", "destCass43", "destCstyle3", "destScss3", "destCss53", "destCrss183", "destPss2", "destCrss3", "destCja183"], "srcCss4": ["srcCcss4", "srcCass1", "srcPssFour", "srcCrss4", "srcCrss2", "srcPss4", "srcCcss1", "srcCass4", "srcPss2", "srcCrss1", "srcPcss1", "srcPss1", "srcCssFour", "srcCcss2", "srcPcss2", "srcPcssFour", "srcCass2", "srcCcssFour", "srcCassFour", "srcCrssFour", "srcPcss4"]}}
{"id1": "5760649", "id2": "10690321", "code1": "    public void createFile(File src, String filename) throws IOException {\n        try {\n            FileInputStream fis = new FileInputStream(src);\n            OutputStream fos = this.fileResourceManager.writeResource(this.txId, filename);\n            IOUtils.copy(fis, fos);\n            fos.close();\n            fis.close();\n        } catch (ResourceManagerException e) {\n            LOGGER.error(e);\n        }\n    }\n", "code2": "    private static void readData() {\n        StringTokenizer sTok;\n        topSet = new HashSet();\n        sTok = new StringTokenizer(tops, \",\");\n        while (sTok.hasMoreTokens()) topSet.add(sTok.nextToken());\n        leftSet = new HashSet();\n        sTok = new StringTokenizer(lefts, \",\");\n        while (sTok.hasMoreTokens()) leftSet.add(sTok.nextToken());\n        rightSet = new HashSet();\n        sTok = new StringTokenizer(rights, \",\");\n        while (sTok.hasMoreTokens()) rightSet.add(sTok.nextToken());\n        farRightSet = new HashSet();\n        sTok = new StringTokenizer(farrights, \",\");\n        while (sTok.hasMoreTokens()) farRightSet.add(sTok.nextToken());\n        vowelSet = new HashSet();\n        sTok = new StringTokenizer(vowels, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            vowelSet.add(ntk = sTok.nextToken());\n            if (maxEwtsVowelLength < ntk.length()) maxEwtsVowelLength = ntk.length();\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        puncSet = new HashSet();\n        sTok = new StringTokenizer(others, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            puncSet.add(ntk = sTok.nextToken());\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet = new HashSet();\n        tibSet = new HashSet();\n        sTok = new StringTokenizer(tibetanConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            tibSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        sanskritStackSet = new HashSet();\n        sTok = new StringTokenizer(otherConsonants, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            sanskritStackSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        numberSet = new HashSet();\n        sTok = new StringTokenizer(numbers, \",\");\n        while (sTok.hasMoreTokens()) {\n            String ntk;\n            charSet.add(ntk = sTok.nextToken());\n            numberSet.add(ntk);\n            validInputSequences.put(ntk, anyOldObjectWillDo);\n        }\n        charSet.add(\"Y\");\n        charSet.add(\"R\");\n        charSet.add(\"W\");\n        validInputSequences.put(\"Y\", anyOldObjectWillDo);\n        validInputSequences.put(\"R\", anyOldObjectWillDo);\n        validInputSequences.put(\"W\", anyOldObjectWillDo);\n        sTok = null;\n        top_vowels = new HashSet();\n        top_vowels.add(i_VOWEL);\n        top_vowels.add(e_VOWEL);\n        top_vowels.add(o_VOWEL);\n        top_vowels.add(ai_VOWEL);\n        top_vowels.add(au_VOWEL);\n        top_vowels.add(reverse_i_VOWEL);\n        try {\n            URL url = TibetanMachineWeb.class.getResource(fileName);\n            if (url == null) {\n                System.err.println(\"Cannot find \" + fileName + \"; aborting.\");\n                System.exit(1);\n            }\n            InputStreamReader isr = new InputStreamReader(url.openStream());\n            BufferedReader in = new BufferedReader(isr);\n            System.out.println(\"Reading Tibetan Machine Web code table \" + fileName);\n            String line;\n            boolean hashOn = false;\n            boolean isTibetan = false;\n            boolean isSanskrit = false;\n            boolean ignore = false;\n            while ((line = in.readLine()) != null) {\n                if (line.startsWith(\"<?\")) {\n                    if (line.equalsIgnoreCase(\"<?Consonants?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Other?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                        do {\n                            line = in.readLine();\n                        } while (line.startsWith(\"//\") || line.equals(\"\"));\n                    } else if (line.equalsIgnoreCase(\"<?Input:Punctuation?>\") || line.equalsIgnoreCase(\"<?Input:Vowels?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Tibetan?>\")) {\n                        isSanskrit = false;\n                        isTibetan = true;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Numbers?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Input:Sanskrit?>\")) {\n                        isSanskrit = true;\n                        isTibetan = false;\n                        hashOn = true;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?ToWylie?>\")) {\n                        isSanskrit = false;\n                        isTibetan = false;\n                        hashOn = false;\n                        ignore = false;\n                    } else if (line.equalsIgnoreCase(\"<?Ignore?>\")) {\n                        isSanskrit = false;\n                        ignore = true;\n                    }\n                } else if (line.startsWith(\"//\")) {\n                    ;\n                } else if (line.equals(\"\")) {\n                    ;\n                } else {\n                    StringTokenizer st = new StringTokenizer(line, DELIMITER, true);\n                    String wylie = null;\n                    DuffCode[] duffCodes;\n                    duffCodes = new DuffCode[11];\n                    int k = 0;\n                    StringBuffer escapedToken = new StringBuffer(\"\");\n                    ThdlDebug.verify(escapedToken.length() == 0);\n                    while (st.hasMoreTokens()) {\n                        String val = getEscapedToken(st, escapedToken);\n                        if (val.equals(DELIMITER) && escapedToken.length() == 0) {\n                            k++;\n                        } else if (!val.equals(\"\")) {\n                            if (escapedToken.length() != 0) {\n                                escapedToken = new StringBuffer(\"\");\n                                ThdlDebug.verify(escapedToken.length() == 0);\n                            }\n                            switch(k) {\n                                case 0:\n                                    wylie = val;\n                                    break;\n                                case 1:\n                                    duffCodes[TM] = new DuffCode(val, false);\n                                    break;\n                                case 2:\n                                    if (!ignore) {\n                                        duffCodes[REDUCED_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 3:\n                                    duffCodes[TMW] = new DuffCode(val, true);\n                                    if (null != duffCodes[TM]) {\n                                        TMtoTMW[duffCodes[TM].getFontNum() - 1][duffCodes[TM].getCharNum() - 32] = duffCodes[TMW];\n                                    }\n                                    if (null != TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32]) throw new Error(\"tibwn.ini is supposed to use the TibetanMachineWeb glyph as the unique key, but \" + val + \" appears two or more times.\");\n                                    TMWtoTM[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = duffCodes[TM];\n                                    if (wylie.toLowerCase().startsWith(\"\\\\uf0\")) {\n                                        int x = Integer.parseInt(wylie.substring(\"\\\\u\".length()), 16);\n                                        ThdlDebug.verify((x >= 0xF000 && x <= 0xF0FF));\n                                        NonUnicodeToTMW[x - '\uf000'] = new DuffCode[] { duffCodes[TMW] };\n                                    }\n                                    break;\n                                case 4:\n                                case 5:\n                                case 6:\n                                case 7:\n                                case 8:\n                                case 9:\n                                    if (!ignore) {\n                                        try {\n                                            duffCodes[k - 1] = new DuffCode(val, true);\n                                        } catch (Exception e) {\n                                            System.err.println(\"Couldn't make a DuffCode out of \" + val + \"; line is \" + line + \"; k is \" + k);\n                                        }\n                                    }\n                                    break;\n                                case 10:\n                                    if (!val.equals(\"none\")) {\n                                        StringBuffer unicodeBuffer = new StringBuffer();\n                                        StringTokenizer uTok = new StringTokenizer(val, \",\");\n                                        while (uTok.hasMoreTokens()) {\n                                            String subval = uTok.nextToken();\n                                            ThdlDebug.verify(subval.length() == 4 || subval.length() == 3);\n                                            try {\n                                                int x = Integer.parseInt(subval, 16);\n                                                ThdlDebug.verify((x >= 0x0F00 && x <= 0x0FFF) || x == 0x5350 || x == 0x534D || x == 0x0020 || x == 0x00A0 || x == 0x2003);\n                                                unicodeBuffer.append((char) x);\n                                            } catch (NumberFormatException e) {\n                                                ThdlDebug.verify(false);\n                                            }\n                                        }\n                                        TMWtoUnicode[duffCodes[TMW].getFontNum() - 1][duffCodes[TMW].getCharNum() - 32] = unicodeBuffer.toString();\n                                        char ch;\n                                        if (unicodeBuffer.length() == 1 && UnicodeUtils.isInTibetanRange(ch = unicodeBuffer.charAt(0))) {\n                                            if (null != UnicodeToTMW[ch - '\u0f00'][0] && '\u0f00' != ch && '\u0f02' != ch && '\u0f03' != ch && '\u0f0b' != ch && '\u0f0e' != ch && '\u0f40' != ch && '\u0f42' != ch && '\u0f49' != ch && '\u0f4f' != ch && '\u0f51' != ch && '\u0f53' != ch && '\u0f5e' != ch && '\u0f62' != ch && '\u0f64' != ch && '\u0f67' != ch && '\u0f6a' != ch && '\u0f71' != ch && '\u0f72' != ch && '\u0f73' != ch && '\u0f74' != ch && '\u0f75' != ch && '\u0f76' != ch && '\u0f77' != ch && '\u0f78' != ch && '\u0f79' != ch && '\u0f7a' != ch && '\u0f7c' != ch && '\u0f7e' != ch && '\u0f81' != ch) {\n                                                throw new Error(\"tibwn.ini has more than one TMW fellow listed that has the Unicode \" + val + \", but it's not on the list of specially handled glyphs\");\n                                            }\n                                            UnicodeToTMW[ch - '\u0f00'][0] = duffCodes[TMW];\n                                        }\n                                    }\n                                    break;\n                                case 11:\n                                    if (!ignore) {\n                                        duffCodes[HALF_C] = new DuffCode(val, true);\n                                    }\n                                    break;\n                                case 12:\n                                    if (!ignore) {\n                                        DuffCode binduCode = new DuffCode(val, true);\n                                        binduMap.put(duffCodes[TMW], binduCode);\n                                    }\n                                    break;\n                                case 13:\n                                    throw new Error(\"tibwn.ini has only 13 columns, you tried to use a 14th column.\");\n                            }\n                        } else {\n                            if (k == 10) {\n                                throw new Error(\"needed none or some unicode; line is \" + line);\n                            }\n                        }\n                    }\n                    if (k < 10) {\n                        throw new Error(\"needed none or some unicode; line is \" + line);\n                    }\n                    if (!ignore) {\n                        if (null == wylie) throw new Error(fileName + \" has a line ^\" + DELIMITER + \" which means that no Wylie is assigned.  That isn't supported.\");\n                        if (hashOn) {\n                            tibHash.put(Manipulate.unescape(wylie), duffCodes);\n                        }\n                        if (isTibetan) {\n                            StringBuffer wylieWithoutDashes = new StringBuffer(wylie);\n                            for (int wl = 0; wl < wylieWithoutDashes.length(); wl++) {\n                                if (wylieWithoutDashes.charAt(wl) == '-') {\n                                    wylieWithoutDashes.deleteCharAt(wl);\n                                    --wl;\n                                }\n                            }\n                            tibSet.add(wylieWithoutDashes.toString());\n                        }\n                        if (isSanskrit) {\n                            sanskritStackSet.add(wylie);\n                        }\n                        if (null == duffCodes[TMW]) throw new Error(fileName + \" has a line with wylie \" + wylie + \" but no TMW; that's not allowed\");\n                        int font = duffCodes[TMW].getFontNum();\n                        int code = duffCodes[TMW].getCharNum() - 32;\n                        toHashKey[font][code] = Manipulate.unescape(wylie);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(\"file Disappeared\");\n            ThdlDebug.noteIffyCode();\n        }\n    }\n", "label": 0, "substitutes": {"createFile": ["createContent", "saveFolder", "saveResource", "saveContent", " createContent", "CreateFile", "CreateContent", "createFolder", " createFolder", "createResource", "saveFile", " createResource", "CreateResource", "CreateFolder"], "src": ["source", "sb", "fp", "uri", "path", "username", "load", "s", "buf", "txt", "input", "resources", "loc", "data", "Source", "resource", "img", "dest", "rob", "url", "name", "proc", "obj", "files", "sel", "sit", "sl", "sc", "secure", "SourceFile", "rc", "rss", "string", "fn", "rb", "upload", "gb", "stream", "ruby", "file", "r", "ssl", "slice", "href", "cb", "content"], "filename": ["source", "uri", "fp", "output", "length", "path", "username", "feat", "ame", "f", "s", "title", "txt", "fil", "l", "loader", "location", "metadata", "resource", "which", "dll", "directory", "FILE", "url", "name", "ames", "files", "rl", "SourceFile", "string", "fn", "ename", "prefix", "Filename", "acl", "file", "utf", "route", "nil", "wb", "sf"], "fis": ["fbs", "Fiss", "fiss", "cfIS", "cfris", "FIS", " fiss", "sfis", "Fbs", "sfos", "fris", "Fos", "Fis", " fais", "Fais", "fais", "cfis", "Fris", "cfbs", "fIS", "sfris", " fIS", "cfais", "sfiss", " fbs", "cfos", " fris"], "fos": ["affis", "affios", "Fas", "bos", "sfios", "foras", "sfis", "affbos", "affos", "Fbos", "sfos", "FOS", " fops", "sfops", " fOS", "bbos", "Fos", "fbos", "bios", "Fis", "Fops", "fas", "fios", " fas", "foris", "Fios", "fOS", "bis", "fops", " fios", "foros", "forOS"]}}
{"id1": "14758866", "id2": "20920051", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getResourceAsStream": ["getResourcesasFile", "getResourceASStream", "getResourceasFile", "getResourceToString", "getResourceasStream", "getResourcesasSteam", "getResourcesAsFile", "getResourcesasString", "getResourceToSteam", "getResourceAsString", "getResourcesAsStream", "getResourcesAsSteam", "getResourcesasStream", "getResourceASString", "getResourceASSteam", "getResourceToFile", "getResourceASFile", "getResourceToStream", "getResourceAsSteam", "getResourceasSteam", "getResourceAsFile", "getResourcesAsString", "getResourceasString"], "name": ["full", "connection", "ame", "data", "version", "type", "remote", "info", "ip", "str", "base", "part", "cache", "time", "size", "domain", "alias", "key", "address", "source", "path", "parent", "filename", "object", "hash", "Name", "config", "uri", "names", "memory", "file", "id", "prefix", "word", "resource", "named", "location", "string", "NAME", "username"], "inputStream": [" inputstream", "inputSteam", "cachestream", "currentBody", "InputConnection", " inputBody", "currentstream", "InputChannel", "InputStream", "currentStream", " inputChannel", "cacheSteam", "pullChannel", "inputBody", "pullConnection", "inputConnection", "cacheStream", "pullStream", "pullSteam", "inputFeed", "InputFeed", " inputConnection", "Inputstream", "inputChannel", "currentSteam", "InputBody", "cacheFeed", "InputSteam", "inputstream", " inputSteam", " inputFeed"], "in": ["reader", "bin", "data", "socket", "ins", "m", "In", "rec", "log", "inner", "din", "r", "IN", "err", "buffer", "source", "image", "path", "exec", "read", "c", "src", "input", "re", "Out"], "out": ["lock", "bin", "msg", "data", "point", "error", "pool", "state", "outs", "ex", "gen", "proc", "dump", "ger", "sys", "log", "copy", "page", "part", "conn", "user", "output", "cache", "cmd", "r", "line", "writer", "pre", "err", "query", "key", "client", "flush", "OUT", "temp", "list", "buffer", "cli", "bar", "outer", "object", "group", "server", "raw", "io", "up", "file", "params", "println", "inter", "window", "debug", "ref", "Out", "obj"], "url": ["full", "connection", "https", "open", "sl", "f", "data", "loc", "org", "socket", "ur", "gl", "remote", "stream", "web", "download", "event", "base", "log", "ssl", "page", "cache", "b", "user", "l", "r", "left", "client", "address", "pull", "Url", "service", "URL", "source", "image", "feed", "api", "path", "object", "update", "config", "li", "server", "uri", "route", "browser", "http", "file", "resource", "result", "coll", "bel", "location", "rel", "string", "ob"], "remoteName": ["fullPath", "localPath", "Remotename", "remoteUrl", "fullname", "fullKey", "remotename", "RemoteUrl", "RemotePath", "localUrl", " remotePath", "RemoteKey", "remotePath", " remoteUrl", "localKey", "remoteKey", "fullName", "RemoteName", " remoteKey", " remotename"], "localName": ["remoteFile", "locString", "locName", "globalString", "locname", "localPath", "LocalKey", " localname", "localFile", "LocalPath", "locUrl", "LocalName", "remoteUrl", " localKey", "locPath", "localString", " localString", "remotename", "localUrl", "globalFile", "remotePath", " localUrl", " localFile", "localKey", "remoteKey", "globalname", "globalName", "globalKey", "globalPath", "localname", "remoteString", " localPath", "Localname"], "host": ["localhost", "loc", "hard", "database", "head", "type", "remote", "format", "conn", "domain", "address", "proxy", "hop", "service", "driver", "path", "h", "config", "arch", "server", "uri", "http", "Host", "prefix", "src", "header", "target", "dir", "home", "addr", "string", "ip", "username"], "prot": ["prop", "family", "channel", "addr", "pt", "lat", "proc", " plat", "ssl", "ht", "conn", "part", " proto", "Prot", "txt", "att", "password", "client", " protocol", "cli", "api", "col", "pattern", "config", "conv", "platform", "pass", "afi", "cert", "pos", "prefix", "ocol", "stat", "ios", "pro", "ref", "def", "rel", "serv", " protocols", "rot", "nat"], "port": ["f", "version", "point", "phone", "PORT", "type", "slice", "allow", "p", "pi", "timeout", "position", "direction", "future", "pr", "time", "size", "Port", "patch", "password", "address", "service", "hop", "proxy", "ort", "select", "value", "limit", "project", "path", "pid", "width", "number", "server", "uri", "pass", "file", "ports", "index", "priority", "target", "length", "string", "ip", "rest"], "cacheFile": ["remoteFile", "CacheDirectory", "basefile", "outputConnection", "localfile", " cacheLine", " cachefile", "cacheConnection", "proxyHandle", "localFile", "outputFile", "baseFile", "CacheDir", "achePlace", "cacheMessage", "storageFile", "cacheDirectory", " cacheDir", "cacheLine", "remoteUrl", "fakeFile", "sessionDir", " cacheFiles", "localDir", "tempDir", "acheFiles", "sessionFiles", "cacheUrl", "tempfile", "fakeUrl", "storageFiles", "localFiles", "cacheHandle", "Cachefile", "cachePlace", "storagePlace", "proxyfile", "cacheFiles", " cacheHandle", "CacheUrl", "cachefile", "proxyDir", "fakeLine", "tempHandle", "remoteLine", "outputMessage", " cachePlace", "baseMessage", "CacheFile", " cacheConnection", "remotefile", "outputfile", "acheFile", "fakefile", " cacheMessage", "sessionUrl", "cacheDir", " cacheDirectory", " cacheUrl", "CacheFiles", "proxyFile", "localDirectory", "baseConnection", "tempFile", "sessionFile"], "urlConnection": ["URLconnection", "sslFile", "URLConnection", "slCode", "urlconnection", "slChannel", "httpCode", " urlFile", "cacheConnection", "cachePool", "cacheConn", "downloadEntry", "downloadConnection", " urlconnection", "webConnect", "fileConnection", "URLResponse", " urlChannel", " urlConnect", "urlPool", "slConnection", "cacheConnect", "fileConn", "urlEntry", "sslConnection", "urlPart", "filePart", "fileConnect", "downloadconnection", "slCommand", "sslResponse", "httpChannel", " urlCommand", "httpPool", "httpCon", "urlCon", "urlResponse", "urlConnect", "sslConn", "httpConnect", "downloadFile", " urlCode", "URLConn", "sslConnect", "urlCommand", " urlPool", "urlChannel", "httpconnection", "URLCon", "sslEntry", "urlCode", "sslconnection", "urlConn", " urlConn", "URLConnect", "httpResponse", " urlPart", "webconnection", " urlEntry", "URLPart", "webConnection", "httpCommand", "httpConn", "webCon", "urlFile", "httpConnection"], "httpURLConnection": ["httpCLConnector", "httpCLConnection", "httpREConnection", "httpSLCode", "upperRTransaction", "httpURLCode", "httpRNode", "upperRNode", " httpLLConstruction", "httpSLConnection", "httpRLConnector", "httpHTTPFunction", "httpREStatement", "httpHTTPQuery", "httpURQuery", "httpCLConnect", "httpSLconnection", "httpurlConnection", "httpRLClient", "httpURLConn", "httpMconnection", "upperURLNode", "httpWSNode", "httpLLconnection", "httpURNode", "httpBLQuery", "httpLLConnection", " httpUrlFunction", "httpUrlconnection", "httpDOMconnection", " httpUrlConnection", "httpMLFunction", "cacheURLClient", "httpUrlConnection", " httpHTTPConnection", " httpURLconnection", "httpRLConnection", "urlUrlClient", "httpBLFunction", "httpDateconnection", "httpURFunction", " httpLLConn", "cacheURLConnection", "httpBLOperation", "upperURLConnection", "httpREConstruction", "httpurlconnection", "httpurlStatement", "urlUrlStatement", "httpFormConnection", "httpURLFunction", "shortURLConnection", "httpREconnection", "httpMLconnection", "httpREClient", "upperURLconnection", "urlURLconnection", "httpRLConnect", "httpURLOperation", " httpHTTPQuery", "cacheURLConnect", "cacheUrlClient", "httpHTTPOperation", "httpWSTransaction", "httpURLClient", "httpMCode", "currentURLCode", "upperURLTransaction", "httpBLConnection", " httpUrlconnection", "httpUROperation", "shortSLConnection", " httpURLConn", "shortSLconnection", "httpURConnection", "httpURLNode", " httpLLConnection", "shortSLConnect", "httpUrlConnect", "httpFormConnect", "httpDateConstruction", "currentURLConnection", " httpHTTPFunction", "httpCLClient", "httpURLConstruction", " httpLLconnection", "httpURLconnection", "httpFormconnection", "httpURLStatement", "httpUrlFunction", "httpHTTPConnection", "httpSLConnect", " httpURLQuery", "urlUrlconnection", "httpWSconnection", " httpURLConnect", "currentURLconnection", "shortURLConnect", " httpURLOperation", "httpDOMFunction", "httpRConnection", "httpURTransaction", "currentURLConnect", "urlURLStatement", "httpDOMConnect", "httpUrlConnector", "httpMLConnect", "cacheUrlConnector", "httpDOMConnection", "httpUrlStatement", " httpURLFunction", " httpURLConstruction", "urlUrlConnection", "upperRconnection", "httpREConn", "urlURLClient", "httpMLConnection", "httpURconnection", "httpURLQuery", "httpLLConn", "httpURLConnector", " httpUrlConnect", "httpUrlClient", "urlURLConnection", "httpURLTransaction", "cacheURLConnector", "httpRLconnection", "httpurlClient", "httpLLConstruction", "cacheUrlConnect", "shortURLconnection", "httpWSConnection", " httpHTTPOperation", "httpDateConnection", "cacheUrlConnection", "httpRTransaction", "httpRconnection", "httpMConnection", "httpURLConnect", "upperRConnection", "httpDateConn", "httpMConnect"], "responseCode": ["statusStatus", "ResponseMessage", "statusCount", "ResponseCode", "statusType", "ResponseStatus", "replyMessage", "ResponseType", "statusCode", "replyType", "responseStatus", "replyCode", "ResponseCount", " responseMessage", "statusMessage", " responseStatus", "replyCount", "responseCount", "responseType", "responseMessage", " responseType"], "lastModified": ["lastModed", "lastMODIFIED", " lastMODined", "lastMinified", "lastEdIFIED", "New", "nextMODified", " lastModied", "lastEdified", "lastModIFIED", "lastmoded", "nextMODed", "lastMODied", "nextModIFIED", "nextMODied", "nextModied", "lastmodIFIED", " lastModined", " lastMODied", " lastMODIFIED", "lastEded", "lastmodified", "_", "lastMODified", "lastMinIFIED", " lastMODified", "lastmodied", "lastModied", "lastMinied", "this", "lastMODification", "lastmodification", "nextModification", "nextMODIFIED", "lastEdification", "lastMODed", " lastModIFIED", "lastModined", "s", "nextModified", "lastModification", "lastMinined", "lastMODined", "nextMODification", "nextModed"]}}
{"id1": "17724879", "id2": "10674824", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    @Before\n    public void setUp() throws Exception {\n        final URL url = getClass().getClassLoader().getResource(\"insecureSSL.keystore\");\n        final KeyStore keystore = KeyStore.getInstance(\"jks\");\n        final char[] pwd = \"nopassword\".toCharArray();\n        keystore.load(url.openStream(), pwd);\n        final TrustManagerFactory trustManagerFactory = createTrustManagerFactory();\n        trustManagerFactory.init(keystore);\n        final TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();\n        final KeyManagerFactory keyManagerFactory = createKeyManagerFactory();\n        keyManagerFactory.init(keystore, pwd);\n        final KeyManager[] keyManagers = keyManagerFactory.getKeyManagers();\n        final SSLContext serverSSLContext = SSLContext.getInstance(\"TLS\");\n        serverSSLContext.init(keyManagers, trustManagers, null);\n        localServer_ = new LocalTestServer(serverSSLContext);\n        localServer_.registerDefaultHandlers();\n        localServer_.start();\n    }\n", "label": 0, "substitutes": {"getDigest": ["getSignests", "getdigHash", "getSignHash", "createdigHash", "createDigester", "getSignester", "getdigests", "createDigests", "getMDHash", "getdigester", "getMDest", "getDigester", "createdigest", "createdigests", "createdigester", "getMDests", "getDigests", "getMDester", "getSignest", "getdigest", "createDigHash", "createDigest", "getDigHash"], "attribute": ["prefix", "att", "component", "subject", "uri", "resource", "image", "message", "connection", "event", "data", "username", "individual", "entry", "document", "application", "definition", "audio", "route", "set", "attr", "type", "ribute", "element", "instance", "plugin", "class", "metadata", "api", "config", "directory", "client", "pair", "expression", "feature", "node", "variable", "object", "address", "character", "name", "property", "entity", "reference", "device", "function", "layer", "operation", "value", "ident", "argument", "manager", "Attribute"], "digestAlgorithm": ["digESTAlg", "digesterAlgebra", "digestalger", "digestElg", "digestElger", "digestAlgorith", "digestalgo", "digesterAlgo", "digestAlg", "digESTAlgo", "digesterAlgorith", "digESTAlgorithm", "digestAlgo", "digestalg", "digestalgorith", "digestAlgebra", "digestalgorithm", "digestElgo", "digestALgorithm", "digestALgebra", "digesterAlgorithm", "digestALgorith", "digestElgorithm", "digestALgo", "digestAlger", "digESTAlger", "digestalgebra"], "digest": ["labest", "DigEST", " digEST", "dger", "bigester", "dest", "bigger", "bigest", "Digester", "signger", "digEST", "Digest", " digested", "diguration", "longester", "Digtest", "digtest", "multipluration", "multiplEST", "labEST", "digger", "multiplest", "signest", " diguration", "multiplester", " digester", "longEST", "Digested", "digester", " digtest", "signester", "dester", "biggest", "labtest", "dgest", "digested", "labester", "diggest", "Diguration", "longest", "signgest", "longested"], "md": ["ds", "own", "m", "wd", "rm", "doc", "mad", "hd", "sd", " MD", "der", "module", "nd", "mp", "cmd", "mr", "mo", "um", "mid", "dd", "ht", "editor", "mc", "mag", "d", "od", "mb", "ms", "dev", "ng", "nm", "amd", "plugin", "dm", "bd", "meta", "metadata", "cm", "pd", "MD", "di", "mn", "mi", "db", "ad", "mac", "my", "id", "po", "mm", "ma", "sm", "app", "ml", "ld", "cb", "pm", "kg", "arm", "mt", "cd", "ui", "mod", "manager", "df"]}}
{"id1": "14865947", "id2": "23335922", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 1, "substitutes": {"execute": ["action", "run", "exit", "send", "call", "ute", "invoke", "open", "process", "command", "task", " executing", "exec", "load", "complete", "evaluate", "start", "transfer", "test", "submit", "message", "loop", "launch", "Submit", "create"], "event": ["vent", "g", "context", "ex", "te", "ents", " Event", " EVENT", "ctx", "events", "object", "exec", "exc", "x", " events", "f", "other", "Event", "image", "ext", "v", "test", "ev", "ent", "t", "message", "ec"], "shell": ["il", "mail", "tty", "live", "ml", "window", "sh", "bot", "site", "environment", "o", "gui", "xml", "tool", "log", "ll", "lex", "tools", "search", "edit", "sol", "ui", "sync", "sql", "child", "build", "Shell", "bash", "cl", "l", "cell", "layout", "model", "exec", "cmd", "server", "sole", "system", "help", "math", "sl", "pool", "cli", "sb", "session", "hell", "dll", "nl", "home", "el", "lib", "cel", "kernel", "null", "prof", "pty", "loop", "lock", "console", " Shell"], "view": ["row", "views", "window", "container", "View", " layout", "gui", "service", "screen", "review", "display", "list", " overview", "tree", "VIEW", "ui", "visual", "summary", "object", "user", "book", "l", " preview", "show", "layout", "model", "iew", "url", "f", "control", "pool", "session", "image", "widget", "page", "v", "plugin", "web", "sel", "lock", "console", "version", "flow"], "rootFolder": [" rootArea", "RootZip", "bottomFile", "homeCenter", "shellDir", "rootFile", "parentFile", "mainfolder", "RootWindow", "rootWindow", "RootFolder", "shellFolder", " rootCenter", "homeFolder", "homeDirectory", " rootDir", " rootOrg", " rootFlow", "parentFlow", "mainFolder", " rootFile", " rootWindow", "RootDirectory", "bottomDirectory", " rootDirectory", "rootOrg", "shellArea", "RootOrg", "shellWindow", "rootFlow", "RootCenter", "rootDir", "rootDirectory", "rootfolder", "parentDirectory", "Rootfolder", "RootFile", "bottomFlow", "RootDir", "bottomFolder", "rootZip", "rootCenter", " rootfolder", "parentFolder", "parentZip", "RootArea", "rootArea", "mainOrg", "mainFile", " rootZip"], "dialog": ["clogg", "clect", "protogg", "logDialog", "challogging", "logogue", "challDialog", "dialogg", "challock", "logock", "challogs", "dialogs", "diffDialog", "diffock", "protect", "logog", "dialock", "dialect", "diffogue", "dialDialog", "dialogging", "logogs", "clogs", "diffog", "dialOG", "clogging", "challogue", "challogg", "protog", "challect", "protogging", "challOG", "dialogue", "logOG", "logogg", "clOG", "clog", "challog"], "password": ["resource", "pass", "root", "token", "username", "words", "sword", "description", "string", "mac", "channel", "pg", "word", "volume", "secret", "language", "Password", "sum", "wallet", "path", "PASS", "params", "patch", "key", "auth", "pad", "database", "wd", "email", "content", "mode", "address", "handler", "command", "p", "connection", "device", "cmd", "phrase", "prefix", "definition", "config", "size", "confirmed", "session", "value", "hash", "page", "diff", "directory", "data", "picture", "account", "message", "pattern", "source", "crypt", "text", "column", "name", "encrypted", "padding"], "md5": ["mand15", "mand2", "md50", "mand5", "MD2", "mg40", "MD40", "dd5", "MD5", " mddown", " md15", "mddown", "md2", "mg2", "mg50", "cmd2", "MDdown", "md15", "md4", " md4", " md2", "manddown", "dd2", "md40", "cmd4", "md512", "MD50", "MD15", "MD4", " md512", "cmd512", "MD512", "dd40", "dd50", "mg5", "mand512", "cmd5"], "md": ["df", "mb", "mg", "mp", "pd", "ms", "pm", "od", "mand", "mac", "m", "sm", " MD", "d", "sha", "sum", "msg", "MD", " ma", "bd", " digest", "meta", "wd", " sd", "mode", "ad", "M", "dd", "mc", "cd", "mod", "cmd", " dd", "ma", "mag", "nd", " cmd", "pkg", " mm", "dm", "hash", "html", " Md", "amd", "nm", "kg", "dig", "sd", "mm", "metadata", "bf", "mo"]}}
{"id1": "17190057", "id2": "22560224", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"encode": ["unode", "Enescape", "Encode", "unescape", "encescape", "uncode", "Enode", "enccode", "enescape", "enode"], "input": ["reader", "inf", "data", "addin", "audio", "secure", "stream", "string", "array", "str", "hex", "binary", "ssl", "format", "text", "output", "instance", "img", "plus", "password", "address", "temp", "this", "buffer", "xxx", "source", "i", "image", "crypt", "request", "pattern", "form", "context", "config", "raw", "empty", "null", "in", "prefix", "amp", "result", "def", "alpha", "Input"], "NoSuchAlgorithmException": ["NoSuchAlodingError", "NoSuchEdgorithmWarning", "NoSuchEdgorithmException", "NoSuchEdryptionError", "NoSuchAlgoement", "NoSuchAlryptionWarning", "NoSuchAlodingException", "NoSuchAlgorithmement", "NoSuchAlgorithmError", "NoSuchEdgorithmError", "NoSuchAlryptionement", "NoSuchAlodingWarning", "NoSuchAlryptionException", "NoSuchAlgorithmWarning", "NoSuchAlgoWarning", "NoSuchEdgorithmement", "NoSuchAlgoException", "NoSuchEdryptionException", "NoSuchAlgoError", "NoSuchEdryptionement", "NoSuchEdryptionWarning", "NoSuchAlodingement", "NoSuchAlryptionError"], "md": ["meta", "df", "bd", "doc", "mag", "cd", "wd", "mad", "dd", "m", "ma", " MD", "mt", "me", "dig", "mb", "mac", "cmd", "zip", "dm", "key", "um", "dc", "d", "MD", "db", "mo", "mod", "hash", "amd", "mi", "sum", "mp", "code", "metadata", "mm", "pm", "message", "sha", "mc", "ms", "pd", "mand", "ad", "hd", "od", "nm"]}}
{"id1": "18217985", "id2": "20924119", "code1": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 0, "substitutes": {"fromHtml": ["fromShText", "fromBushml", " fromPhtml", "fromHText", "fromPhml", " fromHml", " fromHHTML", "fromPhtml", "fromChUrl", " fromPhHTML", " fromPhttp", " fromHUrl", "fromShhtml", "fromHttptml", "fromChtml", " fromChUrl", "fromHttpText", " fromChhtml", "fromBushtml", "fromHml", "fromHhtml", "fromHttphtml", "fromHttpml", "fromShUrl", "fromPhHTML", "fromHttpHTML", "fromHttpttp", "fromHHTML", "fromHttpUrl", " fromHText", "fromChText", "fromHttp", "fromChhtml", " fromHttp", "fromHUrl", " fromChtml", " fromPhml", "fromBushHTML", "fromPhttp", "fromBushttp", " fromChText", " fromHhtml", "fromShtml"], "url": ["connection", "open", "sl", "f", "loc", "name", "org", "email", "ur", "remote", "web", "download", "str", "xml", "base", "ssl", "html", "blog", "page", "loader", "text", "domain", "article", "l", "r", "client", "address", "Url", "service", "URL", "cli", "image", "source", "ch", "or", "builder", "path", "api", "object", "response", "lr", "config", "uri", "server", "browser", "http", "file", "id", "www", "resource", "input", "host", "link", "ref", "location", "string", "obj", "il"], "defaultEncoding": ["defaultCoder", "defaultCoding", " defaultEncoder", "defaultChasing", "currentEnode", "currentEncoding", "defaultEnode", " defaultencasing", "currentEnasing", "defaultEncoder", "currentEnoding", "defaultEncasing", "defaultEngoding", "defaultEngoded", " defaultencoded", "defaultencoding", "defaultCasing", "defaultEngasing", "currentEnoded", "defaultencasing", "defaultChoding", " defaultEncoded", "defaultEncode", "defaultencoder", "defaultEnoded", "defaultChode", "currentEncoded", "defaultEnoder", "defaultEnasing", " defaultencoder", "defaultEncoded", "currentEncasing", "defaultencode", " defaultCoding", "defaultCoded", " defaultencoding", "defaultChoded", " defaultCasing", "defaultEnoding", "defaultEngoder", "currentEncode", " defaultEncasing", " defaultCoder", "defaultencoded", " defaultCoded"], "overrideEncoding": ["overrideencasing", "overwriteEnasing", "overwriteEnoded", "overwriteEncasing", "overwriteEncoding", "overrideencoder", "overrideCoder", "overrideEnoder", "overrideCoded", "overrideEncasing", "overrideEnoded", "overrideEncoder", "overrideencoded", "overrideencoding", "overrideEncoded", "overwriteEncoder", "overwriteEnoder", "overwriteEncoded", "overrideEnasing", "overrideCasing", "overrideCoding", "overwriteEnoding", "overrideEnoding"], "conn": ["connection", "nt", "open", "cb", "f", "loc", "cn", "reg", "socket", "nc", "session", "ct", "sync", "dn", "enc", "ann", "ssl", "conf", "cmd", "l", "err", "client", "dc", "cli", "ctx", "connect", "ch", "db", "api", "exec", "close", "config", "conv", "n", "server", "http", "c", "Conn", "co", "coll", "con", "out", "sql", "cp", "Connection", "ad", "serv", "act"], "contentType": ["contentLine", "worktype", " contentStyle", "ontentName", "filetype", " contentName", "resourceLength", "languageType", "Contenttype", "documentName", "ontentLength", "ContentFormat", "encLength", " contentUnit", "contenttype", "workToken", " contenttype", " contentPath", "resourceUnit", "codeType", "languageInfo", "documentText", "contentClass", "documentType", "contentFile", "languageStyle", "wordName", "filePath", "languagetype", " contentLine", "resourceName", "codeInfo", " contentFile", " contentInfo", "inputUnit", "codeName", "fileType", " contentText", "inputType", "encType", "ContentUnit", " contentLength", "resourcetype", "contentUnit", " contentFormat", "codeStyle", "ContentFile", "encToken", "ContentPath", " contentClass", "ContentType", "ContentName", "contentInfo", "resourceInfo", "ContentLine", "inputPath", "ontentClass", "ontentType", "contentStyle", "documentInfo", "contentToken", "ContentLength", "ontentPath", "contentText", "wordtype", "ontentFormat", "contentName", "inputtype", "wordType", "workLength", "ContentClass", "enctype", "contentLength", "ContentInfo", " contentToken", "workType", "inputLine", "contentFormat", "codeFile", "fileFile", "codetype", "contentPath", "codeUnit", "ContentText", "resourceType"], "encoding": ["ecoding", "encoded", "encasing", "engasing", " encoder", "coded", "execoded", "Encoding", "execasing", "encode", "execoder", "encapping", "ecoder", "Encaching", "enaching", "execoding", "engoding", "encoder", " encasing", "enoded", "ecasing", "caching", "engapping", "encaching", "enhryption", "casing", "equoder", "encryption", "equoded", "coding", " encosing", "equapping", "coder", "enoding", "Encasing", "Encode", " encapping", "equosing", "encosing", "enasing", "colloder", "equoding", "engoder", " encryption", "ecoded", "colloding", "enoder", "engosing", "enhasing", "enhoding", " encode", "engoded", "Encoded", "enhode", "Encryption", "colloded", "Encoder", "enosing", "collasing"], "i": ["x", "ji", "f", "si", "ti", "ri", "slice", "p", "j", "ori", "pi", "info", "ie", "ix", "is", "hi", "ei", "I", "di", "bi", "u", "multi", "lc", "qi", "l", "fi", "e", "o", "ini", "abi", "cli", "ci", "init", "api", "t", "h", "xi", "v", "yi", "ui", "oi", "mi", "li", "zi", "uri", "io", "ii", "c", "ni", "id", "iu", "mu", "eni", "gi", "ai", "phi", "adi", "area", "ip"], "s": ["sl", "su", "f", "ts", "sg", "si", "ds", "g", "session", "ins", "m", "sync", "p", "ns", "settings", "enc", "str", "en", "os", "ssl", "ls", "u", "abs", "b", "sv", "l", "r", "e", "o", "strings", "d", "service", "S", "source", "ws", "t", "js", "h", "v", "gs", "n", "ps", "details", "c", "as", "a", "sb", "ss", "es", "sym", "string", "fs", "ses", "site"], "expected": ["wrong", "required", "specified", "actual", "current", " expectation", "pretty", "ception", "force", "now", "error", "allowed", "email", "type", "pect", "pecting", "latest", "encrypted", "info", " received", " event", " Expect", "illegal", "event", "received", "supported", "ie", " e", "needed", "format", " email", " expect", " accepted", "forced", "opened", "nexpected", "e", "updated", "found", "style", "pected", "entry", "provided", " ie", "example", "response", "yet", "next", "default", "seen", " expecting", "handled", "acceptable", "ed", " expects", "target", "host", "fake", "failed", " unexpected", "reported", "element"], "index": ["x", "offset", "active", "open", "loc", "current", "point", "version", "where", "edit", "type", "slice", "array", "info", "option", "sort", "ind", "find", "ix", "match", "position", "page", "all", "size", "num", "weight", "output", "shape", "key", "address", "pull", "column", "ini", "list", "condition", "Index", "inc", "value", "connect", "object", "update", "level", "number", "width", "unit", "date", "id", "search", "pos", "prefix", "input", "diff", "length", "none", "alpha", "end", "element"], "msg": ["Msg", "ag", "mr", "gm", "sg", "doc", "name", "reg", "error", "reason", "Message", "g", "MS", "ma", "info", "mt", "printf", "str", "gen", "mit", "ug", "log", "format", "mid", "text", "mess", "cmd", "err", "lang", "dr", "og", "rr", " message", "comm", "fg", "gs", "agg", "details", "title", "message", "ms", "sim", "desc"], "in": ["reader", "bin", "connection", "login", "data", "tin", "inas", "ins", "stream", "p", "In", "xml", "b", "inner", "rin", "win", "din", "r", "IN", "err", "fr", "ax", "dr", "ini", "buffer", "inc", "read", "io", "inn", "c", "as", "id", "impl", "input", "out", "con", "gin", "rx"]}}
{"id1": "23510383", "id2": "5414088", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    public static void saveFileData(File file, File destination, java.io.File newDataFile) throws Exception {\n        String fileName = file.getFileName();\n        String assetsPath = FileFactory.getRealAssetsRootPath();\n        new java.io.File(assetsPath).mkdir();\n        java.io.File workingFile = getAssetIOFile(file);\n        DotResourceCache vc = CacheLocator.getVeloctyResourceCache();\n        vc.remove(ResourceManager.RESOURCE_TEMPLATE + workingFile.getPath());\n        if (destination != null && destination.getInode() > 0) {\n            FileInputStream is = new FileInputStream(workingFile);\n            FileChannel channelFrom = is.getChannel();\n            java.io.File newVersionFile = getAssetIOFile(destination);\n            FileChannel channelTo = new FileOutputStream(newVersionFile).getChannel();\n            channelFrom.transferTo(0, channelFrom.size(), channelTo);\n            channelTo.force(false);\n            channelTo.close();\n            channelFrom.close();\n        }\n        if (newDataFile != null) {\n            FileChannel writeCurrentChannel = new FileOutputStream(workingFile).getChannel();\n            writeCurrentChannel.truncate(0);\n            FileChannel fromChannel = new FileInputStream(newDataFile).getChannel();\n            fromChannel.transferTo(0, fromChannel.size(), writeCurrentChannel);\n            writeCurrentChannel.force(false);\n            writeCurrentChannel.close();\n            fromChannel.close();\n            if (UtilMethods.isImage(fileName)) {\n                BufferedImage img = javax.imageio.ImageIO.read(workingFile);\n                int height = img.getHeight();\n                file.setHeight(height);\n                int width = img.getWidth();\n                file.setWidth(width);\n            }\n            String folderPath = workingFile.getParentFile().getAbsolutePath();\n            Identifier identifier = IdentifierCache.getIdentifierFromIdentifierCache(file);\n            java.io.File directory = new java.io.File(folderPath);\n            java.io.File[] files = directory.listFiles((new FileFactory()).new ThumbnailsFileNamesFilter(identifier));\n            for (java.io.File iofile : files) {\n                try {\n                    iofile.delete();\n                } catch (SecurityException e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + iofile.getName() + \" cannot be erased. Please check the file permissions.\");\n                } catch (Exception e) {\n                    Logger.error(FileFactory.class, \"EditFileAction._saveWorkingFileData(): \" + e.getMessage());\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveProject": ["deleteModel", " saveproject", " saveApplication", "insertApplication", "insertproject", "deleteProject", "insertModel", "deleteproject", "saveModel", "insertProject", " saveModel", "saveproject", "deleteApplication", "saveApplication"], "file": ["log", "FILE", "resource", "image", "ile", "parent", "complete", "connection", "lock", "data", "single", "project", "part", "folder", "model", "document", "zip", "out", "dir", "directory", "filename", "work", "use", "db", "files", "base", "table", "object", "local", "found", "handler", "full", "File", "path", "picture", "plus", "line", "fp"], "types": ["forms", "fields", "pes", "keys", "ions", "archives", "products", "users", "Types", "links", "jobs", "lists", "options", "parts", "shows", "tags", "relations", "cats", "times", "reports", "plugins", "groups", "features", "classes", "photos", "projects", "settings", "thumbnails", "objects", "tools", "properties", "packages", "ports", "files", "resources", "ids", "pages", "eps", "versions", "names", "models", "stores", "packs", "tests", "Images", "ames", "params", "locks", "ts", "blocks", "words", "boxes", "ypes", "services", "uploads", "strings", "opens", "its", "styles"], "images": ["rooms", "image", "modules", "users", "tags", "reports", "assets", "plugins", "features", "videos", "photos", "ips", "thumbnails", "media", "scripts", "png", "files", "versions", "Images", "actions", "views", "blocks", "boxes", "events", "uploads", "services", "styles"], "trajectories": ["trajections", "traveyors", "transcessions", "traventors", "trajectory", "traveyory", "traventory", "tracessions", "traventions", "transjectory", "transcessories", "transcessors", "traventories", "trajectors", "traveyions", "tracessories", "traveyories", "tracessors", "transjectories", "transjectors", "transcessory", "tracessory", "transjections"], "databasesIncluded": ["databasesInsclusive", "databytesInshibited", "databytesInhibited", "databasesOutclusion", "databasesOutcluded", "databasesinhibited", "databasesOutcluding", "daturesInclusive", "daturesIncluded", "daturesInhibited", "databasesInclusive", "databytesIncluding", "daturesInsclusive", "databasesInscluding", "databytesIncluded", "databytesInscluded", "daturesInclusion", "databasesOuthibited", "databasesOutclusive", "databasesInscluded", "databasesINcluding", "databasesInclusion", "daturesInsclusion", "databytesInsclusion", "databasesInshibited", "databasesIncluding", "databasesincluded", "databasesInhibited", "daturesInscluded", "databytesInscluding", "databasesinclusive", "databasesInsclusion", "databytesInclusion", "databasesINcluded", "databasesinclusion", "daturesInshibited", "databasesINclusion", "databasesINhibited"], "onlyLinks": ["justFiles", "allLink", "OnlyFiles", " onlyLink", "withLink", "justLinks", "OnlyLinks", " onlyFiles", "alllinks", "onlyFiles", "withlinks", " onlylinks", "allLinks", "onlylinks", "justLink", "withLinks", "OnlyLink", "onlyLink"], "index": ["page", "default", "length", "offset", "Index", "num", "weight", "inc", "old", "part", "search", "input", "end", "key", "i", "size", "width", "number", "point", "slice", "position", "ind", "id", "address", "match", "found", "string", "initial", "xxx", "pattern", "ini", "x", "value", "tail", "level", "head"], "name": ["NAME", "url", "default", "message", "image", "resource", "large", "connection", "none", "data", "title", "part", "named", "key", "unique", "home", "temp", "memory", "Name", "size", "filename", "vision", "number", "base", "id", "names", "string", "up", "full", "domain", "path", "stage", "ext"], "format": ["at", "prefix", "text", "unit", "struct", "style", "offset", "term", "form", "letter", "init", "data", "scale", "parser", "external", "status", "template", "date", "temp", "config", "header", "filename", "base", "transform", "position", "language", "string", "layout", "handler", "Format", "pattern", "function", "current", "value", "pretty", "feed", "export"], "count": ["Count", "page", "call", "length", "parent", "build", "num", "depth", "weight", "child", "limit", "sum", "error", "code", "process", "base", "found", "cache", "match", "counter", "age", "list", "path", "content", "level", "force"], "version": ["description", "Version", "vert", "default", "image", "server", "master", "database", "data", "project", "journal", "channel", "output", "application", "draft", "python", "download", "ver", "xml", "config", "section", "vision", "header", "dir", "directory", "target", "feature", "versions", "video", "string", "v", "platform", "latest", "environment", "cover", "release", "content", "update", "manager", "VERSION"], "writer": ["wave", "page", "book", "widget", "wr", "write", "letter", "data", "later", "engine", "writing", "parser", "journal", "written", "director", "output", "writ", "document", "creator", "editor", "Writer", "out", "player", "xml", "temp", "builder", "W", "driver", "reader", "war", "riter", "er", "worker", "walker", "former", "handler", "wire", "w", "writers", "wrapper", "word", "buffer", "author", "manager", "export"], "xmlDir": ["databaseDir", "databaseArea", " xmlPath", " xmlDirectory", "xmlPath", "externalDir", "xmlFile", "xmlArea", "xmlDirectory", "externalFile", "externalDirectory", " xmlFile", "jsonDirectory", "imageFile", "jsonArea", "imageDir", "imageFolder", "imageDirectory", "xmlFolder", "externalFolder", " xmlFolder", "databasePath", "databaseDirectory", " xmlArea", "jsonPath", "jsonDir"], "databases": ["structases", "datogs", " datrooms", "variogs", "arrables", "diabases", " datases", "variabytes", "drogs", "datases", "Databases", "structabytes", "Datables", "diogs", "datrooms", "Datases", "notations", "Databytes", "drabytes", "diations", "datations", "notrooms", "arrabases", "Datrooms", "drabases", "Datations", "diabytes", "databytes", "drations", "arrabytes", "notabases", " datations", "arrases", "structables", "variations", "notases", "variabases", "datables", "structabases"], "t": ["m", "att", "e", "task", "j", "n", "none", "tm", "title", "o", "d", "template", "h", "test", "T", "te", "class", "Type", "i", "y", "target", "token", "string", "v", "c", "ts", "w", "ant", "q", "ty", "p", " T"], "type": ["to", "pe", "attribute", "role", "e", "parent", "null", "style", "like", "info", "data", "single", "link", "TYPE", "part", "group", "field", "definition", "model", "result", "rule", "block", "ype", "set", "o", "template", "error", "test", "key", "class", "Type", "comment", "y", "action", "target", "base", "slice", "id", "match", "string", "token", "language", "option", "other", "op", "function", "value", "state", "ty", "collection", "p", "database", "right"], "currentName": [" currentType", "currentFile", "CurrentPath", "reportedKey", "thisMember", " currentTime", "recentMember", "thisAddress", "thisTime", "CurrentFile", "thisType", "recentTime", "currentAddress", "currentStyle", "thisPath", "recentStyle", "CurrentType", "reportedPath", "reportedAddress", "thisName", " currentNames", " currentMember", "recentName", "currentKey", " currentStyle", "CurrentAddress", "CurrentKey", "currentPath", "futureFile", "thisStyle", "futureName", "reportedName", "CurrentNames", "futurePath", " currentKey", "currentTime", "futureNames", "reportedNames", "CurrentName", "currentNames", "currentType", "reportedType", " currentFile", " currentPath", "currentMember"], "baseCopy": ["aseShare", "binaryCop", "binaryCopy", "BaseName", " baseShare", "baseSource", "baseCop", " basecopy", "BaseCop", " baseSource", "baseName", "aseName", " baseCreate", "baseShare", "basiccopy", " baseCop", "asecopy", "BaseSource", "BaseCreate", "BaseCopy", "basicCopy", " baseName", "BaseShare", "basecopy", "Basecopy", "binarycopy", "basicSource", "baseCreate", "basicCreate", "aseCopy"], "source": ["proxy", "text", "component", "unit", "resource", "image", "core", "server", "parent", "dest", "scope", "view", "connection", "remote", "ie", "channel", "Source", "result", "input", "site", "storage", "ources", "clone", "src", "reader", "size", "config", "client", "stream", "target", "slave", "inner", "base", "section", "slice", "object", "cache", "ource", "option", "service", "reference", "SOURCE", "current", "scene", "manager", "use", "from", "rate"], "destination": ["distination", "destignment", "Destribution", "transignment", "constinations", "externalinator", "constination", "combination", "Destation", "destation", "Destignment", "destinations", "distinator", "transinator", "Destinator", "distignment", "combinator", " destment", "combinations", "externalinated", " destinated", "distribution", "destribution", "transribution", " destinator", "destinated", "Destination", "externalination", "transination", "Destment", "destinator", "Destinated", "externalment", "combation", "destment", "Destinations", "constinator", "constation"], "clefs": ["clebs", "CleFS", "Cleflows", "Clef", "CLEflows", "Clebs", " clef", "cleflows", " clebs", "CLEfs", "clef", "CLEf", "CLEbs", "cleFS", "CLEFS", " cleFS", "Clefs", " cleflows"], "st": ["ost", "sth", "std", "statement", "stru", "est", "fr", "ct", "nd", "struct", "ste", "ss", "bt", "sts", "ST", "sb", "inst", "str", "tt", "sn", "set", "rest", "St", "src", "ist", "sc", "cr", "sa", "sm", "start", "rd", "ld", "sl", "ts", "sp", "ast", "mt", "bl", "ust", "sta"], "rs": [" src", "res", "R", " Rs", "rc", " sr", " sq", " params", " matches", "RS", "Rs", " re", " Result", " obj", " rc", " hits", " RS", "RC", " repl", " ans", " ra", "rd", "Res", " rm", " changes", " success"]}}
