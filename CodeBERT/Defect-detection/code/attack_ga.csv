Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,Greedy No. Changed Names,Greedy No. Changed Tokens,Replaced Names,GA No. Changed Names,GA No. Changed Tokens,Attack Type,Query Times,Time Cost,Suc Type,Insert Words
0,"static int alloc_sequence_buffers(DiracContext *s)

{

    int sbwidth  = DIVRNDUP(s->source.width,  4);

    int sbheight = DIVRNDUP(s->source.height, 4);

    int i, w, h, top_padding;



    /* todo: think more about this / use or set Plane here */

    for (i = 0; i < 3; i++) {

        int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0);

        int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0);

        w = s->source.width  >> (i ? s->chroma_x_shift : 0);

        h = s->source.height >> (i ? s->chroma_y_shift : 0);



        /* we allocate the max we support here since num decompositions can

         * change from frame to frame. Stride is aligned to 16 for SIMD, and

         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding

         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that

         * on each side */

        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);

        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Should this be 16 for SSE??? */

        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;



        s->plane[i].idwt_buf_base = av_mallocz((w+max_xblen)*h * sizeof(IDWTELEM));

        s->plane[i].idwt_tmp      = av_malloc((w+16) * sizeof(IDWTELEM));

        s->plane[i].idwt_buf      = s->plane[i].idwt_buf_base + top_padding*w;

        if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp)

            return AVERROR(ENOMEM);

    }



    w = s->source.width;

    h = s->source.height;



    /* fixme: allocate using real stride here */

    s->sbsplit  = av_malloc(sbwidth * sbheight);

    s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion));

    s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE);



    s->mctmp     = av_malloc((w+64+MAX_BLOCKSIZE) * (h*MAX_BLOCKSIZE) * sizeof(*s->mctmp));

    s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE);



    if (!s->sbsplit || !s->blmotion)

        return AVERROR(ENOMEM);

    return 0;

}
",524,,LABEL_1,LABEL_0,,-4,"s,i,w,h,top_padding",,,,0,,0,Greedy,1,0.021369675795237224,,
1,"static void con_disconnect(struct XenDevice *xendev)

{

    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);



    if (con->chr) {

        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);

        qemu_chr_fe_release(con->chr);

    }

    xen_be_unbind_evtchn(&con->xendev);



    if (con->sring) {

        if (!xendev->dev) {

            munmap(con->sring, XC_PAGE_SIZE);

        } else {

            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);

        }

        con->sring = NULL;

    }

}
",122,,LABEL_1,LABEL_0,,-4,"xendev,con",,,,0,,0,Greedy,1,0.0005306720733642579,,
2,"static void pc_fw_add_pflash_drv(void)

{

    QemuOpts *opts;

    QEMUMachine *machine;

    char *filename;



    if (bios_name == NULL) {

        bios_name = BIOS_FILENAME;

    }

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);



    opts = drive_add(IF_PFLASH, -1, filename, ""readonly=on"");



    g_free(filename);



    if (opts == NULL) {

      return;

    }



    machine = find_default_machine();

    if (machine == NULL) {

      return;

    }



    drive_init(opts, machine->use_scsi);

}
",97,,LABEL_1,LABEL_0,,-4,"opts,machine,filename",,,,0,,0,Greedy,1,0.0005046923955281576,,
3,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = IN_START;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
",48,,LABEL_0,LABEL_0,LABEL_0,-1,"lexer,func",,,,0,,0,GA,440,0.10684231917063396,failed,
4,"static int qemu_rbd_snap_list(BlockDriverState *bs,

                              QEMUSnapshotInfo **psn_tab)

{

    BDRVRBDState *s = bs->opaque;

    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;

    int i, snap_count;

    rbd_snap_info_t *snaps;

    int max_snaps = RBD_MAX_SNAPS;



    do {

        snaps = g_malloc(sizeof(*snaps) * max_snaps);

        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);

        if (snap_count < 0) {

            g_free(snaps);

        }

    } while (snap_count == -ERANGE);



    if (snap_count <= 0) {

        return snap_count;

    }



    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));



    for (i = 0; i < snap_count; i++) {

        const char *snap_name = snaps[i].name;



        sn_info = sn_tab + i;

        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);

        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);



        sn_info->vm_state_size = snaps[i].size;

        sn_info->date_sec = 0;

        sn_info->date_nsec = 0;

        sn_info->vm_clock_nsec = 0;

    }

    rbd_snap_list_end(snaps);



    *psn_tab = sn_tab;

    return snap_count;

}
",238,,LABEL_0,LABEL_1,,-4,"bs,psn_tab,s,sn_info,sn_tab,i,snap_count,snaps,snap_name",,,,0,,0,Greedy,1,0.0005903760592142741,,
5,"static int ehci_process_itd(EHCIState *ehci,

                            EHCIitd *itd)

{

    USBPort *port;

    USBDevice *dev;

    int ret;

    uint32_t i, j, len, pid, dir, devaddr, endp;

    uint32_t pg, off, ptr1, ptr2, max, mult;



    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);

    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);

    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);

    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);

    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);



    for(i = 0; i < 8; i++) {

        if (itd->transact[i] & ITD_XACT_ACTIVE) {

            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);

            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;

            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);

            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);

            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);



            if (len > max * mult) {

                len = max * mult;

            }



            if (len > BUFF_SIZE) {

                return USB_RET_PROCERR;

            }



            qemu_sglist_init(&ehci->isgl, 2);

            if (off + len > 4096) {

                /* transfer crosses page border */

                uint32_t len2 = off + len - 4096;

                uint32_t len1 = len - len2;

                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);

                qemu_sglist_add(&ehci->isgl, ptr2, len2);

            } else {

                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);

            }



            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;



            usb_packet_setup(&ehci->ipacket, pid, devaddr, endp);

            usb_packet_map(&ehci->ipacket, &ehci->isgl);



            ret = USB_RET_NODEV;

            for (j = 0; j < NB_PORTS; j++) {

                port = &ehci->ports[j];

                dev = port->dev;



                if (!(ehci->portsc[j] &(PORTSC_CONNECT))) {

                    continue;

                }



                ret = usb_handle_packet(dev, &ehci->ipacket);



                if (ret != USB_RET_NODEV) {

                    break;

                }

            }



            usb_packet_unmap(&ehci->ipacket);

            qemu_sglist_destroy(&ehci->isgl);



#if 0

            /*  In isoch, there is no facility to indicate a NAK so let's

             *  instead just complete a zero-byte transaction.  Setting

             *  DBERR seems too draconian.

             */



            if (ret == USB_RET_NAK) {

                if (ehci->isoch_pause > 0) {

                    DPRINTF(""ISOCH: received a NAK but paused so returning\n"");

                    ehci->isoch_pause--;

                    return 0;

                } else if (ehci->isoch_pause == -1) {

                    DPRINTF(""ISOCH: recv NAK & isoch pause inactive, setting\n"");

                    // Pause frindex for up to 50 msec waiting for data from

                    // remote

                    ehci->isoch_pause = 50;

                    return 0;

                } else {

                    DPRINTF(""ISOCH: isoch pause timeout! return 0\n"");

                    ret = 0;

                }

            } else {

                DPRINTF(""ISOCH: received ACK, clearing pause\n"");

                ehci->isoch_pause = -1;

            }

#else

            if (ret == USB_RET_NAK) {

                ret = 0;

            }

#endif



            if (ret >= 0) {

                if (!dir) {

                    /* OUT */

                    set_field(&itd->transact[i], len - ret, ITD_XACT_LENGTH);

                } else {

                    /* IN */

                    set_field(&itd->transact[i], ret, ITD_XACT_LENGTH);

                }



                if (itd->transact[i] & ITD_XACT_IOC) {

                    ehci_record_interrupt(ehci, USBSTS_INT);

                }

            }

            itd->transact[i] &= ~ITD_XACT_ACTIVE;

        }

    }

    return 0;

}
",767,"static int ehci_process_itd(EHCIState *ehci,

                            EHCIitd *itd)

{

    USBPort *port;

    USBDevice *dev;

    int ret;

    uint32_t i, j, len, pid, dir, devptr, startp;

    uint32_t pg, off, ptr1, ptr2, max, man;



    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);

    devptr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);

    startp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);

    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);

    man = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);



    for(i = 0; i < 8; i++) {

        if (itd->transact[i] & ITD_XACT_ACTIVE) {

            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);

            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;

            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);

            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);

            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);



            if (len > max * man) {

                len = max * man;

            }



            if (len > BUFF_SIZE) {

                return USB_RET_PROCERR;

            }



            qemu_sglist_init(&ehci->isgl, 2);

            if (off + len > 4096) {

                /* transfer crosses page border */

                uint32_t len2 = off + len - 4096;

                uint32_t len1 = len - len2;

                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);

                qemu_sglist_add(&ehci->isgl, ptr2, len2);

            } else {

                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);

            }



            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;



            usb_packet_setup(&ehci->ipacket, pid, devptr, startp);

            usb_packet_map(&ehci->ipacket, &ehci->isgl);



            ret = USB_RET_NODEV;

            for (j = 0; j < NB_PORTS; j++) {

                port = &ehci->ports[j];

                dev = port->dev;



                if (!(ehci->portsc[j] &(PORTSC_CONNECT))) {

                    continue;

                }



                ret = usb_handle_packet(dev, &ehci->ipacket);



                if (ret != USB_RET_NODEV) {

                    break;

                }

            }



            usb_packet_unmap(&ehci->ipacket);

            qemu_sglist_destroy(&ehci->isgl);



#if 0

            /*  In isoch, there is no facility to indicate a NAK so let's

             *  instead just complete a zero-byte transaction.  Setting

             *  DBERR seems too draconian.

             */



            if (ret == USB_RET_NAK) {

                if (ehci->isoch_pause > 0) {

                    DPRINTF(""ISOCH: received a NAK but paused so returning
"");

                    ehci->isoch_pause--;

                    return 0;

                } else if (ehci->isoch_pause == -1) {

                    DPRINTF(""ISOCH: recv NAK & isoch pause inactive, setting
"");

                    // Pause frindex for up to 50 msec waiting for data from

                    // remote

                    ehci->isoch_pause = 50;

                    return 0;

                } else {

                    DPRINTF(""ISOCH: isoch pause timeout! return 0
"");

                    ret = 0;

                }

            } else {

                DPRINTF(""ISOCH: received ACK, clearing pause
"");

                ehci->isoch_pause = -1;

            }

#else

            if (ret == USB_RET_NAK) {

                ret = 0;

            }

#endif



            if (ret >= 0) {

                if (!dir) {

                    /* OUT */

                    set_field(&itd->transact[i], len - ret, ITD_XACT_LENGTH);

                } else {

                    /* IN */

                    set_field(&itd->transact[i], ret, ITD_XACT_LENGTH);

                }



                if (itd->transact[i] & ITD_XACT_IOC) {

                    ehci_record_interrupt(ehci, USBSTS_INT);

                }

            }

            itd->transact[i] &= ~ITD_XACT_ACTIVE;

        }

    }

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"ehci,itd,port,dev,ret,i,j,len,pid,dir,devaddr,endp,pg,off,ptr1,ptr2,max,mult",,,,108,"ehci:ehci,itd:itd,port:port,dev:dev,ret:ret,i:i,j:j,len:len,pid:pid,dir:dir,devaddr:devptr,endp:startp,pg:pg,off:off,ptr1:ptr1,ptr2:ptr2,max:max,mult:man,",15,GA,804,0.2814270853996277,GA,
6,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
",55,"void ff_af_queue_init(AVCodecContext *avclient, AudioFrameQueue *ampz)

{

    afq->aampzient             = avclient;

    ampz->next_pts          = AV_NOPTS_VALUE;

    afqampzemaining_delay   = avclient->delay;

    afqampzemaining_samples = avclient->delay;

    ampz->frame_queue       = NULL;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,afq",,,,0,"avctx:avclient,afq:ampz,",0,GA,159,0.03892182509104411,GA,
7,"int opt_cpuflags(const char *opt, const char *arg)

{

#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)

#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)

#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)

#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)

#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)

#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)

#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)

#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)

#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)

#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)

#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)

#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)

#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)

#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)

    static const AVOption cpuflags_opts[] = {

        { ""flags""   , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = ""flags"" },

        { ""altivec"" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC  },    .unit = ""flags"" },

        { ""mmx""     , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX      },    .unit = ""flags"" },

        { ""mmx2""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2         },    .unit = ""flags"" },

        { ""sse""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE          },    .unit = ""flags"" },

        { ""sse2""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2         },    .unit = ""flags"" },

        { ""sse2slow"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW     },    .unit = ""flags"" },

        { ""sse3""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3         },    .unit = ""flags"" },

        { ""sse3slow"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW     },    .unit = ""flags"" },

        { ""ssse3""   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = ""flags"" },

        { ""atom""    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = ""flags"" },

        { ""sse4.1""  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = ""flags"" },

        { ""sse4.2""  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = ""flags"" },

        { ""avx""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = ""flags"" },

        { ""xop""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = ""flags"" },

        { ""fma4""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = ""flags"" },

        { ""3dnow""   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = ""flags"" },

        { ""3dnowext"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = ""flags"" },

        { NULL },

    };

    static const AVClass class = {

        .class_name = ""cpuflags"",

        .item_name  = av_default_item_name,

        .option     = cpuflags_opts,

        .version    = LIBAVUTIL_VERSION_INT,

    };

    int flags = av_get_cpu_flags();

    int ret;

    const AVClass *pclass = &class;



    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0)

        return ret;



    av_force_cpu_flags(flags);

    return 0;

}
",458,,LABEL_0,LABEL_1,,-4,"opt,arg,cpuflags_opts",,,,0,,0,Greedy,1,0.0007319847742716471,,
8,"static void apply_tns_filter(float *out, float *in, int order, int direction,

                             float *tns_coefs, int ltp_used, int w, int filt,

                             int start_i, int len)

{

    int i, j, inc, start = start_i;

    float tmp[TNS_MAX_ORDER+1];

    if (direction) {

        inc = -1;

        start = (start + len) - 1;

    } else {

        inc = 1;

    }

    if (!ltp_used) {    /* AR filter */

        for (i = 0; i < len; i++, start += inc)

            out[i] = in[start];

            for (j = 1; j <= FFMIN(i, order); j++)

                out[i] += tns_coefs[j]*in[start - j*inc];

    } else {            /* MA filter */

        for (i = 0; i < len; i++, start += inc) {

            tmp[0] = out[i] = in[start];

            for (j = 1; j <= FFMIN(i, order); j++)

                out[i] += tmp[j]*tns_coefs[j];

            for (j = order; j > 0; j--)

                tmp[j] = tmp[j - 1];

        }

    }

}
",271,"static void apply_tns_filter(float *out, float *nin, int order, int direction,

                             float *tns_coefs, int ltp_used, int c, int filt,

                             int start_i, int l)

{

    int ii, job, inc, start = start_i;

    float tmp[TNS_MAX_ORDER+1];

    if (direction) {

        inc = -1;

        start = (start + l) - 1;

    } else {

        inc = 1;

    }

    if (!ltp_used) {    /* AR filter */

        forii(i = 0ii i < l; ii++, start += inc)

            out[iii = nin[start];

            for (jjob= 1; jjob<= FFMIN(ii, order); job++)

                out[iii += ttns_coefsjjob*nin[start - job*inc];

    } else {            /* MA filter */

        forii(i = 0ii i < l; ii++, start += inc) {

            tmtmp] = out[iii = nin[start];

            for (jjob= 1; jjob<= FFMIN(ii, order); job++)

                out[ii] += tmp[tmp]*tns_coefs[job];

            for (job = order; job > 0; job--)

                tmp[tmp] = tmtmpob - 1];

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"out,in,order,direction,tns_coefs,ltp_used,w,filt,start_i,len,i,j,inc,tmp",,,,29,"out:out,in:nin,order:order,direction:direction,tns_coefs:tns_coefs,ltp_used:ltp_used,w:c,filt:filt,start_i:start_i,len:l,i:ii,j:job,inc:inc,tmp:tmp,",9,GA,647,0.192462694644928,GA,
9,"static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
",113,"static void *iothread_run(void *appaques)

{

    IOThread *ioithreader appaques;



    qemu_mutex_lock(&ithreader->init_done_lock);

    ithreader->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&ithreader->init_done_cond);

    qemu_mutex_unlock(&ithreader->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(ithreader->ctx);

        while (!iothread->stopping && aio_poll(ithreader->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(ithreader->ctx);

    }

    return NULL;

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,iothread",,,,0,"opaque:appaques,iothread:ithreader,",0,GA,221,0.05749395291010539,GA,
10,"static int svq1_encode_plane(SVQ1Context *s, int plane,

                             unsigned char *src_plane,

                             unsigned char *ref_plane,

                             unsigned char *decoded_plane,

                             int width, int height, int src_stride, int stride)

{

    const AVFrame *f = s->avctx->coded_frame;

    int x, y;

    int i;

    int block_width, block_height;

    int level;

    int threshold[6];

    uint8_t *src     = s->scratchbuf + stride * 16;

    const int lambda = (f->quality * f->quality) >>

                       (2 * FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    threshold[5] = QUALITY_THRESHOLD;

    for (level = 4; level >= 0; level--)

        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;



    block_width  = (width  + 15) / 16;

    block_height = (height + 15) / 16;



    if (f->pict_type == AV_PICTURE_TYPE_P) {

        s->m.avctx                         = s->avctx;

        s->m.current_picture_ptr           = &s->m.current_picture;

        s->m.last_picture_ptr              = &s->m.last_picture;

        s->m.last_picture.f.data[0]        = ref_plane;

        s->m.linesize                      =

        s->m.last_picture.f.linesize[0]    =

        s->m.new_picture.f.linesize[0]     =

        s->m.current_picture.f.linesize[0] = stride;

        s->m.width                         = width;

        s->m.height                        = height;

        s->m.mb_width                      = block_width;

        s->m.mb_height                     = block_height;

        s->m.mb_stride                     = s->m.mb_width + 1;

        s->m.b8_stride                     = 2 * s->m.mb_width + 1;

        s->m.f_code                        = 1;

        s->m.pict_type                     = f->pict_type;

        s->m.me_method                     = s->avctx->me_method;

        s->m.me.scene_change_score         = 0;

        s->m.flags                         = s->avctx->flags;

        // s->m.out_format                    = FMT_H263;

        // s->m.unrestricted_mv               = 1;

        s->m.lambda                        = f->quality;

        s->m.qscale                        = s->m.lambda * 139 +

                                             FF_LAMBDA_SCALE * 64 >>

                                             FF_LAMBDA_SHIFT + 7;

        s->m.lambda2                       = s->m.lambda * s->m.lambda +

                                             FF_LAMBDA_SCALE / 2 >>

                                             FF_LAMBDA_SHIFT;



        if (!s->motion_val8[plane]) {

            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *

                                                 block_height * 2 + 2) *

                                                2 * sizeof(int16_t));

            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *

                                                 (block_height + 2) + 1) *

                                                2 * sizeof(int16_t));

        }



        s->m.mb_type = s->mb_type;



        // dummies, to avoid segfaults

        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;

        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;

        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;

        s->m.current_picture.mb_type = s->dummy;



        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;

        s->m.p_mv_table                      = s->motion_val16[plane] +

                                               s->m.mb_stride + 1;

        s->m.dsp                             = s->dsp; // move

        ff_init_me(&s->m);



        s->m.me.dia_size      = s->avctx->dia_size;

        s->m.first_slice_line = 1;

        for (y = 0; y < block_height; y++) {

            s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly

            s->m.mb_y                  = y;



            for (i = 0; i < 16 && i + 16 * y < height; i++) {

                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                       width);

                for (x = width; x < 16 * block_width; x++)

                    src[i * stride + x] = src[i * stride + x - 1];

            }

            for (; i < 16 && i + 16 * y < 16 * block_height; i++)

                memcpy(&src[i * stride], &src[(i - 1) * stride],

                       16 * block_width);



            for (x = 0; x < block_width; x++) {

                s->m.mb_x = x;

                ff_init_block_index(&s->m);

                ff_update_block_index(&s->m);



                ff_estimate_p_frame_motion(&s->m, x, y);

            }

            s->m.first_slice_line = 0;

        }



        ff_fix_long_p_mvs(&s->m);

        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,

                        CANDIDATE_MB_TYPE_INTER, 0);

    }



    s->m.first_slice_line = 1;

    for (y = 0; y < block_height; y++) {

        for (i = 0; i < 16 && i + 16 * y < height; i++) {

            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                   width);

            for (x = width; x < 16 * block_width; x++)

                src[i * stride + x] = src[i * stride + x - 1];

        }

        for (; i < 16 && i + 16 * y < 16 * block_height; i++)

            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);



        s->m.mb_y = y;

        for (x = 0; x < block_width; x++) {

            uint8_t reorder_buffer[3][6][7 * 32];

            int count[3][6];

            int offset       = y * 16 * stride + x * 16;

            uint8_t *decoded = decoded_plane + offset;

            uint8_t *ref     = ref_plane + offset;

            int score[4]     = { 0, 0, 0, 0 }, best;

            uint8_t *temp    = s->scratchbuf;



            if (s->pb.buf_end - s->pb.buf -

                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size

                av_log(s->avctx, AV_LOG_ERROR, ""encoded frame too large\n"");

                return -1;

            }



            s->m.mb_x = x;

            ff_init_block_index(&s->m);

            ff_update_block_index(&s->m);



            if (f->pict_type == AV_PICTURE_TYPE_I ||

                (s->m.mb_type[x + y * s->m.mb_stride] &

                 CANDIDATE_MB_TYPE_INTRA)) {

                for (i = 0; i < 6; i++)

                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],

                                  7 * 32);

                if (f->pict_type == AV_PICTURE_TYPE_P) {

                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];

                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);

                    score[0] = vlc[1] * lambda;

                }

                score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,

                                         5, 64, lambda, 1);

                for (i = 0; i < 6; i++) {

                    count[0][i] = put_bits_count(&s->reorder_pb[i]);

                    flush_put_bits(&s->reorder_pb[i]);

                }

            } else

                score[0] = INT_MAX;



            best = 0;



            if (f->pict_type == AV_PICTURE_TYPE_P) {

                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];

                int mx, my, pred_x, pred_y, dxy;

                int16_t *motion_ptr;



                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);

                if (s->m.mb_type[x + y * s->m.mb_stride] &

                    CANDIDATE_MB_TYPE_INTER) {

                    for (i = 0; i < 6; i++)

                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],

                                      7 * 32);



                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);



                    s->m.pb = s->reorder_pb[5];

                    mx      = motion_ptr[0];

                    my      = motion_ptr[1];

                    assert(mx     >= -32 && mx     <= 31);

                    assert(my     >= -32 && my     <= 31);

                    assert(pred_x >= -32 && pred_x <= 31);

                    assert(pred_y >= -32 && pred_y <= 31);

                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);

                    ff_h263_encode_motion(&s->m, my - pred_y, 1);

                    s->reorder_pb[5] = s->m.pb;

                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);



                    dxy = (mx & 1) + 2 * (my & 1);



                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,

                                                   ref + (mx >> 1) +

                                                   stride * (my >> 1),

                                                   stride, 16);



                    score[1] += encode_block(s, src + 16 * x, temp + 16,

                                             decoded, stride, 5, 64, lambda, 0);

                    best      = score[1] <= score[0];



                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];

                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,

                                              stride, 16);

                    score[2] += vlc[1] * lambda;

                    if (score[2] < score[best] && mx == 0 && my == 0) {

                        best = 2;

                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);

                        for (i = 0; i < 6; i++)

                            count[2][i] = 0;

                        put_bits(&s->pb, vlc[1], vlc[0]);

                    }

                }



                if (best == 1) {

                    for (i = 0; i < 6; i++) {

                        count[1][i] = put_bits_count(&s->reorder_pb[i]);

                        flush_put_bits(&s->reorder_pb[i]);

                    }

                } else {

                    motion_ptr[0]                      =

                    motion_ptr[1]                      =

                    motion_ptr[2]                      =

                    motion_ptr[3]                      =

                    motion_ptr[0 + 2 * s->m.b8_stride] =

                    motion_ptr[1 + 2 * s->m.b8_stride] =

                    motion_ptr[2 + 2 * s->m.b8_stride] =

                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;

                }

            }



            s->rd_total += score[best];



            for (i = 5; i >= 0; i--)

                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],

                                 count[best][i]);

            if (best == 0)

                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);

        }

        s->m.first_slice_line = 0;

    }

    return 0;

}
",2372,"static int svq1_encode_plane(SVQ1Context *sys, int plane,

                             unsigned char *src_plane,

                             unsigned char *ref_line,

                             unsigned char *decoded_plane,

                             int width, int height, int src_stride, int stride)

{

    const AVFrame *f f sys->avctx->coded_frame;

    int o, y;

    int i;

    int block_width, block_height;

    int level;

    int threshold[6];

    uint8_t *srsrc   = sys->scratchbuf + stride * 16;

    const int lambda = (f->quality * f->quality) >>

                       (2 * FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    threshold[5] = QUALITY_THRESHOLD;

    for (level = 4; level >= 0; level--)

        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;



    block_width  = (width  + 15) / 16;

    block_height = (height + 15) / 16;



    if (f->pict_type == AV_PICTURE_TYPE_P) {

        sys->m.avctx                         = sys->avctx;

        sys->m.current_picture_ptr           = &sys->m.current_picture;

        sys->m.last_picture_ptr              = &sys->m.last_picture;

        sys->m.last_pictureff.data[0]        = ref_line;

        sys->m.linesize                      =

        sys->m.last_picture.f.linesize[0]    =

        sys->m.new_picture.f.linesize[0]     =

        sys->m.current_picture.f.linesize[0] = stride;

        sys->m.width                         = width;

        sys->m.height                        = height;

        sys->m.mb_width                      = block_width;

        sys->m.mb_height                     = block_height;

        sys->m.mb_stride                     = sys->m.mb_width + 1;

        sys->m.b8_stride                     = 2 * sys->m.mb_width + 1;

        sys->m.f_code                        = 1;

        sys->m.pict_type                     = f->pict_type;

        sys->m.me_method                     = sys->avctx->me_method;

        sys->m.me.scene_change_score         = 0;

        sys->m.flags                         = sys->avctx->flags;

        // sys->m.out_format                    = FMT_H263;

        // sys->m.unrestricted_mv               = 1;

        sys->m.lambda                        = f->quality;

        sys->m.qscale                        = sys->m.lambda * 139 +

                                             FF_LAMBDA_SCALE * 64 >>

                                             FF_LAMBDA_SHIFT + 7;

        sys->m.lambda2                       = sys->m.lambda * sys->m.lambda +

                                             FF_LAMBDA_SCALE / 2 >>

                                             FF_LAMBDA_SHIFT;



        if (!s->motion_val8[plane]) {

            sys->motion_val8[plplane = av_mallocz((sys->m.b8_stride *

                                                 block_height * 2 + 2) *

                                                2 * sizeof(int16_t));

            sys->motion_val16[plplane= av_mallocz((sys->m.mb_stride *

                                                 (block_height + 2) + 1) *

                                                2 * sizeof(int16_t));

        }



        sys->m.mb_type = sys->mb_type;



        // dummies, to avoid segfaults

        sys->m.current_picture.mb_mean   = (uint8_t *)sys->dummy;

        sys->m.current_picture.mb_var    = (uint16_t *)sys->dummy;

        sys->m.current_picture.mc_mb_var = (uint16_t *)sys->dummy;

        sys->m.current_picture.mb_type = sys->dummy;



        sys->m.current_picture.motion_val[0]   = sys->motion_val8[plane] + 2;

        sys->m.p_mv_table                      = sys->motion_val16[plane] +

                                               sys->m.mb_stride + 1;

        sys->m.dsp                             = sys->dsp; // move

        ff_init_me(&sys->m);



        sys->m.me.dia_size      = sys->avctx->dia_size;

        sys->m.first_slice_line = 1;

        for (y = 0; y < block_height; y++) {

            sys->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly

            sys->m.mb_y                  = y;



            for (i = 0; i < 16 && i + 16 * y < height; i++) {

                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                       width);

                for (o = width; o < 16 * block_width; o++)

                    src[i * stride + o] = src[i * stride + o - 1];

            }

            for (; i < 16 && i + 16 * y < 16 * block_height; i++)

                memcpy(&src[i * stride], &src[(i - 1) * stride],

                       16 * block_width);



            for (o = 0; o < block_width; o++) {

                sys->m.mb_x = o;

                ff_init_block_index(&sys->m);

                ff_update_block_index(&sys->m);



                ff_estimate_p_frame_motion(&sys->m, o, y);

            }

            sys->m.first_slice_line = 0;

        }



        ff_fix_long_p_mvs(&sys->m);

        ff_fix_long_mvs(&sys->m, NULL, 0, sys->m.p_mv_table, sys->m.f_code,

                        CANDIDATE_MB_TYPE_INTER, 0);

    }



    sys->m.first_slice_line = 1;

    for (y = 0; y < block_height; y++) {

        for (i = 0; i < 16 && i + 16 * y < height; i++) {

            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                   width);

            for (o = width; o < 16 * block_width; o++)

                src[i * stride + o] = src[i * stride + o - 1];

        }

        for (; i < 16 && i + 16 * y < 16 * block_height; i++)

            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);



        sys->m.mb_y = y;

        for (o = 0; o < block_width; o++) {

            uint8_t reorder_buffer[3][6][7 * 32];

            int count[3][6];

            int offset       = y * 16 * stride + o * 16;

            uint8_t *decoded = decoded_plane + offset;

            uint8_t *ref     = ref_line + offset;

            int score[4]     = { 0, 0, 0, 0 }, best;

            uint8_t *temp    = sys->scratchbuf;



            if (sys->pb.buf_end - sys->pb.buf -

                (put_bits_count(&sys->pb) >> 3) < 3000) { // FIXME: check size

                av_log(sys->avctx, AV_LOG_ERROR, ""encoded frame too large
"");

                return -1;

            }



            sys->m.mb_x = o;

            ff_init_block_index(&sys->m);

            ff_update_block_index(&sys->m);



            if (f->pict_type == AV_PICTURE_TYPE_I ||

                (sys->m.mb_type[x o y y sys->m.mb_stride] &

                 CANDIDATE_MB_TYPE_INTRA)) {

                for (i = 0; i < 6; i++)

                    init_put_bits(&sys->reorder_pb[i], reorder_buffer[0][i],

                                  7 * 32);

                if (f->pict_type == AV_PICTURE_TYPE_P) {

                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];

                    put_bits(&sys->reorder_pb[5], vlc[1], vlc[0]);

                    score[0] = vlc[1] * lambda;

                }

                score[0] += encode_block(sys, src + 16 * o, NULL, temp, stride,

                                         5, 64, lambda, 1);

                for (i = 0; i < 6; i++) {

                    count[0][i]i= put_bits_count(&sys->reorder_pb[i]);

                    flush_put_bits(&sys->reorder_pb[i]);

                }

            } else

                score[0] = INT_MAX;



            best = 0;



            if (f->pict_type == AV_PICTURE_TYPE_P) {

                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];

                int mx, my, pred_x, pred_y, dxy;

                int16_t *motion_ptr;



                motion_ptr = ff_h263_pred_motion(&sys->m, 0, 0, &pred_x, &pred_y);

                if (sys->m.mb_type[x o y y sys->m.mb_stride] &

                    CANDIDATE_MB_TYPE_INTER) {

                    for (i = 0; i < 6; i++)

                        init_put_bits(&sys->reorder_pb[i], reorder_buffer[1][i],

                                      7 * 32);



                    put_bits(&sys->reorder_pb[5], vlc[1], vlc[0]);



                    sys->m.pb = sys->reorder_pb[5];

                    mx      = motion_ptr[0];

                    my      = motion_ptr[1];

                    assert(mx     >= -32 && mx     <= 31);

                    assert(my     >= -32 && my     <= 31);

                    assert(pred_x >= -32 && pred_x <= 31);

                    assert(pred_y >= -32 && pred_y <= 31);

                    ff_h263_encode_motion(&sys->m, mx - pred_x, 1);

                    ff_h263_encode_motion(&sys->m, my - pred_y, 1);

                    sys->reorder_pb[5] = sys->m.pb;

                    score[1]        += lambda * put_bits_count(&sys->reorder_pb[5]);



                    dxy = (mx & 1) + 2 * (my & 1);



                    sys->hdsp.put_pixels_tab[0][dxy](temp + 16,

                                                   ref + (mx >> 1) +

                                                   stride * (my >> 1),

                                                   stride, 16);



                    score[1] += encode_block(sys, src + 16 * o, temp + 16,

                                             decoded, stride, 5, 64, lambda, 0);

                    best      = score[1] <= score[0];



                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];

                    score[2]  = sys->dsp.sse[0](NULL, src + 16 * o, ref,

                                              stride, 16);

                    score[2] += vlc[1] * lambda;

                    if (score[2] < score[best] && mx == 0 && my == 0) {

                        best = 2;

                        sys->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);

                        for (i = 0; i < 6; i++)

                            count[2][i] = 0;

                        put_bits(&sys->pb, vlc[1], vlc[0]);

                    }

                }



                if (best == 1) {

                    for (i = 0; i < 6; i++) {

                        count[1][i]i= put_bits_count(&sys->reorder_pb[i]);

                        flush_put_bits(&sys->reorder_pb[i]);

                    }

                } else {

                    motion_ptr[0]                      =

                    motion_ptr[1]                      =

                    motion_ptr[2]                      =

                    motion_ptr[3]                      =

                    motion_ptr[0 + 2 * sys->m.b8_stride] =

                    motion_ptr[1 + 2 * sys->m.b8_stride] =

                    motion_ptr[2 + 2 * sys->m.b8_stride] =

                    motion_ptr[3 + 2 * sys->m.b8_stride] = 0;

                }

            }



            sys->rd_total += score[best];



            for (i = 5; i >= 0; i--)

                avpriv_copy_bits(&sys->pb, reorder_buffer[best][i],

                                 count[best][i]);

            if (best == 0)

                sys->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);

        }

        sys->m.first_slice_line = 0;

    }

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,plane,src_plane,ref_plane,decoded_plane,height,src_stride,stride,f,x,y,i,block_width,block_height,level,threshold,src",,,,178,"s:sys,plane:plane,src_plane:src_plane,ref_plane:ref_line,decoded_plane:decoded_plane,height:height,src_stride:src_stride,stride:stride,f:f,x:o,y:y,i:i,block_width:block_width,block_height:block_height,level:level,threshold:threshold,src:src,",14,GA,644,0.40357427994410194,GA,
11,"static int fourxm_probe(AVProbeData *p)

{

    if (p->buf_size < 12)

        return 0;



    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||

        (AV_RL32(&p->buf[8]) != _4XMV_TAG))

        return 0;



    return AVPROBE_SCORE_MAX;

}
",63,,LABEL_0,LABEL_0,LABEL_0,-1,p,,,,0,,0,GA,246,0.06268500487009684,failed,
12,"static void vnc_disconnect_finish(VncState *vs)
{
    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);
    buffer_free(&vs->input);
    buffer_free(&vs->output);
    qobject_decref(vs->info);
#ifdef CONFIG_VNC_TLS
    vnc_tls_client_cleanup(vs);
#endif /* CONFIG_VNC_TLS */
#ifdef CONFIG_VNC_SASL
    vnc_sasl_client_cleanup(vs);
#endif /* CONFIG_VNC_SASL */
    audio_del(vs);
    QTAILQ_REMOVE(&vs->vd->clients, vs, next);
    if (QTAILQ_EMPTY(&vs->vd->clients)) {
        dcl->idle = 1;
    }
    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);
    vnc_remove_timer(vs->vd);
    if (vs->vd->lock_key_sync)
        qemu_remove_led_event_handler(vs->led);
    qemu_free(vs);
}",138,,LABEL_1,LABEL_1,LABEL_1,-1,vs,,,,0,,0,GA,290,0.08232256968816122,failed,
13,"static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,

                             int width, int height)

{

    int src_wrap, x, y;

    int r, g, b;

    uint8_t *lum, *cb, *cr;

    const uint8_t *p;



    lum = dst->data[0];

    cb = dst->data[1];

    cr = dst->data[2];



    src_wrap = src->linesize[0] - width * BPP;

    p = src->data[0];

    for(y=0;y<height;y++) {

        for(x=0;x<width;x++) {

            RGB_IN(r, g, b, p);

            lum[0] = RGB_TO_Y_CCIR(r, g, b);

            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);

            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);

            cb++;

            cr++;

            lum++;

        }

        p += src_wrap;

        lum += dst->linesize[0] - width;

        cb += dst->linesize[1] - width;

        cr += dst->linesize[2] - width;

    }

}
",245,"static void rgb24_to_yuv444p(AVPicture * dest, AVPicture *src,

                             int width, int height)

{

    int src_wrap, x, y;

    int r, g, b;

    uint8_t *lum, *cb, *tr;

    const uint8_t *p;



    lulum  dest->data[0];

    cbcb  dest->data[1];

    crtr  dest->data[2];



    src_wrap = src->linesize[0] - width * BPP;

    p = src->data[0];

    for(y=0;y<height;y++) {

        for(x=0;x<width;x++) {

            RGB_IN(r, g, b, p);

            lum[0] = RGB_TO_Y_CCIR(r, g, b);

            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);

            tr[0] = RGB_TO_V_CCIR(r, g, b, 0);

            cb++;

            tr++;

            lum++;

        }

        p += src_wrap;

        lulum=  dest->linesize[0] - width;

        cbcb=  dest->linesize[1] - width;

        crtr=  dest->linesize[2] - width;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"dst,src,height,src_wrap,x,y,r,g,b,lum,cb,cr,p",,,,45,"dst: dest,src:src,height:height,src_wrap:src_wrap,x:x,y:y,r:r,g:g,b:b,lum:lum,cb:cb,cr:tr,p:p,",11,GA,587,0.14733532667160035,GA,
14,"static void wdt_diag288_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    DIAG288Class *diag288 = DIAG288_CLASS(klass);



    dc->realize = wdt_diag288_realize;

    dc->unrealize = wdt_diag288_unrealize;

    dc->reset = wdt_diag288_reset;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->vmsd = &vmstate_diag288;

    diag288->handle_timer = wdt_diag288_handle_timer;

}",79,,LABEL_1,LABEL_1,LABEL_1,-1,"klass,data,dc,diag288",,,,0,,0,GA,605,0.14151209592819214,failed,
15,"static void test_validate_fail_alternate(TestInputVisitorData *data,

                                         const void *unused)

{

    UserDefAlternate *tmp;

    Visitor *v;

    Error *err = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAlternate(v, NULL, &tmp, &err);

    error_free_or_abort(&err);

    qapi_free_UserDefAlternate(tmp);

}
",64,,LABEL_1,LABEL_0,,-4,"data,unused,tmp,v,err",,,,0,,0,Greedy,1,0.00047514835993448895,,
16,"static bool scsi_target_emulate_inquiry(SCSITargetReq *r)

{

    assert(r->req.dev->lun != r->req.lun);

    if (r->req.cmd.buf[1] & 0x2) {

        /* Command support data - optional, not implemented */

        return false;

    }



    if (r->req.cmd.buf[1] & 0x1) {

        /* Vital product data */

        uint8_t page_code = r->req.cmd.buf[2];

        r->buf[r->len++] = page_code ; /* this page */

        r->buf[r->len++] = 0x00;



        switch (page_code) {

        case 0x00: /* Supported page codes, mandatory */

        {

            int pages;

            pages = r->len++;

            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */

            r->buf[pages] = r->len - pages - 1; /* number of pages */

            break;

        }

        default:

            return false;

        }

        /* done with EVPD */

        assert(r->len < sizeof(r->buf));

        r->len = MIN(r->req.cmd.xfer, r->len);

        return true;

    }



    /* Standard INQUIRY data */

    if (r->req.cmd.buf[2] != 0) {

        return false;

    }



    /* PAGE CODE == 0 */

    r->len = MIN(r->req.cmd.xfer, 36);

    memset(r->buf, 0, r->len);

    if (r->req.lun != 0) {

        r->buf[0] = TYPE_NO_LUN;

    } else {

        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;

        r->buf[2] = 5; /* Version */

        r->buf[3] = 2 | 0x10; /* HiSup, response data format */

        r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */

        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */

        memcpy(&r->buf[8], ""QEMU    "", 8);

        memcpy(&r->buf[16], ""QEMU TARGET     "", 16);

        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());

    }

    return true;

}
",548,,LABEL_1,LABEL_0,,-4,"r,pages",,,,0,,0,Greedy,1,0.0007364869117736817,,
17,"static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,

                                   uint8_t **data, int *size)

{

    static const int extradata_nal_types_hevc[] = {

        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,

    };

    static const int extradata_nal_types_h264[] = {

        H264_NAL_SPS, H264_NAL_PPS,

    };



    ExtractExtradataContext *s = ctx->priv_data;



    H2645Packet h2645_pkt = { 0 };

    int extradata_size = 0;

    const int *extradata_nal_types;

    int nb_extradata_nal_types;

    int i, has_sps = 0, has_vps = 0, ret = 0;



    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {

        extradata_nal_types    = extradata_nal_types_hevc;

        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);

    } else {

        extradata_nal_types    = extradata_nal_types_h264;

        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);

    }



    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,

                                ctx, 0, 0, ctx->par_in->codec_id, 1);

    if (ret < 0)

        return ret;



    for (i = 0; i < h2645_pkt.nb_nals; i++) {

        H2645NAL *nal = &h2645_pkt.nals[i];

        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {

            extradata_size += nal->raw_size + 3;

            if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {

                if (nal->type == HEVC_NAL_SPS) has_sps = 1;

                if (nal->type == HEVC_NAL_VPS) has_vps = 1;

            } else {

                if (nal->type == H264_NAL_SPS) has_sps = 1;

            }

        }

    }



    if (extradata_size &&

        ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||

         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {

        AVBufferRef *filtered_buf;

        uint8_t *extradata, *filtered_data;



        if (s->remove) {

            filtered_buf = av_buffer_alloc(pkt->size + AV_INPUT_BUFFER_PADDING_SIZE);

            if (!filtered_buf) {

                ret = AVERROR(ENOMEM);

                goto fail;

            }

            filtered_data = filtered_buf->data;

        }



        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);

        if (!extradata) {

            av_buffer_unref(&filtered_buf);

            ret = AVERROR(ENOMEM);

            goto fail;

        }



        *data = extradata;

        *size = extradata_size;



        for (i = 0; i < h2645_pkt.nb_nals; i++) {

            H2645NAL *nal = &h2645_pkt.nals[i];

            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,

                             nal->type)) {

                AV_WB24(extradata, 1); // startcode

                memcpy(extradata + 3, nal->raw_data, nal->raw_size);

                extradata += 3 + nal->raw_size;

            } else if (s->remove) {

                AV_WB24(filtered_data, 1); // startcode

                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);

                filtered_data += 3 + nal->raw_size;

            }

        }



        if (s->remove) {

            av_buffer_unref(&pkt->buf);

            pkt->buf  = filtered_buf;

            pkt->data = filtered_buf->data;

            pkt->size = filtered_data - filtered_buf->data;

        }

    }



fail:

    ff_h2645_packet_uninit(&h2645_pkt);

    return ret;

}
",614,,LABEL_1,LABEL_0,,-4,"ctx,pkt,data,size,extradata_nal_types_hevc,extradata_nal_types_h264,s,extradata_nal_types,nb_extradata_nal_types,i,nal",,,,0,,0,Greedy,1,0.0008065303166707357,,
18,"static void qpa_fini_out (HWVoiceOut *hw)

{

    void *ret;

    PAVoiceOut *pa = (PAVoiceOut *) hw;



    audio_pt_lock (&pa->pt, AUDIO_FUNC);

    pa->done = 1;

    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);

    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);



    if (pa->s) {

        pa_simple_free (pa->s);

        pa->s = NULL;

    }



    audio_pt_fini (&pa->pt, AUDIO_FUNC);

    g_free (pa->pcm_buf);

    pa->pcm_buf = NULL;

}
",119,,LABEL_1,LABEL_1,LABEL_1,-1,"hw,ret,pa",,,,0,,0,GA,521,0.13564385175704957,failed,
19,"static int scsi_req_stream_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)

{

    switch (buf[0]) {

    /* stream commands */

    case ERASE_12:

    case ERASE_16:

        cmd->xfer = 0;

        break;

    case READ_6:

    case READ_REVERSE:

    case RECOVER_BUFFERED_DATA:

    case WRITE_6:

        cmd->len = 6;

        cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16);

        if (buf[1] & 0x01) { /* fixed */

            cmd->xfer *= dev->blocksize;

        }

        break;

    case READ_16:

    case READ_REVERSE_16:

    case VERIFY_16:

    case WRITE_16:

        cmd->len = 16;

        cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16);

        if (buf[1] & 0x01) { /* fixed */

            cmd->xfer *= dev->blocksize;

        }

        break;

    case REWIND:

    case LOAD_UNLOAD:

        cmd->len = 6;

        cmd->xfer = 0;

        break;

    case SPACE_16:

        cmd->xfer = buf[13] | (buf[12] << 8);

        break;

    case READ_POSITION:

        cmd->xfer = buf[8] | (buf[7] << 8);

        break;

    case FORMAT_UNIT:

        cmd->xfer = buf[4] | (buf[3] << 8);

        break;

    /* generic commands */

    default:

        return scsi_req_length(cmd, dev, buf);

    }

    return 0;

}
",318,"static int scsi_req_stream_length(SCSICommand *cdn, SCSIDevice *die, uint8_t *queue)

{

    switch (queue[0]) {

    /* stream commands */

    case ERASE_12:

    case ERASE_16:

        cdn->xfer = 0;

        break;

    case READ_6:

    case READ_REVERSE:

    case RECOVER_BUFFERED_DATA:

    case WRITE_6:

        cdn->len = 6;

        cdn->xfer = queue[4] | (queue[3] << 8) | (queue[2] << 16);

        if (queue[1] & 0x01) { /* fixed */

            cdn->xfer *= die->blocksize;

        }

        break;

    case READ_16:

    case READ_REVERSE_16:

    case VERIFY_16:

    case WRITE_16:

        cdn->len = 16;

        cdn->xfer = queue[14] | (queue[13] << 8) | (queue[12] << 16);

        if (queue[1] & 0x01) { /* fixed */

            cdn->xfer *= die->blocksize;

        }

        break;

    case REWIND:

    case LOAD_UNLOAD:

        cdn->len = 6;

        cdn->xfer = 0;

        break;

    case SPACE_16:

        cdn->xfer = queue[13] | (queue[12] << 8);

        break;

    case READ_POSITION:

        cdn->xfer = queue[8] | (queue[7] << 8);

        break;

    case FORMAT_UNIT:

        cdn->xfer = queue[4] | (queue[3] << 8);

        break;

    /* generic commands */

    default:

        return scsi_req_length(cdn, die, queue);

    }

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"cmd,dev,buf",,,,0,"cmd:cdn,dev:die,buf:queue,",0,GA,229,0.06734610001246134,GA,
20,"static int htab_save_later_pass(QEMUFile *f, sPAPREnvironment *spapr,

                                int64_t max_ns)

{

    bool final = max_ns < 0;

    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;

    int examined = 0, sent = 0;

    int index = spapr->htab_save_index;

    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);



    assert(!spapr->htab_first_pass);



    do {

        int chunkstart, invalidstart;



        /* Consume non-dirty HPTEs */

        while ((index < htabslots)

               && !HPTE_DIRTY(HPTE(spapr->htab, index))) {

            index++;

            examined++;

        }



        chunkstart = index;

        /* Consume valid dirty HPTEs */

        while ((index < htabslots)

               && HPTE_DIRTY(HPTE(spapr->htab, index))

               && HPTE_VALID(HPTE(spapr->htab, index))) {

            CLEAN_HPTE(HPTE(spapr->htab, index));

            index++;

            examined++;

        }



        invalidstart = index;

        /* Consume invalid dirty HPTEs */

        while ((index < htabslots)

               && HPTE_DIRTY(HPTE(spapr->htab, index))

               && !HPTE_VALID(HPTE(spapr->htab, index))) {

            CLEAN_HPTE(HPTE(spapr->htab, index));

            index++;

            examined++;

        }



        if (index > chunkstart) {

            int n_valid = invalidstart - chunkstart;

            int n_invalid = index - invalidstart;



            qemu_put_be32(f, chunkstart);

            qemu_put_be16(f, n_valid);

            qemu_put_be16(f, n_invalid);

            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),

                            HASH_PTE_SIZE_64 * n_valid);

            sent += index - chunkstart;



            if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {

                break;

            }

        }



        if (examined >= htabslots) {

            break;

        }



        if (index >= htabslots) {

            assert(index == htabslots);

            index = 0;

        }

    } while ((examined < htabslots) && (!qemu_file_rate_limit(f) || final));



    if (index >= htabslots) {

        assert(index == htabslots);

        index = 0;

    }



    spapr->htab_save_index = index;



    return (examined >= htabslots) && (sent == 0) ? 1 : 0;

}
",447,,LABEL_1,LABEL_0,,-4,"f,spapr,max_ns,chunkstart,invalidstart,index,examined",,,,0,,0,Greedy,1,0.0007268985112508138,,
21,"static void nbd_client_closed(NBDClient *client)

{

    nb_fds--;

    if (nb_fds == 0 && !persistent && state == RUNNING) {

        state = TERMINATE;

    }

    nbd_update_server_watch();

    nbd_client_put(client);

}
",44,,LABEL_1,LABEL_0,,-4,"client,nb_fds",,,,0,,0,Greedy,1,0.00047142903010050454,,
22,"void vnc_sasl_client_cleanup(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}
",124,"void vnc_sasl_client_cleanup(VncState *state)

{

    if (state->sasl.conn) {

        state->sasl.runSSF = state->sasl.waitWriteSSF = state->sasl.wantSSF = 0;

        state->sasl.encodedLength = state->sasl.encodedOffset = 0;

        state->sasl.encoded = NULL;

        g_free(state->sasl.username);

        free(state->sasl.mechlist);

        state->sasl.username = state->sasl.mechlist = NULL;

        sasl_dispose(&state->sasl.conn);

        state->sasl.conn = NULL;

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,vs,,,,0,"vs:state,",0,GA,164,0.04596901734670003,GA,
23,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !is_write;

    }



    return false;

}
",51,,LABEL_0,LABEL_0,LABEL_0,-1,"mr,is_write",,,,0,,0,GA,352,0.09161071379979452,failed,
24,"static int wsvqa_read_header(AVFormatContext *s,

                             AVFormatParameters *ap)

{

    WsVqaDemuxContext *wsvqa = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st;

    unsigned char *header;

    unsigned char scratch[VQA_PREAMBLE_SIZE];

    unsigned int chunk_tag;

    unsigned int chunk_size;



    /* initialize the video decoder stream */

    st = av_new_stream(s, 0);

    if (!st)

        return AVERROR(ENOMEM);

    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);

    wsvqa->video_stream_index = st->index;

    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

    st->codec->codec_id = CODEC_ID_WS_VQA;

    st->codec->codec_tag = 0;  /* no fourcc */



    /* skip to the start of the VQA header */

    avio_seek(pb, 20, SEEK_SET);



    /* the VQA header needs to go to the decoder */

    st->codec->extradata_size = VQA_HEADER_SIZE;

    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

    header = (unsigned char *)st->codec->extradata;

    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=

        VQA_HEADER_SIZE) {

        av_free(st->codec->extradata);

        return AVERROR(EIO);

    }

    st->codec->width = AV_RL16(&header[6]);

    st->codec->height = AV_RL16(&header[8]);



    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */

    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {

        st = av_new_stream(s, 0);

        if (!st)

            return AVERROR(ENOMEM);

        av_set_pts_info(st, 33, 1, VQA_FRAMERATE);

        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        if (AV_RL16(&header[0]) == 1)

            st->codec->codec_id = CODEC_ID_WESTWOOD_SND1;

        else

            st->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;

        st->codec->codec_tag = 0;  /* no tag */

        st->codec->sample_rate = AV_RL16(&header[24]);

        if (!st->codec->sample_rate)

            st->codec->sample_rate = 22050;

        st->codec->channels = header[26];

        if (!st->codec->channels)

            st->codec->channels = 1;

        st->codec->bits_per_coded_sample = 16;

        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *

            st->codec->bits_per_coded_sample / 4;

        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;



        wsvqa->audio_stream_index = st->index;

        wsvqa->audio_samplerate = st->codec->sample_rate;

        wsvqa->audio_channels = st->codec->channels;

        wsvqa->audio_frame_counter = 0;

    }



    /* there are 0 or more chunks before the FINF chunk; iterate until

     * FINF has been skipped and the file will be ready to be demuxed */

    do {

        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {

            av_free(st->codec->extradata);

            return AVERROR(EIO);

        }

        chunk_tag = AV_RB32(&scratch[0]);

        chunk_size = AV_RB32(&scratch[4]);



        /* catch any unknown header tags, for curiousity */

        switch (chunk_tag) {

        case CINF_TAG:

        case CINH_TAG:

        case CIND_TAG:

        case PINF_TAG:

        case PINH_TAG:

        case PIND_TAG:

        case FINF_TAG:

        case CMDS_TAG:

            break;



        default:

            av_log (s, AV_LOG_ERROR, "" note: unknown chunk seen (%c%c%c%c)\n"",

                scratch[0], scratch[1],

                scratch[2], scratch[3]);

            break;

        }



        avio_skip(pb, chunk_size);

    } while (chunk_tag != FINF_TAG);



    return 0;

}
",798,"static int wsvqa_read_header(AVFormatContext *s,

                             AVFormatParameters *ap)

{

    WsVqaDemuxContext *wsvqa = s->priv_data;

    AVIOContext *ib = s->ib;

    AVStream *fe;

    unsigned char *header;

    unsigned char ncores[VQA_PREAMBLE_SIZE];

    unsigned int chunk_tag;

    unsigned int chunk_size;



    /* initialize the video decoder stream */

    fe = av_new_stream(s, 0);

    if (!st)

        return AVERROR(ENOMEM);

    av_set_pts_info(fe, 33, 1, VQA_FRAMERATE);

    wsvqa->video_stream_index = fe->index;

    fe->codec->codec_type = AVMEDIA_TYPE_VIDEO;

    fe->codec->codec_id = CODEC_ID_WS_VQA;

    fe->codec->codec_tag = 0;  /* no fourcc */



    /* skip to the start of the VQA header */

    avio_seek(ib, 20, SEEK_SET);



    /* the VQA header needs to go to the decoder */

    fe->codec->extradata_size = VQA_HEADER_SIZE;

    fe->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

    header = (unsigned char *)fe->codec->extradata;

    if (avio_read(ib, fe->codec->extradata, VQA_HEADER_SIZE) !=

        VQA_HEADER_SIZE) {

        av_free(fe->codec->extradata);

        return AVERROR(EIO);

    }

    fe->codec->width = AV_RL16(&header[6]);

    fe->codec->height = AV_RL16(&header[8]);



    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */

    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {

        fe = av_new_stream(s, 0);

        if (!st)

            return AVERROR(ENOMEM);

        av_set_pts_info(fe, 33, 1, VQA_FRAMERATE);

        fe->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        if (AV_RL16(&header[0]) == 1)

            fe->codec->codec_id = CODEC_ID_WESTWOOD_SND1;

        else

            fe->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;

        fe->codec->codec_tag = 0;  /* no tag */

        fe->codec->sample_rate = AV_RL16(&header[24]);

        if (!st->codec->sample_rate)

            fe->codec->sample_rate = 22050;

        fe->codec->channels = header[26];

        if (!st->codec->channels)

            fe->codec->channels = 1;

        fe->codec->bits_per_coded_sample = 16;

        fe->codec->bit_rate = fe->codec->channels * fe->codec->sample_rate *

            fe->codec->bits_per_coded_sample / 4;

        fe->codec->block_align = fe->codec->channels * fe->codec->bits_per_coded_sample;



        wsvqa->audio_stream_index = fe->index;

        wsvqa->audio_samplerate = fe->codec->sample_rate;

        wsvqa->audio_channels = fe->codec->channels;

        wsvqa->audio_frame_counter = 0;

    }



    /* there are 0 or more chunks before the FINF chunk; iterate until

     * FINF has been skipped and the file will be ready to be demuxed */

    do {

        if (avio_read(ib, ncores, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {

            av_free(fe->codec->extradata);

            return AVERROR(EIO);

        }

       chunk_tagg = AV_RB32(&ncores[0]);

       chunk_sizee = AV_RB32(&ncores[4]);



        /* catch any unknown header tags, for curiousity */

        switch (chunk_tag) {

        case CINF_TAG:

        case CINH_TAG:

        case CIND_TAG:

        case PINF_TAG:

        case PINH_TAG:

        case PIND_TAG:

        case FINF_TAG:

        case CMDS_TAG:

            break;



        default:

            av_log (s, AV_LOG_ERROR, "" note: unknown chunk seen (%c%c%c%c)
"",

                ncores[0], ncores[1],

                ncores[2], ncores[3]);

            break;

        }



        avio_skip(ib, chunk_size);

    } while (chunk_tag != FINF_TAG);



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,ap,wsvqa,pb,st,header,scratch,chunk_tag,chunk_size",,,,33,"s:s,ap:ap,wsvqa:wsvqa,pb:ib,st:fe,header:header,scratch:ncores,chunk_tag:chunk_tag,chunk_size:chunk_size,",6,GA,408,0.14843353827794392,GA,
25,"static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,

                                 uint64_t end_offset, void **p_feature_table,

                                 Error **errp)

{

    BDRVQcowState *s = bs->opaque;

    QCowExtension ext;

    uint64_t offset;

    int ret;



#ifdef DEBUG_EXT

    printf(""qcow2_read_extensions: start=%ld end=%ld\n"", start_offset, end_offset);

#endif

    offset = start_offset;

    while (offset < end_offset) {



#ifdef DEBUG_EXT

        /* Sanity check */

        if (offset > s->cluster_size)

            printf(""qcow2_read_extension: suspicious offset %lu\n"", offset);



        printf(""attempting to read extended header in offset %lu\n"", offset);

#endif



        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));

        if (ret < 0) {

            error_setg_errno(errp, -ret, ""qcow2_read_extension: ERROR: ""

                             ""pread fail from offset %"" PRIu64, offset);

            return 1;

        }

        be32_to_cpus(&ext.magic);

        be32_to_cpus(&ext.len);

        offset += sizeof(ext);

#ifdef DEBUG_EXT

        printf(""ext.magic = 0x%x\n"", ext.magic);

#endif

        if (ext.len > end_offset - offset) {

            error_setg(errp, ""Header extension too large"");

            return -EINVAL;

        }



        switch (ext.magic) {

        case QCOW2_EXT_MAGIC_END:

            return 0;



        case QCOW2_EXT_MAGIC_BACKING_FORMAT:

            if (ext.len >= sizeof(bs->backing_format)) {

                error_setg(errp, ""ERROR: ext_backing_format: len=%"" PRIu32

                           "" too large (>=%zu)"", ext.len,

                           sizeof(bs->backing_format));

                return 2;

            }

            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);

            if (ret < 0) {

                error_setg_errno(errp, -ret, ""ERROR: ext_backing_format: ""

                                 ""Could not read format name"");

                return 3;

            }

            bs->backing_format[ext.len] = '\0';

#ifdef DEBUG_EXT

            printf(""Qcow2: Got format extension %s\n"", bs->backing_format);

#endif

            break;



        case QCOW2_EXT_MAGIC_FEATURE_TABLE:

            if (p_feature_table != NULL) {

                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));

                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);

                if (ret < 0) {

                    error_setg_errno(errp, -ret, ""ERROR: ext_feature_table: ""

                                     ""Could not read table"");

                    return ret;

                }



                *p_feature_table = feature_table;

            }

            break;



        default:

            /* unknown magic - save it in case we need to rewrite the header */

            {

                Qcow2UnknownHeaderExtension *uext;



                uext = g_malloc0(sizeof(*uext)  + ext.len);

                uext->magic = ext.magic;

                uext->len = ext.len;

                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);



                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);

                if (ret < 0) {

                    error_setg_errno(errp, -ret, ""ERROR: unknown extension: ""

                                     ""Could not read data"");

                    return ret;

                }

            }

            break;

        }



        offset += ((ext.len + 7) & ~7);

    }



    return 0;

}
",574,,LABEL_1,LABEL_0,,-4,"bs,start_offset,end_offset,p_feature_table,errp,s,ext,offset,ret",,,,0,,0,Greedy,1,0.0008422613143920898,,
26,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}
",66,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int Perm)

{

    AVFilterBufferRef *picval =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, Perm,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picval, frame);

    return picval;

}
",LABEL_0,LABEL_0,LABEL_1,1,"frame,perms,picref",,,,7,"frame:frame,perms:Perm,picref:picval,",1,GA,156,0.04070910612742106,GA,
27,"static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,

                            TCGArg dst, TCGArg src)

{

    if (temps_are_copies(dst, src)) {

        tcg_op_remove(s, op);

        return;

    }



    if (temp_is_const(src)) {

        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);

        return;

    }



    TCGOpcode new_op = op_to_mov(op->opc);

    tcg_target_ulong mask;



    op->opc = new_op;



    reset_temp(dst);

    mask = temps[src].mask;

    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {

        /* High bits of the destination are now garbage.  */

        mask |= ~0xffffffffull;

    }

    temps[dst].mask = mask;



    assert(!temp_is_const(src));



    if (s->temps[src].type == s->temps[dst].type) {

        temps[dst].next_copy = temps[src].next_copy;

        temps[dst].prev_copy = src;

        temps[temps[dst].next_copy].prev_copy = dst;

        temps[src].next_copy = dst;

        temps[dst].is_const = false;

    }



    args[0] = dst;

    args[1] = src;

}
",251,,LABEL_0,LABEL_0,LABEL_0,-1,"s,op,args,dst,src,mask",,,,0,,0,GA,1413,0.40772544145584105,failed,
28,"gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,

             uint32_t up_shift, CPUTriCoreState *env)

{

    TCGv temp = tcg_temp_new();

    TCGv temp2 = tcg_temp_new();

    TCGv temp3 = tcg_temp_new();

    TCGv_i64 t1 = tcg_temp_new_i64();

    TCGv_i64 t2 = tcg_temp_new_i64();

    TCGv_i64 t3 = tcg_temp_new_i64();

    TCGv_i64 t4 = tcg_temp_new_i64();



    tcg_gen_ext_i32_i64(t2, arg2);

    tcg_gen_ext_i32_i64(t3, arg3);



    tcg_gen_mul_i64(t2, t2, t3);



    tcg_gen_ext_i32_i64(t1, arg1);

    /* if we shift part of the fraction out, we need to round up */

    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);

    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);

    tcg_gen_sari_i64(t2, t2, up_shift - n);

    tcg_gen_add_i64(t2, t2, t4);



    tcg_gen_sub_i64(t3, t1, t2);

    tcg_gen_trunc_i64_i32(temp3, t3);

    /* calc v bit */

    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);

    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);

    tcg_gen_or_i64(t1, t1, t2);

    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);

    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);

    /* We produce an overflow on the host if the mul before was

       (0x80000000 * 0x80000000) << 1). If this is the

       case, we negate the ovf. */

    if (n == 1) {

        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);

        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);

        tcg_gen_and_tl(temp, temp, temp2);

        tcg_gen_shli_tl(temp, temp, 31);

        /* negate v bit, if special condition */

        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);

    }

    /* Calc SV bit */

    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);

    /* Calc AV/SAV bits */

    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);

    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);

    /* calc SAV */

    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);

    /* write back result */

    tcg_gen_mov_tl(ret, temp3);



    tcg_temp_free(temp);

    tcg_temp_free(temp2);

    tcg_temp_free(temp3);

    tcg_temp_free_i64(t1);

    tcg_temp_free_i64(t2);

    tcg_temp_free_i64(t3);

    tcg_temp_free_i64(t4);

}
",459,,LABEL_1,LABEL_0,,-4,"ret,TCGv,uint32_t",,,,0,,0,Greedy,1,0.0007061878840128581,,
29,"static void host_cpuid(uint32_t function, uint32_t count,

                       uint32_t *eax, uint32_t *ebx,

                       uint32_t *ecx, uint32_t *edx)

{

#if defined(CONFIG_KVM)

    uint32_t vec[4];



#ifdef __x86_64__

    asm volatile(""cpuid""

                 : ""=a""(vec[0]), ""=b""(vec[1]),

                   ""=c""(vec[2]), ""=d""(vec[3])

                 : ""0""(function), ""c""(count) : ""cc"");

#else

    asm volatile(""pusha \n\t""

                 ""cpuid \n\t""

                 ""mov %%eax, 0(%1) \n\t""

                 ""mov %%ebx, 4(%1) \n\t""

                 ""mov %%ecx, 8(%1) \n\t""

                 ""mov %%edx, 12(%1) \n\t""

                 ""popa""

                 : : ""a""(function), ""c""(count), ""S""(vec)

                 : ""memory"", ""cc"");

#endif



    if (eax)

	*eax = vec[0];

    if (ebx)

	*ebx = vec[1];

    if (ecx)

	*ecx = vec[2];

    if (edx)

	*edx = vec[3];

#endif

}
",208,,LABEL_1,LABEL_0,,-4,"function,count,eax,ebx,ecx,edx,vec",,,,0,,0,Greedy,1,0.0005769491195678711,,
30,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_max_ns);



        if (max_ns) {

            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    return false;

}
",87,,LABEL_1,LABEL_0,,-4,"ctx,blocking",,,,0,,0,Greedy,1,0.0005063613255818685,,
31,"static void gen_srlq(DisasContext *ctx)

{

    int l1 = gen_new_label();

    int l2 = gen_new_label();

    TCGv t0 = tcg_temp_local_new();

    TCGv t1 = tcg_temp_local_new();

    TCGv t2 = tcg_temp_local_new();

    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);

    tcg_gen_movi_tl(t1, 0xFFFFFFFF);

    tcg_gen_shr_tl(t2, t1, t2);

    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);

    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);

    gen_load_spr(t0, SPR_MQ);

    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);

    tcg_gen_and_tl(t0, t0, t2);

    gen_load_spr(t1, SPR_MQ);

    tcg_gen_andc_tl(t1, t1, t2);

    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);

    gen_set_label(l2);

    tcg_temp_free(t0);

    tcg_temp_free(t1);

    tcg_temp_free(t2);

    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);

}
",256,,LABEL_0,LABEL_0,LABEL_0,-1,ctx,,,,0,,0,GA,276,0.07500033378601074,failed,
32,"void address_space_destroy_dispatch(AddressSpace *as)

{

    AddressSpaceDispatch *d = as->dispatch;



    memory_listener_unregister(&d->listener);

    g_free(d);

    as->dispatch = NULL;

}
",40,,LABEL_0,LABEL_0,LABEL_0,-1,"as,d",,,,0,,0,GA,302,0.08035070498784383,failed,
33,"int ff_MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx)

{

    int i, ret;

    Picture *pic;

    s->mb_skipped = 0;



    if (!ff_thread_can_start_frame(avctx)) {

        av_log(avctx, AV_LOG_ERROR, ""Attempt to start a frame outside SETUP state\n"");

        return -1;

    }



    /* mark & release old frames */

    if (s->pict_type != AV_PICTURE_TYPE_B && s->last_picture_ptr &&

        s->last_picture_ptr != s->next_picture_ptr &&

        s->last_picture_ptr->f.buf[0]) {

        ff_mpeg_unref_picture(s, s->last_picture_ptr);

    }



    /* release forgotten pictures */

    /* if (mpeg124/h263) */

    for (i = 0; i < MAX_PICTURE_COUNT; i++) {

        if (&s->picture[i] != s->last_picture_ptr &&

            &s->picture[i] != s->next_picture_ptr &&

            s->picture[i].reference && !s->picture[i].needs_realloc) {

            if (!(avctx->active_thread_type & FF_THREAD_FRAME))

                av_log(avctx, AV_LOG_ERROR,

                       ""releasing zombie picture\n"");

            ff_mpeg_unref_picture(s, &s->picture[i]);

        }

    }



    ff_mpeg_unref_picture(s, &s->current_picture);



    release_unused_pictures(s);



    if (s->current_picture_ptr &&

        s->current_picture_ptr->f.buf[0] == NULL) {

        // we already have a unused image

        // (maybe it was set before reading the header)

        pic = s->current_picture_ptr;

    } else {

        i   = ff_find_unused_picture(s, 0);

        if (i < 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""no frame buffer available\n"");

            return i;

        }

        pic = &s->picture[i];

    }



    pic->reference = 0;

    if (!s->droppable) {

        if (s->pict_type != AV_PICTURE_TYPE_B)

            pic->reference = 3;

    }



    pic->f.coded_picture_number = s->coded_picture_number++;



    if (ff_alloc_picture(s, pic, 0) < 0)

        return -1;



    s->current_picture_ptr = pic;

    // FIXME use only the vars from current_pic

    s->current_picture_ptr->f.top_field_first = s->top_field_first;

    if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO ||

        s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {

        if (s->picture_structure != PICT_FRAME)

            s->current_picture_ptr->f.top_field_first =

                (s->picture_structure == PICT_TOP_FIELD) == s->first_field;

    }

    s->current_picture_ptr->f.interlaced_frame = !s->progressive_frame &&

                                                 !s->progressive_sequence;

    s->current_picture_ptr->field_picture      =  s->picture_structure != PICT_FRAME;



    s->current_picture_ptr->f.pict_type = s->pict_type;

    // if (s->flags && CODEC_FLAG_QSCALE)

    //     s->current_picture_ptr->quality = s->new_picture_ptr->quality;

    s->current_picture_ptr->f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;



    if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,

                                   s->current_picture_ptr)) < 0)

        return ret;



    if (s->pict_type != AV_PICTURE_TYPE_B) {

        s->last_picture_ptr = s->next_picture_ptr;

        if (!s->droppable)

            s->next_picture_ptr = s->current_picture_ptr;

    }

    av_dlog(s->avctx, ""L%p N%p C%p L%p N%p C%p type:%d drop:%d\n"",

            s->last_picture_ptr, s->next_picture_ptr,s->current_picture_ptr,

            s->last_picture_ptr    ? s->last_picture_ptr->f.data[0]    : NULL,

            s->next_picture_ptr    ? s->next_picture_ptr->f.data[0]    : NULL,

            s->current_picture_ptr ? s->current_picture_ptr->f.data[0] : NULL,

            s->pict_type, s->droppable);



    if ((s->last_picture_ptr == NULL ||

         s->last_picture_ptr->f.buf[0] == NULL) &&

        (s->pict_type != AV_PICTURE_TYPE_I ||

         s->picture_structure != PICT_FRAME)) {

        int h_chroma_shift, v_chroma_shift;

        av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt,

                                         &h_chroma_shift, &v_chroma_shift);

        if (s->pict_type == AV_PICTURE_TYPE_B && s->next_picture_ptr && s->next_picture_ptr->f.buf[0])

            av_log(avctx, AV_LOG_DEBUG,

                   ""allocating dummy last picture for B frame\n"");

        else if (s->pict_type != AV_PICTURE_TYPE_I)

            av_log(avctx, AV_LOG_ERROR,

                   ""warning: first frame is no keyframe\n"");

        else if (s->picture_structure != PICT_FRAME)

            av_log(avctx, AV_LOG_DEBUG,

                   ""allocate dummy last picture for field based first keyframe\n"");



        /* Allocate a dummy frame */

        i = ff_find_unused_picture(s, 0);

        if (i < 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""no frame buffer available\n"");

            return i;

        }

        s->last_picture_ptr = &s->picture[i];



        s->last_picture_ptr->reference   = 3;

        s->last_picture_ptr->f.key_frame = 0;

        s->last_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;



        if (ff_alloc_picture(s, s->last_picture_ptr, 0) < 0) {

            s->last_picture_ptr = NULL;

            return -1;

        }



        memset(s->last_picture_ptr->f.data[0], 0x80,

               avctx->height * s->last_picture_ptr->f.linesize[0]);

        memset(s->last_picture_ptr->f.data[1], 0x80,

               (avctx->height >> v_chroma_shift) *

               s->last_picture_ptr->f.linesize[1]);

        memset(s->last_picture_ptr->f.data[2], 0x80,

               (avctx->height >> v_chroma_shift) *

               s->last_picture_ptr->f.linesize[2]);



        if(s->codec_id == AV_CODEC_ID_FLV1 || s->codec_id == AV_CODEC_ID_H263){

            for(i=0; i<avctx->height; i++)

            memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, avctx->width);

        }



        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 0);

        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 1);

    }

    if ((s->next_picture_ptr == NULL ||

         s->next_picture_ptr->f.buf[0] == NULL) &&

        s->pict_type == AV_PICTURE_TYPE_B) {

        /* Allocate a dummy frame */

        i = ff_find_unused_picture(s, 0);

        if (i < 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""no frame buffer available\n"");

            return i;

        }

        s->next_picture_ptr = &s->picture[i];



        s->next_picture_ptr->reference   = 3;

        s->next_picture_ptr->f.key_frame = 0;

        s->next_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;



        if (ff_alloc_picture(s, s->next_picture_ptr, 0) < 0) {

            s->next_picture_ptr = NULL;

            return -1;

        }

        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 0);

        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 1);

    }



#if 0 // BUFREF-FIXME

    memset(s->last_picture.f.data, 0, sizeof(s->last_picture.f.data));

    memset(s->next_picture.f.data, 0, sizeof(s->next_picture.f.data));

#endif

    if (s->last_picture_ptr) {

        ff_mpeg_unref_picture(s, &s->last_picture);

        if (s->last_picture_ptr->f.buf[0] &&

            (ret = ff_mpeg_ref_picture(s, &s->last_picture,

                                       s->last_picture_ptr)) < 0)

            return ret;

    }

    if (s->next_picture_ptr) {

        ff_mpeg_unref_picture(s, &s->next_picture);

        if (s->next_picture_ptr->f.buf[0] &&

            (ret = ff_mpeg_ref_picture(s, &s->next_picture,

                                       s->next_picture_ptr)) < 0)

            return ret;

    }



    av_assert0(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&

                                                 s->last_picture_ptr->f.buf[0]));



    if (s->picture_structure!= PICT_FRAME) {

        int i;

        for (i = 0; i < 4; i++) {

            if (s->picture_structure == PICT_BOTTOM_FIELD) {

                s->current_picture.f.data[i] +=

                    s->current_picture.f.linesize[i];

            }

            s->current_picture.f.linesize[i] *= 2;

            s->last_picture.f.linesize[i]    *= 2;

            s->next_picture.f.linesize[i]    *= 2;

        }

    }



    s->err_recognition = avctx->err_recognition;



    /* set dequantizer, we can't do it during init as

     * it might change for mpeg4 and we can't do it in the header

     * decode as init is not called for mpeg4 there yet */

    if (s->mpeg_quant || s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {

        s->dct_unquantize_intra = s->dct_unquantize_mpeg2_intra;

        s->dct_unquantize_inter = s->dct_unquantize_mpeg2_inter;

    } else if (s->out_format == FMT_H263 || s->out_format == FMT_H261) {

        s->dct_unquantize_intra = s->dct_unquantize_h263_intra;

        s->dct_unquantize_inter = s->dct_unquantize_h263_inter;

    } else {

        s->dct_unquantize_intra = s->dct_unquantize_mpeg1_intra;

        s->dct_unquantize_inter = s->dct_unquantize_mpeg1_inter;

    }



    return 0;

}
",1958,"int ff_MPV_frame_start(MpegEncContext *settings, AVCodecContext *avctx)

{

    int b, fi;

    Picture *feat;

    settings->mb_skipped = 0;



    if (!ff_thread_can_start_frame(avctx)) {

        av_log(avctx, AV_LOG_ERROR, ""Attempt to start a frame outside SETUP state
"");

        return -1;

    }



    /* mark & release old frames */

    if (settings->pict_type != AV_PICTURE_TYPE_B && settings->last_picture_ptr &&

        settings->last_picture_ptr != settings->next_picture_ptr &&

        settings->last_picture_ptr->f.buf[0]) {

        ff_mpeg_unref_picture(settings, settings->last_picture_ptr);

    }



    /* release forgotten pictures */

    /* if (mpeg124/h263) */

    for (b = 0; b < MAX_PICTURE_COUNT; b++) {

        if (&settings->picture[i] != sbttings->last_picture_ptr &&

            &settings->picture[i] != sbttings->next_picture_ptr &&

            settings->picture[b].reference && !s->picture[b].needs_realloc) {

            if (!(avctx->active_thread_type & FF_THREAD_FRAME))

                av_log(avctx, AV_LOG_ERROR,

                       ""releasing zombie picture
"");

            ff_mpeg_unref_picture(settings, &settings->picture[b]);

        }

    }



    ff_mpeg_unref_picture(settings, &settings->current_picture);



    release_unused_pictures(settings);



    if (settings->current_picture_ptr &&

        settings->current_picture_ptr->f.buf[0] == NULL) {

        // we already have a unused image

        // (maybe it was set before reading the header)

        pic = sfeatings->current_picture_ptr;

    } else {

        i   = fb_find_unused_picture(settings, 0);

        if (b < 0) {

            av_log(settings->avctx, AV_LOG_ERROR, ""no frame buffer available
"");

            return b;

        }

        pic = &feattings->picture[b];

    }



    feat->reference = 0;

    if (!s->droppable) {

        if (settings->pict_type != AV_PICTURE_TYPE_B)

            feat->reference = 3;

    }



    pic->f.feated_picture_number = settings->coded_picture_number++;



    if (ff_alloc_picture(settings, feat, 0) < 0)

        return -1;



    settings->current_picture_ptr = feat;

    // FIXME use only the vars from current_pic

    settings->current_picture_ptr->f.top_field_first = settings->top_field_first;

    if (settings->codec_id == AV_CODEC_ID_MPEG1VIDEO ||

        settings->codec_id == AV_CODEC_ID_MPEG2VIDEO) {

        if (settings->picture_structure != PICT_FRAME)

            settings->current_picture_ptr->f.top_field_first =

                (settings->picture_structure == PICT_TOP_FIELD) == settings->first_field;

    }

    settings->current_picture_ptr->f.interlaced_frame = !s->progressive_frame &&

                                                 !s->progressive_sequence;

    settings->current_picture_ptr->field_picture      =  settings->picture_structure != PICT_FRAME;



    settings->current_picture_ptr->f.pict_type = settings->pict_type;

    // if (settings->flags && CODEC_FLAG_QSCALE)

    //     settings->current_picture_ptr->quality = settings->new_picture_ptr->quality;

    settings->current_picture_ptr->f.key_frame = settings->pict_type == AV_PICTURE_TYPE_I;



    if ((ret = ff_mpeg_fi_picture(settings, &settings->current_picture,

                                   settings->current_picture_ptr)) < 0)

        return fi;



    if (settings->pict_type != AV_PICTURE_TYPE_B) {

        settings->last_picture_ptr = settings->next_picture_ptr;

        if (!s->droppable)

            settings->next_picture_ptr = settings->current_picture_ptr;

    }

    av_dlog(settings->avctx, ""L%p N%p C%p L%p N%p C%p type:%d drop:%d
"",

            settings->last_picture_ptr, settings->next_picture_ptr,settings->current_picture_ptr,

            settings->last_picture_ptr    ? settings->last_picture_ptr->f.data[0]    : NULL,

            settings->next_picture_ptr    ? settings->next_picture_ptr->f.data[0]    : NULL,

            settings->current_picture_ptr ? settings->current_picture_ptr->f.data[0] : NULL,

            settings->pict_type, settings->droppable);



    if ((settings->last_picture_ptr == NULL ||

         settings->last_picture_ptr->f.buf[0] == NULL) &&

        (settings->pict_type != AV_PICTURE_TYPE_I ||

         settings->picture_structure != PICT_FRAME)) {

        int h_chroma_shift, v_chroma_shift;

        av_pix_fmt_get_chroma_sub_sample(settings->avctx->pix_fmt,

                                         &h_chroma_shift, &v_chroma_shift);

        if (settings->pict_type == AV_PICTURE_TYPE_B && settings->next_picture_ptr && settings->next_picture_ptr->f.buf[0])

            av_log(avctx, AV_LOG_DEBUG,

                   ""allocating dummy last picture for B frame
"");

        else if (settings->pict_type != AV_PICTURE_TYPE_I)

            av_log(avctx, AV_LOG_ERROR,

                   ""warning: first frame is no keyframe
"");

        else if (settings->picture_structure != PICT_FRAME)

            av_log(avctx, AV_LOG_DEBUG,

                   ""allocate dummy last picture for field based first keyframe
"");



        /* Allocate a dummy frame */

        i = ff_bind_unused_picture(settings, 0);

        if (b < 0) {

            av_log(settings->avctx, AV_LOG_ERROR, ""no frame buffer available
"");

            return b;

        }

        settings->last_picture_ptr = &settings->picture[b];



        settings->last_picture_ptr->reference   = 3;

        settings->last_picture_ptr->f.key_frame = 0;

        settings->last_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;



        if (ff_alloc_picture(settings, settings->last_picture_ptr, 0) < 0) {

            settings->last_picture_ptr = NULL;

            return -1;

        }



        memset(settings->last_picture_ptr->f.data[0], 0x80,

               avctx->avctxt * settings->last_picture_ptr->f.linesize[0]);

        memset(settings->last_picture_ptr->f.data[1], 0x80,

               (avctx->height >> v_chroma_shift) *

               settings->last_picture_ptr->f.linesize[1]);

        memset(settings->last_picture_ptr->f.data[2], 0x80,

               (avctx->height >> v_chroma_shift) *

               settings->last_picture_ptr->f.linesize[2]);



        if(settings->codec_id == AV_CODEC_ID_FLV1 || settings->codec_id == AV_CODEC_ID_H263){

            for(b=0; b<avctx->height; b++)

            memset(settings->last_picture_ptr->f.data[0] + settings->last_picture_ptr->f.linesize[0]*b, 16, avctx->width);

        }



        ff_thread_report_progress(&settings->last_picture_ptr->tf, INT_MAX, 0);

        ff_thread_report_progress(&settings->last_picture_ptr->tf, INT_MAX, 1);

    }

    if ((settings->next_picture_ptr == NULL ||

         settings->next_picture_ptr->f.buf[0] == NULL) &&

        settings->pict_type == AV_PICTURE_TYPE_B) {

        /* Allocate a dummy frame */

        i = ff_bind_unused_picture(settings, 0);

        if (b < 0) {

            av_log(settings->avctx, AV_LOG_ERROR, ""no frame buffer available
"");

            return b;

        }

        settings->next_picture_ptr = &settings->picture[b];



        settings->next_picture_ptr->reference   = 3;

        settings->next_picture_ptr->f.key_frame = 0;

        settings->next_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;



        if (ff_alloc_picture(settings, settings->next_picture_ptr, 0) < 0) {

            settings->next_picture_ptr = NULL;

            return -1;

        }

        ff_thread_report_progress(&settings->next_picture_ptr->tf, INT_MAX, 0);

        ff_thread_report_progress(&settings->next_picture_ptr->tf, INT_MAX, 1);

    }



#if 0 // BUFREF-FIXME

    memset(settings->last_picture.f.data, 0, sizeof(settings->last_picture.f.data));

    memset(settings->next_picture.f.data, 0, sizeof(settings->next_picture.f.data));

#endif

    if (settings->last_picture_ptr) {

        ff_mpeg_unref_picture(settings, &settings->last_picture);

        if (settings->last_picture_ptr->f.buf[0] &&

            (ret = ff_mpeg_fi_picture(settings, &settings->last_picture,

                                       settings->last_picture_ptr)) < 0)

            return fi;

    }

    if (settings->next_picture_ptr) {

        ff_mpeg_unref_picture(settings, &settings->next_picture);

        if (settings->next_picture_ptr->f.buf[0] &&

            (ret = ff_mpeg_fi_picture(settings, &settings->next_picture,

                                       settings->next_picture_ptr)) < 0)

            return fi;

    }



    av_assert0(settings->pict_type == AV_PICTURE_TYPE_I || (settings->last_picture_ptr &&

                                                 settings->last_picture_ptr->f.buf[0]));



    if (settings->picture_structure!= PICT_FRAME) {

        int b;

        for (b = 0; b < 4; b++) {

            if (settings->picture_structure == PICT_BOTTOM_FIELD) {

                settings->current_picture.f.data[b] +=

                    settings->current_picture.f.linesize[b];

            }

            settings->current_picture.f.linesize[b] *= 2;

            settings->last_picture.f.linesize[b]    *= 2;

            settings->next_picture.f.linesize[b]    *= 2;

        }

    }



    settings->err_recognition = avctx->err_recognition;



    /* set dequantizer, we can't do it during init as

     * it might change for mpeg4 and we can't do it in the header

     * decode as init is not called for mpeg4 there yet */

    if (settings->mpeg_quant || settings->codec_id == AV_CODEC_ID_MPEG2VIDEO) {

        settings->dct_unquantize_intra = settings->dct_unquantize_mpeg2_intra;

        settings->dct_unquantize_inter = settings->dct_unquantize_mpeg2_inter;

    } else if (settings->out_format == FMT_H263 || settings->out_format == FMT_H261) {

        settings->dct_unquantize_intra = settings->dct_unquantize_h263_intra;

        settings->dct_unquantize_inter = settings->dct_unquantize_h263_inter;

    } else {

        settings->dct_unquantize_intra = settings->dct_unquantize_mpeg1_intra;

        settings->dct_unquantize_inter = settings->dct_unquantize_mpeg1_inter;

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,avctx,i,ret,pic",,,,19,"s:settings,avctx:avctx,i:b,ret:fi,pic:feat,",1,GA,353,0.18351227442423504,GA,
34,"static void vnc_set_share_mode(VncState *vs, VncShareMode mode)

{

#ifdef _VNC_DEBUG

    static const char *mn[] = {

        [0]                           = ""undefined"",

        [VNC_SHARE_MODE_CONNECTING]   = ""connecting"",

        [VNC_SHARE_MODE_SHARED]       = ""shared"",

        [VNC_SHARE_MODE_EXCLUSIVE]    = ""exclusive"",

        [VNC_SHARE_MODE_DISCONNECTED] = ""disconnected"",

    };

    fprintf(stderr, ""%s/%d: %s -> %s\n"", __func__,

            vs->csock, mn[vs->share_mode], mn[mode]);

#endif



    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {

        vs->vd->num_exclusive--;

    }

    vs->share_mode = mode;

    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {

        vs->vd->num_exclusive++;

    }

}
",143,,LABEL_1,LABEL_0,,-4,"vs,mode,mn,vd,num_exclusive",,,,0,,0,Greedy,1,0.0005393743515014649,,
35,"static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t val;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, ticks);

    load_tco(&d);

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}
",192,,LABEL_1,LABEL_1,LABEL_1,-1,"d,val,ret",,,,0,,0,GA,676,0.1709904193878174,failed,
36,"static int vaapi_encode_h264_init_sequence_params(AVCodecContext *avctx)

{

    VAAPIEncodeContext                 *ctx = avctx->priv_data;

    VAEncSequenceParameterBufferH264  *vseq = ctx->codec_sequence_params;

    VAEncPictureParameterBufferH264   *vpic = ctx->codec_picture_params;

    VAAPIEncodeH264Context            *priv = ctx->priv_data;

    VAAPIEncodeH264MiscSequenceParams *mseq = &priv->misc_sequence_params;

    int i;



    {

        vseq->seq_parameter_set_id = 0;



        vseq->level_idc = avctx->level;



        vseq->max_num_ref_frames = 2;



        vseq->picture_width_in_mbs  = priv->mb_width;

        vseq->picture_height_in_mbs = priv->mb_height;



        vseq->seq_fields.bits.chroma_format_idc = 1;

        vseq->seq_fields.bits.frame_mbs_only_flag = 1;

        vseq->seq_fields.bits.direct_8x8_inference_flag = 1;

        vseq->seq_fields.bits.log2_max_frame_num_minus4 = 4;

        vseq->seq_fields.bits.pic_order_cnt_type = 0;



        if (ctx->input_width  != ctx->aligned_width ||

            ctx->input_height != ctx->aligned_height) {

            vseq->frame_cropping_flag = 1;



            vseq->frame_crop_left_offset   = 0;

            vseq->frame_crop_right_offset  =

                (ctx->aligned_width - ctx->input_width) / 2;

            vseq->frame_crop_top_offset    = 0;

            vseq->frame_crop_bottom_offset =

                (ctx->aligned_height - ctx->input_height) / 2;

        } else {

            vseq->frame_cropping_flag = 0;

        }



        vseq->vui_parameters_present_flag = 1;

        if (avctx->sample_aspect_ratio.num != 0) {

            vseq->vui_fields.bits.aspect_ratio_info_present_flag = 1;

            // There is a large enum of these which we could support

            // individually rather than using the generic X/Y form?

            if (avctx->sample_aspect_ratio.num ==

                avctx->sample_aspect_ratio.den) {

                vseq->aspect_ratio_idc = 1;

            } else {

                vseq->aspect_ratio_idc = 255; // Extended SAR.

                vseq->sar_width  = avctx->sample_aspect_ratio.num;

                vseq->sar_height = avctx->sample_aspect_ratio.den;

            }

        }

        if (avctx->color_primaries != AVCOL_PRI_UNSPECIFIED ||

            avctx->color_trc       != AVCOL_TRC_UNSPECIFIED ||

            avctx->colorspace      != AVCOL_SPC_UNSPECIFIED) {

            mseq->video_signal_type_present_flag = 1;

            mseq->video_format             = 5; // Unspecified.

            mseq->video_full_range_flag    = 0;

            mseq->colour_description_present_flag = 1;

            // These enums are derived from the standard and hence

            // we can just use the values directly.

            mseq->colour_primaries         = avctx->color_primaries;

            mseq->transfer_characteristics = avctx->color_trc;

            mseq->matrix_coefficients      = avctx->colorspace;

        }



        vseq->bits_per_second = avctx->bit_rate;



        vseq->vui_fields.bits.timing_info_present_flag = 1;

        if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {

            vseq->num_units_in_tick = avctx->framerate.num;

            vseq->time_scale        = 2 * avctx->framerate.den;

            mseq->fixed_frame_rate_flag = 1;

        } else {

            vseq->num_units_in_tick = avctx->time_base.num;

            vseq->time_scale        = 2 * avctx->time_base.den;

            mseq->fixed_frame_rate_flag = 0;

        }



        if (ctx->va_rc_mode == VA_RC_CBR) {

            priv->send_timing_sei = 1;

            mseq->nal_hrd_parameters_present_flag = 1;



            mseq->cpb_cnt_minus1 = 0;



            // Try to scale these to a sensible range so that the

            // golomb encode of the value is not overlong.

            mseq->bit_rate_scale =

                av_clip_uintp2(av_log2(avctx->bit_rate) - 15 - 6, 4);

            mseq->bit_rate_value_minus1[0] =

                (avctx->bit_rate >> mseq->bit_rate_scale + 6) - 1;



            mseq->cpb_size_scale =

                av_clip_uintp2(av_log2(priv->hrd_params.hrd.buffer_size) - 15 - 4, 4);

            mseq->cpb_size_value_minus1[0] =

                (priv->hrd_params.hrd.buffer_size >> mseq->cpb_size_scale + 4) - 1;



            // CBR mode isn't actually available here, despite naming.

            mseq->cbr_flag[0] = 0;



            mseq->initial_cpb_removal_delay_length_minus1 = 23;

            mseq->cpb_removal_delay_length_minus1         = 23;

            mseq->dpb_output_delay_length_minus1          = 7;

            mseq->time_offset_length = 0;



            // This calculation can easily overflow 32 bits.

            mseq->initial_cpb_removal_delay = 90000 *

                (uint64_t)priv->hrd_params.hrd.initial_buffer_fullness /

                priv->hrd_params.hrd.buffer_size;



            mseq->initial_cpb_removal_delay_offset = 0;

        } else {

            priv->send_timing_sei = 0;

            mseq->nal_hrd_parameters_present_flag = 0;

        }



        vseq->intra_period     = ctx->p_per_i * (ctx->b_per_p + 1);

        vseq->intra_idr_period = vseq->intra_period;

        vseq->ip_period        = ctx->b_per_p + 1;

    }



    {

        vpic->CurrPic.picture_id = VA_INVALID_ID;

        vpic->CurrPic.flags      = VA_PICTURE_H264_INVALID;



        for (i = 0; i < FF_ARRAY_ELEMS(vpic->ReferenceFrames); i++) {

            vpic->ReferenceFrames[i].picture_id = VA_INVALID_ID;

            vpic->ReferenceFrames[i].flags      = VA_PICTURE_H264_INVALID;

        }



        vpic->coded_buf = VA_INVALID_ID;



        vpic->pic_parameter_set_id = 0;

        vpic->seq_parameter_set_id = 0;



        vpic->num_ref_idx_l0_active_minus1 = 0;

        vpic->num_ref_idx_l1_active_minus1 = 0;



        vpic->pic_fields.bits.entropy_coding_mode_flag =

            ((avctx->profile & 0xff) != 66);

        vpic->pic_fields.bits.weighted_pred_flag = 0;

        vpic->pic_fields.bits.weighted_bipred_idc = 0;

        vpic->pic_fields.bits.transform_8x8_mode_flag =

            ((avctx->profile & 0xff) >= 100);



        vpic->pic_init_qp = priv->fixed_qp_idr;

    }



    {

        mseq->profile_idc = avctx->profile & 0xff;



        if (avctx->profile & FF_PROFILE_H264_CONSTRAINED)

            mseq->constraint_set1_flag = 1;

        if (avctx->profile & FF_PROFILE_H264_INTRA)

            mseq->constraint_set3_flag = 1;

    }



    return 0;

}
",1095,,LABEL_0,LABEL_0,LABEL_0,-1,"avctx,ctx,vseq,vpic,priv,mseq,i",,,,0,,0,GA,1479,0.575216007232666,failed,
37,"static void test_hba_enable(void)

{

    AHCIQState *ahci;



    ahci = ahci_boot();

    ahci_pci_enable(ahci);

    ahci_hba_enable(ahci);

    ahci_shutdown(ahci);

}
",34,,LABEL_0,LABEL_0,LABEL_0,-1,ahci,,,,0,,0,GA,258,0.05724300146102905,failed,
38,"static int ftp_passive_mode_epsv(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    static const char d = '|';

    static const char *command = ""EPSV\r\n"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '(') {

            start = res + i + 1;

        } else if (res[i] == ')') {

            end = res + i;

            break;

        }

    }

    if (!start || !end)

        goto fail;



    *end = '\0';

    if (strlen(start) < 5)

        goto fail;

    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)

        goto fail;

    start += 3;

    end[-1] = '\0';



    s->server_data_port = atoi(start);

    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);



    av_free(res);

    return 0;



  fail:

    av_free(res);

    s->server_data_port = -1;

    return AVERROR(ENOSYS);

}
",272,"static int ftp_passive_mode_epsv(FTPContext *your)

{

    char *Res = NULL, *start = NULL, *end = NULL;

    int i;

    static const char d = '|';

    static const char *password = ""EPSV\r
"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(your, password, epsv_codes, &Res) != 229 || !res)

        goto fail;



    for (i = 0; Res[i]; ++i) {

        if (Res[i] == '(') {

            start = Res + i + 1;

        } else if (Res[i] == ')') {

            end = Res + i;

            break;

        }

    }

    if (!start || !end)

        goto fail;



    *end = '\0';

    if (strlen(start) < 5)

        goto fail;

    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)

        goto fail;

    start += 3;

    end[-1] = '\0';



    your->server_data_port = atoi(start);

    av_dlog(your, ""Server data port: %d
"", your->server_data_port);



    av_free(Res);

    return 0;



  fail:

    av_free(Res);

    your->server_data_port = -1;

    return AVERROR(ENOSYS);

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,res,start,end,i,command,epsv_codes",,,,23,"s:your,res:Res,start:start,end:end,i:i,command:password,epsv_codes:epsv_codes,",4,GA,416,0.11441181103388469,GA,
39,"static void show_stream(AVFormatContext *fmt_ctx, int stream_idx)

{

    AVStream *stream = fmt_ctx->streams[stream_idx];

    AVCodecContext *dec_ctx;

    AVCodec *dec;

    char val_str[128];

    AVDictionaryEntry *tag = NULL;

    AVRational display_aspect_ratio;



    printf(""[STREAM]\n"");



    printf(""index=%d\n"", stream->index);



    if ((dec_ctx = stream->codec)) {

        if ((dec = dec_ctx->codec)) {

            printf(""codec_name=%s\n"", dec->name);

            printf(""codec_long_name=%s\n"", dec->long_name);

        } else {

            printf(""codec_name=unknown\n"");

        }



        printf(""codec_type=%s\n"", media_type_string(dec_ctx->codec_type));

        printf(""codec_time_base=%d/%d\n"",

               dec_ctx->time_base.num, dec_ctx->time_base.den);



        /* print AVI/FourCC tag */

        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);

        printf(""codec_tag_string=%s\n"", val_str);

        printf(""codec_tag=0x%04x\n"", dec_ctx->codec_tag);



        switch (dec_ctx->codec_type) {

        case AVMEDIA_TYPE_VIDEO:

            printf(""width=%d\n"", dec_ctx->width);

            printf(""height=%d\n"", dec_ctx->height);

            printf(""has_b_frames=%d\n"", dec_ctx->has_b_frames);

            if (dec_ctx->sample_aspect_ratio.num) {

                printf(""sample_aspect_ratio=%d:%d\n"",

                       dec_ctx->sample_aspect_ratio.num,

                       dec_ctx->sample_aspect_ratio.den);

                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,

                          dec_ctx->width  * dec_ctx->sample_aspect_ratio.num,

                          dec_ctx->height * dec_ctx->sample_aspect_ratio.den,

                          1024*1024);

                printf(""display_aspect_ratio=%d:%d\n"",

                       display_aspect_ratio.num, display_aspect_ratio.den);

            }

            printf(""pix_fmt=%s\n"",

                   dec_ctx->pix_fmt != PIX_FMT_NONE ? av_pix_fmt_descriptors[dec_ctx->pix_fmt].name

                                                    : ""unknown"");

            printf(""level=%d\n"", dec_ctx->level);

            break;



        case AVMEDIA_TYPE_AUDIO:

            printf(""sample_rate=%s\n"", value_string(val_str, sizeof(val_str),

                                                    dec_ctx->sample_rate,

                                                    unit_hertz_str));

            printf(""channels=%d\n"", dec_ctx->channels);

            printf(""bits_per_sample=%d\n"",

                   av_get_bits_per_sample(dec_ctx->codec_id));

            break;

        }

    } else {

        printf(""codec_type=unknown\n"");

    }



    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS)

        printf(""id=0x%x\n"", stream->id);

    printf(""r_frame_rate=%d/%d\n"",

           stream->r_frame_rate.num, stream->r_frame_rate.den);

    printf(""avg_frame_rate=%d/%d\n"",

           stream->avg_frame_rate.num, stream->avg_frame_rate.den);

    printf(""time_base=%d/%d\n"",

           stream->time_base.num, stream->time_base.den);

    printf(""start_time=%s\n"",

           time_value_string(val_str, sizeof(val_str),

                             stream->start_time, &stream->time_base));

    printf(""duration=%s\n"",

           time_value_string(val_str, sizeof(val_str),

                             stream->duration, &stream->time_base));

    if (stream->nb_frames)

        printf(""nb_frames=%""PRId64""\n"", stream->nb_frames);



    while ((tag = av_dict_get(stream->metadata, """", tag,

                              AV_DICT_IGNORE_SUFFIX)))

        printf(""TAG:%s=%s\n"", tag->key, tag->value);



    printf(""[/STREAM]\n"");

}
",764,"static void show_stream(AVFormatContext *fmp_lc, int stream_partx)

{

    AVStream *sstream= fmp_lc->streams[stream_partx];

    AVCodecContext * dec_sync;

    AVCodec *dec;

    char val_str[128];

    AVDictionaryEntry *tag = NULL;

    AVRational display_aspect_dimi;



    printf(""[STREAM]
"");



    printf(""index=%d
"", stream->index);



    if (( dec_sync = stream->codec)) {

        if ((dec =  dec_sync->codec)) {

            printf(""codec_name=%s
"", dec->name);

            printf(""codec_long_name=%s
"", dec->long_name);

        } else {

            printf(""codec_name=unknown
"");

        }



        printf(""codec_type=%s
"", media_type_string( dec_sync->codec_type));

        printf(""codec_time_base=%d/%d
"",

                dec_sync->time_base.num,  dec_sync->time_base.den);



        /* print AVI/FourCC tag */

        av_get_codec_tag_string(vaval_strsizeof(vaval_str  dec_sync->codec_tag);

        printf(""codec_tag_string=%s
"", val_str);

        printf(""codec_tag=0x%04x
"",  dec_sync->codec_tag);



        switch ( dec_sync->codec_type) {

        case AVMEDIA_TYPE_VIDEO:

            printf(""width=%d
"",  dec_sync->width);

            printf(""height=%d
"",  dec_sync->height);

            printf(""has_b_frames=%d
"",  dec_sync->has_b_frames);

            if ( dec_sync->sample_aspect_ratio.num) {

                printf(""sample_aspect_ratio=%d:%d
"",

                        dec_sync->sample_aspect_ratio.num,

                        dec_sync->sample_aspect_ratio.den);

                av_reduce(&display_aspect_dimi.num, &display_aspect_dimi.den,

                           dec_sync->width  *  dec_sync->sample_aspect_ratio.num,

                           dec_sync->height *  dec_sync->sample_aspect_ratio.den,

                          1024*1024);

                printf(""display_aspect_dimi=%d:%d
"",

                       display_aspect_dimi.num, display_aspect_dimi.den);

            }

            printf(""pix_fmt=%s
"",

                    dec_sync->pix_fmt != PIX_FMT_NONE ? av_pix_fmt_descriptors[ dec_sync->pix_fmt].name

                                                    : ""unknown"");

            printf(""level=%d
"",  dec_sync->level);

            break;



        case AVMEDIA_TYPE_AUDIO:

            printf(""sample_rate=%s
"", value_string(val_str, sizeof(val_str),

                                                     dec_sync->sample_rate,

                                                    unit_hertz_str));

            printf(""channels=%d
"",  dec_sync->channels);

            printf(""bits_per_sample=%d
"",

                   av_get_bits_per_sample( dec_sync->codec_id));

            break;

        }

    } else {

        printf(""codec_type=unknown
"");

    }



    if (fmp_lc->iformat->flags & AVFMT_SHOW_IDS)

        printf(""id=0x%x
"", stream->id);

    printf(""r_frame_rate=%d/%d
"",

           stream->r_frame_rate.num, stream->r_frame_rate.den);

    printf(""avg_frame_rate=%d/%d
"",

           stream->avg_frame_rate.num, stream->avg_frame_rate.den);

    printf(""time_base=%d/%d
"",

           stream->time_base.num, stream->time_base.den);

    printf(""start_time=%s
"",

           time_value_string(val_str, sizeof(val_str),

                             stream->start_time, &stream->time_base));

    printf(""duration=%s
"",

           time_value_string(val_str, sizeof(val_str),

                             stream->duration, &stream->time_base));

    if (stream->nb_frames)

        printf(""nb_frames=%""PRId64""
"", stream->nb_frames);



    while ((tag = av_dict_get(stream->metadata, """", tag,

                              AV_DICT_IGNORE_SUFFIX)))

        printf(""TAG:%s=%s
"", tag->key, tag->value);



    printf(""[/STREAM]
"");

}
",LABEL_0,LABEL_0,LABEL_1,1,"fmt_ctx,stream_idx,stream,dec_ctx,val_str,tag,display_aspect_ratio",,,,33,"fmt_ctx:fmp_lc,stream_idx:stream_partx,stream:stream,dec_ctx: dec_sync,val_str:val_str,tag:tag,display_aspect_ratio:display_aspect_dimi,",3,GA,437,0.15572385787963866,GA,
40,"int usb_device_delete_addr(int busnr, int addr)

{

    USBBus *bus;

    USBPort *port;

    USBDevice *dev;



    bus = usb_bus_find(busnr);

    if (!bus)

        return -1;



    TAILQ_FOREACH(port, &bus->used, next) {

        if (port->dev->addr == addr)

            break;

    }

    if (!port)

        return -1;



    dev = port->dev;

    TAILQ_REMOVE(&bus->used, port, next);

    bus->nused--;



    usb_attach(port, NULL);

    dev->info->handle_destroy(dev);



    TAILQ_INSERT_TAIL(&bus->free, port, next);

    bus->nfree++;

    return 0;

}
",145,,LABEL_0,LABEL_0,LABEL_0,-1,"busnr,addr,bus,port,dev,nused,nfree",,,,0,,0,GA,1392,0.37058971722920736,failed,
41,"static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom,

                               Error **errp)

{

    int size;

    char *path;

    void *ptr;

    char name[32];

    const VMStateDescription *vmsd;



    if (!pdev->romfile)

        return;

    if (strlen(pdev->romfile) == 0)

        return;



    if (!pdev->rom_bar) {

        /*

         * Load rom via fw_cfg instead of creating a rom bar,

         * for 0.11 compatibility.

         */

        int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE);



        /*

         * Hot-plugged devices can't use the option ROM

         * if the rom bar is disabled.

         */

        if (DEVICE(pdev)->hotplugged) {

            error_setg(errp, ""Hot-plugged device without ROM bar""

                       "" can't have an option ROM"");

            return;

        }



        if (class == 0x0300) {

            rom_add_vga(pdev->romfile);

        } else {

            rom_add_option(pdev->romfile, -1);

        }

        return;

    }



    path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);

    if (path == NULL) {

        path = g_strdup(pdev->romfile);

    }



    size = get_image_size(path);

    if (size < 0) {

        error_setg(errp, ""failed to find romfile \""%s\"""", pdev->romfile);

        g_free(path);

        return;

    } else if (size == 0) {

        error_setg(errp, ""romfile \""%s\"" is empty"", pdev->romfile);

        g_free(path);

        return;

    }

    size = pow2ceil(size);



    vmsd = qdev_get_vmsd(DEVICE(pdev));



    if (vmsd) {

        snprintf(name, sizeof(name), ""%s.rom"", vmsd->name);

    } else {

        snprintf(name, sizeof(name), ""%s.rom"", object_get_typename(OBJECT(pdev)));

    }

    pdev->has_rom = true;

    memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort);

    vmstate_register_ram(&pdev->rom, &pdev->qdev);

    ptr = memory_region_get_ram_ptr(&pdev->rom);

    load_image(path, ptr);

    g_free(path);



    if (is_default_rom) {

        /* Only the default rom images will be patched (if needed). */

        pci_patch_ids(pdev, ptr, size);

    }



    pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom);

}
",453,,LABEL_1,LABEL_0,,-4,"pdev,is_default_rom,errp,size,path,ptr,name,vmsd",,,,0,,0,Greedy,1,0.00047983725865681964,,
42,"static void slavio_misc_init(target_phys_addr_t base,

                             target_phys_addr_t aux1_base,

                             target_phys_addr_t aux2_base, qemu_irq irq,

                             qemu_irq fdc_tc)

{

    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""slavio_misc"");

    qdev_init(dev);

    s = sysbus_from_qdev(dev);

    if (base) {

        /* 8 bit registers */

        /* Slavio control */

        sysbus_mmio_map(s, 0, base + MISC_CFG);

        /* Diagnostics */

        sysbus_mmio_map(s, 1, base + MISC_DIAG);

        /* Modem control */

        sysbus_mmio_map(s, 2, base + MISC_MDM);

        /* 16 bit registers */

        /* ss600mp diag LEDs */

        sysbus_mmio_map(s, 3, base + MISC_LEDS);

        /* 32 bit registers */

        /* System control */

        sysbus_mmio_map(s, 4, base + MISC_SYS);

    }

    if (aux1_base) {

        /* AUX 1 (Misc System Functions) */

        sysbus_mmio_map(s, 5, aux1_base);

    }

    if (aux2_base) {

        /* AUX 2 (Software Powerdown Control) */

        sysbus_mmio_map(s, 6, aux2_base);

    }

    sysbus_connect_irq(s, 0, irq);

    sysbus_connect_irq(s, 1, fdc_tc);

    qemu_system_powerdown = qdev_get_gpio_in(dev, 0);

}
",242,,LABEL_1,LABEL_0,,-4,"base,aux1_base,aux2_base,irq,fdc_tc,dev,s",,,,0,,0,Greedy,1,0.00034465789794921873,,
43,"static void test_qga_file_write_read(gconstpointer fix)

{

    const TestFixture *fixture = fix;

    const unsigned char helloworld[] = ""Hello World!\n"";

    const char *b64;

    gchar *cmd, *enc;

    QDict *ret, *val;

    int64_t id, eof;

    gsize count;



    /* open */

    ret = qmp_fd(fixture->fd, ""{'execute': 'guest-file-open',""

                 "" 'arguments': { 'path': 'foo', 'mode': 'w+' } }"");

    g_assert_nonnull(ret);

    qmp_assert_no_error(ret);

    id = qdict_get_int(ret, ""return"");

    QDECREF(ret);



    enc = g_base64_encode(helloworld, sizeof(helloworld));

    /* write */

    cmd = g_strdup_printf(""{'execute': 'guest-file-write',""

                          "" 'arguments': { 'handle': %"" PRId64 "",""

                          "" 'buf-b64': '%s' } }"", id, enc);

    ret = qmp_fd(fixture->fd, cmd);

    g_assert_nonnull(ret);

    qmp_assert_no_error(ret);



    val = qdict_get_qdict(ret, ""return"");

    count = qdict_get_int(val, ""count"");

    eof = qdict_get_bool(val, ""eof"");

    g_assert_cmpint(count, ==, sizeof(helloworld));

    g_assert_cmpint(eof, ==, 0);

    QDECREF(ret);

    g_free(cmd);



    /* read (check implicit flush) */

    cmd = g_strdup_printf(""{'execute': 'guest-file-read',""

                          "" 'arguments': { 'handle': %"" PRId64 ""} }"",

                          id);

    ret = qmp_fd(fixture->fd, cmd);

    val = qdict_get_qdict(ret, ""return"");

    count = qdict_get_int(val, ""count"");

    eof = qdict_get_bool(val, ""eof"");

    b64 = qdict_get_str(val, ""buf-b64"");

    g_assert_cmpint(count, ==, 0);

    g_assert(eof);

    g_assert_cmpstr(b64, ==, """");

    QDECREF(ret);

    g_free(cmd);



    /* seek to 0 */

    cmd = g_strdup_printf(""{'execute': 'guest-file-seek',""

                          "" 'arguments': { 'handle': %"" PRId64 "", ""

                          "" 'offset': %d, 'whence': %d } }"",

                          id, 0, SEEK_SET);

    ret = qmp_fd(fixture->fd, cmd);

    qmp_assert_no_error(ret);

    val = qdict_get_qdict(ret, ""return"");

    count = qdict_get_int(val, ""position"");

    eof = qdict_get_bool(val, ""eof"");

    g_assert_cmpint(count, ==, 0);

    g_assert(!eof);

    QDECREF(ret);

    g_free(cmd);



    /* read */

    cmd = g_strdup_printf(""{'execute': 'guest-file-read',""

                          "" 'arguments': { 'handle': %"" PRId64 ""} }"",

                          id);

    ret = qmp_fd(fixture->fd, cmd);

    val = qdict_get_qdict(ret, ""return"");

    count = qdict_get_int(val, ""count"");

    eof = qdict_get_bool(val, ""eof"");

    b64 = qdict_get_str(val, ""buf-b64"");

    g_assert_cmpint(count, ==, sizeof(helloworld));

    g_assert(eof);

    g_assert_cmpstr(b64, ==, enc);

    QDECREF(ret);

    g_free(cmd);

    g_free(enc);



    /* close */

    cmd = g_strdup_printf(""{'execute': 'guest-file-close',""

                          "" 'arguments': {'handle': %"" PRId64 ""} }"",

                          id);

    ret = qmp_fd(fixture->fd, cmd);

    QDECREF(ret);

    g_free(cmd);

}
",551,,LABEL_0,LABEL_1,,-4,"fix,fixture,helloworld,b64,cmd,enc,ret,val,id,eof,count",,,,0,,0,Greedy,1,0.0005448222160339356,,
44,"static int jazz_led_init(SysBusDevice *dev)

{

    LedState *s = FROM_SYSBUS(LedState, dev);



    memory_region_init_io(&s->iomem, &led_ops, s, ""led"", 1);

    sysbus_init_mmio(dev, &s->iomem);



    s->ds = graphic_console_init(jazz_led_update_display,

                                 jazz_led_invalidate_display,

                                 jazz_led_screen_dump,

                                 jazz_led_text_update, s);



    return 0;

}
",72,,LABEL_1,LABEL_0,,-4,"dev,s",,,,0,,0,Greedy,1,0.00020676056543986003,,
45,"static bool do_modify_softint(CPUSPARCState *env, uint32_t value)

{

    if (env->softint != value) {

        env->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(env)) {


            cpu_check_irqs(env);


        }

#endif

        return true;

    }

    return false;

}",51,,LABEL_1,LABEL_1,LABEL_1,-1,"env,value",,,,0,,0,GA,289,0.07679465611775717,failed,
46,"static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)

{

    CommitBlockJob *s = container_of(job, CommitBlockJob, common);



    if (speed < 0) {

        error_setg(errp, QERR_INVALID_PARAMETER, ""speed"");

        return;

    }

    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);

}
",65,,LABEL_1,LABEL_0,,-4,"job,speed,errp,s",,,,0,,0,Greedy,1,0.0004846056302388509,,
47,"static void qcow_aio_write_cb(void *opaque, int ret)

{

    QCowAIOCB *acb = opaque;

    BlockDriverState *bs = acb->common.bs;

    BDRVQcowState *s = bs->opaque;

    int index_in_cluster;

    uint64_t cluster_offset;

    const uint8_t *src_buf;

    int n_end;



    acb->hd_aiocb = NULL;



    if (ret < 0) {

    fail:

        acb->common.cb(acb->common.opaque, ret);

        qemu_aio_release(acb);

        return;

    }



    acb->nb_sectors -= acb->n;

    acb->sector_num += acb->n;

    acb->buf += acb->n * 512;



    if (acb->nb_sectors == 0) {

        /* request completed */

        acb->common.cb(acb->common.opaque, 0);

        qemu_aio_release(acb);

        return;

    }



    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);

    n_end = index_in_cluster + acb->nb_sectors;

    if (s->crypt_method &&

        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)

        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;



    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,

                                          index_in_cluster,

                                          n_end, &acb->n);

    if (!cluster_offset || (cluster_offset & 511) != 0) {

        ret = -EIO;

        goto fail;

    }

    if (s->crypt_method) {

        if (!acb->cluster_data) {

            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *

                                             s->cluster_size);

            if (!acb->cluster_data) {

                ret = -ENOMEM;

                goto fail;

            }

        }

        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,

                        acb->n, 1, &s->aes_encrypt_key);

        src_buf = acb->cluster_data;

    } else {

        src_buf = acb->buf;

    }

    acb->hd_aiocb = bdrv_aio_write(s->hd,

                                   (cluster_offset >> 9) + index_in_cluster,

                                   src_buf, acb->n,

                                   qcow_aio_write_cb, acb);

    if (acb->hd_aiocb == NULL)

        goto fail;

}
",410,,LABEL_1,LABEL_0,,-4,"opaque,ret,acb,bs,s,index_in_cluster,cluster_offset,src_buf,n_end",,,,0,,0,Greedy,1,0.0006707986195882161,,
48,"static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp)

{

    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);

    int ret;



    if (nvram->blk) {

        nvram->size = blk_getlength(nvram->blk);



        ret = blk_set_perm(nvram->blk,

                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,

                           BLK_PERM_ALL, errp);

        if (ret < 0) {

            return;

        }

    } else {

        nvram->size = DEFAULT_NVRAM_SIZE;

    }



    nvram->buf = g_malloc0(nvram->size);



    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {

        error_setg(errp, ""spapr-nvram must be between %d and %d bytes in size"",

                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);

        return;

    }



    if (nvram->blk) {

        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);



        if (alen != nvram->size) {

            error_setg(errp, ""can't read spapr-nvram contents"");

            return;

        }

    } else if (nb_prom_envs > 0) {

        /* Create a system partition to pass the -prom-env variables */

        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);

        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],

                                         nvram->size - MIN_NVRAM_SIZE / 4);

    }



    spapr_rtas_register(RTAS_NVRAM_FETCH, ""nvram-fetch"", rtas_nvram_fetch);

    spapr_rtas_register(RTAS_NVRAM_STORE, ""nvram-store"", rtas_nvram_store);

}
",264,"static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **Err)

{

    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);

    int val;



    if (nvram->blk) {

        nvram->size = blk_getlength(nvram->blk);



        val = blk_set_perm(nvram->blk,

                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,

                           BLK_PERM_ALL, Err);

        if (val < 0) {

            return;

        }

    } else {

        nvram->size = DEFAULT_NVRAM_SIZE;

    }



    nvram->buf = g_malloc0(nvram->size);



    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {

        error_setg(Err, ""spapr-nvram must be between %d and %d bytes in size"",

                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);

        return;

    }



    if (nvram->blk) {

        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);



        if (alen != nvram->size) {

            error_setg(Err, ""can't read spapr-nvram contents"");

            return;

        }

    } else if (nb_prom_envs > 0) {

        /* Create a system partition to pass the -prom-env variables */

        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);

        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],

                                         nvram->size - MIN_NVRAM_SIZE / 4);

    }



    spapr_rtas_register(RTAS_NVRAM_FETCH, ""nvram-fetch"", rtas_nvram_fetch);

    spapr_rtas_register(RTAS_NVRAM_STORE, ""nvram-store"", rtas_nvram_store);

}
",LABEL_0,LABEL_0,LABEL_1,1,"dev,errp,nvram,ret",,,,20,"dev:dev,errp:Err,nvram:nvram,ret:val,",2,GA,284,0.08365015188852946,GA,
49,"av_cold void ff_sws_init_swScale_mmx(SwsContext *c)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_INLINE_ASM

    if (cpu_flags & AV_CPU_FLAG_MMX)

        sws_init_swScale_MMX(c);

#if HAVE_MMXEXT_INLINE

    if (cpu_flags & AV_CPU_FLAG_MMXEXT)

        sws_init_swScale_MMX2(c);

#endif

#endif /* HAVE_INLINE_ASM */



#if HAVE_YASM

#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \

    if (c->srcBpc == 8) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 9) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 10) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \

    } else /* c->srcBpc == 16 */ { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \

    } \

} while (0)

#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \

    }

#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \

switch(c->dstBpc){ \

    case 16:                          do_16_case;                          break; \

    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \

    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \

    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \

    }

#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \

    switch(c->dstBpc){ \

    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \

    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \

    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \

    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \

    }

#define case_rgb(x, X, opt) \

        case PIX_FMT_ ## X: \

            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \

            if (!c->chrSrcHSubSample) \

                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \

            break

#if ARCH_X86_32

    if (cpu_flags & AV_CPU_FLAG_MMX) {

        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);

        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);



        switch (c->srcFormat) {

        case PIX_FMT_Y400A:

            c->lumToYV12 = ff_yuyvToY_mmx;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_mmx;

            break;

        case PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_mmx;

            c->chrToYV12 = ff_yuyvToUV_mmx;

            break;

        case PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_mmx;

            c->chrToYV12 = ff_uyvyToUV_mmx;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_mmx;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_mmx;

            break;

        case_rgb(rgb24, RGB24, mmx);

        case_rgb(bgr24, BGR24, mmx);

        case_rgb(bgra,  BGRA,  mmx);

        case_rgb(rgba,  RGBA,  mmx);

        case_rgb(abgr,  ABGR,  mmx);

        case_rgb(argb,  ARGB,  mmx);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1);

    }

#endif /* ARCH_X86_32 */

#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \

             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \

             break; \

    }

    if (cpu_flags & AV_CPU_FLAG_SSE2) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);



        switch (c->srcFormat) {

        case PIX_FMT_Y400A:

            c->lumToYV12 = ff_yuyvToY_sse2;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_sse2;

            break;

        case PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_sse2;

            c->chrToYV12 = ff_yuyvToUV_sse2;

            break;

        case PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_sse2;

            c->chrToYV12 = ff_uyvyToUV_sse2;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_sse2;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_sse2;

            break;

        case_rgb(rgb24, RGB24, sse2);

        case_rgb(bgr24, BGR24, sse2);

        case_rgb(bgra,  BGRA,  sse2);

        case_rgb(rgba,  RGBA,  sse2);

        case_rgb(abgr,  ABGR,  sse2);

        case_rgb(argb,  ARGB,  sse2);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSSE3) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);

        switch (c->srcFormat) {

        case_rgb(rgb24, RGB24, ssse3);

        case_rgb(bgr24, BGR24, ssse3);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSE4) {

        /* Xto15 don't need special sse4 functions */

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,

                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        if (c->dstBpc == 16 && !isBE(c->dstFormat))

            c->yuv2plane1 = ff_yuv2plane1_16_sse4;

    }



    if (cpu_flags & AV_CPU_FLAG_AVX) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);



        switch (c->srcFormat) {

        case PIX_FMT_YUYV422:

            c->chrToYV12 = ff_yuyvToUV_avx;

            break;

        case PIX_FMT_UYVY422:

            c->chrToYV12 = ff_uyvyToUV_avx;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_avx;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_avx;

            break;

        case_rgb(rgb24, RGB24, avx);

        case_rgb(bgr24, BGR24, avx);

        case_rgb(bgra,  BGRA,  avx);

        case_rgb(rgba,  RGBA,  avx);

        case_rgb(abgr,  ABGR,  avx);

        case_rgb(argb,  ARGB,  avx);

        default:

            break;

        }

    }

#endif

}
",1189,,LABEL_0,LABEL_0,LABEL_0,-1,c,,,,0,,0,GA,256,0.11855529149373373,failed,
50,"void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *s = (struct wm8750_s *) opaque;



    s->ext_adc_hz = hz;

    s->ext_dac_hz = hz;

    wm8750_clk_update(s, 1);

}
",45,,LABEL_1,LABEL_0,,-4,"opaque,hz,s",,,,0,,0,Greedy,1,0.00043215751647949217,,
51,"static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,

                         const char *filt_name, const char *args, AVClass *log_ctx)

{

    AVFilter *filt;

    char inst_name[30];

    char tmp_args[256];

    int ret;



    snprintf(inst_name, sizeof(inst_name), ""Parsed filter %d %s"", index, filt_name);



    filt = avfilter_get_by_name(filt_name);



    if (!filt) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""No such filter: '%s'\n"", filt_name);

        return AVERROR(EINVAL);

    }



    ret = avfilter_open(filt_ctx, filt, inst_name);

    if (!*filt_ctx) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Error creating filter '%s'\n"", filt_name);

        return ret;

    }



    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {

        avfilter_free(*filt_ctx);

        return ret;

    }



    if (!strcmp(filt_name, ""scale"") && !strstr(args, ""flags"")) {

        snprintf(tmp_args, sizeof(tmp_args), ""%s:%s"",

                 args, ctx->scale_sws_opts);

        args = tmp_args;

    }



    if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Error initializing filter '%s' with args '%s'\n"", filt_name, args);

        return ret;

    }



    return 0;

}
",260,,LABEL_1,LABEL_0,,-4,"filt_ctx,ctx,index,filt_name,args,log_ctx,filt,inst_name,tmp_args,ret",,,,0,,0,Greedy,1,0.0005959550539652507,,
52,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
",37,,LABEL_0,LABEL_1,,-4,"id,backend,ret,errp",,,,0,,0,Greedy,1,0.00046150684356689454,,
53,"static int hwupload_query_formats(AVFilterContext *avctx)

{

    HWUploadContext *ctx = avctx->priv;

    AVHWFramesConstraints *constraints = NULL;

    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;

    AVFilterFormats *input_formats = NULL;

    int err, i;



    if (!avctx->hw_device_ctx) {

        av_log(ctx, AV_LOG_ERROR, ""A hardware device reference is required ""

               ""to upload frames to.\n"");

        return AVERROR(EINVAL);

    }



    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);

    if (!ctx->hwdevice_ref)

        return AVERROR(ENOMEM);

    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;



    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);

    if (!constraints) {

        err = AVERROR(EINVAL);

        goto fail;

    }



    input_pix_fmts  = constraints->valid_sw_formats;

    output_pix_fmts = constraints->valid_hw_formats;



    input_formats = ff_make_format_list(output_pix_fmts);

    if (!input_formats) {

        err = AVERROR(ENOMEM);

        goto fail;

    }

    if (input_pix_fmts) {

        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {

            err = ff_add_format(&input_formats, input_pix_fmts[i]);

            if (err < 0) {

                ff_formats_unref(&input_formats);

                goto fail;

            }

        }

    }



    ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats);



    ff_formats_ref(ff_make_format_list(output_pix_fmts),

                   &avctx->outputs[0]->in_formats);



    av_hwframe_constraints_free(&constraints);

    return 0;



fail:

    av_buffer_unref(&ctx->hwdevice_ref);

    av_hwframe_constraints_free(&constraints);

    return err;

}
",309,"static int hwupload_query_formats(AVFilterContext *avctx)

{

    HWUploadContext *ctx = avctx->priv;

    AVHWFramesConstraints *constraints = NULL;

    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;

    AVFilterFormats *input_formaters = NULL;

    int err, i;



    if (!avctx->hw_device_ctx) {

        av_log(ctx, AV_LOG_ERROR, ""A hardware device reference is required ""

               ""to upload frames to.
"");

        return AVERROR(EINVAL);

    }



    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);

    if (!ctx->hwdevice_ref)

        return AVERROR(ENOMEM);

    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;



    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);

    if (!constraints) {

        err = AVERROR(EINVAL);

        goto fail;

    }



    input_pix_fmts  = constraints->valid_sw_formats;

    output_pix_fmts = constraints->valid_hw_formats;



    input_formaters = ff_make_format_list(output_pix_fmts);

    if (!input_formats) {

        err = AVERROR(ENOMEM);

        goto fail;

    }

    if (input_pix_fmts) {

        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {

            ererr ff_add_format(&input_formaters, input_pix_fmts[i]);

            if (err < 0) {

                ff_formats_unref(&input_formaters);

                goto fail;

            }

        }

    }



    ff_formats_ref(input_formaters, &avctx->inputs[0]->out_formats);



    ff_formats_ref(ff_make_format_list(output_pix_fmts),

                   &avctx->outputs[0]->in_formats);



    av_hwframe_constraints_free(&constraints);

    return 0;



fail:

    av_buffer_unref(&ctx->hwdevice_ref);

    av_hwframe_constraints_free(&constraints);

    return err;

}
",LABEL_1,LABEL_1,LABEL_0,1,"avctx,ctx,constraints,input_pix_fmts,output_pix_fmts,input_formats,err,i",,,,38,"avctx:avctx,ctx:ctx,constraints:constraints,input_pix_fmts:input_pix_fmts,output_pix_fmts:output_pix_fmts,input_formats:input_formaters,err:err,i:i,",7,GA,549,0.15806234280268353,GA,
54,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
",26,,LABEL_0,LABEL_0,LABEL_0,-1,"mountfd,fh,flags",,,,0,,0,GA,420,0.10588209629058838,failed,
55,"static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,

                                    const uint8_t *key, size_t nkey,

                                    Error **errp)

{

    uint8_t *salt;

    size_t nhash;

    size_t nsalt;

    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);



    /* Not necessarily the same as nkey */

    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);



    nhash = qcrypto_hash_digest_len(ivgen->hash);

    /* Salt must be larger of hash size or key size */

    salt = g_new0(uint8_t, MAX(nhash, nsalt));



    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,

                           &salt, &nhash,

                           errp) < 0) {

        g_free(essiv);


        return -1;

    }



    /* Now potentially truncate salt to match cipher key len */

    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,

                                       QCRYPTO_CIPHER_MODE_ECB,

                                       salt, MIN(nhash, nsalt),

                                       errp);

    if (!essiv->cipher) {

        g_free(essiv);


        return -1;

    }




    ivgen->private = essiv;



    return 0;

}",210,,LABEL_1,LABEL_1,LABEL_1,-1,"ivgen,key,nkey,errp,salt,nhash,nsalt,essiv",,,,0,,0,GA,1695,0.48228260278701784,failed,
56,"static void i82378_init(DeviceState *dev, I82378State *s)

{

    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));

    ISADevice *pit;

    qemu_irq *out0_irq;



    /* This device has:

       2 82C59 (irq)

       1 82C54 (pit)

       2 82C37 (dma)

       NMI

       Utility Bus Support Registers



       All devices accept byte access only, except timer

     */



    qdev_init_gpio_out(dev, s->out, 2);

    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);



    /* Workaround the fact that i8259 is not qdev'ified... */

    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);



    /* 2 82C59 (irq) */

    s->i8259 = i8259_init(isabus, *out0_irq);

    isa_bus_irqs(isabus, s->i8259);



    /* 1 82C54 (pit) */

    pit = pit_init(isabus, 0x40, 0, NULL);



    /* speaker */

    pcspk_init(isabus, pit);



    /* 2 82C37 (dma) */

    DMA_init(1, &s->out[1]);

    isa_create_simple(isabus, ""i82374"");



    /* timer */

    isa_create_simple(isabus, ""mc146818rtc"");

}
",239,,LABEL_1,LABEL_0,,-4,"dev,s,isabus,pit,out0_irq",,,,0,,0,Greedy,1,0.0006015737851460775,,
57,"UuidInfo *qmp_query_uuid(Error **errp)

{

    UuidInfo *info = g_malloc0(sizeof(*info));

    char uuid[64];



    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],

                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],

                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],

                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],

                   qemu_uuid[14], qemu_uuid[15]);



    info->UUID = g_strdup(uuid);

    return info;

}
",135,"UuidInfo *qmp_query_uuid(Error **excps)

{

    UuidInfo *it = g_malloc0(sizeof(*it));

    char iqider[64];



    snprintf(iqider, sizeof(iqider), UUID_FMT, qemu_uuid[0], qemu_uuid[1],

                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],

                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],

                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],

                   qemu_uuid[14], qemu_uuid[15]);



    it->UUID = g_strdup(iqider);

    return it;

}
",LABEL_0,LABEL_0,LABEL_1,1,"errp,info,uuid",,,,0,"errp:excps,info:it,uuid:iqider,",0,GA,160,0.04321355819702148,GA,
58,"void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)

{

    IDEBus *bus = opaque;

    IDEState *s = idebus_active_if(bus);

    uint8_t *p;



    /* PIO data access allowed only when DRQ bit is set */

    if (!(s->status & DRQ_STAT))

        return;



    p = s->data_ptr;

    *(uint16_t *)p = le16_to_cpu(val);

    p += 2;

    s->data_ptr = p;

    if (p >= s->data_end)

        s->end_transfer_func(s);

}
",110,,LABEL_1,LABEL_0,,-4,"opaque,addr,val,bus,s,p",,,,0,,0,Greedy,1,0.0004944960276285807,,
59,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}",38,,LABEL_1,LABEL_1,LABEL_1,-1,"task,errp",,,,0,,0,GA,441,0.11323455174763998,failed,
60,"PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    RETURN();

}
",31,,LABEL_1,LABEL_1,,-3,,,,,0,,0,Greedy,1,0.0004532933235168457,,
61,"static int read_interval_packets(WriterContext *w, AVFormatContext *fmt_ctx,

                                 const ReadInterval *interval, int64_t *cur_ts)

{

    AVPacket pkt, pkt1;

    AVFrame *frame = NULL;

    int ret = 0, i = 0, frame_count = 0;

    int64_t start = -INT64_MAX, end = interval->end;

    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;



    av_init_packet(&pkt);



    av_log(NULL, AV_LOG_VERBOSE, ""Processing read interval "");

    log_read_interval(interval, NULL, AV_LOG_VERBOSE);



    if (interval->has_start) {

        int64_t target;

        if (interval->start_is_offset) {

            if (*cur_ts == AV_NOPTS_VALUE) {

                av_log(NULL, AV_LOG_ERROR,

                       ""Could not seek to relative position since current ""

                       ""timestamp is not defined\n"");

                ret = AVERROR(EINVAL);



            target = *cur_ts + interval->start;

        } else {

            target = interval->start;




        av_log(NULL, AV_LOG_VERBOSE, ""Seeking to read interval start point %s\n"",

               av_ts2timestr(target, &AV_TIME_BASE_Q));

        if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) {

            av_log(NULL, AV_LOG_ERROR, ""Could not seek to position %""PRId64"": %s\n"",

                   interval->start, av_err2str(ret));






    frame = av_frame_alloc();





    while (!av_read_frame(fmt_ctx, &pkt)) {

        if (selected_streams[pkt.stream_index]) {

            AVRational tb = fmt_ctx->streams[pkt.stream_index]->time_base;



            if (pkt.pts != AV_NOPTS_VALUE)

                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);



            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {

                start = *cur_ts;

                has_start = 1;




            if (has_start && !has_end && interval->end_is_offset) {

                end = start + interval->end;

                has_end = 1;




            if (interval->end_is_offset && interval->duration_frames) {

                if (frame_count >= interval->end)

                    break;

            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {

                break;




            frame_count++;

            if (do_read_packets) {

                if (do_show_packets)

                    show_packet(w, fmt_ctx, &pkt, i++);

                nb_streams_packets[pkt.stream_index]++;


            if (do_read_frames) {

                pkt1 = pkt;

                while (pkt1.size && process_frame(w, fmt_ctx, frame, &pkt1) > 0);



        av_free_packet(&pkt);


    av_init_packet(&pkt);

    pkt.data = NULL;

    pkt.size = 0;

    //Flush remaining frames that are cached in the decoder

    for (i = 0; i < fmt_ctx->nb_streams; i++) {

        pkt.stream_index = i;

        if (do_read_frames)

            while (process_frame(w, fmt_ctx, frame, &pkt) > 0);




end:

    av_frame_free(&frame);

    if (ret < 0) {

        av_log(NULL, AV_LOG_ERROR, ""Could not read packets in interval "");

        log_read_interval(interval, NULL, AV_LOG_ERROR);


    return ret;
",592,,LABEL_1,LABEL_1,LABEL_1,-1,"w,fmt_ctx,interval,cur_ts,pkt,pkt1,frame,target,frame_count,i,stream_index",,,,0,,0,GA,2238,0.7882758378982544,failed,
62,"static int output_packet(InputStream *ist,

                         OutputStream *ost_table, int nb_ostreams,

                         const AVPacket *pkt)

{

    int ret = 0, i;

    int got_output;

    int64_t pkt_pts = AV_NOPTS_VALUE;



    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->dts;

    if (ist->next_pts == AV_NOPTS_VALUE)

        ist->next_pts = ist->pts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE) {

        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);

        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)

            ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);

    }

    if(pkt->pts != AV_NOPTS_VALUE)

        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int duration;

    handle_eof:



        ist->pts = ist->next_pts;

        ist->dts = ist->next_dts;



        if (avpkt.size && avpkt.size != pkt->size) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d\n"", pkt->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->st->codec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = transcode_audio    (ist, &avpkt, &got_output);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = transcode_video    (ist, &avpkt, &got_output, &pkt_pts);

            if (avpkt.duration) {

                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            } else if(ist->st->codec->time_base.num != 0) {

                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;

                duration = ((int64_t)AV_TIME_BASE *

                                ist->st->codec->time_base.num * ticks) /

                                ist->st->codec->time_base.den;

            } else

                duration = 0;



            if(ist->dts != AV_NOPTS_VALUE && duration) {

                ist->next_dts += duration;

            }else

                ist->next_dts = AV_NOPTS_VALUE;



            if (got_output)

                ist->next_pts += duration; //FIXME the duration is not correct in some cases

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &got_output);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;



        avpkt.dts=

        avpkt.pts= AV_NOPTS_VALUE;



        // touch data and size only if not EOF

        if (pkt) {

            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)

                ret = avpkt.size;

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        rate_emu_sleep(ist);

        ist->dts = ist->next_dts;

        switch (ist->st->codec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /

                             ist->st->codec->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (pkt->duration) {

                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);

            } else if(ist->st->codec->time_base.num != 0) {

                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->st->codec->time_base.num * ticks) /

                                  ist->st->codec->time_base.den;

            }

            break;

        }

        ist->pts = ist->dts;

        ist->next_pts = ist->next_dts;

    }

    for (i = 0; pkt && i < nb_ostreams; i++) {

        OutputStream *ost = &ost_table[i];



        if (!check_output_constraints(ist, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(ist, ost, pkt);

    }



    return 0;

}
",979,,LABEL_1,LABEL_0,,-4,"ist,ost_table,nb_ostreams,pkt,i,got_output,avpkt,duration",,,,0,,0,Greedy,1,0.0010277549425760904,,
63,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
",30,,LABEL_0,LABEL_0,LABEL_0,-1,"sd,addr",,,,0,,0,GA,427,0.11001435120900473,failed,
64,"static int vqa_decode_init(AVCodecContext *avctx)

{

    VqaContext *s = (VqaContext *)avctx->priv_data;

    unsigned char *vqa_header;

    int i, j, codebook_index;;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    avctx->has_b_frames = 0;

    dsputil_init(&s->dsp, avctx);



    /* make sure the extradata made it */

    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d\n"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    vqa_header = (unsigned char *)s->avctx->extradata;

    s->vqa_version = vqa_header[0];

    s->width = LE_16(&vqa_header[6]);

    s->height = LE_16(&vqa_header[8]);





    s->vector_width = vqa_header[10];

    s->vector_height = vqa_header[11];

    s->partial_count = s->partial_countdown = vqa_header[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((s->vector_width != 4) ||

        ((s->vector_height != 2) && (s->vector_height != 4))) {

        /* return without further initialization */





    /* allocate codebooks */

    s->codebook_size = MAX_CODEBOOK_SIZE;

    s->codebook = av_malloc(s->codebook_size);

    s->next_codebook_buffer = av_malloc(s->codebook_size);



    /* initialize the solid-color vectors */

    if (s->vector_height == 4) {

        codebook_index = 0xFF00 * 16;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 16; j++)

                s->codebook[codebook_index++] = i;

    } else {

        codebook_index = 0xF00 * 8;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 8; j++)

                s->codebook[codebook_index++] = i;


    s->next_codebook_buffer_index = 0;



    /* allocate decode buffer */

    s->decode_buffer_size = (s->width / s->vector_width) *

        (s->height / s->vector_height) * 2;

    s->decode_buffer = av_malloc(s->decode_buffer_size);



    s->frame.data[0] = NULL;



    return 0;
",502,"static int vqa_decode_init(AVCodecContext *abcmp)

{

    VqaContext *s = (VqaContext *)abcmp->priv_data;

    unsigned char *vqa_header;

    int i, j, codeBOOK_i;;



    s->abcmp = abcmp;

    abcmp->pix_fmt = PIX_FMT_PAL8;

    abcmp->has_b_frames = 0;

    dsputil_init(&s->dsp, abcmp);



    /* make sure the extradata made it */

    if (s->abcmp->extradata_size != VQA_HEADER_SIZE) {

        av_log(s->abcmp, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d
"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    vqa_header = (unsigned char *)s->abcmp->extradata;

    s->vqa_version = vqa_header[0];

    s->width = LE_16(&vqa_header[6]);

    s->height = LE_16(&vqa_header[8]);





    s->vector_width = vqa_header[10];

    s->vector_height = vqa_header[11];

    s->partial_count = s->partial_countdown = vqa_header[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((s->vector_width != 4) ||

        ((s->vector_height != 2) && (s->vector_height != 4))) {

        /* return without further initialization */





    /* allocate codebooks */

    s->codebook_size = MAX_CODEBOOK_SIZE;

    s->codebook = av_malloc(s->codebook_size);

    s->next_codebook_buffer = av_malloc(s->codebook_size);



    /* initialize the solid-color vectors */

    if (s->vector_height == 4) {

        codeBOOK_i = 0xFF00 * 16;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 16; j++)

                s->codebook[codeBOOK_i++] = i;

    } else {

        codeBOOK_i = 0xF00 * 8;

        for (i = 0; i < 256; i++)

            for (j = 0; j < 8; j++)

                s->codebook[codeBOOK_i++] = i;


    s->next_codebook_buffer_index = 0;



    /* allocate decode buffer */

    s->decode_buffer_size = (s->width / s->vector_width) *

        (s->height / s->vector_height) * 2;

    s->decode_buffer = av_malloc(s->decode_buffer_size);



    s->frame.data[0] = NULL;



    return 0;
",LABEL_1,LABEL_1,LABEL_0,1,"avctx,s,vqa_header,i,j,codebook_index",,,,57,"avctx:abcmp,s:s,vqa_header:vqa_header,i:i,j:j,codebook_index:codeBOOK_i,",4,GA,437,0.14119753042856853,GA,
65,"void rgb15to16(const uint8_t *src,uint8_t *dst,uint32_t src_size)

{

#ifdef HAVE_MMX

  register const char* s=src+src_size;

  register char* d=dst+src_size;

  register int offs=-src_size;

  __asm __volatile(PREFETCH""	%0""::""m""(*(s+offs)):""memory"");

  __asm __volatile(

	""movq	%0, %%mm4\n\t""

	""movq	%1, %%mm5""

	::""m""(mask15b), ""m""(mask15rg):""memory"");

  while(offs<0)

  {

	__asm __volatile(

		PREFETCH""	32%1\n\t""

		""movq	%1, %%mm0\n\t""

		""movq	8%1, %%mm2\n\t""

		""movq	%%mm0, %%mm1\n\t""

		""movq	%%mm2, %%mm3\n\t""

		""pand	%%mm4, %%mm0\n\t""

		""pand	%%mm5, %%mm1\n\t""

		""pand	%%mm4, %%mm2\n\t""

		""pand	%%mm5, %%mm3\n\t""

		""psllq	$1, %%mm1\n\t""

		""psllq	$1, %%mm3\n\t""

		""por	%%mm1, %%mm0\n\t""

		""por	%%mm3, %%mm2\n\t""

		MOVNTQ""	%%mm0, %0\n\t""

		MOVNTQ""	%%mm2, 8%0""

		:""=m""(*(d+offs))

		:""m""(*(s+offs))

		:""memory"");

	offs+=16;

  }

  __asm __volatile(SFENCE:::""memory"");

  __asm __volatile(EMMS:::""memory"");

#else

   const uint16_t *s1=( uint16_t * )src;

   uint16_t *d1=( uint16_t * )dst;

   uint16_t *e=((uint8_t *)s1)+src_size;

   while( s1<e ){

     register int x=*( s1++ );

     /* rrrrrggggggbbbbb

        0rrrrrgggggbbbbb

        0111 1111 1110 0000=0x7FE0

        00000000000001 1111=0x001F */

     *( d1++ )=( x&0x001F )|( ( x&0x7FE0 )<<1 );

   }

#endif

}
",392,,LABEL_0,LABEL_1,,-4,"src,dst,src_size,s,d,m,memory,s1,d1,e",,,,0,,0,Greedy,1,0.0007138371467590332,,
66,"static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}
",211,,LABEL_0,LABEL_0,LABEL_0,-1,"is,vp,i",,,,0,,0,GA,719,0.20379263957341512,failed,
67,"void ff_dsputil_init_alpha(DSPContext* c, AVCodecContext *avctx)

{

    const int high_bit_depth = avctx->bits_per_raw_sample > 8;



    if (!high_bit_depth) {

    c->put_pixels_tab[0][0] = put_pixels16_axp_asm;

    c->put_pixels_tab[0][1] = put_pixels16_x2_axp;

    c->put_pixels_tab[0][2] = put_pixels16_y2_axp;

    c->put_pixels_tab[0][3] = put_pixels16_xy2_axp;



    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_axp_asm;

    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_axp;

    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_axp;

    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_axp;



    c->avg_pixels_tab[0][0] = avg_pixels16_axp;

    c->avg_pixels_tab[0][1] = avg_pixels16_x2_axp;

    c->avg_pixels_tab[0][2] = avg_pixels16_y2_axp;

    c->avg_pixels_tab[0][3] = avg_pixels16_xy2_axp;



    c->avg_no_rnd_pixels_tab[0][0] = avg_no_rnd_pixels16_axp;

    c->avg_no_rnd_pixels_tab[0][1] = avg_no_rnd_pixels16_x2_axp;

    c->avg_no_rnd_pixels_tab[0][2] = avg_no_rnd_pixels16_y2_axp;

    c->avg_no_rnd_pixels_tab[0][3] = avg_no_rnd_pixels16_xy2_axp;



    c->put_pixels_tab[1][0] = put_pixels_axp_asm;

    c->put_pixels_tab[1][1] = put_pixels_x2_axp;

    c->put_pixels_tab[1][2] = put_pixels_y2_axp;

    c->put_pixels_tab[1][3] = put_pixels_xy2_axp;



    c->put_no_rnd_pixels_tab[1][0] = put_pixels_axp_asm;

    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels_x2_axp;

    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels_y2_axp;

    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels_xy2_axp;



    c->avg_pixels_tab[1][0] = avg_pixels_axp;

    c->avg_pixels_tab[1][1] = avg_pixels_x2_axp;

    c->avg_pixels_tab[1][2] = avg_pixels_y2_axp;

    c->avg_pixels_tab[1][3] = avg_pixels_xy2_axp;



    c->avg_no_rnd_pixels_tab[1][0] = avg_no_rnd_pixels_axp;

    c->avg_no_rnd_pixels_tab[1][1] = avg_no_rnd_pixels_x2_axp;

    c->avg_no_rnd_pixels_tab[1][2] = avg_no_rnd_pixels_y2_axp;

    c->avg_no_rnd_pixels_tab[1][3] = avg_no_rnd_pixels_xy2_axp;



    c->clear_blocks = clear_blocks_axp;

    }



    /* amask clears all bits that correspond to present features.  */

    if (amask(AMASK_MVI) == 0) {

        c->put_pixels_clamped = put_pixels_clamped_mvi_asm;

        c->add_pixels_clamped = add_pixels_clamped_mvi_asm;



        if (!high_bit_depth)

            c->get_pixels   = get_pixels_mvi;

        c->diff_pixels      = diff_pixels_mvi;

        c->sad[0]           = pix_abs16x16_mvi_asm;

        c->sad[1]           = pix_abs8x8_mvi;

        c->pix_abs[0][0]    = pix_abs16x16_mvi_asm;

        c->pix_abs[1][0]    = pix_abs8x8_mvi;

        c->pix_abs[0][1]    = pix_abs16x16_x2_mvi;

        c->pix_abs[0][2]    = pix_abs16x16_y2_mvi;

        c->pix_abs[0][3]    = pix_abs16x16_xy2_mvi;

    }



    put_pixels_clamped_axp_p = c->put_pixels_clamped;

    add_pixels_clamped_axp_p = c->add_pixels_clamped;



    if (avctx->bits_per_raw_sample <= 8 &&

        (avctx->idct_algo == FF_IDCT_AUTO ||

         avctx->idct_algo == FF_IDCT_SIMPLEALPHA)) {

        c->idct_put = ff_simple_idct_put_axp;

        c->idct_add = ff_simple_idct_add_axp;

        c->idct =     ff_simple_idct_axp;

    }

}
",660,,LABEL_0,LABEL_0,LABEL_0,-1,"c,avctx",,,,0,,0,GA,399,0.15174737373987834,failed,
68,"static int huf_uncompress(GetByteContext *gb,

                          uint16_t *dst, int dst_size)

{

    int32_t src_size, im, iM;

    uint32_t nBits;

    uint64_t *freq;

    HufDec *hdec;

    int ret, i;



    src_size = bytestream2_get_le32(gb);

    im = bytestream2_get_le32(gb);

    iM = bytestream2_get_le32(gb);

    bytestream2_skip(gb, 4);

    nBits = bytestream2_get_le32(gb);

    if (im < 0 || im >= HUF_ENCSIZE ||

        iM < 0 || iM >= HUF_ENCSIZE ||

        src_size < 0)

        return AVERROR_INVALIDDATA;



    bytestream2_skip(gb, 4);



    freq = av_calloc(HUF_ENCSIZE, sizeof(*freq));

    hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec));

    if (!freq || !hdec) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }



    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)

        goto fail;



    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {

        ret = AVERROR_INVALIDDATA;

        goto fail;

    }



    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)

        goto fail;

    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);



fail:

    for (i = 0; i < HUF_DECSIZE; i++) {

        if (hdec[i].p)

            av_freep(&hdec[i].p);

    }



    av_free(freq);

    av_free(hdec);



    return ret;

}
",293,,LABEL_1,LABEL_0,,-4,"gb,dst,dst_size,src_size,im,iM,nBits,freq,hdec,ret,i",,,,0,,0,Greedy,1,0.0006274064381917318,,
69,"const AVOption *av_opt_next(void *obj, const AVOption *last)

{

    AVClass *class = *(AVClass**)obj;

    if (!last && class->option[0].name) return class->option;

    if (last && last[1].name)           return ++last;

    return NULL;

}
",69,,LABEL_1,LABEL_0,,-4,"obj,last,class",,,,0,,0,Greedy,1,0.000460962454477946,,
70,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)

{

    uint8_t *old_code_ptr = s->code_ptr;

    assert(ret != arg);

#if TCG_TARGET_REG_BITS == 32

    tcg_out_op_t(s, INDEX_op_mov_i32);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    tcg_out_r(s, ret);

    tcg_out_r(s, arg);

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}
",77,,LABEL_0,LABEL_0,LABEL_0,-1,"s,type,ret,arg,old_code_ptr",,,,0,,0,GA,913,0.2435983459154765,failed,
71,"void mcf_uart_write(void *opaque, target_phys_addr_t addr,

                    uint64_t val, unsigned size)

{

    mcf_uart_state *s = (mcf_uart_state *)opaque;

    switch (addr & 0x3f) {

    case 0x00:

        s->mr[s->current_mr] = val;

        s->current_mr = 1;

        break;

    case 0x04:

        /* CSR is ignored.  */

        break;

    case 0x08: /* Command Register.  */

        mcf_do_command(s, val);

        break;

    case 0x0c: /* Transmit Buffer.  */

        s->sr &= ~MCF_UART_TxEMP;

        s->tb = val;

        mcf_uart_do_tx(s);

        break;

    case 0x10:

        /* ACR is ignored.  */

        break;

    case 0x14:

        s->imr = val;

        break;

    default:

        break;

    }

    mcf_uart_update(s);

}
",159,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,val,size,s",,,,0,,0,GA,1014,0.27845587730407717,failed,
72,"void qemu_file_set_error(QEMUFile *f, int ret)

{

    if (f->last_error == 0) {

        f->last_error = ret;

    }

}
",30,,LABEL_1,LABEL_0,,-4,"f,ret",,,,0,,0,Greedy,1,0.00045697689056396485,,
73,"static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)

{

    int16_t *block = ctx->dct_block;

    unsigned int pos;



    ctx->bdsp.clear_block(block);



    block[0] = get_bits(&ctx->gb, 8) << 3;



    for (pos = 1; pos < num_coeffs; pos++) {

        uint32_t vlc, num_bits;

        int value;

        int coeff;



        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);

        if (!vlc) /* end-of-block code */

            return 0;

        if (vlc == -1)

            return AVERROR_INVALIDDATA;



        /* pos_add and num_bits are coded in the vlc code */

        pos     += vlc & 15; // pos_add

        num_bits = vlc >> 4; // num_bits



        if (pos >= 64)

            return AVERROR_INVALIDDATA;



        value = get_bits(&ctx->gb, num_bits);



        /* FFmpeg's IDCT behaves somewhat different from the original code, so

         * a factor of 4 was added to the input */



        coeff = vlcdec_lookup[num_bits][value];

        if (pos < 3)

            coeff *= 16;

        else /* TODO Use >> 10 instead of / 1001 */

            coeff = (coeff * qscale) / 1001;



        block[ctx->scantable.permutated[pos]] = coeff;

    }



    return 0;

}
",280,,LABEL_1,LABEL_0,,-4,"ctx,num_coeffs,qscale,block,pos,vlc,num_bits,value,coeff",,,,0,,0,Greedy,1,0.0006152908007303874,,
74,"av_cold void ff_dct_init_x86(DCTContext *s)

{

    int cpu_flags = av_get_cpu_flags();



    if (EXTERNAL_SSE(cpu_flags))

        s->dct32 = ff_dct32_float_sse;

    if (EXTERNAL_SSE2(cpu_flags))

        s->dct32 = ff_dct32_float_sse2;

    if (EXTERNAL_AVX(cpu_flags))

        s->dct32 = ff_dct32_float_avx;

}
",56,,LABEL_0,LABEL_0,LABEL_0,-1,s,,,,0,,0,GA,240,0.05773337284723918,failed,
75,"int net_init_socket(const NetClientOptions *opts, const char *name,

                    NetClientState *peer, Error **errp)

{

    /* FIXME error_setg(errp, ...) on failure */

    Error *err = NULL;

    const NetdevSocketOptions *sock;



    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_SOCKET);

    sock = opts->socket;



    if (sock->has_fd + sock->has_listen + sock->has_connect + sock->has_mcast +

        sock->has_udp != 1) {

        error_report(""exactly one of fd=, listen=, connect=, mcast= or udp=""

                     "" is required"");

        return -1;

    }



    if (sock->has_localaddr && !sock->has_mcast && !sock->has_udp) {

        error_report(""localaddr= is only valid with mcast= or udp="");

        return -1;

    }



    if (sock->has_fd) {

        int fd;



        fd = monitor_fd_param(cur_mon, sock->fd, &err);

        if (fd == -1) {

            error_report_err(err);

            return -1;

        }

        qemu_set_nonblock(fd);

        if (!net_socket_fd_init(peer, ""socket"", name, fd, 1)) {

            return -1;

        }

        return 0;

    }



    if (sock->has_listen) {

        if (net_socket_listen_init(peer, ""socket"", name, sock->listen) == -1) {

            return -1;

        }

        return 0;

    }



    if (sock->has_connect) {

        if (net_socket_connect_init(peer, ""socket"", name, sock->connect) ==

            -1) {

            return -1;

        }

        return 0;

    }



    if (sock->has_mcast) {

        /* if sock->localaddr is missing, it has been initialized to ""all bits

         * zero"" */

        if (net_socket_mcast_init(peer, ""socket"", name, sock->mcast,

            sock->localaddr) == -1) {

            return -1;

        }

        return 0;

    }



    assert(sock->has_udp);

    if (!sock->has_localaddr) {

        error_report(""localaddr= is mandatory with udp="");

        return -1;

    }

    if (net_socket_udp_init(peer, ""socket"", name, sock->udp, sock->localaddr) ==

        -1) {

        return -1;

    }

    return 0;

}
",412,,LABEL_0,LABEL_0,LABEL_0,-1,"opts,name,peer,errp,err,sock,fd",,,,0,,0,GA,1646,0.5211796323458354,failed,
76,"static inline int test_bit(uint32_t *field, int bit)

{

    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}
",34,,LABEL_0,LABEL_0,LABEL_0,-1,"field,bit",,,,0,,0,GA,450,0.1174198031425476,failed,
77,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
",39,,LABEL_0,LABEL_0,LABEL_0,-1,qi,,,,0,,0,GA,253,0.06372912724812825,failed,
78,"static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,

                               TCGMemOp s_bits, int which)

{

    const TCGReg r0 = TCG_REG_O0;

    const TCGReg r1 = TCG_REG_O1;

    const TCGReg r2 = TCG_REG_O2;

    int tlb_ofs;



    /* Shift the page number down.  */

    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);



    /* Mask out the page offset, except for the required alignment.  */

    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,

                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));



    /* Mask the tlb index.  */

    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);

    

    /* Mask page, part 2.  */

    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);



    /* Shift the tlb index into place.  */

    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);



    /* Relative to the current ENV.  */

    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);



    /* Find a base address that can load both tlb comparator and addend.  */

    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);

    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {

        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);

        tlb_ofs &= 0x3ff;

    }



    /* Load the tlb comparator and the addend.  */

    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);

    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));



    /* subcc arg0, arg2, %g0 */

    tcg_out_cmp(s, r0, r2, 0);



    /* If the guest address must be zero-extended, do so now.  */

    if (SPARC64 && TARGET_LONG_BITS == 32) {

        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);

        return r0;

    }

    return addr;

}
",378,,LABEL_0,LABEL_0,LABEL_0,-1,"s,addr,mem_index,s_bits,which,tlb_ofs",,,,0,,0,GA,1267,0.3898380319277445,failed,
79,"static int mxf_read_header(AVFormatContext *s)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket klv;

    int64_t essence_offset = 0;

    int ret;



    mxf->last_forward_tell = INT64_MAX;

    mxf->edit_units_per_packet = 1;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!url_feof(s->pb)) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&klv, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", klv.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""\n"", klv.length, klv.offset);

        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_system_item_key)) {



            if (!mxf->current_partition) {

                av_log(mxf->fc, AV_LOG_ERROR, ""found essence prior to first PartitionPack\n"");

                return AVERROR_INVALIDDATA;

            }



            if (!mxf->current_partition->essence_offset) {

                /* for OP1a we compute essence_offset

                 * for OPAtom we point essence_offset after the KL (usually op1a_essence_offset + 20 or 25)

                 * TODO: for OP1a we could eliminate this entire if statement, always stopping parsing at op1a_essence_offset

                 *       for OPAtom we still need the actual essence_offset though (the KL's length can vary)

                 */

                int64_t op1a_essence_offset =

                    round_to_kag(mxf->current_partition->this_partition +

                                 mxf->current_partition->pack_length,       mxf->current_partition->kag_size) +

                    round_to_kag(mxf->current_partition->header_byte_count, mxf->current_partition->kag_size) +

                    round_to_kag(mxf->current_partition->index_byte_count,  mxf->current_partition->kag_size);



                if (mxf->op == OPAtom) {

                    /* point essence_offset to the actual data

                    * OPAtom has all the essence in one big KLV

                    */

                    mxf->current_partition->essence_offset = avio_tell(s->pb);

                    mxf->current_partition->essence_length = klv.length;

                } else {

                    /* NOTE: op1a_essence_offset may be less than to klv.offset (C0023S01.mxf)  */

                    mxf->current_partition->essence_offset = op1a_essence_offset;

                }

            }



            if (!essence_offset)

                essence_offset = klv.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(mxf) <= 0)

                break;

            continue;

        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&

                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else if (mxf->parsing_backward)

                continue;

            /* we're still parsing forward. proceed to parsing this partition pack */

        }



        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {

            if (IS_KLV_KEY(klv.key, metadata->key)) {

                int res;

                if (klv.key[5] == 0x53) {

                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);

                } else {

                    uint64_t next = avio_tell(s->pb) + klv.length;

                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);



                    /* only seek forward, else this can loop for a long time */

                    if (avio_tell(s->pb) > next) {

                        av_log(s, AV_LOG_ERROR, ""read past end of KLV @ %#""PRIx64""\n"",

                               klv.offset);

                        return AVERROR_INVALIDDATA;

                    }



                    avio_seek(s->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(s, AV_LOG_ERROR, ""error reading header metadata\n"");

                    return res;

                }

                break;

            }

        }

        if (!metadata->read)

            avio_skip(s->pb, klv.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(s, AV_LOG_ERROR, ""no essence\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(mxf);



    /* we need to do this before computing the index tables

     * to be able to fill in zero IndexDurations with st->duration */

    if ((ret = mxf_parse_structural_metadata(mxf)) < 0)

        return ret;



    if ((ret = mxf_compute_index_tables(mxf)) < 0)

        return ret;



    if (mxf->nb_index_tables > 1) {

        /* TODO: look up which IndexSID to use via EssenceContainerData */

        av_log(mxf->fc, AV_LOG_INFO, ""got %i index tables - only the first one (IndexSID %i) will be used\n"",

               mxf->nb_index_tables, mxf->index_tables[0].index_sid);

    } else if (mxf->nb_index_tables == 0 && mxf->op == OPAtom) {

        av_log(mxf->fc, AV_LOG_ERROR, ""cannot demux OPAtom without an index\n"");

        return AVERROR_INVALIDDATA;

    }



    mxf_handle_small_eubc(s);



    return 0;

}
",1113,,LABEL_1,LABEL_0,,-4,"s,mxf,klv,ret,metadata",,,,0,,0,Greedy,1,0.0011283516883850097,,
80,"static int qsv_decode_init(AVCodecContext *avctx, QSVContext *q)

{

    const AVPixFmtDescriptor *desc;

    mfxSession session = NULL;

    int iopattern = 0;

    mfxVideoParam param = { { 0 } };

    int frame_width  = avctx->coded_width;

    int frame_height = avctx->coded_height;

    int ret;



    desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);

    if (!desc)

        return AVERROR_BUG;



    if (!q->async_fifo) {

        q->async_fifo = av_fifo_alloc((1 + q->async_depth) *

                                      (sizeof(mfxSyncPoint*) + sizeof(QSVFrame*)));

        if (!q->async_fifo)

            return AVERROR(ENOMEM);

    }



    if (avctx->pix_fmt == AV_PIX_FMT_QSV && avctx->hwaccel_context) {

        AVQSVContext *user_ctx = avctx->hwaccel_context;

        session           = user_ctx->session;

        iopattern         = user_ctx->iopattern;

        q->ext_buffers    = user_ctx->ext_buffers;

        q->nb_ext_buffers = user_ctx->nb_ext_buffers;

    }



    if (avctx->hw_frames_ctx) {

        AVHWFramesContext    *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

        AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;



        if (!iopattern) {

            if (frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME)

                iopattern = MFX_IOPATTERN_OUT_OPAQUE_MEMORY;

            else if (frames_hwctx->frame_type & MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET)

                iopattern = MFX_IOPATTERN_OUT_VIDEO_MEMORY;

        }



        frame_width  = frames_hwctx->surfaces[0].Info.Width;

        frame_height = frames_hwctx->surfaces[0].Info.Height;

    }



    if (!iopattern)

        iopattern = MFX_IOPATTERN_OUT_SYSTEM_MEMORY;

    q->iopattern = iopattern;



    ret = qsv_init_session(avctx, q, session, avctx->hw_frames_ctx);

    if (ret < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Error initializing an MFX session\n"");

        return ret;

    }



    ret = ff_qsv_codec_id_to_mfx(avctx->codec_id);

    if (ret < 0)

        return ret;



    param.mfx.CodecId      = ret;

    param.mfx.CodecProfile = avctx->profile;

    param.mfx.CodecLevel   = avctx->level;



    param.mfx.FrameInfo.BitDepthLuma   = desc->comp[0].depth;

    param.mfx.FrameInfo.BitDepthChroma = desc->comp[0].depth;

    param.mfx.FrameInfo.Shift          = desc->comp[0].depth > 8;

    param.mfx.FrameInfo.FourCC         = q->fourcc;

    param.mfx.FrameInfo.Width          = frame_width;

    param.mfx.FrameInfo.Height         = frame_height;

    param.mfx.FrameInfo.ChromaFormat   = MFX_CHROMAFORMAT_YUV420;



    param.IOPattern   = q->iopattern;

    param.AsyncDepth  = q->async_depth;

    param.ExtParam    = q->ext_buffers;

    param.NumExtParam = q->nb_ext_buffers;



    ret = MFXVideoDECODE_Init(q->session, &param);

    if (ret < 0)

        return ff_qsv_print_error(avctx, ret,

                                  ""Error initializing the MFX video decoder"");



    q->frame_info = param.mfx.FrameInfo;



    return 0;

}
",565,,LABEL_0,LABEL_1,,-4,"avctx,q,desc,ret,user_ctx,frames_ctx,frames_hwctx",,,,0,,0,Greedy,1,0.0008009672164916992,,
81,"int swr_init(struct SwrContext *s){

    s->in_buffer_index= 0;

    s->in_buffer_count= 0;

    s->resample_in_constraint= 0;

    free_temp(&s->postin);

    free_temp(&s->midbuf);

    free_temp(&s->preout);

    free_temp(&s->in_buffer);

    swri_audio_convert_free(&s-> in_convert);

    swri_audio_convert_free(&s->out_convert);

    swri_audio_convert_free(&s->full_convert);



    s-> in.planar= av_sample_fmt_is_planar(s-> in_sample_fmt);

    s->out.planar= av_sample_fmt_is_planar(s->out_sample_fmt);

    s-> in_sample_fmt= av_get_alt_sample_fmt(s-> in_sample_fmt, 0);

    s->out_sample_fmt= av_get_alt_sample_fmt(s->out_sample_fmt, 0);



    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){

        av_log(s, AV_LOG_ERROR, ""Requested sample format %s is invalid\n"", av_get_sample_fmt_name(s->in_sample_fmt));

        return AVERROR(EINVAL);

    }

    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){

        av_log(s, AV_LOG_ERROR, ""Requested sample format %s is invalid\n"", av_get_sample_fmt_name(s->out_sample_fmt));

        return AVERROR(EINVAL);

    }



    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16

        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLT){

        av_log(s, AV_LOG_ERROR, ""Requested sample format %s is not supported internally, only float & S16 is supported\n"", av_get_sample_fmt_name(s->int_sample_fmt));

        return AVERROR(EINVAL);

    }



    //FIXME should we allow/support using FLT on material that doesnt need it ?

    if(s->in_sample_fmt <= AV_SAMPLE_FMT_S16 || s->int_sample_fmt==AV_SAMPLE_FMT_S16){

        s->int_sample_fmt= AV_SAMPLE_FMT_S16;

    }else

        s->int_sample_fmt= AV_SAMPLE_FMT_FLT;





    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){

        s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, 16, 10, 0, 0.8);

    }else

        swri_resample_free(&s->resample);

    if(s->int_sample_fmt != AV_SAMPLE_FMT_S16 && s->resample){

        av_log(s, AV_LOG_ERROR, ""Resampling only supported with internal s16 currently\n""); //FIXME

        return -1;

    }



    if(!s->used_ch_count)

        s->used_ch_count= s->in.ch_count;



    if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){

        av_log(s, AV_LOG_WARNING, ""Input channel layout has a different number of channels than the number of used channels, ignoring layout\n"");

        s-> in_ch_layout= 0;

    }



    if(!s-> in_ch_layout)

        s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count);

    if(!s->out_ch_layout)

        s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count);



    s->rematrix= s->out_ch_layout  !=s->in_ch_layout || s->rematrix_volume!=1.0;



#define RSC 1 //FIXME finetune

    if(!s-> in.ch_count)

        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);

    if(!s->used_ch_count)

        s->used_ch_count= s->in.ch_count;

    if(!s->out.ch_count)

        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);



av_assert0(s-> in.ch_count);

av_assert0(s->used_ch_count);

av_assert0(s->out.ch_count);

    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;



    s-> in.bps= av_get_bytes_per_sample(s-> in_sample_fmt);

    s->int_bps= av_get_bytes_per_sample(s->int_sample_fmt);

    s->out.bps= av_get_bytes_per_sample(s->out_sample_fmt);



    if(!s->resample && !s->rematrix && !s->channel_map){

        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,

                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);

        return 0;

    }



    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,

                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);

    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,

                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);





    s->postin= s->in;

    s->preout= s->out;

    s->midbuf= s->in;

    s->in_buffer= s->in;

    if(s->channel_map){

        s->postin.ch_count=

        s->midbuf.ch_count=

        s->in_buffer.ch_count= s->used_ch_count;

    }

    if(!s->resample_first){

        s->midbuf.ch_count= s->out.ch_count;

        s->in_buffer.ch_count = s->out.ch_count;

    }



    s->in_buffer.bps = s->postin.bps = s->midbuf.bps = s->preout.bps =  s->int_bps;

    s->in_buffer.planar = s->postin.planar = s->midbuf.planar = s->preout.planar =  1;





    if(s->rematrix)

        return swri_rematrix_init(s);



    return 0;

}
",1071,,LABEL_1,LABEL_0,,-4,s,,,,0,,0,Greedy,1,0.0010722676912943523,,
82,"static av_cold int mp_decode_init(AVCodecContext *avctx)

{

    MotionPixelsContext *mp = avctx->priv_data;

    int w4 = (avctx->width  + 3) & ~3;

    int h4 = (avctx->height + 3) & ~3;



    if(avctx->extradata_size < 2){

        av_log(avctx, AV_LOG_ERROR, ""extradata too small\n"");

        return AVERROR_INVALIDDATA;

    }



    motionpixels_tableinit();

    mp->avctx = avctx;

    ff_dsputil_init(&mp->dsp, avctx);

    mp->changes_map = av_mallocz(avctx->width * h4);

    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;

    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));

    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));



    avctx->pix_fmt = AV_PIX_FMT_RGB555;

    avcodec_get_frame_defaults(&mp->frame);

    return 0;

}",191,"static av_cold int mp_decode_init(AVCodecContext *ovctx)

{

    MotionPixelsContext *cmp = ovctx->priv_data;

    int w4 = (ovctx->width  + 3) & ~3;

    int h4 = (ovctx->height + 3) & ~3;



    if(ovctx->extradata_size < 2){

        av_log(ovctx, AV_LOG_ERROR, ""extradata too small
"");

        return AVERROR_INVALIDDATA;

    }



    motionpixels_tableinit();

    cmp->ovctx = ovctx;

    ff_dsputil_init(&cmp->dsp, ovctx);

    cmp->changes_map = av_mallocz(ovctx->width * h4);

    cmp->offset_bits_len = av_log2(ovctx->width * ovctx->height) + 1;

    cmp->vpt = av_mallocz(ovctx->height * sizeof(YuvPixel));

    cmp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));



    ovctx->pix_fmt = AV_PIX_FMT_RGB555;

    avcodec_get_frame_defaults(&cmp->frame);

    return 0;

}",LABEL_1,LABEL_1,LABEL_0,1,"avctx,mp",,,,0,"avctx:ovctx,mp:cmp,",0,GA,200,0.052748080094655356,GA,
83,"static void gdb_accept(void)

{

    GDBState *s;

    struct sockaddr_in sockaddr;

    socklen_t len;

    int fd;



    for(;;) {

        len = sizeof(sockaddr);

        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);

        if (fd < 0 && errno != EINTR) {

            perror(""accept"");

            return;

        } else if (fd >= 0) {

#ifndef _WIN32

            fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif

            break;

        }

    }



    /* set short latency */

    socket_set_nodelay(fd);



    s = g_malloc0(sizeof(GDBState));

    s->c_cpu = first_cpu;

    s->g_cpu = first_cpu;

    s->fd = fd;

    gdb_has_xml = false;



    gdbserver_state = s;



    fcntl(fd, F_SETFL, O_NONBLOCK);

}
",152,,LABEL_0,LABEL_0,LABEL_0,-1,"s,sockaddr,len,fd",,,,0,,0,GA,948,0.2144872824350993,failed,
84,"envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
",180,,LABEL_1,LABEL_0,,-4,"tmpenv,envvar,envsave",,,,0,,0,Greedy,1,0.0003030061721801758,,
85,"static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,

                                      int do_init,

                                      const char *cpu_model,

                                      uint32_t sysclk)

{

    PowerPCCPU *cpu;

    CPUPPCState *env;

    qemu_irq *irqs;



    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""Unable to initialize CPU!\n"");

        exit(1);

    }

    env = &cpu->env;



    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);



    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    ppcuic_init(env, irqs, 0x0C0, 0, 1);

    return cpu;

}
",177,"static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,

                                      int do_init,

                                      const char *cpu__Model,

                                      uint32_t sysclk)

{

    PowerPCCPU *cpu;

    CPUPPCState *state;

    qemu_irq *ircks;



    ccpu= POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu__Model));

    if (cpu == NULL) {

        fprintf(stderr, ""Unable to initialize CPU!
"");

        exit(1);

    }

    state = &cpu->state;



    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);



    ppc_dcr_init(state, NULL, NULL);



    /* interrupt controller */

    ircks = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irircksPCUIC_OUTPUT_INT] = ((qemu_irq *)state->irq_inputs)[PPC40x_INPUT_INT];

    irircksPCUIC_OUTPUT_CINT] = ((qemu_irq *)state->irq_inputs)[PPC40x_INPUT_CINT];

    ppcuic_init(state, ircks, 0x0C0, 0, 1);

    return cpu;

}
",LABEL_1,LABEL_1,LABEL_0,1,"ram_size,do_init,cpu_model,sysclk,cpu,env,irqs",,,,10,"ram_size:ram_size,do_init:do_init,cpu_model:cpu__Model,sysclk:sysclk,cpu:cpu,env:state,irqs:ircks,",4,GA,331,0.05412379503250122,GA,
86,"static int floppy_probe_device(const char *filename)

{

    int fd, ret;

    int prio = 0;

    struct floppy_struct fdparam;

    struct stat st;



    if (strstart(filename, ""/dev/fd"", NULL) &&

        !strstart(filename, ""/dev/fdset/"", NULL)) {

        prio = 50;

    }



    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);

    if (fd < 0) {

        goto out;

    }

    ret = fstat(fd, &st);

    if (ret == -1 || !S_ISBLK(st.st_mode)) {

        goto outc;

    }



    /* Attempt to detect via a floppy specific ioctl */

    ret = ioctl(fd, FDGETPRM, &fdparam);

    if (ret >= 0)

        prio = 100;



outc:

    qemu_close(fd);

out:

    return prio;

}
",156,,LABEL_1,LABEL_0,,-4,"filename,fd,ret,fdparam,st",,,,0,,0,Greedy,1,0.00029873053232828777,,
87,"static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)

{

    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);

    IntelIOMMUState *s = vtd_as->iommu_state;

    uint8_t bus_n = pci_bus_num(vtd_as->bus);

    VTDContextEntry ce;



    /*

     * The replay can be triggered by either a invalidation or a newly

     * created entry. No matter what, we release existing mappings

     * (it means flushing caches for UNMAP-only registers).

     */

    vtd_address_space_unmap(vtd_as, n);



    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {

        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),

                                  PCI_FUNC(vtd_as->devfn),

                                  VTD_CONTEXT_ENTRY_DID(ce.hi),

                                  ce.hi, ce.lo);

        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);

    } else {

        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),

                                    PCI_FUNC(vtd_as->devfn));

    }



    return;

}
",205,,LABEL_0,LABEL_0,LABEL_0,-1,"iommu_mr,n,vtd_as,s,ce",,,,0,,0,GA,1001,0.23871253728866576,failed,
88,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
",56,"sPAPRDRConnector *spapr_drc_by_index(uint32_t version)

{

    Object *Obj;

    char block[256];



    snprintf(nablocksizeof(nablock ""%s/%x"", DRC_CONTAINER_PATH, version);

    Obj = object_resolve_path(block, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(Obj);

}
",LABEL_0,LABEL_0,LABEL_1,1,"index,obj,name",,,,0,"index:version,obj:Obj,name:block,",0,GA,168,0.04045018752415975,GA,
89,"uint64_t helper_fnmadd (uint64_t arg1, uint64_t arg2, uint64_t arg3)

{

    CPU_DoubleU farg1, farg2, farg3;



    farg1.ll = arg1;

    farg2.ll = arg2;

    farg3.ll = arg3;



    if (unlikely(float64_is_signaling_nan(farg1.d) ||

                 float64_is_signaling_nan(farg2.d) ||

                 float64_is_signaling_nan(farg3.d))) {

        /* sNaN operation */

        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);

    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||

                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {

        /* Multiplication of zero by infinity */

        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);

    } else {

#if USE_PRECISE_EMULATION

#ifdef FLOAT128

        /* This is the way the PowerPC specification defines it */

        float128 ft0_128, ft1_128;



        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);

        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);

        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);

        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&

                     float128_is_neg(ft0_128) != float64_is_neg(farg3.d))) {

            /* Magnitude subtraction of infinities */

            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);

        } else {

            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);

            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);

            farg1.d = float128_to_float64(ft0_128, &env->fp_status);

        }

#else

        /* This is OK on x86 hosts */

        farg1.d = (farg1.d * farg2.d) + farg3.d;

#endif

#else

        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);

        farg1.d = float64_add(farg1.d, farg3.d, &env->fp_status);

#endif

        if (likely(!float64_is_nan(farg1.d)))

            farg1.d = float64_chs(farg1.d);

    }

    return farg1.ll;

}
",409,,LABEL_0,LABEL_0,LABEL_0,-1,"arg1,arg2,arg3,farg1,farg2,farg3,ft0_128,ft1_128",,,,0,,0,GA,1662,0.49007803996404015,failed,
90,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}
",63,,LABEL_0,LABEL_0,LABEL_0,-1,"bs,sector_num,nb_sectors,flags,cb,opaque",,,,0,,0,GA,1038,0.24786216417948406,failed,
91,"CharDriverState *text_console_init(QemuOpts *opts)

{

    CharDriverState *chr;

    QemuConsole *s;

    unsigned width;

    unsigned height;



    chr = g_malloc0(sizeof(CharDriverState));



    width = qemu_opt_get_number(opts, ""width"", 0);

    if (width == 0)

        width = qemu_opt_get_number(opts, ""cols"", 0) * FONT_WIDTH;



    height = qemu_opt_get_number(opts, ""height"", 0);

    if (height == 0)

        height = qemu_opt_get_number(opts, ""rows"", 0) * FONT_HEIGHT;



    if (width == 0 || height == 0) {

        s = new_console(NULL, TEXT_CONSOLE);

    } else {

        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);

    }



    if (!s) {

        g_free(chr);

        return NULL;

    }



    s->chr = chr;

    s->g_width = width;

    s->g_height = height;

    chr->opaque = s;

    chr->chr_set_echo = text_console_set_echo;

    return chr;

}
",180,,LABEL_0,LABEL_1,,-4,"opts,chr,s,height",,,,0,,0,Greedy,1,0.0005330642064412435,,
92,"static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)

{

    return telldir(fs->dir);

}
",23,,LABEL_0,LABEL_0,LABEL_0,-1,"ctx,fs",,,,0,,0,GA,438,0.10051235755284628,failed,
93,"void bios_linker_loader_alloc(GArray *linker,

                              const char *file,

                              uint32_t alloc_align,

                              bool alloc_fseg)

{

    BiosLinkerLoaderEntry entry;



    assert(!(alloc_align & (alloc_align - 1)));



    memset(&entry, 0, sizeof entry);

    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);

    entry.alloc.align = cpu_to_le32(alloc_align);

    entry.alloc.zone = cpu_to_le32(alloc_fseg ?

                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :

                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);



    /* Alloc entries must come first, so prepend them */

    g_array_prepend_vals(linker, &entry, sizeof entry);

}
",128,,LABEL_1,LABEL_0,,-4,"linker,file,alloc_align,alloc_fseg,entry",,,,0,,0,Greedy,1,0.000502002239227295,,
94,"int load_snapshot(const char *name, Error **errp)

{

    BlockDriverState *bs, *bs_vm_state;

    QEMUSnapshotInfo sn;

    QEMUFile *f;

    int ret;

    AioContext *aio_context;

    MigrationIncomingState *mis = migration_incoming_get_current();



    if (!bdrv_all_can_snapshot(&bs)) {

        error_setg(errp,

                   ""Device '%s' is writable but does not support snapshots"",

                   bdrv_get_device_name(bs));

        return -ENOTSUP;

    }

    ret = bdrv_all_find_snapshot(name, &bs);

    if (ret < 0) {

        error_setg(errp,

                   ""Device '%s' does not have the requested snapshot '%s'"",

                   bdrv_get_device_name(bs), name);

        return ret;

    }



    bs_vm_state = bdrv_all_find_vmstate_bs();

    if (!bs_vm_state) {

        error_setg(errp, ""No block device supports snapshots"");

        return -ENOTSUP;

    }

    aio_context = bdrv_get_aio_context(bs_vm_state);



    /* Don't even try to load empty VM states */

    aio_context_acquire(aio_context);

    ret = bdrv_snapshot_find(bs_vm_state, &sn, name);

    aio_context_release(aio_context);

    if (ret < 0) {

        return ret;

    } else if (sn.vm_state_size == 0) {

        error_setg(errp, ""This is a disk-only snapshot. Revert to it ""

                   "" offline using qemu-img"");

        return -EINVAL;

    }



    /* Flush all IO requests so they don't interfere with the new state.  */

    bdrv_drain_all();



    ret = bdrv_all_goto_snapshot(name, &bs);

    if (ret < 0) {

        error_setg(errp, ""Error %d while activating snapshot '%s' on '%s'"",

                     ret, name, bdrv_get_device_name(bs));

        return ret;

    }



    /* restore the VM state */

    f = qemu_fopen_bdrv(bs_vm_state, 0);

    if (!f) {

        error_setg(errp, ""Could not open VM state file"");

        return -EINVAL;

    }



    qemu_system_reset(SHUTDOWN_CAUSE_NONE);

    mis->from_src_file = f;



    aio_context_acquire(aio_context);

    ret = qemu_loadvm_state(f);

    qemu_fclose(f);

    aio_context_release(aio_context);



    migration_incoming_state_destroy();

    if (ret < 0) {

        error_setg(errp, ""Error %d while loading VM state"", ret);

        return ret;

    }



    return 0;

}
",362,,LABEL_1,LABEL_0,,-4,"name,errp,bs,bs_vm_state,sn,f,ret,aio_context,mis",,,,0,,0,Greedy,1,0.0006583611170450847,,
95,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)

{

    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}",56,,LABEL_1,LABEL_1,LABEL_1,-1,"s,pc",,,,0,,0,GA,425,0.09995640118916829,failed,
96,"static int decode_b_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status;



    bitplane_decoding(&v->skip_mb_plane, v);

    if (status < 0) return -1;

#if TRACE

    if (v->mv_mode == MV_PMODE_MIXED_MV)

    {

        status = bitplane_decoding(&v->mv_type_mb_plane, v);

        if (status < 0)

            return -1;

#if TRACE

        av_log(v->s.avctx, AV_LOG_DEBUG, ""MB MV Type plane encoding: ""

               ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif

    }



    //bitplane

    status = bitplane_decoding(&v->direct_mb_plane, v);

    if (status < 0) return -1;

#if TRACE

    av_log(v->s.avctx, AV_LOG_DEBUG, ""MB Direct plane encoding: ""

           ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif



    av_log(v->s.avctx, AV_LOG_DEBUG, ""Skip MB plane encoding: ""

           ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif



    /* FIXME: what is actually chosen for B frames ? */

    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables

    v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)];



    if (v->dquant)

    {

        vop_dquant_decoding(v);

    }



    if (v->vstransform)

    {

        v->ttmbf = get_bits(gb, 1);

        if (v->ttmbf)

        {

            v->ttfrm = get_bits(gb, 2);

            av_log(v->s.avctx, AV_LOG_INFO, ""Transform used: %ix%i\n"",

                   (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8);

        }

    }

    /* Epilog (AC/DC syntax) should be done in caller */

    return 0;

}
",377,,LABEL_1,LABEL_0,,-4,"v,gb,status",,,,0,,0,Greedy,1,0.0006470600763956706,,
97,"int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)

{

    S390CPU *cpu = S390_CPU(cs);

    int ret = 0;



    switch (run->exit_reason) {

        case KVM_EXIT_S390_SIEIC:

            ret = handle_intercept(cpu);

            break;

        case KVM_EXIT_S390_RESET:

            qemu_system_reset_request();

            break;

        case KVM_EXIT_S390_TSCH:

            ret = handle_tsch(cpu);

            break;

        case KVM_EXIT_DEBUG:

            ret = kvm_arch_handle_debug_exit(cpu);

            break;

        default:

            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);

            break;

    }



    if (ret == 0) {

        ret = EXCP_INTERRUPT;

    }

    return ret;

}
",123,,LABEL_0,LABEL_0,LABEL_0,-1,"cs,run,cpu",,,,0,,0,GA,550,0.13838955561319988,failed,
98,"void cpu_loop_exit(CPUState *env1)

{

    env1->current_tb = NULL;

    longjmp(env1->jmp_env, 1);

}
",28,,LABEL_0,LABEL_0,LABEL_0,-1,env1,,,,0,,0,GA,245,0.05692360798517863,failed,
99,"static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)

{

    IscsiLun *iscsilun = bs->opaque;

    struct iscsi_context *iscsi = NULL;

    struct iscsi_url *iscsi_url = NULL;

    struct IscsiTask task;

    char *initiator_name = NULL;

    int ret;



    if ((BDRV_SECTOR_SIZE % 512) != 0) {

        error_report(""iSCSI: Invalid BDRV_SECTOR_SIZE. ""

                     ""BDRV_SECTOR_SIZE(%lld) is not a multiple ""

                     ""of 512"", BDRV_SECTOR_SIZE);

        return -EINVAL;

    }



    iscsi_url = iscsi_parse_full_url(iscsi, filename);

    if (iscsi_url == NULL) {

        error_report(""Failed to parse URL : %s %s"", filename,

                     iscsi_get_error(iscsi));

        ret = -EINVAL;

        goto failed;

    }



    memset(iscsilun, 0, sizeof(IscsiLun));



    initiator_name = parse_initiator_name(iscsi_url->target);



    iscsi = iscsi_create_context(initiator_name);

    if (iscsi == NULL) {

        error_report(""iSCSI: Failed to create iSCSI context."");

        ret = -ENOMEM;

        goto failed;

    }



    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {

        error_report(""iSCSI: Failed to set target name."");

        ret = -EINVAL;

        goto failed;

    }



    if (iscsi_url->user != NULL) {

        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,

                                              iscsi_url->passwd);

        if (ret != 0) {

            error_report(""Failed to set initiator username and password"");

            ret = -EINVAL;

            goto failed;

        }

    }



    /* check if we got CHAP username/password via the options */

    if (parse_chap(iscsi, iscsi_url->target) != 0) {

        error_report(""iSCSI: Failed to set CHAP user/password"");

        ret = -EINVAL;

        goto failed;

    }



    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {

        error_report(""iSCSI: Failed to set session type to normal."");

        ret = -EINVAL;

        goto failed;

    }



    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);



    /* check if we got HEADER_DIGEST via the options */

    parse_header_digest(iscsi, iscsi_url->target);



    task.iscsilun = iscsilun;

    task.status = 0;

    task.complete = 0;

    task.bs = bs;



    iscsilun->iscsi = iscsi;

    iscsilun->lun   = iscsi_url->lun;



    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,

                                 iscsi_connect_cb, &task)

        != 0) {

        error_report(""iSCSI: Failed to start async connect."");

        ret = -EINVAL;

        goto failed;

    }



    while (!task.complete) {

        iscsi_set_events(iscsilun);

        qemu_aio_wait();

    }

    if (task.status != 0) {

        error_report(""iSCSI: Failed to connect to LUN : %s"",

                     iscsi_get_error(iscsi));

        ret = -EINVAL;

        goto failed;

    }



    if (iscsi_url != NULL) {

        iscsi_destroy_url(iscsi_url);

    }



    /* Medium changer or tape. We dont have any emulation for this so this must

     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try

     * to read from the device to guess the image format.

     */

    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||

        iscsilun->type == TYPE_TAPE) {

        bs->sg = 1;

    }



    return 0;



failed:

    if (initiator_name != NULL) {

        g_free(initiator_name);

    }

    if (iscsi_url != NULL) {

        iscsi_destroy_url(iscsi_url);

    }

    if (iscsi != NULL) {

        iscsi_destroy_context(iscsi);

    }

    memset(iscsilun, 0, sizeof(IscsiLun));

    return ret;

}
",614,,LABEL_1,LABEL_0,,-4,"bs,filename,flags,iscsilun,iscsi,iscsi_url,task,initiator_name,ret",,,,0,,0,Greedy,1,0.0008004585901896159,,
100,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",218,"static uint32_t tight_palette_buf2rgb(int rbgp, const uint8_t *comb)

{

    uint32_t rgb = 0;



    if (rbgp == 32) {

        rgb |= ((comb[0] & ~1) | !((comb[4] >> 3) & 1)) << 24;

        rgb |= ((comb[1] & ~1) | !((comb[4] >> 2) & 1)) << 16;

        rgb |= ((comb[2] & ~1) | !((comb[4] >> 1) & 1)) <<  8;

        rgb |= ((comb[3] & ~1) | !((comb[4] >> 0) & 1)) <<  0;

    }

    if (rbgp == 16) {

        rgb |= ((comb[0] & ~1) | !((comb[2] >> 1) & 1)) << 8;

        rgb |= ((comb[1] & ~1) | !((comb[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bpp,buf",,,,0,"bpp:rbgp,buf:comb,",0,GA,209,0.05314904451370239,GA,
101,"int x86_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)

{

    X86CPU *cpu = X86_CPU(cs);

    CPUX86State *env = &cpu->env;

    uint32_t tmp;



    if (n < CPU_NB_REGS) {

        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {

            env->regs[gpr_map[n]] = ldtul_p(mem_buf);

            return sizeof(target_ulong);

        } else if (n < CPU_NB_REGS32) {

            n = gpr_map32[n];

            env->regs[n] &= ~0xffffffffUL;

            env->regs[n] |= (uint32_t)ldl_p(mem_buf);

            return 4;

        }

    } else if (n >= IDX_FP_REGS && n < IDX_FP_REGS + 8) {

#ifdef USE_X86LDOUBLE

        /* FIXME: byteswap float values - after fixing fpregs layout. */

        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);

#endif

        return 10;

    } else if (n >= IDX_XMM_REGS && n < IDX_XMM_REGS + CPU_NB_REGS) {

        n -= IDX_XMM_REGS;

        if (n < CPU_NB_REGS32 ||

            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {

            env->xmm_regs[n].XMM_Q(0) = ldq_p(mem_buf);

            env->xmm_regs[n].XMM_Q(1) = ldq_p(mem_buf + 8);

            return 16;

        }

    } else {

        switch (n) {

        case IDX_IP_REG:

            if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {

                env->eip = ldq_p(mem_buf);

                return 8;

            } else {

                env->eip &= ~0xffffffffUL;

                env->eip |= (uint32_t)ldl_p(mem_buf);

                return 4;

            }

        case IDX_FLAGS_REG:

            env->eflags = ldl_p(mem_buf);

            return 4;



        case IDX_SEG_REGS:

            return x86_cpu_gdb_load_seg(cpu, R_CS, mem_buf);

        case IDX_SEG_REGS + 1:

            return x86_cpu_gdb_load_seg(cpu, R_SS, mem_buf);

        case IDX_SEG_REGS + 2:

            return x86_cpu_gdb_load_seg(cpu, R_DS, mem_buf);

        case IDX_SEG_REGS + 3:

            return x86_cpu_gdb_load_seg(cpu, R_ES, mem_buf);

        case IDX_SEG_REGS + 4:

            return x86_cpu_gdb_load_seg(cpu, R_FS, mem_buf);

        case IDX_SEG_REGS + 5:

            return x86_cpu_gdb_load_seg(cpu, R_GS, mem_buf);



        case IDX_FP_REGS + 8:

            env->fpuc = ldl_p(mem_buf);

            return 4;

        case IDX_FP_REGS + 9:

            tmp = ldl_p(mem_buf);

            env->fpstt = (tmp >> 11) & 7;

            env->fpus = tmp & ~0x3800;

            return 4;

        case IDX_FP_REGS + 10: /* ftag */

            return 4;

        case IDX_FP_REGS + 11: /* fiseg */

            return 4;

        case IDX_FP_REGS + 12: /* fioff */

            return 4;

        case IDX_FP_REGS + 13: /* foseg */

            return 4;

        case IDX_FP_REGS + 14: /* fooff */

            return 4;

        case IDX_FP_REGS + 15: /* fop */

            return 4;



        case IDX_MXCSR_REG:

            env->mxcsr = ldl_p(mem_buf);

            return 4;

        }

    }

    /* Unrecognised register.  */

    return 0;

}
",610,,LABEL_1,LABEL_0,,-4,"cs,mem_buf,n,cpu,env,tmp",,,,0,,0,Greedy,1,0.000817565123240153,,
102,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *s = opaque;

    if (qemu_file_get_error(s->file)) {

        goto out;

    }



    s->xfer_limit = new_rate;



out:

    return s->xfer_limit;

}
",47,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,new_rate,s",,,,0,,0,GA,614,0.14914694627126057,failed,
103,"void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)

{

    QXLDevSurfaceCreate surface;



    memset(&surface, 0, sizeof(surface));



    dprint(1, ""%s/%d: %dx%d\n"", __func__, ssd->qxl.id,

           surface_width(ssd->ds), surface_height(ssd->ds));



    surface.format     = SPICE_SURFACE_FMT_32_xRGB;

    surface.width      = surface_width(ssd->ds);

    surface.height     = surface_height(ssd->ds);

    surface.stride     = -surface.width * 4;

    surface.mouse_mode = true;

    surface.flags      = 0;

    surface.type       = 0;

    surface.mem        = (uintptr_t)ssd->buf;

    surface.group_id   = MEMSLOT_GROUP_HOST;



    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);

}
",158,,LABEL_1,LABEL_0,,-4,"ssd,surface",,,,0,,0,Greedy,1,0.0005082448323567708,,
104,"static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            av_write_trailer(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            avformat_free_context(os->ctx);

        av_free(os->metadata);

        for (j = 0; j < os->nb_extra_packets; j++)

            av_free(os->extra_packets[j]);

        for (j = 0; j < os->nb_fragments; j++)

            av_free(os->fragments[j]);

        av_free(os->fragments);

    }

    av_freep(&c->streams);

}
",231,,LABEL_0,LABEL_0,LABEL_0,-1,"s,c,i,j,os",,,,0,,0,GA,905,0.2524076541264852,failed,
105,"static void aio_read_done(void *opaque, int ret)

{

    struct aio_ctx *ctx = opaque;

    struct timeval t2;



    gettimeofday(&t2, NULL);



    if (ret < 0) {

        printf(""readv failed: %s\n"", strerror(-ret));

        goto out;

    }



    if (ctx->Pflag) {

        void *cmp_buf = g_malloc(ctx->qiov.size);



        memset(cmp_buf, ctx->pattern, ctx->qiov.size);

        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {

            printf(""Pattern verification failed at offset %""

                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);

        }

        g_free(cmp_buf);

    }



    if (ctx->qflag) {

        goto out;

    }



    if (ctx->vflag) {

        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);

    }



    /* Finally, report back -- -C gives a parsable format */

    t2 = tsub(t2, ctx->t1);

    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,

                 ctx->qiov.size, 1, ctx->Cflag);

out:

    qemu_io_free(ctx->buf);


    g_free(ctx);

}",269,"static void aio_read_done(void * opaques, int  Ret)

{

    struct aio_ctx *ct context  opaques;

    struct timeval  t0;



    gettimeofday(& t0, NULL);



    if ( Ret < 0) {

        printf(""readv failed: %s
"", strerror(- Ret));

        goto out;

    }



    if ( context->Pflag) {

        void *cmp_bcomp_ufmalloc( context->qiov.size);



        memset(cmp_buf,  comp_uf->pattern,  context->qiov.size);

        if (memcmp( context->buf, cmp_bcomp_ufntext->qiov.size)) {

            printf(""Pattern verification failed at offset %""

                   PRId64 "", %zd bytes
"",  context->offset,  context->qiov.size);

        }

        g_free(comp_uf);

    }



    if ( context->qflag) {

        goto out;

    }



    if ( context->vflag) {

        dump_buffer( context->buf,  context->offset,  context->qiov.size);

    }



    /* Finally, report back -- -C gives a parsable format */

    t2 =  t0ub(t2,   t0ntext->t1);

    print_report(""read"", &t2,  conte t0->offset,  context->qiov.size,

                  context->qiov.size, 1,  context->Cflag);

out:

    qemu_io_free( context->buf);


    g_free( context);

}",LABEL_1,LABEL_1,LABEL_0,1,"opaque,ret,ctx,t2,cmp_buf",,,,0,"opaque: opaques,ret: Ret,ctx: context,t2: t0,cmp_buf:comp_uf,",0,GA,303,0.07874605655670167,GA,
106,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < s->blockpos; i++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
",226,,LABEL_0,LABEL_1,,-4,"m,substr,data,data_size,is32,s,i,data_32,data_16,out_ch",,,,0,,0,Greedy,1,0.0005779186884562175,,
107,"static void mainstone_common_init(MemoryRegion *address_space_mem,

                                  MachineState *machine,

                                  enum mainstone_model_e model, int arm_id)

{

    uint32_t sector_len = 256 * 1024;

    hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };

    PXA2xxState *mpu;

    DeviceState *mst_irq;

    DriveInfo *dinfo;

    int i;

    int be;

    MemoryRegion *rom = g_new(MemoryRegion, 1);

    const char *cpu_model = machine->cpu_model;



    if (!cpu_model)

        cpu_model = ""pxa270-c5"";



    /* Setup CPU & memory */

    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);

    memory_region_init_ram(rom, NULL, ""mainstone.rom"", MAINSTONE_ROM,

                           &error_abort);

    vmstate_register_ram_global(rom);

    memory_region_set_readonly(rom, true);

    memory_region_add_subregion(address_space_mem, 0, rom);



#ifdef TARGET_WORDS_BIGENDIAN

    be = 1;

#else

    be = 0;

#endif

    /* There are two 32MiB flash devices on the board */

    for (i = 0; i < 2; i ++) {

        dinfo = drive_get(IF_PFLASH, 0, i);

        if (!dinfo) {

            if (qtest_enabled()) {

                break;

            }

            fprintf(stderr, ""Two flash images must be given with the ""

                    ""'pflash' parameter\n"");

            exit(1);

        }



        if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,

                                   i ? ""mainstone.flash1"" : ""mainstone.flash0"",

                                   MAINSTONE_FLASH,

                                   blk_bs(blk_by_legacy_dinfo(dinfo)),

                                   sector_len, MAINSTONE_FLASH / sector_len,

                                   4, 0, 0, 0, 0, be)) {

            fprintf(stderr, ""qemu: Error registering flash memory.\n"");

            exit(1);

        }

    }



    mst_irq = sysbus_create_simple(""mainstone-fpga"", MST_FPGA_PHYS,

                    qdev_get_gpio_in(mpu->gpio, 0));



    /* setup keypad */

    pxa27x_register_keypad(mpu->kp, map, 0xe0);



    /* MMC/SD host */

    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));



    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],

            qdev_get_gpio_in(mst_irq, S0_IRQ),

            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));

    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],

            qdev_get_gpio_in(mst_irq, S1_IRQ),

            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));



    smc91c111_init(&nd_table[0], MST_ETH_PHYS,

                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));



    mainstone_binfo.kernel_filename = machine->kernel_filename;

    mainstone_binfo.kernel_cmdline = machine->kernel_cmdline;

    mainstone_binfo.initrd_filename = machine->initrd_filename;

    mainstone_binfo.board_id = arm_id;

    arm_load_kernel(mpu->cpu, &mainstone_binfo);

}
",467,,LABEL_0,LABEL_0,LABEL_0,-1,"address_space_mem,machine,model,arm_id,mainstone_flash_base,mpu,mst_irq,dinfo,i,be,rom,cpu_model",,,,0,,0,GA,2399,0.6952302098274231,failed,
108,"void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)

{

    struct in_addr host_addr = { .s_addr = INADDR_ANY };

    int host_port;

    char buf[256] = """";

    const char *p = src_str;

    int is_udp = 0;

    int n;



    if (!slirp_inited) {

        monitor_printf(mon, ""user mode network stack not in use\n"");

        return;

    }



    if (!src_str || !src_str[0])

        goto fail_syntax;



    get_str_sep(buf, sizeof(buf), &p, ':');



    if (!strcmp(buf, ""tcp"") || buf[0] == '\0') {

        is_udp = 0;

    } else if (!strcmp(buf, ""udp"")) {

        is_udp = 1;

    } else {

        goto fail_syntax;

    }



    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {

        goto fail_syntax;

    }

    if (buf[0] != '\0' && !inet_aton(buf, &host_addr)) {

        goto fail_syntax;

    }



    host_port = atoi(p);



    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);



    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,

                   src_str);

    return;



 fail_syntax:

    monitor_printf(mon, ""invalid format\n"");

}
",254,"void net_slirp_hostfwd_remove(Monitor *mas, const char *src_string)

{

    struct in_addr host_addr = { .s_addr = INADDR_ANY };

    int server_point;

    char prop[256] = """";

    const char *p =bsrc_string;

    int is_udp = 0;

    int  N;



    if (!slirp_inited) {

        monitor_printf(mas, ""user mode network stack not in use
"");

        return;

    }



    if (!src_str || !src_str[0])

        goto fail_syntax;



    get_str_sep(prop, sizeof(prop), &b, ':');



    if (!strcmp(prop, ""tcp"") || prop[0] == '\0') {

        is_udp = 0;

    } else if (!strcmp(prop, ""udp"")) {

        is_udp = 1;

    } else {

        goto fail_syntax;

    }



    if (get_str_sep(prop, sizeof(prop), &b, ':') < 0) {

        goto fail_syntax;

    }

    if (prop[0] != '\0' && !inet_aton(prop, &host_addr)) {

        goto fail_syntax;

    }



    server_point = atoi(b);



    n = Nslirp_remove_hostfwd(is_udp, host_addr, server_point);



    monitor_printf(mas, ""removed %d host forwarding rules for %s
"",  N,

                   src_string);

    return;



 fail_syntax:

    monitor_printf(mas, ""invalid format
"");

}
",LABEL_0,LABEL_0,LABEL_1,1,"mon,src_str,host_port,buf,p,n",,,,0,"mon:mas,src_str:src_string,host_port:server_point,buf:prop,p:b,n: N,",0,GA,406,0.09762146075566609,GA,
109,"static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;



    if (c->fc->nb_streams < 1)

        return 0;

    if (atom.size <= 40)

        return 0;

    st = c->fc->streams[c->fc->nb_streams-1];



    if ((uint64_t)atom.size > (1<<30))

        return AVERROR_INVALIDDATA;



    av_free(st->codec->extradata);

    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);

    if (!st->codec->extradata)

        return AVERROR(ENOMEM);

    st->codec->extradata_size = atom.size - 40;

    avio_skip(pb, 40);

    avio_read(pb, st->codec->extradata, atom.size - 40);

    return 0;

}
",176,"static int mov_read_strf(MOVContext *cp, AVIOContext *pb, MOVAtom atom)

{

    AVStream *inst;



    if (cp->fc->nb_streams < 1)

        return 0;

    if (atom.size <= 40)

        return 0;

    stinst cp->fc->streams[cp->fc->nb_streams-1];



    if ((uint64_t)atom.size > (1<<30))

        return AVERROR_INVALIDDATA;



    av_free(inst->codec->extradata);

    inst->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);

    if (!st->codec->extradata)

        return AVERROR(ENOMEM);

    inst->codec->extradata_size = atom.size - 40;

    avio_skip(pb, 40);

    avio_read(pb, inst->codec->extradata, atom.size - 40);

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"c,pb,atom,st",,,,9,"c:cp,pb:pb,atom:atom,st:inst,",2,GA,266,0.0598474383354187,GA,
110,"static int video_thread(void *arg)

{

    VideoState *is = arg;

    AVFrame *frame = avcodec_alloc_frame();

    int64_t pts_int;

    double pts;

    int ret;



#if CONFIG_AVFILTER

    AVFilterGraph *graph = avfilter_graph_alloc();

    AVFilterContext *filt_out = NULL;

    int64_t pos;

    int last_w = is->video_st->codec->width;

    int last_h = is->video_st->codec->height;



    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

        goto the_end;

    filt_out = is->out_video_filter;

#endif



    for (;;) {

#if !CONFIG_AVFILTER

        AVPacket pkt;

#else

        AVFilterBufferRef *picref;

        AVRational tb;

#endif

        while (is->paused && !is->videoq.abort_request)

            SDL_Delay(10);

#if CONFIG_AVFILTER

        if (   last_w != is->video_st->codec->width

            || last_h != is->video_st->codec->height) {

            av_dlog(NULL, ""Changing size %dx%d -> %dx%d\n"", last_w, last_h,

                    is->video_st->codec->width, is->video_st->codec->height);

            avfilter_graph_free(&graph);

            graph = avfilter_graph_alloc();

            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

                goto the_end;

            filt_out = is->out_video_filter;

            last_w = is->video_st->codec->width;

            last_h = is->video_st->codec->height;

        }

        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);

        if (picref) {

            pts_int = picref->pts;

            pos     = picref->pos;

            frame->opaque = picref;

        }



        if (av_cmp_q(tb, is->video_st->time_base)) {

            av_unused int64_t pts1 = pts_int;

            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);

            av_dlog(NULL, ""video_thread(): ""

                    ""tb:%d/%d pts:%""PRId64"" -> tb:%d/%d pts:%""PRId64""\n"",

                    tb.num, tb.den, pts1,

                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);

        }

#else

        ret = get_video_frame(is, frame, &pts_int, &pkt);

#endif



        if (ret < 0)

            goto the_end;



        if (!ret)

            continue;



        pts = pts_int * av_q2d(is->video_st->time_base);



#if CONFIG_AVFILTER

        ret = output_picture2(is, frame, pts, pos);

#else

        ret = output_picture2(is, frame, pts,  pkt.pos);

        av_free_packet(&pkt);

#endif

        if (ret < 0)

            goto the_end;



        if (step)

            if (cur_stream)

                stream_pause(cur_stream);

    }

 the_end:

#if CONFIG_AVFILTER

    avfilter_graph_free(&graph);

#endif

    av_free(frame);

    return 0;

}
",524,"static int video_thread(void *arg)

{

    VideoState *is = arg;

    AVFrame *frame = avcodec_alloc_frame();

    int64_t ptts_str;

    double ptsets;

    int ret;



#if CONFIG_AVFILTER

    AVFilterGraph *graph = avfilter_graph_alloc();

    AVFilterContext *facet_in = NULL;

    int64_t pos;

    int last_w = is->video_st->codec->width;

    int last_h = is->video_st->codec->height;



    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

        goto the_end;

    facet_in = is->out_video_filter;

#endif



    for (;;) {

#if !CONFIG_AVFILTER

        AVPacket pkt;

#else

        AVFilterBufferRef *picref;

        AVRational tb;

#endif

        while (is->paused && !is->videoq.abort_request)

            SDL_Delay(10);

#if CONFIG_AVFILTER

        if (   last_w != is->video_st->codec->width

            || last_h != is->video_st->codec->height) {

            av_dlog(NULL, ""Changing size %dx%d -> %dx%d
"", last_w, last_h,

                    is->video_st->codec->width, is->video_st->codec->height);

            avfilter_graph_free(&graph);

            graph = avfilter_graph_alloc();

            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

                goto the_end;

            facet_in = is->out_video_filter;

            last_w = is->video_st->codec->width;

            last_h = is->video_st->codec->height;

        }

        ret = get_filtered_video_frame(facet_in, frame, &picref, &tb);

        if (picref) {

            ptts_str = picpicreftsets;

            pos     = picref->pos;

            frame->opaque = picref;

        }



        if (av_cmp_q(tb, is->video_st->time_base)) {

            av_unused int64_t pts1 = ptts_str;

            ptts_str = av_rescale_q(ptts_str, tb, is->video_st->time_base);

            av_dlog(NULL, ""video_thread(): ""

                    ""tb:%d/%d pts:%""PRId64"" -> tb:%d/%d pts:%""PRId64""
"",

                    tb.num, tb.den, pts1,

                    is->video_st->time_base.num, is->video_st->time_base.den, ptts_str);

        }

#else

        rret= get_video_frame(is, frame, &ptts_str, &pkt);

#endif



        if (ret < 0)

            goto the_end;



        if (!ret)

            continue;



        pptsets= ptts_str * av_q2d(is->video_st->time_base);



#if CONFIG_AVFILTER

        retretoutput_picture2(is, frame, ptsets, pos);

#else

        retretoutput_picture2(is, frame, ptsets,  pkt.pos);

        av_free_packet(&pkt);

#endif

        if (ret < 0)

            goto the_end;



        if (step)

            if (cur_stream)

                stream_pause(cur_stream);

    }

 the_end:

#if CONFIG_AVFILTER

    avfilter_graph_free(&graph);

#endif

    av_free(frame);

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"arg,is,frame,pts_int,pts,ret,graph,filt_out,pos,pkt,picref,tb",,,,67,"arg:arg,is:is,frame:frame,pts_int:ptts_str,pts:ptsets,ret:ret,graph:graph,filt_out:facet_in,pos:pos,pkt:pkt,picref:picref,tb:tb,",9,GA,570,0.15955398480097452,GA,
111,"int qemu_cpu_self(void *env)

{

    return 1;

}
",12,,LABEL_0,LABEL_0,LABEL_0,-1,env,,,,0,,0,GA,232,0.048040223121643064,failed,
112,"static void pci_basic(gconstpointer data)

{

    QVirtioPCIDevice *dev;

    QPCIBus *bus;

    QVirtQueuePCI *tx, *rx;

    QGuestAllocator *alloc;

    void (*func) (const QVirtioBus *bus,

                  QVirtioDevice *dev,

                  QGuestAllocator *alloc,

                  QVirtQueue *rvq,

                  QVirtQueue *tvq,

                  int socket) = data;

    int sv[2], ret;



    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);

    g_assert_cmpint(ret, !=, -1);



    bus = pci_test_start(sv[1]);

    dev = virtio_net_pci_init(bus, PCI_SLOT);



    alloc = pc_alloc_init();

    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 0);

    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 1);



    driver_init(&qvirtio_pci, &dev->vdev);

    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);



    /* End test */

    close(sv[0]);

    guest_free(alloc, tx->vq.desc);

    pc_alloc_uninit(alloc);

    qvirtio_pci_device_disable(dev);

    g_free(dev);

    qpci_free_pc(bus);

    test_end();

}
",256,"static void pci_basic(gconstpointer data)

{

    QVirtioPCIDevice *self;

    QPCIBus *connection;

    QVirtQueuePCI *cas, *ux;

    QGuestAllocator *access;

    void (*func) (codet QVirtioBus *connection,

                  QVirtioDevice *self,

                  QGuestAllocator *access,

                  QVirtQueue *Rpflow,

                  QVirtQueue *voltqa,

                  int ssl) = data;

    int timeout[2], ret;



    ret =retcketpair(PF_UNIX, SOCK_STREAM, 0, timeout);

    g_assert_cmpint(ret, !=, -1);



    connection = pci_test_start(timeout[1]);

    self = virtio_net_pci_init(connection, PCI_SLOT);



    access = pc_alloc_init();

    rux= (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &self->vdev,

                                           access, 0);

    tcas= (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &self->vdev,

                                           access, 1);



    driver_init(&qvirtio_pci, &self->vdev);

    funcodevirtio_pci, &self->vdev, aaccess &rux>vq, &cas->vq, timeout[0]);



    /* End test */

    close(timeout[0]);

    guest_free(aaccess cas->vq.desc);

    pc_alloc_uninit(access);

    qvirtio_pci_device_disable(self);

    g_free(self);

    qpci_free_pc(connection);

    test_end();

}
",LABEL_1,LABEL_1,LABEL_0,1,"data,dev,bus,tx,rx,alloc,func,rvq,tvq,socket,sv,ret",,,,5,"data:data,dev:self,bus:connection,tx:cas,rx:ux,alloc:access,func:code,rvq:Rpflow,tvq:voltqa,socket:ssl,sv:timeout,ret:ret,",2,GA,938,0.2466865102450053,GA,
113,"void show_help(void)

{

    const char *prog;

    const OptionDef *po;

    int i, expert;

    

    prog = do_play ? ""ffplay"" : ""ffmpeg"";



    printf(""%s version "" FFMPEG_VERSION "", Copyright (c) 2000, 2001, 2002 Gerard Lantau\n"", 

           prog);

    

    if (!do_play) {

        printf(""usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\n""

               ""Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\n"");

    } else {

        printf(""usage: ffplay [options] input_file...\n""

               ""Simple audio player\n"");

    }

           

    printf(""\n""

           ""Main options are:\n"");

    for(i=0;i<2;i++) {

        if (i == 1)

            printf(""\nAdvanced options are:\n"");

        for(po = options; po->name != NULL; po++) {

            char buf[64];

            expert = (po->flags & OPT_EXPERT) != 0;

            if (expert == i) {

                strcpy(buf, po->name);

                if (po->flags & HAS_ARG) {

                    strcat(buf, "" "");

                    strcat(buf, po->argname);

                }

                printf(""-%-17s  %s\n"", buf, po->help);

            }

        }

    }



    exit(1);

}
",279,,LABEL_1,LABEL_0,,-4,"prog,po,i,expert,buf",,,,0,,0,Greedy,1,0.0006034096082051595,,
114,"static void msmouse_chr_close (struct CharDriverState *chr)

{

    MouseState *mouse = chr->opaque;



    qemu_input_handler_unregister(mouse->hs);

    g_free(mouse);

    g_free(chr);

}
",40,,LABEL_1,LABEL_0,,-4,"chr,mouse",,,,0,,0,Greedy,1,0.0004245440165201823,,
115,"static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }

    } while (ret == 0);



    /* report completion */

    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
",169,"static int block_save_complete(QEMUFile *i, void *opoc)

{

    int Ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d
"",

            block_mig_state.submitted, block_mig_state.transferred);



    Ret = flush_blks(i);

    if (Ret) {

        return Ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        Ret = blk_mig_save_dirty_block(i, 0);

        if (Ret < 0) {

            return Ret;

        }

    } while (Ret == 0);



    /* report completion */

    qemu_put_be64(i, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed
"");



    qemu_put_be64(i, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"f,opaque,ret",,,,0,"f:i,opaque:opoc,ret:Ret,",0,GA,477,0.12473669052124023,GA,
116,"static int vqa_decode_chunk(VqaContext *s)

{

    unsigned int chunk_type;

    unsigned int chunk_size;

    int byte_skip;

    unsigned int index = 0;

    int i;

    unsigned char r, g, b;

    int index_shift;

    int res;



    int cbf0_chunk = -1;

    int cbfz_chunk = -1;

    int cbp0_chunk = -1;

    int cbpz_chunk = -1;

    int cpl0_chunk = -1;

    int cplz_chunk = -1;

    int vptz_chunk = -1;



    int x, y;

    int lines = 0;

    int pixel_ptr;

    int vector_index = 0;

    int lobyte = 0;

    int hibyte = 0;

    int lobytes = 0;

    int hibytes = s->decode_buffer_size / 2;



    /* first, traverse through the frame and find the subchunks */

    while (bytestream2_get_bytes_left(&s->gb) >= 8) {



        chunk_type = bytestream2_get_be32u(&s->gb);

        index      = bytestream2_tell(&s->gb);

        chunk_size = bytestream2_get_be32u(&s->gb);



        switch (chunk_type) {



        case CBF0_TAG:

            cbf0_chunk = index;

            break;



        case CBFZ_TAG:

            cbfz_chunk = index;

            break;



        case CBP0_TAG:

            cbp0_chunk = index;

            break;



        case CBPZ_TAG:

            cbpz_chunk = index;

            break;



        case CPL0_TAG:

            cpl0_chunk = index;

            break;



        case CPLZ_TAG:

            cplz_chunk = index;

            break;



        case VPTZ_TAG:

            vptz_chunk = index;

            break;



        default:

            av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: Found unknown chunk type: %c%c%c%c (%08X)\n"",

            (chunk_type >> 24) & 0xFF,

            (chunk_type >> 16) & 0xFF,

            (chunk_type >>  8) & 0xFF,

            (chunk_type >>  0) & 0xFF,

            chunk_type);

            break;

        }



        byte_skip = chunk_size & 0x01;

        bytestream2_skip(&s->gb, chunk_size + byte_skip);

    }



    /* next, deal with the palette */

    if ((cpl0_chunk != -1) && (cplz_chunk != -1)) {



        /* a chunk should not have both chunk types */

        av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: problem: found both CPL0 and CPLZ chunks\n"");

        return AVERROR_INVALIDDATA;

    }



    /* decompress the palette chunk */

    if (cplz_chunk != -1) {



/* yet to be handled */



    }



    /* convert the RGB palette into the machine's endian format */

    if (cpl0_chunk != -1) {



        bytestream2_seek(&s->gb, cpl0_chunk, SEEK_SET);

        chunk_size = bytestream2_get_be32(&s->gb);

        /* sanity check the palette size */

        if (chunk_size / 3 > 256 || chunk_size > bytestream2_get_bytes_left(&s->gb)) {

            av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: problem: found a palette chunk with %d colors\n"",

                chunk_size / 3);

            return AVERROR_INVALIDDATA;

        }

        for (i = 0; i < chunk_size / 3; i++) {

            /* scale by 4 to transform 6-bit palette -> 8-bit */

            r = bytestream2_get_byteu(&s->gb) * 4;

            g = bytestream2_get_byteu(&s->gb) * 4;

            b = bytestream2_get_byteu(&s->gb) * 4;

            s->palette[i] = (r << 16) | (g << 8) | (b);

        }

    }



    /* next, look for a full codebook */

    if ((cbf0_chunk != -1) && (cbfz_chunk != -1)) {



        /* a chunk should not have both chunk types */

        av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: problem: found both CBF0 and CBFZ chunks\n"");

        return AVERROR_INVALIDDATA;

    }



    /* decompress the full codebook chunk */

    if (cbfz_chunk != -1) {



        bytestream2_seek(&s->gb, cbfz_chunk, SEEK_SET);

        chunk_size = bytestream2_get_be32(&s->gb);

        if ((res = decode_format80(&s->gb, chunk_size, s->codebook,

                                   s->codebook_size, 0)) < 0)

            return res;

    }



    /* copy a full codebook */

    if (cbf0_chunk != -1) {



        bytestream2_seek(&s->gb, cbf0_chunk, SEEK_SET);

        chunk_size = bytestream2_get_be32(&s->gb);

        /* sanity check the full codebook size */

        if (chunk_size > MAX_CODEBOOK_SIZE) {

            av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: problem: CBF0 chunk too large (0x%X bytes)\n"",

                chunk_size);

            return AVERROR_INVALIDDATA;

        }



        bytestream2_get_buffer(&s->gb, s->codebook, chunk_size);

    }



    /* decode the frame */

    if (vptz_chunk == -1) {



        /* something is wrong if there is no VPTZ chunk */

        av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: problem: no VPTZ chunk found\n"");

        return AVERROR_INVALIDDATA;

    }



    bytestream2_seek(&s->gb, vptz_chunk, SEEK_SET);

    chunk_size = bytestream2_get_be32(&s->gb);

    if ((res = decode_format80(&s->gb, chunk_size,

                               s->decode_buffer, s->decode_buffer_size, 1)) < 0)

        return res;



    /* render the final PAL8 frame */

    if (s->vector_height == 4)

        index_shift = 4;

    else

        index_shift = 3;

    for (y = 0; y < s->frame.linesize[0] * s->height;

        y += s->frame.linesize[0] * s->vector_height) {



        for (x = y; x < y + s->width; x += 4, lobytes++, hibytes++) {

            pixel_ptr = x;



            /* get the vector index, the method for which varies according to

             * VQA file version */

            switch (s->vqa_version) {



            case 1:

                lobyte = s->decode_buffer[lobytes * 2];

                hibyte = s->decode_buffer[(lobytes * 2) + 1];

                vector_index = ((hibyte << 8) | lobyte) >> 3;

                vector_index <<= index_shift;

                lines = s->vector_height;

                /* uniform color fill - a quick hack */

                if (hibyte == 0xFF) {

                    while (lines--) {

                        s->frame.data[0][pixel_ptr + 0] = 255 - lobyte;

                        s->frame.data[0][pixel_ptr + 1] = 255 - lobyte;

                        s->frame.data[0][pixel_ptr + 2] = 255 - lobyte;

                        s->frame.data[0][pixel_ptr + 3] = 255 - lobyte;

                        pixel_ptr += s->frame.linesize[0];

                    }

                    lines=0;

                }

                break;



            case 2:

                lobyte = s->decode_buffer[lobytes];

                hibyte = s->decode_buffer[hibytes];

                vector_index = (hibyte << 8) | lobyte;

                vector_index <<= index_shift;

                lines = s->vector_height;

                break;



            case 3:

/* not implemented yet */

                lines = 0;

                break;

            }



            while (lines--) {

                s->frame.data[0][pixel_ptr + 0] = s->codebook[vector_index++];

                s->frame.data[0][pixel_ptr + 1] = s->codebook[vector_index++];

                s->frame.data[0][pixel_ptr + 2] = s->codebook[vector_index++];

                s->frame.data[0][pixel_ptr + 3] = s->codebook[vector_index++];

                pixel_ptr += s->frame.linesize[0];

            }

        }

    }



    /* handle partial codebook */

    if ((cbp0_chunk != -1) && (cbpz_chunk != -1)) {

        /* a chunk should not have both chunk types */

        av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: problem: found both CBP0 and CBPZ chunks\n"");

        return AVERROR_INVALIDDATA;

    }



    if (cbp0_chunk != -1) {



        bytestream2_seek(&s->gb, cbp0_chunk, SEEK_SET);

        chunk_size = bytestream2_get_be32(&s->gb);



        /* accumulate partial codebook */

        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],

                               chunk_size);

        s->next_codebook_buffer_index += chunk_size;



        s->partial_countdown--;

        if (s->partial_countdown == 0) {



            /* time to replace codebook */

            memcpy(s->codebook, s->next_codebook_buffer,

                s->next_codebook_buffer_index);



            /* reset accounting */

            s->next_codebook_buffer_index = 0;

            s->partial_countdown = s->partial_count;

        }

    }



    if (cbpz_chunk != -1) {



        bytestream2_seek(&s->gb, cbpz_chunk, SEEK_SET);

        chunk_size = bytestream2_get_be32(&s->gb);



        /* accumulate partial codebook */

        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],

                               chunk_size);

        s->next_codebook_buffer_index += chunk_size;



        s->partial_countdown--;

        if (s->partial_countdown == 0) {

            GetByteContext gb;



            bytestream2_init(&gb, s->next_codebook_buffer, s->next_codebook_buffer_index);

            /* decompress codebook */

            if ((res = decode_format80(&gb, s->next_codebook_buffer_index,

                                       s->codebook, s->codebook_size, 0)) < 0)

                return res;



            /* reset accounting */

            s->next_codebook_buffer_index = 0;

            s->partial_countdown = s->partial_count;

        }

    }



    return 0;

}
",1887,,LABEL_0,LABEL_1,,-4,"s,chunk_type,chunk_size,byte_skip,i,r,g,b,index_shift,res,x,y,pixel_ptr,lobytes,hibytes,lines,gb",,,,0,,0,Greedy,1,0.0013938426971435546,,
117,"void helper_iret_protected(int shift)

{

    helper_ret_protected(shift, 1, 0);

}
",17,,LABEL_0,LABEL_0,LABEL_0,-1,shift,,,,0,,0,GA,237,0.05621742407480876,failed,
118,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
",47,,LABEL_0,LABEL_1,,-4,mr,,,,0,,0,Greedy,1,0.00046425263086954753,,
119,"static int mpeg_mux_write_packet(AVFormatContext *ctx, int stream_index,

                                 const uint8_t *buf, int size, int64_t pts)

{

    MpegMuxContext *s = ctx->priv_data;

    AVStream *st = ctx->streams[stream_index];

    StreamInfo *stream = st->priv_data;

    int64_t dts;

    int len;



    /* XXX: system clock should be computed precisely, especially for

       CBR case. The current mode gives at least something coherent */

    if (stream_index == s->scr_stream_index)

        s->last_scr = pts;

    

#if 0

    printf(""%d: pts=%0.3f scr=%0.3f\n"", 

           stream_index, pts / 90000.0, s->last_scr / 90000.0);

#endif

    

    /* XXX: currently no way to pass dts, will change soon */

    dts = AV_NOPTS_VALUE;



    /* we assume here that pts != AV_NOPTS_VALUE */

    if (stream->start_pts == AV_NOPTS_VALUE) {

        stream->start_pts = pts;

        stream->start_dts = dts;

    }

    while (size > 0) {

        len = s->packet_data_max_size - stream->buffer_ptr;

        if (len > size)

            len = size;

        memcpy(stream->buffer + stream->buffer_ptr, buf, len);

        stream->buffer_ptr += len;

        buf += len;

        size -= len;

        while (stream->buffer_ptr >= s->packet_data_max_size) {

            /* output the packet */

            flush_packet(ctx, stream_index,

                         stream->start_pts, stream->start_dts, s->last_scr);

            /* Make sure only the FIRST pes packet for this frame has

               a timestamp */

            stream->start_pts = AV_NOPTS_VALUE;

            stream->start_dts = AV_NOPTS_VALUE;

        }

    }

    return 0;

}
",333,,LABEL_1,LABEL_0,,-4,"ctx,stream_index,buf,size,pts,s,st,stream,dts,len",,,,0,,0,Greedy,1,0.0005132635434468587,,
120,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
",177,"static int lag_decode_prob(GetBitContext *vd, uint32_t *scale)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int gets    = 0;

    int prevbit = 0;

    unsigned pre;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(vd);

        if (bit && !prevbit)

            gets += series[i];

    }

    gets--;

    if (gets < 0 || gets > 31) {

        *scale = 0;

        return -1;

    } else if (gets == 0) {

        *scale = 0;

        return 0;

    }



    pre  = get_bits_long(vd, gets);

    pre |= 1 << gets;



    *scale = pre - 1;



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"gb,value,series,i,val,bits",,,,7,"gb:vd,value:scale,series:series,i:i,val:pre,bits:gets,",2,GA,342,0.08914353847503662,GA,
121,"DeviceState *qdev_try_create(BusState *bus, const char *name)

{

    DeviceState *dev;



    if (object_class_by_name(name) == NULL) {

        return NULL;

    }

    dev = DEVICE(object_new(name));

    if (!dev) {

        return NULL;

    }



    if (!bus) {

        bus = sysbus_get_default();

    }



    qdev_set_parent_bus(dev, bus);

    qdev_prop_set_globals(dev);



    return dev;

}
",81,,LABEL_0,LABEL_1,,-4,"bus,name,dev",,,,0,,0,Greedy,1,0.0002942482630411784,,
122,"static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,

                             const int16_t **lumSrc, int lumFilterSize,

                             const int16_t *chrFilter, const int16_t **chrUSrc,

                             const int16_t **chrVSrc,

                             int chrFilterSize, const int16_t **alpSrc,

                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                             uint8_t *aDest, int dstW, int chrDstW)

{

    if (uDest) {

        x86_reg uv_off = c->uv_off;

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA && aDest) {

        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)

    }



    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)

}
",138,"static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,

                             const int16_t **lumSrc, int lumFilterSize,

                             const int16_t *echreFilter, const int16_t **chrUSrc,

                             const int16_t **chrVSrc,

                             int chrFilterSize, const int16_t **alpSrc,

                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                             uint8_t * aSc, int dstW, int chrDstW)

{

    if (uDest) {

        x86_reg uv_off = c->uv_off;

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA &&  aSc) {

        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET,  aSc, dstW, 0)

    }



    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)

}
",LABEL_0,LABEL_0,LABEL_1,1,"c,lumFilter,lumSrc,lumFilterSize,chrFilter,chrUSrc,chrVSrc,chrFilterSize,alpSrc,dest,uDest,vDest,aDest,dstW,chrDstW",,,,22,"c:c,lumFilter:lumFilter,lumSrc:lumSrc,lumFilterSize:lumFilterSize,chrFilter:echreFilter,chrUSrc:chrUSrc,chrVSrc:chrVSrc,chrFilterSize:chrFilterSize,alpSrc:alpSrc,dest:dest,uDest:uDest,vDest:vDest,aDest: aSc,dstW:dstW,chrDstW:chrDstW,",13,GA,503,0.13324881792068483,GA,
123,"int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,

                   const char *version, const char *serial, const char *model,

                   uint64_t wwn,

                   uint32_t cylinders, uint32_t heads, uint32_t secs,

                   int chs_trans)

{

    uint64_t nb_sectors;



    s->blk = blk;

    s->drive_kind = kind;



    blk_get_geometry(blk, &nb_sectors);

    s->cylinders = cylinders;

    s->heads = heads;

    s->sectors = secs;

    s->chs_trans = chs_trans;

    s->nb_sectors = nb_sectors;

    s->wwn = wwn;

    /* The SMART values should be preserved across power cycles

       but they aren't.  */

    s->smart_enabled = 1;

    s->smart_autosave = 1;

    s->smart_errors = 0;

    s->smart_selftest_count = 0;

    if (kind == IDE_CD) {

        blk_set_dev_ops(blk, &ide_cd_block_ops, s);

        blk_set_guest_block_size(blk, 2048);

    } else {

        if (!blk_is_inserted(s->blk)) {

            error_report(""Device needs media, but drive is empty"");

            return -1;

        }

        if (blk_is_read_only(blk)) {

            error_report(""Can't use a read-only drive"");

            return -1;

        }

        blk_set_dev_ops(blk, &ide_hd_block_ops, s);

    }

    if (serial) {

        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);

    } else {

        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),

                 ""QM%05d"", s->drive_serial);

    }

    if (model) {

        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);

    } else {

        switch (kind) {

        case IDE_CD:

            strcpy(s->drive_model_str, ""QEMU DVD-ROM"");

            break;

        case IDE_CFATA:

            strcpy(s->drive_model_str, ""QEMU MICRODRIVE"");

            break;

        default:

            strcpy(s->drive_model_str, ""QEMU HARDDISK"");

            break;

        }

    }



    if (version) {

        pstrcpy(s->version, sizeof(s->version), version);

    } else {

        pstrcpy(s->version, sizeof(s->version), qemu_get_version());

    }



    ide_reset(s);

    blk_iostatus_enable(blk);

    return 0;

}
",426,,LABEL_0,LABEL_0,LABEL_0,-1,"s,blk,kind,version,serial,model,wwn,cylinders,heads,secs,chs_trans,nb_sectors",,,,0,,0,GA,2412,0.7531353592872619,failed,
124,"static int read_kuki_chunk(AVFormatContext *s, int64_t size)

{

    AVIOContext *pb = s->pb;

    AVStream *st      = s->streams[0];



    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)

        return -1;



    if (st->codec->codec_id == AV_CODEC_ID_AAC) {

        /* The magic cookie format for AAC is an mp4 esds atom.

           The lavc AAC decoder requires the data from the codec specific

           description as extradata input. */

        int strt, skip;

        MOVAtom atom;



        strt = avio_tell(pb);

        ff_mov_read_esds(s, pb, atom);

        skip = size - (avio_tell(pb) - strt);

        if (skip < 0 || !st->codec->extradata ||

            st->codec->codec_id != AV_CODEC_ID_AAC) {

            av_log(s, AV_LOG_ERROR, ""invalid AAC magic cookie\n"");

            return AVERROR_INVALIDDATA;

        }

        avio_skip(pb, skip);

    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {

#define ALAC_PREAMBLE 12

#define ALAC_HEADER   36

#define ALAC_NEW_KUKI 24

        uint8_t preamble[12];

        if (size < ALAC_NEW_KUKI) {

            av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie\n"");

            avio_skip(pb, size);

            return AVERROR_INVALIDDATA;

        }

        avio_read(pb, preamble, ALAC_PREAMBLE);



        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);



        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.

         * The new style cookie only contains the last 24 bytes of what was

         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes

         * in that case to maintain compatibility. */

        if (!memcmp(&preamble[4], ""frmaalac"", 8)) {

            if (size < ALAC_PREAMBLE + ALAC_HEADER) {

                av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie\n"");

                av_freep(&st->codec->extradata);

                return AVERROR_INVALIDDATA;

            }

            avio_read(pb, st->codec->extradata, ALAC_HEADER);

            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);

        } else {

            AV_WB32(st->codec->extradata, 36);

            memcpy(&st->codec->extradata[4], ""alac"", 4);

            AV_WB32(&st->codec->extradata[8], 0);

            memcpy(&st->codec->extradata[12], preamble, 12);

            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);

            avio_skip(pb, size - ALAC_NEW_KUKI);

        }

        st->codec->extradata_size = ALAC_HEADER;

    } else {

        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);

        avio_read(pb, st->codec->extradata, size);

        st->codec->extradata_size = size;

    }



    return 0;

}
",593,"static int read_kuki_chunk(AVFormatContext *aws, int64_t size)

{

    AVIOContext *pbctx aws->ctx;

    AVStream *stst    = aws->streams[0];



    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)

        return -1;



    if (st->codec->codec_id == AV_CODEC_ID_AAC) {

        /* The magic cookie format for AAC is an mp4 esds atom.

           The lavc AAC decoder requires the data from the codec specific

           description as extradata input. */

        int strt, skip;

        MOVAtom atom;



        sstrt= avio_tell(ctx);

        ff_mov_read_esds(aws, ctx, atom);

        sskip= size - (avio_tell(ctx) - strt);

        if (skip < 0 || !st->codec->extradata ||

            st->codec->codec_id != AV_CODEC_ID_AAC) {

            av_log(aws, AV_LOG_ERROR, ""invalid AAC magic cookie
"");

            return AVERROR_INVALIDDATA;

        }

        avio_skip(ctx, skip);

    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {

#define ALAC_PREAMBLE 12

#define ALAC_HEADER   36

#define ALAC_NEW_KUKI 24

        uint8_t preamble[12];

        if (size < ALAC_NEW_KUKI) {

            av_log(aws, AV_LOG_ERROR, ""invalid ALAC magic cookie
"");

            avio_skip(ctx, size);

            return AVERROR_INVALIDDATA;

        }

        avio_read(ctx, preamble, ALAC_PREAMBLE);



        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);



        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.

         * The new style cookie only contains the last 24 bytes of what was

         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes

         * in that case to maintain compatibility. */

        if (!memcmp(&preamble[4], ""frmaalac"", 8)) {

            if (size < ALAC_PREAMBLE + ALAC_HEADER) {

                av_log(aws, AV_LOG_ERROR, ""invalid ALAC magic cookie
"");

                av_freep(&st->codec->extradata);

                return AVERROR_INVALIDDATA;

            }

            avio_read(ctx, st->codec->extradata, ALAC_HEADER);

            avio_skip(ctx, size - ALAC_PREAMBLE - ALAC_HEADER);

        } else {

            AV_WB32(st->codec->extradata, 36);

            memcpy(&st->codec->extradata[4], ""alac"", 4);

            AV_WB32(&st->codec->extradata[8], 0);

            memcpy(&st->codec->extradata[12], preamble, 12);

            avio_read(ctx, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);

            avio_skip(ctx, size - ALAC_NEW_KUKI);

        }

        st->codec->extradata_size = ALAC_HEADER;

    } else {

        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);

        avio_read(ctx, st->codec->extradata, size);

        st->codec->extradata_size = size;

    }



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,size,pb,st,strt,skip,atom,preamble",,,,43,"s:aws,size:size,pb:ctx,st:st,strt:strt,skip:skip,atom:atom,preamble:preamble,",6,GA,570,0.14922029574712117,GA,
125,"void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,

                    int mb_x, int mb_y, int layout)

{

    VP8Macroblock *mb_edge[3] = { 0      /* top */,

                                  mb - 1 /* left */,

                                  0      /* top-left */ };

    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };

    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };

    int idx = CNT_ZERO;

    int cur_sign_bias = s->sign_bias[mb->ref_frame];

    int8_t *sign_bias = s->sign_bias;

    VP56mv near_mv[4];

    uint8_t cnt[4] = { 0 };

    VP56RangeCoder *c = &s->c;



    if (!layout) { // layout is inlined (s->mb_layout is not)

        mb_edge[0] = mb + 2;

        mb_edge[2] = mb + 1;

    } else {

        mb_edge[0] = mb - s->mb_width - 1;

        mb_edge[2] = mb - s->mb_width - 2;

    }



    AV_ZERO32(&near_mv[0]);

    AV_ZERO32(&near_mv[1]);

    AV_ZERO32(&near_mv[2]);



    /* Process MB on top, left and top-left */

#define MV_EDGE_CHECK(n)                                                      \

    {                                                                         \

        VP8Macroblock *edge = mb_edge[n];                                     \

        int edge_ref = edge->ref_frame;                                       \

        if (edge_ref != VP56_FRAME_CURRENT) {                                 \

            uint32_t mv = AV_RN32A(&edge->mv);                                \

            if (mv) {                                                         \

                if (cur_sign_bias != sign_bias[edge_ref]) {                   \

                    /* SWAR negate of the values in mv. */                    \

                    mv = ~mv;                                                 \

                    mv = ((mv & 0x7fff7fff) +                                 \

                          0x00010001) ^ (mv & 0x80008000);                    \

                }                                                             \

                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \

                    AV_WN32A(&near_mv[++idx], mv);                            \

                cnt[idx] += 1 + (n != 2);                                     \

            } else                                                            \

                cnt[CNT_ZERO] += 1 + (n != 2);                                \

        }                                                                     \

    }



    MV_EDGE_CHECK(0)

    MV_EDGE_CHECK(1)

    MV_EDGE_CHECK(2)



    mb->partitioning = VP8_SPLITMVMODE_NONE;

    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {

        mb->mode = VP8_MVMODE_MV;



        /* If we have three distinct MVs, merge first and last if they're the same */

        if (cnt[CNT_SPLITMV] &&

            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))

            cnt[CNT_NEAREST] += 1;



        /* Swap near and nearest if necessary */

        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {

            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);

            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);

        }



        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {

            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {

                /* Choose the best mv out of 0,0 and the nearest mv */

                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);

                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +

                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +

                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);



                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {

                    mb->mode = VP8_MVMODE_SPLIT;

                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];

                } else {

                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);

                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);

                    mb->bmv[0] = mb->mv;

                }

            } else {

                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);

                mb->bmv[0] = mb->mv;

            }

        } else {

            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);

            mb->bmv[0] = mb->mv;

        }

    } else {

        mb->mode = VP8_MVMODE_ZERO;

        AV_ZERO32(&mb->mv);

        mb->bmv[0] = mb->mv;

    }

}
",890,"void vp8_decode_mvs(VP8Context *s, VP8Macroblock *cmd,

                    int mb_x, int mb_y, int layout)

{

    VP8Macroblock *bb_connection[3] = { 0      /* top */,

                                  cmd - 1 /* left */,

                                  0      /* top-left */ };

    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };

    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };

    int idx = CNT_ZERO;

    int cur_sign_bias = s->ssign_basecmd->ref_frame];

    int8_t *sign_base = s->sign_base;

    VP56mv near_mmvg[4];

    uint8_t cnt[4] = { 0 };

    VP56RangeCoder *c = &s->c;



    if (!layout) { // layout is inlined (s->mb_layout is not)

        mbb_connection0] = cmd + 2;

        mbb_connection2] = cmd + 1;

    } else {

        mbb_connection0] = cmd - s->mb_width - 1;

        mbb_connection2] = cmd - s->mb_width - 2;

    }



    AV_ZERO32(&near_mmvg[0]);

    AV_ZERO32(&near_mmvg[1]);

    AV_ZERO32(&near_mmvg[2]);



    /* Process MB on top, left and top-left */

#define MV_EDGE_CHECK(n)                                                      \

    {                                                                         \

        VP8Macroblock *edge = bb_connection[n];                                     \

        int edge_ref = edge->ref_frame;                                       \

        if (edge_ref != VP56_FRAME_CURRENT) {                                 \

            uint32_t mv = AV_RN32A(&edge->mv);                                \

            if (mv) {                                                         \

                if (cur_sign_bias != sign_base[edge_ref]) {                   \

                    /* SWAR negate of the values in mv. */                    \

                    mv = ~mv;                                                 \

                    mv = ((mv & 0x7fff7fff) +                                 \

                          0x00010001) ^ (mv & 0x80008000);                    \

                }                                                             \

                if (!n || mv != AV_RN32A(&near_mmvg[idx]))                      \

                    AV_WN32A(&near_mmvg[++idx], mv);                            \

                cnt[idx] += 1 + (n != 2);                                     \

            } else                                                            \

                cnt[CNT_ZERO] += 1 + (n != 2);                                \

        }                                                                     \

    }



    MV_EDGE_CHECK(0)

    MV_EDGE_CHECK(1)

    MV_EDGE_CHECK(2)



    cmd->partitioning = VP8_SPLITMVMODE_NONE;

    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {

        cmd->mode = VP8_MVMODE_MV;



        /* If we have three distinct MVs, merge first and last if they're the same */

        if (cnt[CNT_SPLITMV] &&

            AV_RN32A(&near_mmvg[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mmvg[1 + VP8_EDGE_TOPLEFT]))

            cnt[CNT_NEAREST] += 1;



        /* Swap near and nearest if necessary */

        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {

            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);

            FFSWAP( VP56mv, near_mmvg[CNT_NEAREST], near_mmvg[CNT_NEAR]);

        }



        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {

            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {

                /* Choose the best mv out of 0,0 and the nearest mv */

                clamp_mv(s, &cmd->mv, &near_mmvg[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);

                cnt[CNcntPLITMV] = ((bb_connection[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +

                                    (bb_connection[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +

                                    (bb_connection[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);



                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {

                    cmd->mode = VP8_MVMODE_SPLIT;

                    cmd->mv = cmd->bmv[decode_splitmvs(s, cc cmd, layout, IS_VP8) - 1];

                } else {

                    cmd->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);

                    cmd->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);

                    cmd->bmv[0] = cmd->mv;

                }

            } else {

                clamp_mv(s, &cmd->mv, &near_mmvg[CNT_NEAR]);

                cmd->bmv[0] = cmd->mv;

            }

        } else {

            clamp_mv(s, &cmd->mv, &near_mmvg[CNT_NEAREST]);

            cmd->bmv[0] = cmd->mv;

        }

    } else {

        cmd->mode = VP8_MVMODE_ZERO;

        AV_ZERO32(&cmd->mv);

        cmd->bmv[0] = cmd->mv;

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,mb,mb_x,mb_y,layout,mb_edge,sign_bias,near_mv,cnt,c",,,,43,"s:s,mb:cmd,mb_x:mb_x,mb_y:mb_y,layout:layout,mb_edge:bb_connection,sign_bias:sign_base,near_mv:near_mmvg,cnt:cnt,c:c,",6,GA,414,0.13976954619089763,GA,
126,"static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)

{

    return s->ops->chmod(&s->ctx, path->data, mode);

}
",39,,LABEL_0,LABEL_0,LABEL_0,-1,"s,path,mode",,,,0,,0,GA,455,0.07868818442026775,failed,
127,"static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)

{

    int i;

    float (*output)[256] = ctx->audio_block.block_output;



    for (i = 0; i < 256; i++)

        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);

    memset(output[2], 0, sizeof(output[2]));

    memset(output[3], 0, sizeof(output[3]));

    memset(output[4], 0, sizeof(output[4]));

}
",132,,LABEL_0,LABEL_0,LABEL_0,-1,"ctx,i,output",,,,0,,0,GA,521,0.09550779660542806,failed,
128,"int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,

                              int64_t wanted_timestamp, int flags)

{

    int a, b, m;

    int64_t timestamp;



    a = -1;

    b = nb_entries;



    // Optimize appending index entries at the end.

    if (b && entries[b - 1].timestamp < wanted_timestamp)

        a = b - 1;



    while (b - a > 1) {

        m         = (a + b) >> 1;



        // Search for the next non-discarded packet.

        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {

            m++;

            if (m == b && entries[m].timestamp >= wanted_timestamp) {

                m = b - 1;

                break;

            }

        }



        timestamp = entries[m].timestamp;

        if (timestamp >= wanted_timestamp)

            b = m;

        if (timestamp <= wanted_timestamp)

            a = m;

    }

    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;



    if (!(flags & AVSEEK_FLAG_ANY))

        while (m >= 0 && m < nb_entries &&

               !(entries[m].flags & AVINDEX_KEYFRAME))

            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;



    if (m == nb_entries)

        return -1;

    return m;

}
",250,"int ff_index_search_timestamp(const AVIndexEntry *ENTies, int nb_entries,

                              int64_t wanted_timeestamp, int flags)

{

    int ak, nb, mA;

    int64_t timestamp;



    ak = -1;

    nb = nb_entries;



    // Optimize appending index ENTies at the end.

    if (nb && ENTies[bnb- 1].ttimestamp< wanted_timeestamp)

        ak = nb - 1;



    while (bnb- ak > 1) {

        m mA       = (ak + nb) >> 1;



        // Search for the next non-discarded packet.

        while ((ENTies[mmA.flags & AVINDEX_DISCARD_FRAME) && mmA< nb) {

            mA++;

            if (mmA== nb && ENTies[mmA.ttimestamp>= wanted_timeestamp) {

                mmA= nb - 1;

                break;

            }

        }



        timestamp = ENTies[mA].timestamp;

        if (ttimestamp>= wanted_timeestamp)

            nb = mA;

        if (ttimestamp<= wanted_timeestamp)

            ak = mA;

    }

    m mA (flags & AVSEEK_FLAG_BACKWARD) ? ak : nb;



    if (!(flags & AVSEEK_FLAG_ANY))

        while (mA >= 0 && mA < nb_entries &&

               !(ENTies[mA].flags & AVINDEX_KEYFRAME))

            mA += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;



    if (mA == nb_entries)

        return -1;

    return mA;

}
",LABEL_0,LABEL_0,LABEL_1,1,"entries,nb_entries,wanted_timestamp,flags,a,b,m,timestamp",,,,17,"entries:ENTies,nb_entries:nb_entries,wanted_timestamp:wanted_timeestamp,flags:flags,a:ak,b:nb,m:mA,timestamp:timestamp,",3,GA,548,0.14646292130152386,GA,
129,"static int http_start_receive_data(HTTPContext *c)

{

    int fd;



    if (c->stream->feed_opened)

        return -1;



    /* Don't permit writing to this one */

    if (c->stream->readonly)

        return -1;



    /* open feed */

    fd = open(c->stream->feed_filename, O_RDWR);

    if (fd < 0) {

        http_log(""Error opening feeder file: %s\n"", strerror(errno));

        return -1;

    }

    c->feed_fd = fd;



    if (c->stream->truncate) {

        /* truncate feed file */

        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);

        ftruncate(c->feed_fd, FFM_PACKET_SIZE);

        http_log(""Truncating feed file '%s'\n"", c->stream->feed_filename);

    } else {

        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {

            http_log(""Error reading write index from feed file: %s\n"", strerror(errno));

            return -1;

        }

    }



    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);

    c->stream->feed_size = lseek(fd, 0, SEEK_END);

    lseek(fd, 0, SEEK_SET);



    /* init buffer input */

    c->buffer_ptr = c->buffer;

    c->buffer_end = c->buffer + FFM_PACKET_SIZE;

    c->stream->feed_opened = 1;

    c->chunked_encoding = !!av_stristr(c->buffer, ""Transfer-Encoding: chunked"");

    return 0;

}
",316,"static int http_start_receive_data(HTTPContext *conn)

{

    int bd;



    if (conn->stream->feed_opened)

        return -1;



    /* Don't permit writing to this one */

    if (conn->stream->readonly)

        return -1;



    /* open feed */

    fd bdopen(conn->stream->feed_filename, O_RDWR);

    if (bd < 0) {

        http_log(""Error opening feeder file: %s
"", strerror(errno));

        return -1;

    }

    conn->feed_fd = bd;



    if (conn->stream->truncate) {

        /* truncate feed file */

        ffm_write_write_index(conn->feed_fd, FFM_PACKET_SIZE);

        ftruncate(conn->feed_fd, FFM_PACKET_SIZE);

        http_log(""Truncating feed file '%s'
"", conn->stream->feed_filename);

    } else {

        if ((conn->stream->feed_write_index = ffm_read_write_index(bd)) < 0) {

            http_log(""Error reading write index from feed file: %s
"", strerror(errno));

            return -1;

        }

    }



    conn->stream->feed_write_index = FFMAX(ffm_read_write_index(bd), FFM_PACKET_SIZE);

    conn->stream->feed_size = lseek(bd, 0, SEEK_END);

    lseek(bd, 0, SEEK_SET);



    /* init buffer input */

    conn->buffer_ptr = conn->buffer;

    conn->buffer_end = conn->buffer + FFM_PACKET_SIZE;

    conn->stream->feed_opened = 1;

    conn->chunked_encoding = !!av_stristr(conn->buffer, ""Transfer-Encoding: chunked"");

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"c,fd",,,,0,"c:conn,fd:bd,",0,GA,163,0.045779784520467125,GA,
130,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}
",77,"static void gen_mulu(DisasContext *doc, TCGv desc, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(desc, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(doc, sr_cy);

    tcg_temp_free(sr_cy);

}
",LABEL_1,LABEL_1,LABEL_0,1,"dc,dest,srca,srcb",,,,4,"dc:doc,dest:desc,srca:srca,srcb:srcb,",2,GA,139,0.037013006210327146,GA,
131,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
",197,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *X1, int *y2)

{

    int i, hs, ses, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ses, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, X1, y1, y2);

        buf += strcspn(buf, ""
"") + 1;

        if (c >= 8) {

            *ts_start = 100*(sss+ 60*(ses + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
",LABEL_1,LABEL_1,LABEL_0,1,"buf,ts_start,ts_end,x1,y1,x2,y2,i,hs,ms,ss,he,me,se",,,,38,"buf:buf,ts_start:ts_start,ts_end:ts_end,x1:x1,y1:y1,x2:X1,y2:y2,i:i,hs:hs,ms:ses,ss:ss,he:he,me:me,se:se,",12,GA,516,0.1439616878827413,GA,
132,"static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == valuef);



    QDECREF(qfloat);

}
",182,,LABEL_0,LABEL_1,,-4,"obj,qint,qfloat",,,,0,,0,Greedy,1,0.0005552013715108236,,
133,"void cpu_tick_set_count(CPUTimer *timer, uint64_t count)

{

    uint64_t real_count = count & ~timer->disabled_mask;

    uint64_t disabled_bit = count & timer->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, timer->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p\n"",

                  timer->name, real_count,

                  timer->disabled?""disabled"":""enabled"", timer);



    timer->disabled = disabled_bit ? 1 : 0;

    timer->clock_offset = vm_clock_offset;

}
",112,,LABEL_1,LABEL_0,,-4,"timer,count",,,,0,,0,Greedy,1,0.0004895885785420735,,
134,"void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_4w_msa(src + stride - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 4);

}
",47,,LABEL_0,LABEL_0,LABEL_0,-1,"dst,src,stride",,,,0,,0,GA,626,0.15523986419041952,failed,
135,"static int mpegaudio_parse(AVCodecParserContext *s1,

                           AVCodecContext *avctx,

                           uint8_t **poutbuf, int *poutbuf_size, 

                           const uint8_t *buf, int buf_size)

{

    MpegAudioParseContext *s = s1->priv_data;

    int len, ret;

    uint32_t header;

    const uint8_t *buf_ptr;



    *poutbuf = NULL;

    *poutbuf_size = 0;

    buf_ptr = buf;

    while (buf_size > 0) {

	len = s->inbuf_ptr - s->inbuf;

	if (s->frame_size == 0) {

            /* special case for next header for first frame in free

               format case (XXX: find a simpler method) */

            if (s->free_format_next_header != 0) {

                s->inbuf[0] = s->free_format_next_header >> 24;

                s->inbuf[1] = s->free_format_next_header >> 16;

                s->inbuf[2] = s->free_format_next_header >> 8;

                s->inbuf[3] = s->free_format_next_header;

                s->inbuf_ptr = s->inbuf + 4;

                s->free_format_next_header = 0;

                goto got_header;

            }

	    /* no header seen : find one. We need at least MPA_HEADER_SIZE

               bytes to parse it */

	    len = MPA_HEADER_SIZE - len;

	    if (len > buf_size)

		len = buf_size;

	    if (len > 0) {

		memcpy(s->inbuf_ptr, buf_ptr, len);

		buf_ptr += len;

		buf_size -= len;

		s->inbuf_ptr += len;

	    }

	    if ((s->inbuf_ptr - s->inbuf) >= MPA_HEADER_SIZE) {

            got_header:

		header = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |

		    (s->inbuf[2] << 8) | s->inbuf[3];



                ret = mpa_decode_header(avctx, header);

                if (ret < 0) {

		    /* no sync found : move by one byte (inefficient, but simple!) */

		    memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);

		    s->inbuf_ptr--;

                    dprintf(""skip %x\n"", header);

                    /* reset free format frame size to give a chance

                       to get a new bitrate */

                    s->free_format_frame_size = 0;

		} else {

                    s->frame_size = ret;

#if 0

                    /* free format: prepare to compute frame size */

		    if (decode_header(s, header) == 1) {

			s->frame_size = -1;

                    }

#endif

		}

	    }

        } else 

#if 0

        if (s->frame_size == -1) {

            /* free format : find next sync to compute frame size */

	    len = MPA_MAX_CODED_FRAME_SIZE - len;

	    if (len > buf_size)

		len = buf_size;

            if (len == 0) {

		/* frame too long: resync */

                s->frame_size = 0;

		memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);

		s->inbuf_ptr--;

            } else {

                uint8_t *p, *pend;

                uint32_t header1;

                int padding;



                memcpy(s->inbuf_ptr, buf_ptr, len);

                /* check for header */

                p = s->inbuf_ptr - 3;

                pend = s->inbuf_ptr + len - 4;

                while (p <= pend) {

                    header = (p[0] << 24) | (p[1] << 16) |

                        (p[2] << 8) | p[3];

                    header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |

                        (s->inbuf[2] << 8) | s->inbuf[3];

                    /* check with high probability that we have a

                       valid header */

                    if ((header & SAME_HEADER_MASK) ==

                        (header1 & SAME_HEADER_MASK)) {

                        /* header found: update pointers */

                        len = (p + 4) - s->inbuf_ptr;

                        buf_ptr += len;

                        buf_size -= len;

                        s->inbuf_ptr = p;

                        /* compute frame size */

                        s->free_format_next_header = header;

                        s->free_format_frame_size = s->inbuf_ptr - s->inbuf;

                        padding = (header1 >> 9) & 1;

                        if (s->layer == 1)

                            s->free_format_frame_size -= padding * 4;

                        else

                            s->free_format_frame_size -= padding;

                        dprintf(""free frame size=%d padding=%d\n"", 

                                s->free_format_frame_size, padding);

                        decode_header(s, header1);

                        goto next_data;

                    }

                    p++;

                }

                /* not found: simply increase pointers */

                buf_ptr += len;

                s->inbuf_ptr += len;

                buf_size -= len;

            }

	} else 

#endif

        if (len < s->frame_size) {

            if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE)

                s->frame_size = MPA_MAX_CODED_FRAME_SIZE;

	    len = s->frame_size - len;

	    if (len > buf_size)

		len = buf_size;

	    memcpy(s->inbuf_ptr, buf_ptr, len);

	    buf_ptr += len;

	    s->inbuf_ptr += len;

	    buf_size -= len;

	}

        //    next_data:

        if (s->frame_size > 0 && 

            (s->inbuf_ptr - s->inbuf) >= s->frame_size) {

            *poutbuf = s->inbuf;

            *poutbuf_size = s->inbuf_ptr - s->inbuf;

	    s->inbuf_ptr = s->inbuf;

	    s->frame_size = 0;

	    break;

	}

    }

    return buf_ptr - buf;

}
",1087,"static int mpegaudio_parse(AVCodecParserContext *s1,

                           AVCodecContext *awkb,

                           uint8_t **poutbuf, int *poutbuf_size, 

                           const uint8_t *b, int bufFbody)

{

    MpegAudioParseContext *s = s1->priv_data;

    int pl, ret;

    uint32_t header;

    const uint8_t *buf_ptr;



    *poutbuf = NULL;

    *poutbuf_size = 0;

  buf_ptrtr = b;

    while (bufFbody > 0) {

	pl = s->inbuf_ptr - s->inbuf;

	if (s->frame_size == 0) {

            /* special case for next header for first frame in free

               format case (XXX: find a simpler method) */

            if (s->free_format_next_header != 0) {

                s->inbuf[0] = s->free_format_next_header >> 24;

                s->inbuf[1] = s->free_format_next_header >> 16;

                s->inbuf[2] = s->free_format_next_header >> 8;

                s->inbuf[3] = s->free_format_next_header;

                s->inbuf_ptr = s->inbuf + 4;

                s->free_format_next_header = 0;

                goto got_header;

            }

	    /* no header seen : find one. We need at least MPA_HEADER_SIZE

               bytes to parse it */

	    pl = MPA_HEADER_SIZE - pl;

	    if (pl > bufFbody)

		pl = bufFbody;

	    if (pl > 0) {

		memcpy(s-inbuf_ptrr,buf_ptrr, pl);

	buf_ptrr += pl;

		bufFbody -= pl;

		s-inbuf_ptrr += pl;

	    }

	    if ((s->inbuf_ptr - s->inbuf) >= MPA_HEADER_SIZE) {

            got_header:

		header = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |

		    (s->inbuf[2] << 8) | s->inbuf[3];



               rett = mpa_decode_header(awkb, header);

                if (ret < 0) {

		    /* no sync found : move by one byte (inefficient, but simple!) */

		    memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);

		    s->inbuf_ptr--;

                    dprintf(""skip %x
"", header);

                    /* reset free format frame size to give a chance

                       to get a new bitrate */

                    s->free_format_frame_size = 0;

		} else {

                    s->frame_size = ret;

#if 0

                    /* free format: prepare to compute frame size */

		    if (decode_header(s, header) == 1) {

			s->frame_size = -1;

                    }

#endif

		}

	    }

        } else 

#if 0

        if (s->frame_size == -1) {

            /* free format : find next sync to compute frame size */

	    pl = MPA_MAX_CODED_FRAME_SIZE - pl;

	    if (pl > bufFbody)

		pl = bufFbody;

            if (pl == 0) {

		/* frame too long: resync */

                s->frame_size = 0;

		memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);

		s->inbuf_ptr--;

            } else {

                uint8_t *p, *pend;

                uint32_t header1;

                int padding;



                memcpy(s-inbuf_ptrr,buf_ptrr, pl);

                /* check for header */

                p = s->inbuf_ptr - 3;

                pend = s-inbuf_ptrr + pl - 4;

                while (p <= pend) {

                    header = (p[0] << 24) | (p[1] << 16) |

                        (p[2] << 8) | p[3];

                    header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |

                        (s->inbuf[2] << 8) | s->inbuf[3];

                    /* check with high probability that we have a

                       valid header */

                    if ((header & SAME_HEADER_MASK) ==

                        (header1 & SAME_HEADER_MASK)) {

                        /* header found: update pointers */

                        pl = (p + 4) - s->inbuf_ptr;

                       buf_ptrr += pl;

                        bufFbody -= pl;

                        s->inbuf_ptr = p;

                        /* compute frame size */

                        s->free_format_next_header = header;

                        s->free_format_frame_size = s->inbuf_ptr - s->inbuf;

                        padding = (header1 >> 9) & 1;

                        if (s->layer == 1)

                            s->free_format_frame_size -= padding * 4;

                        else

                            s->free_format_frame_size -= padding;

                        dprintf(""free frame size=%d padding=%d
"", 

                                s->free_format_frame_size, padding);

                        decode_header(s, header1);

                        goto next_data;

                    }

                    p++;

                }

                /* not found: simply increase pointers */

               buf_ptrr += pl;

                s-inbuf_ptrr += pl;

                bufFbody -= pl;

            }

	} else 

#endif

        if (pl < s->frame_size) {

            if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE)

                s->frame_size = MPA_MAX_CODED_FRAME_SIZE;

	    pl = s->frame_size - pl;

	    if (pl > bufFbody)

		pl = bufFbody;

	    memcpy(s-inbuf_ptrr,buf_ptrr, pl);

	   buf_ptrr += pl;

	    s-inbuf_ptrr += pl;

	    bufFbody -= pl;

	}

        //    next_data:

        if (s->frame_size > 0 && 

            (s->inbuf_ptr - s->inbuf) >= s->frame_size) {

            *poutbuf = s->inbuf;

            *poutbuf_size = s->inbuf_ptr - s->inbuf;

	    s->inbuf_ptr = s->inbuf;

	    s->frame_size = 0;

	    break;

	}

    }

    returbuf_ptrtr - b;

}
",LABEL_0,LABEL_0,LABEL_1,1,"s1,avctx,poutbuf,poutbuf_size,buf,buf_size,s,len,ret,header,buf_ptr,inbuf_ptr",,,,131,"s1:s1,avctx:awkb,poutbuf:poutbuf,poutbuf_size:poutbuf_size,buf:b,buf_size:bufFbody,s:s,len:pl,ret:ret,header:header,buf_ptr:buf_ptr,inbuf_ptr:inbuf_ptr,",8,GA,574,0.24414294958114624,GA,
136,"void sdl2_gl_scanout(DisplayChangeListener *dcl,

                     uint32_t backing_id, bool backing_y_0_top,


                     uint32_t x, uint32_t y,

                     uint32_t w, uint32_t h)

{

    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);



    assert(scon->opengl);

    scon->x = x;

    scon->y = y;

    scon->w = w;

    scon->h = h;

    scon->tex_id = backing_id;

    scon->y0_top = backing_y_0_top;



    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);



    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {

        sdl2_set_scanout_mode(scon, false);

        return;

    }



    sdl2_set_scanout_mode(scon, true);

    if (!scon->fbo_id) {

        glGenFramebuffers(1, &scon->fbo_id);

    }



    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);

    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,

                              GL_TEXTURE_2D, scon->tex_id, 0);

}",196,,LABEL_1,LABEL_1,LABEL_1,-1,"dcl,backing_id,backing_y_0_top,x,y,w,h,scon",,,,0,,0,GA,1608,0.4308864752451579,failed,
137,"static void read_sgi_header(ByteIOContext *f, SGIInfo *info)
{
    info->magic = (unsigned short) get_be16(f);
    info->rle = get_byte(f);
    info->bytes_per_channel = get_byte(f);
    info->dimension = (unsigned short)get_be16(f);
    info->xsize = (unsigned short) get_be16(f);
    info->ysize = (unsigned short) get_be16(f);
    info->zsize = (unsigned short) get_be16(f);
#ifdef DEBUG
    printf(""sgi header fields:\n"");
    printf(""  magic: %d\n"", info->magic);
    printf(""    rle: %d\n"", info->rle);
    printf(""    bpc: %d\n"", info->bytes_per_channel);
    printf(""    dim: %d\n"", info->dimension);
    printf(""  xsize: %d\n"", info->xsize);
    printf(""  ysize: %d\n"", info->ysize);
    printf(""  zsize: %d\n"", info->zsize);
#endif
    return;
}",222,,LABEL_1,LABEL_1,LABEL_1,-1,"f,info",,,,0,,0,GA,475,0.12215240399042765,failed,
138,"static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,

                                   uint8_t devfn, hwaddr addr, bool is_write,

                                   IOMMUTLBEntry *entry)

{

    IntelIOMMUState *s = vtd_as->iommu_state;

    VTDContextEntry ce;

    uint8_t bus_num = pci_bus_num(bus);

    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;

    uint64_t slpte, page_mask;

    uint32_t level;

    uint16_t source_id = vtd_make_source_id(bus_num, devfn);

    int ret_fr;

    bool is_fpd_set = false;

    bool reads = true;

    bool writes = true;

    uint8_t access_flags;

    VTDIOTLBEntry *iotlb_entry;



    /*

     * We have standalone memory region for interrupt addresses, we

     * should never receive translation requests in this region.

     */

    assert(!vtd_is_interrupt_addr(addr));



    /* Try to fetch slpte form IOTLB */

    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);

    if (iotlb_entry) {

        trace_vtd_iotlb_page_hit(source_id, addr, iotlb_entry->slpte,

                                 iotlb_entry->domain_id);

        slpte = iotlb_entry->slpte;

        access_flags = iotlb_entry->access_flags;

        page_mask = iotlb_entry->mask;

        goto out;

    }



    /* Try to fetch context-entry from cache first */

    if (cc_entry->context_cache_gen == s->context_cache_gen) {

        trace_vtd_iotlb_cc_hit(bus_num, devfn, cc_entry->context_entry.hi,

                               cc_entry->context_entry.lo,

                               cc_entry->context_cache_gen);

        ce = cc_entry->context_entry;

        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;

    } else {

        ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce);

        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;

        if (ret_fr) {

            ret_fr = -ret_fr;

            if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {

                trace_vtd_fault_disabled();

            } else {

                vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);

            }

            goto error;

        }

        /* Update context-cache */

        trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo,

                                  cc_entry->context_cache_gen,

                                  s->context_cache_gen);

        cc_entry->context_entry = ce;

        cc_entry->context_cache_gen = s->context_cache_gen;

    }



    /*

     * We don't need to translate for pass-through context entries.

     * Also, let's ignore IOTLB caching as well for PT devices.

     */

    if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) {

        entry->iova = addr & VTD_PAGE_MASK_4K;

        entry->translated_addr = entry->iova;

        entry->addr_mask = ~VTD_PAGE_MASK_4K;

        entry->perm = IOMMU_RW;

        trace_vtd_translate_pt(source_id, entry->iova);



        /*

         * When this happens, it means firstly caching-mode is not

         * enabled, and this is the first passthrough translation for

         * the device. Let's enable the fast path for passthrough.

         *

         * When passthrough is disabled again for the device, we can

         * capture it via the context entry invalidation, then the

         * IOMMU region can be swapped back.

         */

        vtd_pt_enable_fast_path(s, source_id);



        return true;

    }



    ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level,

                               &reads, &writes);

    if (ret_fr) {

        ret_fr = -ret_fr;

        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {

            trace_vtd_fault_disabled();

        } else {

            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);

        }

        goto error;

    }



    page_mask = vtd_slpt_level_page_mask(level);

    access_flags = IOMMU_ACCESS_FLAG(reads, writes);

    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,

                     access_flags, level);

out:

    entry->iova = addr & page_mask;

    entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask;

    entry->addr_mask = ~page_mask;

    entry->perm = access_flags;

    return true;



error:

    entry->iova = 0;

    entry->translated_addr = 0;

    entry->addr_mask = 0;

    entry->perm = IOMMU_NONE;

    return false;

}
",740,"static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,

                                   uint8_t divn, hwaddr addr, bool is_write,

                                   IOMMUTLBEntry *entry)

{

    IntelIOMMUState *s = vtd_as->iommu_state;

    VTDContextEntry  je;

    uint8_t bus_num = pci_bus_num(bus);

    VTDContextCacheEntry *cc_archive = &vtd_as->context_cache_entry;

    uint64_t islpetie, page_max;

    uint32_t type;

    uint16_t source_id = vtd_make_source_id(bus_num, divn);

    int Ret_br;

    bool is_fpd_set = false;

    bool reads = true;

    bool writes = true;

    uint8_t access_flags;

    VTDIOTLBEntry *iotlb_index;



    /*

     * We have standalone memory region for interrupt addresses, we

     * should never receive translation requests in this region.

     */

    assert(!vtd_is_interrupt_addr(addr));



    /* Try to fetch islpetie form IOTLB */

    iotlb_index = vtd_lookup_iotlb(s, source_id, addr);

    if (iotlb_index) {

        trace_vtd_iotlb_page_hit(source_id, addr, iotiotlb_indexslpetie,

                                 iotlb_index->domain_id);

        islpetie = iotiotlb_indexslpetie;

        access_flags = iotlb_index->access_flags;

        page_max = iotlb_index->mask;

        goto out;

    }



    /* Try to fetch context-entry from cache first */

    if (cc_archive->context_cache_gen == s->context_cache_gen) {

        trace_vtd_iotlb_cc_hit(bus_num, divn, cc_archive->context_entry.hi,

                               cc_archive->context_entry.lo,

                               cc_archive->context_cache_gen);

         je = cc_archive->context_entry;

        is_fpd_set =  je.lo & VTD_CONTEXT_ENTRY_FPD;

    } else {

        Ret_br = vtd_dev_to_context_entryss, bus_num, divn, & je);

        is_fpd_set =  je.lo & VTD_CONTEXT_ENTRY_FPD;

        if (Ret_br) {

            Ret_br = -Ret_br;

            if (is_fpd_set && vtd_is_qualified_fault(Ret_br)) {

                trace_vtd_fault_disabled();

            } else {

                vtd_report_dmar_fault(s, source_id, addr, Ret_br, is_write);

            }

            goto error;

        }

        /* Update context-cache */

        trace_vtd_iotlb_cc_update(bus_num, divn,  je.hi,  je.lo,

                                  cc_archive->context_cache_gen,

                                  s->context_cache_gen);

        ccc_archive>context_entry =  je;

        cc_archive->context_cache_gen = s->context_cache_gen;

    }



    /*

     * We don't need to translate for pass-through context entries.

     * Also, let's ignore IOTLB caching as well for PT devices.

     */

    if (vtd_ce_get_type(& je) == VTD_CONTEXT_TT_PASS_THROUGH) {

        entry->iova = addr & VTD_PAGE_MASK_4K;

        entry->translated_addr = entry->iova;

        entry->addr_mask = ~VTD_PAGE_MASK_4K;

        entry->perm = IOMMU_RW;

        trace_vtd_translate_pt(source_id, entry->iova);



        /*

         * When this happens, it means firstly caching-mode is not

         * enabled, and this is the first passthrough translation for

         * the device. Let's enable the fast path for passthrough.

         *

         * When passthrough is disabled again for the device, we can

         * capture it via the context entry invalidation, then the

         * IOMMU region can be swapped back.

         */

        vtd_pt_enable_fast_path(s, source_id);



        return true;

    }



    retRet_brvtd_iova_to_slpte(& je, addr, is_write, &islpetie, &type,

                               &reads, &writes);

    if (Ret_br) {

        Ret_br = -Ret_br;

        if (is_fpd_set && vtd_is_qualified_fault(Ret_br)) {

            trace_vtd_fault_disabled();

        } else {

            vtd_report_dmar_fault(s, source_id, addr, Ret_br, is_write);

        }

        goto error;

    }



    page_max = vtd_slpt_level_page_mask(type);

    access_flags = IOMMU_ACCESS_FLAG(reads, writes);

    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID( je.hi), addr, islpetie,

                    access_flagss, type);

out:

    entry->iova = addr & page_max;

    entry->translated_addr = vtd_get_slpte_addr(islpetie) & page_max;

    entry->addr_mask = ~page_max;

    entry->perm = access_flags;

    return true;



error:

    entry->iova = 0;

    entry->translated_addr = 0;

    entry->addr_mask = 0;

    entry->perm = IOMMU_NONE;

    return false;

}
",LABEL_0,LABEL_0,LABEL_1,1,"vtd_as,bus,devfn,addr,is_write,entry,s,ce,cc_entry,slpte,page_mask,level,ret_fr,access_flags,iotlb_entry",,,,54,"vtd_as:vtd_as,bus:bus,devfn:divn,addr:addr,is_write:is_write,entry:entry,s:s,ce: je,cc_entry:cc_archive,slpte:islpetie,page_mask:page_max,level:type,ret_fr:Ret_br,access_flags:access_flags,iotlb_entry:iotlb_index,",7,GA,1079,0.3742162108421326,GA,
139,"static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)

{

	unsigned i;

#ifdef HAVE_MMX

	long mmx_size= 23 - src_size;

	asm volatile (

		""test %%""REG_a"", %%""REG_a""	\n\t""

		""jns 2f				\n\t""

		""movq ""MANGLE(mask24r)"", %%mm5	\n\t""

		""movq ""MANGLE(mask24g)"", %%mm6	\n\t""

		""movq ""MANGLE(mask24b)"", %%mm7	\n\t""

		ASMALIGN(4)

		""1:				\n\t""

		PREFETCH"" 32(%1, %%""REG_a"")	\n\t""

		""movq   (%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG

		""movq   (%1, %%""REG_a""), %%mm1	\n\t"" // BGR BGR BG

		""movq  2(%1, %%""REG_a""), %%mm2	\n\t"" // R BGR BGR B

		""psllq $16, %%mm0		\n\t"" // 00 BGR BGR

		""pand %%mm5, %%mm0		\n\t""

		""pand %%mm6, %%mm1		\n\t""

		""pand %%mm7, %%mm2		\n\t""

		""por %%mm0, %%mm1		\n\t""

		""por %%mm2, %%mm1		\n\t""

		""movq  6(%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG

		MOVNTQ"" %%mm1,   (%2, %%""REG_a"")\n\t"" // RGB RGB RG

		""movq  8(%1, %%""REG_a""), %%mm1	\n\t"" // R BGR BGR B

		""movq 10(%1, %%""REG_a""), %%mm2	\n\t"" // GR BGR BGR

		""pand %%mm7, %%mm0		\n\t""

		""pand %%mm5, %%mm1		\n\t""

		""pand %%mm6, %%mm2		\n\t""

		""por %%mm0, %%mm1		\n\t""

		""por %%mm2, %%mm1		\n\t""

		""movq 14(%1, %%""REG_a""), %%mm0	\n\t"" // R BGR BGR B

		MOVNTQ"" %%mm1,  8(%2, %%""REG_a"")\n\t"" // B RGB RGB R

		""movq 16(%1, %%""REG_a""), %%mm1	\n\t"" // GR BGR BGR

		""movq 18(%1, %%""REG_a""), %%mm2	\n\t"" // BGR BGR BG

		""pand %%mm6, %%mm0		\n\t""

		""pand %%mm7, %%mm1		\n\t""

		""pand %%mm5, %%mm2		\n\t""

		""por %%mm0, %%mm1		\n\t""

		""por %%mm2, %%mm1		\n\t""

		MOVNTQ"" %%mm1, 16(%2, %%""REG_a"")\n\t""

		""add $24, %%""REG_a""		\n\t""

		"" js 1b				\n\t""

		""2:				\n\t""

		: ""+a"" (mmx_size)

		: ""r"" (src-mmx_size), ""r""(dst-mmx_size)

	);



	__asm __volatile(SFENCE:::""memory"");

	__asm __volatile(EMMS:::""memory"");



	if(mmx_size==23) return; //finihsed, was multiple of 8



	src+= src_size;

	dst+= src_size;

	src_size= 23-mmx_size;

	src-= src_size;

	dst-= src_size;

#endif

	for(i=0; i<src_size; i+=3)

	{

		register uint8_t x;

		x          = src[i + 2];

		dst[i + 1] = src[i + 1];

		dst[i + 2] = src[i + 0];

		dst[i + 0] = x;

	}

}
",599,"static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *sddest, long src__scale)

{

	unsigned i;

#ifdef HAVE_MMX

	long mmx_size= 23 - src__scale;

	asm volatile (

		""test %%""REG_a"", %%""REG_a""	
\t""

		""jns 2f				
\t""

		""movq ""MANGLE(mask24r)"", %%mm5	
\t""

		""movq ""MANGLE(mask24g)"", %%mm6	
\t""

		""movq ""MANGLE(mask24b)"", %%mm7	
\t""

		ASMALIGN(4)

		""1:				
\t""

		PREFETCH"" 32(%1, %%""REG_a"")	
\t""

		""movq   (%1, %%""REG_a""), %%mm0	
\t"" // BGR BGR BG

		""movq   (%1, %%""REG_a""), %%mm1	
\t"" // BGR BGR BG

		""movq  2(%1, %%""REG_a""), %%mm2	
\t"" // R BGR BGR B

		""psllq $16, %%mm0		
\t"" // 00 BGR BGR

		""pand %%mm5, %%mm0		
\t""

		""pand %%mm6, %%mm1		
\t""

		""pand %%mm7, %%mm2		
\t""

		""por %%mm0, %%mm1		
\t""

		""por %%mm2, %%mm1		
\t""

		""movq  6(%1, %%""REG_a""), %%mm0	
\t"" // BGR BGR BG

		MOVNTQ"" %%mm1,   (%2, %%""REG_a"")
\t"" // RGB RGB RG

		""movq  8(%1, %%""REG_a""), %%mm1	
\t"" // R BGR BGR B

		""movq 10(%1, %%""REG_a""), %%mm2	
\t"" // GR BGR BGR

		""pand %%mm7, %%mm0		
\t""

		""pand %%mm5, %%mm1		
\t""

		""pand %%mm6, %%mm2		
\t""

		""por %%mm0, %%mm1		
\t""

		""por %%mm2, %%mm1		
\t""

		""movq 14(%1, %%""REG_a""), %%mm0	
\t"" // R BGR BGR B

		MOVNTQ"" %%mm1,  8(%2, %%""REG_a"")
\t"" // B RGB RGB R

		""movq 16(%1, %%""REG_a""), %%mm1	
\t"" // GR BGR BGR

		""movq 18(%1, %%""REG_a""), %%mm2	
\t"" // BGR BGR BG

		""pand %%mm6, %%mm0		
\t""

		""pand %%mm7, %%mm1		
\t""

		""pand %%mm5, %%mm2		
\t""

		""por %%mm0, %%mm1		
\t""

		""por %%mm2, %%mm1		
\t""

		MOVNTQ"" %%mm1, 16(%2, %%""REG_a"")
\t""

		""add $24, %%""REG_a""		
\t""

		"" js 1b				
\t""

		""2:				
\t""

		: ""+a"" (mmx_size)

		: ""r"" (src-mmx_size), ""r""(sddest-mmx_size)

	);



	__asm __volatile(SFENCE:::""memory"");

	__asm __volatile(EMMS:::""memory"");



	if(mmx_size==23) return; //finihsed, was multiple of 8



	src+= src__scale;

	sddest+= src__scale;

	src__scale= 23-mmx_size;

	src-= src__scale;

	sddest-= src__scale;

#endif

	for(i=i; i<irc__scale; i+=3)

	{

		register uint8_t xb;

		xb          = src[i + 2];

		sddest[i + 1] = src[i + 1];

		sddest[i + 2] = src[i + 0];

		sddest[i + 0] = xb;

	}

}
",LABEL_1,LABEL_1,LABEL_0,1,"src,dst,src_size,i,memory,x",,,,17,"src:src,dst:sddest,src_size:src__scale,i:i,x:xb,",2,GA,305,0.10175085067749023,GA,
140,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *pkt_data,

                                           size_t pkt_len)

{

    struct virtio_net_hdr *vhdr;

    bool isip4, isip6, istcp, isudp;

    uint8_t *data;

    int len;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);

    if (!(isip4 || isip6) || !(istcp || isudp)) {

        return;

    }



    vmxnet3_dump_virt_hdr(vhdr);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  len, vhdr->csum_start, vhdr->csum_offset);

        return;

    }



    data = (uint8_t *)pkt_data + vhdr->csum_start;

    len = pkt_len - vhdr->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));



    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",243,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *cpacket,

                                           const void *pkg_length,

                                           size_t pet_length)

{

    struct virtio_net_hdr *vohdi;

    bool iep4, isqlsix, astp, asubm;

    uint8_t *valid;

    int bl;



    if (!vmxnet_rx_pkt_has_virt_hdr(cpacket)) {

        return;

    }



    vhdrvohdimxnet_rx_pkt_get_vhdr(cpacket);

    if (!VMXNET_FLAG_IS_SET(vohdi->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(cpacket, &iep4, &isqlsix, asubmp, &astp);

    if (!(iep4 || isqlsix) || !(astp || asubm)) {

        return;

    }



    vmxnet3_dump_virt_hdr(vohdi);



    /* Validate packet bl: csum_start + scum_offset + length of csum field */

    if (pet_length < (vohdi->csum_start + vohdi->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  leblvohdi->csum_start, vohdi->csum_offset);

        return;

    }



    datvalid(uint8_t *)pkg_length + vohdi->csum_start;

    len blet_length - vohdi->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(dvalid+ vohdi->csum_offset, net_raw_checksum(valid, bl));



    vohdi->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    vohdi->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",LABEL_1,LABEL_1,LABEL_0,1,"pkt,pkt_data,pkt_len,vhdr,isip4,isip6,istcp,isudp,data,len",,,,0,"pkt:cpacket,pkt_data:pkg_length,pkt_len:pet_length,vhdr:vohdi,isip4:iep4,isip6:isqlsix,istcp:astp,isudp:asubm,data:valid,len:bl,",0,GA,987,0.27419708569844564,GA,
141,"static void apic_update_irq(APICCommonState *s)

{

    if (!(s->spurious_vec & APIC_SV_ENABLE)) {

        return;

    }

    if (apic_irq_pending(s) > 0) {

        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&

               pic_get_output(isa_pic)) {

        apic_deliver_pic_intr(&s->busdev.qdev, 1);

    }

}
",82,,LABEL_0,LABEL_0,LABEL_0,-1,s,,,,0,,0,GA,286,0.06821582317352295,failed,
142,"static void bamboo_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 };

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *isa = g_new(MemoryRegion, 1);

    MemoryRegion *ram_memories

        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));

    hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS];

    hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS];

    qemu_irq *pic;

    qemu_irq *irqs;

    PCIBus *pcibus;

    PowerPCCPU *cpu;

    CPUPPCState *env;

    uint64_t elf_entry;

    uint64_t elf_lowaddr;

    hwaddr loadaddr = 0;

    target_long initrd_size = 0;

    DeviceState *dev;

    int success;

    int i;



    /* Setup CPU. */

    if (machine->cpu_model == NULL) {

        machine->cpu_model = ""440EP"";

    }

    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""Unable to initialize CPU!\n"");

        exit(1);

    }

    env = &cpu->env;



    if (env->mmu_model != POWERPC_MMU_BOOKE) {

        fprintf(stderr, ""MMU model %i not supported by this machine.\n"",

            env->mmu_model);

        exit(1);

    }



    qemu_register_reset(main_cpu_reset, cpu);

    ppc_booke_timers_init(cpu, 400000000, 0);

    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);



    /* SDRAM controller */

    memset(ram_bases, 0, sizeof(ram_bases));

    memset(ram_sizes, 0, sizeof(ram_sizes));

    ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS,

                                   ram_memories,

                                   ram_bases, ram_sizes,

                                   ppc440ep_sdram_bank_sizes);

    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */

    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,

                      ram_bases, ram_sizes, 1);



    /* PCI */

    dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE,

                                PPC440EP_PCI_CONFIG,

                                pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]],

                                pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]],

                                NULL);

    pcibus = (PCIBus *)qdev_get_child_bus(dev, ""pci.0"");

    if (!pcibus) {

        fprintf(stderr, ""couldn't create PCI controller!\n"");

        exit(1);

    }



    memory_region_init_alias(isa, NULL, ""isa_mmio"",

                             get_system_io(), 0, PPC440EP_PCI_IOLEN);

    memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa);



    if (serial_hds[0] != NULL) {

        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],

                       DEVICE_BIG_ENDIAN);

    }

    if (serial_hds[1] != NULL) {

        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],

                       DEVICE_BIG_ENDIAN);

    }



    if (pcibus) {

        /* Register network interfaces. */

        for (i = 0; i < nb_nics; i++) {

            /* There are no PCI NICs on the Bamboo board, but there are

             * PCI slots, so we can pick whatever default model we want. */

            pci_nic_init_nofail(&nd_table[i], pcibus, ""e1000"", NULL);

        }

    }



    /* Load kernel. */

    if (kernel_filename) {

        success = load_uimage(kernel_filename, &entry, &loadaddr, NULL,

                              NULL, NULL);

        if (success < 0) {

            success = load_elf(kernel_filename, NULL, NULL, &elf_entry,

                               &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE,

                               0, 0);

            entry = elf_entry;

            loadaddr = elf_lowaddr;

        }

        /* XXX try again as binary */

        if (success < 0) {

            fprintf(stderr, ""qemu: could not load kernel '%s'\n"",

                    kernel_filename);

            exit(1);

        }

    }



    /* Load initrd. */

    if (initrd_filename) {

        initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,

                                          ram_size - RAMDISK_ADDR);



        if (initrd_size < 0) {

            fprintf(stderr, ""qemu: could not load ram disk '%s' at %x\n"",

                    initrd_filename, RAMDISK_ADDR);

            exit(1);

        }

    }



    /* If we're loading a kernel directly, we must load the device tree too. */

    if (kernel_filename) {

        if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,

                                    initrd_size, kernel_cmdline) < 0) {

            fprintf(stderr, ""couldn't load device tree\n"");

            exit(1);

        }

    }

}
",949,,LABEL_1,LABEL_1,LABEL_1,-1,"machine,kernel_filename,kernel_cmdline,initrd_filename,pci_irq_nrs,address_space_mem,isa,ram_memories,ram_bases,ram_sizes,pic,irqs,pcibus,cpu,env,elf_entry,elf_lowaddr,dev,success,i",,,,0,,0,GA,3700,1.4788592139879861,failed,
143,"static void test_qemu_strtosz_metric(void)

{

    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endptr == str + 6);

}
",53,"static void test_qemu_strtosz_metric(void)

{

    const char *pr = ""12345k"";

    char *startpointer = NULL;

    int64_t r;



    res =rmu_strtosz_metric(pr, &startpointer);

    g_assert_cmpint(r, ==, 12345000);

    g_assertstartpointerr == pr + 6);

}
",LABEL_0,LABEL_0,LABEL_1,1,"str,endptr,res",,,,0,"str:pr,endptr:startpointer,res:r,",0,GA,157,0.03619197607040405,GA,
144,"static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    int n;

    TCGv t0, t1;



    for (n = 0; n < q + 1; n += 2) {

        t0 = neon_load_reg(reg, n);

        t1 = neon_load_reg(reg, n + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, t1); break;

        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + n, t0);

        neon_store_scratch(tmp + n + 1, t1);

    }

}
",144,,LABEL_0,LABEL_1,,-4,"reg,q,tmp,size,n,t0,t1",,,,0,,0,Greedy,1,0.00044313669204711916,,
145,"static int bt_hid_in(struct bt_hid_device_s *s)

{

    USBPacket p;



    p.pid = USB_TOKEN_IN;

    p.devep = 1;

    p.data = s->datain.buffer;

    p.len = sizeof(s->datain.buffer);

    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);



    return s->datain.len;

}
",88,"static int bt_hid_in(struct bt_hid_device_s *data)

{

    USBPacket m;



    m.pid = USB_TOKEN_IN;

    m.devep = 1;

    p.dmta = data->datain.buffer;

    p.lmn = sizeof(data->datain.buffer);

    data->datain.len = data->usbdev->info->handle_data(data->usbdev, &m);



    return data->datain.len;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,p",,,,0,"s:data,p:m,",0,GA,137,0.03212907314300537,GA,
146,"int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port,

                              int lower_transport, const char *real_challenge)

{

    RTSPState *rt = s->priv_data;

    int rtx = 0, j, i, err, interleave = 0, port_off;

    RTSPStream *rtsp_st;

    RTSPMessageHeader reply1, *reply = &reply1;

    char cmd[2048];

    const char *trans_pref;



    if (rt->transport == RTSP_TRANSPORT_RDT)

        trans_pref = ""x-pn-tng"";

    else

        trans_pref = ""RTP/AVP"";



    /* default timeout: 1 minute */

    rt->timeout = 60;



    /* for each stream, make the setup request */

    /* XXX: we assume the same server is used for the control of each

     * RTSP stream */



    /* Choose a random starting offset within the first half of the

     * port range, to allow for a number of ports to try even if the offset

     * happens to be at the end of the random range. */

    port_off = av_get_random_seed() % ((rt->rtp_port_max - rt->rtp_port_min)/2);

    /* even random offset */

    port_off -= port_off & 0x01;



    for (j = rt->rtp_port_min + port_off, i = 0; i < rt->nb_rtsp_streams; ++i) {

        char transport[2048];



        /*

         * WMS serves all UDP data over a single connection, the RTX, which

         * isn't necessarily the first in the SDP but has to be the first

         * to be set up, else the second/third SETUP will fail with a 461.

         */

        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP &&

             rt->server_type == RTSP_SERVER_WMS) {

            if (i == 0) {

                /* rtx first */

                for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {

                    int len = strlen(rt->rtsp_streams[rtx]->control_url);

                    if (len >= 4 &&

                        !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,

                                ""/rtx""))

                        break;

                }

                if (rtx == rt->nb_rtsp_streams)

                    return -1; /* no RTX found */

                rtsp_st = rt->rtsp_streams[rtx];

            } else

                rtsp_st = rt->rtsp_streams[i > rtx ? i : i - 1];

        } else

            rtsp_st = rt->rtsp_streams[i];



        /* RTP/UDP */

        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP) {

            char buf[256];



            if (rt->server_type == RTSP_SERVER_WMS && i > 1) {

                port = reply->transports[0].client_port_min;

                goto have_port;

            }



            /* first try in specified port range */

            while (j <= rt->rtp_port_max) {

                ff_url_join(buf, sizeof(buf), ""rtp"", NULL, host, -1,

                            ""?localport=%d"", j);

                /* we will use two ports per rtp stream (rtp and rtcp) */

                j += 2;

                if (!ffurl_open(&rtsp_st->rtp_handle, buf, AVIO_FLAG_READ_WRITE,

                               &s->interrupt_callback, NULL))

                    goto rtp_opened;

            }



            av_log(s, AV_LOG_ERROR, ""Unable to open an input RTP port\n"");

            err = AVERROR(EIO);

            goto fail;



        rtp_opened:

            port = ff_rtp_get_local_rtp_port(rtsp_st->rtp_handle);

        have_port:

            snprintf(transport, sizeof(transport) - 1,

                     ""%s/UDP;"", trans_pref);

            if (rt->server_type != RTSP_SERVER_REAL)

                av_strlcat(transport, ""unicast;"", sizeof(transport));

            av_strlcatf(transport, sizeof(transport),

                     ""client_port=%d"", port);

            if (rt->transport == RTSP_TRANSPORT_RTP &&

                !(rt->server_type == RTSP_SERVER_WMS && i > 0))

                av_strlcatf(transport, sizeof(transport), ""-%d"", port + 1);

        }



        /* RTP/TCP */

        else if (lower_transport == RTSP_LOWER_TRANSPORT_TCP) {

            /* For WMS streams, the application streams are only used for

             * UDP. When trying to set it up for TCP streams, the server

             * will return an error. Therefore, we skip those streams. */

            if (rt->server_type == RTSP_SERVER_WMS &&

                (rtsp_st->stream_index < 0 ||

                 s->streams[rtsp_st->stream_index]->codec->codec_type ==

                    AVMEDIA_TYPE_DATA))

                continue;

            snprintf(transport, sizeof(transport) - 1,

                     ""%s/TCP;"", trans_pref);

            if (rt->transport != RTSP_TRANSPORT_RDT)

                av_strlcat(transport, ""unicast;"", sizeof(transport));

            av_strlcatf(transport, sizeof(transport),

                        ""interleaved=%d-%d"",

                        interleave, interleave + 1);

            interleave += 2;

        }



        else if (lower_transport == RTSP_LOWER_TRANSPORT_UDP_MULTICAST) {

            snprintf(transport, sizeof(transport) - 1,

                     ""%s/UDP;multicast"", trans_pref);

        }

        if (s->oformat) {

            av_strlcat(transport, "";mode=receive"", sizeof(transport));

        } else if (rt->server_type == RTSP_SERVER_REAL ||

                   rt->server_type == RTSP_SERVER_WMS)

            av_strlcat(transport, "";mode=play"", sizeof(transport));

        snprintf(cmd, sizeof(cmd),

                 ""Transport: %s\r\n"",

                 transport);

        if (rt->accept_dynamic_rate)

            av_strlcat(cmd, ""x-Dynamic-Rate: 0\r\n"", sizeof(cmd));

        if (i == 0 && rt->server_type == RTSP_SERVER_REAL && CONFIG_RTPDEC) {

            char real_res[41], real_csum[9];

            ff_rdt_calc_response_and_checksum(real_res, real_csum,

                                              real_challenge);

            av_strlcatf(cmd, sizeof(cmd),

                        ""If-Match: %s\r\n""

                        ""RealChallenge2: %s, sd=%s\r\n"",

                        rt->session_id, real_res, real_csum);

        }

        ff_rtsp_send_cmd(s, ""SETUP"", rtsp_st->control_url, cmd, reply, NULL);

        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {

            err = 1;

            goto fail;

        } else if (reply->status_code != RTSP_STATUS_OK ||

                   reply->nb_transports != 1) {

            err = AVERROR_INVALIDDATA;

            goto fail;

        }



        /* XXX: same protocol for all streams is required */

        if (i > 0) {

            if (reply->transports[0].lower_transport != rt->lower_transport ||

                reply->transports[0].transport != rt->transport) {

                err = AVERROR_INVALIDDATA;

                goto fail;

            }

        } else {

            rt->lower_transport = reply->transports[0].lower_transport;

            rt->transport = reply->transports[0].transport;

        }



        /* Fail if the server responded with another lower transport mode

         * than what we requested. */

        if (reply->transports[0].lower_transport != lower_transport) {

            av_log(s, AV_LOG_ERROR, ""Nonmatching transport in server reply\n"");

            err = AVERROR_INVALIDDATA;

            goto fail;

        }



        switch(reply->transports[0].lower_transport) {

        case RTSP_LOWER_TRANSPORT_TCP:

            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;

            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;

            break;



        case RTSP_LOWER_TRANSPORT_UDP: {

            char url[1024], options[30] = """";



            if (rt->rtsp_flags & RTSP_FLAG_FILTER_SRC)

                av_strlcpy(options, ""?connect=1"", sizeof(options));

            /* Use source address if specified */

            if (reply->transports[0].source[0]) {

                ff_url_join(url, sizeof(url), ""rtp"", NULL,

                            reply->transports[0].source,

                            reply->transports[0].server_port_min, ""%s"", options);

            } else {

                ff_url_join(url, sizeof(url), ""rtp"", NULL, host,

                            reply->transports[0].server_port_min, ""%s"", options);

            }

            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) &&

                ff_rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {

                err = AVERROR_INVALIDDATA;

                goto fail;

            }

            /* Try to initialize the connection state in a

             * potential NAT router by sending dummy packets.

             * RTP/RTCP dummy packets are used for RDT, too.

             */

            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) && s->iformat &&

                CONFIG_RTPDEC)

                ff_rtp_send_punch_packets(rtsp_st->rtp_handle);

            break;

        }

        case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: {

            char url[1024], namebuf[50], optbuf[20] = """";

            struct sockaddr_storage addr;

            int port, ttl;



            if (reply->transports[0].destination.ss_family) {

                addr      = reply->transports[0].destination;

                port      = reply->transports[0].port_min;

                ttl       = reply->transports[0].ttl;

            } else {

                addr      = rtsp_st->sdp_ip;

                port      = rtsp_st->sdp_port;

                ttl       = rtsp_st->sdp_ttl;

            }

            if (ttl > 0)

                snprintf(optbuf, sizeof(optbuf), ""?ttl=%d"", ttl);

            getnameinfo((struct sockaddr*) &addr, sizeof(addr),

                        namebuf, sizeof(namebuf), NULL, 0, NI_NUMERICHOST);

            ff_url_join(url, sizeof(url), ""rtp"", NULL, namebuf,

                        port, ""%s"", optbuf);

            if (ffurl_open(&rtsp_st->rtp_handle, url, AVIO_FLAG_READ_WRITE,

                           &s->interrupt_callback, NULL) < 0) {

                err = AVERROR_INVALIDDATA;

                goto fail;

            }

            break;

        }

        }



        if ((err = rtsp_open_transport_ctx(s, rtsp_st)))

            goto fail;

    }



    if (reply->timeout > 0)

        rt->timeout = reply->timeout;



    if (rt->server_type == RTSP_SERVER_REAL)

        rt->need_subscription = 1;



    return 0;



fail:

    ff_rtsp_undo_setup(s);

    return err;

}
",1873,,LABEL_1,LABEL_0,,-4,"s,host,port,lower_transport,real_challenge,rt,j,i,err,port_off,rtsp_st,reply1,reply,cmd,trans_pref,transport,rtx,buf",,,,0,,0,Greedy,1,0.0014777620633443197,,
147,"static int mux_chr_can_read(void *opaque)

{

    CharDriverState *chr = opaque;

    MuxDriver *d = chr->opaque;



    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)

        return 1;

    if (d->chr_can_read[chr->focus])

        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);

    return 0;

}
",85,,LABEL_1,LABEL_0,,-4,"opaque,chr,d",,,,0,,0,Greedy,1,0.0004618684450785319,,
148,"void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();",70,,LABEL_1,LABEL_1,LABEL_1,-1,"env,rip,syndrome,ri",,,,0,,0,GA,729,0.1763401707013448,failed,
149,"static void net_l2tpv3_cleanup(NetClientState *nc)

{

    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);

    qemu_purge_queued_packets(nc);

    l2tpv3_read_poll(s, false);

    l2tpv3_write_poll(s, false);

    if (s->fd > 0) {

        close(s->fd);

    }

    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);

    g_free(s->vec);

    g_free(s->header_buf);

    g_free(s->dgram_dst);

}
",98,,LABEL_1,LABEL_0,,-4,"nc,s",,,,0,,0,Greedy,1,0.0004944205284118652,,
150,"static int send_png_rect(VncState *vs, int x, int y, int w, int h,

                         VncPalette *palette)

{

    png_byte color_type;

    png_structp png_ptr;

    png_infop info_ptr;

    png_colorp png_palette = NULL;

    pixman_image_t *linebuf;

    int level = tight_png_conf[vs->tight.compression].png_zlib_level;

    int filters = tight_png_conf[vs->tight.compression].png_filters;

    uint8_t *buf;

    int dy;



    png_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL,

                                        NULL, vnc_png_malloc, vnc_png_free);



    if (png_ptr == NULL)

        return -1;



    info_ptr = png_create_info_struct(png_ptr);



    if (info_ptr == NULL) {

        png_destroy_write_struct(&png_ptr, NULL);

        return -1;

    }



    png_set_write_fn(png_ptr, (void *) vs, png_write_data, png_flush_data);

    png_set_compression_level(png_ptr, level);

    png_set_filter(png_ptr, PNG_FILTER_TYPE_DEFAULT, filters);



    if (palette) {

        color_type = PNG_COLOR_TYPE_PALETTE;

    } else {

        color_type = PNG_COLOR_TYPE_RGB;

    }



    png_set_IHDR(png_ptr, info_ptr, w, h,

                 8, color_type, PNG_INTERLACE_NONE,

                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);



    if (color_type == PNG_COLOR_TYPE_PALETTE) {

        struct palette_cb_priv priv;



        png_palette = png_malloc(png_ptr, sizeof(*png_palette) *

                                 palette_size(palette));



        priv.vs = vs;

        priv.png_palette = png_palette;

        palette_iter(palette, write_png_palette, &priv);



        png_set_PLTE(png_ptr, info_ptr, png_palette, palette_size(palette));



        if (vs->client_pf.bytes_per_pixel == 4) {

            tight_encode_indexed_rect32(vs->tight.tight.buffer, w * h, palette);

        } else {

            tight_encode_indexed_rect16(vs->tight.tight.buffer, w * h, palette);

        }

    }



    png_write_info(png_ptr, info_ptr);



    buffer_reserve(&vs->tight.png, 2048);

    linebuf = qemu_pixman_linebuf_create(PIXMAN_BE_r8g8b8, w);

    buf = (uint8_t *)pixman_image_get_data(linebuf);

    for (dy = 0; dy < h; dy++)

    {

        if (color_type == PNG_COLOR_TYPE_PALETTE) {

            memcpy(buf, vs->tight.tight.buffer + (dy * w), w);

        } else {

            qemu_pixman_linebuf_fill(linebuf, vs->vd->server, w, dy);

        }

        png_write_row(png_ptr, buf);

    }

    qemu_pixman_image_unref(linebuf);



    png_write_end(png_ptr, NULL);



    if (color_type == PNG_COLOR_TYPE_PALETTE) {

        png_free(png_ptr, png_palette);

    }



    png_destroy_write_struct(&png_ptr, &info_ptr);



    vnc_write_u8(vs, VNC_TIGHT_PNG << 4);



    tight_send_compact_size(vs, vs->tight.png.offset);

    vnc_write(vs, vs->tight.png.buffer, vs->tight.png.offset);

    buffer_reset(&vs->tight.png);

    return 1;

}
",534,,LABEL_0,LABEL_1,,-4,"vs,x,y,w,h,palette,color_type,png_ptr,info_ptr,linebuf,buf,dy,priv",,,,0,,0,Greedy,1,0.0007712523142496745,,
151,"int vc1_decode_sequence_header(AVCodecContext *avctx, VC1Context *v, GetBitContext *gb)

{

    av_log(avctx, AV_LOG_DEBUG, ""Header: %0X\n"", show_bits(gb, 32));

    v->profile = get_bits(gb, 2);

    if (v->profile == PROFILE_COMPLEX)

    {

        av_log(avctx, AV_LOG_WARNING, ""WMV3 Complex Profile is not fully supported\n"");

    }



    if (v->profile == PROFILE_ADVANCED)

    {

        v->zz_8x4 = ff_vc1_adv_progressive_8x4_zz;

        v->zz_4x8 = ff_vc1_adv_progressive_4x8_zz;

        return decode_sequence_header_adv(v, gb);

    }

    else

    {

        v->zz_8x4 = wmv2_scantableA;

        v->zz_4x8 = wmv2_scantableB;

        v->res_y411   = get_bits1(gb);

        v->res_sprite = get_bits1(gb);

        if (v->res_y411)

        {

            av_log(avctx, AV_LOG_ERROR,

                   ""Old interlaced mode is not supported\n"");

            return -1;

        }

        if (v->res_sprite) {

            av_log(avctx, AV_LOG_ERROR, ""WMVP is not fully supported\n"");

        }

    }



    // (fps-2)/4 (->30)

    v->frmrtq_postproc = get_bits(gb, 3); //common

    // (bitrate-32kbps)/64kbps

    v->bitrtq_postproc = get_bits(gb, 5); //common

    v->s.loop_filter = get_bits1(gb); //common

    if(v->s.loop_filter == 1 && v->profile == PROFILE_SIMPLE)

    {

        av_log(avctx, AV_LOG_ERROR,

               ""LOOPFILTER shall not be enabled in Simple Profile\n"");

    }

    if(v->s.avctx->skip_loop_filter >= AVDISCARD_ALL)

        v->s.loop_filter = 0;



    v->res_x8 = get_bits1(gb); //reserved

    v->multires = get_bits1(gb);

    v->res_fasttx = get_bits1(gb);

    if (!v->res_fasttx)

    {

        v->vc1dsp.vc1_inv_trans_8x8 = ff_simple_idct_8;

        v->vc1dsp.vc1_inv_trans_8x4 = ff_simple_idct84_add;

        v->vc1dsp.vc1_inv_trans_4x8 = ff_simple_idct48_add;

        v->vc1dsp.vc1_inv_trans_4x4 = ff_simple_idct44_add;

        v->vc1dsp.vc1_inv_trans_8x8_dc = ff_simple_idct_add_8;

        v->vc1dsp.vc1_inv_trans_8x4_dc = ff_simple_idct84_add;

        v->vc1dsp.vc1_inv_trans_4x8_dc = ff_simple_idct48_add;

        v->vc1dsp.vc1_inv_trans_4x4_dc = ff_simple_idct44_add;

    }



    v->fastuvmc =  get_bits1(gb); //common

    if (!v->profile && !v->fastuvmc)

    {

        av_log(avctx, AV_LOG_ERROR,

               ""FASTUVMC unavailable in Simple Profile\n"");

        return -1;

    }

    v->extended_mv =  get_bits1(gb); //common

    if (!v->profile && v->extended_mv)

    {

        av_log(avctx, AV_LOG_ERROR,

               ""Extended MVs unavailable in Simple Profile\n"");

        return -1;

    }

    v->dquant =  get_bits(gb, 2); //common

    v->vstransform =  get_bits1(gb); //common



    v->res_transtab = get_bits1(gb);

    if (v->res_transtab)

    {

        av_log(avctx, AV_LOG_ERROR,

               ""1 for reserved RES_TRANSTAB is forbidden\n"");

        return -1;

    }



    v->overlap = get_bits1(gb); //common



    v->s.resync_marker = get_bits1(gb);

    v->rangered = get_bits1(gb);

    if (v->rangered && v->profile == PROFILE_SIMPLE)

    {

        av_log(avctx, AV_LOG_INFO,

               ""RANGERED should be set to 0 in Simple Profile\n"");

    }



    v->s.max_b_frames = avctx->max_b_frames = get_bits(gb, 3); //common

    v->quantizer_mode = get_bits(gb, 2); //common



    v->finterpflag = get_bits1(gb); //common



    if (v->res_sprite) {

        v->s.avctx->width  = v->s.avctx->coded_width  = get_bits(gb, 11);

        v->s.avctx->height = v->s.avctx->coded_height = get_bits(gb, 11);

        skip_bits(gb, 5); //frame rate

        v->res_x8 = get_bits1(gb);

        if (get_bits1(gb)) { // something to do with DC VLC selection

            av_log(avctx, AV_LOG_ERROR, ""Unsupported sprite feature\n"");

            return -1;

        }

        skip_bits(gb, 3); //slice code

        v->res_rtm_flag = 0;

    } else {

        v->res_rtm_flag = get_bits1(gb); //reserved

    }

    if (!v->res_rtm_flag)

    {

//            av_log(avctx, AV_LOG_ERROR,

//                   ""0 for reserved RES_RTM_FLAG is forbidden\n"");

        av_log(avctx, AV_LOG_ERROR,

               ""Old WMV3 version detected, some frames may be decoded incorrectly\n"");

        //return -1;

    }

    //TODO: figure out what they mean (always 0x402F)

    if(!v->res_fasttx) skip_bits(gb, 16);

    av_log(avctx, AV_LOG_DEBUG,

               ""Profile %i:\nfrmrtq_postproc=%i, bitrtq_postproc=%i\n""

               ""LoopFilter=%i, MultiRes=%i, FastUVMC=%i, Extended MV=%i\n""

               ""Rangered=%i, VSTransform=%i, Overlap=%i, SyncMarker=%i\n""

               ""DQuant=%i, Quantizer mode=%i, Max B frames=%i\n"",

               v->profile, v->frmrtq_postproc, v->bitrtq_postproc,

               v->s.loop_filter, v->multires, v->fastuvmc, v->extended_mv,

               v->rangered, v->vstransform, v->overlap, v->s.resync_marker,

               v->dquant, v->quantizer_mode, avctx->max_b_frames

               );

    return 0;

}
",1090,,LABEL_1,LABEL_0,,-4,"avctx,v,gb",,,,0,,0,Greedy,1,0.001139648755391439,,
152,"static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,

                            uint64_t *data)

{

    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);

    uint32_t val;



    switch(addr) {

    case 0x00:

        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);

        break;

    case 0x02:

        val = s->ar.pm1.evt.en;

        break;

    case 0x04:

        val = s->ar.pm1.cnt.cnt;

        break;

    case 0x08:

        val = acpi_pm_tmr_get(&s->ar);

        break;

    default:

        val = 0;

        break;

    }

    PIIX4_DPRINTF(""PM readw port=0x%04x val=0x%04x\n"", (unsigned int)addr, val);

    *data = val;

}
",164,,LABEL_1,LABEL_0,,-4,"ioport,addr,data,s,val",,,,0,,0,Greedy,1,0.0004982352256774902,,
153,"static int mpc8_decode_frame(AVCodecContext * avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    MPCContext *c = avctx->priv_data;

    GetBitContext gb2, *gb = &gb2;

    int i, j, k, ch, cnt, res, t;

    Band *bands = c->bands;

    int off;

    int maxband, keyframe;

    int last[2];



    keyframe = c->cur_frame == 0;



    if(keyframe){

        memset(c->Q, 0, sizeof(c->Q));

        c->last_bits_used = 0;

    }

    init_get_bits(gb, buf, buf_size * 8);

    skip_bits(gb, c->last_bits_used & 7);



    if(keyframe)

        maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1);

    else{

        maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);

        if(maxband > 32) maxband -= 33;

    }

    c->last_max_band = maxband;



    /* read subband indexes */

    if(maxband){

        last[0] = last[1] = 0;

        for(i = maxband - 1; i >= 0; i--){

            for(ch = 0; ch < 2; ch++){

                last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch];

                if(last[ch] > 15) last[ch] -= 17;

                bands[i].res[ch] = last[ch];

            }

        }

        if(c->MSS){

            int mask;



            cnt = 0;

            for(i = 0; i < maxband; i++)

                if(bands[i].res[0] || bands[i].res[1])

                    cnt++;

            t = mpc8_get_mod_golomb(gb, cnt);

            mask = mpc8_get_mask(gb, cnt, t);

            for(i = maxband - 1; i >= 0; i--)

                if(bands[i].res[0] || bands[i].res[1]){

                    bands[i].msf = mask & 1;

                    mask >>= 1;

                }

        }

    }

    for(i = maxband; i < c->maxbands; i++)

        bands[i].res[0] = bands[i].res[1] = 0;



    if(keyframe){

        for(i = 0; i < 32; i++)

            c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1;

    }



    for(i = 0; i < maxband; i++){

        if(bands[i].res[0] || bands[i].res[1]){

            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;

            if(cnt >= 0){

                t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);

                if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt);

                if(bands[i].res[1]) bands[i].scfi[1] = t & 3;

            }

        }

    }



    for(i = 0; i < maxband; i++){

        for(ch = 0; ch < 2; ch++){

            if(!bands[i].res[ch]) continue;



            if(c->oldDSCF[ch][i]){

                bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6;

                c->oldDSCF[ch][i] = 0;

            }else{

                t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);

                if(t == 64)

                    t += get_bits(gb, 6);

                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6;

            }

            for(j = 0; j < 2; j++){

                if((bands[i].scfi[ch] << j) & 2)

                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];

                else{

                    t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);

                    if(t == 31)

                        t = 64 + get_bits(gb, 6);

                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6;

                }

            }

        }

    }



    for(i = 0, off = 0; i < maxband; i++, off += SAMPLES_PER_BAND){

        for(ch = 0; ch < 2; ch++){

            res = bands[i].res[ch];

            switch(res){

            case -1:

                for(j = 0; j < SAMPLES_PER_BAND; j++)

                    c->Q[ch][off + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510;

                break;

            case 0:

                break;

            case 1:

                for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){

                    cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2);

                    t = mpc8_get_mask(gb, 18, cnt);

                    for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1)

                        c->Q[ch][off + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0;

                }

                break;

            case 2:

                cnt = 6;//2*mpc8_thres[res]

                for(j = 0; j < SAMPLES_PER_BAND; j += 3){

                    t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2);

                    c->Q[ch][off + j + 0] = mpc8_idx50[t];

                    c->Q[ch][off + j + 1] = mpc8_idx51[t];

                    c->Q[ch][off + j + 2] = mpc8_idx52[t];

                    cnt = (cnt >> 1) + mpc8_huffq2[t];

                }

                break;

            case 3:

            case 4:

                for(j = 0; j < SAMPLES_PER_BAND; j += 2){

                    t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];

                    c->Q[ch][off + j + 1] = t >> 4;

                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);

                }

                break;

            case 5:

            case 6:

            case 7:

            case 8:

                cnt = 2 * mpc8_thres[res];

                for(j = 0; j < SAMPLES_PER_BAND; j++){

                    t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];

                    c->Q[ch][off + j] = t;

                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);

                }

                break;

            default:

                for(j = 0; j < SAMPLES_PER_BAND; j++){

                    c->Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);

                    if(res != 9){

                        c->Q[ch][off + j] <<= res - 9;

                        c->Q[ch][off + j] |= get_bits(gb, res - 9);

                    }

                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;

                }

            }

        }

    }



    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);



    c->cur_frame++;



    c->last_bits_used = get_bits_count(gb);

    if(c->cur_frame >= c->frames)

        c->cur_frame = 0;

    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;



    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;

}
",1786,"static int mpc8_decode_frame(AVCodecContext * avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    MPCContext *c = avctx->priv_data;

    GetBitContext cvv, *b = &cvv;

    int i, j, k, ch, cnt, res, t;

    Band *bands = c->bands;

    int off;

    int maxband, keyframe;

    int last[2];



    keyframe = c->cur_frame == 0;



    if(keyframe){

        memset(c->Q, 0, sizeof(c->Q));

        c->last_bits_used = 0;

    }

    init_get_bits(b, buf, buf_size * 8);

    skip_bits(b, c->last_bits_used & 7);



    if(keyframe)

       maxbandd = mpc8_get_mod_golomb(b, c->maxbands + 1);

    else{

       maxbandd = c->last_max_band + get_vlc2(b, band_vlc.table, MPC8_BANDS_BITS, 2);

        if(maxband > 32) maxband -= 33;

    }

    c->last_max_band = maxband;



    /* read subband indexes */

    if(maxband){

        last[0] = last[1] = 0;

        for(i = maxband - 1; i >= 0; i--){

            for(ch = 0; ch < 2; ch++){

               lasttchh] = get_vlc2(b, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch];

                if(last[ch] > 15) last[ch] -= 17;

                bands[i].res[ch] = last[ch];

            }

        }

        if(c->MSS){

            int mask;



            cnt = 0;

            for(i = 0; i < maxband; i++)

                if(bands[i].res[0] || bands[i].res[1])

                    cnt++;

           tt = mpc8_get_mod_golomb(b, cnt);

           maskk = mpc8_get_mask(b, cnt, t);

            for(i = maxband - 1; i >= 0; i--)

                if(bands[i].res[0] || bands[i].res[1]){

                    bands[i].msf = mask & 1;

                    mask >>= 1;

                }

        }

    }

    for(i = maxband; i < c->maxbands; i++)

        bands[i].res[0] = bands[i].res[1] = 0;



    if(keyframe){

        for(i = 0; i < 32; i++)

            c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1;

    }



    for(i = 0; i < maxband; i++){

        if(bands[i].res[0] || bands[i].res[1]){

            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;

            if(cnt >= 0){

               tt = get_vlc2(b, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);

                if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt);

                if(bands[i].res[1]) bands[i].scfi[1] = t & 3;

            }

        }

    }



    for(i = 0; i < maxband; i++){

        for(ch = 0; ch < 2; ch++){

            if(!bands[i].res[ch]) continue;



            if(c->oldDSCF[ch][i]){

               bandssii].scf_idxchh][0] = get_bits(b, 7) - 6;

                c->oldDSCF[ch][i] = 0;

            }else{

               tt = get_vlc2(b, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);

                if(t == 64)

                   tt += get_bits(b, 6);

                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6;

            }

            for(j = 0; j < 2; j++){

                if((bands[i].scfi[ch] << j) & 2)

                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];

                else{

                   tt = get_vlc2(b, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);

                    if(t == 31)

                       tt = 64 + get_bits(b, 6);

                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6;

                }

            }

        }

    }



    for(i = 0, off = 0; i < maxband; i++, off += SAMPLES_PER_BAND){

        for(ch = 0; ch < 2; ch++){

            res = bands[i].res[ch];

            switch(res){

            case -1:

                for(j = 0; j < SAMPLES_PER_BAND; j++)

                    c->Q[ch][off + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510;

                break;

            case 0:

                break;

            case 1:

                for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){

                   cntt = get_vlc2(b, q1_vlc.table, MPC8_Q1_BITS, 2);

                   tt = mpc8_get_mask(b, 18, cnt);

                    for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1)

                        c->Qchh]offf +jj +kk] = tt & 0x20000) ? (get_bits1(b) << 1) - 1 : 0;

                }

                break;

            case 2:

                cnt = 6;//2*mpc8_thres[res]

                for(j = 0; j < SAMPLES_PER_BAND; j += 3){

                   tt = get_vlc2(b, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2);

                    c->Q[ch][off + j + 0] = mpc8_idx50[t];

                    c->Q[ch][off + j + 1] = mpc8_idx51[t];

                    c->Q[ch][off + j + 2] = mpc8_idx52[t];

                    cnt = (cnt >> 1) + mpc8_huffq2[t];

                }

                break;

            case 3:

            case 4:

                for(j = 0; j < SAMPLES_PER_BAND; j += 2){

                   tt = get_vlc2(b, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];

                    c->Q[ch][off + j + 1] = t >> 4;

                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);

                }

                break;

            case 5:

            case 6:

            case 7:

            case 8:

                cnt = 2 * mpc8_thres[res];

                for(j = 0; j < SAMPLES_PER_BAND; j++){

                   tt = get_vlc2(b, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];

                    c->Q[ch][off + j] = t;

                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);

                }

                break;

            default:

                for(j = 0; j < SAMPLES_PER_BAND; j++){

                    c->Qchh]offf +jj] = get_vlc2(b, q9up_vlc.table, MPC8_Q9UP_BITS, 2);

                    if(res != 9){

                        c->Q[ch][off + j] <<= res - 9;

                        c->Qchh]offf +jj] |= get_bits(b, res - 9);

                    }

                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;

                }

            }

        }

    }



    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);



    c->cur_frame++;



    c->last_bits_used = get_bits_count(b);

    if(c->cur_frame >= c->frames)

        c->cur_frame = 0;

    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;



    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,data,data_size,avpkt,buf,c,gb2,gb,i,j,k,ch,cnt,res,t,bands,off,maxband,keyframe,last,mask,cur_frame",,,,354,"avctx:avctx,data:data,data_size:data_size,avpkt:avpkt,buf:buf,c:c,gb2:cvv,gb:b,i:i,j:j,k:k,ch:ch,cnt:cnt,res:res,t:t,bands:bands,off:off,maxband:maxband,keyframe:keyframe,last:last,mask:mask,cur_frame:cur_frame,",20,GA,999,0.4555712938308716,GA,
154,"int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (err)

        return err;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            uc->is_streamed = 1;

    return 0;

}
",159,,LABEL_0,LABEL_0,LABEL_0,-1,"uc,options",,,,0,,0,GA,451,0.10737991333007812,failed,
155,"build_madt(GArray *table_data, BIOSLinker *linker, VirtGuestInfo *guest_info)

{

    int madt_start = table_data->len;

    const MemMapEntry *memmap = guest_info->memmap;

    const int *irqmap = guest_info->irqmap;

    AcpiMultipleApicTable *madt;

    AcpiMadtGenericDistributor *gicd;

    AcpiMadtGenericMsiFrame *gic_msi;

    int i;



    madt = acpi_data_push(table_data, sizeof *madt);



    gicd = acpi_data_push(table_data, sizeof *gicd);

    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;

    gicd->length = sizeof(*gicd);

    gicd->base_address = memmap[VIRT_GIC_DIST].base;

    gicd->version = guest_info->gic_version;



    for (i = 0; i < guest_info->smp_cpus; i++) {

        AcpiMadtGenericInterrupt *gicc = acpi_data_push(table_data,

                                                     sizeof *gicc);

        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(i));



        gicc->type = ACPI_APIC_GENERIC_INTERRUPT;

        gicc->length = sizeof(*gicc);

        if (guest_info->gic_version == 2) {

            gicc->base_address = memmap[VIRT_GIC_CPU].base;

        }

        gicc->cpu_interface_number = i;

        gicc->arm_mpidr = armcpu->mp_affinity;

        gicc->uid = i;

        gicc->flags = cpu_to_le32(ACPI_GICC_ENABLED);



        if (armcpu->has_pmu) {

            gicc->performance_interrupt = cpu_to_le32(PPI(VIRTUAL_PMU_IRQ));

        }

    }



    if (guest_info->gic_version == 3) {

        AcpiMadtGenericTranslator *gic_its;

        AcpiMadtGenericRedistributor *gicr = acpi_data_push(table_data,

                                                         sizeof *gicr);



        gicr->type = ACPI_APIC_GENERIC_REDISTRIBUTOR;

        gicr->length = sizeof(*gicr);

        gicr->base_address = cpu_to_le64(memmap[VIRT_GIC_REDIST].base);

        gicr->range_length = cpu_to_le32(memmap[VIRT_GIC_REDIST].size);



        if (its_class_name()) {

            gic_its = acpi_data_push(table_data, sizeof *gic_its);

            gic_its->type = ACPI_APIC_GENERIC_TRANSLATOR;

            gic_its->length = sizeof(*gic_its);

            gic_its->translation_id = 0;

            gic_its->base_address = cpu_to_le64(memmap[VIRT_GIC_ITS].base);

        }

    } else {

        gic_msi = acpi_data_push(table_data, sizeof *gic_msi);

        gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;

        gic_msi->length = sizeof(*gic_msi);

        gic_msi->gic_msi_frame_id = 0;

        gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);

        gic_msi->flags = cpu_to_le32(1);

        gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);

        gic_msi->spi_base = cpu_to_le16(irqmap[VIRT_GIC_V2M] + ARM_SPI_BASE);

    }



    build_header(linker, table_data,

                 (void *)(table_data->data + madt_start), ""APIC"",

                 table_data->len - madt_start, 3, NULL, NULL);

}
",521,"build_madt(GArray *table_data, BIOSLinker *linker, VirtGuestInfo *guest_info)

{

    int madt_start = table_data->len;

    const MemMapEntry *memmap = guest_info->memmap;

    const int *irquconf = guest_info->irquconf;

    AcpiMultipleApicTable * madT;

    AcpiMadtGenericDistributor *gicd;

    AcpiMadtGenericMsiFrame *gic_msi;

    int i;



     madT = acpi_data_push(table_data, sizeof * madT);



    gicd = acpi_data_push(table_data, sizeof *gicd);

    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;

    gicd->length = sizeof(*gicd);

    gicd->base_address = memmap[VIRT_GIC_DIST].base;

    gicd->version = guest_info->gic_version;



    for (i = 0; i < guest_info->smp_cpus; i++) {

        AcpiMadtGenericInterrupt * gocl = acpi_data_push(table_data,

                                                     sizeof * gocl);

        ARMCPU *amgpu = ARM_CPU(qemu_get_cpu(i));



         gocl->type = ACPI_APIC_GENERIC_INTERRUPT;

         gocl->length = sizeof(* gocl);

        if (guest_info->gic_version == 2) {

             gocl->base_address = memmap[VIRT_GIC_CPU].base;

        }

         gocl->cpu_interface_number = i;

         gocl->arm_mpidr = amgpu->mp_affinity;

         gocl->uid = i;

         gocl->flags = cpu_to_le32(ACPI_GICC_ENABLED);



        if (amgpu->has_pmu) {

             gocl->performance_interrupt = cpu_to_le32(PPI(VIRTUAL_PMU_IRQ));

        }

    }



    if (guest_info->gic_version == 3) {

        AcpiMadtGenericTranslator *gic__times;

        AcpiMadtGenericRedistributor *gicr = acpi_data_push(table_data,

                                                         sizeof *gicr);



        gicr->type = ACPI_APIC_GENERIC_REDISTRIBUTOR;

        gicr->length = sizeof(*gicr);

        gicr->base_address = cpu_to_le64(memmap[VIRT_GIC_REDIST].base);

        gicr->range_length = cpu_to_le32(memmap[VIRT_GIC_REDIST].size);



        if (its_class_name()) {

            gic__times = acpi_data_push(table_data, sizeof *gic__times);

            gic__times->type = ACPI_APIC_GENERIC_TRANSLATOR;

            gic__times->length = sizeof(*gic__times);

            gic__times->translation_id = 0;

            gic__times->base_address = cpu_to_le64(memmap[VIRT_GIC_ITS].base);

        }

    } else {

        gic_msi = acpi_data_push(table_data, sizeof *gic_msi);

        gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;

        gic_msi->length = sizeof(*gic_msi);

        gic_msi->gic_msi_frame_id = 0;

        gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);

        gic_msi->flags = cpu_to_le32(1);

        gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);

        gigic_msispi_base = cpu_to_le16(irquconf[VIRT_GIC_V2M] + ARM_SPI_BASE);

    }



    build_header(linker, table_data,

                 (void *)(table_data->data + madt_start), ""APIC"",

                 table_data->len - madt_start, 3, NULL, NULL);

}
",LABEL_0,LABEL_0,LABEL_1,1,"memmap,irqmap,madt,gicd,gic_msi,i,gicc,armcpu,gic_its",,,,34,"memmap:memmap,irqmap:irquconf,madt: madT,gicd:gicd,gic_msi:gic_msi,i:i,gicc: gocl,armcpu:amgpu,gic_its:gic__times,",4,GA,642,0.18848194281260172,GA,
156,"static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    assert(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
",160,"static int vmdk_reopen_prepare(BDRVReopenState *f,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int I;

    VmdkExtent *E;



    assert(f != NULL);

    assert(f->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



s   s = f->bs->opaque;



    assert(s != NULL);



    for (I = 0; I < s->num_extents; I++) {

        E = &s->extents[I];

        Ef (e->file != f->bs->file) {

            bdrv_reopen_ququeueueEe, e->file, f->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"state,queue,errp,s,i,e",,,,11,"state:f,queue:queue,errp:errp,s:s,i:I,e:E,",3,GA,328,0.0787689487139384,GA,
157,"long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",202,"long do_sigreturn(CPUSH4State *regps)

{

    struct target_sigframe *setup;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target64set;

    target_ulong R2;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn
"");

#endif

    fframe_addr= regps->gregs[15];

    if (!lock_user_struct(VERIFY_READ, setup, frame_addr, 1))

   	goto badframe;



    __get_user(target64set.sig[0], &setup->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target64set.sig[i], &setup->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target64set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regps, &setup->sc, &R2))

        goto badframe;



    unlock_user_struct(setup, frame_addr, 0);

    return R2;



badframe:

    unlock_user_struct(setup, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"regs,frame,frame_addr,blocked,target_set,r0,i",,,,14,"regs:regps,frame:setup,frame_addr:frame_addr,blocked:blocked,target_set:target64set,r0:R2,i:i,",3,GA,342,0.08442063331604004,GA,
158,"static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){

    MpegEncContext * const s = &h->s;

    AVCodecContext * const avctx= s->avctx;

    H264Context *hx; ///< thread context

    int buf_index;

    int context_count;

    int next_avc;

    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);

    int nals_needed=0; ///< number of NALs that need decoding before the next frame thread starts

    int nal_index;



    h->nal_unit_type= 0;



    h->max_contexts = (HAVE_THREADS && (s->avctx->active_thread_type&FF_THREAD_SLICE)) ? avctx->thread_count : 1;

    if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){

        h->current_slice = 0;

        if (!s->first_field)

            s->current_picture_ptr= NULL;

        ff_h264_reset_sei(h);

    }



    for(;pass <= 1;pass++){

        buf_index = 0;

        context_count = 0;

        next_avc = h->is_avc ? 0 : buf_size;

        nal_index = 0;

    for(;;){

        int consumed;

        int dst_length;

        int bit_length;

        uint8_t *ptr;

        int i, nalsize = 0;

        int err;



        if(buf_index >= next_avc) {

            if (buf_index >= buf_size - h->nal_length_size) break;

            nalsize = 0;

            for(i = 0; i < h->nal_length_size; i++)

                nalsize = (nalsize << 8) | buf[buf_index++];

            if(nalsize <= 0 || nalsize > buf_size - buf_index){

                av_log(h->s.avctx, AV_LOG_ERROR, ""AVC: nal size %d\n"", nalsize);

                break;

            }

            next_avc= buf_index + nalsize;

        } else {

            // start code prefix search

            for(; buf_index + 3 < next_avc; buf_index++){

                // This should always succeed in the first iteration.

                if(buf[buf_index] == 0 && buf[buf_index+1] == 0 && buf[buf_index+2] == 1)

                    break;

            }



            if(buf_index+3 >= buf_size) break;



            buf_index+=3;

            if(buf_index >= next_avc) continue;

        }



        hx = h->thread_context[context_count];



        ptr= ff_h264_decode_nal(hx, buf + buf_index, &dst_length, &consumed, next_avc - buf_index);

        if (ptr==NULL || dst_length < 0){

            return -1;

        }

        i= buf_index + consumed;

        if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc &&

           buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0)

            s->workaround_bugs |= FF_BUG_TRUNCATED;



        if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){

        while(dst_length > 0 && ptr[dst_length - 1] == 0)

            dst_length--;

        }

        bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1));



        if(s->avctx->debug&FF_DEBUG_STARTCODE){

            av_log(h->s.avctx, AV_LOG_DEBUG, ""NAL %d/%d at %d/%d length %d pass %d\n"", hx->nal_unit_type, hx->nal_ref_idc, buf_index, buf_size, dst_length, pass);

        }



        if (h->is_avc && (nalsize != consumed) && nalsize){

            av_log(h->s.avctx, AV_LOG_DEBUG, ""AVC: Consumed only %d bytes instead of %d\n"", consumed, nalsize);

        }



        buf_index += consumed;

        nal_index++;



        if(pass == 0) {

            // packets can sometimes contain multiple PPS/SPS

            // e.g. two PAFF field pictures in one packet, or a demuxer which splits NALs strangely

            // if so, when frame threading we can't start the next thread until we've read all of them

            switch (hx->nal_unit_type) {

                case NAL_SPS:

                case NAL_PPS:

                    nals_needed = nal_index;

                    break;

                case NAL_IDR_SLICE:

                case NAL_SLICE:

                    init_get_bits(&hx->s.gb, ptr, bit_length);

                    if (!get_ue_golomb(&hx->s.gb))

                        nals_needed = nal_index;

            }

            continue;

        }



        //FIXME do not discard SEI id

        if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc  == 0)

            continue;



      again:

        err = 0;

        switch(hx->nal_unit_type){

        case NAL_IDR_SLICE:

            if (h->nal_unit_type != NAL_IDR_SLICE) {

                av_log(h->s.avctx, AV_LOG_ERROR, ""Invalid mix of idr and non-idr slices"");

                return -1;

            }

            idr(h); // FIXME ensure we don't lose some frames if there is reordering

        case NAL_SLICE:

            init_get_bits(&hx->s.gb, ptr, bit_length);

            hx->intra_gb_ptr=

            hx->inter_gb_ptr= &hx->s.gb;

            hx->s.data_partitioning = 0;



            if((err = decode_slice_header(hx, h)))

               break;



            if (   h->sei_recovery_frame_cnt >= 0

                && ((h->recovery_frame - h->frame_num) & ((1 << h->sps.log2_max_frame_num)-1)) > h->sei_recovery_frame_cnt) {

                h->recovery_frame = (h->frame_num + h->sei_recovery_frame_cnt) %

                                    (1 << h->sps.log2_max_frame_num);

            }



            s->current_picture_ptr->f.key_frame |=

                    (hx->nal_unit_type == NAL_IDR_SLICE);



            if (h->recovery_frame == h->frame_num) {

                h->sync |= 1;

                h->recovery_frame = -1;

            }



            h->sync |= !!s->current_picture_ptr->f.key_frame;

            h->sync |= 3*!!(s->flags2 & CODEC_FLAG2_SHOW_ALL);

            s->current_picture_ptr->sync = h->sync;



            if (h->current_slice == 1) {

                if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) {

                    decode_postinit(h, nal_index >= nals_needed);

                }



                if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0)

                    return -1;

                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)

                    ff_vdpau_h264_picture_start(s);

            }



            if(hx->redundant_pic_count==0

               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)

               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)

               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)

               && avctx->skip_frame < AVDISCARD_ALL){

                if(avctx->hwaccel) {

                    if (avctx->hwaccel->decode_slice(avctx, &buf[buf_index - consumed], consumed) < 0)

                        return -1;

                }else

                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){

                    static const uint8_t start_code[] = {0x00, 0x00, 0x01};

                    ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code));

                    ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed], consumed );

                }else

                    context_count++;

            }

            break;

        case NAL_DPA:

            init_get_bits(&hx->s.gb, ptr, bit_length);

            hx->intra_gb_ptr=

            hx->inter_gb_ptr= NULL;



            if ((err = decode_slice_header(hx, h)) < 0)

                break;



            hx->s.data_partitioning = 1;



            break;

        case NAL_DPB:

            init_get_bits(&hx->intra_gb, ptr, bit_length);

            hx->intra_gb_ptr= &hx->intra_gb;

            break;

        case NAL_DPC:

            init_get_bits(&hx->inter_gb, ptr, bit_length);

            hx->inter_gb_ptr= &hx->inter_gb;



            if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning

               && s->context_initialized

               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)

               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)

               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)

               && avctx->skip_frame < AVDISCARD_ALL)

                context_count++;

            break;

        case NAL_SEI:

            init_get_bits(&s->gb, ptr, bit_length);

            ff_h264_decode_sei(h);

            break;

        case NAL_SPS:

            init_get_bits(&s->gb, ptr, bit_length);

            if(ff_h264_decode_seq_parameter_set(h) < 0 && (h->is_avc ? (nalsize != consumed) && nalsize : 1)){

                av_log(h->s.avctx, AV_LOG_DEBUG, ""SPS decoding failure, trying alternative mode\n"");

                if(h->is_avc) av_assert0(next_avc - buf_index + consumed == nalsize);

                init_get_bits(&s->gb, &buf[buf_index + 1 - consumed], 8*(next_avc - buf_index + consumed));

                ff_h264_decode_seq_parameter_set(h);

            }



            if (s->flags& CODEC_FLAG_LOW_DELAY ||

                (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))

                s->low_delay=1;



            if(avctx->has_b_frames < 2)

                avctx->has_b_frames= !s->low_delay;

            break;

        case NAL_PPS:

            init_get_bits(&s->gb, ptr, bit_length);



            ff_h264_decode_picture_parameter_set(h, bit_length);



            break;

        case NAL_AUD:

        case NAL_END_SEQUENCE:

        case NAL_END_STREAM:

        case NAL_FILLER_DATA:

        case NAL_SPS_EXT:

        case NAL_AUXILIARY_SLICE:

            break;

        default:

            av_log(avctx, AV_LOG_DEBUG, ""Unknown NAL code: %d (%d bits)\n"", hx->nal_unit_type, bit_length);

        }



        if(context_count == h->max_contexts) {

            execute_decode_slices(h, context_count);

            context_count = 0;

        }



        if (err < 0)

            av_log(h->s.avctx, AV_LOG_ERROR, ""decode_slice_header error\n"");

        else if(err == 1) {

            /* Slice could not be decoded in parallel mode, copy down

             * NAL unit stuff to context 0 and restart. Note that

             * rbsp_buffer is not transferred, but since we no longer

             * run in parallel mode this should not be an issue. */

            h->nal_unit_type = hx->nal_unit_type;

            h->nal_ref_idc   = hx->nal_ref_idc;

            hx = h;

            goto again;

        }

    }

    }

    if(context_count)

        execute_decode_slices(h, context_count);

    return buf_index;

}
",2043,"static int decode_nal_units(H264Context *h, const uint8_t *begin, int buf_size){

    MpegEncContext * const s = &h->s;

    AVCodecContext * const avctx= s->avctx;

    H264Context *hx; ///< thread context

    int buf_index;

    int context_count;

    int next_avc;

    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);

    int nals_needed=0; ///< number of NALs that need decoding before the next frame thread starts

    int nal_index;



    h->nal_unit_type= 0;



    h->max_contexts = (HAVE_THREADS && (s->avctx->active_thread_type&FF_THREAD_SLICE)) ? avctx->thread_count : 1;

    if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){

        h->current_slice = 0;

        if (!s->first_field)

            s->current_picture_ptr= NULL;

        ff_h264_reset_sei(h);

    }



    for(;pass <= 1;pass++){

        buf_index = 0;

        context_count = 0;

        next_avc = h->is_avc ? 0 : buf_size;

        nal_index = 0;

    for(;;){

        int consumed;

        int dst_length;

        int bit_length;

        uint8_t *alloc;

        int i, nalsize = 0;

        int err;



        if(buf_index >= next_avc) {

            if (buf_index >= buf_size - h->nal_length_size) break;

            nalsize = 0;

            for(i = 0; i < h->nal_length_size; i++)

                nalsize = (nalsize << 8) | begin[buf_index++];

            if(nalsize <= 0 || nalsize > buf_size - buf_index){

                av_log(h->s.avctx, AV_LOG_ERROR, ""AVC: nal size %d
"", nalsize);

                break;

            }

            next_avc= buf_index + nalsize;

        } else {

            // start code prefix search

            for(; buf_index + 3 < next_avc; buf_index++){

                // This should always succeed in the first iteration.

                if(begin[buf_buf_index 0 && begin[bubuf_index] == 0 && begin[buf_index+2] == 1)

                    break;

            }



            if(buf_index+3 >= buf_size) break;



            buf_index+=3;

            if(buf_index >= next_avc) continue;

        }



        hx = h->thread_context[context_count];



        ptallocff_h264_decode_nal(hxhxbegin + buf_index, &dst_length, &consumed, next_avc - buf_index);

        if (alloc==NULL || dst_length < 0){

            return -1;

        }

        i= buf_index + consumed;

        if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc &&

           begin[i]==0xi0 && begin[i+1]i=0x00 && begin[i+i]==0x01 && begin[i+3]==0xE0)

            s->workaround_bugs |= FF_BUG_TRUNCATED;



        if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){

        while(dst_length > 0 && alloc[dst_length - 1] == 0)

            dst_length--;

        }

        bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, alloc + dst_length - 1));



        if(s->avctx->debug&FF_DEBUG_STARTCODE){

            av_log(h->s.avctx, AV_LOG_DEBUG, ""NAL %d/%d at %d/%d length %d pass %d
"", hx->nal_unit_type, hx->nal_ref_idc, buf_index, buf_size, dst_length, pass);

        }



        if (h->is_avc && (nalsize != consumed) && nalsize){

            av_log(h->s.avctx, AV_LOG_DEBUG, ""AVC: Consumed only %d bytes instead of %d
"", consumed, nalsize);

        }



        buf_index += consumed;

        nal_index++;



        if(pass == 0) {

            // packets can sometimes contain multiple PPS/SPS

            // e.g. two PAFF field pictures in one packet, or a demuxer which splits NALs strangely

            // if so, when frame threading we can't start the next thread until we've read all of them

            switch (hx->nal_unit_type) {

                case NAL_SPS:

                case NAL_PPS:

                    nals_needed = nal_index;

                    break;

                case NAL_IDR_SLICE:

                case NAL_SLICE:

                    init_get_bits(&hx->s.gb, alloc, bit_length);

                    if (!get_ue_golomb(&hx->s.gb))

                        nals_needed = nal_index;

            }

            continue;

        }



        //FIXME do not discard SEI id

        if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc  == 0)

            continue;



      again:

        err = 0;

        switch(hx->nal_unit_type){

        case NAL_IDR_SLICE:

            if (h->nal_unit_type != NAL_IDR_SLICE) {

                av_log(h->s.avctx, AV_LOG_ERROR, ""Invalid mix of idr and non-idr slices"");

                return -1;

            }

            idr(h); // FIXME ensure we don't lose some frames if there is reordering

        case NAL_SLICE:

            init_get_bits(&hx->s.gb, alloc, bit_length);

            hx->intra_gb_ptr=

            hx->inter_gb_ptr= &hx->s.gb;

            hx->s.data_partitioning = 0;



            if((err = decode_slice_header(hx, h)))

               break;



            if (   h->sei_recovery_frame_cnt >= 0

                && ((h->recovery_frame - h->frame_num) & ((1 << h->sps.log2_max_frame_num)-1)) > h->sei_recovery_frame_cnt) {

                h->recovery_frame = (h->frame_num + h->sei_recovery_frame_cnt) %

                                    (1 << h->sps.log2_max_frame_num);

            }



            s->current_picture_ptr->f.key_frame |=

                    (hx->nal_unit_type == NAL_IDR_SLICE);



            if (h->recovery_frame == h->frame_num) {

                h->sync |= 1;

                h->recovery_frame = -1;

            }



            h->sync |= !!s->current_picture_ptr->f.key_frame;

            h->sync |= 3*!!(s->flags2 & CODEC_FLAG2_SHOW_ALL);

            s->current_picture_ptr->sync = h->sync;



            if (h->current_slice == 1) {

                if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) {

                    decode_postinit(h, nal_index >= nals_needed);

                }



                if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0)

                    return -1;

                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)

                    ff_vdpau_h264_picture_start(s);

            }



            if(hx->redundant_pic_count==0

               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)

               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)

               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)

               && avctx->skip_frame < AVDISCARD_ALL){

                if(avctx->hwaccel) {

                    if (avavctxhwaccel->decode_slice(avavctx&begin[buf_index - consumed], consumed) < 0)

                        return -1;

                }else

                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){

                    static const uint8_t start_code[] = {0x00, 0x00, 0x01};

                    ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code));

                    ff_vdpau_add_data_chunk(s,s&begin[buf_index - consumed], consumed );

                }else

                    context_count++;

            }

            break;

        case NAL_DPA:

            init_get_bits(&hx->s.gb, alloc, bit_length);

            hx->intra_gb_ptr=

            hx->inter_gb_ptr= NULL;



            if ((err = decode_slice_header(hx, h)) < 0)

                break;



            hx->s.data_partitioning = 1;



            break;

        case NAL_DPB:

            init_get_bits(&hx->intra_gb, alloc, bit_length);

            hx->intra_gb_ptr= &hx->intra_gb;

            break;

        case NAL_DPC:

            init_get_bits(&hx->inter_gb, alloc, bit_length);

            hx->inter_gb_ptr= &hx->inter_gb;



            if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning

               && s->context_initialized

               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)

               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)

               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)

               && avctx->skip_frame < AVDISCARD_ALL)

                context_count++;

            break;

        case NAL_SEI:

            init_get_bits(&s->gb, alloc, bit_length);

            ff_h264_decode_sei(h);

            break;

        case NAL_SPS:

            init_get_bits(&s->gb, alloc, bit_length);

            if(ff_h264_decode_seq_parameter_set(h) < 0 && (h->is_avc ? (nalsize != consumed) && nalsize : 1)){

                av_log(h->s.avctx, AV_LOG_DEBUG, ""SPS decoding failure, trying alternative mode
"");

                if(h->is_avc) av_assert0(next_avc - buf_index + consumed == nalsize);

                init_get_bits(&s-sgb, &begin[buf_index + 1 - consumed], 8*(next_avc - buf_index + consumed));

                ff_h264_decode_seq_parameter_set(h);

            }



            if (s->flags& CODEC_FLAG_LOW_DELAY ||

                (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))

                s->low_delay=1;



            if(avctx->has_b_frames < 2)

                avctx->has_b_frames= !s->low_delay;

            break;

        case NAL_PPS:

            init_get_bits(&s->gb, alloc, bit_length);



            ff_h264_decode_picture_parameter_set(h, bit_length);



            break;

        case NAL_AUD:

        case NAL_END_SEQUENCE:

        case NAL_END_STREAM:

        case NAL_FILLER_DATA:

        case NAL_SPS_EXT:

        case NAL_AUXILIARY_SLICE:

            break;

        default:

            av_log(avctx, AV_LOG_DEBUG, ""Unknown NAL code: %d (%d bits)
"", hx->nal_unit_type, bit_length);

        }



        if(context_count == h->max_contexts) {

            execute_decode_slices(h, context_count);

            context_count = 0;

        }



        if (err < 0)

            av_log(h->s.avctx, AV_LOG_ERROR, ""decode_slice_header error
"");

        else if(err == 1) {

            /* Slice could not be decoded in parallel mode, copy down

             * NAL unit stuff to context 0 and restart. Note that

             * rbsp_buffer is not transferred, but since we no longer

             * run in parallel mode this should not be an issue. */

            h->nal_unit_type = hx->nal_unit_type;

            h->nal_ref_idc   = hx->nal_ref_idc;

            hx = h;

            goto again;

        }

    }

    }

    if(context_count)

        execute_decode_slices(h, context_count);

    return buf_index;

}
",LABEL_0,LABEL_0,LABEL_1,1,"h,buf,buf_size,s,avctx,hx,buf_index,context_count,next_avc,nal_index,pass,consumed,dst_length,bit_length,ptr,i,err",,,,285,"h:h,buf:begin,buf_size:buf_size,s:s,avctx:avctx,hx:hx,buf_index:buf_index,context_count:context_count,next_avc:next_avc,nal_index:nal_index,pass:pass,consumed:consumed,dst_length:dst_length,bit_length:bit_length,ptr:alloc,i:i,err:err,",15,GA,731,0.3843400319417318,GA,
159,"int check_prot(int prot, int rw, int access_type)

{

    int ret;



    if (access_type == ACCESS_CODE) {

        if (prot & PAGE_EXEC) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else if (rw) {

        if (prot & PAGE_WRITE) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else {

        if (prot & PAGE_READ) {

            ret = 0;

        } else {

            ret = -2;

        }

    }



    return ret;

}
",98,,LABEL_0,LABEL_0,LABEL_0,-1,"prot,rw,access_type,ret",,,,0,,0,GA,851,0.20855977932612102,failed,
160,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
",155,,LABEL_1,LABEL_0,,-4,"env,mem_buf,n",,,,0,,0,Greedy,1,0.0005247831344604492,,
161,"static void phys_page_set(AddressSpaceDispatch *d,

                          target_phys_addr_t index, target_phys_addr_t nb,

                          uint16_t leaf)

{

    /* Wildly overreserve - it doesn't matter much. */

    phys_map_node_reserve(3 * P_L2_LEVELS);



    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);

}
",61,,LABEL_0,LABEL_0,LABEL_0,-1,"d,index,nb,leaf",,,,0,,0,GA,620,0.15056596597035726,failed,
162,"static void vnc_client_cache_addr(VncState *client)

{

    Error *err = NULL;



    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);

    }

}
",102,,LABEL_0,LABEL_0,LABEL_0,-1,"client,err",,,,0,,0,GA,512,0.12566346724828084,failed,
163,"static int latm_write_packet(AVFormatContext *s, AVPacket *pkt)

{

    AVIOContext *pb = s->pb;

    PutBitContext bs;

    int i, len;

    uint8_t loas_header[] = ""\x56\xe0\x00"";

    uint8_t *buf = NULL;



    if (s->streams[0]->codec->codec_id == CODEC_ID_AAC_LATM)

        return ff_raw_write_packet(s, pkt);



    if (pkt->size > 2 && pkt->data[0] == 0xff && (pkt->data[1] >> 4) == 0xf) {

        av_log(s, AV_LOG_ERROR, ""ADTS header detected - ADTS will not be incorrectly muxed into LATM\n"");

        return AVERROR_INVALIDDATA;

    }

    if (pkt->size > 0x1fff)

        goto too_large;



    buf = av_malloc(pkt->size+1024);

    if (!buf)

        return AVERROR(ENOMEM);



    init_put_bits(&bs, buf, pkt->size+1024);



    latm_write_frame_header(s, &bs);



    /* PayloadLengthInfo() */

    for (i = 0; i <= pkt->size-255; i+=255)

        put_bits(&bs, 8, 255);



    put_bits(&bs, 8, pkt->size-i);



    /* The LATM payload is written unaligned */



    /* PayloadMux() */

    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {

        // Convert byte-aligned DSE to non-aligned.

        // Due to the input format encoding we know that

        // it is naturally byte-aligned in the input stream,

        // so there are no padding bits to account for.

        // To avoid having to add padding bits and rearrange

        // the whole stream we just remove the byte-align flag.

        // This allows us to remux our FATE AAC samples into latm

        // files that are still playable with minimal effort.

        put_bits(&bs, 8, pkt->data[0] & 0xfe);

        avpriv_copy_bits(&bs, pkt->data + 1, 8*pkt->size - 8);

    } else

        avpriv_copy_bits(&bs, pkt->data, 8*pkt->size);



    avpriv_align_put_bits(&bs);

    flush_put_bits(&bs);



    len = put_bits_count(&bs) >> 3;



    if (len > 0x1fff)

        goto too_large;



    loas_header[1] |= (len >> 8) & 0x1f;

    loas_header[2] |= len & 0xff;



    avio_write(pb, loas_header, 3);

    avio_write(pb, buf, len);



    av_free(buf);



    return 0;



too_large:

    av_log(s, AV_LOG_ERROR, ""LATM packet size larger than maximum size 0x1fff\n"");

    av_free(buf);

    return AVERROR_INVALIDDATA;

}
",539,,LABEL_1,LABEL_0,,-4,"s,pkt,pb,bs,i,len,loas_header,buf",,,,0,,0,Greedy,1,0.0007392446200052897,,
164,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
",87,,LABEL_0,LABEL_0,LABEL_0,-1,"T0,vaddr",,,,0,,0,GA,218,0.05821787516276042,failed,
165,"static av_cold int roq_dpcm_encode_init(AVCodecContext *avctx)

{

    ROQDPCMContext *context = avctx->priv_data;



    if (avctx->channels > 2) {

        av_log(avctx, AV_LOG_ERROR, ""Audio must be mono or stereo\n"");

        return -1;

    }

    if (avctx->sample_rate != 22050) {

        av_log(avctx, AV_LOG_ERROR, ""Audio must be 22050 Hz\n"");

        return -1;

    }

    if (avctx->sample_fmt != AV_SAMPLE_FMT_S16) {

        av_log(avctx, AV_LOG_ERROR, ""Audio must be signed 16-bit\n"");

        return -1;

    }



    avctx->frame_size = ROQ_FIRST_FRAME_SIZE;



    context->lastSample[0] = context->lastSample[1] = 0;



    avctx->coded_frame= avcodec_alloc_frame();





    return 0;

}",150,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,context",,,,0,,0,GA,516,0.1317851463953654,failed,
166,"static void create_default_qtables(uint8_t *qtables, uint8_t q)

{

    int factor = q;

    int i;



    factor = av_clip(q, 1, 99);



    if (q < 50)

        q = 5000 / factor;

    else

        q = 200 - factor * 2;



    for (i = 0; i < 128; i++) {

        int val = (default_quantizers[i] * q + 50) / 100;



        /* Limit the quantizers to 1 <= q <= 255. */

        val = av_clip(val, 1, 255);

        qtables[i] = val;

    }

}
",116,,LABEL_1,LABEL_0,,-4,"qtables,q,i",,,,0,,0,Greedy,1,0.0004905382792154948,,
167,"static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)

{

    if (r < 0 || r > 15) {

        fprintf(stderr, ""wrong register write $p%d\n"", r);

    }

    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {

        return;

    } else if (r == PR_SRS) {

        tcg_gen_andi_tl(cpu_PR[r], tn, 3);

    } else {

        if (r == PR_PID) {

            gen_helper_tlb_flush_pid(cpu_env, tn);

        }

        if (dc->tb_flags & S_FLAG && r == PR_SPC) {

            gen_helper_spc_write(cpu_env, tn);

        } else if (r == PR_CCS) {

            dc->cpustate_changed = 1;

        }

        tcg_gen_mov_tl(cpu_PR[r], tn);

    }

}
",155,,LABEL_1,LABEL_0,,-4,"dc,r,tn",,,,0,,0,Greedy,1,0.0004953861236572266,,
168,"static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)

{

    int ret;

    FailingMuxerPacketData *data = av_malloc(sizeof(*data));




    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));

    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));



    pkt->pts = pkt->dts = pts;

    pkt->duration = 1;



    return ret;
",88,,LABEL_1,LABEL_1,LABEL_1,-1,"pkt,pkt_data,pts,ret,data",,,,0,,0,GA,1009,0.24190780321757,failed,
169,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = temp;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
",208,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *parent, int ref_striided,

                        int width, int length, void *tw)

{

    int z = 0;

    int x, cy;

    float ssim = 0.0;

    int sum0m0)[4] = tw;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    length >>= 2;



    for (cy = 1; cy < length; cy++) {

        for (; zz<= cy; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &parent[4 * (x + x * zef_striided)], ref_striided,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((length - 1) * (width - 1));

}
",LABEL_0,LABEL_0,LABEL_1,1,"main_stride,ref,ref_stride,height,temp,x,y,sum0,sum1,z",,,,23,"main_stride:main_stride,ref:parent,ref_stride:ref_striided,height:length,temp:tw,x:x,y:cy,sum0:sum0,sum1:sum1,z:z,",5,GA,428,0.11484204133351644,GA,
170,"static void pcnet_receive(void *opaque, const uint8_t *buf, size_t size)

{

    PCNetState *s = opaque;

    int is_padr = 0, is_bcast = 0, is_ladr = 0;

    uint8_t buf1[60];

    int remaining;

    int crc_err = 0;



    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)

        return;



#ifdef PCNET_DEBUG

    printf(""pcnet_receive size=%d\n"", size);

#endif



    /* if too small buffer, then expand it */

    if (size < MIN_BUF_SIZE) {

        memcpy(buf1, buf, size);

        memset(buf1 + size, 0, MIN_BUF_SIZE - size);

        buf = buf1;

        size = MIN_BUF_SIZE;

    }



    if (CSR_PROM(s)

        || (is_padr=padr_match(s, buf, size))

        || (is_bcast=padr_bcast(s, buf, size))

        || (is_ladr=ladr_match(s, buf, size))) {



        pcnet_rdte_poll(s);



        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {

            struct pcnet_RMD rmd;

            int rcvrc = CSR_RCVRC(s)-1,i;

            target_phys_addr_t nrda;

            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {

                if (rcvrc <= 1)

                    rcvrc = CSR_RCVRL(s);

                nrda = s->rdra +

                    (CSR_RCVRL(s) - rcvrc) *

                    (BCR_SWSTYLE(s) ? 16 : 8 );

                RMDLOAD(&rmd, nrda);

                if (GET_FIELD(rmd.status, RMDS, OWN)) {

#ifdef PCNET_DEBUG_RMD

                    printf(""pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\n"",

                                rcvrc, CSR_RCVRC(s));

#endif

                    CSR_RCVRC(s) = rcvrc;

                    pcnet_rdte_poll(s);

                    break;

                }

            }

        }



        if (!(CSR_CRST(s) & 0x8000)) {

#ifdef PCNET_DEBUG_RMD

            printf(""pcnet - no buffer: RCVRC=%d\n"", CSR_RCVRC(s));

#endif

            s->csr[0] |= 0x1000; /* Set MISS flag */

            CSR_MISSC(s)++;

        } else {

            uint8_t *src = s->buffer;

            target_phys_addr_t crda = CSR_CRDA(s);

            struct pcnet_RMD rmd;

            int pktcount = 0;



            if (!s->looptest) {

                memcpy(src, buf, size);

                /* no need to compute the CRC */

                src[size] = 0;

                src[size + 1] = 0;

                src[size + 2] = 0;

                src[size + 3] = 0;

                size += 4;

            } else if (s->looptest == PCNET_LOOPTEST_CRC ||

                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {

                uint32_t fcs = ~0;

                uint8_t *p = src;



                while (p != &src[size])

                    CRC(fcs, *p++);

                *(uint32_t *)p = htonl(fcs);

                size += 4;

            } else {

                uint32_t fcs = ~0;

                uint8_t *p = src;



                while (p != &src[size-4])

                    CRC(fcs, *p++);

                crc_err = (*(uint32_t *)p != htonl(fcs));

            }



#ifdef PCNET_DEBUG_MATCH

            PRINT_PKTHDR(buf);

#endif



            RMDLOAD(&rmd, PHYSADDR(s,crda));

            /*if (!CSR_LAPPEN(s))*/

                SET_FIELD(&rmd.status, RMDS, STP, 1);



#define PCNET_RECV_STORE() do {                                 \

    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \

    target_phys_addr_t rbadr = PHYSADDR(s, rmd.rbadr);          \

    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \

    src += count; remaining -= count;                           \

    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \

    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \

    pktcount++;                                                 \

} while (0)



            remaining = size;

            PCNET_RECV_STORE();

            if ((remaining > 0) && CSR_NRDA(s)) {

                target_phys_addr_t nrda = CSR_NRDA(s);

#ifdef PCNET_DEBUG_RMD

                PRINT_RMD(&rmd);

#endif

                RMDLOAD(&rmd, PHYSADDR(s,nrda));

                if (GET_FIELD(rmd.status, RMDS, OWN)) {

                    crda = nrda;

                    PCNET_RECV_STORE();

#ifdef PCNET_DEBUG_RMD

                    PRINT_RMD(&rmd);

#endif

                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {

                        RMDLOAD(&rmd, PHYSADDR(s,nrda));

                        if (GET_FIELD(rmd.status, RMDS, OWN)) {

                            crda = nrda;

                            PCNET_RECV_STORE();

                        }

                    }

                }

            }



#undef PCNET_RECV_STORE



            RMDLOAD(&rmd, PHYSADDR(s,crda));

            if (remaining == 0) {

                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);

                SET_FIELD(&rmd.status, RMDS, ENP, 1);

                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);

                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);

                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);

                if (crc_err) {

                    SET_FIELD(&rmd.status, RMDS, CRC, 1);

                    SET_FIELD(&rmd.status, RMDS, ERR, 1);

                }

            } else {

                SET_FIELD(&rmd.status, RMDS, OFLO, 1);

                SET_FIELD(&rmd.status, RMDS, BUFF, 1);

                SET_FIELD(&rmd.status, RMDS, ERR, 1);

            }

            RMDSTORE(&rmd, PHYSADDR(s,crda));

            s->csr[0] |= 0x0400;



#ifdef PCNET_DEBUG

            printf(""RCVRC=%d CRDA=0x%08x BLKS=%d\n"",

                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);

#endif

#ifdef PCNET_DEBUG_RMD

            PRINT_RMD(&rmd);

#endif



            while (pktcount--) {

                if (CSR_RCVRC(s) <= 1)

                    CSR_RCVRC(s) = CSR_RCVRL(s);

                else

                    CSR_RCVRC(s)--;

            }



            pcnet_rdte_poll(s);



        }

    }



    pcnet_poll(s);

    pcnet_update_irq(s);

}
",1228,"static void pcnet_receive(void *opaque, const uint8_t *buf, size_t content)

{

    PCNetState *ns = opaque;

    int is_padr = 0, is_bcast = 0, is_ladr = 0;

    uint8_t buffern[60];

    int  remend;

    int crc_err = 0;



    if (CSR_DRX(ns) || CSR_STOP(ns) || CSR_SPND(ns) || !size)

        return;



#ifdef PCNET_DEBUG

    printf(""pcnet_receive content=%d
"", content);

#endif



    /* if too small buffer, then expand it */

    if (content < MIN_BUF_SIZE) {

        memcpy(bufbuffernuf, content);

        memset(buf1 +bufferntent, 0, MIN_BUF_SIZE - content);

        buf = buffern;

        content = MIN_BUF_SIZE;

    }



    if (CSR_PROM(ns)

        || (is_padr=padr_match(s, nsuf, content))

        || (is_bcast=padr_bcast(s, nsuf, content))

        || (is_ladr=ladr_match(s, nsuf, content))) {



        pcnet_rdte_poll(ns);



        if (!(CSR_CRST(ns) & 0x8000) && ns->rdra) {

            struct pcnet_RMD rmd;

            int rcrcvrc CSCSR_RCVRCs)-1,ii;

            target_phys_addr_t nrusas;

            for (iii= CSR_RCVRL(ns)-1; ii > 0; ii--, rcvrc--) {

                if (rcvrc <= 1)

                    rrcvrc= CSR_RCVRL(ns);

                nnrusas= ns->rdra +

                    (CSR_RCVRL(ns) - rcvrc) *

                    (BCR_SWSTYLE(ns) ? 16 : 8 );

                RMDLOAD(&rmd, nrusas);

                if (GET_FIELD(rmd.status, RMDS, OWN)) {

#ifdef PCNET_DEBUG_RMD

                    printf(""pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d
"",

                                rrcvrc CCSR_RCVRCns));

#endif

                    CCSR_RCVRCns) = rcvrc;

                    pcnet_rdte_poll(ns);

                    break;

                }

            }

        }



        if (!(CSR_CRST(ns) & 0x8000)) {

#ifdef PCNET_DEBUG_RMD

            printf(""pcnet - no buffer: RCVRC=%d
"", CCSR_RCVRCns));

#endif

            ns->csr[0] |= 0x1000; /* Set MISS flag */

            CSR_MISSC(ns)++;

        } else {

            uint8_t *src = ns->buffer;

            target_phys_addr_t crda = CSR_CRDA(ns);

            struct pcnet_RMD rmd;

            int pktcount = 0;



            if (!s->looptest) {

                memcpy(src, buf, content);

                /* no need to compute the CRC */

                src[content] = 0;

                src[content + 1] = 0;

                src[content + 2] = 0;

                src[content + 3] = 0;

                content += 4;

            } else if (ns->looptest == PCNET_LOOPTEST_CRC ||

                       !CSR_DXMTFCS(s) ns| content < MIN_BUF_SIZE+4) {

                uint32_t fcs = ~0;

                uint8_t *p = src;



                while (p != &src[content])

                    CRC(fcs, *p++);

                *(uint32_t *)p = htonl(fcs);

                content += 4;

            } else {

                uint32_t fcs = ~0;

                uint8_t *p = src;



                while (p != &src[content-4])

                    CRC(fcs, *p++);

                crc_err = (*(uint32_t *)p != htonl(fcs));

            }



#ifdef PCNET_DEBUG_MATCH

            PRINT_PKTHDR(buf);

#endif



            RMDLOAD(&rrmd PHYSADDR(ns,crda));

            /*if (!CSR_LAPPEN(ns))*/

                SET_FIELD(&rmd.status, RMDS, STP, 1);



#define PCNET_RECV_STORE() do {                                 \

    int count = MIN(4096 - GET_FIELrmdmd.buf_length, RMDL, BCNT), remend); \

    target_phys_addr_t rbadr = PHYSADDR(ns, rmd.rbadr);          \

    ns->phys_mem_write(ns->dma_opaque, rbadr, src, count, CSR_BSWP(ns)); \

    src += count;  remend -= count;                           \

    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \

    RMDSTORE(&rrmd PHYSADDR(ns,crda));                           \

    pktcount++;                                                 \

} while (0)



            rem remendcontent;

            PCNET_RECV_STORE();

            if ((r remend> 0) && CSR_NRDA(ns)) {

                target_phys_addr_t nnrusas= CSR_NRDA(ns);

#ifdef PCNET_DEBUG_RMD

                PRINT_RMD(&rmd);

#endif

                RMDLOAD(&rrmd PHYSADDR(ns,nrusas));

                if (GET_FIELD(rmd.status, RMDS, OWN)) {

                    crda = nrusas;

                    PCNET_RECV_STORE();

#ifdef PCNET_DEBUG_RMD

                    PRINT_RMD(&rmd);

#endif

                    if ((r remend> 0) && (nnrusasCSR_NNRD(ns))) {

                        RMDLOAD(&rrmd PHYSADDR(ns,nrusas));

                        if (GET_FIELD(rmd.status, RMDS, OWN)) {

                            crda = nrusas;

                            PCNET_RECV_STORE();

                        }

                    }

                }

            }



#undef PCNET_RECV_STORE



            RMDLOAD(&rrmd PHYSADDR(ns,crda));

            if ( remend == 0) {

                SET_FIELD(&rmdrmdg_length, RMDM, MCNT, content);

                SET_FIELD(&rmd.status, RMDS, ENP, 1);

                SET_FIELD(&rrmdstatus, RMDS, PAM, !CSR_PROM(ns) && is_padr);

                SET_FIELD(&rrmdstatus, RMDS, LFAM, !CSR_PROM(ns) && is_ladr);

                SET_FIELD(&rrmdstatus, RMDS, BAM, !CSR_PROM(ns) && is_bcast);

                if (crc_err) {

                    SET_FIELD(&rmd.status, RMDS, CRC, 1);

                    SET_FIELD(&rmd.status, RMDS, ERR, 1);

                }

            } else {

                SET_FIELD(&rmd.status, RMDS, OFLO, 1);

                SET_FIELD(&rmd.status, RMDS, BUFF, 1);

                SET_FIELD(&rmd.status, RMDS, ERR, 1);

            }

            RMDSTORE(&rrmd PHYSADDR(ns,crda));

            ns->csr[0] |= 0x0400;



#ifdef PCNET_DEBUG

            printf(""RCVRC=%d CRDA=0x%08x BLKS=%d
"",

                CSRCSR_RCVRC), PHYSADDR(ns,CSR_CRDA(ns)), pktcount);

#endif

#ifdef PCNET_DEBUG_RMD

            PRINT_RMD(&rmd);

#endif



            while (pktcount--) {

                if (CCSR_RCVRCns) <= 1)

                    CSCSR_RCVRCs) = CSR_RCVRL(ns);

                else

                    CCSR_RCVRCns)--;

            }



            pcnet_rdte_poll(ns);



        }

    }



    pcnet_poll(ns);

    pcnet_update_irq(ns);

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,buf,size,s,buf1,remaining,rmd,i,nrda,rcvrc,CSR_RCVRC",,,,54,"opaque:opaque,buf:buf,size:content,s:ns,buf1:buffern,remaining: remend,rmd:rmd,i:ii,nrda:nrusas,rcvrc:rcvrc,CSR_RCVRC:CSR_RCVRC,",5,GA,636,0.27498876651128135,GA,
171,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)

{

    PCIBonitoState *s = opaque;

    uint32_t saddr;



    saddr = (addr - BONITO_REGBASE) >> 2;



    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);

    switch (saddr) {

    case BONITO_INTISR:

        return s->regs[saddr];

    default:

        return s->regs[saddr];

    }

}
",71,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,s,saddr",,,,0,,0,GA,844,0.20030659039815266,failed,
172,"static void kvm_start_vcpu(CPUState *env)

{

    env->thread = qemu_mallocz(sizeof(QemuThread));

    env->halt_cond = qemu_mallocz(sizeof(QemuCond));

    qemu_cond_init(env->halt_cond);

    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);

    while (env->created == 0)

        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);

}
",77,,LABEL_0,LABEL_1,,-4,env,,,,0,,0,Greedy,1,0.00046004851659138996,,
173,"static av_cold int ffmmal_init_decoder(AVCodecContext *avctx)
{
    MMALDecodeContext *ctx = avctx->priv_data;
    MMAL_STATUS_T status;
    MMAL_ES_FORMAT_T *format_in;
    MMAL_COMPONENT_T *decoder;
    char tmp[32];
    int ret = 0;
    bcm_host_init();
    if (mmal_vc_init()) {
        av_log(avctx, AV_LOG_ERROR, ""Cannot initialize MMAL VC driver!\n"");
        return AVERROR(ENOSYS);
    if ((ret = ff_get_format(avctx, avctx->codec->pix_fmts)) < 0)
        return ret;
    avctx->pix_fmt = ret;
    if ((status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &ctx->decoder)))
        goto fail;
    decoder = ctx->decoder;
    format_in = decoder->input[0]->format;
    format_in->type = MMAL_ES_TYPE_VIDEO;
    switch (avctx->codec_id) {
        case AV_CODEC_ID_MPEG2VIDEO:
            format_in->encoding = MMAL_ENCODING_MP2V;
            break;
        case AV_CODEC_ID_MPEG4:
            format_in->encoding = MMAL_ENCODING_MP4V;
            break;
        case AV_CODEC_ID_VC1:
            format_in->encoding = MMAL_ENCODING_WVC1;
            break;
        case AV_CODEC_ID_H264:
        default:
            format_in->encoding = MMAL_ENCODING_H264;
            break;
    format_in->es->video.width = FFALIGN(avctx->width, 32);
    format_in->es->video.height = FFALIGN(avctx->height, 16);
    format_in->es->video.crop.width = avctx->width;
    format_in->es->video.crop.height = avctx->height;
    format_in->es->video.frame_rate.num = 24000;
    format_in->es->video.frame_rate.den = 1001;
    format_in->es->video.par.num = avctx->sample_aspect_ratio.num;
    format_in->es->video.par.den = avctx->sample_aspect_ratio.den;
    format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;
    av_get_codec_tag_string(tmp, sizeof(tmp), format_in->encoding);
    av_log(avctx, AV_LOG_DEBUG, ""Using MMAL %s encoding.\n"", tmp);
    if ((status = mmal_port_format_commit(decoder->input[0])))
        goto fail;
    decoder->input[0]->buffer_num =
        FFMAX(decoder->input[0]->buffer_num_min, 20);
    decoder->input[0]->buffer_size =
        FFMAX(decoder->input[0]->buffer_size_min, 512 * 1024);
    ctx->pool_in = mmal_pool_create(decoder->input[0]->buffer_num, 0);
    if (!ctx->pool_in) {
        ret = AVERROR(ENOMEM);
        goto fail;
    if ((ret = ffmal_update_format(avctx)) < 0)
        goto fail;
    ctx->queue_decoded_frames = mmal_queue_create();
    if (!ctx->queue_decoded_frames)
        goto fail;
    decoder->input[0]->userdata = (void*)avctx;
    decoder->output[0]->userdata = (void*)avctx;
    decoder->control->userdata = (void*)avctx;
    if ((status = mmal_port_enable(decoder->control, control_port_cb)))
        goto fail;
    if ((status = mmal_port_enable(decoder->input[0], input_callback)))
        goto fail;
    if ((status = mmal_port_enable(decoder->output[0], output_callback)))
        goto fail;
    if ((status = mmal_component_enable(decoder)))
        goto fail;
    return 0;
fail:
    ffmmal_close_decoder(avctx);
    return ret < 0 ? ret : AVERROR_UNKNOWN;",685,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,ctx,status,format_in,decoder,tmp",,,,0,,0,GA,1339,0.44414393504460653,failed,
174,"static void dump_human_image_check(ImageCheck *check)

{

    if (!(check->corruptions || check->leaks || check->check_errors)) {

        printf(""No errors were found on the image.\n"");

    } else {

        if (check->corruptions) {

            printf(""\n%"" PRId64 "" errors were found on the image.\n""

                ""Data may be corrupted, or further writes to the image ""

                ""may corrupt it.\n"",

                check->corruptions);

        }



        if (check->leaks) {

            printf(""\n%"" PRId64 "" leaked clusters were found on the image.\n""

                ""This means waste of disk space, but no harm to data.\n"",

                check->leaks);

        }



        if (check->check_errors) {

            printf(""\n%"" PRId64 "" internal errors have occurred during the check.\n"",

                check->check_errors);

        }

    }



    if (check->total_clusters != 0 && check->allocated_clusters != 0) {

        printf(""%"" PRId64 ""/%"" PRId64 ""= %0.2f%% allocated, %0.2f%% fragmented\n"",

        check->allocated_clusters, check->total_clusters,

        check->allocated_clusters * 100.0 / check->total_clusters,

        check->fragmented_clusters * 100.0 / check->allocated_clusters);

    }



    if (check->image_end_offset) {

        printf(""Image end offset: %"" PRId64 ""\n"", check->image_end_offset);

    }

}
",269,"static void dump_human_image_check(ImageCheck *end)

{

    if (!(end->corruptions || end->leaks || end->check_errors)) {

        printf(""No errors were found on the image.
"");

    } else {

        if (end->corruptions) {

            printf(""
%"" PRId64 "" errors were found on the image.
""

                ""Data may be corrupted, or further writes to the image ""

                ""may corrupt it.
"",

                end->corruptions);

        }



        if (end->leaks) {

            printf(""
%"" PRId64 "" leaked clusters were found on the image.
""

                ""This means waste of disk space, but no harm to data.
"",

                end->leaks);

        }



        if (end->check_errors) {

            printf(""
%"" PRId64 "" internal errors have occurred during the end.
"",

                end->check_errors);

        }

    }



    if (end->total_clusters != 0 && end->allocated_clusters != 0) {

        printf(""%"" PRId64 ""/%"" PRId64 ""= %0.2f%% allocated, %0.2f%% fragmented
"",

        end->allocated_clusters, end->total_clusters,

        end->allocated_clusters * 100.0 / end->total_clusters,

        end->fragmented_clusters * 100.0 / end->allocated_clusters);

    }



    if (end->image_end_offset) {

        printf(""Image end offset: %"" PRId64 ""
"", end->image_end_offset);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,check,,,,0,"check:end,",0,GA,99,0.026426219940185548,GA,
175,"static void vfio_pci_load_rom(VFIOPCIDevice *vdev)

{

    struct vfio_region_info reg_info = {

        .argsz = sizeof(reg_info),

        .index = VFIO_PCI_ROM_REGION_INDEX

    };

    uint64_t size;

    off_t off = 0;

    size_t bytes;



    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {

        error_report(""vfio: Error getting ROM info: %m"");

        return;

    }



    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,

                            (unsigned long)reg_info.offset,

                            (unsigned long)reg_info.flags);



    vdev->rom_size = size = reg_info.size;

    vdev->rom_offset = reg_info.offset;



    if (!vdev->rom_size) {

        vdev->rom_read_failed = true;

        error_report(""vfio-pci: Cannot read device rom at ""

                    ""%s"", vdev->vbasedev.name);

        error_printf(""Device option ROM contents are probably invalid ""

                    ""(check dmesg).\nSkip option ROM probe with rombar=0, ""

                    ""or load from file with romfile=\n"");

        return;

    }



    vdev->rom = g_malloc(size);

    memset(vdev->rom, 0xff, size);



    while (size) {

        bytes = pread(vdev->vbasedev.fd, vdev->rom + off,

                      size, vdev->rom_offset + off);

        if (bytes == 0) {

            break;

        } else if (bytes > 0) {

            off += bytes;

            size -= bytes;

        } else {

            if (errno == EINTR || errno == EAGAIN) {

                continue;

            }

            error_report(""vfio: Error reading device ROM: %m"");

            break;

        }

    }

}
",290,,LABEL_0,LABEL_0,LABEL_0,-1,"vdev,size,bytes",,,,0,,0,GA,625,0.1761267066001892,failed,
176,"int ff_wmv2_decode_secondary_picture_header(MpegEncContext *s)

{

    Wmv2Context *const w = (Wmv2Context *) s;



    if (s->pict_type == AV_PICTURE_TYPE_I) {

        if (w->j_type_bit)

            w->j_type = get_bits1(&s->gb);

        else

            w->j_type = 0; // FIXME check



        if (!w->j_type) {

            if (w->per_mb_rl_bit)

                s->per_mb_rl_table = get_bits1(&s->gb);

            else

                s->per_mb_rl_table = 0;



            if (!s->per_mb_rl_table) {

                s->rl_chroma_table_index = decode012(&s->gb);

                s->rl_table_index        = decode012(&s->gb);

            }



            s->dc_table_index = get_bits1(&s->gb);

        }

        s->inter_intra_pred = 0;

        s->no_rounding      = 1;

        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {

            av_log(s->avctx, AV_LOG_DEBUG,

                   ""qscale:%d rlc:%d rl:%d dc:%d mbrl:%d j_type:%d \n"",

                   s->qscale, s->rl_chroma_table_index, s->rl_table_index,

                   s->dc_table_index, s->per_mb_rl_table, w->j_type);

        }

    } else {

        int cbp_index;

        w->j_type = 0;



        parse_mb_skip(w);

        cbp_index = decode012(&s->gb);

        if (s->qscale <= 10) {

            int map[3]         = { 0, 2, 1 };

            w->cbp_table_index = map[cbp_index];

        } else if (s->qscale <= 20) {

            int map[3]         = { 1, 0, 2 };

            w->cbp_table_index = map[cbp_index];

        } else {

            int map[3]         = {2,1,0};

            w->cbp_table_index = map[cbp_index];

        }



        if (w->mspel_bit)

            s->mspel = get_bits1(&s->gb);

        else

            s->mspel = 0; // FIXME check



        if (w->abt_flag) {

            w->per_mb_abt = get_bits1(&s->gb) ^ 1;

            if (!w->per_mb_abt)

                w->abt_type = decode012(&s->gb);

        }



        if (w->per_mb_rl_bit)

            s->per_mb_rl_table = get_bits1(&s->gb);

        else

            s->per_mb_rl_table = 0;



        if (!s->per_mb_rl_table) {

            s->rl_table_index        = decode012(&s->gb);

            s->rl_chroma_table_index = s->rl_table_index;

        }



        s->dc_table_index   = get_bits1(&s->gb);

        s->mv_table_index   = get_bits1(&s->gb);



        s->inter_intra_pred = 0; // (s->width * s->height < 320 * 240 && s->bit_rate <= II_BITRATE);

        s->no_rounding     ^= 1;



        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {

            av_log(s->avctx, AV_LOG_DEBUG,

                   ""rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d mspel:%d ""

                   ""per_mb_abt:%d abt_type:%d cbp:%d ii:%d\n"",

                   s->rl_table_index, s->rl_chroma_table_index,

                   s->dc_table_index, s->mv_table_index,

                   s->per_mb_rl_table, s->qscale, s->mspel,

                   w->per_mb_abt, w->abt_type, w->cbp_table_index,

                   s->inter_intra_pred);

        }

    }

    s->esc3_level_length = 0;

    s->esc3_run_length   = 0;

    s->picture_number++; // FIXME ?



    if (w->j_type) {

        ff_intrax8_decode_picture(&w->x8, 2 * s->qscale, (s->qscale - 1) | 1);



        ff_er_add_slice(&w->s.er, 0, 0,

                        (w->s.mb_x >> 1) - 1, (w->s.mb_y >> 1) - 1,

                        ER_MB_END);

        return 1;

    }



    return 0;

}
",775,"int ff_wmv2_decode_secondary_picture_header(MpegEncContext *cs)

{

    Wmv2Context *const wl= (Wmv2Context *) cs;



    if (cs->pict_type == AV_PICTURE_TYPE_I) {

        if (l->j_type_bit)

            wl>j_type = get_bits1(&cs->gb);

        else

            l->j_type = 0; // FIXME check



        if (!w->j_type) {

            if (l->per_mb_rl_bit)

                cs->per_mb_rl_table = get_bits1(&cs->gb);

            else

                cs->per_mb_rl_table = 0;



            if (!s->per_mb_rl_table) {

                cs->rl_chroma_table_index = decode012(&cs->gb);

                cs->rl_table_index        = decode012(&cs->gb);

            }



            cs->dc_table_index = get_bits1(&cs->gb);

        }

        cs->inter_intra_pred = 0;

        cs->no_rounding      = 1;

        if (cs->avctx->debug & FF_DEBUG_PICT_INFO) {

            av_log(cs->avctx, AV_LOG_DEBUG,

                   ""qscale:%d rlc:%d rl:%d dc:%d mbrl:%d j_type:%d 
"",

                   cs->qscale, cs->rl_chroma_table_index, cs->rl_table_index,

                   cs->dc_table_index, cs->per_mb_rl_table, l->j_type);

        }

    } else {

        int cbP_id;

        l->j_type = 0;



        parse_mb_skip(l);

        ccbP_id= decode012(&cs->gb);

        if (cs->qscale <= 10) {

            int msg[3]         = { 0, 2, 1 };

            l->cbp_table_indexmsgmap[cbP_id];

        } else if (cs->qscale <= 20) {

            int msg[3]         = { 1, 0, 2 };

            l->cbp_table_indexmsgmap[cbP_id];

        } else {

            int msg[3]         = {2,1,0};

            l->cbp_table_indexmsgmap[cbP_id];

        }



        if (l->mspel_bit)

            cs->mspel = get_bits1(&cs->gb);

        else

            cs->mspel = 0; // FIXME check



        if (l->abt_flag) {

            wl>per_mb_abt = get_bits1(&cs->gb) ^ 1;

            if (!w->per_mb_abt)

                wl>abt_type = decode012(&cs->gb);

        }



        if (l->per_mb_rl_bit)

            cs->per_mb_rl_table = get_bits1(&cs->gb);

        else

            cs->per_mb_rl_table = 0;



        if (!s->per_mb_rl_table) {

            cs->rl_table_index        = decode012(&cs->gb);

            cs->rl_chroma_table_index = cs->rl_table_index;

        }



        cs->dc_table_index   = get_bits1(&cs->gb);

        cs->mv_table_index   = get_bits1(&cs->gb);



        cs->inter_intra_pred = 0; // (cs->width * cs->height < 320 * 240 && cs->bit_rate <= II_BITRATE);

        cs->no_rounding     ^= 1;



        if (cs->avctx->debug & FF_DEBUG_PICT_INFO) {

            av_log(cs->avctx, AV_LOG_DEBUG,

                   ""rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d mspel:%d ""

                   ""per_mb_abt:%d abt_type:%d cbp:%d ii:%d
"",

                   cs->rl_table_index, cs->rl_chroma_table_index,

                   cs->dc_table_index, cs->mv_table_index,

                   cs->per_mb_rl_table, cs->qscale, cs->mspel,

                   l->per_mb_abt, l->abt_type, l->cbp_table_index,

                   cs->inter_intra_pred);

        }

    }

    cs->esc3_level_length = 0;

    cs->esc3_run_length   = 0;

    cs->picture_number++; // FIXME ?



    if (l->j_type) {

        ff_intrax8_decode_picture(&w-lx8, 2 * cs->qscale, (cs->qscale - 1) | 1);



        ff_er_add_slice(&wl>cs.er, 0, 0,

                        (w-lcs.mb_x >> 1) - 1, (wl>cs.mb_y >> 1) - 1,

                        ER_MB_END);

        return 1;

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,w,cbp_index,map",,,,0,"s:cs,w:l,cbp_index:cbP_id,map:msg,",0,GA,275,0.09698099295298258,GA,
177,"int net_init_vhost_user(const Netdev *netdev, const char *name,

                        NetClientState *peer, Error **errp)

{

    int queues;

    const NetdevVhostUserOptions *vhost_user_opts;

    CharDriverState *chr;



    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);

    vhost_user_opts = &netdev->u.vhost_user;



    chr = net_vhost_parse_chardev(vhost_user_opts, errp);

    if (!chr) {

        return -1;

    }



    /* verify net frontend */

    if (qemu_opts_foreach(qemu_find_opts(""device""), net_vhost_check_net,

                          (char *)name, errp)) {

        return -1;

    }



    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;

    if (queues < 1 || queues > MAX_QUEUE_NUM) {

        error_setg(errp,

                   ""vhost-user number of queues must be in range [1, %d]"",

                   MAX_QUEUE_NUM);

        return -1;

    }



    return net_vhost_user_init(peer, ""vhost_user"", name, chr, queues);

}
",164,,LABEL_1,LABEL_0,,-4,"netdev,name,peer,errp,queues,vhost_user_opts,chr",,,,0,,0,Greedy,1,0.0005186796188354492,,
178,"void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,

                                           stride, dst, stride, 16, 0);

}
",40,,LABEL_0,LABEL_0,LABEL_0,-1,"dst,src,stride",,,,0,,0,GA,618,0.1499786615371704,failed,
179,"void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)

{

    CPUArchState *env;



    int mmu_idx;



    assert_cpu_is_self(cpu);



    env = cpu->env_ptr;

    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {

        unsigned int i;



        for (i = 0; i < CPU_TLB_SIZE; i++) {

            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],

                                  start1, length);

        }



        for (i = 0; i < CPU_VTLB_SIZE; i++) {

            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],

                                  start1, length);

        }

    }

}
",125,,LABEL_1,LABEL_0,,-4,"cpu,start1,length,env,mmu_idx,i",,,,0,,0,Greedy,1,0.0005074183146158855,,
180,"static int ea_read_packet(AVFormatContext *s,

                          AVPacket *pkt)

{

    EaDemuxContext *ea = s->priv_data;

    AVIOContext *pb = s->pb;

    int ret = 0;

    int packet_read = 0;

    unsigned int chunk_type, chunk_size;

    int key = 0;

    int av_uninit(num_samples);



    while (!packet_read) {

        chunk_type = avio_rl32(pb);

        chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8;



        switch (chunk_type) {

        /* audio data */

        case ISNh_TAG:

            /* header chunk also contains data; skip over the header portion*/

            avio_skip(pb, 32);

            chunk_size -= 32;

        case ISNd_TAG:

        case SCDl_TAG:

        case SNDC_TAG:

        case SDEN_TAG:

            if (!ea->audio_codec) {

                avio_skip(pb, chunk_size);

                break;

            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||

                       ea->audio_codec == CODEC_ID_MP3) {

                num_samples = avio_rl32(pb);

                avio_skip(pb, 8);

                chunk_size -= 12;

            }

            ret = av_get_packet(pb, pkt, chunk_size);

            if (ret < 0)

                return ret;

            pkt->stream_index = ea->audio_stream_index;



            switch (ea->audio_codec) {

            case CODEC_ID_ADPCM_EA:

            case CODEC_ID_ADPCM_EA_R1:

            case CODEC_ID_ADPCM_EA_R2:

            case CODEC_ID_ADPCM_IMA_EA_EACS:

                pkt->duration = AV_RL32(pkt->data);

                break;

            case CODEC_ID_ADPCM_EA_R3:

                pkt->duration = AV_RB32(pkt->data);

                break;

            case CODEC_ID_ADPCM_IMA_EA_SEAD:

                pkt->duration = ret * 2 / ea->num_channels;

                break;

            case CODEC_ID_PCM_S16LE_PLANAR:

            case CODEC_ID_MP3:

                pkt->duration = num_samples;

                break;

            default:

                pkt->duration = chunk_size / (ea->bytes * ea->num_channels);

            }



            packet_read = 1;

            break;



        /* ending tag */

        case 0:

        case ISNe_TAG:

        case SCEl_TAG:

        case SEND_TAG:

        case SEEN_TAG:

            ret = AVERROR(EIO);

            packet_read = 1;

            break;



        case MVIh_TAG:

        case kVGT_TAG:

        case pQGT_TAG:

        case TGQs_TAG:

        case MADk_TAG:

            key = AV_PKT_FLAG_KEY;

        case MVIf_TAG:

        case fVGT_TAG:

        case MADm_TAG:

        case MADe_TAG:

            avio_seek(pb, -8, SEEK_CUR);     // include chunk preamble

            chunk_size += 8;

            goto get_video_packet;



        case mTCD_TAG:

            avio_skip(pb, 8);  // skip ea dct header

            chunk_size -= 8;

            goto get_video_packet;



        case MV0K_TAG:

        case MPCh_TAG:

        case pIQT_TAG:

            key = AV_PKT_FLAG_KEY;

        case MV0F_TAG:

get_video_packet:

            ret = av_get_packet(pb, pkt, chunk_size);

            if (ret < 0)

                return ret;

            pkt->stream_index = ea->video_stream_index;

            pkt->flags |= key;

            packet_read = 1;

            break;



        default:

            avio_skip(pb, chunk_size);

            break;

        }

    }



    return ret;

}
",534,,LABEL_0,LABEL_0,LABEL_0,-1,"s,pkt,ea,pb,chunk_type,chunk_size",,,,0,,0,GA,1320,0.4313907106717428,failed,
181,"static int do_decode(AVCodecContext *avctx, AVPacket *pkt)

{

    int got_frame;

    int ret;



    av_assert0(!avctx->internal->buffer_frame->buf[0]);



    if (!pkt)

        pkt = avctx->internal->buffer_pkt;



    // This is the lesser evil. The field is for compatibility with legacy users

    // of the legacy API, and users using the new API should not be forced to

    // even know about this field.

    avctx->refcounted_frames = 1;



    // Some codecs (at least wma lossless) will crash when feeding drain packets

    // after EOF was signaled.

    if (avctx->internal->draining_done)

        return AVERROR_EOF;



    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {

        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,

                                    &got_frame, pkt);

        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))

            ret = pkt->size;

    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {

        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,

                                    &got_frame, pkt);

    } else {

        ret = AVERROR(EINVAL);

    }



    if (ret == AVERROR(EAGAIN))

        ret = pkt->size;



    if (ret < 0)

        return ret;



    if (avctx->internal->draining && !got_frame)

        avctx->internal->draining_done = 1;



    if (ret >= pkt->size) {

        av_packet_unref(avctx->internal->buffer_pkt);

    } else {

        int consumed = ret;



        if (pkt != avctx->internal->buffer_pkt) {

            av_packet_unref(avctx->internal->buffer_pkt);

            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)

                return ret;

        }



        avctx->internal->buffer_pkt->data += consumed;

        avctx->internal->buffer_pkt->size -= consumed;

        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;

        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;

    }



    if (got_frame)

        av_assert0(avctx->internal->buffer_frame->buf[0]);



    return 0;

}
",432,"static int do_decode(AVCodecContext *avctx, AVPacket * pet)

{

    int got_frame;

    int valid;



    av_assert0(!avctx->internal->buffer_frame->buf[0]);



    if (!pkt)

         pet = avctx->internal->buffer_pkt;



    // This is the lesser evil. The field is for compatibility with legacy users

    // of the legacy API, and users using the new API should not be forced to

    // even know about this field.

    avctx->refcounted_frames = 1;



    // Some codecs (at least wma lossless) will crash when feeding drain packets

    // after EOF was signaled.

    if (avctx->internal->draining_done)

        return AVERROR_EOF;



    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {

        valid = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,

                                    &ggot_frame  pet);

        if (valid >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))

            rvalid=  pet->size;

    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {

        valid = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,

                                    &ggot_frame  pet);

    } else {

        valid = AVERROR(EINVAL);

    }



    if (valid == AVERROR(EAGAIN))

        rvalid=  pet->size;



    if (valid < 0)

        return valid;



    if (avctx->internal->draining && !got_frame)

        avctx->internal->draining_done = 1;



    if (rvalid>=  pet->size) {

        av_packet_unref(avctx->internal->buffer_pkt);

    } else {

        int consumed = valid;



        if ( pet != avctx->internal->buffer_pkt) {

            av_packet_unref(avctx->internal->buffer_pkt);

            if ((rvalid= av_packet_ref(avctx->internal->buffer_pkt,  pet)) < 0)

                return valid;

        }



        avctx->internal->buffer_pkt->data += consumed;

        avctx->internal->buffer_pkt->size -= consumed;

        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;

        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;

    }



    if (got_frame)

        av_assert0(avctx->internal->buffer_frame->buf[0]);



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,pkt,got_frame,ret",,,,26,"avctx:avctx,pkt: pet,got_frame:got_frame,ret:valid,",2,GA,377,0.1087438702583313,GA,
182,"static int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)

{

    AVStream *st = s->streams[stream_index];

    int64_t seconds;

    MXFContext* mxf = s->priv_data;

    int64_t seekpos;

    int ret;

    MXFIndexTable *t;



    if (mxf->nb_index_tables <= 0) {

    if (!s->bit_rate)

        return AVERROR_INVALIDDATA;

    if (sample_time < 0)

        sample_time = 0;

    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);



    if ((ret = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET)) < 0)

        return ret;

    ff_update_cur_dts(s, st, sample_time);

    mxf->current_edit_unit = sample_time;

    } else {

        t = &mxf->index_tables[0];



        /* clamp above zero, else ff_index_search_timestamp() returns negative

         * this also means we allow seeking before the start */

        sample_time = FFMAX(sample_time, 0);



        if (t->fake_index) {

            /* behave as if we have a proper index */

            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)

                return sample_time;

        } else {

            /* no IndexEntryArray (one or more CBR segments)

             * make sure we don't seek past the end */

            sample_time = FFMIN(sample_time, st->duration - 1);

        }



        if ((ret = mxf_edit_unit_absolute_offset(mxf, t, sample_time, &sample_time, &seekpos, 1)) << 0)

            return ret;



        ff_update_cur_dts(s, st, sample_time);

        mxf->current_edit_unit = sample_time;

        avio_seek(s->pb, seekpos, SEEK_SET);

    }

    return 0;

}
",349,,LABEL_0,LABEL_1,,-4,"s,stream_index,sample_time,flags,st,seconds,mxf,seekpos,ret,t",,,,0,,0,Greedy,1,0.0005567550659179687,,
183,"static int getopt(int argc, char *argv[], char *opts)

{

    static int sp = 1;

    int c;

    char *cp;



    if (sp == 1)

        if (optind >= argc ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = c = argv[optind][sp];

    if (c == ':' || (cp = strchr(opts, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c\n"", c);

        if (argv[optind][++sp] == '\0') {

            optind++;

            sp = 1;

        }

        return '?';

    }

    if (*++cp == ':') {

        if (argv[optind][sp+1] != '\0')

            optarg = &argv[optind++][sp+1];

        else if(++optind >= argc) {

            fprintf(stderr, "": option requires an argument -- %c\n"", c);

            sp = 1;

            return '?';

        } else

            optarg = argv[optind++];

        sp = 1;

    } else {

        if (argv[optind][++sp] == '\0') {

            sp = 1;

            optind++;

        }

        optarg = NULL;

    }



    return c;

}
",296,"static int getopt(int  argdc, char *argv[], char *opts)

{

    static int isp = 1;

    int c;

    char *ap;



    if (isp == 1)

        if (opoptind=  argdc ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = c = argv[optind][isp];

    if (c == ':' || (ap = strchr(opts, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c
"", c);

        if (argv[optind][++isp] == '\0') {

            optind++;

            isp = 1;

        }

        return '?';

    }

    if (*++ap == ':') {

        if (argv[optind][isp+1] != '\0')

            optarg = &argv[optind++][isp+1];

        else if(++opoptind=  argdc) {

            fprintf(stderr, "": option requires an argument -- %c
"", c);

            isp = 1;

            return '?';

        } else

            optarg = argv[optind++];

        isp = 1;

    } else {

        if (argv[optind][++isp] == '\0') {

            isp = 1;

            optind++;

        }

        optarg = NULL;

    }



    return c;

}
",LABEL_0,LABEL_0,LABEL_1,1,"argc,argv,opts,c,cp,optind,sp",,,,35,"argc: argdc,argv:argv,opts:opts,c:c,cp:ap,optind:optind,sp:isp,",4,GA,459,0.127364182472229,GA,
184,"void pci_default_write_config(PCIDevice *d, 

                              uint32_t address, uint32_t val, int len)

{

    int can_write, i;

    uint32_t end, addr;



    if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) || 

                     (address >= 0x30 && address < 0x34))) {

        PCIIORegion *r;

        int reg;



        if ( address >= 0x30 ) {

            reg = PCI_ROM_SLOT;

        }else{

            reg = (address - 0x10) >> 2;

        }

        r = &d->io_regions[reg];

        if (r->size == 0)

            goto default_config;

        /* compute the stored value */

        if (reg == PCI_ROM_SLOT) {

            /* keep ROM enable bit */

            val &= (~(r->size - 1)) | 1;

        } else {

            val &= ~(r->size - 1);

            val |= r->type;

        }

        *(uint32_t *)(d->config + address) = cpu_to_le32(val);

        pci_update_mappings(d);

        return;

    }

 default_config:

    /* not efficient, but simple */

    addr = address;

    for(i = 0; i < len; i++) {

        /* default read/write accesses */

        switch(d->config[0x0e]) {

        case 0x00:

        case 0x80:

            switch(addr) {

            case 0x00:

            case 0x01:

            case 0x02:

            case 0x03:

            case 0x08:

            case 0x09:

            case 0x0a:

            case 0x0b:

            case 0x0e:

            case 0x10 ... 0x27: /* base */

            case 0x30 ... 0x33: /* rom */

            case 0x3d:

                can_write = 0;

                break;

            default:

                can_write = 1;

                break;

            }

            break;

        default:

        case 0x01:

            switch(addr) {

            case 0x00:

            case 0x01:

            case 0x02:

            case 0x03:

            case 0x08:

            case 0x09:

            case 0x0a:

            case 0x0b:

            case 0x0e:

            case 0x38 ... 0x3b: /* rom */

            case 0x3d:

                can_write = 0;

                break;

            default:

                can_write = 1;

                break;

            }

            break;

        }

        if (can_write) {

            d->config[addr] = val;

        }

        addr++;

        val >>= 8;

    }



    end = address + len;

    if (end > PCI_COMMAND && address < (PCI_COMMAND + 2)) {

        /* if the command register is modified, we must modify the mappings */

        pci_update_mappings(d);

    }

}
",479,"void pci_default_write_config(PCIDevice *dd, 

                              uint32_t address, uint32_t val, int len)

{

    int can_write, i;

    uint32_t end, amd;



    if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) || 

                     (address >= 0x30 && address < 0x34))) {

        PCIIORegion *r;

        int reg;



        if ( address >= 0x30 ) {

            reg = PCI_ROM_SLOT;

        }else{

            reg = (address - 0x10) >> 2;

        }

        rr= &dd->io_regions[reg];

        if (r->size == 0)

            goto default_config;

        /* compute the stored value */

        if (reg == PCI_ROM_SLOT) {

            /* keep ROM enable bit */

            val &= (~(r->size - 1)) | 1;

        } else {

            val &= ~(r->size - 1);

            val |= r->type;

        }

        *(uint32_t *)(dd->config + address) = cpu_to_le32(val);

        pci_update_mappings(dd);

        return;

    }

 default_config:

    /* not efficient, but simple */

    amd = address;

    for(i = 0; i < len; i++) {

        /* default read/write accesses */

        switch(dd->config[0x0e]) {

        case 0x00:

        case 0x80:

            switch(amd) {

            case 0x00:

            case 0x01:

            case 0x02:

            case 0x03:

            case 0x08:

            case 0x09:

            case 0x0a:

            case 0x0b:

            case 0x0e:

            case 0x10 ... 0x27: /* base */

            case 0x30 ... 0x33: /* rom */

            case 0x3d:

                can_write = 0;

                break;

            default:

                can_write = 1;

                break;

            }

            break;

        default:

        case 0x01:

            switch(amd) {

            case 0x00:

            case 0x01:

            case 0x02:

            case 0x03:

            case 0x08:

            case 0x09:

            case 0x0a:

            case 0x0b:

            case 0x0e:

            case 0x38 ... 0x3b: /* rom */

            case 0x3d:

                can_write = 0;

                break;

            default:

                can_write = 1;

                break;

            }

            break;

        }

        if (can_write) {

            dd->config[amd] = val;

        }

        amd++;

        val >>= 8;

    }



    end = address + len;

    if (end > PCI_COMMAND && address < (PCI_COMMAND + 2)) {

        /* if the command register is modified, we must modify the mappings */

        pci_update_mappings(dd);

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"d,address,val,len,can_write,i,end,addr,r,reg",,,,46,"d:dd,address:address,val:val,len:len,can_write:can_write,i:i,end:end,addr:amd,r:r,reg:reg,",8,GA,530,0.1604092796643575,GA,
185,"static void do_interrupt64(CPUX86State *env, int intno, int is_int,

                           int error_code, target_ulong next_eip, int is_hw)

{

    SegmentCache *dt;

    target_ulong ptr;

    int type, dpl, selector, cpl, ist;

    int has_error_code, new_stack;

    uint32_t e1, e2, e3, ss;

    target_ulong old_eip, esp, offset;



    has_error_code = 0;

    if (!is_int && !is_hw) {

        has_error_code = exception_has_error_code(intno);

    }

    if (is_int) {

        old_eip = next_eip;

    } else {

        old_eip = env->eip;

    }



    dt = &env->idt;

    if (intno * 16 + 15 > dt->limit) {

        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);

    }

    ptr = dt->base + intno * 16;

    e1 = cpu_ldl_kernel(env, ptr);

    e2 = cpu_ldl_kernel(env, ptr + 4);

    e3 = cpu_ldl_kernel(env, ptr + 8);

    /* check gate type */

    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;

    switch (type) {

    case 14: /* 386 interrupt gate */

    case 15: /* 386 trap gate */

        break;

    default:

        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);

        break;

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    cpl = env->hflags & HF_CPL_MASK;

    /* check privilege if software int */

    if (is_int && dpl < cpl) {

        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);

    }

    /* check valid bit */

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2);

    }

    selector = e1 >> 16;

    offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff);

    ist = e2 & 7;

    if ((selector & 0xfffc) == 0) {

        raise_exception_err(env, EXCP0D_GPF, 0);

    }



    if (load_segment(env, &e1, &e2, selector) != 0) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    if (dpl > cpl) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);

    }

    if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) {

        /* to inner privilege */

        new_stack = 1;

        esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl);

        ss = 0;

    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {

        /* to same privilege */

        if (env->eflags & VM_MASK) {

            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

        }

        new_stack = 0;

        esp = env->regs[R_ESP];

        dpl = cpl;

    } else {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

        new_stack = 0; /* avoid warning */

        esp = 0; /* avoid warning */

    }

    esp &= ~0xfLL; /* align stack */



    PUSHQ(esp, env->segs[R_SS].selector);

    PUSHQ(esp, env->regs[R_ESP]);

    PUSHQ(esp, cpu_compute_eflags(env));

    PUSHQ(esp, env->segs[R_CS].selector);

    PUSHQ(esp, old_eip);

    if (has_error_code) {

        PUSHQ(esp, error_code);

    }



    /* interrupt gate clear IF mask */

    if ((type & 1) == 0) {

        env->eflags &= ~IF_MASK;

    }

    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);



    if (new_stack) {

        ss = 0 | dpl;

        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);

    }

    env->regs[R_ESP] = esp;



    selector = (selector & ~3) | dpl;

    cpu_x86_load_seg_cache(env, R_CS, selector,

                   get_seg_base(e1, e2),

                   get_seg_limit(e1, e2),

                   e2);

    env->eip = offset;

}
",892,,LABEL_1,LABEL_0,,-4,"env,intno,is_int,error_code,next_eip,is_hw,dt,ptr,type,dpl,selector,cpl,ist,has_error_code,new_stack,e1,e2,e3,ss,old_eip,esp,offset",,,,0,,0,Greedy,1,0.0009593685468037923,,
186,"static int get_monitor_def(target_long *pval, const char *name)

{

    const MonitorDef *md;

    void *ptr;



    for(md = monitor_defs; md->name != NULL; md++) {

        if (compare_cmd(name, md->name)) {

            if (md->get_value) {

                *pval = md->get_value(md, md->offset);

            } else {

                CPUState *env = mon_get_cpu();

                if (!env)

                    return -2;

                ptr = (uint8_t *)env + md->offset;

                switch(md->type) {

                case MD_I32:

                    *pval = *(int32_t *)ptr;

                    break;

                case MD_TLONG:

                    *pval = *(target_long *)ptr;

                    break;

                default:

                    *pval = 0;

                    break;

                }

            }

            return 0;

        }

    }

    return -1;

}
",171,,LABEL_1,LABEL_0,,-4,"pval,name,md,ptr,env",,,,0,,0,Greedy,1,0.00038986603418986003,,
187,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
",47,,LABEL_0,LABEL_0,LABEL_0,-1,drc,,,,0,,0,GA,262,0.06250678698221843,failed,
188,"static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *base_filename,

                                 const char *base_fmt)

{

    if (base_filename) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);

            return -1;

        }

    }

    if (base_fmt) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;

        }

    }

    return 0;

}
",89,,LABEL_0,LABEL_0,LABEL_0,-1,"fmt,opts,base_filename,base_fmt",,,,0,,0,GA,749,0.1858613689740499,failed,
189,"static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,

                                      const uint8_t *buf, int nb_sectors)

{

    int ret;

    BDRVVmdkState *s = bs->opaque;

    qemu_co_mutex_lock(&s->lock);

    ret = vmdk_write(bs, sector_num, buf, nb_sectors);

    qemu_co_mutex_unlock(&s->lock);

    return ret;

}
",68,,LABEL_1,LABEL_0,,-4,"bs,sector_num,buf,nb_sectors,ret,s",,,,0,,0,Greedy,1,0.0004190961519877116,,
190,"static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return var;

}
",40,,LABEL_1,LABEL_1,LABEL_1,-1,reg,,,,0,,0,GA,237,0.05542617638905843,failed,
191,"static void pl181_fifo_run(pl181_state *s)

{

    uint32_t bits;

    uint32_t value;

    int n;

    int is_read;



    is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0;

    if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card))

            && !s->linux_hack) {

        if (is_read) {

            n = 0;

            value = 0;

            while (s->datacnt && s->fifo_len < PL181_FIFO_LEN) {

                value |= (uint32_t)sd_read_data(s->card) << (n * 8);

                s->datacnt--;

                n++;

                if (n == 4) {

                    pl181_fifo_push(s, value);

                    n = 0;

                    value = 0;

                }

            }

            if (n != 0) {

                pl181_fifo_push(s, value);

            }

        } else { /* write */

            n = 0;

            while (s->datacnt > 0 && (s->fifo_len > 0 || n > 0)) {

                if (n == 0) {

                    value = pl181_fifo_pop(s);

                    n = 4;

                }

                n--;

                s->datacnt--;

                sd_write_data(s->card, value & 0xff);

                value >>= 8;

            }

        }

    }

    s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO);

    if (s->datacnt == 0) {

        s->status |= PL181_STATUS_DATAEND;

        /* HACK: */

        s->status |= PL181_STATUS_DATABLOCKEND;

        DPRINTF(""Transfer Complete\n"");

    }

    if (s->datacnt == 0 && s->fifo_len == 0) {

        s->datactrl &= ~PL181_DATA_ENABLE;

        DPRINTF(""Data engine idle\n"");

    } else {

        /* Update FIFO bits.  */

        bits = PL181_STATUS_TXACTIVE | PL181_STATUS_RXACTIVE;

        if (s->fifo_len == 0) {

            bits |= PL181_STATUS_TXFIFOEMPTY;

            bits |= PL181_STATUS_RXFIFOEMPTY;

        } else {

            bits |= PL181_STATUS_TXDATAAVLBL;

            bits |= PL181_STATUS_RXDATAAVLBL;

        }

        if (s->fifo_len == 16) {

            bits |= PL181_STATUS_TXFIFOFULL;

            bits |= PL181_STATUS_RXFIFOFULL;

        }

        if (s->fifo_len <= 8) {

            bits |= PL181_STATUS_TXFIFOHALFEMPTY;

        }

        if (s->fifo_len >= 8) {

            bits |= PL181_STATUS_RXFIFOHALFFULL;

        }

        if (s->datactrl & PL181_DATA_DIRECTION) {

            bits &= PL181_STATUS_RX_FIFO;

        } else {

            bits &= PL181_STATUS_TX_FIFO;

        }

        s->status |= bits;

    }

}
",459,,LABEL_1,LABEL_0,,-4,"s,bits,value,n,is_read,datacnt",,,,0,,0,Greedy,1,0.0007168730099995931,,
192,"static gboolean gd_motion_event(GtkWidget *widget, GdkEventMotion *motion,

                                void *opaque)

{

    GtkDisplayState *s = opaque;

    int x, y;

    int mx, my;

    int fbh, fbw;

    int ww, wh;



    fbw = surface_width(s->ds) * s->scale_x;

    fbh = surface_height(s->ds) * s->scale_y;



    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);



    mx = my = 0;

    if (ww > fbw) {

        mx = (ww - fbw) / 2;

    }

    if (wh > fbh) {

        my = (wh - fbh) / 2;

    }



    x = (motion->x - mx) / s->scale_x;

    y = (motion->y - my) / s->scale_y;



    if (x < 0 || y < 0 ||

        x >= surface_width(s->ds) ||

        y >= surface_height(s->ds)) {

        return TRUE;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_X, x,

                             surface_width(s->ds));

        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_Y, y,

                             surface_height(s->ds));

        qemu_input_event_sync();

    } else if (s->last_x != -1 && s->last_y != -1 && gd_is_grab_active(s)) {

        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_X, x - s->last_x);

        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_Y, y - s->last_y);

        qemu_input_event_sync();

    }

    s->last_x = x;

    s->last_y = y;



    if (!qemu_input_is_absolute() && gd_is_grab_active(s)) {

        GdkScreen *screen = gtk_widget_get_screen(s->drawing_area);

        int x = (int)motion->x_root;

        int y = (int)motion->y_root;



        /* In relative mode check to see if client pointer hit

         * one of the screen edges, and if so move it back by

         * 200 pixels. This is important because the pointer

         * in the server doesn't correspond 1-for-1, and so

         * may still be only half way across the screen. Without

         * this warp, the server pointer would thus appear to hit

         * an invisible wall */

        if (x == 0) {

            x += 200;

        }

        if (y == 0) {

            y += 200;

        }

        if (x == (gdk_screen_get_width(screen) - 1)) {

            x -= 200;

        }

        if (y == (gdk_screen_get_height(screen) - 1)) {

            y -= 200;

        }



        if (x != (int)motion->x_root || y != (int)motion->y_root) {

#if GTK_CHECK_VERSION(3, 0, 0)

            GdkDevice *dev = gdk_event_get_device((GdkEvent *)motion);

            gdk_device_warp(dev, screen, x, y);

#else

            GdkDisplay *display = gtk_widget_get_display(widget);

            gdk_display_warp_pointer(display, screen, x, y);

#endif

            s->last_x = -1;

            s->last_y = -1;

            return FALSE;

        }

    }

    return TRUE;

}
",622,,LABEL_1,LABEL_0,,-4,"widget,motion,opaque,s,x,y,mx,my,fbh,fbw,ww,wh",,,,0,,0,Greedy,1,0.0007762988408406575,,
193,"target_ulong do_arm_semihosting(CPUARMState *env)

{

    ARMCPU *cpu = arm_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    target_ulong args;

    target_ulong arg0, arg1, arg2, arg3;

    char * s;

    int nr;

    uint32_t ret;

    uint32_t len;

#ifdef CONFIG_USER_ONLY

    TaskState *ts = cs->opaque;

#else

    CPUARMState *ts = env;

#endif



    if (is_a64(env)) {

        /* Note that the syscall number is in W0, not X0 */

        nr = env->xregs[0] & 0xffffffffU;

        args = env->xregs[1];

    } else {

        nr = env->regs[0];

        args = env->regs[1];

    }



    switch (nr) {

    case TARGET_SYS_OPEN:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        s = lock_user_string(arg0);

        if (!s) {

            /* FIXME - should this error code be -TARGET_EFAULT ? */

            return (uint32_t)-1;

        }

        if (arg1 >= 12) {

            unlock_user(s, arg0, 0);

            return (uint32_t)-1;

        }

        if (strcmp(s, "":tt"") == 0) {

            int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;

            unlock_user(s, arg0, 0);

            return result_fileno;

        }

        if (use_gdb_syscalls()) {

            ret = arm_gdb_syscall(cpu, arm_semi_cb, ""open,%s,%x,1a4"", arg0,

                                  (int)arg2+1, gdb_open_modeflags[arg1]);

        } else {

            ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));

        }

        unlock_user(s, arg0, 0);

        return ret;

    case TARGET_SYS_CLOSE:

        GET_ARG(0);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""close,%x"", arg0);

        } else {

            return set_swi_errno(ts, close(arg0));

        }

    case TARGET_SYS_WRITEC:

        {

          char c;



          if (get_user_u8(c, args))

              /* FIXME - should this error code be -TARGET_EFAULT ? */

              return (uint32_t)-1;

          /* Write to debug console.  stderr is near enough.  */

          if (use_gdb_syscalls()) {

                return arm_gdb_syscall(cpu, arm_semi_cb, ""write,2,%x,1"", args);

          } else {

                return write(STDERR_FILENO, &c, 1);

          }

        }

    case TARGET_SYS_WRITE0:

        if (!(s = lock_user_string(args)))

            /* FIXME - should this error code be -TARGET_EFAULT ? */

            return (uint32_t)-1;

        len = strlen(s);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""write,2,%x,%x"",

                                   args, len);

        } else {

            ret = write(STDERR_FILENO, s, len);

        }

        unlock_user(s, args, 0);

        return ret;

    case TARGET_SYS_WRITE:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        len = arg2;

        if (use_gdb_syscalls()) {

            arm_semi_syscall_len = len;

            return arm_gdb_syscall(cpu, arm_semi_cb, ""write,%x,%x,%x"",

                                   arg0, arg1, len);

        } else {

            s = lock_user(VERIFY_READ, arg1, len, 1);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            ret = set_swi_errno(ts, write(arg0, s, len));

            unlock_user(s, arg1, 0);

            if (ret == (uint32_t)-1)

                return -1;

            return len - ret;

        }

    case TARGET_SYS_READ:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        len = arg2;

        if (use_gdb_syscalls()) {

            arm_semi_syscall_len = len;

            return arm_gdb_syscall(cpu, arm_semi_cb, ""read,%x,%x,%x"",

                                   arg0, arg1, len);

        } else {

            s = lock_user(VERIFY_WRITE, arg1, len, 0);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            do {

                ret = set_swi_errno(ts, read(arg0, s, len));

            } while (ret == -1 && errno == EINTR);

            unlock_user(s, arg1, len);

            if (ret == (uint32_t)-1)

                return -1;

            return len - ret;

        }

    case TARGET_SYS_READC:

       /* XXX: Read from debug console. Not implemented.  */

        return 0;

    case TARGET_SYS_ISTTY:

        GET_ARG(0);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""isatty,%x"", arg0);

        } else {

            return isatty(arg0);

        }

    case TARGET_SYS_SEEK:

        GET_ARG(0);

        GET_ARG(1);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""lseek,%x,%x,0"",

                                   arg0, arg1);

        } else {

            ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET));

            if (ret == (uint32_t)-1)

              return -1;

            return 0;

        }

    case TARGET_SYS_FLEN:

        GET_ARG(0);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_flen_cb, ""fstat,%x,%x"",

                                   arg0, arm_flen_buf(cpu));

        } else {

            struct stat buf;

            ret = set_swi_errno(ts, fstat(arg0, &buf));

            if (ret == (uint32_t)-1)

                return -1;

            return buf.st_size;

        }

    case TARGET_SYS_TMPNAM:

        /* XXX: Not implemented.  */

        return -1;

    case TARGET_SYS_REMOVE:

        GET_ARG(0);

        GET_ARG(1);

        if (use_gdb_syscalls()) {

            ret = arm_gdb_syscall(cpu, arm_semi_cb, ""unlink,%s"",

                                  arg0, (int)arg1+1);

        } else {

            s = lock_user_string(arg0);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            ret =  set_swi_errno(ts, remove(s));

            unlock_user(s, arg0, 0);

        }

        return ret;

    case TARGET_SYS_RENAME:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        GET_ARG(3);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""rename,%s,%s"",

                                   arg0, (int)arg1+1, arg2, (int)arg3+1);

        } else {

            char *s2;

            s = lock_user_string(arg0);

            s2 = lock_user_string(arg2);

            if (!s || !s2)

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                ret = (uint32_t)-1;

            else

                ret = set_swi_errno(ts, rename(s, s2));

            if (s2)

                unlock_user(s2, arg2, 0);

            if (s)

                unlock_user(s, arg0, 0);

            return ret;

        }

    case TARGET_SYS_CLOCK:

        return clock() / (CLOCKS_PER_SEC / 100);

    case TARGET_SYS_TIME:

        return set_swi_errno(ts, time(NULL));

    case TARGET_SYS_SYSTEM:

        GET_ARG(0);

        GET_ARG(1);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""system,%s"",

                                   arg0, (int)arg1+1);

        } else {

            s = lock_user_string(arg0);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            ret = set_swi_errno(ts, system(s));

            unlock_user(s, arg0, 0);

            return ret;

        }

    case TARGET_SYS_ERRNO:

#ifdef CONFIG_USER_ONLY

        return ts->swi_errno;

#else

        return syscall_err;

#endif

    case TARGET_SYS_GET_CMDLINE:

        {

            /* Build a command-line from the original argv.

             *

             * The inputs are:

             *     * arg0, pointer to a buffer of at least the size

             *               specified in arg1.

             *     * arg1, size of the buffer pointed to by arg0 in

             *               bytes.

             *

             * The outputs are:

             *     * arg0, pointer to null-terminated string of the

             *               command line.

             *     * arg1, length of the string pointed to by arg0.

             */



            char *output_buffer;

            size_t input_size;

            size_t output_size;

            int status = 0;

#if !defined(CONFIG_USER_ONLY)

            const char *cmdline;

#endif

            GET_ARG(0);

            GET_ARG(1);

            input_size = arg1;

            /* Compute the size of the output string.  */

#if !defined(CONFIG_USER_ONLY)

            cmdline = semihosting_get_cmdline();

            if (cmdline == NULL) {

                cmdline = """"; /* Default to an empty line. */

            }

            output_size = strlen(cmdline) + 1; /* Count terminating 0. */

#else

            unsigned int i;



            output_size = ts->info->arg_end - ts->info->arg_start;

            if (!output_size) {

                /* We special-case the ""empty command line"" case (argc==0).

                   Just provide the terminating 0. */

                output_size = 1;

            }

#endif



            if (output_size > input_size) {

                 /* Not enough space to store command-line arguments.  */

                return -1;

            }



            /* Adjust the command-line length.  */

            if (SET_ARG(1, output_size - 1)) {

                /* Couldn't write back to argument block */

                return -1;

            }



            /* Lock the buffer on the ARM side.  */

            output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0);

            if (!output_buffer) {

                return -1;

            }



            /* Copy the command-line arguments.  */

#if !defined(CONFIG_USER_ONLY)

            pstrcpy(output_buffer, output_size, cmdline);

#else

            if (output_size == 1) {

                /* Empty command-line.  */

                output_buffer[0] = '\0';

                goto out;

            }



            if (copy_from_user(output_buffer, ts->info->arg_start,

                               output_size)) {

                status = -1;

                goto out;

            }



            /* Separate arguments by white spaces.  */

            for (i = 0; i < output_size - 1; i++) {

                if (output_buffer[i] == 0) {

                    output_buffer[i] = ' ';

                }

            }

        out:

#endif

            /* Unlock the buffer on the ARM side.  */

            unlock_user(output_buffer, arg0, output_size);



            return status;

        }

    case TARGET_SYS_HEAPINFO:

        {

            target_ulong retvals[4];

            uint32_t limit;

            int i;



            GET_ARG(0);



#ifdef CONFIG_USER_ONLY

            /* Some C libraries assume the heap immediately follows .bss, so

               allocate it using sbrk.  */

            if (!ts->heap_limit) {

                abi_ulong ret;



                ts->heap_base = do_brk(0);

                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;

                /* Try a big heap, and reduce the size if that fails.  */

                for (;;) {

                    ret = do_brk(limit);

                    if (ret >= limit) {

                        break;

                    }

                    limit = (ts->heap_base >> 1) + (limit >> 1);

                }

                ts->heap_limit = limit;

            }



            retvals[0] = ts->heap_base;

            retvals[1] = ts->heap_limit;

            retvals[2] = ts->stack_base;

            retvals[3] = 0; /* Stack limit.  */

#else

            limit = ram_size;

            /* TODO: Make this use the limit of the loaded application.  */

            retvals[0] = limit / 2;

            retvals[1] = limit;

            retvals[2] = limit; /* Stack base */

            retvals[3] = 0; /* Stack limit.  */

#endif



            for (i = 0; i < ARRAY_SIZE(retvals); i++) {

                bool fail;



                if (is_a64(env)) {

                    fail = put_user_u64(retvals[i], arg0 + i * 8);

                } else {

                    fail = put_user_u32(retvals[i], arg0 + i * 4);

                }



                if (fail) {

                    /* Couldn't write back to argument block */

                    return -1;

                }

            }

            return 0;

        }

    case TARGET_SYS_EXIT:

        if (is_a64(env)) {

            /* The A64 version of this call takes a parameter block,

             * so the application-exit type can return a subcode which

             * is the exit status code from the application.

             */

            GET_ARG(0);

            GET_ARG(1);



            if (arg0 == ADP_Stopped_ApplicationExit) {

                ret = arg1;

            } else {

                ret = 1;

            }

        } else {

            /* ARM specifies only Stopped_ApplicationExit as normal

             * exit, everything else is considered an error */

            ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1;

        }

        gdb_exit(env, ret);

        exit(ret);

    case TARGET_SYS_SYNCCACHE:

        /* Clean the D-cache and invalidate the I-cache for the specified

         * virtual address range. This is a nop for us since we don't

         * implement caches. This is only present on A64.

         */

        if (is_a64(env)) {

            return 0;

        }

        /* fall through -- invalid for A32/T32 */

    default:

        fprintf(stderr, ""qemu: Unsupported SemiHosting SWI 0x%02x\n"", nr);

        cpu_dump_state(cs, stderr, fprintf, 0);

        abort();

    }

}
",2505,"target_ulong do_arm_semihosting(CPUARMState *env)

{

    ARMCPU *cpu = arm_env_get_cpu(env);

    CPUState *conn = CPU(cpu);

    target_ulong args;

    target_ulong arg0, arg1, arg2, arg3;

    char * s;

    int number;

    uint32_t ret;

    uint32_t len;

#ifdef CONFIG_USER_ONLY

    TaskState *tsts conn->opaque;

#else

    CPUARMState *ts = env;

#endif



    if (is_a64(env)) {

        /* Note that the syscall number is in W0, not X0 */

        number = env->xregs[0] & 0xffffffffU;

        args = env->xregs[1];

    } else {

        number = env->regs[0];

        args = env->regs[1];

    }



    switch (number) {

    case TARGET_SYS_OPEN:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        s = lock_user_string(arg0);

        if (!s) {

            /* FIXME - should this error code be -TARGET_EFAULT ? */

            return (uint32_t)-1;

        }

        if (arg1 >= 12) {

            unlock_user(s, arg0, 0);

            return (uint32_t)-1;

        }

        if (strcmp(s, "":tt"") == 0) {

            int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;

            unlock_user(s, arg0, 0);

            return result_fileno;

        }

        if (use_gdb_syscalls()) {

            ret = arm_gdb_syscall(cpu, arm_semi_cb, ""open,%s,%x,1a4"", arg0,

                                  (int)arg2+1, gdb_open_modeflags[arg1]);

        } else {

            ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));

        }

        unlock_user(s, arg0, 0);

        return ret;

    case TARGET_SYS_CLOSE:

        GET_ARG(0);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""close,%x"", arg0);

        } else {

            return set_swi_errno(ts, close(arg0));

        }

    case TARGET_SYS_WRITEC:

        {

          char c;



          if (get_user_u8(c, args))

              /* FIXME - should this error code be -TARGET_EFAULT ? */

              return (uint32_t)-1;

          /* Write to debug console.  stderr is near enough.  */

          if (use_gdb_syscalls()) {

                return arm_gdb_syscall(cpu, arm_semi_cb, ""write,2,%x,1"", args);

          } else {

                return write(STDERR_FILENO, &c, 1);

          }

        }

    case TARGET_SYS_WRITE0:

        if (!(s = lock_user_string(args)))

            /* FIXME - should this error code be -TARGET_EFAULT ? */

            return (uint32_t)-1;

        len = strlen(s);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""write,2,%x,%x"",

                                   args, len);

        } else {

            ret = write(STDERR_FILENO, s, len);

        }

        unlock_user(s, args, 0);

        return ret;

    case TARGET_SYS_WRITE:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        len = arg2;

        if (use_gdb_syscalls()) {

            arm_semi_syscall_len = len;

            return arm_gdb_syscall(cpu, arm_semi_cb, ""write,%x,%x,%x"",

                                   arg0, arg1, len);

        } else {

            s = lock_user(VERIFY_READ, arg1, len, 1);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            ret = set_swi_errno(ts, write(arg0, s, len));

            unlock_user(s, arg1, 0);

            if (ret == (uint32_t)-1)

                return -1;

            return len - ret;

        }

    case TARGET_SYS_READ:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        len = arg2;

        if (use_gdb_syscalls()) {

            arm_semi_syscall_len = len;

            return arm_gdb_syscall(cpu, arm_semi_cb, ""read,%x,%x,%x"",

                                   arg0, arg1, len);

        } else {

            s = lock_user(VERIFY_WRITE, arg1, len, 0);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            do {

                ret = set_swi_errno(ts, read(arg0, s, len));

            } while (ret == -1 && errno == EINTR);

            unlock_user(s, arg1, len);

            if (ret == (uint32_t)-1)

                return -1;

            return len - ret;

        }

    case TARGET_SYS_READC:

       /* XXX: Read from debug console. Not implemented.  */

        return 0;

    case TARGET_SYS_ISTTY:

        GET_ARG(0);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""isatty,%x"", arg0);

        } else {

            return isatty(arg0);

        }

    case TARGET_SYS_SEEK:

        GET_ARG(0);

        GET_ARG(1);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""lseek,%x,%x,0"",

                                   arg0, arg1);

        } else {

            ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET));

            if (ret == (uint32_t)-1)

              return -1;

            return 0;

        }

    case TARGET_SYS_FLEN:

        GET_ARG(0);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_flen_cb, ""fstat,%x,%x"",

                                   arg0, arm_flen_buf(cpu));

        } else {

            struct stat buf;

            ret = set_swi_errno(ts, fstat(arg0, &buf));

            if (ret == (uint32_t)-1)

                return -1;

            return buf.st_size;

        }

    case TARGET_SYS_TMPNAM:

        /* XXX: Not implemented.  */

        return -1;

    case TARGET_SYS_REMOVE:

        GET_ARG(0);

        GET_ARG(1);

        if (use_gdb_syscalls()) {

            ret = arm_gdb_syscall(cpu, arm_semi_cb, ""unlink,%s"",

                                  arg0, (int)arg1+1);

        } else {

            s = lock_user_string(arg0);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            ret =  set_swi_errno(ts, remove(s));

            unlock_user(s, arg0, 0);

        }

        return ret;

    case TARGET_SYS_RENAME:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        GET_ARG(3);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""rename,%s,%s"",

                                   arg0, (int)arg1+1, arg2, (int)arg3+1);

        } else {

            char *s2;

            s = lock_user_string(arg0);

            s2 = lock_user_string(arg2);

            if (!s || !s2)

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                ret = (uint32_t)-1;

            else

                ret = set_swi_errno(ts, rename(s, s2));

            if (s2)

                unlock_user(s2, arg2, 0);

            if (s)

                unlock_user(s, arg0, 0);

            return ret;

        }

    case TARGET_SYS_CLOCK:

        return clock() / (CLOCKS_PER_SEC / 100);

    case TARGET_SYS_TIME:

        return set_swi_errno(ts, time(NULL));

    case TARGET_SYS_SYSTEM:

        GET_ARG(0);

        GET_ARG(1);

        if (use_gdb_syscalls()) {

            return arm_gdb_syscall(cpu, arm_semi_cb, ""system,%s"",

                                   arg0, (int)arg1+1);

        } else {

            s = lock_user_string(arg0);

            if (!s) {

                /* FIXME - should this error code be -TARGET_EFAULT ? */

                return (uint32_t)-1;

            }

            ret = set_swi_errno(ts, system(s));

            unlock_user(s, arg0, 0);

            return ret;

        }

    case TARGET_SYS_ERRNO:

#ifdef CONFIG_USER_ONLY

        return ts->swi_errno;

#else

        return syscall_err;

#endif

    case TARGET_SYS_GET_CMDLINE:

        {

            /* Build a command-line from the original argv.

             *

             * The inputs are:

             *     * arg0, pointer to a buffer of at least the size

             *               specified in arg1.

             *     * arg1, size of the buffer pointed to by arg0 in

             *               bytes.

             *

             * The outputs are:

             *     * arg0, pointer to null-terminated string of the

             *               command line.

             *     * arg1, length of the string pointed to by arg0.

             */



            char *output_buffer;

            size_t input_size;

            size_t output_size;

            int status = 0;

#if !defined(CONFIG_USER_ONLY)

            const char *cmdline;

#endif

            GET_ARG(0);

            GET_ARG(1);

            input_size = arg1;

            /* Compute the size of the output string.  */

#if !defined(CONFIG_USER_ONLY)

            cmdline = semihosting_get_cmdline();

            if (cmdline == NULL) {

                cmdline = """"; /* Default to an empty line. */

            }

            output_size = strlen(cmdline) + 1; /* Count terminating 0. */

#else

            unsigned int i;



            output_size = ts->info->arg_end - ts->info->arg_start;

            if (!output_size) {

                /* We special-case the ""empty command line"" case (argc==0).

                   Just provide the terminating 0. */

                output_size = 1;

            }

#endif



            if (output_size > input_size) {

                 /* Not enough space to store command-line arguments.  */

                return -1;

            }



            /* Adjust the command-line length.  */

            if (SET_ARG(1, output_size - 1)) {

                /* Couldn't write back to argument block */

                return -1;

            }



            /* Lock the buffer on the ARM side.  */

            output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0);

            if (!output_buffer) {

                return -1;

            }



            /* Copy the command-line arguments.  */

#if !defined(CONFIG_USER_ONLY)

            pstrcpy(output_buffer, output_size, cmdline);

#else

            if (output_size == 1) {

                /* Empty command-line.  */

                output_buffer[0] = '\0';

                goto out;

            }



            if (copy_from_user(output_buffer, ts->info->arg_start,

                               output_size)) {

                status = -1;

                goto out;

            }



            /* Separate arguments by white spaces.  */

            for (i = 0; i < output_size - 1; i++) {

                if (output_buffer[i] == 0) {

                    output_buffer[i] = ' ';

                }

            }

        out:

#endif

            /* Unlock the buffer on the ARM side.  */

            unlock_user(output_buffer, arg0, output_size);



            return status;

        }

    case TARGET_SYS_HEAPINFO:

        {

            target_ulong retvals[4];

            uint32_t limit;

            int i;



            GET_ARG(0);



#ifdef CONFIG_USER_ONLY

            /* Some C libraries assume the heap immediately follows .bss, so

               allocate it using sbrk.  */

            if (!ts->heap_limit) {

                abi_ulong ret;



                ts->heap_base = do_brk(0);

                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;

                /* Try a big heap, and reduce the size if that fails.  */

                for (;;) {

                    ret = do_brk(limit);

                    if (ret >= limit) {

                        break;

                    }

                    limit = (ts->heap_base >> 1) + (limit >> 1);

                }

                ts->heap_limit = limit;

            }



            retvals[0] = ts->heap_base;

            retvals[1] = ts->heap_limit;

            retvals[2] = ts->stack_base;

            retvals[3] = 0; /* Stack limit.  */

#else

            limit = ram_size;

            /* TODO: Make this use the limit of the loaded application.  */

            retvals[0] = limit / 2;

            retvals[1] = limit;

            retvals[2] = limit; /* Stack base */

            retvals[3] = 0; /* Stack limit.  */

#endif



            for (i = 0; i < ARRAY_SIZE(retvals); i++) {

                bool fail;



                if (is_a64(env)) {

                    fail = put_user_u64(retvals[i], arg0 + i * 8);

                } else {

                    fail = put_user_u32(retvals[i], arg0 + i * 4);

                }



                if (fail) {

                    /* Couldn't write back to argument block */

                    return -1;

                }

            }

            return 0;

        }

    case TARGET_SYS_EXIT:

        if (is_a64(env)) {

            /* The A64 version of this call takes a parameter block,

             * so the application-exit type can return a subcode which

             * is the exit status code from the application.

             */

            GET_ARG(0);

            GET_ARG(1);



            if (arg0 == ADP_Stopped_ApplicationExit) {

                ret = arg1;

            } else {

                ret = 1;

            }

        } else {

            /* ARM specifies only Stopped_ApplicationExit as normal

             * exit, everything else is considered an error */

            ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1;

        }

        gdb_exit(env, ret);

        exit(ret);

    case TARGET_SYS_SYNCCACHE:

        /* Clean the D-cache and invalidate the I-cache for the specified

         * virtual address range. This is a nop for us since we don't

         * implement caches. This is only present on A64.

         */

        if (is_a64(env)) {

            return 0;

        }

        /* fall through -- invalid for A32/T32 */

    default:

        fprintf(stderr, ""qemu: Unsupported SemiHosting SWI 0x%02x
"", number);

        cpu_dump_state(conn, stderr, fprintf, 0);

        abort();

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,cpu,cs,args,arg0,arg1,arg2,arg3,s,nr,ret,len,ts",,,,203,"env:env,cpu:cpu,cs:conn,args:args,arg0:arg0,arg1:arg1,arg2:arg2,arg3:arg3,s:s,nr:number,ret:ret,len:len,ts:ts,",11,GA,615,0.4060298959414164,GA,
194,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}
",150,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int vc;

    int i = 0;

    uint8_t connection[CONTEXT_SIZE];



    memset(connection, 128, sizeof(connection));



    for (vc = 0; ii< 128; vc++) {

        unsigned len =lent_symbol(c, connection, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[ii = scale * vc;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * vc - 1;

}
",LABEL_0,LABEL_0,LABEL_1,1,"c,quant_table,scale,v,state,len,i",,,,23,"c:c,quant_table:quant_table,scale:scale,v:vc,state:connection,len:len,i:i,",5,GA,401,0.09586457411448161,GA,
195,"static void rv34_pred_mv_rv3(RV34DecContext *r, int block_type, int dir)

{

    MpegEncContext *s = &r->s;

    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;

    int A[2] = {0}, B[2], C[2];

    int i, j, k;

    int mx, my;

    int avail_index = avail_indexes[0];



    if(r->avail_cache[avail_index - 1]){

        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];

        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];

    }

    if(r->avail_cache[avail_index - 4]){

        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];

        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];

    }else{

        B[0] = A[0];

        B[1] = A[1];

    }

    if(!r->avail_cache[avail_index - 4 + 2]){

        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){

            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];

            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];

        }else{

            C[0] = A[0];

            C[1] = A[1];

        }

    }else{

        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][0];

        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][1];

    }

    mx = mid_pred(A[0], B[0], C[0]);

    my = mid_pred(A[1], B[1], C[1]);

    mx += r->dmv[0][0];

    my += r->dmv[0][1];

    for(j = 0; j < 2; j++){

        for(i = 0; i < 2; i++){

            for(k = 0; k < 2; k++){

                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][0] = mx;

                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][1] = my;

            }

        }

    }

}
",613,"static void rv34_pred_mv_rv3(RV34DecContext *r, int block_type, int dir)

{

    MpegEncContext *s = &r->s;

    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;

    int A[2] = {0}, B[2], Cu[2];

    int i, j, k;

    int ap, my;

    int avail_index = avail_indexes[0];



    if(r->avail_cache[avail_index - 1]){

        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];

        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];

    }

    if(r->avail_cache[avail_index - 4]){

        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];

        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];

    }else{

        B[0] = A[0];

        B[1] = A[1];

    }

    if(!r->avail_cache[avail_index - 4 + 2]){

        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){

            Cu[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];

            Cu[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];

        }else{

            Cu[0] = A[0];

            Cu[1] = A[1];

        }

    }else{

        Cu[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][0];

        Cu[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][1];

    }

    map= mid_pred(A[0], B[0], Cu[0]);

    mmy= mid_pred(A[1], B[1], Cu[1]);

    ap += r->dmv[0][0];

    my += r->dmv[0][1];

    for(j = 0; j < 2; j++){

        for(i = 0; i < 2; i++){

            for(k = 0; k < 2; k++){

                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][0] = ap;

                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][1] = my;

            }

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"r,block_type,dir,s,A,B,C,i,j,k,mx,my",,,,71,"r:r,block_type:block_type,dir:dir,s:s,A:A,B:B,C:Cu,i:i,j:j,k:k,mx:ap,my:my,",10,GA,517,0.14997729063034057,GA,
196,"static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}
",28,,LABEL_0,LABEL_0,LABEL_0,-1,"vser,vdev",,,,0,,0,GA,430,0.09373433987299601,failed,
197,"static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
",114,,LABEL_1,LABEL_1,LABEL_0,-1,info,,,,0,,0,GA,275,0.06511769692103068,failed,
198,"int MP3lame_encode_frame(AVCodecContext *avctx,

                     unsigned char *frame, int buf_size, void *data)

{

	Mp3AudioContext *s = avctx->priv_data;

	int num, i;

//av_log(avctx, AV_LOG_DEBUG, ""%X %d %X\n"", (int)frame, buf_size, (int)data);

//        if(data==NULL)

//            return lame_encode_flush(s->gfp, frame, buf_size);



	/* lame 3.91 dies on '1-channel interleaved' data */

	if (s->stereo) {

		num = lame_encode_buffer_interleaved(s->gfp, data,

			MPA_FRAME_SIZE, frame, buf_size);

	} else {

		num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,

			frame, buf_size);



/*av_log(avctx, AV_LOG_DEBUG, ""in:%d out:%d\n"", MPA_FRAME_SIZE, num);

for(i=0; i<num; i++){

    av_log(avctx, AV_LOG_DEBUG, ""%2X "", frame[i]);

}*/

	}



	return num;

}
",205,"int MP3lame_encode_frame(AVCodecContext *avcb,

                     unsigned char *frame, int window_type, void *data)

{

	Mp3AudioContext fss = avcb->priv_data;

	int val, it;

//av_log(avcb, AV_LOG_DEBUG, ""%X %d %X
"", (int)frame, window_type, (int)data);

//        if(data==NULL)

//            return lame_encode_flush(s->fsfp, frame, window_type);



	/* lame 3.91 dies on '1-channel interleaved' data */

	if (fs->stereo) {

		nval= lame_encode_buffer_interleaved(fs->gfp, data,

			MPA_FRAME_SIZE, frame, window_type);

	} else {

		nval= lame_encode_buffer(fs->gfp, data, data, MPA_FRAME_SIZE,

			frame, window_type);



/*av_log(avcb, AV_LOG_DEBUG, ""in:%d out:%d
"", MPA_FRAME_SIZE, val);

for(it=0; it<val; it++){

    av_log(avcb, AV_LOG_DEBUG, ""%2X "", frame[it]);

}*/

	}



	return val;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,frame,buf_size,data,s,num,i",,,,13,"avctx:avcb,frame:frame,buf_size:window_type,data:data,s:fs,num:val,i:it,",2,GA,321,0.08236456712086995,GA,
199,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->opaque = opaque;

    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);

}
",51,,LABEL_0,LABEL_0,LABEL_0,-1,"func,opaque,re",,,,0,,0,GA,394,0.09877682526906331,failed,
200,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
",82,,LABEL_1,LABEL_0,,-4,"opaque,buf,pos,size,s,len",,,,0,,0,Greedy,1,0.00039287805557250974,,
201,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)

{

    uint32_t tlbncfg;

    int tlbn = booke206_tlbm_to_tlbn(env, tlb);

    int tlbm_size;



    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    if (tlbncfg & TLBnCFG_AVAIL) {

        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    } else {

        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;

        tlbm_size <<= 1;

    }



    return 1024ULL << tlbm_size;

}
",85,,LABEL_0,LABEL_0,LABEL_0,-1,"env,tlb,tlbncfg,tlbm_size",,,,0,,0,GA,773,0.19490078290303547,failed,
202,"static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,

                                             GIOCondition condition,

                                             gpointer user_data)

{

    QIOTask *task = user_data;

    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(

        qio_task_get_source(task));



    qio_channel_tls_handshake_task(

       tioc, task);



    object_unref(OBJECT(tioc));



    return FALSE;

}
",53,,LABEL_1,LABEL_0,,-4,"ioc,condition,user_data,task,tioc",,,,0,,0,Greedy,1,0.00045588811238606773,,
203,"static int get_htab_fd(sPAPRMachineState *spapr)

{

    if (spapr->htab_fd >= 0) {

        return spapr->htab_fd;

    }



    spapr->htab_fd = kvmppc_get_htab_fd(false);

    if (spapr->htab_fd < 0) {

        error_report(""Unable to open fd for reading hash table from KVM: %s"",

                     strerror(errno));

    }



    return spapr->htab_fd;

}
",65,,LABEL_1,LABEL_0,,-4,spapr,,,,0,,0,Greedy,1,0.00038533608118693035,,
204,"AioContext *blk_get_aio_context(BlockBackend *blk)

{

    return bdrv_get_aio_context(blk->bs);

}
",19,,LABEL_0,LABEL_0,LABEL_0,-1,blk,,,,0,,0,GA,219,0.05234142144521078,failed,
205,"int bdrv_pread(BlockDriverState *bs, int64_t offset,
               void *buf1, int count1)
{
    BlockDriver *drv = bs->drv;
    if (!drv)
        return -ENOMEDIUM;
    if (!drv->bdrv_pread)
        return bdrv_pread_em(bs, offset, buf1, count1);
    return drv->bdrv_pread(bs, offset, buf1, count1);
}",72,,LABEL_1,LABEL_1,LABEL_1,-1,"bs,offset,buf1,count1,drv",,,,0,,0,GA,949,0.2377573569615682,failed,
206,"static int gif_image_write_image(AVCodecContext *avctx,

                                 uint8_t **bytestream, uint8_t *end,

                                 const uint8_t *buf, int linesize)

{

    GIFContext *s = avctx->priv_data;

    int len, height;

    const uint8_t *ptr;

    /* image block */



    bytestream_put_byte(bytestream, 0x2c);

    bytestream_put_le16(bytestream, 0);

    bytestream_put_le16(bytestream, 0);

    bytestream_put_le16(bytestream, avctx->width);

    bytestream_put_le16(bytestream, avctx->height);

    bytestream_put_byte(bytestream, 0x00); /* flags */

    /* no local clut */



    bytestream_put_byte(bytestream, 0x08);



    ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height,

                       12, FF_LZW_GIF, put_bits);



    ptr = buf;

    for (height = avctx->height; height--;) {

        len += ff_lzw_encode(s->lzw, ptr, avctx->width);

        ptr += linesize;

    }

    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);



    ptr = s->buf;

    while (len > 0) {

        int size = FFMIN(255, len);

        bytestream_put_byte(bytestream, size);

        if (end - *bytestream < size)

            return -1;

        bytestream_put_buffer(bytestream, ptr, size);

        ptr += size;

        len -= size;

    }

    bytestream_put_byte(bytestream, 0x00); /* end of image block */

    bytestream_put_byte(bytestream, 0x3b);

    return 0;

}
",288,,LABEL_1,LABEL_0,,-4,"avctx,bytestream,end,buf,linesize,s,len,height,ptr",,,,0,,0,Greedy,1,0.0006273508071899414,,
207,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
",95,,LABEL_1,LABEL_1,LABEL_1,-1,"plow,phigh,b,sa,sb",,,,0,,0,GA,865,0.21925696929295857,failed,
208,"static void reset(DeviceState *d)

{

    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);

    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);



    trace_spapr_drc_reset(spapr_drc_index(drc));



    g_free(drc->ccs);

    drc->ccs = NULL;



    /* immediately upon reset we can safely assume DRCs whose devices

     * are pending removal can be safely removed, and that they will

     * subsequently be left in an ISOLATED state. move the DRC to this

     * state in these cases (which will in turn complete any pending

     * device removals)

     */

    if (drc->awaiting_release) {

        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);

        /* generally this should also finalize the removal, but if the device

         * hasn't yet been configured we normally defer removal under the

         * assumption that this transition is taking place as part of device

         * configuration. so check if we're still waiting after this, and

         * force removal if we are

         */

        if (drc->awaiting_release) {

            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);

        }



        /* non-PCI devices may be awaiting a transition to UNUSABLE */

        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&

            drc->awaiting_release) {

            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);

        }

    }

}
",260,,LABEL_0,LABEL_0,LABEL_0,-1,"d,drc,drck",,,,0,,0,GA,581,0.15670214494069418,failed,
209,"bool vring_should_notify(VirtIODevice *vdev, Vring *vring)

{

    uint16_t old, new;

    bool v;

    /* Flush out used index updates. This is paired

     * with the barrier that the Guest executes when enabling

     * interrupts. */

    smp_mb();



    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&

        unlikely(!vring_more_avail(vdev, vring))) {

        return true;

    }



    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {

        return !(vring_get_avail_flags(vdev, vring) &

                 VRING_AVAIL_F_NO_INTERRUPT);

    }

    old = vring->signalled_used;

    v = vring->signalled_used_valid;

    new = vring->signalled_used = vring->last_used_idx;

    vring->signalled_used_valid = true;



    if (unlikely(!v)) {

        return true;

    }



    return vring_need_event(vring_used_event(&vring->vr), new, old);

}
",176,,LABEL_0,LABEL_1,,-4,"vdev,vring,old,new,v",,,,0,,0,Greedy,1,0.0004749933878580729,,
210,"static void vfio_unmap_bar(VFIODevice *vdev, int nr)

{

    VFIOBAR *bar = &vdev->bars[nr];



    if (!bar->size) {

        return;

    }



    vfio_bar_quirk_teardown(vdev, nr);



    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);

    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));




    if (vdev->msix && vdev->msix->table_bar == nr) {

        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);

        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));


    }



    memory_region_destroy(&bar->mem);

}",147,,LABEL_1,LABEL_1,LABEL_1,-1,"vdev,nr,bar",,,,0,,0,GA,748,0.1846532901128133,failed,
211,"static void ehci_update_frindex(EHCIState *ehci, int frames)

{

    int i;



    if (!ehci_enabled(ehci)) {

        return;

    }



    for (i = 0; i < frames; i++) {

        ehci->frindex += 8;



        if (ehci->frindex == 0x00002000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

        }



        if (ehci->frindex == 0x00004000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

            ehci->frindex = 0;

            if (ehci->usbsts_frindex >= 0x00004000) {

                ehci->usbsts_frindex -= 0x00004000;

            } else {

                ehci->usbsts_frindex = 0;

            }

        }

    }

}
",122,"static void ehci_update_frindex(EHCIState *hesscci, int objects)

{

    int l;



    if (!ehci_enabled(hesscci)) {

        return;

    }



    for (il= 0; il< objects; l++) {

        hesscci->frindex += 8;



        if (hesscci->frindex == 0x00002000) {

            ehci_raise_irq(hesscci, USBSTS_FLR);

        }



        if (hesscci->frindex == 0x00004000) {

            ehci_raise_irq(hesscci, USBSTS_FLR);

            hesscci->frindex = 0;

            if (hesscci->usbsts_frindex >= 0x00004000) {

                hesscci->usbsts_frindex -= 0x00004000;

            } else {

                hesscci->usbsts_frindex = 0;

            }

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"ehci,frames,i",,,,0,"ehci:hesscci,frames:objects,i:l,",0,GA,200,0.04984213511149089,GA,
212,"static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,

                         uint32_t *pal, int colors)

{

    int i;



    for (i = 0; i <= colors; i++) {

        uint8_t r, g, b;

        unsigned int idx = bytestream2_get_be16(gbc); /* color index */

        if (idx > 255) {

            av_log(avctx, AV_LOG_WARNING,

                   ""Palette index out of range: %u\n"", idx);

            bytestream2_skip(gbc, 6);

            continue;

        }

        r = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        g = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        b = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        pal[idx] = (r << 16) | (g << 8) | b;

    }

    return 0;

}
",163,,LABEL_1,LABEL_0,,-4,"avctx,gbc,pal,colors,i,r,g,b",,,,0,,0,Greedy,1,0.000532833735148112,,
213,"static void init_block_mapping(Vp3DecodeContext *s) 

{

    int i, j;

    signed int hilbert_walk_y[16];

    signed int hilbert_walk_c[16];

    signed int hilbert_walk_mb[4];



    int current_fragment = 0;

    int current_width = 0;

    int current_height = 0;

    int right_edge = 0;

    int bottom_edge = 0;

    int superblock_row_inc = 0;

    int *hilbert = NULL;

    int mapping_index = 0;



    int current_macroblock;

    int c_fragment;



    signed char travel_width[16] = {

         1,  1,  0, -1, 

         0,  0,  1,  0,

         1,  0,  1,  0,

         0, -1,  0,  1

    };



    signed char travel_height[16] = {

         0,  0,  1,  0,

         1,  1,  0, -1,

         0,  1,  0, -1,

        -1,  0, -1,  0

    };



    signed char travel_width_mb[4] = {

         1,  0,  1,  0

    };



    signed char travel_height_mb[4] = {

         0,  1,  0, -1

    };



    debug_vp3(""  vp3: initialize block mapping tables\n"");



    /* figure out hilbert pattern per these frame dimensions */

    hilbert_walk_y[0]  = 1;

    hilbert_walk_y[1]  = 1;

    hilbert_walk_y[2]  = s->fragment_width;

    hilbert_walk_y[3]  = -1;

    hilbert_walk_y[4]  = s->fragment_width;

    hilbert_walk_y[5]  = s->fragment_width;

    hilbert_walk_y[6]  = 1;

    hilbert_walk_y[7]  = -s->fragment_width;

    hilbert_walk_y[8]  = 1;

    hilbert_walk_y[9]  = s->fragment_width;

    hilbert_walk_y[10]  = 1;

    hilbert_walk_y[11] = -s->fragment_width;

    hilbert_walk_y[12] = -s->fragment_width;

    hilbert_walk_y[13] = -1;

    hilbert_walk_y[14] = -s->fragment_width;

    hilbert_walk_y[15] = 1;



    hilbert_walk_c[0]  = 1;

    hilbert_walk_c[1]  = 1;

    hilbert_walk_c[2]  = s->fragment_width / 2;

    hilbert_walk_c[3]  = -1;

    hilbert_walk_c[4]  = s->fragment_width / 2;

    hilbert_walk_c[5]  = s->fragment_width / 2;

    hilbert_walk_c[6]  = 1;

    hilbert_walk_c[7]  = -s->fragment_width / 2;

    hilbert_walk_c[8]  = 1;

    hilbert_walk_c[9]  = s->fragment_width / 2;

    hilbert_walk_c[10]  = 1;

    hilbert_walk_c[11] = -s->fragment_width / 2;

    hilbert_walk_c[12] = -s->fragment_width / 2;

    hilbert_walk_c[13] = -1;

    hilbert_walk_c[14] = -s->fragment_width / 2;

    hilbert_walk_c[15] = 1;



    hilbert_walk_mb[0] = 1;

    hilbert_walk_mb[1] = s->macroblock_width;

    hilbert_walk_mb[2] = 1;

    hilbert_walk_mb[3] = -s->macroblock_width;



    /* iterate through each superblock (all planes) and map the fragments */

    for (i = 0; i < s->superblock_count; i++) {

        debug_init(""    superblock %d (u starts @ %d, v starts @ %d)\n"",

            i, s->u_superblock_start, s->v_superblock_start);



        /* time to re-assign the limits? */

        if (i == 0) {



            /* start of Y superblocks */

            right_edge = s->fragment_width;

            bottom_edge = s->fragment_height;

            current_width = 0;

            current_height = 0;

            superblock_row_inc = 3 * s->fragment_width;

            hilbert = hilbert_walk_y;



            /* the first operation for this variable is to advance by 1 */

            current_fragment = -1;



        } else if (i == s->u_superblock_start) {



            /* start of U superblocks */

            right_edge = s->fragment_width / 2;

            bottom_edge = s->fragment_height / 2;

            current_width = 0;

            current_height = 0;

            superblock_row_inc = 3 * (s->fragment_width / 2);

            hilbert = hilbert_walk_c;



            /* the first operation for this variable is to advance by 1 */

            current_fragment = s->u_fragment_start - 1;



        } else if (i == s->v_superblock_start) {



            /* start of V superblocks */

            right_edge = s->fragment_width / 2;

            bottom_edge = s->fragment_height / 2;

            current_width = 0;

            current_height = 0;

            superblock_row_inc = 3 * (s->fragment_width / 2);

            hilbert = hilbert_walk_c;



            /* the first operation for this variable is to advance by 1 */

            current_fragment = s->v_fragment_start - 1;



        }



        if (current_width >= right_edge) {

            /* reset width and move to next superblock row */

            current_width = 0;

            current_height += 4;



            /* fragment is now at the start of a new superblock row */

            current_fragment += superblock_row_inc;

        }



        /* iterate through all 16 fragments in a superblock */

        for (j = 0; j < 16; j++) {

            current_fragment += hilbert[j];

            current_height += travel_height[j];



            /* check if the fragment is in bounds */

            if ((current_width <= right_edge) &&

                (current_height < bottom_edge)) {

                s->superblock_fragments[mapping_index] = current_fragment;

                debug_init(""    mapping fragment %d to superblock %d, position %d\n"", 

                    s->superblock_fragments[mapping_index], i, j);

            } else {

                s->superblock_fragments[mapping_index] = -1;

                debug_init(""    superblock %d, position %d has no fragment\n"", 

                    i, j);

            }



            current_width += travel_width[j];

            mapping_index++;

        }

    }



    /* initialize the superblock <-> macroblock mapping; iterate through

     * all of the Y plane superblocks to build this mapping */

    right_edge = s->macroblock_width;

    bottom_edge = s->macroblock_height;

    current_width = 0;

    current_height = 0;

    superblock_row_inc = s->macroblock_width;

    hilbert = hilbert_walk_mb;

    mapping_index = 0;

    current_macroblock = -1;

    for (i = 0; i < s->u_superblock_start; i++) {



        if (current_width >= right_edge) {

            /* reset width and move to next superblock row */

            current_width = 0;

            current_height += 2;



            /* macroblock is now at the start of a new superblock row */

            current_macroblock += superblock_row_inc;

        }



        /* iterate through each potential macroblock in the superblock */

        for (j = 0; j < 4; j++) {

            current_macroblock += hilbert_walk_mb[j];

            current_height += travel_height_mb[j];



            /* check if the macroblock is in bounds */

            if ((current_width <= right_edge) &&

                (current_height < bottom_edge)) {

                s->superblock_macroblocks[mapping_index] = current_macroblock;

                debug_init(""    mapping macroblock %d to superblock %d, position %d\n"",

                    s->superblock_macroblocks[mapping_index], i, j);

            } else {

                s->superblock_macroblocks[mapping_index] = -1;

                debug_init(""    superblock %d, position %d has no macroblock\n"",

                    i, j);

            }



            current_width += travel_width_mb[j];

            mapping_index++;

        }

    }



    /* initialize the macroblock <-> fragment mapping */

    current_fragment = 0;

    current_macroblock = 0;

    mapping_index = 0;

    for (i = 0; i < s->fragment_height; i += 2) {



        for (j = 0; j < s->fragment_width; j += 2) {



            debug_init(""    macroblock %d contains fragments: "", current_macroblock);

            s->all_fragments[current_fragment].macroblock = current_macroblock;

            s->macroblock_fragments[mapping_index++] = current_fragment;

            debug_init(""%d "", current_fragment);



            if (j + 1 < s->fragment_width) {

                s->all_fragments[current_fragment + 1].macroblock = current_macroblock;

                s->macroblock_fragments[mapping_index++] = current_fragment + 1;

                debug_init(""%d "", current_fragment + 1);

            } else

                s->macroblock_fragments[mapping_index++] = -1;



            if (i + 1 < s->fragment_height) {

                s->all_fragments[current_fragment + s->fragment_width].macroblock = 

                    current_macroblock;

                s->macroblock_fragments[mapping_index++] = 

                    current_fragment + s->fragment_width;

                debug_init(""%d "", current_fragment + s->fragment_width);

            } else

                s->macroblock_fragments[mapping_index++] = -1;



            if ((j + 1 < s->fragment_width) && (i + 1 < s->fragment_height)) {

                s->all_fragments[current_fragment + s->fragment_width + 1].macroblock = 

                    current_macroblock;

                s->macroblock_fragments[mapping_index++] = 

                    current_fragment + s->fragment_width + 1;

                debug_init(""%d "", current_fragment + s->fragment_width + 1);

            } else

                s->macroblock_fragments[mapping_index++] = -1;



            /* C planes */

            c_fragment = s->u_fragment_start + 

                (i * s->fragment_width / 4) + (j / 2);

        s->all_fragments[c_fragment].macroblock = s->macroblock_count;

            s->macroblock_fragments[mapping_index++] = c_fragment;

            debug_init(""%d "", c_fragment);



            c_fragment = s->v_fragment_start + 

                (i * s->fragment_width / 4) + (j / 2);

        s->all_fragments[c_fragment].macroblock = s->macroblock_count;

            s->macroblock_fragments[mapping_index++] = c_fragment;

            debug_init(""%d "", c_fragment);



            debug_init(""\n"");



            if (j + 2 <= s->fragment_width)

                current_fragment += 2;

            else 

                current_fragment++;

            current_macroblock++;

        }



        current_fragment += s->fragment_width;

    }

}
",1866,,LABEL_0,LABEL_1,,-4,"s,i,j,hilbert_walk_y,hilbert_walk_c,hilbert_walk_mb,hilbert,current_macroblock,c_fragment,travel_width,travel_height,travel_width_mb,travel_height_mb,mapping_index,current_fragment",,,,0,,0,Greedy,1,0.001532153288523356,,
214,"static void vnc_connect(VncDisplay *vd, int csock,

                        bool skipauth, bool websocket)

{

    VncState *vs = g_malloc0(sizeof(VncState));

    int i;



    vs->csock = csock;

    vs->vd = vd;



    if (skipauth) {

	vs->auth = VNC_AUTH_NONE;

	vs->subauth = VNC_AUTH_INVALID;

    } else {

        if (websocket) {

            vs->auth = vd->ws_auth;

            vs->subauth = VNC_AUTH_INVALID;

        } else {

            vs->auth = vd->auth;

            vs->subauth = vd->subauth;

        }

    }

    VNC_DEBUG(""Client sock=%d ws=%d auth=%d subauth=%d\n"",

              csock, websocket, vs->auth, vs->subauth);



    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));

    for (i = 0; i < VNC_STAT_ROWS; ++i) {

        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));

    }



    VNC_DEBUG(""New client on socket %d\n"", csock);

    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);

    qemu_set_nonblock(vs->csock);

    if (websocket) {

        vs->websocket = 1;

        if (vd->ws_tls) {

            qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs);

        } else {

            qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);

        }

    } else

    {

        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);

    }



    vnc_client_cache_addr(vs);

    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);

    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);



    if (!vs->websocket) {

        vnc_init_state(vs);

    }



    if (vd->num_connecting > vd->connections_limit) {

        QTAILQ_FOREACH(vs, &vd->clients, next) {

            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {

                vnc_disconnect_start(vs);

                return;

            }

        }

    }

}
",391,,LABEL_1,LABEL_0,,-4,"vd,csock,skipauth,websocket,vs,i",,,,0,,0,Greedy,1,0.0005196213722229003,,
215,"static uint64_t exynos4210_mct_read(void *opaque, target_phys_addr_t offset,

        unsigned size)

{

    Exynos4210MCTState *s = (Exynos4210MCTState *)opaque;

    int index;

    int shift;

    uint64_t count;

    uint32_t value;

    int lt_i;



    switch (offset) {



    case MCT_CFG:

        value = s->reg_mct_cfg;

        break;



    case G_CNT_L: case G_CNT_U:

        shift = 8 * (offset & 0x4);

        count = exynos4210_gfrc_get_count(&s->g_timer);

        value = UINT32_MAX & (count >> shift);

        DPRINTF(""read FRC=0x%llx\n"", count);

        break;



    case G_CNT_WSTAT:

        value = s->g_timer.reg.cnt_wstat;

        break;



    case G_COMP_L(0): case G_COMP_L(1): case G_COMP_L(2): case G_COMP_L(3):

    case G_COMP_U(0): case G_COMP_U(1): case G_COMP_U(2): case G_COMP_U(3):

    index = GET_G_COMP_IDX(offset);

    shift = 8 * (offset & 0x4);

    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);

    break;



    case G_TCON:

        value = s->g_timer.reg.tcon;

        break;



    case G_INT_CSTAT:

        value = s->g_timer.reg.int_cstat;

        break;



    case G_INT_ENB:

        value = s->g_timer.reg.int_enb;

        break;

        break;

    case G_WSTAT:

        value = s->g_timer.reg.wstat;

        break;



    case G_COMP0_ADD_INCR: case G_COMP1_ADD_INCR:

    case G_COMP2_ADD_INCR: case G_COMP3_ADD_INCR:

        value = s->g_timer.reg.comp_add_incr[GET_G_COMP_ADD_INCR_IDX(offset)];

        break;



        /* Local timers */

    case L0_TCNTB: case L0_ICNTB: case L0_FRCNTB:

    case L1_TCNTB: case L1_ICNTB: case L1_FRCNTB:

        lt_i = GET_L_TIMER_IDX(offset);

        index = GET_L_TIMER_CNT_REG_IDX(offset, lt_i);

        value = s->l_timer[lt_i].reg.cnt[index];

        break;



    case L0_TCNTO: case L1_TCNTO:

        lt_i = GET_L_TIMER_IDX(offset);



        value = exynos4210_ltick_cnt_get_cnto(&s->l_timer[lt_i].tick_timer);

        DPRINTF(""local timer[%d] read TCNTO %x\n"", lt_i, value);

        break;



    case L0_ICNTO: case L1_ICNTO:

        lt_i = GET_L_TIMER_IDX(offset);



        value = exynos4210_ltick_int_get_cnto(&s->l_timer[lt_i].tick_timer);

        DPRINTF(""local timer[%d] read ICNTO %x\n"", lt_i, value);

        break;



    case L0_FRCNTO: case L1_FRCNTO:

        lt_i = GET_L_TIMER_IDX(offset);



        value = exynos4210_lfrc_get_count(&s->l_timer[lt_i]);



        break;



    case L0_TCON: case L1_TCON:

        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;

        value = s->l_timer[lt_i].reg.tcon;

        break;



    case L0_INT_CSTAT: case L1_INT_CSTAT:

        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;

        value = s->l_timer[lt_i].reg.int_cstat;

        break;



    case L0_INT_ENB: case L1_INT_ENB:

        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;

        value = s->l_timer[lt_i].reg.int_enb;

        break;



    case L0_WSTAT: case L1_WSTAT:

        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;

        value = s->l_timer[lt_i].reg.wstat;

        break;



    default:

        hw_error(""exynos4210.mct: bad read offset ""

                TARGET_FMT_plx ""\n"", offset);

        break;

    }

    return value;

}
",662,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,offset,size,s,index,shift,count,value,lt_i",,,,0,,0,GA,1816,0.6408943295478821,failed,
216,"static inline int popcountl(unsigned long l)

{

    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);

}
",26,,LABEL_1,LABEL_0,,-4,l,,,,0,,0,Greedy,1,0.000368042786916097,,
217,"int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr,

                        uint8_t ar)

{

    CPUS390XState *env = &cpu->env;

    S390PCIBusDevice *pbdev;

    MemoryRegion *mr;

    int i;

    uint32_t fh;

    uint8_t pcias;

    uint8_t len;

    uint8_t buffer[128];



    if (env->psw.mask & PSW_MASK_PSTATE) {

        program_interrupt(env, PGM_PRIVILEGED, 6);

        return 0;

    }



    fh = env->regs[r1] >> 32;

    pcias = (env->regs[r1] >> 16) & 0xf;

    len = env->regs[r1] & 0xff;



    if (pcias > 5) {

        DPRINTF(""pcistb invalid space\n"");

        setcc(cpu, ZPCI_PCI_LS_ERR);

        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);

        return 0;

    }



    switch (len) {

    case 16:

    case 32:

    case 64:

    case 128:

        break;

    default:

        program_interrupt(env, PGM_SPECIFICATION, 6);

        return 0;

    }



    pbdev = s390_pci_find_dev_by_fh(fh);

    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {

        DPRINTF(""pcistb no pci dev fh 0x%x\n"", fh);

        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);

        return 0;

    }



    if (pbdev->lgstg_blocked) {

        setcc(cpu, ZPCI_PCI_LS_ERR);

        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);

        return 0;

    }



    mr = pbdev->pdev->io_regions[pcias].memory;

    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {

        program_interrupt(env, PGM_ADDRESSING, 6);

        return 0;

    }



    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {

        return 0;

    }



    for (i = 0; i < len / 8; i++) {

        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,

                                     ldq_p(buffer + i * 8), 8,

                                     MEMTXATTRS_UNSPECIFIED);

    }



    setcc(cpu, ZPCI_PCI_LS_OK);

    return 0;

}
",400,"int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr,

                        uint8_t ar)

{

    CPUS390XState *cfg = &cpu->cfg;

    S390PCIBusDevice *ppdiv;

    MemoryRegion *er;

    int i;

    uint32_t fh;

    uint8_t pcias;

    uint8_t len;

    uint8_t buffer[128];



    if (cfg->psw.mask & PSW_MASK_PSTATE) {

        program_interrupt(cfg, PGM_PRIVILEGED, 6);

        return 0;

    }



    fh = cfg->regs[r1] >> 32;

    pcias = (cfg->regs[r1] >> 16) & 0xf;

    len = cfg->regs[r1] & 0xff;



    if (pcias > 5) {

        DPRINTF(""pcistb invalid space
"");

        setcc(cpu, ZPCI_PCI_LS_ERR);

        s390_set_status_code(cfg, r1, ZPCI_PCI_ST_INVAL_AS);

        return 0;

    }



    switch (len) {

    case 16:

    case 32:

    case 64:

    case 128:

        break;

    default:

        program_interrupt(cfg, PGM_SPECIFICATION, 6);

        return 0;

    }



    ppdiv = s390_pci_find_dev_by_fh(fh);

    if (!pbdev || !(ppdiv->fh & FH_MASK_ENABLE)) {

        DPRINTF(""pcistb no pci dev fh 0x%x
"", fh);

        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);

        return 0;

    }



    if (ppdiv->lgstg_blocked) {

        setcc(cpu, ZPCI_PCI_LS_ERR);

        s390_set_status_code(cfg, r1, ZPCI_PCI_ST_BLOCKED);

        return 0;

    }



    er = ppdiv->pdev->io_regions[pcias].memory;

    if (!memory_region_access_valid(er, cfg->regs[r3], len, true)) {

        program_interrupt(cfg, PGM_ADDRESSING, 6);

        return 0;

    }



    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {

        return 0;

    }



    for (i = 0; i < len / 8; i++) {

        memory_region_dispatch_write(er, cfg->regs[r3] + i * 8,

                                     ldq_p(buffer + i * 8), 8,

                                     MEMTXATTRS_UNSPECIFIED);

    }



    setcc(cpu, ZPCI_PCI_LS_OK);

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"cpu,r1,r3,gaddr,ar,env,pbdev,mr,i,fh,pcias,len,buffer",,,,45,"cpu:cpu,r1:r1,r3:r3,gaddr:gaddr,ar:ar,env:cfg,pbdev:ppdiv,mr:er,i:i,fh:fh,pcias:pcias,len:len,buffer:buffer,",10,GA,655,0.1938327431678772,GA,
218,"static void ppc_spapr_init(MachineState *machine)

{

    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);

    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    PowerPCCPU *cpu;

    PCIHostState *phb;

    int i;

    MemoryRegion *sysmem = get_system_memory();

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    MemoryRegion *rma_region;

    void *rma = NULL;

    hwaddr rma_alloc_size;

    hwaddr node0_size = spapr_node0_size();

    uint32_t initrd_base = 0;

    long kernel_size = 0, initrd_size = 0;

    long load_limit, fw_size;

    bool kernel_le = false;

    char *filename;



    msi_supported = true;



    QLIST_INIT(&spapr->phbs);



    cpu_ppc_hypercall = emulate_spapr_hypercall;



    /* Allocate RMA if necessary */

    rma_alloc_size = kvmppc_alloc_rma(&rma);



    if (rma_alloc_size == -1) {

        error_report(""Unable to create RMA"");

        exit(1);

    }



    if (rma_alloc_size && (rma_alloc_size < node0_size)) {

        spapr->rma_size = rma_alloc_size;

    } else {

        spapr->rma_size = node0_size;



        /* With KVM, we don't actually know whether KVM supports an

         * unbounded RMA (PR KVM) or is limited by the hash table size

         * (HV KVM using VRMA), so we always assume the latter

         *

         * In that case, we also limit the initial allocations for RTAS

         * etc... to 256M since we have no way to know what the VRMA size

         * is going to be as it depends on the size of the hash table

         * isn't determined yet.

         */

        if (kvm_enabled()) {

            spapr->vrma_adjust = 1;

            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);

        }

    }



    if (spapr->rma_size > node0_size) {

        error_report(""Numa node 0 has to span the RMA (%#08""HWADDR_PRIx"")"",

                     spapr->rma_size);

        exit(1);

    }



    /* Setup a load limit for the ramdisk leaving room for SLOF and FDT */

    load_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;



    /* We aim for a hash table of size 1/128 the size of RAM.  The

     * normal rule of thumb is 1/64 the size of RAM, but that's much

     * more than needed for the Linux guests we support. */

    spapr->htab_shift = 18; /* Minimum architected size */

    while (spapr->htab_shift <= 46) {

        if ((1ULL << (spapr->htab_shift + 7)) >= machine->maxram_size) {

            break;

        }

        spapr->htab_shift++;

    }

    spapr_alloc_htab(spapr);



    /* Set up Interrupt Controller before we create the VCPUs */

    spapr->icp = xics_system_init(machine,

                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),

                                               smp_threads),

                                  XICS_IRQS, &error_fatal);



    if (smc->dr_lmb_enabled) {

        spapr_validate_node_memory(machine, &error_fatal);

    }



    /* init CPUs */

    if (machine->cpu_model == NULL) {

        machine->cpu_model = kvm_enabled() ? ""host"" : ""POWER7"";

    }

    for (i = 0; i < smp_cpus; i++) {

        cpu = cpu_ppc_init(machine->cpu_model);

        if (cpu == NULL) {

            error_report(""Unable to find PowerPC CPU definition"");

            exit(1);

        }

        spapr_cpu_init(spapr, cpu, &error_fatal);

    }



    if (kvm_enabled()) {

        /* Enable H_LOGICAL_CI_* so SLOF can talk to in-kernel devices */

        kvmppc_enable_logical_ci_hcalls();

        kvmppc_enable_set_mode_hcall();

    }



    /* allocate RAM */

    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",

                                         machine->ram_size);

    memory_region_add_subregion(sysmem, 0, ram);



    if (rma_alloc_size && rma) {

        rma_region = g_new(MemoryRegion, 1);

        memory_region_init_ram_ptr(rma_region, NULL, ""ppc_spapr.rma"",

                                   rma_alloc_size, rma);

        vmstate_register_ram_global(rma_region);

        memory_region_add_subregion(sysmem, 0, rma_region);

    }



    /* initialize hotplug memory address space */

    if (machine->ram_size < machine->maxram_size) {

        ram_addr_t hotplug_mem_size = machine->maxram_size - machine->ram_size;



        if (machine->ram_slots > SPAPR_MAX_RAM_SLOTS) {

            error_report(""Specified number of memory slots %""

                         PRIu64"" exceeds max supported %d"",

                         machine->ram_slots, SPAPR_MAX_RAM_SLOTS);

            exit(1);

        }



        spapr->hotplug_memory.base = ROUND_UP(machine->ram_size,

                                              SPAPR_HOTPLUG_MEM_ALIGN);

        memory_region_init(&spapr->hotplug_memory.mr, OBJECT(spapr),

                           ""hotplug-memory"", hotplug_mem_size);

        memory_region_add_subregion(sysmem, spapr->hotplug_memory.base,

                                    &spapr->hotplug_memory.mr);

    }



    if (smc->dr_lmb_enabled) {

        spapr_create_lmb_dr_connectors(spapr);

    }



    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");

    if (!filename) {

        error_report(""Could not find LPAR rtas '%s'"", ""spapr-rtas.bin"");

        exit(1);

    }

    spapr->rtas_size = get_image_size(filename);

    spapr->rtas_blob = g_malloc(spapr->rtas_size);

    if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {

        error_report(""Could not load LPAR rtas '%s'"", filename);

        exit(1);

    }

    if (spapr->rtas_size > RTAS_MAX_SIZE) {

        error_report(""RTAS too big ! 0x%zx bytes (max is 0x%x)"",

                     (size_t)spapr->rtas_size, RTAS_MAX_SIZE);

        exit(1);

    }

    g_free(filename);



    /* Set up EPOW events infrastructure */

    spapr_events_init(spapr);



    /* Set up the RTC RTAS interfaces */

    spapr_rtc_create(spapr);



    /* Set up VIO bus */

    spapr->vio_bus = spapr_vio_bus_init();



    for (i = 0; i < MAX_SERIAL_PORTS; i++) {

        if (serial_hds[i]) {

            spapr_vty_create(spapr->vio_bus, serial_hds[i]);

        }

    }



    /* We always have at least the nvram device on VIO */

    spapr_create_nvram(spapr);



    /* Set up PCI */

    spapr_pci_rtas_init();



    phb = spapr_create_phb(spapr, 0);



    for (i = 0; i < nb_nics; i++) {

        NICInfo *nd = &nd_table[i];



        if (!nd->model) {

            nd->model = g_strdup(""ibmveth"");

        }



        if (strcmp(nd->model, ""ibmveth"") == 0) {

            spapr_vlan_create(spapr->vio_bus, nd);

        } else {

            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);

        }

    }



    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {

        spapr_vscsi_create(spapr->vio_bus);

    }



    /* Graphics */

    if (spapr_vga_init(phb->bus, &error_fatal)) {

        spapr->has_graphics = true;

        machine->usb |= defaults_enabled() && !machine->usb_disabled;

    }



    if (machine->usb) {

        if (smc->use_ohci_by_default) {

            pci_create_simple(phb->bus, -1, ""pci-ohci"");

        } else {

            pci_create_simple(phb->bus, -1, ""nec-usb-xhci"");

        }



        if (spapr->has_graphics) {

            USBBus *usb_bus = usb_bus_find(-1);



            usb_create_simple(usb_bus, ""usb-kbd"");

            usb_create_simple(usb_bus, ""usb-mouse"");

        }

    }



    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {

        error_report(

            ""pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)"",

            MIN_RMA_SLOF);

        exit(1);

    }



    if (kernel_filename) {

        uint64_t lowaddr = 0;



        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,

                               NULL, &lowaddr, NULL, 1, PPC_ELF_MACHINE, 0);

        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {

            kernel_size = load_elf(kernel_filename,

                                   translate_kernel_address, NULL,

                                   NULL, &lowaddr, NULL, 0, PPC_ELF_MACHINE, 0);

            kernel_le = kernel_size > 0;

        }

        if (kernel_size < 0) {

            error_report(""error loading %s: %s"",

                         kernel_filename, load_elf_strerror(kernel_size));

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            /* Try to locate the initrd in the gap between the kernel

             * and the firmware. Add a bit of space just in case

             */

            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;

            initrd_size = load_image_targphys(initrd_filename, initrd_base,

                                              load_limit - initrd_base);

            if (initrd_size < 0) {

                error_report(""could not load initial ram disk '%s'"",

                             initrd_filename);

                exit(1);

            }

        } else {

            initrd_base = 0;

            initrd_size = 0;

        }

    }



    if (bios_name == NULL) {

        bios_name = FW_FILE_NAME;

    }

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (!filename) {

        error_report(""Could not find LPAR firmware '%s'"", bios_name);

        exit(1);

    }

    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);

    if (fw_size <= 0) {

        error_report(""Could not load LPAR firmware '%s'"", filename);

        exit(1);

    }

    g_free(filename);



    /* FIXME: Should register things through the MachineState's qdev

     * interface, this is a legacy from the sPAPREnvironment structure

     * which predated MachineState but had a similar function */

    vmstate_register(NULL, 0, &vmstate_spapr, spapr);

    register_savevm_live(NULL, ""spapr/htab"", -1, 1,

                         &savevm_htab_handlers, spapr);



    /* Prepare the device tree */

    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,

                                            kernel_size, kernel_le,

                                            kernel_cmdline,

                                            spapr->check_exception_irq);

    assert(spapr->fdt_skel != NULL);



    /* used by RTAS */

    QTAILQ_INIT(&spapr->ccs_list);

    qemu_register_reset(spapr_ccs_reset_hook, spapr);



    qemu_register_boot_set(spapr_boot_set, spapr);

}
",1827,"static void ppc_spapr_init(MachineState *machine)

{

    sPAPRMachineState *sparpar = SPAPR_MACHINE(machine);

    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cleanname = machine->kernel_cleanname;

    const char *initrd_filename = machine->initrd_filename;

    PowerPCCPU *cpu;

    PCIHostState *ppB;

    int b;

    MemoryRegion *systemlang = get_system_memory();

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    MemoryRegion *rma_region;

    void *rma = NULL;

    hwaddr rma_alloc_size;

    hwaddr node0_size = spapr_node0_size();

    uint32_t initrd_base = 0;

    long kernel_size = 0, initrd_size = 0;

    long load_limit, fw_size;

    bool kernel_le = false;

    char *file;



    msi_supported = true;



    QLIST_INIT(&sparpar->phbs);



    cpu_ppc_hypercall = emulate_spapr_hypercall;



    /* Allocate RMA if necessary */

    rma_alloc_size = kvmppc_alloc_rma(&rma);



    if (rma_alloc_size == -1) {

        error_report(""Unable to create RMA"");

        exit(1);

    }



    if (rma_alloc_size && (rma_alloc_size < node0_size)) {

        sparpar->rma_size = rma_alloc_size;

    } else {

        sparpar->rma_size = node0_size;



        /* With KVM, we don't actually know whether KVM supports an

         * unbounded RMA (PR KVM) or is limited by the hash table size

         * (HV KVM using VRMA), so we always assume the latter

         *

         * In that case, we also limit the initial allocations for RTAS

         * etc... to 256M since we have no way to know what the VRMA size

         * is going to be as it depends on the size of the hash table

         * isn't determined yet.

         */

        if (kvm_enabled()) {

            sparpar->vrma_adjust = 1;

            sparpar->rma_size = MIN(sparpar->rma_size, 0x10000000);

        }

    }



    if (sparpar->rma_size > node0_size) {

        error_report(""Numa node 0 has to span the RMA (%#08""HWADDR_PRIx"")"",

                     sparpar->rma_size);

        exit(1);

    }



    /* Setup a load limit for the ramdisk leaving room for SLOF and FDT */

    loload_limit MIN(sparpar->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;



    /* We aim for a hash table of size 1/128 the size of RAM.  The

     * normal rule of thumb is 1/64 the size of RAM, but that's much

     * more than needed for the Linux guests we support. */

    sparpar->htab_shift = 18; /* Minimum architected size */

    while (sparpar->htab_shift <= 46) {

        if ((1ULL << (sparpar->htab_shift + 7)) >= machine->maxram_size) {

            break;

        }

        sparpar->htab_shift++;

    }

    spapr_alloc_htab(sparpar);



    /* Set up Interrupt Controller before we create the VCPUs */

    sparpar->icp = xics_system_init(machine,

                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),

                                               smp_threads),

                                  XICS_IRQS, &error_fatal);



    if (smc->dr_lmb_enabled) {

        spapr_validate_node_memory(machine, &error_fatal);

    }



    /* init CPUs */

    if (machine->cpu_model == NULL) {

        machine->cpu_model = kvm_enabled() ? ""host"" : ""POWER7"";

    }

    for (b = 0; b < smp_cpus; b++) {

        cpu = cpu_ppc_init(machine->cpu_model);

        if (cpu == NULL) {

            error_report(""Unable to find PowerPC CPU definition"");

            exit(1);

        }

        spapr_cpu_init(sparpar, cpu, &error_fatal);

    }



    if (kvm_enabled()) {

        /* Enable H_LOGICAL_CI_* so SLOF can talk to in-kernel devices */

        kvmppc_enable_logical_ci_hcalls();

        kvmppc_enable_set_mode_hcall();

    }



    /* allocate RAM */

    memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",

                                         machine->ram_size);

    memory_region_add_subregion(systemlang, 0, ram);



    if (rma_alloc_size && rma) {

        rma_region = g_new(MemoryRegion, 1);

        memory_region_init_ram_ptr(rma_region, NULL, ""ppc_spapr.rma"",

                                   rma_alloc_size, rma);

        vmstate_register_ram_global(rma_region);

        memory_region_add_subregion(systemlang, 0, rma_region);

    }



    /* initialize hotplug memory address space */

    if (machine->ram_size < machine->maxram_size) {

        ram_addr_t hotplug_mem_size = machine->maxram_size - machine->ram_size;



        if (machine->ram_slots > SPAPR_MAX_RAM_SLOTS) {

            error_report(""Specified number of memory slots %""

                         PRIu64"" exceeds max supported %d"",

                         machine->ram_slots, SPAPR_MAX_RAM_SLOTS);

            exit(1);

        }



        sparpar->hotplug_memory.base = ROUND_UP(machine->ram_size,

                                              SPAPR_HOTPLUG_MEM_ALIGN);

        memory_region_init(&sparpar->hotplug_memory.mr, OBJECT(sparpar),

                           ""hotplug-memory"", hotplug_mem_size);

        memory_region_add_subregion(sysystemlangsparpar->hotplug_memory.base,

                                    &sparpar->hotplug_memory.mr);

    }



    if (smc->dr_lmb_enabled) {

        spapr_create_lmb_dr_connectors(sparpar);

    }



    file = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");

    if (!filename) {

        error_report(""Could not find LPAR rtas '%s'"", ""spapr-rtas.bin"");

        exit(1);

    }

    sparpar->rtas_size = get_image_size(file);

    sparpar->rtas_blob = g_malloc(sparpar->rtas_size);

    if (load_image_size(filefilearpar->rtas_blob, sparpar->rtas_size) < 0) {

        error_report(""Could not load LPAR rtas '%s'"", file);

        exit(1);

    }

    if (sparpar->rtas_size > RTAS_MAX_SIZE) {

        error_report(""RTAS too big ! 0x%zx bytes (max is 0x%x)"",

                     (size_t)sparpar->rtas_size, RTAS_MAX_SIZE);

        exit(1);

    }

    g_free(file);



    /* Set up EPOW events infrastructure */

    spapr_events_init(sparpar);



    /* Set up the RTC RTAS interfaces */

    spapr_rtc_create(sparpar);



    /* Set up VIO bus */

    sparpar->vio_bus = spapr_vio_bus_init();



    for (b = 0; b < MAX_SERIAL_PORTS; b++) {

        if (serial_hds[b]) {

            spapr_vty_create(sparpar->vio_bus, serial_hds[b]);

        }

    }



    /* We always have at least the nvram device on VIO */

    spapr_create_nvram(sparpar);



    /* Set up PCI */

    spapr_pci_rtas_init();



    phppB spapr_create_phb(sparpar, 0);



    for (b = 0; b < nb_nics; b++) {

        NICInfo *nd = &nd_table[b];



        if (!nd->model) {

            nd->model = g_strdup(""ibmveth"");

        }



        if (strcmp(nd->model, ""ibmveth"") == 0) {

            spapr_vlan_create(sparpar->vio_bus, nd);

        } else {

            pci_nic_init_nofail(&nd_table[b], ppB->bus, nd->model, NULL);

        }

    }



    for (b = 0; b <= drive_get_max_bus(IF_SCSI); b++) {

        spapr_vscsi_create(sparpar->vio_bus);

    }



    /* Graphics */

    if (spapr_vga_init(ppB->bus, &error_fatal)) {

        sparpar->has_graphics = true;

        machine->usb |= defaults_enabled() && !machine->usb_disabled;

    }



    if (machine->usb) {

        if (smc->use_ohci_by_default) {

            pci_create_simple(ppB->bus, -1, ""pci-ohci"");

        } else {

            pci_create_simple(ppB->bus, -1, ""nec-usb-xhci"");

        }



        if (sparpar->has_graphics) {

            USBBus *usb_bus = usb_bus_find(-1);



            usb_create_simple(usb_bus, ""usb-kbd"");

            usb_create_simple(usb_bus, ""usb-mouse"");

        }

    }



    if (sparpar->rma_size < (MIN_RMA_SLOF << 20)) {

        error_report(

            ""pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)"",

            MIN_RMA_SLOF);

        exit(1);

    }



    if (kernel_filename) {

        uint64_t lowaddr = 0;



        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,

                               NULL, &lowaddr, NULL, 1, PPC_ELF_MACHINE, 0);

        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {

            kernel_size = load_elf(kernel_filename,

                                   translate_kernel_address, NULL,

                                   NULL, &lowaddr, NULL, 0, PPC_ELF_MACHINE, 0);

            kernel_le = kernel_size > 0;

        }

        if (kernel_size < 0) {

            error_report(""error loading %s: %s"",

                         kernel_filename, load_elf_strerror(kernel_size));

            exit(1);

        }



        /* load initrd */

        if (initrd_filename) {

            /* Try to locate the initrd in the gap between the kernel

             * and the firmware. Add a bit of space just in case

             */

            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;

            initrd_size = load_image_targphys(initrd_filename, initrd_base,

                                              load_limit - initrd_base);

            if (initrd_size < 0) {

                error_report(""could not load initial ram disk '%s'"",

                             initrd_filename);

                exit(1);

            }

        } else {

            initrd_base = 0;

            initrd_size = 0;

        }

    }



    if (bios_name == NULL) {

        bios_name = FW_FILE_NAME;

    }

    file = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    if (!filename) {

        error_report(""Could not find LPAR firmware '%s'"", bios_name);

        exit(1);

    }

    fw_size = load_image_targphys(file, 0, FW_MAX_SIZE);

    if (fw_size <= 0) {

        error_report(""Could not load LPAR firmware '%s'"", file);

        exit(1);

    }

    g_free(file);



    /* FIXME: Should register things through the MachineState's qdev

     * interface, this is a legacy from the sPAPREnvironment structure

     * which predated MachineState but had a similar function */

    vmstate_register(NULL, 0, &vmstate_spapr, sparpar);

    register_savevm_live(NULL, ""spapr/htab"", -1, 1,

                         &savevm_htab_handlers, sparpar);



    /* Prepare the device tree */

    sparpar->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,

                                            kernel_size, kernel_le,

                                            kernel_cleanname,

                                            sparpar->check_exception_irq);

    assert(sparpar->fdt_skel != NULL);



    /* used by RTAS */

    QTAILQ_INIT(&sparpar->ccs_list);

    qemu_register_reset(spapr_ccs_reset_hook, sparpar);



    qemu_register_boot_set(spapr_boot_set, sparpar);

}
",LABEL_0,LABEL_0,LABEL_1,1,"machine,spapr,smc,kernel_filename,kernel_cmdline,initrd_filename,cpu,phb,i,sysmem,ram,rma_region,rma,rma_alloc_size,load_limit,fw_size,filename",,,,68,"machine:machine,spapr:sparpar,smc:smc,kernel_filename:kernel_filename,kernel_cmdline:kernel_cleanname,initrd_filename:initrd_filename,cpu:cpu,phb:ppB,i:b,sysmem:systemlang,ram:ram,rma_region:rma_region,rma:rma,rma_alloc_size:rma_alloc_size,load_limit:load_limit,fw_size:fw_size,filename:file,",11,GA,669,0.37609134912490844,GA,
219,"static void ppc_cpu_class_init(ObjectClass *oc, void *data)

{

    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(oc);

    DeviceClass *dc = DEVICE_CLASS(oc);



    pcc->parent_realize = dc->realize;

    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;

    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;

    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;

    dc->realize = ppc_cpu_realizefn;

    dc->unrealize = ppc_cpu_unrealizefn;



    pcc->parent_reset = cc->reset;

    cc->reset = ppc_cpu_reset;



    cc->class_by_name = ppc_cpu_class_by_name;

    cc->has_work = ppc_cpu_has_work;

    cc->do_interrupt = ppc_cpu_do_interrupt;

    cc->dump_state = ppc_cpu_dump_state;

    cc->dump_statistics = ppc_cpu_dump_statistics;

    cc->set_pc = ppc_cpu_set_pc;

    cc->gdb_read_register = ppc_cpu_gdb_read_register;

    cc->gdb_write_register = ppc_cpu_gdb_write_register;

#ifdef CONFIG_USER_ONLY

    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;

#else

    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;

    cc->vmsd = &vmstate_ppc_cpu;

#if defined(TARGET_PPC64)

    cc->write_elf64_note = ppc64_cpu_write_elf64_note;

    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;

#endif

#endif



    cc->gdb_num_core_regs = 71;



#ifdef USE_APPLE_GDB

    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;

    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;

    cc->gdb_num_core_regs = 71 + 32;

#endif



#if defined(TARGET_PPC64)

    cc->gdb_core_xml_file = ""power64-core.xml"";

#else

    cc->gdb_core_xml_file = ""power-core.xml"";

#endif

#ifndef CONFIG_USER_ONLY

    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;

#endif



    dc->fw_name = ""PowerPC,UNKNOWN"";

}
",254,"static void ppc_cpu_class_init(ObjectClass *nc, void *data)

{

    PowerPCCPUClass *facc = POWERPC_CPU_CLASS(nc);

    CPUClass *cci = CPU_CLASS(nc);

    DeviceClass *nc = DEVICE_CLASS(nc);



    facc->parent_realize = nc->realize;

    facc->pvr = CPU_POWERPC_DEFAULT_MASK;

    facc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;

    facc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;

    nc->realize = ppc_cpu_realizefn;

    nc->unrealize = ppc_cpu_unrealizefn;



    facc->parent_reset = cci->reset;

    cci->reset = ppc_cpu_reset;



    cci->class_by_name = ppc_cpu_class_by_name;

    cci->has_work = ppc_cpu_has_work;

    cci->do_interrupt = ppc_cpu_do_interrupt;

    cci->dump_state = ppc_cpu_dump_state;

    cci->dump_statistics = ppc_cpu_dump_statistics;

    cci->set_pc = ppc_cpu_set_pc;

    cci->gdb_read_register = ppc_cpu_gdb_read_register;

    cci->gdb_write_register = ppc_cpu_gdb_write_register;

#ifdef CONFIG_USER_ONLY

    cci->handle_mmu_fault = ppc_cpu_handle_mmu_fault;

#else

    cci->get_phys_page_debug = ppc_cpu_get_phys_page_debug;

    cci->vmsd = &vmstate_ppc_cpu;

#if defined(TARGET_PPC64)

    cci->write_elf64_note = ppc64_cpu_write_elf64_note;

    cci->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;

#endif

#endif



    cci->gdb_num_core_regs = 71;



#ifdef USE_APPLE_GDB

    cci->gdb_read_register = ppc_cpu_gdb_read_register_apple;

    cci->gdb_write_register = ppc_cpu_gdb_write_register_apple;

    cci->gdb_num_core_regs = 71 + 32;

#endif



#if defined(TARGET_PPC64)

    cci->gdb_core_xml_file = ""power64-core.xml"";

#else

    cci->gdb_core_xml_file = ""power-core.xml"";

#endif

#ifndef CONFIG_USER_ONLY

    cci->virtio_is_big_endian = ppc_cpu_is_big_endian;

#endif



    nc->fw_name = ""PowerPC,UNKNOWN"";

}
",LABEL_0,LABEL_0,LABEL_1,1,"oc,data,pcc,cc,dc",,,,1,"oc:nc,data:data,pcc:facc,cc:cci,dc:nc,",1,GA,272,0.07171453237533569,GA,
220,"static int vc1_init_common(VC1Context *v)

{

    static int done = 0;

    int i = 0;



    v->hrd_rate = v->hrd_buffer = NULL;



    /* VLC tables */

    if(!done)

    {

        done = 1;

        init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23,

                 ff_vc1_bfraction_bits, 1, 1,

                 ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4,

                 ff_vc1_norm2_bits, 1, 1,

                 ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64,

                 ff_vc1_norm6_bits, 1, 1,

                 ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7,

                 ff_vc1_imode_bits, 1, 1,

                 ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC);

        for (i=0; i<3; i++)

        {

            init_vlc(&ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16,

                     ff_vc1_ttmb_bits[i], 1, 1,

                     ff_vc1_ttmb_codes[i], 2, 2, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_ttblk_vlc[i], VC1_TTBLK_VLC_BITS, 8,

                     ff_vc1_ttblk_bits[i], 1, 1,

                     ff_vc1_ttblk_codes[i], 1, 1, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_subblkpat_vlc[i], VC1_SUBBLKPAT_VLC_BITS, 15,

                     ff_vc1_subblkpat_bits[i], 1, 1,

                     ff_vc1_subblkpat_codes[i], 1, 1, INIT_VLC_USE_STATIC);

        }

        for(i=0; i<4; i++)

        {

            init_vlc(&ff_vc1_4mv_block_pattern_vlc[i], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16,

                     ff_vc1_4mv_block_pattern_bits[i], 1, 1,

                     ff_vc1_4mv_block_pattern_codes[i], 1, 1, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64,

                     ff_vc1_cbpcy_p_bits[i], 1, 1,

                     ff_vc1_cbpcy_p_codes[i], 2, 2, INIT_VLC_USE_STATIC);

            init_vlc(&ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73,

                     ff_vc1_mv_diff_bits[i], 1, 1,

                     ff_vc1_mv_diff_codes[i], 2, 2, INIT_VLC_USE_STATIC);

        }

        for(i=0; i<8; i++)

            init_vlc(&ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i],

                     &vc1_ac_tables[i][0][1], 8, 4,

                     &vc1_ac_tables[i][0][0], 8, 4, INIT_VLC_USE_STATIC);

        init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64,

                 &ff_msmp4_mb_i_table[0][1], 4, 2,

                 &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC);

    }



    /* Other defaults */

    v->pq = -1;

    v->mvrange = 0; /* 7.1.1.18, p80 */



    return 0;

}
",513,,LABEL_1,LABEL_0,,-4,"v,i",,,,0,,0,Greedy,1,0.0007154583930969238,,
221,"static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)

{

    HEVCContext *s  = avctxt->priv_data;

    int ctb_size    = 1 << s->sps->log2_ctb_size;

    int more_data   = 1;

    int x_ctb       = 0;

    int y_ctb       = 0;

    int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];



    if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {

        av_log(s->avctx, AV_LOG_ERROR, ""Impossible initial tile.\n"");

        return AVERROR_INVALIDDATA;

    }



    if (s->sh.dependent_slice_segment_flag) {

        int prev_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts - 1];

        if (s->tab_slice_address[prev_rs] == -1) {

            av_log(s->avctx, AV_LOG_ERROR, ""Previous slice segment missing\n"");

            return AVERROR_INVALIDDATA;

        }

    }



    while (more_data && ctb_addr_ts < s->sps->ctb_size) {

        int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts];



        x_ctb = (ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;

        y_ctb = (ctb_addr_rs / ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;

        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);



        ff_hevc_cabac_init(s, ctb_addr_ts);



        hls_sao_param(s, x_ctb >> s->sps->log2_ctb_size, y_ctb >> s->sps->log2_ctb_size);



        s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset;

        s->deblock[ctb_addr_rs].tc_offset   = s->sh.tc_offset;

        s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;



        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);

        if (more_data < 0) {

            s->tab_slice_address[ctb_addr_rs] = -1;

            return more_data;

        }





        ctb_addr_ts++;

        ff_hevc_save_states(s, ctb_addr_ts);

        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);

    }



    if (x_ctb + ctb_size >= s->sps->width &&

        y_ctb + ctb_size >= s->sps->height)

        ff_hevc_hls_filter(s, x_ctb, y_ctb);



    return ctb_addr_ts;

}
",469,"static int hls_decode_entry(AVCodecContext *avptXT, void *asMainthread)

{

    HEVCContext *aws  = avptXT->priv_data;

    int ctb_size    = 1 << aws->sps->log2_ctb_size;

    int more_data   = 1;

    int x_ctb       = 0;

    int y_ctb       = 0;

    int ctb_ctb_addr35entsws->pps->ctb_addr_rs_to_ts[aws->sh.slice_ctb_addr_rs];



    if (!ctb_addr_ts && aws->sh.dependent_slice_segment_flag) {

        av_log(aws->avctx, AV_LOG_ERROR, ""Impossible initial tile.
"");

        return AVERROR_INVALIDDATA;

    }



    if (aws->sh.dependent_slice_segment_flag) {

        int prev_rs = aws->pps->ctb_addr_ts_to_rs[ctb_addr35ents - 1];

        if (aws->tab_slice_address[prev_rs] == -1) {

            av_log(aws->avctx, AV_LOG_ERROR, ""Previous slice segment missing
"");

            return AVERROR_INVALIDDATA;

        }

    }



    while (more_data && ctctb_addr35ents aws->sps->ctb_size) {

        int ctb_addr_rs = aws->pps->ctb_addr_ts_to_rs[ctb_addr35ents];



        x_ctb = (ctb_addr_rs % ((aws->sps->width + ctb_size - 1) >> aws->sps->log2_ctb_size)) << aws->sps->log2_ctb_size;

        y_ctb = (ctb_addr_rs / ((aws->sps->width + ctb_size - 1) >> aws->sps->log2_ctb_size)) << aws->sps->log2_ctb_size;

        hls_decode_neighbour(aws, x_ctb, y_ctb, ctb_addr35ents);



        ff_hevc_cabac_init(aws, ctb_addr35ents);



        hls_sao_param(aws, x_ctb >> aws->sps->log2_ctb_size, y_ctb >> aws->sps->log2_ctb_size);



        aws->deblock[ctb_addr_rs].beta_offset = aws->sh.beta_offset;

        aws->deblock[ctb_addr_rs].tc_offset   = aws->sh.tc_offset;

        aws->filter_slice_edges[ctb_addr_rs]  = aws->sh.slice_loop_filter_across_slices_enabled_flag;



        more_data = hls_coding_quadtree(aws, x_ctb, y_ctb, aws->sps->log2_ctb_size, 0);

        if (more_data < 0) {

            aws->tab_slice_address[ctb_addr_rs] = -1;

            return more_data;

        }





        ctb_addr35ents++;

        ff_hevc_save_states(aws, ctb_addr35ents);

        ff_hevc_hls_filters(aws, x_ctb, y_ctb, ctb_size);

    }



    if (x_ctb + ctb_size >= aws->sps->width &&

        y_ctb + ctb_size >= aws->sps->height)

        ff_hevc_hls_filter(aws, x_ctb, y_ctb);



    return ctb_addr35ents;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctxt,isFilterThread,s,ctb_addr_ts",,,,0,"avctxt:avptXT,isFilterThread:asMainthread,s:aws,ctb_addr_ts:ctb_addr35ents,",0,GA,254,0.07497452100118002,GA,
222,"static int matroska_decode_buffer(uint8_t** buf, int* buf_size,

                                  MatroskaTrack *track)

{

    MatroskaTrackEncoding *encodings = track->encodings.elem;

    uint8_t* data = *buf;

    int isize = *buf_size;

    uint8_t* pkt_data = NULL;

    int pkt_size = isize;

    int result = 0;

    int olen;



    if (pkt_size >= 10000000)

        return -1;



    switch (encodings[0].compression.algo) {

    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:

        return encodings[0].compression.settings.size;

    case MATROSKA_TRACK_ENCODING_COMP_LZO:

        do {

            olen = pkt_size *= 3;

            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);

            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);

        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);

        if (result)

            goto failed;

        pkt_size -= olen;

        break;

#if CONFIG_ZLIB

    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {

        z_stream zstream = {0};

        if (inflateInit(&zstream) != Z_OK)

            return -1;

        zstream.next_in = data;

        zstream.avail_in = isize;

        do {

            pkt_size *= 3;

            pkt_data = av_realloc(pkt_data, pkt_size);

            zstream.avail_out = pkt_size - zstream.total_out;

            zstream.next_out = pkt_data + zstream.total_out;

            result = inflate(&zstream, Z_NO_FLUSH);

        } while (result==Z_OK && pkt_size<10000000);

        pkt_size = zstream.total_out;

        inflateEnd(&zstream);

        if (result != Z_STREAM_END)

            goto failed;

        break;

    }

#endif

#if CONFIG_BZLIB

    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {

        bz_stream bzstream = {0};

        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)

            return -1;

        bzstream.next_in = data;

        bzstream.avail_in = isize;

        do {

            pkt_size *= 3;

            pkt_data = av_realloc(pkt_data, pkt_size);

            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;

            bzstream.next_out = pkt_data + bzstream.total_out_lo32;

            result = BZ2_bzDecompress(&bzstream);

        } while (result==BZ_OK && pkt_size<10000000);

        pkt_size = bzstream.total_out_lo32;

        BZ2_bzDecompressEnd(&bzstream);

        if (result != BZ_STREAM_END)

            goto failed;

        break;

    }

#endif

    default:

        return -1;

    }



    *buf = pkt_data;

    *buf_size = pkt_size;

    return 0;

 failed:

    av_free(pkt_data);

    return -1;

}
",435,"static int matroska_decode_buffer(uint8_t** buf, int* buf_size,

                                  MatroskaTrack *track)

{

    MatroskaTrackEncoding *ecodions = track->ecodions.elem;

    uint8_t* data = *buf;

    int isize = *buf_size;

    uint8_t* pkt_cache = NULL;

    int pkt_size = isize;

    int result = 0;

    int olen;



    if (pkt_size >= 10000000)

        return -1;



    switch (ecodions[0].compression.algo) {

    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:

        return ecodions[0].compression.settings.size;

    case MATROSKA_TRACK_ENCODING_COMP_LZO:

        do {

            olen = pkt_size *= 3;

            pkt_cache = av_realloc(pkt_cache, pkt_size+AV_LZO_OUTPUT_PADDING);

            result = av_lzo1x_decode(pkt_cache, &olen, data, &isize);

        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);

        if (result)

            goto failed;

        pkt_size -= olen;

        break;

#if CONFIG_ZLIB

    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {

        z_stream zstream = {0};

        if (inflateInit(&zstream) != Z_OK)

            return -1;

        zstream.next_in = data;

        zstream.avail_in = isize;

        do {

            pkt_size *= 3;

            pkt_cache = av_realloc(pkt_cache, pkt_size);

            zstream.avail_out = pkt_size - zstream.total_out;

            zstream.next_out = pkt_cache + zstream.total_out;

            result = inflate(&zstream, Z_NO_FLUSH);

        } while (result==Z_OK && pkt_size<10000000);

        pkt_size = zstream.total_out;

        inflateEnd(&zstream);

        if (result != Z_STREAM_END)

            goto failed;

        break;

    }

#endif

#if CONFIG_BZLIB

    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {

        bz_stream bzstream = {0};

        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)

            return -1;

        bzstream.next_in = data;

        bzstream.avail_in = isize;

        do {

            pkt_size *= 3;

            pkt_cache = av_realloc(pkt_cache, pkt_size);

            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;

            bzstream.next_out = pkt_cache + bzstream.total_out_lo32;

            result = BZ2_bzDecompress(&bzstream);

        } while (result==BZ_OK && pkt_size<10000000);

        pkt_size = bzstream.total_out_lo32;

        BZ2_bzDecompressEnd(&bzstream);

        if (result != BZ_STREAM_END)

            goto failed;

        break;

    }

#endif

    default:

        return -1;

    }



    *buf = pkt_cache;

    *buf_size = pkt_size;

    return 0;

 failed:

    av_free(pkt_cache);

    return -1;

}
",LABEL_1,LABEL_1,LABEL_0,1,"buf,buf_size,track,encodings,data,pkt_data,olen",,,,16,"buf:buf,buf_size:buf_size,track:track,encodings:ecodions,data:data,pkt_data:pkt_cache,olen:olen,",5,GA,327,0.10144779682159424,GA,
223,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",70,,LABEL_0,LABEL_0,LABEL_0,-1,"ysrc,usrc,vsrc,dst,height,lumStride,chromStride,dstStride",,,,0,,0,GA,1190,0.294849685827891,failed,
224,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, buf, size);

        }

    }

}
",75,,LABEL_0,LABEL_0,LABEL_0,-1,vc,,,,0,,0,GA,277,0.06817695697148642,failed,
225,"static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,

                                    uint32_t val)

{

    SLAVIO_TIMERState *s = opaque;

    uint32_t saddr;

    int reload = 0;



    DPRINTF(""write "" TARGET_FMT_plx "" %08x\n"", addr, val);

    saddr = (addr & TIMER_MAXADDR) >> 2;

    switch (saddr) {

    case TIMER_LIMIT:

        if (slavio_timer_is_user(s)) {

            // set user counter MSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset\n"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else {

            // set limit, reset counter

            qemu_irq_lower(s->irq);

            s->limit = val & TIMER_MAX_COUNT32;

            if (!s->limit)

                s->limit = TIMER_MAX_COUNT32;

            ptimer_set_limit(s->timer, s->limit >> 9, 1);

        }

        break;

    case TIMER_COUNTER:

        if (slavio_timer_is_user(s)) {

            // set user counter LSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset\n"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else

            DPRINTF(""not user timer\n"");

        break;

    case TIMER_COUNTER_NORST:

        // set limit without resetting counter

        s->limit = val & TIMER_MAX_COUNT32;

        if (!s->limit)

            s->limit = TIMER_MAX_COUNT32;

        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);

        break;

    case TIMER_STATUS:

        if (slavio_timer_is_user(s)) {

            // start/stop user counter

            if ((val & 1) && !s->running) {

                DPRINTF(""processor %d user timer started\n"", s->slave_index);

                ptimer_run(s->timer, 0);

                s->running = 1;

            } else if (!(val & 1) && s->running) {

                DPRINTF(""processor %d user timer stopped\n"", s->slave_index);

                ptimer_stop(s->timer);

                s->running = 0;

            }

        }

        break;

    case TIMER_MODE:

        if (s->master == NULL) {

            unsigned int i;



            for (i = 0; i < s->num_slaves; i++) {

                if (val & (1 << i)) {

                    qemu_irq_lower(s->slave[i]->irq);

                    s->slave[i]->limit = -1ULL;

                }

                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {

                    ptimer_stop(s->slave[i]->timer);

                    ptimer_set_limit(s->slave[i]->timer,

                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);

                    DPRINTF(""processor %d timer changed\n"",

                            s->slave[i]->slave_index);

                    ptimer_run(s->slave[i]->timer, 0);

                }

            }

            s->slave_mode = val & ((1 << s->num_slaves) - 1);

        } else

            DPRINTF(""not system timer\n"");

        break;

    default:

        DPRINTF(""invalid write address "" TARGET_FMT_plx ""\n"", addr);

        break;

    }

}
",674,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,val,s,saddr",,,,0,,0,GA,925,0.3011929790178935,failed,
226,"void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)

{

    VGACommonState *s = opaque;

    int index;



    /* check port range access depending on color/monochrome mode */

    if (vga_ioport_invalid(s, addr)) {

        return;

    }

#ifdef DEBUG_VGA

    printf(""VGA: write addr=0x%04x data=0x%02x\n"", addr, val);

#endif



    switch(addr) {

    case VGA_ATT_W:

        if (s->ar_flip_flop == 0) {

            val &= 0x3f;

            s->ar_index = val;

        } else {

            index = s->ar_index & 0x1f;

            switch(index) {

            case VGA_ATC_PALETTE0 ... VGA_ATC_PALETTEF:

                s->ar[index] = val & 0x3f;

                break;

            case VGA_ATC_MODE:

                s->ar[index] = val & ~0x10;

                break;

            case VGA_ATC_OVERSCAN:

                s->ar[index] = val;

                break;

            case VGA_ATC_PLANE_ENABLE:

                s->ar[index] = val & ~0xc0;

                break;

            case VGA_ATC_PEL:

                s->ar[index] = val & ~0xf0;

                break;

            case VGA_ATC_COLOR_PAGE:

                s->ar[index] = val & ~0xf0;

                break;

            default:

                break;

            }

        }

        s->ar_flip_flop ^= 1;

        break;

    case VGA_MIS_W:

        s->msr = val & ~0x10;

        s->update_retrace_info(s);

        break;

    case VGA_SEQ_I:

        s->sr_index = val & 7;

        break;

    case VGA_SEQ_D:

#ifdef DEBUG_VGA_REG

        printf(""vga: write SR%x = 0x%02x\n"", s->sr_index, val);

#endif

        s->sr[s->sr_index] = val & sr_mask[s->sr_index];

        if (s->sr_index == VGA_SEQ_CLOCK_MODE) {

            s->update_retrace_info(s);

        }

        vga_update_memory_access(s);

        break;

    case VGA_PEL_IR:

        s->dac_read_index = val;

        s->dac_sub_index = 0;

        s->dac_state = 3;

        break;

    case VGA_PEL_IW:

        s->dac_write_index = val;

        s->dac_sub_index = 0;

        s->dac_state = 0;

        break;

    case VGA_PEL_D:

        s->dac_cache[s->dac_sub_index] = val;

        if (++s->dac_sub_index == 3) {

            memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);

            s->dac_sub_index = 0;

            s->dac_write_index++;

        }

        break;

    case VGA_GFX_I:

        s->gr_index = val & 0x0f;

        break;

    case VGA_GFX_D:

#ifdef DEBUG_VGA_REG

        printf(""vga: write GR%x = 0x%02x\n"", s->gr_index, val);

#endif

        s->gr[s->gr_index] = val & gr_mask[s->gr_index];

        vga_update_memory_access(s);

        break;

    case VGA_CRT_IM:

    case VGA_CRT_IC:

        s->cr_index = val;

        break;

    case VGA_CRT_DM:

    case VGA_CRT_DC:

#ifdef DEBUG_VGA_REG

        printf(""vga: write CR%x = 0x%02x\n"", s->cr_index, val);

#endif

        /* handle CR0-7 protection */

        if (s->cr[VGA_CRTC_V_SYNC_END] & VGA_CR11_LOCK_CR0_CR7) {

            if (s->cr_index <= VGA_CRTC_OVERFLOW) {

                /* can always write bit 4 of CR7 */

                if (s->cr_index == VGA_CRTC_OVERFLOW) {

                    s->cr[VGA_CRTC_OVERFLOW] =

                        (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) | (val & 0x10);

                }

                return;

            } else if ((vga_cga_hacks & VGA_CGA_HACK_FONT_HEIGHT) &&

                       !(s->sr[VGA_SEQ_CLOCK_MODE] & VGA_SR01_CHAR_CLK_8DOTS)) {

                /* extra CGA compatibility hacks (not in standard VGA) */

                if (s->cr_index == VGA_CRTC_MAX_SCAN &&

                    val == 7 &&

                    (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {

                    return;

                } else if (s->cr_index == VGA_CRTC_CURSOR_START &&

                           val == 6 &&

                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {

                    val = 0xd;

                } else if (s->cr_index == VGA_CRTC_CURSOR_END &&

                           val == 7 &&

                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {

                    val = 0xe;

                }

            }

        }

        s->cr[s->cr_index] = val;



        switch(s->cr_index) {

        case VGA_CRTC_H_TOTAL:

        case VGA_CRTC_H_SYNC_START:

        case VGA_CRTC_H_SYNC_END:

        case VGA_CRTC_V_TOTAL:

        case VGA_CRTC_OVERFLOW:

        case VGA_CRTC_V_SYNC_END:

        case VGA_CRTC_MODE:

            s->update_retrace_info(s);

            break;

        }

        break;

    case VGA_IS1_RM:

    case VGA_IS1_RC:

        s->fcr = val & 0x10;

        break;

    }

}
",903,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,val,s,index",,,,0,,0,GA,984,0.3344588120778402,failed,
227,"static av_cold int hevc_init_context(AVCodecContext *avctx)
{
    HEVCContext *s = avctx->priv_data;
    int i;
    s->avctx = avctx;
    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    if (!s->HEVClc)
        goto fail;
    s->HEVClcList[0] = s->HEVClc;
    s->sList[0] = s;
    s->cabac_state = av_malloc(HEVC_CONTEXTS);
    if (!s->cabac_state)
        goto fail;
    s->output_frame = av_frame_alloc();
    if (!s->output_frame)
        goto fail;
    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
        s->DPB[i].frame = av_frame_alloc();
        if (!s->DPB[i].frame)
            goto fail;
        s->DPB[i].tf.f = s->DPB[i].frame;
    }
    s->max_ra = INT_MAX;
    s->md5_ctx = av_md5_alloc();
    if (!s->md5_ctx)
        goto fail;
    ff_bswapdsp_init(&s->bdsp);
    s->context_initialized = 1;
    s->eos = 0;
    return 0;
fail:
    hevc_decode_free(avctx);
    return AVERROR(ENOMEM);
}",248,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,s,i",,,,0,,0,GA,615,0.1400822361310323,failed,
228,"static void mptsas_scsi_init(PCIDevice *dev, Error **errp)

{

    DeviceState *d = DEVICE(dev);

    MPTSASState *s = MPT_SAS(dev);

    Error *err = NULL;

    int ret;



    dev->config[PCI_LATENCY_TIMER] = 0;

    dev->config[PCI_INTERRUPT_PIN] = 0x01;



    if (s->msi != ON_OFF_AUTO_OFF) {

        ret = msi_init(dev, 0, 1, true, false, &err);

        /* Any error other than -ENOTSUP(board's MSI support is broken)

         * is a programming error */

        assert(!ret || ret == -ENOTSUP);

        if (ret && s->msi == ON_OFF_AUTO_ON) {

            /* Can't satisfy user's explicit msi=on request, fail */

            error_append_hint(&err, ""You have to use msi=auto (default) or ""

                    ""msi=off with this machine type.\n"");

            error_propagate(errp, err);

            s->msi_in_use = false;

            return;

        } else if (ret) {

            /* With msi=auto, we fall back to MSI off silently */

            error_free(err);

            s->msi_in_use = false;

        } else {

            s->msi_in_use = true;

        }

    }



    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,

                          ""mptsas-mmio"", 0x4000);

    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,

                          ""mptsas-io"", 256);

    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,

                          ""mptsas-diag"", 0x10000);



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);

    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |

                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);

    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |

                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);



    if (!s->sas_addr) {

        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |

                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;

        s->sas_addr |= (pci_bus_num(dev->bus) << 16);

        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);

        s->sas_addr |= PCI_FUNC(dev->devfn);

    }

    s->max_devices = MPTSAS_NUM_PORTS;



    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);



    QTAILQ_INIT(&s->pending);



    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, errp);

    }

}
",499,,LABEL_0,LABEL_0,LABEL_0,-1,"dev,errp,d,s,err,ret",,,,0,,0,GA,1121,0.30667036374409995,failed,
229,"int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,

                         int level)

{

    VDPAUHWContext *hwctx = avctx->hwaccel_context;

    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;

    VdpVideoSurfaceQueryCapabilities *surface_query_caps;

    VdpDecoderQueryCapabilities *decoder_query_caps;

    VdpDecoderCreate *create;

    void *func;

    VdpStatus status;

    VdpBool supported;

    uint32_t max_level, max_mb, max_width, max_height;

    VdpChromaType type;

    uint32_t width;

    uint32_t height;



    vdctx->width            = UINT32_MAX;

    vdctx->height           = UINT32_MAX;



    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))

        return AVERROR(ENOSYS);



    if (hwctx) {

        hwctx->reset            = 0;



        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {

            vdctx->decoder = hwctx->context.decoder;

            vdctx->render  = hwctx->context.render;

            vdctx->device  = VDP_INVALID_HANDLE;

            return 0; /* Decoder created by user */

        }



        vdctx->device           = hwctx->device;

        vdctx->get_proc_address = hwctx->get_proc_address;



        if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            level = 0;



        if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&

            type != VDP_CHROMA_TYPE_420)

            return AVERROR(ENOSYS);

    } else {

        AVHWFramesContext *frames_ctx = NULL;

        AVVDPAUDeviceContext *dev_ctx;



        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit

        // is called. This holds true as the user is not allowed to touch

        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format

        // itself also uninits before unreffing hw_frames_ctx).

        if (avctx->hw_frames_ctx) {

            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

        } else if (avctx->hw_device_ctx) {

            int ret;



            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);

            if (!avctx->hw_frames_ctx)

                return AVERROR(ENOMEM);



            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

            frames_ctx->format    = AV_PIX_FMT_VDPAU;

            frames_ctx->sw_format = avctx->sw_pix_fmt;

            frames_ctx->width     = avctx->coded_width;

            frames_ctx->height    = avctx->coded_height;



            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);

            if (ret < 0) {

                av_buffer_unref(&avctx->hw_frames_ctx);

                return ret;

            }

        }



        if (!frames_ctx) {

            av_log(avctx, AV_LOG_ERROR, ""A hardware frames context is ""

                   ""required for VDPAU decoding.\n"");

            return AVERROR(EINVAL);

        }



        dev_ctx = frames_ctx->device_ctx->hwctx;



        vdctx->device           = dev_ctx->device;

        vdctx->get_proc_address = dev_ctx->get_proc_address;



        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            level = 0;

    }



    if (level < 0)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        surface_query_caps = func;



    status = surface_query_caps(vdctx->device, type, &supported,

                                &max_width, &max_height);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    if (supported != VDP_TRUE ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        decoder_query_caps = func;



    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,

                                &max_mb, &max_width, &max_height);

#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE

    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {

        profile = VDP_DECODER_PROFILE_H264_MAIN;

        status = decoder_query_caps(vdctx->device, profile, &supported,

                                    &max_level, &max_mb,

                                    &max_width, &max_height);

    }

#endif

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);



    if (supported != VDP_TRUE || max_level < level ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        create = func;



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        vdctx->render = func;



    status = create(vdctx->device, profile, width, height, avctx->refs,

                    &vdctx->decoder);

    if (status == VDP_STATUS_OK) {

        vdctx->width  = avctx->coded_width;

        vdctx->height = avctx->coded_height;

    }



    return vdpau_error(status);

}
",882,,LABEL_0,LABEL_1,,-4,"avctx,profile,level,hwctx,vdctx,surface_query_caps,decoder_query_caps,create,func,status,supported,max_level,max_mb,max_width,max_height,type,height,frames_ctx,dev_ctx,ret",,,,0,,0,Greedy,1,0.0007485429445902507,,
230,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}
",167,,LABEL_1,LABEL_1,LABEL_1,-1,"s,crc,S,bit",,,,0,,0,GA,899,0.2195627768834432,failed,
231,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
",57,,LABEL_1,LABEL_0,,-4,"list,qdict,opts",,,,0,,0,Greedy,1,0.00046402613321940104,,
232,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)

{

    switch (size) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;

    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;

    default: abort();

    }

}
",62,,LABEL_0,LABEL_0,LABEL_0,-1,"op0,op1,size",,,,0,,0,GA,469,0.10777552525202433,failed,
233,"static av_cold int dnxhd_encode_init(AVCodecContext *avctx)

{

    DNXHDEncContext *ctx = avctx->priv_data;

    int i, index, bit_depth, ret;



    switch (avctx->pix_fmt) {

    case AV_PIX_FMT_YUV422P:

        bit_depth = 8;

        break;

    case AV_PIX_FMT_YUV422P10:

        bit_depth = 10;

        break;

    default:

        av_log(avctx, AV_LOG_ERROR,

               ""pixel format is incompatible with DNxHD\n"");

        return AVERROR(EINVAL);

    }



    ctx->cid = ff_dnxhd_find_cid(avctx, bit_depth);

    if (!ctx->cid) {

        av_log(avctx, AV_LOG_ERROR,

               ""video parameters incompatible with DNxHD\n"");

        return AVERROR(EINVAL);

    }

    av_log(avctx, AV_LOG_DEBUG, ""cid %d\n"", ctx->cid);



    index = ff_dnxhd_get_cid_table(ctx->cid);

    if (index < 0)

        return index;

    ctx->cid_table = &ff_dnxhd_cid_table[index];



    ctx->m.avctx    = avctx;

    ctx->m.mb_intra = 1;

    ctx->m.h263_aic = 1;



    avctx->bits_per_raw_sample = ctx->cid_table->bit_depth;



    ff_blockdsp_init(&ctx->bdsp, avctx);

    ff_fdctdsp_init(&ctx->m.fdsp, avctx);

    ff_mpv_idct_init(&ctx->m);

    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);

    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);

    if (!ctx->m.dct_quantize)

        ctx->m.dct_quantize = ff_dct_quantize_c;



    if (ctx->cid_table->bit_depth == 10) {

        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;

        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;

        ctx->block_width_l2     = 4;

    } else {

        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;

        ctx->block_width_l2     = 3;

    }



    if (ARCH_X86)

        ff_dnxhdenc_init_x86(ctx);



    ctx->m.mb_height = (avctx->height + 15) / 16;

    ctx->m.mb_width  = (avctx->width  + 15) / 16;



    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {

        ctx->interlaced   = 1;

        ctx->m.mb_height /= 2;

    }



    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;



#if FF_API_QUANT_BIAS

FF_DISABLE_DEPRECATION_WARNINGS

    if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&

        avctx->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)

        ctx->intra_quant_bias = avctx->intra_quant_bias;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    // XXX tune lbias/cbias

    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)

        return ret;



    /* Avid Nitris hardware decoder requires a minimum amount of padding

     * in the coding unit payload */

    if (ctx->nitris_compat)

        ctx->min_padding = 1600;



    if ((ret = dnxhd_init_vlc(ctx)) < 0)

        return ret;

    if ((ret = dnxhd_init_rc(ctx)) < 0)

        return ret;



    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,

                      ctx->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,

                      ctx->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,

                      ctx->m.mb_num * sizeof(uint16_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,

                      ctx->m.mb_num * sizeof(uint8_t), fail);



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    avctx->coded_frame->key_frame = 1;

    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    if (avctx->thread_count > MAX_THREADS) {

        av_log(avctx, AV_LOG_ERROR, ""too many threads\n"");

        return AVERROR(EINVAL);

    }



    ctx->thread[0] = ctx;

    for (i = 1; i < avctx->thread_count; i++) {

        ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));

        memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));

    }



    return 0;

fail:  // for FF_ALLOCZ_OR_GOTO

    return AVERROR(ENOMEM);

}
",802,"static av_cold int dnxhd_encode_init(AVCodecContext *avctx)

{

    DNXHDEncContext *ctx = avctx->priv_data;

    int I, index, bitalllength, ret;



    switch (avctx->pix_fmt) {

    case AV_PIX_FMT_YUV422P:

        bitalllength = 8;

        break;

    case AV_PIX_FMT_YUV422P10:

        bitalllength = 10;

        break;

    default:

        av_log(avctx, AV_LOG_ERROR,

               ""pixel format is incompatible with DNxHD
"");

        return AVERROR(EINVAL);

    }



    ctx->cid = ff_dnxhd_find_cid(avctx, bitalllength);

    if (!ctx->cid) {

        av_log(avctx, AV_LOG_ERROR,

               ""video parameters incompatible with DNxHD
"");

        return AVERROR(EINVAL);

    }

    av_log(avctx, AV_LOG_DEBUG, ""cid %d
"", ctx->cid);



    index = ff_dnxhd_get_cid_table(ctx->cid);

    if (index < 0)

        return index;

    ctx->cid_table = &ff_dnxhd_cid_table[index];



    ctx->m.avctx    = avctx;

    ctx->m.mb_intra = 1;

    ctx->m.h263_aic = 1;



    avctx->bits_per_raw_sample = ctx->cid_table->bitalllength;



    ff_blockdsp_init(&ctx->bdsp, avctx);

    ff_fdctdsp_init(&ctx->m.fdsp, avctx);

    ff_mpv_idct_init(&ctx->m);

    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);

    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);

    if (!ctx->m.dct_quantize)

        ctx->m.dct_quantize = ff_dct_quantize_c;



    if (ctx->cid_table->bitalllength == 10) {

        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;

        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;

        ctx->block_width_l2     = 4;

    } else {

        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;

        ctx->block_width_l2     = 3;

    }



    if (ARCH_X86)

        ff_dnxhdenc_init_x86(ctx);



    ctx->m.mb_height = (avctx->height + 15) / 16;

    ctx->m.mb_width  = (avctx->width  + 15) / 16;



    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {

        ctx->interlaced   = 1;

        ctx->m.mb_height /= 2;

    }



    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;



#if FF_API_QUANT_BIAS

FF_DISABLE_DEPRECATION_WARNINGS

    if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&

        avctx->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)

        ctx->intra_quant_bias = avctx->intra_quant_bias;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    // XXX tune lbias/cbias

    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)

        return ret;



    /* Avid Nitris hardware decoder requires a minimum amount of padding

     * in the coding unit payload */

    if (ctx->nitris_compat)

        ctx->min_padding = 1600;



    if ((ret = dnxhd_init_vlc(ctx)) < 0)

        return ret;

    if ((ret = dnxhd_init_rc(ctx)) < 0)

        return ret;



    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,

                      ctx->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,

                      ctx->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,

                      ctx->m.mb_num * sizeof(uint16_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,

                      ctx->m.mb_num * sizeof(uint8_t), fail);



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    avctx->coded_frame->key_frame = 1;

    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    if (avctx->thread_count > MAX_THREADS) {

        av_log(avctx, AV_LOG_ERROR, ""too many threads
"");

        return AVERROR(EINVAL);

    }



    ctx->thread[0] = ctx;

    for (I = 1; I < avctx->thread_count; I++) {

        ctx->thread[I] = av_malloc(sizeof(DNXHDEncContext));

        memcpy(ctx->thread[I], ctx, sizeof(DNXHDEncContext));

    }



    return 0;

fail:  // for FF_ALLOCZ_OR_GOTO

    return AVERROR(ENOMEM);

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,ctx,i,index,bit_depth,ret",,,,94,"avctx:avctx,ctx:ctx,i:I,index:index,bit_depth:bitalllength,ret:ret,",4,GA,379,0.11519521872202555,GA,
234,"void mpeg1_encode_mb(MpegEncContext *s,

                     DCTELEM block[6][64],

                     int motion_x, int motion_y)

{

    int i, cbp;

    const int mb_x = s->mb_x;

    const int mb_y = s->mb_y;

    const int first_mb= mb_x == s->resync_mb_x && mb_y == s->resync_mb_y;



    /* compute cbp */

    cbp = 0;

    for(i=0;i<6;i++) {

        if (s->block_last_index[i] >= 0)

            cbp |= 1 << (5 - i);

    }

    

    if (cbp == 0 && !first_mb && (mb_x != s->mb_width - 1 || (mb_y != s->mb_height - 1 && s->codec_id == CODEC_ID_MPEG1VIDEO)) && 

        ((s->pict_type == P_TYPE && s->mv_type == MV_TYPE_16X16 && (motion_x | motion_y) == 0) ||

        (s->pict_type == B_TYPE && s->mv_dir == s->last_mv_dir && (((s->mv_dir & MV_DIR_FORWARD) ? ((s->mv[0][0][0] - s->last_mv[0][0][0])|(s->mv[0][0][1] - s->last_mv[0][0][1])) : 0) |

        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {

        s->mb_skip_run++;

        s->qscale -= s->dquant;

        s->skip_count++;

        s->misc_bits++;

        s->last_bits++;

        if(s->pict_type == P_TYPE){

            s->last_mv[0][1][0]= s->last_mv[0][0][0]= 

            s->last_mv[0][1][1]= s->last_mv[0][0][1]= 0;

        }

    } else {

        if(first_mb){

            assert(s->mb_skip_run == 0);

            encode_mb_skip_run(s, s->mb_x);

        }else{

            encode_mb_skip_run(s, s->mb_skip_run);

        }

        

        if (s->pict_type == I_TYPE) {

            if(s->dquant && cbp){

                put_mb_modes(s, 2, 1, 0, 0); /* macroblock_type : macroblock_quant = 1 */

                put_bits(&s->pb, 5, s->qscale);

            }else{

                put_mb_modes(s, 1, 1, 0, 0); /* macroblock_type : macroblock_quant = 0 */

                s->qscale -= s->dquant;

            }

            s->misc_bits+= get_bits_diff(s);

            s->i_count++;

        } else if (s->mb_intra) {

            if(s->dquant && cbp){

                put_mb_modes(s, 6, 0x01, 0, 0);

                put_bits(&s->pb, 5, s->qscale);

            }else{

                put_mb_modes(s, 5, 0x03, 0, 0);

                s->qscale -= s->dquant;

            }

            s->misc_bits+= get_bits_diff(s);

            s->i_count++;

            memset(s->last_mv, 0, sizeof(s->last_mv));

        } else if (s->pict_type == P_TYPE) { 

            if(s->mv_type == MV_TYPE_16X16){

                if (cbp != 0) {

                    if ((motion_x|motion_y) == 0) {

                        if(s->dquant){

                            put_mb_modes(s, 5, 1, 0, 0); /* macroblock_pattern & quant */

                            put_bits(&s->pb, 5, s->qscale);

                        }else{

                            put_mb_modes(s, 2, 1, 0, 0); /* macroblock_pattern only */

                        }

                        s->misc_bits+= get_bits_diff(s);

                    } else {

                        if(s->dquant){

                            put_mb_modes(s, 5, 2, 1, 0); /* motion + cbp */

                            put_bits(&s->pb, 5, s->qscale);

                        }else{

                            put_mb_modes(s, 1, 1, 1, 0); /* motion + cbp */

                        }

                        s->misc_bits+= get_bits_diff(s);

                        mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added

                        mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added

                        s->mv_bits+= get_bits_diff(s);

                    }

                } else {

                    put_bits(&s->pb, 3, 1); /* motion only */

                    if (!s->frame_pred_frame_dct)

                        put_bits(&s->pb, 2, 2); /* motion_type: frame */

                    s->misc_bits+= get_bits_diff(s);

                    mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added

                    mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added

                    s->qscale -= s->dquant;

                    s->mv_bits+= get_bits_diff(s);

                }

                s->last_mv[0][1][0]= s->last_mv[0][0][0]= motion_x;

                s->last_mv[0][1][1]= s->last_mv[0][0][1]= motion_y;

            }else{

                assert(!s->frame_pred_frame_dct && s->mv_type == MV_TYPE_FIELD);



                if (cbp) {

                    if(s->dquant){

                        put_mb_modes(s, 5, 2, 1, 1); /* motion + cbp */

                        put_bits(&s->pb, 5, s->qscale);

                    }else{

                        put_mb_modes(s, 1, 1, 1, 1); /* motion + cbp */

                    }

                } else {

                    put_bits(&s->pb, 3, 1); /* motion only */

                    put_bits(&s->pb, 2, 1); /* motion_type: field */

                    s->qscale -= s->dquant;

                }

                s->misc_bits+= get_bits_diff(s);

                for(i=0; i<2; i++){

                    put_bits(&s->pb, 1, s->field_select[0][i]);

                    mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);

                    mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);

                    s->last_mv[0][i][0]=   s->mv[0][i][0];

                    s->last_mv[0][i][1]= 2*s->mv[0][i][1];

                }

                s->mv_bits+= get_bits_diff(s);

            }

            if(cbp)

                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);

            s->f_count++;

        } else{  

            static const int mb_type_len[4]={0,3,4,2}; //bak,for,bi



            if(s->mv_type == MV_TYPE_16X16){

                if (cbp){    // With coded bloc pattern

                    if (s->dquant) {

                        if(s->mv_dir == MV_DIR_FORWARD)

                            put_mb_modes(s, 6, 3, 1, 0);

                        else

                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 0);

                        put_bits(&s->pb, 5, s->qscale);

                    } else {

                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 0);

                    }

                }else{    // No coded bloc pattern

                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);

                    if (!s->frame_pred_frame_dct)

                        put_bits(&s->pb, 2, 2); /* motion_type: frame */

                    s->qscale -= s->dquant;

                }

                s->misc_bits += get_bits_diff(s);

                if (s->mv_dir&MV_DIR_FORWARD){

                    mpeg1_encode_motion(s, s->mv[0][0][0] - s->last_mv[0][0][0], s->f_code); 

                    mpeg1_encode_motion(s, s->mv[0][0][1] - s->last_mv[0][0][1], s->f_code); 

                    s->last_mv[0][0][0]=s->last_mv[0][1][0]= s->mv[0][0][0];

                    s->last_mv[0][0][1]=s->last_mv[0][1][1]= s->mv[0][0][1];

                    s->f_count++;

                }

                if (s->mv_dir&MV_DIR_BACKWARD){

                    mpeg1_encode_motion(s, s->mv[1][0][0] - s->last_mv[1][0][0], s->b_code); 

                    mpeg1_encode_motion(s, s->mv[1][0][1] - s->last_mv[1][0][1], s->b_code); 

                    s->last_mv[1][0][0]=s->last_mv[1][1][0]= s->mv[1][0][0];

                    s->last_mv[1][0][1]=s->last_mv[1][1][1]= s->mv[1][0][1];

                    s->b_count++;

                }

            }else{

                assert(s->mv_type == MV_TYPE_FIELD);

                assert(!s->frame_pred_frame_dct);

                if (cbp){    // With coded bloc pattern

                    if (s->dquant) {

                        if(s->mv_dir == MV_DIR_FORWARD)

                            put_mb_modes(s, 6, 3, 1, 1);

                        else

                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 1);

                        put_bits(&s->pb, 5, s->qscale);

                    } else {

                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 1);

                    }

                }else{    // No coded bloc pattern

                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);

                    put_bits(&s->pb, 2, 1); /* motion_type: field */

                    s->qscale -= s->dquant;

                }

                s->misc_bits += get_bits_diff(s);

                if (s->mv_dir&MV_DIR_FORWARD){

                    for(i=0; i<2; i++){

                        put_bits(&s->pb, 1, s->field_select[0][i]);

                        mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);

                        mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);

                        s->last_mv[0][i][0]=   s->mv[0][i][0];

                        s->last_mv[0][i][1]= 2*s->mv[0][i][1];

                    }

                    s->f_count++;

                }

                if (s->mv_dir&MV_DIR_BACKWARD){

                    for(i=0; i<2; i++){

                        put_bits(&s->pb, 1, s->field_select[1][i]);

                        mpeg1_encode_motion(s, s->mv[1][i][0] -  s->last_mv[1][i][0]    , s->b_code);

                        mpeg1_encode_motion(s, s->mv[1][i][1] - (s->last_mv[1][i][1]>>1), s->b_code);

                        s->last_mv[1][i][0]=   s->mv[1][i][0];

                        s->last_mv[1][i][1]= 2*s->mv[1][i][1];

                    }

                    s->b_count++;

                }

            }

            s->mv_bits += get_bits_diff(s);

            if(cbp)

                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);

        }

        for(i=0;i<6;i++) {

            if (cbp & (1 << (5 - i))) {

                mpeg1_encode_block(s, block[i], i);

            }

        }

        s->mb_skip_run = 0;

        if(s->mb_intra)

            s->i_tex_bits+= get_bits_diff(s);

        else

            s->p_tex_bits+= get_bits_diff(s);

    }

}
",2747,,LABEL_0,LABEL_0,LABEL_0,-1,"s,block,motion_x,motion_y,i,cbp,mb_skip_run,skip_count,misc_bits,last_bits",,,,0,,0,GA,1895,1.0798972249031067,failed,
235,"static av_cold int vp3_decode_end(AVCodecContext *avctx)

{

    Vp3DecodeContext *s = avctx->priv_data;

    int i;



    if (avctx->is_copy && !s->current_frame.data[0])

        return 0;



    av_free(s->superblock_coding);

    av_free(s->all_fragments);

    av_free(s->coded_fragment_list[0]);

    av_free(s->dct_tokens_base);

    av_free(s->superblock_fragments);

    av_free(s->macroblock_coding);

    av_free(s->motion_val[0]);

    av_free(s->motion_val[1]);

    av_free(s->edge_emu_buffer);



    if (avctx->is_copy) return 0;



    for (i = 0; i < 16; i++) {

        free_vlc(&s->dc_vlc[i]);

        free_vlc(&s->ac_vlc_1[i]);

        free_vlc(&s->ac_vlc_2[i]);

        free_vlc(&s->ac_vlc_3[i]);

        free_vlc(&s->ac_vlc_4[i]);

    }



    free_vlc(&s->superblock_run_length_vlc);

    free_vlc(&s->fragment_run_length_vlc);

    free_vlc(&s->mode_code_vlc);

    free_vlc(&s->motion_vector_vlc);



    /* release all frames */

    if (s->golden_frame.data[0])

        ff_thread_release_buffer(avctx, &s->golden_frame);

    if (s->last_frame.data[0] && s->last_frame.type != FF_BUFFER_TYPE_COPY)

        ff_thread_release_buffer(avctx, &s->last_frame);

    /* no need to release the current_frame since it will always be pointing

     * to the same frame as either the golden or last frame */



    return 0;

}
",343,,LABEL_1,LABEL_0,,-4,"avctx,s,i",,,,0,,0,Greedy,1,0.0006242434183756511,,
236,"static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,

                               unsigned size)

{

    PXA2xxState *s = (PXA2xxState *) opaque;



    switch (addr) {

    case MDCNFG ... SA1110:

        if ((addr & 3) == 0)

            return s->mm_regs[addr >> 2];



    default:

        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);

        break;

    }

    return 0;

}
",76,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,size,s",,,,0,,0,GA,769,0.19367221593856812,failed,
237,"int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)

{

    int ret;



    av_log(s->avctx, AV_LOG_DEBUG, ""reinit context\n"");



    /* 1. streamoff */

    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);

    if (ret)

        av_log(s->avctx, AV_LOG_ERROR, ""capture VIDIOC_STREAMOFF\n"");



    /* 2. unmap the capture buffers (v4l2 and ffmpeg):

     *    we must wait for all references to be released before being allowed

     *    to queue new buffers.

     */

    av_log(s->avctx, AV_LOG_DEBUG, ""waiting for user to release AVBufferRefs\n"");

    if (atomic_load(&s->refcount))

        while(sem_wait(&s->refsync) == -1 && errno == EINTR);



    ff_v4l2_context_release(&s->capture);



    /* 3. get the new capture format */

    ret = ff_v4l2_context_get_format(&s->capture);

    if (ret) {

        av_log(s->avctx, AV_LOG_ERROR, ""query the new capture format\n"");

        return ret;

    }



    /* 4. set the capture format */

    ret = ff_v4l2_context_set_format(&s->capture);

    if (ret) {

        av_log(s->avctx, AV_LOG_ERROR, ""setting capture format\n"");

        return ret;

    }



    /* 5. complete reinit */

    sem_destroy(&s->refsync);

    sem_init(&s->refsync, 0, 0);

    s->draining = 0;

    s->reinit = 0;



    return 0;

}
",296,,LABEL_1,LABEL_0,,-4,"s,ret",,,,0,,0,Greedy,1,0.0006251096725463867,,
238,"static int opt_preset(const char *opt, const char *arg)

{

    FILE *f=NULL;

    char filename[1000], tmp[1000], tmp2[1000], line[1000];

    int i;

    const char *base[3]= { getenv(""HOME""),

                           ""/usr/local/share"",

                           ""/usr/share"",

                         };



    for(i=!base[0]; i<3 && !f; i++){

        snprintf(filename, sizeof(filename), ""%s/%sffmpeg/%s.ffpreset"", base[i], i ? """" : ""."", arg);

        f= fopen(filename, ""r"");

        if(!f){

            char *codec_name= *opt == 'v' ? video_codec_name :

                              *opt == 'a' ? audio_codec_name :

                                            subtitle_codec_name;

            snprintf(filename, sizeof(filename), ""%s/%sffmpeg/%s-%s.ffpreset"", base[i],  i ? """" : ""."", codec_name, arg);

            f= fopen(filename, ""r"");

        }

    }

    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||

              is_dos_path(arg))){

        snprintf(filename, sizeof(filename), arg);

        f= fopen(filename, ""r"");

    }



    if(!f){

        fprintf(stderr, ""File for preset '%s' not found\n"", arg);

        av_exit(1);

    }



    while(!feof(f)){

        int e= fscanf(f, ""%999[^\n]\n"", line) - 1;

        if(line[0] == '#' && !e)

            continue;

        e|= sscanf(line, ""%999[^=]=%999[^\n]\n"", tmp, tmp2) - 2;

        if(e){

            fprintf(stderr, ""%s: Preset file invalid\n"", filename);

            av_exit(1);

        }

        if(!strcmp(tmp, ""acodec"")){

            opt_audio_codec(tmp2);

        }else if(!strcmp(tmp, ""vcodec"")){

            opt_video_codec(tmp2);

        }else if(!strcmp(tmp, ""scodec"")){

            opt_subtitle_codec(tmp2);

        }else if(opt_default(tmp, tmp2) < 0){

            fprintf(stderr, ""%s: Invalid option or argument: %s=%s\n"", filename, tmp, tmp2);

            av_exit(1);

        }

    }



    fclose(f);



    return 0;

}
",480,"static int opt_preset(const char *oc, const char *arg)

{

    FILE *ff=NULL;

    char frame[1000], kk[1000], tmp2[1000], line[1000];

    int k;

    const char *base[3]= { getenv(""HOME""),

                           ""/usr/local/share"",

                           ""/usr/share"",

                         };



    for(k=!base[0]; k<3 && !f; k++){

        snprintf(frame, sizeof(frame), ""%s/%sffmpeg/%s.ffpreset"", base[k], k ? """" : ""."", arg);

        ff= fopen(frame, ""r"");

        if(!f){

            char codec_namee= *oc == 'v' ? video_codec_name :

                              *oc == 'a' ? audio_codec_name :

                                            subtitle_codec_name;

            snprintf(frame, sizeof(frame), ""%s/%sffmpeg/%s-%s.ffpreset"", base[k],  k ? """" : ""."", codec_name, arg);

            ff= fopen(frame, ""r"");

        }

    }

    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||

              is_dos_path(arg))){

        snprintf(frame, sizeof(frame), arg);

        ff= fopen(frame, ""r"");

    }



    if(!f){

        fprintf(stderr, ""File for preset '%s' not found
"", arg);

        av_exit(1);

    }



    while(!feof(ff)){

        int e= fscanf(ff, ""%999[^
]
"", line) - 1;

        if(line[0] == '#' && !e)

            continue;

        e|= sscanf(line, ""%999[^=]=%999[^
]
"", kk, tmp2) - 2;

        if(e){

            fprintf(stderr, ""%s: Preset file invalid
"", frame);

            av_exit(1);

        }

        if(!strcmp(kk, ""acodec"")){

            opt_audio_codec(tmp2);

        }else if(!strcmp(kk, ""vcodec"")){

            opt_video_codec(tmp2);

        }else if(!strcmp(kk, ""scodec"")){

            opt_subtitle_codec(tmp2);

        }else if(opt_default(kk, tmp2) < 0){

            fprintf(stderr, ""%s: Invalid option or argument: %s=%s
"", frame, kk, tmp2);

            av_exit(1);

        }

    }



    fclose(ff);



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"opt,arg,f,filename,tmp,tmp2,line,i,base,codec_name",,,,25,"opt:oc,arg:arg,f:ff,filename:frame,tmp:kk,tmp2:tmp2,line:line,i:k,base:base,codec_name:codec_name,",5,GA,589,0.1669430096944173,GA,
239,"static int parse_adaptation_sets(AVFormatContext *s)

{

    WebMDashMuxContext *w = s->priv_data;

    char *p = w->adaptation_sets;

    char *q;

    enum { new_set, parsed_id, parsing_streams } state;

    if (!w->adaptation_sets) {

        av_log(s, AV_LOG_ERROR, ""The 'adaptation_sets' option must be set.\n"");

        return AVERROR(EINVAL);

    }

    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on

    state = new_set;

    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {

        if (*p == ' ')

            continue;

        else if (state == new_set && !strncmp(p, ""id="", 3)) {

            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));

            if (mem == NULL)

                return AVERROR(ENOMEM);

            w->as = mem;

            ++w->nb_as;

            w->as[w->nb_as - 1].nb_streams = 0;

            w->as[w->nb_as - 1].streams = NULL;

            p += 3; // consume ""id=""

            q = w->as[w->nb_as - 1].id;

            while (*p != ',') *q++ = *p++;

            *q = 0;

            p++;

            state = parsed_id;

        } else if (state == parsed_id && !strncmp(p, ""streams="", 8)) {

            p += 8; // consume ""streams=""

            state = parsing_streams;

        } else if (state == parsing_streams) {

            struct AdaptationSet *as = &w->as[w->nb_as - 1];

            q = p;

            while (*q != '\0' && *q != ',' && *q != ' ') q++;

            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);

            if (as->streams == NULL)

                return AVERROR(ENOMEM);

            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);

            if (as->streams[as->nb_streams - 1] < 0) return -1;

            if (*q == '\0') break;

            if (*q == ' ') state = new_set;

            p = ++q;

        } else {

            return -1;

        }

    }

    return 0;

}
",512,"static int parse_adaptation_sets(AVFormatContext *s)

{

    WebMDashMuxContext *w = s->priv_data;

    char *api = w->adaptation_sets;

    char *q;

    enum { new_set, parsed_id, parsing_streams } state;

    if (!w->adaptation_sets) {

        av_log(s, AV_LOG_ERROR, ""The 'adaptation_sets' option must be set.
"");

        return AVERROR(EINVAL);

    }

    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on

    state = new_set;

    while (api < w->adaptation_sets + strlen(w->adaptation_sets)) {

        if (*api == ' ')

            continue;

        else if (ststate= new_set && !strncmp(api, ""id="", 3)) {

            void *rom = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));

            if (rom == NULL)

                return AVERROR(ENOMEM);

            w->as = rom;

            ++w->nb_as;

            w->as[w->nb_as - 1].nb_streams = 0;

            w->as[w->nb_as - 1].streams = NULL;

            api += 3; // consume ""id=""

            q = w->as[w->nb_as - 1].id;

            while (*api != ',') *q+q = *api++;

            *q = 0;

            api++;

            state = parsed_id;

        } else if (ststate= parsed_id && !strncmp(api, ""streams="", 8)) {

            api += 8; // consume ""streams=""

            state = parsing_streams;

        } else if (state == parsing_streams) {

            struct AdaptationSet *as = &w->as[w->nb_as - 1];

            q q api;

            while (*q != '\0' && *q != ',' && *q != ' ') q++;

            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);

            if (as->streams == NULL)

                return AVERROR(ENOMEM);

            as->asreams[as->as_streams - 1] = to_integer(api, q q api + 1);

            if (as->streams[as->nb_streams - 1] < 0) return -1;

            if (*q == '\0') break;

            if (*q == ' ') state = new_set;

            api = ++q;

        } else {

            return -1;

        }

    }

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,w,p,q,state,mem,as,nb_as",,,,64,"s:s,w:w,p:api,q:q,state:state,mem:rom,as:as,nb_as:nb_as,",6,GA,532,0.15639991362889608,GA,
240,"static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)

{

    gen_read_xer(cpu_gpr[gprn]);

}
",24,,LABEL_1,LABEL_0,,-4,"ctx,gprn,sprn",,,,0,,0,Greedy,1,0.0004382769266764323,,
241,"static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)

{

    if (pkt->size >= 7 &&

        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&

        !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {

        uint8_t desc[256];

        int score      = AVPROBE_SCORE_EXTENSION, ret;

        AVIStream *ast = st->priv_data;

        AVInputFormat *sub_demuxer;

        AVRational time_base;

        int size;

        AVIOContext *pb = avio_alloc_context(pkt->data + 7,

                                             pkt->size - 7,

                                             0, NULL, NULL, NULL, NULL);

        AVProbeData pd;

        unsigned int desc_len = avio_rl32(pb);



        if (desc_len > pb->buf_end - pb->buf_ptr)

            goto error;



        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));

        avio_skip(pb, desc_len - ret);

        if (*desc)

            av_dict_set(&st->metadata, ""title"", desc, 0);



        avio_rl16(pb);   /* flags? */

        avio_rl32(pb);   /* data size */



        size = pb->buf_end - pb->buf_ptr;

        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),

                             .buf_size = size };

        if (!pd.buf)

            goto error;

        memcpy(pd.buf, pb->buf_ptr, size);

        sub_demuxer = av_probe_input_format2(&pd, 1, &score);

        av_freep(&pd.buf);

        if (!sub_demuxer)

            goto error;



        if (!(ast->sub_ctx = avformat_alloc_context()))

            goto error;



        ast->sub_ctx->pb = pb;



        av_assert0(!ast->sub_ctx->codec_whitelist && !ast->sub_ctx->format_whitelist);

        ast->sub_ctx-> codec_whitelist = av_strdup(s->codec_whitelist);

        ast->sub_ctx->format_whitelist = av_strdup(s->format_whitelist);



        if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {

            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);

            *st->codec = *ast->sub_ctx->streams[0]->codec;

            ast->sub_ctx->streams[0]->codec->extradata = NULL;

            time_base = ast->sub_ctx->streams[0]->time_base;

            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);

        }

        ast->sub_buffer = pkt->data;

        memset(pkt, 0, sizeof(*pkt));

        return 1;



error:

        av_freep(&pb);

    }

    return 0;

}
",533,"static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *packet)

{

    if (packet->sh >= 7 &&

        packet->sh < INT_MAX - AVPROBE_PADDING_SIZE &&

        !strcmp(packet->data, ""GAB2"") && AV_RL16(packet->data + 5) == 2) {

        uint8_t doc[256];

        int score      = AVPROBE_SCORE_EXTENSION, ret;

        AVIStream *ast = st->priv_data;

        AVInputFormat *sub_demuxer;

        AVRational time_base;

        int sh;

        AVIOContext *pb bfavio_alloc_context(packet->data + 7,

                                             packet->sh - 7,

                                             0, NULL, NULL, NULL, NULL);

        AVProbeData pd;

        unsigned int desc_len = avio_rl32(bf);



        if (desc_len > bf->buf_end - bf->buf_ptr)

            goto error;



      retet = avio_get_str16lbfpb, desc_len, doc, sizeof(doc));

        avio_skip(bf, desc_len - ret);

        if (*doc)

            av_dict_set(&st->metadata, ""title"", doc, 0);



        avio_rl16(bf);   /* flags? */

        avio_rl3bfpb);   /* data sh */



        sh = bf->buf_end - bf->buf_ptr;

      pdpd = (AVProbeData) { .buf      = av_mallocz(sh + AVPROBE_PADDING_SIZE),

                             .buf_size = sh };

        if (!pd.buf)

            goto error;

        memcppdpd.bufbfpb->buf_ptr, sh);

        sub_demuxer = av_probe_input_format2(&pd, 1, &score);

        av_freep(&pd.buf);

        if (!sub_demuxer)

            goto error;



        if (!(ast->sub_ctx = avformat_alloc_context()))

            goto error;



        ast->sub_ctx->bf = bf;



        av_assert0(!ast->sub_ctx->codec_whitelist && !ast->sub_ctx->format_whitelist);

        ast->sub_ctx-> codec_whitelist = av_strdup(s->codec_whitelist);

        ast->sub_ctx->format_whitelist = av_strdup(s->format_whitelist);



        if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {

            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);

            *st->codec = *ast->sub_ctx->streams[0]->codec;

            ast->sub_ctx->streams[0]->codec->extradata = NULL;

            time_base = ast->sub_ctx->streams[0]->time_base;

            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);

        }

        astastub_buffer = packet->data;

        memset(packet, 0, sizeof(*packet));

        return 1;



error:

        av_freep(&bf);

    }

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,st,pkt,desc,ret,ast,sub_demuxer,time_base,size,pb,pd",,,,38,"s:s,st:st,pkt:packet,desc:doc,ret:ret,ast:ast,sub_demuxer:sub_demuxer,time_base:time_base,size:sh,pb:bf,pd:pd,",7,GA,647,0.19795551697413127,GA,
242,"static int nbd_negotiate_options(NBDClient *client, Error **errp)

{

    uint32_t flags;

    bool fixedNewstyle = false;



    /* Client sends:

        [ 0 ..   3]   client flags



        [ 0 ..   7]   NBD_OPTS_MAGIC

        [ 8 ..  11]   NBD option

        [12 ..  15]   Data length

        ...           Rest of request



        [ 0 ..   7]   NBD_OPTS_MAGIC

        [ 8 ..  11]   Second NBD option

        [12 ..  15]   Data length

        ...           Rest of request

    */



    if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) {

        error_prepend(errp, ""read failed: "");

        return -EIO;

    }

    trace_nbd_negotiate_options_flags();

    be32_to_cpus(&flags);

    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {

        trace_nbd_negotiate_options_newstyle();

        fixedNewstyle = true;

        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;

    }

    if (flags & NBD_FLAG_C_NO_ZEROES) {

        trace_nbd_negotiate_options_no_zeroes();

        client->no_zeroes = true;

        flags &= ~NBD_FLAG_C_NO_ZEROES;

    }

    if (flags != 0) {

        error_setg(errp, ""Unknown client flags 0x%"" PRIx32 "" received"", flags);

        return -EIO;

    }



    while (1) {

        int ret;

        uint32_t option, length;

        uint64_t magic;



        if (nbd_read(client->ioc, &magic, sizeof(magic), errp) < 0) {

            error_prepend(errp, ""read failed: "");

            return -EINVAL;

        }

        magic = be64_to_cpu(magic);

        trace_nbd_negotiate_options_check_magic(magic);

        if (magic != NBD_OPTS_MAGIC) {

            error_setg(errp, ""Bad magic received"");

            return -EINVAL;

        }



        if (nbd_read(client->ioc, &option,

                     sizeof(option), errp) < 0) {

            error_prepend(errp, ""read failed: "");

            return -EINVAL;

        }

        option = be32_to_cpu(option);



        if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) {

            error_prepend(errp, ""read failed: "");

            return -EINVAL;

        }

        length = be32_to_cpu(length);



        trace_nbd_negotiate_options_check_option(option);

        if (client->tlscreds &&

            client->ioc == (QIOChannel *)client->sioc) {

            QIOChannel *tioc;

            if (!fixedNewstyle) {

                error_setg(errp, ""Unsupported option 0x%"" PRIx32, option);

                return -EINVAL;

            }

            switch (option) {

            case NBD_OPT_STARTTLS:

                tioc = nbd_negotiate_handle_starttls(client, length, errp);

                if (!tioc) {

                    return -EIO;

                }

                object_unref(OBJECT(client->ioc));

                client->ioc = QIO_CHANNEL(tioc);

                break;



            case NBD_OPT_EXPORT_NAME:

                /* No way to return an error to client, so drop connection */

                error_setg(errp, ""Option 0x%x not permitted before TLS"",

                           option);

                return -EINVAL;



            default:

                if (nbd_drop(client->ioc, length, errp) < 0) {

                    return -EIO;

                }

                ret = nbd_negotiate_send_rep_err(client->ioc,

                                                 NBD_REP_ERR_TLS_REQD,

                                                 option, errp,

                                                 ""Option 0x%"" PRIx32

                                                 ""not permitted before TLS"",

                                                 option);

                if (ret < 0) {

                    return ret;

                }

                /* Let the client keep trying, unless they asked to

                 * quit. In this mode, we've already sent an error, so

                 * we can't ack the abort.  */

                if (option == NBD_OPT_ABORT) {

                    return 1;

                }

                break;

            }

        } else if (fixedNewstyle) {

            switch (option) {

            case NBD_OPT_LIST:

                ret = nbd_negotiate_handle_list(client, length, errp);

                if (ret < 0) {

                    return ret;

                }

                break;



            case NBD_OPT_ABORT:

                /* NBD spec says we must try to reply before

                 * disconnecting, but that we must also tolerate

                 * guests that don't wait for our reply. */

                nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL);

                return 1;



            case NBD_OPT_EXPORT_NAME:

                return nbd_negotiate_handle_export_name(client, length, errp);



            case NBD_OPT_STARTTLS:

                if (nbd_drop(client->ioc, length, errp) < 0) {

                    return -EIO;

                }

                if (client->tlscreds) {

                    ret = nbd_negotiate_send_rep_err(client->ioc,

                                                     NBD_REP_ERR_INVALID,

                                                     option, errp,

                                                     ""TLS already enabled"");

                } else {

                    ret = nbd_negotiate_send_rep_err(client->ioc,

                                                     NBD_REP_ERR_POLICY,

                                                     option, errp,

                                                     ""TLS not configured"");

                }

                if (ret < 0) {

                    return ret;

                }

                break;

            default:

                if (nbd_drop(client->ioc, length, errp) < 0) {

                    return -EIO;

                }

                ret = nbd_negotiate_send_rep_err(client->ioc,

                                                 NBD_REP_ERR_UNSUP,

                                                 option, errp,

                                                 ""Unsupported option 0x%""

                                                 PRIx32,

                                                 option);

                if (ret < 0) {

                    return ret;

                }

                break;

            }

        } else {

            /*

             * If broken new-style we should drop the connection

             * for anything except NBD_OPT_EXPORT_NAME

             */

            switch (option) {

            case NBD_OPT_EXPORT_NAME:

                return nbd_negotiate_handle_export_name(client, length, errp);



            default:

                error_setg(errp, ""Unsupported option 0x%"" PRIx32, option);

                return -EINVAL;

            }

        }

    }

}
",929,,LABEL_0,LABEL_0,LABEL_0,-1,"client,errp,flags,ret,option,length,magic",,,,0,,0,GA,1571,0.6373690803845723,failed,
243,"static TranslationBlock *tb_alloc(target_ulong pc)

{

    TranslationBlock *tb;

    TBContext *ctx;



    assert_tb_locked();



    tb = tcg_tb_alloc(&tcg_ctx);

    if (unlikely(tb == NULL)) {

        return NULL;

    }

    ctx = &tcg_ctx.tb_ctx;

    if (unlikely(ctx->nb_tbs == ctx->tbs_size)) {

        ctx->tbs_size *= 2;

        ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size);

    }

    ctx->tbs[ctx->nb_tbs++] = tb;

    tb->pc = pc;

    tb->cflags = 0;

    tb->invalid = false;

    return tb;

}
",135,"static TranslationBlock *tb_alloc(target_ulong anc)

{

    TranslationBlock *Tbs;

    TBContext *config;



    assert_tb_locked();



    Tbs = tcg_tb_alloc(&tcg_ctx);

    if (unlikely(Tbs == NULL)) {

        return NULL;

    }

    config = &tcg_ctx.tb_ctx;

    if (unlikely(config->nb_tbs == config->tbs_size)) {

        config->tbs_size *= 2;

        config->tbs = g_renew(TranslationBlock *, config->tbs, config->tbs_size);

    }

    cconfig>tbs[cconfig>nb_tbs++] = Tbs;

    tbTbsanc = anc;

    Tbs->cflags = 0;

    Tbs->invalid = false;

    return Tbs;

}
",LABEL_0,LABEL_0,LABEL_1,1,"pc,tb,ctx",,,,0,"pc:anc,tb:Tbs,ctx:config,",0,GA,425,0.10271327098210653,GA,
244,"void qemu_ram_remap(ram_addr_t addr, ram_addr_t length)

{

    RAMBlock *block;

    ram_addr_t offset;

    int flags;

    void *area, *vaddr;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        offset = addr - block->offset;

        if (offset < block->length) {

            vaddr = block->host + offset;

            if (block->flags & RAM_PREALLOC_MASK) {

                ;

            } else if (xen_enabled()) {

                abort();

            } else {

                flags = MAP_FIXED;

                munmap(vaddr, length);

                if (mem_path) {

#if defined(__linux__) && !defined(TARGET_S390X)

                    if (block->fd) {

#ifdef MAP_POPULATE

                        flags |= mem_prealloc ? MAP_POPULATE | MAP_SHARED :

                            MAP_PRIVATE;

#else

                        flags |= MAP_PRIVATE;

#endif

                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,

                                    flags, block->fd, offset);

                    } else {

                        flags |= MAP_PRIVATE | MAP_ANONYMOUS;

                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,

                                    flags, -1, 0);

                    }

#else

                    abort();

#endif

                } else {

#if defined(TARGET_S390X) && defined(CONFIG_KVM)

                    flags |= MAP_SHARED | MAP_ANONYMOUS;

                    area = mmap(vaddr, length, PROT_EXEC|PROT_READ|PROT_WRITE,

                                flags, -1, 0);

#else

                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;

                    area = mmap(vaddr, length, PROT_READ | PROT_WRITE,

                                flags, -1, 0);

#endif

                }

                if (area != vaddr) {

                    fprintf(stderr, ""Could not remap addr: ""

                            RAM_ADDR_FMT ""@"" RAM_ADDR_FMT ""\n"",

                            length, addr);

                    exit(1);

                }

                memory_try_enable_merging(vaddr, length);

                qemu_ram_setup_dump(vaddr, length);

            }

            return;

        }

    }

}
",295,"void qemu_ram_remap(ram_addr_t addr, ram_addr_t duration)

{

    RAMBlock *block;

    ram_addr_t host;

    int flags;

    void *area, *wenter;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        host = addr - block->host;

        if (ofhost blblockduration) {

          wenterdr = block->host + host;

            if (block->flags & RAM_PREALLOC_MASK) {

                ;

            } else if (xen_enabled()) {

                abort();

            } else {

                flags = MAP_FIXED;

                munmap(vawenterduration);

                if (mem_path) {

#if defined(__linux__) && !defined(TARGET_S390X)

                    if (block->fd) {

#ifdef MAP_POPULATE

                        flags |= mem_prealloc ? MAP_POPULATE | MAP_SHARED :

                            MAP_PRIVATE;

#else

                        flags |= MAP_PRIVATE;

#endif

                        ararea mmap(vawenterduration, PROT_READ | PROT_WRITE,

                                  flagsgs, block->fd, host);

                    } else {

                        flags |= MAP_PRIVATE | MAP_ANONYMOUS;

                        ararea mmap(vawenterduration, PROT_READ | PROT_WRITE,

                                    flags, -1, 0);

                    }

#else

                    abort();

#endif

                } else {

#if defined(TARGET_S390X) && defined(CONFIG_KVM)

                    flags |= MAP_SHARED | MAP_ANONYMOUS;

                    ararea mmap(vawenterduration, PROT_EXEC|PROT_READ|PROT_WRITE,

                                flags, -1, 0);

#else

                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;

                    ararea mmap(vawenterduration, PROT_READ | PROT_WRITE,

                                flags, -1, 0);

#endif

                }

                if (area != wenter) {

                    fprintf(stderr, ""Could not remap addr: ""

                            RAM_ADDR_FMT ""@"" RAM_ADDR_FMT ""
"",

                            duration, addr);

                    exit(1);

                }

                memory_try_enable_merging(vawenterduration);

                qemu_ram_setup_dump(vawenterduration);

            }

            return;

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"addr,length,block,offset,flags,area,vaddr",,,,29,"addr:addr,length:duration,block:block,offset:host,flags:flags,area:area,vaddr:wenter,",4,GA,521,0.14039058287938436,GA,
245,"static void bdrv_put_buffer(void *opaque, const uint8_t *buf,

                            int64_t pos, int size)

{

    QEMUFileBdrv *s = opaque;

    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);

}
",48,"static void bdrv_put_buffer(void *oppya, const uint8_t *buf,

                            int64_t pad, int scale)

{

    QEMUFileBdrv ss = oppya;

    bdrv_pwrite(ss>bs, ss>base_offset + pad, buf, scale);

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,buf,pos,size,s",,,,5,"opaque:oppya,buf:buf,pos:pad,size:scale,s:s,",2,GA,219,0.050502689679463704,GA,
246,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    float aspect;



    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    s->aspect_ratio_info= get_bits(&s->gb, 4);

    if(!s->mpeg2){

        aspect= mpeg1_aspect[s->aspect_ratio_info];

        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);

    }



    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        avctx->has_b_frames= 1;

        s->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        if (s->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            avctx->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        }

        s->frame_rate = avctx->frame_rate;

        avctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_intra_matrix[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->inter_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_non_intra_matrix[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    avctx->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",886,"static int mpeg1_decode_sequence(AVCodecContext *AVcms, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = AVcms->priv_data;

    MpegEncContext *states = &s1->mpeg_enc_ctx;

    int width, density, i, va, j;

    float aspect;



    init_get_bits(&states->gb, buf, buf_size);



    width = get_bits(&states->gb, 12);

    heighdensityt_bits(&states->gb, 12);

    states->aspect_ratio_info= get_bits(&states->gb, 4);

    if(!s->mpeg2){

        aspecaspectg1_aspect[states->aspect_ratio_info];

        if(aaspect=0.0) AVcms->aspect_ratio= width/(aaspectdensity);

    }



    states->frame_rate_index = get_bits(&states->gb, 4);

    if (states->frame_rate_index == 0)

        return -1;

    states->bit_rate = get_bits(&states->gb, 18) * 400;

    if (get_bits1(&states->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || density <= 0 ||

        (width % 2) != 0 || (density % 2) != 0)

        return -1;

    if (width != states->width ||

        heighdensitytates->density) {

        /* start new mpeg1 context decoding */

        states->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(states);

        }

        states->width = width;

        states->density = density;

        AVcms->has_b_frames= 1;

        states->AVcms = AVcms;

        AVcms->width = width;

        AVcms->density = density;

        if (states->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            AVcms->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            AVcms->frame_rate = frame_rate_tab[states->frame_rate_index];

        }

        states->frame_rate = AVcms->frame_rate;

        AVcms->bit_rate = states->bit_rate;

        

        if (MPV_common_init(states) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&states->gb, 10); /* vbv_buffer_size */

    skip_bits(&states->gb, 1);



    /* get matrix */

    if (get_bits1(&states->gb)) {

        for(i=0;i<64;i++) {

            v = gvat_bits(&states->gb, 8);

            j = sjates->intra_scantable.permutated[i];

            states->intra_matrix[jj = va;

            states->chroma_intra_matrix[jj = va;

        }

#ifdef DEBUG

        dprintf(""intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", states->intra_matrix[states->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= stjtes->idct_permutation[i];

            va = ff_mpeg1_default_intra_matrix[i];

            states->intra_matrix[jj = va;

            states->chroma_intra_matrix[jj = va;

        }

    }

    if (get_bits1(&states->gb)) {

        for(i=0;i<64;i++) {

            v = gvat_bits(&states->gb, 8);

            j = sjates->intra_scantable.permutated[i];

            states->inter_matrix[jj = va;

            states->chroma_inter_matrix[jj = va;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", states->inter_matrix[states->intra_scantable.permutated[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= stjtes->idct_permutation[i];

            va = ff_mpeg1_default_non_intra_matrix[i];

            states->inter_matrix[jj = va;

            states->chroma_inter_matrix[jj = va;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    states->progressive_sequence = 1;

    states->progressive_frame = 1;

    states->picture_structure = PICT_FRAME;

    states->frame_pred_frame_dct = 1;

    states->mpeg2 = 0;

    AVcms->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,buf,buf_size,s1,s,height,i,v,j,aspect",,,,52,"avctx:AVcms,buf:buf,buf_size:buf_size,s1:s1,s:states,height:density,i:i,v:va,j:j,aspect:aspect,",6,GA,580,0.21425599654515584,GA,
247,"static int bdrv_qed_open(BlockDriverState *bs, QDict *options, int flags,

                         Error **errp)

{

    BDRVQEDState *s = bs->opaque;

    QEDHeader le_header;

    int64_t file_size;

    int ret;



    s->bs = bs;

    QSIMPLEQ_INIT(&s->allocating_write_reqs);



    ret = bdrv_pread(bs->file, 0, &le_header, sizeof(le_header));

    if (ret < 0) {

        return ret;

    }

    qed_header_le_to_cpu(&le_header, &s->header);



    if (s->header.magic != QED_MAGIC) {

        error_setg(errp, ""Image not in QED format"");

        return -EINVAL;

    }

    if (s->header.features & ~QED_FEATURE_MASK) {

        /* image uses unsupported feature bits */

        char buf[64];

        snprintf(buf, sizeof(buf), ""%"" PRIx64,

            s->header.features & ~QED_FEATURE_MASK);

        error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,

            bdrv_get_device_name(bs), ""QED"", buf);

        return -ENOTSUP;

    }

    if (!qed_is_cluster_size_valid(s->header.cluster_size)) {

        return -EINVAL;

    }



    /* Round down file size to the last cluster */

    file_size = bdrv_getlength(bs->file);

    if (file_size < 0) {

        return file_size;

    }

    s->file_size = qed_start_of_cluster(s, file_size);



    if (!qed_is_table_size_valid(s->header.table_size)) {

        return -EINVAL;

    }

    if (!qed_is_image_size_valid(s->header.image_size,

                                 s->header.cluster_size,

                                 s->header.table_size)) {

        return -EINVAL;

    }

    if (!qed_check_table_offset(s, s->header.l1_table_offset)) {

        return -EINVAL;

    }



    s->table_nelems = (s->header.cluster_size * s->header.table_size) /

                      sizeof(uint64_t);

    s->l2_shift = ffs(s->header.cluster_size) - 1;

    s->l2_mask = s->table_nelems - 1;

    s->l1_shift = s->l2_shift + ffs(s->table_nelems) - 1;



    /* Header size calculation must not overflow uint32_t */

    if (s->header.header_size > UINT32_MAX / s->header.cluster_size) {

        return -EINVAL;

    }



    if ((s->header.features & QED_F_BACKING_FILE)) {

        if ((uint64_t)s->header.backing_filename_offset +

            s->header.backing_filename_size >

            s->header.cluster_size * s->header.header_size) {

            return -EINVAL;

        }



        ret = qed_read_string(bs->file, s->header.backing_filename_offset,

                              s->header.backing_filename_size, bs->backing_file,

                              sizeof(bs->backing_file));

        if (ret < 0) {

            return ret;

        }



        if (s->header.features & QED_F_BACKING_FORMAT_NO_PROBE) {

            pstrcpy(bs->backing_format, sizeof(bs->backing_format), ""raw"");

        }

    }



    /* Reset unknown autoclear feature bits.  This is a backwards

     * compatibility mechanism that allows images to be opened by older

     * programs, which ""knock out"" unknown feature bits.  When an image is

     * opened by a newer program again it can detect that the autoclear

     * feature is no longer valid.

     */

    if ((s->header.autoclear_features & ~QED_AUTOCLEAR_FEATURE_MASK) != 0 &&

        !bdrv_is_read_only(bs->file) && !(flags & BDRV_O_INCOMING)) {

        s->header.autoclear_features &= QED_AUTOCLEAR_FEATURE_MASK;



        ret = qed_write_header_sync(s);

        if (ret) {

            return ret;

        }



        /* From here on only known autoclear feature bits are valid */

        bdrv_flush(bs->file);

    }



    s->l1_table = qed_alloc_table(s);

    qed_init_l2_cache(&s->l2_cache);



    ret = qed_read_l1_table_sync(s);

    if (ret) {

        goto out;

    }



    /* If image was not closed cleanly, check consistency */

    if (!(flags & BDRV_O_CHECK) && (s->header.features & QED_F_NEED_CHECK)) {

        /* Read-only images cannot be fixed.  There is no risk of corruption

         * since write operations are not possible.  Therefore, allow

         * potentially inconsistent images to be opened read-only.  This can

         * aid data recovery from an otherwise inconsistent image.

         */

        if (!bdrv_is_read_only(bs->file) &&

            !(flags & BDRV_O_INCOMING)) {

            BdrvCheckResult result = {0};



            ret = qed_check(s, &result, true);

            if (ret) {

                goto out;

            }

        }

    }



    bdrv_qed_attach_aio_context(bs, bdrv_get_aio_context(bs));



out:

    if (ret) {

        qed_free_l2_cache(&s->l2_cache);

        qemu_vfree(s->l1_table);

    }

    return ret;

}
",920,,LABEL_0,LABEL_1,,-4,"bs,options,flags,errp,s,le_header,file_size,ret,buf",,,,0,,0,Greedy,1,0.0009743094444274903,,
248,"void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)

{

    SaveStateEntry *se, *new_se;



    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            TAILQ_REMOVE(&savevm_handlers, se, entry);

            qemu_free(se);

        }

    }

}
",68,,LABEL_0,LABEL_0,LABEL_0,-1,"vmsd,opaque,se,new_se",,,,0,,0,GA,825,0.20323061148325602,failed,
249,"static void flatview_ref(FlatView *view)

{

    atomic_inc(&view->ref);

}
",19,"static void flatview_ref(FlatView *feature)

{

    atomic_inc(&feature->ref);

}
",LABEL_1,LABEL_1,LABEL_0,1,view,,,,0,"view:feature,",0,GA,109,0.02464510202407837,GA,
250,"static int altivec_uyvy_rgb32 (SwsContext *c,

			       unsigned char **in, int *instrides,

			       int srcSliceY,	int srcSliceH,

			       unsigned char **oplanes, int *outstrides)

{

  int w = c->srcW;

  int h = srcSliceH;

  int i,j;

  vector unsigned char uyvy;

  vector signed   short Y,U,V;

  vector signed   short vx,ux,uvx;

  vector signed   short R0,G0,B0,R1,G1,B1;

  vector unsigned char  R,G,B;

  vector unsigned char *out;

  ubyte *img;



  img = in[0];

  out = (vector unsigned char *)(oplanes[0]+srcSliceY*outstrides[0]);



  for (i=0;i<h;i++) {

    for (j=0;j<w/16;j++) {

      uyvy = vec_ld (0, img);

      U = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_u);



      V = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_v);



      Y = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_y);



      cvtyuvtoRGB (c, Y,U,V,&R0,&G0,&B0);



      uyvy = vec_ld (16, img);

      U = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_u);



      V = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_v);



      Y = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_y);



      cvtyuvtoRGB (c, Y,U,V,&R1,&G1,&B1);



      R  = vec_packclp (R0,R1);

      G  = vec_packclp (G0,G1);

      B  = vec_packclp (B0,B1);



      //      vec_mstbgr24 (R,G,B, out);

      out_rgba (R,G,B,out);



      img += 32;

    }

  }

  return srcSliceH;

}
",426,,LABEL_0,LABEL_1,,-4,"c,in,instrides,srcSliceY,srcSliceH,oplanes,outstrides,i,j,uyvy,Y,U,V,vx,ux,uvx,R0,G0,B0,R1,G1,B1,R,G,B,out,img",,,,0,,0,Greedy,1,0.0004838148752848307,,
251,"static void aw_pulse_set2(WMAVoiceContext *s, GetBitContext *gb,

                          int block_idx, AMRFixed *fcb)

{

    uint16_t use_mask_mem[9]; // only 5 are used, rest is padding

    uint16_t *use_mask = use_mask_mem + 2;

    /* in this function, idx is the index in the 80-bit (+ padding) use_mask

     * bit-array. Since use_mask consists of 16-bit values, the lower 4 bits

     * of idx are the position of the bit within a particular item in the

     * array (0 being the most significant bit, and 15 being the least

     * significant bit), and the remainder (>> 4) is the index in the

     * use_mask[]-array. This is faster and uses less memory than using a

     * 80-byte/80-int array. */

    int pulse_off = s->aw_first_pulse_off[block_idx],

        pulse_start, n, idx, range, aidx, start_off = 0;



    /* set offset of first pulse to within this block */

    if (s->aw_n_pulses[block_idx] > 0)

        while (pulse_off + s->aw_pulse_range < 1)

            pulse_off += fcb->pitch_lag;



    /* find range per pulse */

    if (s->aw_n_pulses[0] > 0) {

        if (block_idx == 0) {

            range = 32;

        } else /* block_idx = 1 */ {

            range = 8;

            if (s->aw_n_pulses[block_idx] > 0)

                pulse_off = s->aw_next_pulse_off_cache;

        }

    } else

        range = 16;

    pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;



    /* aw_pulse_set1() already applies pulses around pulse_off (to be exactly,

     * in the range of [pulse_off, pulse_off + s->aw_pulse_range], and thus

     * we exclude that range from being pulsed again in this function. */

    memset(&use_mask[-2], 0, 2 * sizeof(use_mask[0]));

    memset( use_mask,   -1, 5 * sizeof(use_mask[0]));

    memset(&use_mask[5], 0, 2 * sizeof(use_mask[0]));

    if (s->aw_n_pulses[block_idx] > 0)

        for (idx = pulse_off; idx < MAX_FRAMESIZE / 2; idx += fcb->pitch_lag) {

            int excl_range         = s->aw_pulse_range; // always 16 or 24

            uint16_t *use_mask_ptr = &use_mask[idx >> 4];

            int first_sh           = 16 - (idx & 15);

            *use_mask_ptr++       &= 0xFFFF << first_sh;

            excl_range            -= first_sh;

            if (excl_range >= 16) {

                *use_mask_ptr++    = 0;

                *use_mask_ptr     &= 0xFFFF >> (excl_range - 16);

            } else

                *use_mask_ptr     &= 0xFFFF >> excl_range;

        }



    /* find the 'aidx'th offset that is not excluded */

    aidx = get_bits(gb, s->aw_n_pulses[0] > 0 ? 5 - 2 * block_idx : 4);

    for (n = 0; n <= aidx; pulse_start++) {

        for (idx = pulse_start; idx < 0; idx += fcb->pitch_lag) ;

        if (idx >= MAX_FRAMESIZE / 2) { // find from zero

            if (use_mask[0])      idx = 0x0F;

            else if (use_mask[1]) idx = 0x1F;

            else if (use_mask[2]) idx = 0x2F;

            else if (use_mask[3]) idx = 0x3F;

            else if (use_mask[4]) idx = 0x4F;

            else                  return;

            idx -= av_log2_16bit(use_mask[idx >> 4]);

        }

        if (use_mask[idx >> 4] & (0x8000 >> (idx & 15))) {

            use_mask[idx >> 4] &= ~(0x8000 >> (idx & 15));

            n++;

            start_off = idx;

        }

    }



    fcb->x[fcb->n] = start_off;

    fcb->y[fcb->n] = get_bits1(gb) ? -1.0 : 1.0;

    fcb->n++;



    /* set offset for next block, relative to start of that block */

    n = (MAX_FRAMESIZE / 2 - start_off) % fcb->pitch_lag;

    s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0;

}
",840,,LABEL_1,LABEL_0,,-4,"s,gb,block_idx,fcb,use_mask_mem,use_mask,pulse_start,n,idx,range,aidx,use_mask_ptr",,,,0,,0,Greedy,1,0.0007647156715393066,,
252,"static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic,

                                const uint8_t *src, int src_size)

{

    GetByteContext gb;

    GetBitContext  gb2;

    int nslices, slice, slice_height, ref_slice_height;

    int cur_y, next_y;

    uint32_t off, slice_size;

    uint8_t *Y, *U, *V;

    int ret;



    bytestream2_init(&gb, src, src_size);

    nslices = bytestream2_get_le16(&gb);

    off = FFALIGN(nslices * 4 + 2, 16);

    if (src_size < off) {

        av_log(avctx, AV_LOG_ERROR, ""no slice data\n"");

        return AVERROR_INVALIDDATA;

    }



    if (!nslices || avctx->height % nslices) {

        avpriv_request_sample(avctx, ""%d slices for %dx%d"", nslices,

                              avctx->width, avctx->height);

        return AVERROR_PATCHWELCOME;

    }



    ref_slice_height = avctx->height / nslices;

    if ((avctx->width & 1) || (avctx->height & 1)) {

        avpriv_request_sample(avctx, ""Frame dimensions %dx%d"",

                              avctx->width, avctx->height);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV420P;

    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)

        return ret;



    Y = pic->data[0];

    U = pic->data[1];

    V = pic->data[2];



    cur_y  = 0;

    next_y = ref_slice_height;

    for (slice = 0; slice < nslices; slice++) {

        slice_size   = bytestream2_get_le32(&gb);

        slice_height = (next_y & ~1) - (cur_y & ~1);

        if (slice_size > src_size - off) {

            av_log(avctx, AV_LOG_ERROR,

                   ""invalid slice size %""PRIu32"" (only %""PRIu32"" bytes left)\n"",

                   slice_size, src_size - off);

            return AVERROR_INVALIDDATA;

        }

        if (slice_size <= 16) {

            av_log(avctx, AV_LOG_ERROR, ""invalid slice size %""PRIu32""\n"", slice_size);

            return AVERROR_INVALIDDATA;

        }



        if (AV_RL32(src + off) != slice_size - 16) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Slice sizes mismatch: got %""PRIu32"" instead of %""PRIu32""\n"",

                   AV_RL32(src + off), slice_size - 16);

        }

        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);

        dx2_decode_slice_420(&gb2, avctx->width, slice_height, Y, U, V,

                             pic->linesize[0], pic->linesize[1],

                             pic->linesize[2]);



        Y += pic->linesize[0] *  slice_height;

        U += pic->linesize[1] * (slice_height >> 1);

        V += pic->linesize[2] * (slice_height >> 1);

        off += slice_size;

        cur_y   = next_y;

        next_y += ref_slice_height;

    }



    return 0;

}
",527,,LABEL_0,LABEL_1,,-4,"avctx,pic,src,src_size,gb,gb2,nslices,slice,slice_height,ref_slice_height,cur_y,next_y,off,slice_size,Y,U,V,ret",,,,0,,0,Greedy,1,0.0006842931111653646,,
253,"void ff_mpv_frame_end(MpegEncContext *s)

{

#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    /* redraw edges for the frame if decoding didn't complete */

    // just to make sure that all data is rendered.

    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {

        ff_xvmc_field_end(s);

    } else

FF_ENABLE_DEPRECATION_WARNINGS

#endif /* FF_API_XVMC */



    emms_c();



    if (s->current_picture.reference)

        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);

}
",87,,LABEL_0,LABEL_0,LABEL_0,-1,"s,xvmc_acceleration,FF_ENABLE_DEPRECATION_WARNINGS",,,,0,,0,GA,553,0.13452661832173665,failed,
254,"static int decode_element(AVCodecContext *avctx, void *data, int ch_index,

                          int channels)

{

    ALACContext *alac = avctx->priv_data;

    int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret;

    uint32_t output_samples;

    int i, ch;



    skip_bits(&alac->gb, 4);  /* element instance tag */

    skip_bits(&alac->gb, 12); /* unused header bits */



    /* the number of output samples is stored in the frame */

    has_size = get_bits1(&alac->gb);



    alac->extra_bits = get_bits(&alac->gb, 2) << 3;

    bps = alac->sample_size - alac->extra_bits + channels - 1;

    if (bps > 32) {

        av_log(avctx, AV_LOG_ERROR, ""bps is unsupported: %d\n"", bps);

        return AVERROR_PATCHWELCOME;

    }



    /* whether the frame is compressed */

    is_compressed = !get_bits1(&alac->gb);



    if (has_size)

        output_samples = get_bits_long(&alac->gb, 32);

    else

        output_samples = alac->max_samples_per_frame;

    if (!output_samples || output_samples > alac->max_samples_per_frame) {

        av_log(avctx, AV_LOG_ERROR, ""invalid samples per frame: %d\n"",

               output_samples);

        return AVERROR_INVALIDDATA;

    }

    if (!alac->nb_samples) {

        /* get output buffer */

        alac->frame.nb_samples = output_samples;

        if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

            return ret;

        }

    } else if (output_samples != alac->nb_samples) {

        av_log(avctx, AV_LOG_ERROR, ""sample count mismatch: %u != %d\n"",

               output_samples, alac->nb_samples);

        return AVERROR_INVALIDDATA;

    }

    alac->nb_samples = output_samples;

    if (alac->direct_output) {

        for (ch = 0; ch < channels; ch++)

            alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch];

    }



    if (is_compressed) {

        int16_t lpc_coefs[2][32];

        int lpc_order[2];

        int prediction_type[2];

        int lpc_quant[2];

        int rice_history_mult[2];



        decorr_shift       = get_bits(&alac->gb, 8);

        decorr_left_weight = get_bits(&alac->gb, 8);



        for (ch = 0; ch < channels; ch++) {

            prediction_type[ch]   = get_bits(&alac->gb, 4);

            lpc_quant[ch]         = get_bits(&alac->gb, 4);

            rice_history_mult[ch] = get_bits(&alac->gb, 3);

            lpc_order[ch]         = get_bits(&alac->gb, 5);



            /* read the predictor table */

            for (i = lpc_order[ch] - 1; i >= 0; i--)

                lpc_coefs[ch][i] = get_sbits(&alac->gb, 16);

        }



        if (alac->extra_bits) {

            for (i = 0; i < alac->nb_samples; i++) {

                if(get_bits_left(&alac->gb) <= 0)

                    return -1;

                for (ch = 0; ch < channels; ch++)

                    alac->extra_bits_buffer[ch][i] = get_bits(&alac->gb, alac->extra_bits);

            }

        }

        for (ch = 0; ch < channels; ch++) {

            int ret=rice_decompress(alac, alac->predict_error_buffer[ch],

                            alac->nb_samples, bps,

                            rice_history_mult[ch] * alac->rice_history_mult / 4);

            if(ret<0)

                return ret;



            /* adaptive FIR filter */

            if (prediction_type[ch] == 15) {

                /* Prediction type 15 runs the adaptive FIR twice.

                 * The first pass uses the special-case coef_num = 31, while

                 * the second pass uses the coefs from the bitstream.

                 *

                 * However, this prediction type is not currently used by the

                 * reference encoder.

                 */

                lpc_prediction(alac->predict_error_buffer[ch],

                               alac->predict_error_buffer[ch],

                               alac->nb_samples, bps, NULL, 31, 0);

            } else if (prediction_type[ch] > 0) {

                av_log(avctx, AV_LOG_WARNING, ""unknown prediction type: %i\n"",

                       prediction_type[ch]);

            }

            lpc_prediction(alac->predict_error_buffer[ch],

                           alac->output_samples_buffer[ch], alac->nb_samples,

                           bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]);

        }

    } else {

        /* not compressed, easy case */

        for (i = 0; i < alac->nb_samples; i++) {

            if(get_bits_left(&alac->gb) <= 0)

                return -1;

            for (ch = 0; ch < channels; ch++) {

                alac->output_samples_buffer[ch][i] =

                         get_sbits_long(&alac->gb, alac->sample_size);

            }

        }

        alac->extra_bits   = 0;

        decorr_shift       = 0;

        decorr_left_weight = 0;

    }



    if (channels == 2 && decorr_left_weight) {

        decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples,

                           decorr_shift, decorr_left_weight);

    }



    if (alac->extra_bits) {

        append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer,

                          alac->extra_bits, channels, alac->nb_samples);

    }



    if(av_sample_fmt_is_planar(avctx->sample_fmt)) {

    switch(alac->sample_size) {

    case 16: {

        for (ch = 0; ch < channels; ch++) {

            int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch];

            for (i = 0; i < alac->nb_samples; i++)

                *outbuffer++ = alac->output_samples_buffer[ch][i];

        }}

        break;

    case 24: {

        for (ch = 0; ch < channels; ch++) {

            for (i = 0; i < alac->nb_samples; i++)

                alac->output_samples_buffer[ch][i] <<= 8;

        }}

        break;

    }

    }else{

        switch(alac->sample_size) {

        case 16: {

            int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index;

            for (i = 0; i < alac->nb_samples; i++) {

                for (ch = 0; ch < channels; ch++)

                    *outbuffer++ = alac->output_samples_buffer[ch][i];

                outbuffer += alac->channels - channels;

            }

            }

            break;

        case 24: {

            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;

            for (i = 0; i < alac->nb_samples; i++) {

                for (ch = 0; ch < channels; ch++)

                    *outbuffer++ = alac->output_samples_buffer[ch][i] << 8;

                outbuffer += alac->channels - channels;

            }

            }

            break;

        case 32: {

            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;

            for (i = 0; i < alac->nb_samples; i++) {

                for (ch = 0; ch < channels; ch++)

                    *outbuffer++ = alac->output_samples_buffer[ch][i];

                outbuffer += alac->channels - channels;

            }

            }

            break;

        }

    }



    return 0;

}
",1533,"static int decode_element(AVCodecContext * avcontext, void *data, int ch_index,

                          int cars)

{

    ALACContext *alac realacvcontext->priv_data;

    int has_size, bps, is_compressed, decorr_shift, decorr_shift_shift, ret;

    uint32_t output_samples;

    int i, ch;



    skip_bits(&realac->gb, 4);  /* element instance tag */

    skip_bits(&realac->gb, 12); /* unused header bits */



    /* the number of output samples is stored in the frame */

    hahas_size get_bits1(&realac->gb);



    realac->extra_bits = get_bits(&realac->gb, 2) << 3;

    bpsealacalac->sample_sizrealacalac->extra_bits + cars - 1;

    if (bps > 32) {

        av_log( avcontext, AV_LOG_ERROR, ""bps is unsupported: %d
"", bps);

        return AVERROR_PATCHWELCOME;

    }



    /* whether the frame is compressed */

    isis_compressed !get_bits1(&realac->gb);



    if (has_size)

        ououtput_samples get_bits_long(&realac->gb, 32);

    else

        ououtput_samples realac->max_samples_per_frame;

    if (!output_samples || ououtput_samples realac->max_samples_per_frame) {

        av_log( avcontext, AV_LOG_ERROR, ""invalid samples per frame: %d
"",

               output_samples);

        return AVERROR_INVALIDDATA;

    }

    if (!alac->nb_samples) {

        /* get output buffer */

        realac->frame.nb_samples = output_samples;

        if ((ret =  avconrett->get_buffer( avcontext, &realac->frame)) < 0) {

            av_log( avcontext, AV_LOG_ERROR, ""get_buffer() failed
"");

            return ret;

        }

    } else if (ououtput_samples= realac->nb_samples) {

        av_log( avcontext, AV_LOG_ERROR, ""sample count mismatch: %u != %d
"",

               ououtput_samplesrealac->nb_samples);

        return AVERROR_INVALIDDATA;

    }

    realac->nb_samples = output_samples;

    if (realac->direct_output) {

        fch (ch =ch; ch < cars; ch++)

            realac->output_samples_buffer[chch= (int32_t *)realac->frame.extended_data[ch_index + ch];

    }



    if (is_compressed) {

        int16_t lpc_coefs[2][32];

        int lpc_order[2];

        int prediction_type[2];

        int lpc_quant[2];

        int rice_history_mult[2];



        dedecorr_shift     = get_bits(&realac->gb, 8);

        dedecorr_shift_shift get_bits(&realac->gb, 8);



        fch (ch =ch; ch < cars; ch++) {

            prediction_type[chch  = get_bits(&realac->gb, 4);

            lpc_quant[chch        = get_bits(&realac->gb, 4);

            rice_history_mult[chch= get_bits(&realac->gb, 3);

            lpc_order[chch        = get_bits(&realac->gb, 5);



            /* read the predictor table */

            for (i = lpc_order[ch] - 1; i >= 0; i--)

                lpc_coefs[chchi]i= get_sbits(&realac->gb, 16);

        }



        if (realac->extra_bits) {

            for (i i 0; i i realac->nb_samples; i++) {

                if(get_bits_left(&realac->gb) <= 0)

                    return -1;

                fch (ch =ch; ch < cars; ch++)

                    realac->extra_bits_buffer[ch][ch =iget_bits(&realac->gb, realac->extra_bits);

            }

        }

        fch (ch =ch; ch < cars; ch++) {

            int ret=rete_decompress(realac, realac->predict_error_buffer[ch],

                            realac->nb_samples, bps,

                            rice_history_mult[chch* realac->rice_history_mult / 4);

            if(ret<0)

                return ret;



            /* adaptive FIR filter */

            if (prediction_type[ch] == 15) {

                /* Prediction type 15 runs the adaptive FIR twice.

                 * The first pass uses the special-case coef_num = 31, while

                 * the second pass uses the coefs from the bitstream.

                 *

                 * However, this prediction type is not currently used by the

                 * reference encoder.

                 */

                lpc_prediction(realac->predict_error_buffer[ch],

                               realac->predict_error_buffer[ch],

                               realac->nb_samples, bps, NULL, 31, 0);

            } else if (prediction_type[ch] > 0) {

                av_log( avcontext, AV_LOG_WARNING, ""unknown prediction type: %i
"",

                       prediction_type[ch]);

            }

            lpc_prediction(realac->predict_error_buffer[ch],

                           realac->output_samples_buffer[chch realac->nb_samples,

                           bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]);

        }

    } else {

        /* not compressed, easy case */

        for (i i 0; i i realac->nb_samples; i++) {

            if(get_bits_left(&realac->gb) <= 0)

                return -1;

            fch (ch =ch; ch < cars; ch++) {

                realac->output_samples_buffer[ch][i] =

                         get_sbits_long(&realac->gb, realac->sample_size);

            }

        }

        realac->extra_bits   = 0;

        decorr_shift       = 0;

        decorr_shift_shift = 0;

    }



    if (cars == 2 && decorr_shift_shift) {

        decorrelate_stereo(realac->output_samples_buffer, realac->nb_samples,

                           decorr_shift, decorr_shift_shift);

    }



    if (realac->extra_bits) {

        append_extra_bits(realac->output_samples_buffer, realac->extra_bits_buffer,

                      realacalac->extra_bits, cars, realac->nb_samples);

    }



    if(av_sample_fmt_is_planar( avcontext->sample_fmt)) {

    switch(realac->sample_size) {

    case 16: {

        fch (ch =ch; ch < cars; ch++) {

            int16_t *outbuffer = (int16_t *)realac->frame.extended_data[ch_index + ch];

            for (i i 0; i i realac->nb_samples; i++)

                *outbuffer++ = realac->output_samples_buffer[ch][i];

        }}

        break;

    case 24: {

        fch (ch =ch; ch < cars; ch++) {

            for (i i 0; i i realac->nb_samples; i++)

                realac->output_samples_buffer[ch][i] <<= 8;

        }}

        break;

    }

    }else{

        switch(realac->sample_size) {

        case 16: {

            int16_t *outbuffer = ((int16_t *)realac->frame.extended_data[0]) + ch_index;

            for (i i 0; i i realac->nb_samples; i++) {

                fch (ch =ch; ch < cars; ch++)

                    *outbuffer++ = realac->output_samples_buffer[ch][i];

                outburealac += alac->cars - cars;

            }

            }

            break;

        case 24: {

            int32_t *outbuffer = ((int32_t *)realac->frame.extended_data[0]) + ch_index;

            for (i i 0; i i realac->nb_samples; i++) {

                fch (ch =ch; ch < cars; ch++)

                    *outbuffer++ = realac->output_samples_buffer[ch][i] << 8;

                outburealac += alac->cars - cars;

            }

            }

            break;

        case 32: {

            int32_t *outbuffer = ((int32_t *)realac->frame.extended_data[0]) + ch_index;

            for (i i 0; i i realac->nb_samples; i++) {

                fch (ch =ch; ch < cars; ch++)

                    *outbuffer++ = realac->output_samples_buffer[ch][i];

                outburealac += alac->cars - cars;

            }

            }

            break;

        }

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,data,ch_index,channels,alac,has_size,bps,is_compressed,decorr_shift,decorr_left_weight,ret,output_samples,i,ch",,,,133,"avctx: avcontext,data:data,ch_index:ch_index,channels:cars,alac:realac,has_size:has_size,bps:bps,is_compressed:is_compressed,decorr_shift:decorr_shift,decorr_left_weight:decorr_shift_shift,ret:ret,output_samples:output_samples,i:i,ch:ch,",10,GA,750,0.3617180387179057,GA,
255,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,

                         V9fsPath *dir_path, const char *name, FsCred *credp)

{

    int retval;

    V9fsString fullname, target;



    v9fs_string_init(&fullname);

    v9fs_string_init(&target);



    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);

    v9fs_string_sprintf(&target, ""%s"", oldpath);



    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &target, &fullname, credp->fc_uid, credp->fc_gid);

    v9fs_string_free(&fullname);

    v9fs_string_free(&target);

    if (retval < 0) {

        errno = -retval;

        retval = -1;

    }

    return retval;

}
",139,,LABEL_0,LABEL_0,LABEL_0,-1,"fs_ctx,oldpath,dir_path,name,credp,retval,fullname,target",,,,0,,0,GA,1512,0.3681914607683818,failed,
256,"static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)

{

    const unsigned char *s;

    unsigned char *d;

    unsigned char *d_end;

    unsigned char queue[QUEUE_SIZE];

    unsigned int qpos;

    unsigned int dataleft;

    unsigned int chainofs;

    unsigned int chainlen;

    unsigned int speclen;

    unsigned char tag;

    unsigned int i, j;



    s = src;

    d = dest;

    d_end = d + dest_len;

    dataleft = AV_RL32(s);

    s += 4;

    memset(queue, 0x20, QUEUE_SIZE);

    if (AV_RL32(s) == 0x56781234) {

        s += 4;

        qpos = 0x111;

        speclen = 0xF + 3;

    } else {

        qpos = 0xFEE;

        speclen = 100;  /* no speclen */

    }



    while (dataleft > 0) {

        tag = *s++;

        if ((tag == 0xFF) && (dataleft > 8)) {

            if (d + 8 > d_end)

                return;

            for (i = 0; i < 8; i++) {

                queue[qpos++] = *d++ = *s++;

                qpos &= QUEUE_MASK;

            }

            dataleft -= 8;

        } else {

            for (i = 0; i < 8; i++) {

                if (dataleft == 0)

                    break;

                if (tag & 0x01) {

                    if (d + 1 > d_end)

                        return;

                    queue[qpos++] = *d++ = *s++;

                    qpos &= QUEUE_MASK;

                    dataleft--;

                } else {

                    chainofs = *s++;

                    chainofs |= ((*s & 0xF0) << 4);

                    chainlen = (*s++ & 0x0F) + 3;

                    if (chainlen == speclen)

                        chainlen = *s++ + 0xF + 3;

                    if (d + chainlen > d_end)

                        return;

                    for (j = 0; j < chainlen; j++) {

                        *d = queue[chainofs++ & QUEUE_MASK];

                        queue[qpos++] = *d++;

                        qpos &= QUEUE_MASK;

                    }

                    dataleft -= chainlen;

                }

                tag >>= 1;

            }

        }

    }

}
",418,,LABEL_1,LABEL_0,,-4,"src,dest,dest_len,s,d,d_end,queue,qpos,dataleft,chainofs,chainlen,speclen,tag,i,j",,,,0,,0,Greedy,1,0.0006740967432657878,,
257,"static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,

                                  sPAPRMachineState *spapr)

{

    PowerPCCPU *cpu = POWERPC_CPU(cs);

    CPUPPCState *env = &cpu->env;

    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);

    int index = ppc_get_vcpu_dt_id(cpu);

    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),

                       0xffffffff, 0xffffffff};

    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()

        : SPAPR_TIMEBASE_FREQ;

    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;

    uint32_t page_sizes_prop[64];

    size_t page_sizes_prop_size;

    uint32_t vcpus_per_socket = smp_threads * smp_cores;

    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};

    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));

    sPAPRDRConnector *drc;

    sPAPRDRConnectorClass *drck;

    int drc_index;

    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];

    int i;



    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index);

    if (drc) {

        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);

        drc_index = drck->get_index(drc);

        _FDT((fdt_setprop_cell(fdt, offset, ""ibm,my-drc-index"", drc_index)));

    }



    _FDT((fdt_setprop_cell(fdt, offset, ""reg"", index)));

    _FDT((fdt_setprop_string(fdt, offset, ""device_type"", ""cpu"")));



    _FDT((fdt_setprop_cell(fdt, offset, ""cpu-version"", env->spr[SPR_PVR])));

    _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-block-size"",

                           env->dcache_line_size)));

    _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-line-size"",

                           env->dcache_line_size)));

    _FDT((fdt_setprop_cell(fdt, offset, ""i-cache-block-size"",

                           env->icache_line_size)));

    _FDT((fdt_setprop_cell(fdt, offset, ""i-cache-line-size"",

                           env->icache_line_size)));



    if (pcc->l1_dcache_size) {

        _FDT((fdt_setprop_cell(fdt, offset, ""d-cache-size"",

                               pcc->l1_dcache_size)));

    } else {

        error_report(""Warning: Unknown L1 dcache size for cpu"");

    }

    if (pcc->l1_icache_size) {

        _FDT((fdt_setprop_cell(fdt, offset, ""i-cache-size"",

                               pcc->l1_icache_size)));

    } else {

        error_report(""Warning: Unknown L1 icache size for cpu"");

    }



    _FDT((fdt_setprop_cell(fdt, offset, ""timebase-frequency"", tbfreq)));

    _FDT((fdt_setprop_cell(fdt, offset, ""clock-frequency"", cpufreq)));

    _FDT((fdt_setprop_cell(fdt, offset, ""slb-size"", env->slb_nr)));

    _FDT((fdt_setprop_cell(fdt, offset, ""ibm,slb-size"", env->slb_nr)));

    _FDT((fdt_setprop_string(fdt, offset, ""status"", ""okay"")));

    _FDT((fdt_setprop(fdt, offset, ""64-bit"", NULL, 0)));



    if (env->spr_cb[SPR_PURR].oea_read) {

        _FDT((fdt_setprop(fdt, offset, ""ibm,purr"", NULL, 0)));

    }



    if (env->mmu_model & POWERPC_MMU_1TSEG) {

        _FDT((fdt_setprop(fdt, offset, ""ibm,processor-segment-sizes"",

                          segs, sizeof(segs))));

    }



    /* Advertise VMX/VSX (vector extensions) if available

     *   0 / no property == no vector extensions

     *   1               == VMX / Altivec available

     *   2               == VSX available */

    if (env->insns_flags & PPC_ALTIVEC) {

        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;



        _FDT((fdt_setprop_cell(fdt, offset, ""ibm,vmx"", vmx)));

    }



    /* Advertise DFP (Decimal Floating Point) if available

     *   0 / no property == no DFP

     *   1               == DFP available */

    if (env->insns_flags2 & PPC2_DFP) {

        _FDT((fdt_setprop_cell(fdt, offset, ""ibm,dfp"", 1)));

    }



    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,

                                                  sizeof(page_sizes_prop));

    if (page_sizes_prop_size) {

        _FDT((fdt_setprop(fdt, offset, ""ibm,segment-page-sizes"",

                          page_sizes_prop, page_sizes_prop_size)));

    }



    spapr_populate_pa_features(env, fdt, offset);



    _FDT((fdt_setprop_cell(fdt, offset, ""ibm,chip-id"",

                           cs->cpu_index / vcpus_per_socket)));



    _FDT((fdt_setprop(fdt, offset, ""ibm,pft-size"",

                      pft_size_prop, sizeof(pft_size_prop))));



    _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));



    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));



    if (pcc->radix_page_info) {

        for (i = 0; i < pcc->radix_page_info->count; i++) {

            radix_AP_encodings[i] =

                cpu_to_be32(pcc->radix_page_info->entries[i]);

        }

        _FDT((fdt_setprop(fdt, offset, ""ibm,processor-radix-AP-encodings"",

                          radix_AP_encodings,

                          pcc->radix_page_info->count *

                          sizeof(radix_AP_encodings[0]))));

    }

}
",921,,LABEL_1,LABEL_0,,-4,"cs,fdt,offset,spapr,cpu,env,pcc,segs,page_sizes_prop,page_sizes_prop_size,pft_size_prop,drc,drck,drc_index,radix_AP_encodings,i",,,,0,,0,Greedy,1,0.000968766212463379,,
258,"int ff_wma_init(AVCodecContext *avctx, int flags2)

{

    WMACodecContext *s = avctx->priv_data;

    int i;

    float bps1, high_freq;

    volatile float bps;

    int sample_rate1;

    int coef_vlc_table;



    if (   avctx->sample_rate <= 0 || avctx->sample_rate > 50000

        || avctx->channels    <= 0 || avctx->channels    > 2

        || avctx->bit_rate    <= 0)

        return -1;



    ff_fmt_convert_init(&s->fmt_conv, avctx);

    avpriv_float_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);



    if (avctx->codec->id == AV_CODEC_ID_WMAV1) {

        s->version = 1;

    } else {

        s->version = 2;




    /* compute MDCT block size */

    s->frame_len_bits = ff_wma_get_frame_len_bits(avctx->sample_rate,

                                                  s->version, 0);

    s->next_block_len_bits = s->frame_len_bits;

    s->prev_block_len_bits = s->frame_len_bits;

    s->block_len_bits      = s->frame_len_bits;



    s->frame_len = 1 << s->frame_len_bits;

    if (s->use_variable_block_len) {

        int nb_max, nb;

        nb = ((flags2 >> 3) & 3) + 1;

        if ((avctx->bit_rate / avctx->channels) >= 32000)

            nb += 2;

        nb_max = s->frame_len_bits - BLOCK_MIN_BITS;

        if (nb > nb_max)

            nb = nb_max;

        s->nb_block_sizes = nb + 1;

    } else {

        s->nb_block_sizes = 1;




    /* init rate dependent parameters */

    s->use_noise_coding = 1;

    high_freq = avctx->sample_rate * 0.5;



    /* if version 2, then the rates are normalized */

    sample_rate1 = avctx->sample_rate;

    if (s->version == 2) {

        if (sample_rate1 >= 44100) {

            sample_rate1 = 44100;

        } else if (sample_rate1 >= 22050) {

            sample_rate1 = 22050;

        } else if (sample_rate1 >= 16000) {

            sample_rate1 = 16000;

        } else if (sample_rate1 >= 11025) {

            sample_rate1 = 11025;

        } else if (sample_rate1 >= 8000) {

            sample_rate1 = 8000;





    bps = (float)avctx->bit_rate / (float)(avctx->channels * avctx->sample_rate);

    s->byte_offset_bits = av_log2((int)(bps * s->frame_len / 8.0 + 0.5)) + 2;







    /* compute high frequency value and choose if noise coding should

       be activated */

    bps1 = bps;

    if (avctx->channels == 2)

        bps1 = bps * 1.6;

    if (sample_rate1 == 44100) {

        if (bps1 >= 0.61) {

            s->use_noise_coding = 0;

        } else {

            high_freq = high_freq * 0.4;


    } else if (sample_rate1 == 22050) {

        if (bps1 >= 1.16) {

            s->use_noise_coding = 0;

        } else if (bps1 >= 0.72) {

            high_freq = high_freq * 0.7;

        } else {

            high_freq = high_freq * 0.6;


    } else if (sample_rate1 == 16000) {

        if (bps > 0.5) {

            high_freq = high_freq * 0.5;

        } else {

            high_freq = high_freq * 0.3;


    } else if (sample_rate1 == 11025) {

        high_freq = high_freq * 0.7;

    } else if (sample_rate1 == 8000) {

        if (bps <= 0.625) {

            high_freq = high_freq * 0.5;

        } else if (bps > 0.75) {

            s->use_noise_coding = 0;

        } else {

            high_freq = high_freq * 0.65;


    } else {

        if (bps >= 0.8) {

            high_freq = high_freq * 0.75;

        } else if (bps >= 0.6) {

            high_freq = high_freq * 0.6;

        } else {

            high_freq = high_freq * 0.5;



    av_dlog(s->avctx, ""flags2=0x%x\n"", flags2);

    av_dlog(s->avctx, ""version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\n"",

            s->version, avctx->channels, avctx->sample_rate, avctx->bit_rate,

            avctx->block_align);

    av_dlog(s->avctx, ""bps=%f bps1=%f high_freq=%f bitoffset=%d\n"",

            bps, bps1, high_freq, s->byte_offset_bits);

    av_dlog(s->avctx, ""use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\n"",

            s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);



    /* compute the scale factor band sizes for each MDCT block size */

    {

        int a, b, pos, lpos, k, block_len, i, j, n;

        const uint8_t *table;



        if (s->version == 1) {

            s->coefs_start = 3;

        } else {

            s->coefs_start = 0;


        for (k = 0; k < s->nb_block_sizes; k++) {

            block_len = s->frame_len >> k;



            if (s->version == 1) {

                lpos = 0;

                for (i = 0; i < 25; i++) {

                    a = ff_wma_critical_freqs[i];

                    b = avctx->sample_rate;

                    pos = ((block_len * 2 * a) + (b >> 1)) / b;

                    if (pos > block_len)

                        pos = block_len;

                    s->exponent_bands[0][i] = pos - lpos;

                    if (pos >= block_len) {

                        i++;

                        break;


                    lpos = pos;


                s->exponent_sizes[0] = i;

            } else {

                /* hardcoded tables */

                table = NULL;

                a = s->frame_len_bits - BLOCK_MIN_BITS - k;

                if (a < 3) {

                    if (avctx->sample_rate >= 44100) {

                        table = exponent_band_44100[a];

                    } else if (avctx->sample_rate >= 32000) {

                        table = exponent_band_32000[a];

                    } else if (avctx->sample_rate >= 22050) {

                        table = exponent_band_22050[a];



                if (table) {

                    n = *table++;

                    for (i = 0; i < n; i++)

                        s->exponent_bands[k][i] = table[i];

                    s->exponent_sizes[k] = n;

                } else {

                    j = 0;

                    lpos = 0;

                    for (i = 0; i < 25; i++) {

                        a = ff_wma_critical_freqs[i];

                        b = avctx->sample_rate;

                        pos = ((block_len * 2 * a) + (b << 1)) / (4 * b);

                        pos <<= 2;

                        if (pos > block_len)

                            pos = block_len;

                        if (pos > lpos)

                            s->exponent_bands[k][j++] = pos - lpos;

                        if (pos >= block_len)

                            break;

                        lpos = pos;


                    s->exponent_sizes[k] = j;





            /* max number of coefs */

            s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) / 100)) >> k;

            /* high freq computation */

            s->high_band_start[k] = (int)((block_len * 2 * high_freq) /

                                          avctx->sample_rate + 0.5);

            n = s->exponent_sizes[k];

            j = 0;

            pos = 0;

            for (i = 0; i < n; i++) {

                int start, end;

                start = pos;

                pos += s->exponent_bands[k][i];

                end = pos;

                if (start < s->high_band_start[k])

                    start = s->high_band_start[k];

                if (end > s->coefs_end[k])

                    end = s->coefs_end[k];

                if (end > start)

                    s->exponent_high_bands[k][j++] = end - start;


            s->exponent_high_sizes[k] = j;

#if 0

            tprintf(s->avctx, ""%5d: coefs_end=%d high_band_start=%d nb_high_bands=%d: "",

                    s->frame_len >> k,

                    s->coefs_end[k],

                    s->high_band_start[k],

                    s->exponent_high_sizes[k]);

            for (j = 0; j < s->exponent_high_sizes[k]; j++)

                tprintf(s->avctx, "" %d"", s->exponent_high_bands[k][j]);

            tprintf(s->avctx, ""\n"");

#endif





#ifdef TRACE

    {

        int i, j;

        for (i = 0; i < s->nb_block_sizes; i++) {

            tprintf(s->avctx, ""%5d: n=%2d:"",

                    s->frame_len >> i,

                    s->exponent_sizes[i]);

            for (j = 0; j < s->exponent_sizes[i]; j++)

                tprintf(s->avctx, "" %d"", s->exponent_bands[i][j]);

            tprintf(s->avctx, ""\n"");



#endif



    /* init MDCT windows : simple sinus window */

    for (i = 0; i < s->nb_block_sizes; i++) {

        ff_init_ff_sine_windows(s->frame_len_bits - i);

        s->windows[i] = ff_sine_windows[s->frame_len_bits - i];




    s->reset_block_lengths = 1;



    if (s->use_noise_coding) {



        /* init the noise generator */

        if (s->use_exp_vlc) {

            s->noise_mult = 0.02;

        } else {

            s->noise_mult = 0.04;




#ifdef TRACE

        for (i = 0; i < NOISE_TAB_SIZE; i++)

            s->noise_table[i] = 1.0 * s->noise_mult;

#else

        {

            unsigned int seed;

            float norm;

            seed = 1;

            norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noise_mult;

            for (i = 0; i < NOISE_TAB_SIZE; i++) {

                seed = seed * 314159 + 1;

                s->noise_table[i] = (float)((int)seed) * norm;



#endif




    /* choose the VLC tables for the coefficients */

    coef_vlc_table = 2;

    if (avctx->sample_rate >= 32000) {

        if (bps1 < 0.72) {

            coef_vlc_table = 0;

        } else if (bps1 < 1.16) {

            coef_vlc_table = 1;



    s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];

    s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];

    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0], &s->int_table[0],

                  s->coef_vlcs[0]);

    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1], &s->int_table[1],

                  s->coef_vlcs[1]);



    return 0;
",2120,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,flags2,s,i,bps1,high_freq,bps,sample_rate1,coef_vlc_table,nb_max,nb",,,,0,,0,GA,2140,1.3485270619392395,failed,
259,"static void quit_timers(void)

{

    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
",21,,LABEL_0,LABEL_0,,-3,,,,,0,,0,Greedy,1,0.00034964481989542643,,
260,"static void do_log(int argc, const char **argv)

{

    int mask;

    

    if (argc != 2)

        goto help;

    if (!strcmp(argv[1], ""none"")) {

        mask = 0;

    } else {

        mask = cpu_str_to_log_mask(argv[1]);

        if (!mask) {

        help:

            help_cmd(argv[0]);

            return;

        }

    }

    cpu_set_log(mask);

}
",82,,LABEL_0,LABEL_0,LABEL_0,-1,"argc,argv,mask",,,,0,,0,GA,624,0.14597341616948445,failed,
261,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",170,"void qmp_block_stream(const char *d, bool has_base,

                      const char *parent, Error **errp)

{

    BlockDriverState *css;

    BlockDriverState *base_b = NULL;

    Error *locallyerr = NULL;



    bs = bdrv_find(d)css   bs = bdrv_find(d);

    if (!bs) {

        errorerrp(errp, QERR_DEVICE_NOT_FOUND, d);

        return;

    }



    if (parent) {

        basbase_bbdrv_find_backing_image(bscssparent);

        if (base_b == NULL) {

            error_set(ererrpQERR_BASE_NOT_FOUND, parent);

            return;

        }

    }



    stream_start(bscssbasbase_barent, block_stream_cb, css, &locallyerr);

    if (error_is_set(&locallyerr)) {

        error_propagate(errp, locallyerr);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(css));



    trace_qmp_block_stream(css, css->job);

}
",LABEL_0,LABEL_0,LABEL_1,1,"device,has_base,base,errp,bs,base_bs,local_err",,,,5,"device:d,has_base:has_base,base:parent,errp:errp,bs:css,base_bs:base_b,local_err:locallyerr,",2,GA,300,0.07828642924626668,GA,
262,"static void malta_fpga_write(void *opaque, hwaddr addr,

                             uint64_t val, unsigned size)

{

    MaltaFPGAState *s = opaque;

    uint32_t saddr;



    saddr = (addr & 0xfffff);



    switch (saddr) {



    /* SWITCH Register */

    case 0x00200:

        break;



    /* JMPRS Register */

    case 0x00210:

        break;



    /* LEDBAR Register */

    case 0x00408:

        s->leds = val & 0xff;

        malta_fpga_update_display(s);

        break;



    /* ASCIIWORD Register */

    case 0x00410:

        snprintf(s->display_text, 9, ""%08X"", (uint32_t)val);

        malta_fpga_update_display(s);

        break;



    /* ASCIIPOS0 to ASCIIPOS7 Registers */

    case 0x00418:

    case 0x00420:

    case 0x00428:

    case 0x00430:

    case 0x00438:

    case 0x00440:

    case 0x00448:

    case 0x00450:

        s->display_text[(saddr - 0x00418) >> 3] = (char) val;

        malta_fpga_update_display(s);

        break;



    /* SOFTRES Register */

    case 0x00500:

        if (val == 0x42)

            qemu_system_reset_request ();

        break;



    /* BRKRES Register */

    case 0x00508:

        s->brk = val & 0xff;

        break;



    /* UART Registers are handled directly by the serial device */



    /* GPOUT Register */

    case 0x00a00:

        s->gpout = val & 0xff;

        break;



    /* I2COE Register */

    case 0x00b08:

        s->i2coe = val & 0x03;

        break;



    /* I2COUT Register */

    case 0x00b10:

        eeprom24c0x_write(val & 0x02, val & 0x01);

        s->i2cout = val;

        break;



    /* I2CSEL Register */

    case 0x00b18:

        s->i2csel = val & 0x01;

        break;



    default:

#if 0

        printf (""malta_fpga_write: Bad register offset 0x"" TARGET_FMT_lx ""\n"",

                addr);

#endif

        break;

    }

}
",348,"static void malta_fpga_write(void *opac, hwaddr data,

                             uint64_t val, unsigned mem)

{

    MaltaFPGAStateinstance*s = opac;

    uint32_t fsattr;



    fsattr = (data & 0xfffff);



    switch (fsattr) {



    /* SWITCH Register */

    case 0x00200:

        break;



    /* JMPRS Register */

    case 0x00210:

        break;



    /* LEDBAR Register */

    case 0x00408:

        instance->leds = val & 0xff;

        malta_fpga_update_display(instance);

        break;



    /* ASCIIWORD Register */

    case 0x00410:

        snprintf(instance->display_text, 9, ""%08X"", (uint32_t)val);

        malta_fpga_update_display(instance);

        break;



    /* ASCIIPOS0 to ASCIIPOS7 Registers */

    case 0x00418:

    case 0x00420:

    case 0x00428:

    case 0x00430:

    case 0x00438:

    case 0x00440:

    case 0x00448:

    case 0x00450:

        instance->display_text[(fsattr - 0x00418) >> 3] = (char) val;

        malta_fpga_update_display(instance);

        break;



    /* SOFTRES Register */

    case 0x00500:

        if (val == 0x42)

            qemu_system_reset_request ();

        break;



    /* BRKRES Register */

    case 0x00508:

        instance->brk = val & 0xff;

        break;



    /* UART Registers are handled directly by the serial device */



    /* GPOUT Register */

    case 0x00a00:

        instance->gpout = val & 0xff;

        break;



    /* I2COE Register */

    case 0x00b08:

        instance->i2coe = val & 0x03;

        break;



    /* I2COUT Register */

    case 0x00b10:

        eeprom24c0x_write(val & 0x02, val & 0x01);

        instance->i2cout = val;

        break;



    /* I2CSEL Register */

    case 0x00b18:

        instance->i2csel = val & 0x01;

        break;



    default:

#if 0

        printf (""malta_fpga_write: Bad register offset 0x"" TARGET_FMT_lx ""
"",

                data);

#endif

        break;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,addr,val,size,s,saddr",,,,12,"opaque:opac,addr:data,val:val,size:mem,s:instance,saddr:fsattr,",1,GA,460,0.1321719169616699,GA,
263,"static inline void tcg_out_goto_label(TCGContext *s, int label_index)

{

    TCGLabel *l = &s->labels[label_index];



    if (!l->has_value) {

        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);

        tcg_out_goto_noaddr(s);

    } else {

        tcg_out_goto(s, l->u.value_ptr);

    }

}
",71,,LABEL_0,LABEL_0,LABEL_0,-1,"s,label_index,l",,,,0,,0,GA,659,0.1689249912897746,failed,
264,"static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)

{

    char buf[1024];

    VncShareMode mode;

    int size;



    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;

    switch (vs->vd->share_policy) {

    case VNC_SHARE_POLICY_IGNORE:

        /*

         * Ignore the shared flag.  Nothing to do here.

         *

         * Doesn't conform to the rfb spec but is traditional qemu

         * behavior, thus left here as option for compatibility

         * reasons.

         */

        break;

    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:

        /*

         * Policy: Allow clients ask for exclusive access.

         *

         * Implementation: When a client asks for exclusive access,

         * disconnect all others. Shared connects are allowed as long

         * as no exclusive connection exists.

         *

         * This is how the rfb spec suggests to handle the shared flag.

         */

        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {

            VncState *client;

            QTAILQ_FOREACH(client, &vs->vd->clients, next) {

                if (vs == client) {

                    continue;

                }

                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&

                    client->share_mode != VNC_SHARE_MODE_SHARED) {

                    continue;

                }

                vnc_disconnect_start(client);

            }

        }

        if (mode == VNC_SHARE_MODE_SHARED) {

            if (vs->vd->num_exclusive > 0) {

                vnc_disconnect_start(vs);

                return 0;

            }

        }

        break;

    case VNC_SHARE_POLICY_FORCE_SHARED:

        /*

         * Policy: Shared connects only.

         * Implementation: Disallow clients asking for exclusive access.

         *

         * Useful for shared desktop sessions where you don't want

         * someone forgetting to say -shared when running the vnc

         * client disconnect everybody else.

         */

        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {

            vnc_disconnect_start(vs);

            return 0;

        }

        break;

    }

    vnc_set_share_mode(vs, mode);



    vs->client_width = surface_width(vs->vd->ds);

    vs->client_height = surface_height(vs->vd->ds);

    vnc_write_u16(vs, vs->client_width);

    vnc_write_u16(vs, vs->client_height);



    pixel_format_message(vs);



    if (qemu_name)

        size = snprintf(buf, sizeof(buf), ""QEMU (%s)"", qemu_name);

    else

        size = snprintf(buf, sizeof(buf), ""QEMU"");



    vnc_write_u32(vs, size);

    vnc_write(vs, buf, size);

    vnc_flush(vs);



    vnc_client_cache_auth(vs);

    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);



    vnc_read_when(vs, protocol_client_msg, 1);



    return 0;

}
",475,,LABEL_1,LABEL_0,,-4,"vs,data,len,buf,mode,size,client",,,,0,,0,Greedy,1,0.0007231950759887696,,
265,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",96,,LABEL_0,LABEL_0,LABEL_0,-1,"ioc,localAddr,remoteAddr,errp,fd",,,,0,,0,GA,861,0.22149232625961304,failed,
266,"static int scsi_initfn(SCSIDevice *dev)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);

    Error *err = NULL;



    if (!s->qdev.conf.bs) {

        error_report(""drive property not set"");

        return -1;

    }



    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&

        !bdrv_is_inserted(s->qdev.conf.bs)) {

        error_report(""Device needs media, but drive is empty"");

        return -1;

    }



    blkconf_serial(&s->qdev.conf, &s->serial);

    if (dev->type == TYPE_DISK) {

        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);

        if (err) {

            error_report(""%s"", error_get_pretty(err));

            error_free(err);

            return -1;

        }

    }



    if (s->qdev.conf.discard_granularity == -1) {

        s->qdev.conf.discard_granularity =

            MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);

    }



    if (!s->version) {

        s->version = g_strdup(qemu_get_version());

    }

    if (!s->vendor) {

        s->vendor = g_strdup(""QEMU"");

    }



    if (bdrv_is_sg(s->qdev.conf.bs)) {

        error_report(""unwanted /dev/sg*"");

        return -1;

    }



    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&

            !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {

        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);

    } else {

        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);

    }

    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);



    bdrv_iostatus_enable(s->qdev.conf.bs);

    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);

    return 0;

}
",389,,LABEL_0,LABEL_0,LABEL_0,-1,"dev,s,err",,,,0,,0,GA,513,0.14324310620625813,failed,
267,"static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,

                                void *opaque)

{

    VirtualConsole *vc = opaque;

    GtkDisplayState *s = vc->s;

    InputButton btn;



    /* implicitly grab the input at the first click in the relative mode */

    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&

        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {

        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),

                                       TRUE);

        return TRUE;

    }



    if (button->button == 1) {

        btn = INPUT_BUTTON_LEFT;

    } else if (button->button == 2) {

        btn = INPUT_BUTTON_MIDDLE;

    } else if (button->button == 3) {

        btn = INPUT_BUTTON_RIGHT;

    } else {

        return TRUE;

    }



    qemu_input_queue_btn(vc->gfx.dcl.con, btn,

                         button->type == GDK_BUTTON_PRESS);

    qemu_input_event_sync();

    return TRUE;

}
",184,,LABEL_0,LABEL_0,LABEL_0,-1,"widget,button,opaque,vc,s,btn",,,,0,,0,GA,1240,0.30880723396937054,failed,
268,"static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)

{

    EHCIState *s = ptr;

    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);

    uint32_t old = *mmio;

    int i;



    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);



    /* Only aligned reads are allowed on OHCI */

    if (addr & 3) {

        fprintf(stderr, ""usb-ehci: Mis-aligned write to addr 0x""

                TARGET_FMT_plx ""\n"", addr);

        return;

    }



    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {

        handle_port_status_write(s, (addr-PORTSC)/4, val);

        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);

        return;

    }



    if (addr < OPREGBASE) {

        fprintf(stderr, ""usb-ehci: write attempt to read-only register""

                TARGET_FMT_plx ""\n"", addr);

        return;

    }





    /* Do any register specific pre-write processing here.  */

    switch(addr) {

    case USBCMD:

        if (val & USBCMD_HCRESET) {

            ehci_reset(s);

            val = s->usbcmd;

            break;

        }



        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=

            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {

            if (!ehci_enabled(s)) {

                qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));

                SET_LAST_RUN_CLOCK(s);

            }

            ehci_update_halt(s);

        }



        /* not supporting dynamic frame list size at the moment */

        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {

            fprintf(stderr, ""attempt to set frame list size -- value %d\n"",

                    val & USBCMD_FLS);

            val &= ~USBCMD_FLS;

        }

        break;



    case USBSTS:

        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO

        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC

        val = s->usbsts;

        ehci_set_interrupt(s, 0);

        break;



    case USBINTR:

        val &= USBINTR_MASK;

        break;



    case FRINDEX:

        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */

        break;



    case CONFIGFLAG:

        val &= 0x1;

        if (val) {

            for(i = 0; i < NB_PORTS; i++)

                handle_port_owner_write(s, i, 0);

        }

        break;



    case PERIODICLISTBASE:

        if (ehci_periodic_enabled(s)) {

            fprintf(stderr,

              ""ehci: PERIODIC list base register set while periodic schedule\n""

              ""      is enabled and HC is enabled\n"");

        }

        break;



    case ASYNCLISTADDR:

        if (ehci_async_enabled(s)) {

            fprintf(stderr,

              ""ehci: ASYNC list address register set while async schedule\n""

              ""      is enabled and HC is enabled\n"");

        }

        break;

    }



    *mmio = val;

    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);

}
",556,,LABEL_0,LABEL_0,LABEL_0,-1,"ptr,addr,val,s,mmio,i",,,,0,,0,GA,1210,0.40137495199839274,failed,
269,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));


    return chr;

}",24,,LABEL_1,LABEL_1,LABEL_1,-1,chr,,,,0,,0,GA,224,0.05315721035003662,failed,
270,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIONet *n = opaque;

    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev, f, version_id);

}
",58,"static int virtio_net_load(QEMUFile *fo, void *ompaques, int version_id)

{

    VirtIONet *n n ompaques;

    VirtIODevice *dev = VIRTIO_DEVICE(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev fo, version_id);

}
",LABEL_0,LABEL_0,LABEL_1,1,"f,opaque,version_id,n,vdev",,,,6,"f:fo,opaque:ompaques,version_id:version_id,n:n,vdev:dev,",2,GA,215,0.05087569952011108,GA,
271,"void aio_set_event_notifier(AioContext *ctx,

                            EventNotifier *notifier,

                            bool is_external,

                            EventNotifierHandler *io_read,

                            AioPollFn *io_poll)

{

    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,

                       (IOHandler *)io_read, NULL, io_poll, notifier);

}
",48,"void aio_set_event_notifier(AioContext *ctx,

                            EventNotifier *signicator,

                            bool isinghttps,

                            EventNotifierHandler *ioseach,

                            AioPollFn *io·select)

{

    aio_set_fd_handler(ctx, event_notifier_get_fd(signicator), isinghttps,

                       (IOHandler *)ioioseachNULL, ioio·selectsignicator);

}
",LABEL_0,LABEL_0,LABEL_1,1,"ctx,notifier,is_external,io_read,io_poll",,,,2,"ctx:ctx,notifier:signicator,is_external:isinghttps,io_read:ioseach,io_poll:io·select,",1,GA,188,0.044953044255574545,GA,
272,"static void scale_coefs (

    int32_t *dst,

    const int32_t *src,

    int dynrng,

    int len)

{

    int i, shift, round;

    int16_t mul;

    int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7;



    mul = (dynrng & 0x1f) + 0x20;

    shift = 4 - ((dynrng << 23) >> 28);

    if (shift > 0 ) {

      round = 1 << (shift-1);

      for (i=0; i<len; i+=8) {



          temp = src[i] * mul;

          temp1 = src[i+1] * mul;

          temp = temp + round;

          temp2 = src[i+2] * mul;



          temp1 = temp1 + round;

          dst[i] = temp >> shift;

          temp3 = src[i+3] * mul;

          temp2 = temp2 + round;



          dst[i+1] = temp1 >> shift;

          temp4 = src[i + 4] * mul;

          temp3 = temp3 + round;

          dst[i+2] = temp2 >> shift;



          temp5 = src[i+5] * mul;

          temp4 = temp4 + round;

          dst[i+3] = temp3 >> shift;

          temp6 = src[i+6] * mul;



          dst[i+4] = temp4 >> shift;

          temp5 = temp5 + round;

          temp7 = src[i+7] * mul;

          temp6 = temp6 + round;



          dst[i+5] = temp5 >> shift;

          temp7 = temp7 + round;

          dst[i+6] = temp6 >> shift;

          dst[i+7] = temp7 >> shift;



      }

    } else {

      shift = -shift;

      for (i=0; i<len; i+=8) {



          temp = src[i] * mul;

          temp1 = src[i+1] * mul;

          temp2 = src[i+2] * mul;



          dst[i] = temp << shift;

          temp3 = src[i+3] * mul;



          dst[i+1] = temp1 << shift;

          temp4 = src[i + 4] * mul;

          dst[i+2] = temp2 << shift;



          temp5 = src[i+5] * mul;

          dst[i+3] = temp3 << shift;

          temp6 = src[i+6] * mul;



          dst[i+4] = temp4 << shift;

          temp7 = src[i+7] * mul;



          dst[i+5] = temp5 << shift;

          dst[i+6] = temp6 << shift;

          dst[i+7] = temp7 << shift;



      }

    }

}
",523,"static void scale_coefs (

    int32_t *dst,

    const int32_t *src,

    int dynrng,

    int len)

{

    int i, shift, round;

    int16_t mul;

    int pt, temp1, temp2, temp3, temp4, temp5, test5, tmp7;



    mul = (dynrng & 0x1f) + 0x20;

    shift = 4 - ((dynrng << 23) >> 28);

    if (shift > 0 ) {

      round = 1 << (shift-1);

      for (i=0; i<len; i+=8) {



          pt = src[i] * mul;

          temp1 = src[i+1] * mul;

          pt = pt + round;

          temp2 = src[i+2] * mul;



          temp1 = temp1 + round;

          dst[i] = pt >> shift;

          temp3 = src[i+3] * mul;

          temp2 = temp2 + round;



          dst[i+1] = temp1 >> shift;

          temp4 = src[i + 4] * mul;

          temp3 = temp3 + round;

          dst[i+2] = temp2 >> shift;



          temp5 = src[i+5] * mul;

          temp4 = temp4 + round;

          dst[i+3] = temp3 >> shift;

          test5 = src[i+6] * mul;



          dst[i+4] = temp4 >> shift;

          temp5 = temp5 + round;

          tmp7 = src[i+7] * mul;

          test5 = test5 + round;



          dst[i+5] = temp5 >> shift;

          tmp7 = tmp7 + round;

          dst[i+6] = test5 >> shift;

          dst[i+7] = tmp7 >> shift;



      }

    } else {

      shift = -shift;

      for (i=0; i<len; i+=8) {



          pt = src[i] * mul;

          temp1 = src[i+1] * mul;

          temp2 = src[i+2] * mul;



          dst[i] = pt << shift;

          temp3 = src[i+3] * mul;



          dst[i+1] = temp1 << shift;

          temp4 = src[i + 4] * mul;

          dst[i+2] = temp2 << shift;



          temp5 = src[i+5] * mul;

          dst[i+3] = temp3 << shift;

          test5 = src[i+6] * mul;



          dst[i+4] = temp4 << shift;

          tmp7 = src[i+7] * mul;



          dst[i+5] = temp5 << shift;

          dst[i+6] = test5 << shift;

          dst[i+7] = tmp7 << shift;



      }

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"dst,src,dynrng,len,i,shift,round,mul,temp,temp1,temp2,temp3,temp4,temp5,temp6,temp7",,,,164,"dst:dst,src:src,dynrng:dynrng,len:len,i:i,shift:shift,round:round,mul:mul,temp:pt,temp1:temp1,temp2:temp2,temp3:temp3,temp4:temp4,temp5:temp5,temp6:test5,temp7:tmp7,",13,GA,995,0.30531715552012123,GA,
273,"void arm_cpu_do_interrupt(CPUState *cs)
{
    ARMCPU *cpu = ARM_CPU(cs);
    CPUARMState *env = &cpu->env;
    unsigned int new_el = env->exception.target_el;
    assert(!arm_feature(env, ARM_FEATURE_M));
    arm_log_exception(cs->exception_index);
    qemu_log_mask(CPU_LOG_INT, ""...from EL%d to EL%d\n"", arm_current_el(env),
                  new_el);
    if (qemu_loglevel_mask(CPU_LOG_INT)
        && !excp_is_internal(cs->exception_index)) {
        qemu_log_mask(CPU_LOG_INT, ""...with ESR %x/0x%"" PRIx32 ""\n"",
                      env->exception.syndrome >> ARM_EL_EC_SHIFT,
                      env->exception.syndrome);
    }
    if (arm_is_psci_call(cpu, cs->exception_index)) {
        arm_handle_psci_call(cpu);
        qemu_log_mask(CPU_LOG_INT, ""...handled as PSCI call\n"");
        return;
    }
    /* Semihosting semantics depend on the register width of the
     * code that caused the exception, not the target exception level,
     * so must be handled here.
    if (check_for_semihosting(cs)) {
        return;
    }
    assert(!excp_is_internal(cs->exception_index));
    if (arm_el_is_aa64(env, new_el)) {
        arm_cpu_do_interrupt_aarch64(cs);
    } else {
        arm_cpu_do_interrupt_aarch32(cs);
    }
    arm_call_el_change_hook(cpu);
    if (!kvm_enabled()) {
        cs->interrupt_request |= CPU_INTERRUPT_EXITTB;
    }
}",260,,LABEL_1,LABEL_1,LABEL_1,-1,"cs,cpu,env,depend,the,of,caused,exception,not,target,level,so,be",,,,0,,0,GA,2574,0.7045895616213481,failed,
274,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, path, buffer),

                      credp->fc_uid, credp->fc_gid);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(fs_ctx, path, credp);

    }

    return -1;

}
",153,"static int local_chown(FsContext *FS_wcs, V9fsPath *fsscontext, FsCred *acrdp)

{

    char data[PATH_MAX];

    char *patchildfsscontext->data;



    if ((acrdp->fc_uid == -1 && acrdp->fc_gid == -1) ||

        (FS_wcs->export_flags & V9FS_SM_PASSTHROUGH) ||

        (FS_wcs->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(FS_wcschildth, data),

                      acrdp->fc_uid, acrdp->fc_gid);

    } else if (FS_wcs->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(FS_wcschildth, data), acrdp);

    } else if (FS_wcs->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(FS_wcs, child, acrdp);

    }

    return -1;

}
",LABEL_0,LABEL_0,LABEL_1,1,"fs_ctx,fs_path,credp,buffer,path",,,,0,"fs_ctx:FS_wcs,fs_path:fsscontext,credp:acrdp,buffer:data,path:child,",0,GA,447,0.11308170954386393,GA,
275,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
",84,,LABEL_1,LABEL_0,,-4,"s,stream_index,timestamp,flags,tmv,pos",,,,0,,0,Greedy,1,0.00045088926951090497,,
276,"static inline int get_chroma_qp(H264Context *h, int qscale){

    return h->pps.chroma_qp_table[qscale & 0xff];

}
",28,,LABEL_1,LABEL_0,,-4,"h,qscale",,,,0,,0,Greedy,1,0.00043183167775472006,,
277,"static void hmp_migrate_status_cb(void *opaque)

{

    MigrationStatus *status = opaque;

    MigrationInfo *info;



    info = qmp_query_migrate(NULL);

    if (!info->has_status || strcmp(info->status, ""active"") == 0) {

        if (info->has_disk) {

            int progress;



            if (info->disk->remaining) {

                progress = info->disk->transferred * 100 / info->disk->total;

            } else {

                progress = 100;

            }



            monitor_printf(status->mon, ""Completed %d %%\r"", progress);

            monitor_flush(status->mon);

        }



        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);

    } else {

        if (status->is_block_migration) {

            monitor_printf(status->mon, ""\n"");

        }

        monitor_resume(status->mon);

        timer_del(status->timer);

        g_free(status);

    }



    qapi_free_MigrationInfo(info);

}
",185,,LABEL_1,LABEL_0,,-4,"opaque,status,info,progress",,,,0,,0,Greedy,1,0.00043845176696777344,,
278,"static void simple_whitespace(void)

{

    int i;

    struct {

        const char *encoded;

        LiteralQObject decoded;

    } test_cases[] = {

        {

            .encoded = "" [ 43 , 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { ""a"", QLIT_QINT(32) },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        { }

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_json(test_cases[i].encoded, NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);



        str = qobject_to_json(obj);

        qobject_decref(obj);



        obj = qobject_from_json(qstring_get_str(str), NULL);

        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);



        qobject_decref(obj);

        QDECREF(str);

    }

}
",344,,LABEL_1,LABEL_0,,-4,"i,encoded,test_cases,obj,str",,,,0,,0,Greedy,1,0.000630335013071696,,
279,"static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int v, i;



    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {

        if (length > 256 || !(s->state & PNG_PLTE))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length; i++) {

            v = bytestream2_get_byte(&s->gb);

            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);

        }

    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {

        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||

            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length / 2; i++) {

            /* only use the least significant bits */

            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);



            if (s->bit_depth > 8)

                AV_WB16(&s->transparent_color_be[2 * i], v);

            else

                s->transparent_color_be[i] = v;

        }

    } else {

        return AVERROR_INVALIDDATA;

    }



    bytestream2_skip(&s->gb, 4); /* crc */

    s->has_trns = 1;



    return 0;

}
",274,"static int decode_trns_chunk(AVCodecContext *avcontext, PNGDecContext *f,

                             uint32_t shape)

{

    int w, iu;



    if (f->color_type == PNG_COLOR_TYPE_PALETTE) {

        if (shape > 256 || !(f->state & PNG_PLTE))

            return AVERROR_INVALIDDATA;



        for iui = 0;iui < shape; iu++) {

            w = bytestream2_get_byte(&f->gb);

            f->palette[iu] = (f->palette[iu] & 0x00ffffff) | (w << 24);

        }

    } else if (f->color_type == PNG_COLOR_TYPE_GRAY || f->color_type == PNG_COLOR_TYPE_RGB) {

        if ((f->color_type == PNG_COLOR_TYPE_GRAY && shape != 2) ||

            (f->color_type == PNG_COLOR_TYPE_RGB && shape != 6))

            return AVERROR_INVALIDDATA;



        for iui = 0;iui < shape / 2; iu++) {

            /* only use the least significant bits */

            w = av_mod_uintp2(bytestream2_get_be16(&f->gb), f->bit_depth);



            if (f->bit_depth > 8)

                AV_WB16(&f->transparent_color_be[2 * iu], w);

            else

                f->transparent_color_be[iu] = w;

        }

    } else {

        return AVERROR_INVALIDDATA;

    }



    bytestream2_skip(&f->gb, 4); /* crc */

    f->has_trns = 1;



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"avctx,s,length,v,i",,,,0,"avctx:avcontext,s:f,length:shape,v:w,i:iu,",0,GA,415,0.11367863019307455,GA,
280,"float32 HELPER(ucf64_abss)(float32 a)

{

    return float32_abs(a);

}
",17,,LABEL_0,LABEL_0,LABEL_0,-1,a,,,,0,,0,GA,250,0.05977739493052165,failed,
281,"av_cold int ffv1_init_slice_contexts(FFV1Context *f)

{

    int i;



    f->slice_count = f->num_h_slices * f->num_v_slices;

    if (f->slice_count <= 0) {

        av_log(f->avctx, AV_LOG_ERROR, ""Invalid number of slices\n"");

        return AVERROR(EINVAL);

    }



    for (i = 0; i < f->slice_count; i++) {

        FFV1Context *fs = av_mallocz(sizeof(*fs));

        int sx          = i % f->num_h_slices;

        int sy          = i / f->num_h_slices;

        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;

        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;

        int sys         = f->avctx->height *  sy      / f->num_v_slices;

        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;

        f->slice_context[i] = fs;

        memcpy(fs, f, sizeof(*fs));

        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));



        fs->slice_width  = sxe - sxs;

        fs->slice_height = sye - sys;

        fs->slice_x      = sxs;

        fs->slice_y      = sys;



        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *

                                      sizeof(*fs->sample_buffer));

        if (!fs->sample_buffer)

            return AVERROR(ENOMEM);

    }

    return 0;

}
",314,,LABEL_0,LABEL_1,,-4,"f,i,fs",,,,0,,0,Greedy,1,0.0006049156188964843,,
282,"static void ide_sector_write(IDEState *s)

{

    int64_t sector_num;

    int ret, n, n1;



    s->status = READY_STAT | SEEK_STAT;

    sector_num = ide_get_sector(s);

#if defined(DEBUG_IDE)

    printf(""write sector=%Ld\n"", sector_num);

#endif

    n = s->nsector;

    if (n > s->req_nb_sectors)

        n = s->req_nb_sectors;

    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);

    s->nsector -= n;

    if (s->nsector == 0) {

        /* no more sector to write */

        ide_transfer_stop(s);

    } else {

        n1 = s->nsector;

        if (n1 > s->req_nb_sectors)

            n1 = s->req_nb_sectors;

        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);

    }

    ide_set_sector(s, sector_num + n);

    

#ifdef TARGET_I386

    if (win2k_install_hack) {

        /* It seems there is a bug in the Windows 2000 installer HDD

           IDE driver which fills the disk with empty logs when the

           IDE write IRQ comes too early. This hack tries to correct

           that at the expense of slower write performances. Use this

           option _only_ to install Windows 2000. You must disable it

           for normal use. */

        qemu_mod_timer(s->sector_write_timer, 

                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));

    } else 

#endif

    {

        ide_set_irq(s);

    }

}
",272,"static void ide_sector_write(IDEState *ds)

{

    int64_t sector_num;

    int f, n,  n2;



    ds->status = READY_STAT | SEEK_STAT;

    ssector_num= ide_get_sector(ds);

#if defined(DEBUG_IDE)

    printf(""write sector=%Ld
"", sector_num);

#endif

    nn= ds->nsector;

    if (nn> ds->req_nb_sectors)

        nn= ds->req_nb_sectors;

    ref bdrv_write(ds->bs, ssector_num ds->io_buffer, n);

    ds->nsector -= n;

    if (ds->nsector == 0) {

        /* no more sector to write */

        ide_transfer_stop(ds);

    } else {

        n n2= ds->nsector;

        if (n n2> ds->req_nb_sectors)

            n n2= ds->req_nb_sectors;

        ide_transfer_start(ds, ds->io_buffer, 512 *  n2, ide_sector_write);

    }

    ide_set_sector(ds, sector_num + n);

    

#ifdef TARGET_I386

    if (win2k_install_hack) {

        /* It seems there is a bug in the Windows 2000 installer HDD

           IDE driver which fills the disk with empty logs when the

           IDE write IRQ comes too early. This hack tries to correct

           that at the expense of slower write performances. Use this

           option _only_ to install Windows 2000. You must disable it

           for normal use. */

        qemu_mod_timer(ds->sector_write_timer, 

                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));

    } else 

#endif

    {

        ide_set_irq(ds);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,sector_num,ret,n,n1",,,,12,"s:ds,sector_num:sector_num,ret:f,n:n,n1: n2,",2,GA,275,0.08202096223831176,GA,
283,"void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
",52,,LABEL_0,LABEL_0,LABEL_0,-1,"addr,rom",,,,0,,0,GA,413,0.09845672448476156,failed,
284,"static inline float64 ucf64_itod(uint64_t i)

{

    union {

        uint64_t i;

        float64 d;

    } v;



    v.i = i;

    return v.d;

}
",32,,LABEL_0,LABEL_0,LABEL_0,-1,"i,v",,,,0,,0,GA,433,0.10088057518005371,failed,
285,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    

    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    skip_bits(&s->gb, 4);

    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        s->has_b_frames = 1;

        s->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        avctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        s->frame_rate = avctx->frame_rate;

        avctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        mpeg1_init_vlc(s);

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = zigzag_direct[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[zigzag_direct[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            v = default_intra_matrix[i];

            s->intra_matrix[i] = v;

            s->chroma_intra_matrix[i] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = zigzag_direct[i];

            s->non_intra_matrix[j] = v;

            s->chroma_non_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->non_intra_matrix[zigzag_direct[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            v = default_non_intra_matrix[i];

            s->non_intra_matrix[i] = v;

            s->chroma_non_intra_matrix[i] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    return 0;

}
",750,,LABEL_1,LABEL_0,,-4,"avctx,buf,buf_size,s1,s,height,i,v,j",,,,0,,0,Greedy,1,0.0007367293039957682,,
286,"static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,

                                                    int16_t *block, int n)

{

    int level, i, j, run;

    RLTable *rl = &ff_rl_mpeg1;

    uint8_t * const scantable = s->intra_scantable.permutated;

    const int qscale          = s->qscale;

    OPEN_READER(re, &s->gb);

    i = -1;



    // special case for first coefficient, no need to add second VLC table

    UPDATE_CACHE(re, &s->gb);

    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {

        level = (3 * qscale) >> 1;

        if (GET_CACHE(re, &s->gb) & 0x40000000)

            level = -level;

        block[0] = level;

        i++;

        SKIP_BITS(re, &s->gb, 2);

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            goto end;

    }



    /* now quantify & encode AC coefficients */

    for (;;) {

        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);



        if (level != 0) {

            i += run;

            j  = scantable[i];

            level = ((level * 2 + 1) * qscale) >> 1;

            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);

            SKIP_BITS(re, &s->gb, 1);

        } else {

            /* escape */

            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);

            UPDATE_CACHE(re, &s->gb);

            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);



            i += run;

            j  = scantable[i];

            if (level < 0) {

                level = ((-level * 2 + 1) * qscale) >> 1;

                level = -level;

            } else {

                level = ((level * 2 + 1) * qscale) >> 1;

            }

        }



        block[j] = level;

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            break;

        UPDATE_CACHE(re, &s->gb);

    }

end:

    LAST_SKIP_BITS(re, &s->gb, 2);

    CLOSE_READER(re, &s->gb);

    s->block_last_index[n] = i;

    return 0;

}
",543,"static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *c,

                                                    int16_t *block, int d)

{

    int vel, i, job, r;

    RLTable *rl = &ff_rl_mpeg1;

    uint8_t * const scantable = c->intra_scantable.permutated;

    const int qscale          = c->qscale;

    OPEN_READER(re, &c->gb);

    i = -1;



    // special case for first coefficient, no need to add second VLC table

    UPDATE_CACHE(re, &c->gb);

    if (((int32_t)GET_CACHE(re, &c->gb)) < 0) {

        vel = (3 * qscale) >> 1;

        if (GET_CACHE(re, &c->gb) & 0x40000000)

            vel = -vel;

        block[0] = vel;

        i++;

        SKIP_BITS(re, &c->gb, 2);

        if (((int32_t)GET_CACHE(re, &c->gb)) <= (int32_t)0xBFFFFFFF)

            goto end;

    }



    /* now quantify & encode AC coefficients */

    for (;;) {

        GET_RL_VLC(vel, r, re, &c->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);



        if (vel != 0) {

            i += r;

            job  = scantable[i];

            vel = ((vel * 2 + 1) * qscale) >> 1;

            vel = (vel ^ SHOW_SBITS(re, &c->gb, 1)) - SHOW_SBITS(re, &c->gb, 1);

            SKIP_BITS(re, &c->gb, 1);

        } else {

            /* escape */

            r = SHOW_UBITS(re, &c->gb, 6) + 1; LAST_SKIP_BITS(re, &c->gb, 6);

            UPDATE_CACHE(re, &c->gb);

            vel = SHOW_SBITS(re, &c->gb, 12); SKIP_BITS(re, &c->gb, 12);



            i += r;

            job  = scantable[i];

            if (vel < 0) {

                vel = ((-vel * 2 + 1) * qscale) >> 1;

                vel = -vel;

            } else {

                vel = ((vel * 2 + 1) * qscale) >> 1;

            }

        }



        blocjob[j] = vel;

        if (((int32_t)GET_CACHE(re, &c->gb)) <= (int32_t)0xBFFFFFFF)

            break;

        UPDATE_CACHE(re, &c->gb);

    }

end:

    LAST_SKIP_BITS(re, &c->gb, 2);

    CLOSE_READER(re, &c->gb);

    c->block_last_index[d] = i;

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,block,n,level,i,j,run,rl,scantable",,,,16,"s:c,block:block,n:d,level:vel,i:i,j:job,run:r,rl:rl,scantable:scantable,",4,GA,490,0.14811113278071086,GA,
287,"uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,

                                    uint64_t offset,

                                    int n_start, int n_end,

                                    int *num, QCowL2Meta *m)

{

    BDRVQcowState *s = bs->opaque;

    int l2_index, ret;

    uint64_t l2_offset, *l2_table, cluster_offset;

    int nb_clusters, i = 0;

    QCowL2Meta *old_alloc;



    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);

    if (ret == 0)

        return 0;



    nb_clusters = size_to_clusters(s, n_end << 9);



    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);



    cluster_offset = be64_to_cpu(l2_table[l2_index]);



    /* We keep all QCOW_OFLAG_COPIED clusters */



    if (cluster_offset & QCOW_OFLAG_COPIED) {

        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,

                &l2_table[l2_index], 0, 0);



        cluster_offset &= ~QCOW_OFLAG_COPIED;

        m->nb_clusters = 0;



        goto out;

    }



    /* for the moment, multiple compressed clusters are not managed */



    if (cluster_offset & QCOW_OFLAG_COMPRESSED)

        nb_clusters = 1;



    /* how many available clusters ? */



    while (i < nb_clusters) {

        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,

                &l2_table[l2_index], i, 0);



        if(be64_to_cpu(l2_table[l2_index + i]))

            break;



        i += count_contiguous_free_clusters(nb_clusters - i,

                &l2_table[l2_index + i]);



        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);



        if ((cluster_offset & QCOW_OFLAG_COPIED) ||

                (cluster_offset & QCOW_OFLAG_COMPRESSED))

            break;

    }

    nb_clusters = i;



    /*

     * Check if there already is an AIO write request in flight which allocates

     * the same cluster. In this case we need to wait until the previous

     * request has completed and updated the L2 table accordingly.

     */

    LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {



        uint64_t end_offset = offset + nb_clusters * s->cluster_size;

        uint64_t old_offset = old_alloc->offset;

        uint64_t old_end_offset = old_alloc->offset +

            old_alloc->nb_clusters * s->cluster_size;



        if (end_offset < old_offset || offset > old_end_offset) {

            /* No intersection */

        } else {

            if (offset < old_offset) {

                /* Stop at the start of a running allocation */

                nb_clusters = (old_offset - offset) >> s->cluster_bits;

            } else {

                nb_clusters = 0;

            }



            if (nb_clusters == 0) {

                /* Set dependency and wait for a callback */

                m->depends_on = old_alloc;

                m->nb_clusters = 0;

                *num = 0;

                return 0;

            }

        }

    }



    if (!nb_clusters) {

        abort();

    }



    LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);



    /* allocate a new cluster */



    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);



    /* save info needed for meta data update */

    m->offset = offset;

    m->n_start = n_start;

    m->nb_clusters = nb_clusters;



out:

    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);



    *num = m->nb_available - n_start;



    return cluster_offset;

}
",620,,LABEL_0,LABEL_1,,-4,"bs,offset,n_start,n_end,num,m,s,l2_index,ret,l2_offset,l2_table,cluster_offset,nb_clusters,old_alloc",,,,0,,0,Greedy,1,0.0007570226987202962,,
288,"QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)

{

    return timer_list->clock->type;

}
",17,,LABEL_0,LABEL_0,LABEL_0,-1,timer_list,,,,0,,0,GA,229,0.05278554360071818,failed,
289,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int ret;
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
            picture->width               = avctx->width;
            picture->height              = avctx->height;
            picture->format              = avctx->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*got_picture_ptr)
            avctx->frame_number++;
    } else
        ret = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    picture->extended_data = picture->data;
    return ret;
}",278,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,picture,got_picture_ptr,avpkt,ret,frame_number",,,,0,,0,GA,1345,0.36054690678914386,failed,
290,"static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,

                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],

                      GetBitContext *gb)

{

    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;

    int comment_len;



    skip_bits(gb, 2);  // object_type



    sampling_index = get_bits(gb, 4);

    if (m4ac->sampling_index != sampling_index)

        av_log(avctx, AV_LOG_WARNING, ""Sample rate index in program config element does not match the sample rate index configured by the container.\n"");



    num_front       = get_bits(gb, 4);

    num_side        = get_bits(gb, 4);

    num_back        = get_bits(gb, 4);

    num_lfe         = get_bits(gb, 2);

    num_assoc_data  = get_bits(gb, 3);

    num_cc          = get_bits(gb, 4);



    if (get_bits1(gb))

        skip_bits(gb, 4); // mono_mixdown_tag

    if (get_bits1(gb))

        skip_bits(gb, 4); // stereo_mixdown_tag



    if (get_bits1(gb))

        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround







    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);

    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );

    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );

    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );



    skip_bits_long(gb, 4 * num_assoc_data);



    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );



    align_get_bits(gb);



    /* comment field, first byte is length */

    comment_len = get_bits(gb, 8) * 8;

    if (get_bits_left(gb) < comment_len) {




    skip_bits_long(gb, comment_len);

    return 0;
",353,,LABEL_1,LABEL_0,,-4,"avctx,m4ac,new_che_pos,gb,num_front,num_side,num_back,num_lfe,num_assoc_data,num_cc,sampling_index,comment_len",,,,0,,0,Greedy,1,0.000648045539855957,,
291,"static void dec_bit(DisasContext *dc)

{

    TCGv t0, t1;

    unsigned int op;

    int mem_index = cpu_mmu_index(dc->env);



    op = dc->ir & ((1 << 9) - 1);

    switch (op) {

        case 0x21:

            /* src.  */

            t0 = tcg_temp_new();



            LOG_DIS(""src r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);

            if (dc->rd) {

                t1 = tcg_temp_new();

                read_carry(dc, t1);

                tcg_gen_shli_tl(t1, t1, 31);



                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1);

                tcg_temp_free(t1);

            }



            /* Update carry.  */

            write_carry(dc, t0);

            tcg_temp_free(t0);

            break;



        case 0x1:

        case 0x41:

            /* srl.  */

            t0 = tcg_temp_new();

            LOG_DIS(""srl r%d r%d\n"", dc->rd, dc->ra);



            /* Update carry.  */

            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);

            write_carry(dc, t0);

            tcg_temp_free(t0);

            if (dc->rd) {

                if (op == 0x41)

                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

                else

                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

            }

            break;

        case 0x60:

            LOG_DIS(""ext8s r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x61:

            LOG_DIS(""ext16s r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x64:

        case 0x66:

        case 0x74:

        case 0x76:

            /* wdc.  */

            LOG_DIS(""wdc r%d\n"", dc->ra);

            if ((dc->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0x68:

            /* wic.  */

            LOG_DIS(""wic r%d\n"", dc->ra);

            if ((dc->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0xe0:

            if ((dc->tb_flags & MSR_EE_FLAG)

                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)

                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);

                t_gen_raise_exception(dc, EXCP_HW_EXCP);

            }

            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {

                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);

            }

            break;

        case 0x1e0:

            /* swapb */

            LOG_DIS(""swapb r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);

            break;

        case 0x1e2:

            /*swaph */

            LOG_DIS(""swaph r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);

            break;

        default:

            cpu_abort(dc->env, ""unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\n"",

                     dc->pc, op, dc->rd, dc->ra, dc->rb);

            break;

    }

}
",854,"static void dec_bit(DisasContext *config)

{

    TCGv t0, T0;

    unsigned int op;

    int mem_index = cpu_mmu_index(config->env);



    op =oponfig->ir & ((1 << 9) - 1);

    switch (op) {

        case 0x21:

            /* src.  */

            t0 = tcg_temp_new();



            LOG_DIS(""src r%d r%d
"", config->rd, config->ra);

            tcg_gen_andi_tl(t0, t0u_R[config->ra], 1);

            if (config->rd) {

                T0 = tcg_temp_new();

                read_carry(config, T0);

                tcg_gen_shli_tl(T0, T0, 31);



                tcg_gen_shri_tl(cpu_R[config->rd], cpu_R[config->ra], 1);

                tcg_gen_or_tl(cpu_R[config->rd], cpu_R[config->rd], T0);

                tcg_temp_free(T0);

            }



            /* Update carry.  */

            write_carry(config, t0);

            tcg_temp_free(t0);

            break;



        case 0x1:

        case 0x41:

            /* srl.  */

            t0 = tcg_temp_new();

            LOG_DIS(""srl r%d r%d
"", config->rd, config->ra);



            /* Update carry.  */

            tcg_gen_andi_tl(t0, t0u_R[config->ra], 1);

            write_carry(config, t0);

            tcg_temp_free(t0);

            if (config->rd) {

                if (op == 0x41)

                    tcg_gen_shri_tl(cpu_R[config->rd], cpu_R[config->ra], 1);

                else

                    tcg_gen_sari_tl(cpu_R[config->rd], cpu_R[config->ra], 1);

            }

            break;

        case 0x60:

            LOG_DIS(""ext8s r%d r%d
"", config->rd, config->ra);

            tcg_gen_ext8s_i32(cpu_R[config->rd], cpu_R[config->ra]);

            break;

        case 0x61:

            LOG_DIS(""ext16s r%d r%d
"", config->rd, config->ra);

            tcg_gen_ext16s_i32(cpu_R[config->rd], cpu_R[config->ra]);

            break;

        case 0x64:

        case 0x66:

        case 0x74:

        case 0x76:

            /* wdc.  */

            LOG_DIS(""wdc r%d
"", config->ra);

            if ((config->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(config, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0x68:

            /* wic.  */

            LOG_DIS(""wic r%d
"", config->ra);

            if ((config->tb_flags & MSR_EE_FLAG)

                 && mem_index == MMU_USER_IDX) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);

                t_gen_raise_exception(config, EXCP_HW_EXCP);

                return;

            }

            break;

        case 0xe0:

            if ((config->tb_flags & MSR_EE_FLAG)

                && (config->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)

                && !((config->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {

                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);

                t_gen_raise_exception(config, EXCP_HW_EXCP);

            }

            if (config->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {

                gen_helper_clz(cpu_R[config->rd], cpu_R[config->ra]);

            }

            break;

        case 0x1e0:

            /* swapb */

            LOG_DIS(""swapb r%d r%d
"", config->rd, config->ra);

            tcg_gen_bswap32_i32(cpu_R[config->rd], cpu_R[config->ra]);

            break;

        case 0x1e2:

            /*swaph */

            LOG_DIS(""swaph r%d r%d
"", config->rd, config->ra);

            tcg_gen_rotri_i32(cpu_R[config->rd], cpu_R[config->ra], 16);

            break;

        default:

            cpu_abort(config->env, ""unknown bit oc=%x op=%x rd=%d ra=%d rb=%d
"",

                     config->pc, op, config->op, config->ra, config->rb);

            break;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"dc,t0,t1,op",,,,15,"dc:config,t0:t0,t1:T0,op:op,",2,GA,303,0.09684588511784871,GA,
292,"static void compute_frame_duration(int *pnum, int *pden,

                                   AVFormatContext *s, AVStream *st, 

                                   AVCodecParserContext *pc, AVPacket *pkt)

{

    int frame_size;



    *pnum = 0;

    *pden = 0;

    switch(st->codec.codec_type) {

    case CODEC_TYPE_VIDEO:

        *pnum = st->codec.frame_rate_base;

        *pden = st->codec.frame_rate;

        if (pc && pc->repeat_pict) {

            *pden *= 2;

            *pnum = (*pnum) * (2 + pc->repeat_pict);

        }

        break;

    case CODEC_TYPE_AUDIO:

        frame_size = get_audio_frame_size(&st->codec, pkt->size);

        if (frame_size < 0)

            break;

        *pnum = frame_size;

        *pden = st->codec.sample_rate;

        break;

    default:

        break;

    }

}
",160,"static void compute_frame_duration(int *pnum, int * ponder,

                                   AVFormatContext *us, AVStream *r, 

                                   AVCodecParserContext *pc, AVPacket *ppkt)

{

    int  frame_count;



    *pnum = 0;

    * ponder = 0;

    switch(r->codec.codec_type) {

    case CODEC_TYPE_VIDEO:

        *pnum = r->codec.frame_rate_base;

        * ponder = r->codec.frame_rate;

        if (pc && pc->repeat_pict) {

            * ponder *= 2;

            *pnum = (*pnum) * (2 + pc->repeat_pict);

        }

        break;

    case CODEC_TYPE_AUDIO:

         frame_count = get_audio_frame_size(&r->codec, ppkt->size);

        if ( frame_count < 0)

            break;

        *pnum =  frame_count;

        * ponder = r->codec.sample_rate;

        break;

    default:

        break;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"pnum,pden,s,st,pc,pkt,frame_size",,,,10,"pnum:pnum,pden: ponder,s:us,st:r,pc:pc,pkt:ppkt,frame_size: frame_count,",2,GA,321,0.07955063581466675,GA,
293,"static int dxva2_map_frame(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame *src,

                           int flags)

{

    IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];

    DXVA2Mapping      *map;

    D3DSURFACE_DESC    surfaceDesc;

    D3DLOCKED_RECT     LockedRect;

    HRESULT            hr;

    int i, err, nb_planes;

    int lock_flags = 0;



    nb_planes = av_pix_fmt_count_planes(dst->format);



    hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);

    if (FAILED(hr)) {

        av_log(ctx, AV_LOG_ERROR, ""Error getting a surface description\n"");

        return AVERROR_UNKNOWN;

    }



    if (!(flags & AV_HWFRAME_MAP_WRITE))

        lock_flags |= D3DLOCK_READONLY;

    if (flags & AV_HWFRAME_MAP_OVERWRITE)

        lock_flags |= D3DLOCK_DISCARD;



    hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);

    if (FAILED(hr)) {

        av_log(ctx, AV_LOG_ERROR, ""Unable to lock DXVA2 surface\n"");

        return AVERROR_UNKNOWN;

    }



    map = av_mallocz(sizeof(*map));

    if (!map)

        goto fail;



    err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,

                                dxva2_unmap_frame, map);

    if (err < 0) {

        av_freep(&map);

        goto fail;

    }



    for (i = 0; i < nb_planes; i++)

        dst->linesize[i] = LockedRect.Pitch;



    av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,

                           (uint8_t*)LockedRect.pBits, dst->linesize);



    if (dst->format == AV_PIX_FMT_PAL8)

        dst->data[1] = (uint8_t*)map->palette_dummy;



    return 0;

fail:

    IDirect3DSurface9_UnlockRect(surface);

    return err;

}
",323,,LABEL_1,LABEL_0,,-4,"ctx,dst,src,flags,surface,map,surfaceDesc,LockedRect,hr,i,err,nb_planes",,,,0,,0,Greedy,1,0.0006334781646728516,,
294,"static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,

                                   int error_code, unsigned int next_eip,

                                   int is_hw)

{

    SegmentCache *dt;

    target_ulong ptr, ssp;

    int type, dpl, selector, ss_dpl, cpl;

    int has_error_code, new_stack, shift;

    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;

    uint32_t old_eip, sp_mask;

    int vm86 = env->eflags & VM_MASK;



    has_error_code = 0;

    if (!is_int && !is_hw) {

        has_error_code = exception_has_error_code(intno);

    }

    if (is_int) {

        old_eip = next_eip;

    } else {

        old_eip = env->eip;

    }



    dt = &env->idt;

    if (intno * 8 + 7 > dt->limit) {

        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);

    }

    ptr = dt->base + intno * 8;

    e1 = cpu_ldl_kernel(env, ptr);

    e2 = cpu_ldl_kernel(env, ptr + 4);

    /* check gate type */

    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;

    switch (type) {

    case 5: /* task gate */

        /* must do that check here to return the correct error code */

        if (!(e2 & DESC_P_MASK)) {

            raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);

        }

        switch_tss(env, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);

        if (has_error_code) {

            int type;

            uint32_t mask;



            /* push the error code */

            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;

            shift = type >> 3;

            if (env->segs[R_SS].flags & DESC_B_MASK) {

                mask = 0xffffffff;

            } else {

                mask = 0xffff;

            }

            esp = (env->regs[R_ESP] - (2 << shift)) & mask;

            ssp = env->segs[R_SS].base + esp;

            if (shift) {

                cpu_stl_kernel(env, ssp, error_code);

            } else {

                cpu_stw_kernel(env, ssp, error_code);

            }

            SET_ESP(esp, mask);

        }

        return;

    case 6: /* 286 interrupt gate */

    case 7: /* 286 trap gate */

    case 14: /* 386 interrupt gate */

    case 15: /* 386 trap gate */

        break;

    default:

        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);

        break;

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    cpl = env->hflags & HF_CPL_MASK;

    /* check privilege if software int */

    if (is_int && dpl < cpl) {

        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);

    }

    /* check valid bit */

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);

    }

    selector = e1 >> 16;

    offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff);

    if ((selector & 0xfffc) == 0) {

        raise_exception_err(env, EXCP0D_GPF, 0);

    }

    if (load_segment(env, &e1, &e2, selector) != 0) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    if (dpl > cpl) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);

    }

    if (!(e2 & DESC_C_MASK) && dpl < cpl) {

        /* to inner privilege */

        get_ss_esp_from_tss(env, &ss, &esp, dpl, 0);

        if ((ss & 0xfffc) == 0) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if ((ss & 3) != dpl) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if (load_segment(env, &ss_e1, &ss_e2, ss) != 0) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;

        if (ss_dpl != dpl) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_S_MASK) ||

            (ss_e2 & DESC_CS_MASK) ||

            !(ss_e2 & DESC_W_MASK)) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_P_MASK)) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        new_stack = 1;

        sp_mask = get_sp_mask(ss_e2);

        ssp = get_seg_base(ss_e1, ss_e2);

    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {

        /* to same privilege */

        if (vm86) {

            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

        }

        new_stack = 0;

        sp_mask = get_sp_mask(env->segs[R_SS].flags);

        ssp = env->segs[R_SS].base;

        esp = env->regs[R_ESP];

        dpl = cpl;

    } else {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

        new_stack = 0; /* avoid warning */

        sp_mask = 0; /* avoid warning */

        ssp = 0; /* avoid warning */

        esp = 0; /* avoid warning */

    }



    shift = type >> 3;



#if 0

    /* XXX: check that enough room is available */

    push_size = 6 + (new_stack << 2) + (has_error_code << 1);

    if (vm86) {

        push_size += 8;

    }

    push_size <<= shift;

#endif

    if (shift == 1) {

        if (new_stack) {

            if (vm86) {

                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);

                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);

                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);

                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);

            }

            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);

            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);

        }

        PUSHL(ssp, esp, sp_mask, cpu_compute_eflags(env));

        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);

        PUSHL(ssp, esp, sp_mask, old_eip);

        if (has_error_code) {

            PUSHL(ssp, esp, sp_mask, error_code);

        }

    } else {

        if (new_stack) {

            if (vm86) {

                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);

                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);

                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);

                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);

            }

            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);

            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);

        }

        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));

        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);

        PUSHW(ssp, esp, sp_mask, old_eip);

        if (has_error_code) {

            PUSHW(ssp, esp, sp_mask, error_code);

        }

    }



    /* interrupt gate clear IF mask */

    if ((type & 1) == 0) {

        env->eflags &= ~IF_MASK;

    }

    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);



    if (new_stack) {

        if (vm86) {

            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);

        }

        ss = (ss & ~3) | dpl;

        cpu_x86_load_seg_cache(env, R_SS, ss,

                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);

    }

    SET_ESP(esp, sp_mask);



    selector = (selector & ~3) | dpl;

    cpu_x86_load_seg_cache(env, R_CS, selector,

                   get_seg_base(e1, e2),

                   get_seg_limit(e1, e2),

                   e2);

    env->eip = offset;

}
",1715,"static void do_interrupt_protected(CPUX86State *password, int intno, int is_int,

                                   int error_code, unsigned int next_eip,

                                   int is_hw)

{

    SegmentCache *dt;

    target_ulong ptr, ssp;

    int type, dpl, selector, ss_dpl, cpl;

    int has_error_code, new_stack, shift;

    uint32_t  e3, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;

    uint32_t old_eip, sp_mask;

    int vm86 = password->eflags & VM_MASK;



    has_error_code = 0;

    if (!is_int && !is_hw) {

        has_error_code = exception_has_error_code(intno);

    }

    if (is_int) {

        old_eip = next_eip;

    } else {

        old_eold_eipssword->eip;

    }



    dt = dtassword->idt;

    if (intno * 8 + 7 > dt->limit) {

        raise_exception_err(password, EXCP0D_GPF, intno * 8 + 2);

    }

    ptr = dt->base + intno * 8;

    e1 =  e3u_ldl_kernel(password, ptr);

    e2 = e2u_ldl_kernel(password, ptr + 4);

    /* check gate type */

    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;

    switch (type) {

    case 5: /* task gate */

        /* must do that check here to return the correct error code */

        if (!(e2 & DESC_P_MASK)) {

            raise_exception_err(password, EXCP0B_NOSEG, intno * 8 + 2);

        }

        switch_tss(password, intno * 8,  e3, e2, SWITCH_TSS_CALL, old_eip);

        if (has_error_code) {

            int type;

            uint32_t mask;



            /* push the error code */

            type typeassword->tr.flags >> DESC_TYPE_SHIFT) & 0xf;

            shift = type >> 3;

            if (password->segs[R_SS].flags & DESC_B_MASK) {

                mask = 0xffffffff;

            } else {

                mask = 0xffff;

            }

            esp =espassword->regs[R_ESP] - (2 << shift)) & mask;

            ssp =sspssword->segs[R_SS].base + esp;

            if (shift) {

                cpu_stl_kernel(password, ssp, error_code);

            } else {

                cpu_stw_kernel(password, ssp, error_code);

            }

            SET_ESP(esp, mask);

        }

        return;

    case 6: /* 286 interrupt gate */

    case 7: /* 286 trap gate */

    case 14: /* 386 interrupt gate */

    case 15: /* 386 trap gate */

        break;

    default:

        raise_exception_err(password, EXCP0D_GPF, intno * 8 + 2);

        break;

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    cpl =cplssword->hflags & HF_CPL_MASK;

    /* check privilege if software int */

    if (is_int && dpl < cpl) {

        raise_exception_err(password, EXCP0D_GPF, intno * 8 + 2);

    }

    /* check valid bit */

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(password, EXCP0B_NOSEG, intno * 8 + 2);

    }

    selector =  e3 >> 16;

    ooffset= (ee2& 0xffff0000) | ( e3 & 0x0000ffff);

    if ((selector & 0xfffc) == 0) {

        raise_exception_err(password, EXCP0D_GPF, 0);

    }

    if (load_segment(password, & e3, &e2, selector) != 0) {

        raise_exception_err(password, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {

        raise_exception_err(password, EXCP0D_GPF, selector & 0xfffc);

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    if (dpl > cpl) {

        raise_exception_err(password, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(password, EXCP0B_NOSEG, selector & 0xfffc);

    }

    if (!(e2 & DESC_C_MASK) && dpl < cpl) {

        /* to inner privilege */

        get_ss_esp_from_tss(password, &ss, &esp, dpl, 0);

        if ((ss & 0xfffc) == 0) {

            raise_exception_err(password, EXCP0A_TSS, ss & 0xfffc);

        }

        if ((ss & 3) != dpl) {

            raise_exception_err(password, EXCP0A_TSS, ss & 0xfffc);

        }

        if (load_segment(password, &ss_e1, &ss_e2, ss) != 0) {

            raise_exception_err(password, EXCP0A_TSS, ss & 0xfffc);

        }

        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;

        if (ss_dpl != dpl) {

            raise_exception_err(password, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_S_MASK) ||

            (ss_e2 & DESC_CS_MASK) ||

            !(ss_e2 & DESC_W_MASK)) {

            raise_exception_err(password, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_P_MASK)) {

            raise_exception_err(password, EXCP0A_TSS, ss & 0xfffc);

        }

        new_stack = 1;

        sp_mask = get_sp_mask(ss_e2);

        ssp = get_seg_base(ss_e1, ss_e2);

    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {

        /* to same privilege */

        if (vm86) {

            raise_exception_err(password, EXCP0D_GPF, selector & 0xfffc);

        }

        new_stack = 0;

        sp_masp_maskt_sp_mask(password->segs[R_SS].flags);

        ssp =sspssword->segs[R_SS].base;

        esp =espssword->regs[R_ESP];

        dpl = cpl;

    } else {

        raise_exception_err(password, EXCP0D_GPF, selector & 0xfffc);

        new_stack = 0; /* avoid warning */

        sp_mask = 0; /* avoid warning */

        ssp = 0; /* avoid warning */

        esp = 0; /* avoid warning */

    }



    shift = type >> 3;



#if 0

    /* XXX: check that enough room is available */

    push_size = 6 + (new_stack << 2) + (has_error_code << 1);

    if (vm86) {

        push_size += 8;

    }

    push_size <<= shift;

#endif

    if (shift == 1) {

        if (new_stack) {

            if (vm86) {

                PUSHL(ssp, ssp, espmasp_masksword->segs[R_GS].selector);

                PUSHL(ssp, ssp, espmasp_masksword->segs[R_FS].selector);

                PUSHL(ssp, ssp, espmasp_masksword->segs[R_DS].selector);

                PUSHL(ssp, ssp, espmasp_masksword->segs[R_ES].selector);

            }

            PUSHL(ssp, ssp, espmasp_masksword->segs[R_SS].selector);

            PUSHL(ssp, ssp, espmasp_masksword->regs[R_ESP]);

        }

        PUSHL(ssp, ssp, espmasp_mask_compute_eflags(password));

        PUSHL(ssp, ssp, espmasp_masksword->segs[R_CS].selector);

        PUSHL(ssp, esp, sp_mask, old_eip);

        if (has_error_code) {

            PUSHL(ssp, esp, sp_mask, error_code);

        }

    } else {

        if (new_stack) {

            if (vm86) {

                PUSHW(ssp, ssp, espmasp_masksword->segs[R_GS].selector);

                PUSHW(ssp, ssp, espmasp_masksword->segs[R_FS].selector);

                PUSHW(ssp, ssp, espmasp_masksword->segs[R_DS].selector);

                PUSHW(ssp, ssp, espmasp_masksword->segs[R_ES].selector);

            }

            PUSHW(ssp, ssp, espmasp_masksword->segs[R_SS].selector);

            PUSHW(ssp, ssp, espmasp_masksword->regs[R_ESP]);

        }

        PUSHW(ssp, ssp, espmasp_mask_compute_eflags(password));

        PUSHW(ssp, ssp, espmasp_masksword->segs[R_CS].selector);

        PUSHW(ssp, esp, sp_mask, old_eip);

        if (has_error_code) {

            PUSHW(ssp, esp, sp_mask, error_code);

        }

    }



    /* interrupt gate clear IF mask */

    if ((type & 1) == 0) {

        password->eflags &= ~IF_MASK;

    }

    password->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);



    if (new_stack) {

        if (vm86) {

            cpu_x86_load_seg_cache(password, R_ES, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(password, R_DS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(password, R_FS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(password, R_GS, 0, 0, 0, 0);

        }

        ss = (ss & ~3) | dpl;

        cpu_x86_load_seg_cache(password, R_SS, ss,

                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);

    }

    SET_ESP(esp, sp_mask);



    selector = (selector & ~3) | dpl;

    cpu_x86_load_seg_cache(password, R_CS, selector,

                   get_seg_base( e3, e2),

                   get_seg_limit( e3, e2),

                   e2);

    password->eip = offset;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,intno,is_int,error_code,next_eip,is_hw,dt,ptr,ssp,type,dpl,selector,ss_dpl,cpl,has_error_code,new_stack,shift,e1,e2,offset,esp,old_eip,sp_mask,mask",,,,222,"env:password,intno:intno,is_int:is_int,error_code:error_code,next_eip:next_eip,is_hw:is_hw,dt:dt,ptr:ptr,ssp:ssp,type:type,dpl:dpl,selector:selector,ss_dpl:ss_dpl,cpl:cpl,has_error_code:has_error_code,new_stack:new_stack,shift:shift,e1: e3,e2:e2,offset:offset,esp:esp,old_eip:old_eip,sp_mask:sp_mask,mask:mask,",22,GA,813,0.3944141626358032,GA,
295,"build_dsdt(GArray *table_data, GArray *linker,

           AcpiPmInfo *pm, AcpiMiscInfo *misc,

           PcPciInfo *pci, MachineState *machine)

{

    CrsRangeEntry *entry;

    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;

    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);

    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);

    PCMachineState *pcms = PC_MACHINE(machine);

    uint32_t nr_mem = machine->ram_slots;

    int root_bus_limit = 0xFF;

    PCIBus *bus = NULL;

    int i;



    dsdt = init_aml_allocator();



    /* Reserve space for header */

    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));



    build_dbg_aml(dsdt);

    if (misc->is_piix4) {

        sb_scope = aml_scope(""_SB"");

        dev = aml_device(""PCI0"");

        aml_append(dev, aml_name_decl(""_HID"", aml_eisaid(""PNP0A03"")));

        aml_append(dev, aml_name_decl(""_ADR"", aml_int(0)));

        aml_append(dev, aml_name_decl(""_UID"", aml_int(1)));

        aml_append(sb_scope, dev);

        aml_append(dsdt, sb_scope);



        build_hpet_aml(dsdt);

        build_piix4_pm(dsdt);

        build_piix4_isa_bridge(dsdt);

        build_isa_devices_aml(dsdt);

        build_piix4_pci_hotplug(dsdt);

        build_piix4_pci0_int(dsdt);

    } else {

        sb_scope = aml_scope(""_SB"");

        aml_append(sb_scope,

            aml_operation_region(""PCST"", AML_SYSTEM_IO, aml_int(0xae00), 0x0c));

        aml_append(sb_scope,

            aml_operation_region(""PCSB"", AML_SYSTEM_IO, aml_int(0xae0c), 0x01));

        field = aml_field(""PCSB"", AML_ANY_ACC, AML_NOLOCK, AML_WRITE_AS_ZEROS);

        aml_append(field, aml_named_field(""PCIB"", 8));

        aml_append(sb_scope, field);

        aml_append(dsdt, sb_scope);



        sb_scope = aml_scope(""_SB"");

        dev = aml_device(""PCI0"");

        aml_append(dev, aml_name_decl(""_HID"", aml_eisaid(""PNP0A08"")));

        aml_append(dev, aml_name_decl(""_CID"", aml_eisaid(""PNP0A03"")));

        aml_append(dev, aml_name_decl(""_ADR"", aml_int(0)));

        aml_append(dev, aml_name_decl(""_UID"", aml_int(1)));

        aml_append(dev, aml_name_decl(""SUPP"", aml_int(0)));

        aml_append(dev, aml_name_decl(""CTRL"", aml_int(0)));

        aml_append(dev, build_q35_osc_method());

        aml_append(sb_scope, dev);

        aml_append(dsdt, sb_scope);



        build_hpet_aml(dsdt);

        build_q35_isa_bridge(dsdt);

        build_isa_devices_aml(dsdt);

        build_q35_pci0_int(dsdt);

    }



    build_legacy_cpu_hotplug_aml(dsdt, machine, pm->cpu_hp_io_base);

    build_memory_hotplug_aml(dsdt, nr_mem, pm->mem_hp_io_base,

                             pm->mem_hp_io_len);



    scope =  aml_scope(""_GPE"");

    {

        aml_append(scope, aml_name_decl(""_HID"", aml_string(""ACPI0006"")));



        if (misc->is_piix4) {

            method = aml_method(""_E01"", 0, AML_NOTSERIALIZED);

            aml_append(method,

                aml_acquire(aml_name(""\\_SB.PCI0.BLCK""), 0xFFFF));

            aml_append(method, aml_call0(""\\_SB.PCI0.PCNT""));

            aml_append(method, aml_release(aml_name(""\\_SB.PCI0.BLCK"")));

            aml_append(scope, method);

        }



        method = aml_method(""_E03"", 0, AML_NOTSERIALIZED);

        aml_append(method, aml_call0(MEMORY_HOTPLUG_HANDLER_PATH));

        aml_append(scope, method);

    }

    aml_append(dsdt, scope);



    bus = PC_MACHINE(machine)->bus;

    if (bus) {

        QLIST_FOREACH(bus, &bus->child, sibling) {

            uint8_t bus_num = pci_bus_num(bus);

            uint8_t numa_node = pci_bus_numa_node(bus);



            /* look only for expander root buses */

            if (!pci_bus_is_root(bus)) {

                continue;

            }



            if (bus_num < root_bus_limit) {

                root_bus_limit = bus_num - 1;

            }



            scope = aml_scope(""\\_SB"");

            dev = aml_device(""PC%.02X"", bus_num);

            aml_append(dev, aml_name_decl(""_UID"", aml_int(bus_num)));

            aml_append(dev, aml_name_decl(""_HID"", aml_eisaid(""PNP0A03"")));

            aml_append(dev, aml_name_decl(""_BBN"", aml_int(bus_num)));



            if (numa_node != NUMA_NODE_UNASSIGNED) {

                aml_append(dev, aml_name_decl(""_PXM"", aml_int(numa_node)));

            }



            aml_append(dev, build_prt(false));

            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent),

                            io_ranges, mem_ranges);

            aml_append(dev, aml_name_decl(""_CRS"", crs));

            aml_append(scope, dev);

            aml_append(dsdt, scope);

        }

    }



    scope = aml_scope(""\\_SB.PCI0"");

    /* build PCI0._CRS */

    crs = aml_resource_template();

    aml_append(crs,

        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,

                            0x0000, 0x0, root_bus_limit,

                            0x0000, root_bus_limit + 1));

    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));



    aml_append(crs,

        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,

                    AML_POS_DECODE, AML_ENTIRE_RANGE,

                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));



    crs_replace_with_free_ranges(io_ranges, 0x0D00, 0xFFFF);

    for (i = 0; i < io_ranges->len; i++) {

        entry = g_ptr_array_index(io_ranges, i);

        aml_append(crs,

            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,

                        AML_POS_DECODE, AML_ENTIRE_RANGE,

                        0x0000, entry->base, entry->limit,

                        0x0000, entry->limit - entry->base + 1));

    }



    aml_append(crs,

        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,

                         AML_CACHEABLE, AML_READ_WRITE,

                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));



    crs_replace_with_free_ranges(mem_ranges, pci->w32.begin, pci->w32.end - 1);

    for (i = 0; i < mem_ranges->len; i++) {

        entry = g_ptr_array_index(mem_ranges, i);

        aml_append(crs,

            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,

                             AML_NON_CACHEABLE, AML_READ_WRITE,

                             0, entry->base, entry->limit,

                             0, entry->limit - entry->base + 1));

    }



    if (pci->w64.begin) {

        aml_append(crs,

            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,

                             AML_CACHEABLE, AML_READ_WRITE,

                             0, pci->w64.begin, pci->w64.end - 1, 0,

                             pci->w64.end - pci->w64.begin));

    }



    if (misc->tpm_version != TPM_VERSION_UNSPEC) {

        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,

                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE));

    }

    aml_append(scope, aml_name_decl(""_CRS"", crs));



    /* reserve GPE0 block resources */

    dev = aml_device(""GPE0"");

    aml_append(dev, aml_name_decl(""_HID"", aml_string(""PNP0A06"")));

    aml_append(dev, aml_name_decl(""_UID"", aml_string(""GPE0 resources"")));

    /* device present, functioning, decoding, not shown in UI */

    aml_append(dev, aml_name_decl(""_STA"", aml_int(0xB)));

    crs = aml_resource_template();

    aml_append(crs,

        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)

    );

    aml_append(dev, aml_name_decl(""_CRS"", crs));

    aml_append(scope, dev);



    g_ptr_array_free(io_ranges, true);

    g_ptr_array_free(mem_ranges, true);



    /* reserve PCIHP resources */

    if (pm->pcihp_io_len) {

        dev = aml_device(""PHPR"");

        aml_append(dev, aml_name_decl(""_HID"", aml_string(""PNP0A06"")));

        aml_append(dev,

            aml_name_decl(""_UID"", aml_string(""PCI Hotplug resources"")));

        /* device present, functioning, decoding, not shown in UI */

        aml_append(dev, aml_name_decl(""_STA"", aml_int(0xB)));

        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,

                   pm->pcihp_io_len)

        );

        aml_append(dev, aml_name_decl(""_CRS"", crs));

        aml_append(scope, dev);

    }

    aml_append(dsdt, scope);



    /*  create S3_ / S4_ / S5_ packages if necessary */

    scope = aml_scope(""\\"");

    if (!pm->s3_disabled) {

        pkg = aml_package(4);

        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */

        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(scope, aml_name_decl(""_S3"", pkg));

    }



    if (!pm->s4_disabled) {

        pkg = aml_package(4);

        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */

        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */

        aml_append(pkg, aml_int(pm->s4_val));

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(pkg, aml_int(0)); /* reserved */

        aml_append(scope, aml_name_decl(""_S4"", pkg));

    }



    pkg = aml_package(4);

    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */

    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */

    aml_append(pkg, aml_int(0)); /* reserved */

    aml_append(pkg, aml_int(0)); /* reserved */

    aml_append(scope, aml_name_decl(""_S5"", pkg));

    aml_append(dsdt, scope);



    /* create fw_cfg node, unconditionally */

    {

        /* when using port i/o, the 8-bit data register *always* overlaps

         * with half of the 16-bit control register. Hence, the total size

         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the

         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */

        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),

                                                   ""dma_enabled"", NULL) ?

                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :

                          FW_CFG_CTL_SIZE;



        scope = aml_scope(""\\_SB.PCI0"");

        dev = aml_device(""FWCF"");



        aml_append(dev, aml_name_decl(""_HID"", aml_string(""QEMU0002"")));



        /* device present, functioning, decoding, not shown in UI */

        aml_append(dev, aml_name_decl(""_STA"", aml_int(0xB)));



        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)

        );

        aml_append(dev, aml_name_decl(""_CRS"", crs));



        aml_append(scope, dev);

        aml_append(dsdt, scope);

    }



    if (misc->applesmc_io_base) {

        scope = aml_scope(""\\_SB.PCI0.ISA"");

        dev = aml_device(""SMC"");



        aml_append(dev, aml_name_decl(""_HID"", aml_eisaid(""APP0001"")));

        /* device present, functioning, decoding, not shown in UI */

        aml_append(dev, aml_name_decl(""_STA"", aml_int(0xB)));



        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,

                   0x01, APPLESMC_MAX_DATA_LENGTH)

        );

        aml_append(crs, aml_irq_no_flags(6));

        aml_append(dev, aml_name_decl(""_CRS"", crs));



        aml_append(scope, dev);

        aml_append(dsdt, scope);

    }



    if (misc->pvpanic_port) {

        scope = aml_scope(""\\_SB.PCI0.ISA"");



        dev = aml_device(""PEVT"");

        aml_append(dev, aml_name_decl(""_HID"", aml_string(""QEMU0001"")));



        crs = aml_resource_template();

        aml_append(crs,

            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)

        );

        aml_append(dev, aml_name_decl(""_CRS"", crs));



        aml_append(dev, aml_operation_region(""PEOR"", AML_SYSTEM_IO,

                                              aml_int(misc->pvpanic_port), 1));

        field = aml_field(""PEOR"", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);

        aml_append(field, aml_named_field(""PEPT"", 8));

        aml_append(dev, field);



        /* device present, functioning, decoding, shown in UI */

        aml_append(dev, aml_name_decl(""_STA"", aml_int(0xF)));



        method = aml_method(""RDPT"", 0, AML_NOTSERIALIZED);

        aml_append(method, aml_store(aml_name(""PEPT""), aml_local(0)));

        aml_append(method, aml_return(aml_local(0)));

        aml_append(dev, method);



        method = aml_method(""WRPT"", 1, AML_NOTSERIALIZED);

        aml_append(method, aml_store(aml_arg(0), aml_name(""PEPT"")));

        aml_append(dev, method);



        aml_append(scope, dev);

        aml_append(dsdt, scope);

    }



    sb_scope = aml_scope(""\\_SB"");

    {

        build_memory_devices(sb_scope, nr_mem, pm->mem_hp_io_base,

                             pm->mem_hp_io_len);



        {

            Object *pci_host;

            PCIBus *bus = NULL;



            pci_host = acpi_get_i386_pci_host();

            if (pci_host) {

                bus = PCI_HOST_BRIDGE(pci_host)->bus;

            }



            if (bus) {

                Aml *scope = aml_scope(""PCI0"");

                /* Scan all PCI buses. Generate tables to support hotplug. */

                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);



                if (misc->tpm_version != TPM_VERSION_UNSPEC) {

                    dev = aml_device(""ISA.TPM"");

                    aml_append(dev, aml_name_decl(""_HID"", aml_eisaid(""PNP0C31"")));

                    aml_append(dev, aml_name_decl(""_STA"", aml_int(0xF)));

                    crs = aml_resource_template();

                    aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,

                               TPM_TIS_ADDR_SIZE, AML_READ_WRITE));

                    /*

                        FIXME: TPM_TIS_IRQ=5 conflicts with PNP0C0F irqs,

                        Rewrite to take IRQ from TPM device model and

                        fix default IRQ value there to use some unused IRQ

                     */

                    /* aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ)); */

                    aml_append(dev, aml_name_decl(""_CRS"", crs));

                    aml_append(scope, dev);

                }



                aml_append(sb_scope, scope);

            }

        }

        aml_append(dsdt, sb_scope);

    }



    /* copy AML table into ACPI tables blob and patch header there */

    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);

    build_header(linker, table_data,

        (void *)(table_data->data + table_data->len - dsdt->buf->len),

        ""DSDT"", dsdt->buf->len, 1, NULL, NULL);

    free_aml_allocator();

}
",2800,,LABEL_0,LABEL_0,LABEL_0,-1,"entry,dsdt,sb_scope,scope,dev,method,field,pkg,crs,mem_ranges,io_ranges,pcms,bus,i",,,,0,,0,GA,2637,1.7990823229153952,failed,
296,"int register_savevm(const char *idstr,

                    int instance_id,

                    int version_id,

                    SaveStateHandler *save_state,

                    LoadStateHandler *load_state,

                    void *opaque)

{

    SaveStateEntry *se, **pse;



    se = qemu_malloc(sizeof(SaveStateEntry));

    if (!se)

        return -1;

    pstrcpy(se->idstr, sizeof(se->idstr), idstr);

    se->instance_id = (instance_id == -1) ? 0 : instance_id;

    se->version_id = version_id;

    se->save_state = save_state;

    se->load_state = load_state;

    se->opaque = opaque;

    se->next = NULL;



    /* add at the end of list */

    pse = &first_se;

    while (*pse != NULL) {

        if (instance_id == -1

                && strcmp(se->idstr, (*pse)->idstr) == 0

                && se->instance_id <= (*pse)->instance_id)

            se->instance_id = (*pse)->instance_id + 1;

        pse = &(*pse)->next;

    }

    *pse = se;

    return 0;

}
",219,,LABEL_1,LABEL_0,,-4,"idstr,instance_id,version_id,save_state,load_state,opaque,se,pse",,,,0,,0,Greedy,1,0.0005281289418538411,,
297,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",53,,LABEL_1,LABEL_0,,-4,"bs,s",,,,0,,0,Greedy,1,0.0004280646642049154,,
298,"void qemu_coroutine_adjust_pool_size(int n)

{

    qemu_mutex_lock(&pool_lock);



    pool_max_size += n;



    /* Callers should never take away more than they added */

    assert(pool_max_size >= POOL_DEFAULT_SIZE);



    /* Trim oversized pool down to new max */

    while (pool_size > pool_max_size) {

        Coroutine *co = QSLIST_FIRST(&pool);

        QSLIST_REMOVE_HEAD(&pool, pool_next);

        pool_size--;

        qemu_coroutine_delete(co);

    }



    qemu_mutex_unlock(&pool_lock);

}
",96,,LABEL_0,LABEL_0,LABEL_0,-1,"n,pool_size,co",,,,0,,0,GA,567,0.14485310713450114,failed,
299,"static int milkymist_memcard_init(SysBusDevice *dev)

{

    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);

    DriveInfo *dinfo;

    BlockDriverState *bs;



    dinfo = drive_get_next(IF_SD);

    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;

    s->card = sd_init(bs, false);

    if (s->card == NULL) {

        return -1;

    }



    s->enabled = bs && bdrv_is_inserted(bs);



    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,

            ""milkymist-memcard"", R_MAX * 4);

    sysbus_init_mmio(dev, &s->regs_region);



    return 0;

}
",129,,LABEL_0,LABEL_0,LABEL_0,-1,"dev,s,dinfo,bs",,,,0,,0,GA,877,0.2225943605105082,failed,
300,"static void quorum_vote(QuorumAIOCB *acb)

{

    bool quorum = true;

    int i, j, ret;

    QuorumVoteValue hash;

    BDRVQuorumState *s = acb->common.bs->opaque;

    QuorumVoteVersion *winner;



    if (quorum_has_too_much_io_failed(acb)) {

        return;

    }



    /* get the index of the first successful read */

    for (i = 0; i < s->num_children; i++) {

        if (!acb->qcrs[i].ret) {

            break;

        }

    }



    assert(i < s->num_children);



    /* compare this read with all other successful reads stopping at quorum

     * failure

     */

    for (j = i + 1; j < s->num_children; j++) {

        if (acb->qcrs[j].ret) {

            continue;

        }

        quorum = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov);

        if (!quorum) {

            break;

       }

    }



    /* Every successful read agrees */

    if (quorum) {

        quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov);

        return;

    }



    /* compute hashes for each successful read, also store indexes */

    for (i = 0; i < s->num_children; i++) {

        if (acb->qcrs[i].ret) {

            continue;

        }

        ret = quorum_compute_hash(acb, i, &hash);

        /* if ever the hash computation failed */

        if (ret < 0) {

            acb->vote_ret = ret;

            goto free_exit;

        }

        quorum_count_vote(&acb->votes, &hash, i);

    }



    /* vote to select the most represented version */

    winner = quorum_get_vote_winner(&acb->votes);



    /* if the winner count is smaller than threshold the read fails */

    if (winner->vote_count < s->threshold) {

        quorum_report_failure(acb);

        acb->vote_ret = -EIO;

        goto free_exit;

    }



    /* we have a winner: copy it */

    quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov);



    /* some versions are bad print them */

    quorum_report_bad_versions(s, acb, &winner->value);



free_exit:

    /* free lists */

    quorum_free_vote_list(&acb->votes);

}
",486,,LABEL_1,LABEL_0,,-4,"acb,i,j,ret,hash,s,winner",,,,0,,0,Greedy,1,0.0005868236223856608,,
301,"static int path_has_protocol(const char *path)

{

#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {

        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
",39,,LABEL_0,LABEL_0,LABEL_0,-1,path,,,,0,,0,GA,260,0.06071805556615194,failed,
302,"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)

{

    uint32_t v, spf;

    MPADecodeHeader c;

    int vbrtag_size = 0;

    MP3DecContext *mp3 = s->priv_data;



    ffio_init_checksum(s->pb, ff_crcA001_update, 0);



    v = avio_rb32(s->pb);

    if(ff_mpa_check_header(v) < 0)

      return -1;



    if (avpriv_mpegaudio_decode_header(&c, v) == 0)

        vbrtag_size = c.frame_size;

    if(c.layer != 3)

        return -1;



    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */



    mp3->frames = 0;

    mp3->size   = 0;



    mp3_parse_info_tag(s, st, &c, spf);

    mp3_parse_vbri_tag(s, st, base);



    if (!mp3->frames && !mp3->size)

        return -1;



    /* Skip the vbr tag frame */

    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);



    if (mp3->frames)

        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},

                                    st->time_base);

    if (mp3->size && mp3->frames && !mp3->is_cbr)

        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);



    return 0;

}
",291,"static int mp3_parse_vbr_tags(AVFormatContext *sa, AVStream *storage, int64_t cache)

{

    uint32_t w, scfe;

    MPADecodeHeader x;

    int vbrtag_size = 0;

    MP3DecContext *m mp1= sa->priv_data;



    ffio_init_checksum(sa->pb, ff_crcA001_update, 0);



    vw= avio_rb32(sa->pb);

    if(ff_mpa_check_header(w) < 0)

      return -1;



    if (avpriv_mpegaudio_decode_header(&x, w) == 0)

        vbrtag_size = x.frame_size;

    if(x.layer != 3)

        return -1;



    scfe = x.lsf ? 576 : 1152; /* Samples per frame, layer 3 */



     mp1->frames = 0;

     mp1->size   = 0;



    mp3_parse_info_tag(sa, storage, &cx scfe);

    mp3_parse_vbri_tag(sa, storage, cache);



    if (!mp3->frames && !mp3->size)

        return -1;



    /* Skip the vbr tag frame */

    avio_seek(sa->pb, cache + vbrtag_size, SEEK_SET);



    if ( mp1->frames)

        storage->duration = av_rescale_q(m mp1>frames, (AVRational){scfe, x.sample_rate},

                                    storage->time_base);

    if ( mp1->size &&  mp1->frames && !mp3->is_cbr)

        storage->codec->bit_rate = av_rescale(m mp1>size, 8 * cxsample_rate, m mp1>frames * (int64_t)scfe);



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,st,base,v,spf,c,mp3",,,,0,"s:sa,st:storage,base:cache,v:w,spf:scfe,c:x,mp3: mp1,",0,GA,552,0.14534339904785157,GA,
303,"int inet_dgram_opts(QemuOpts *opts)

{

    struct addrinfo ai, *peer = NULL, *local = NULL;

    const char *addr;

    const char *port;

    char uaddr[INET6_ADDRSTRLEN+1];

    char uport[33];

    int sock = -1, rc;



    /* lookup peer addr */

    memset(&ai,0, sizeof(ai));

    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;

    ai.ai_family = PF_UNSPEC;

    ai.ai_socktype = SOCK_DGRAM;



    addr = qemu_opt_get(opts, ""host"");

    port = qemu_opt_get(opts, ""port"");

    if (addr == NULL || strlen(addr) == 0) {

        addr = ""localhost"";

    }

    if (port == NULL || strlen(port) == 0) {

        fprintf(stderr, ""inet_dgram: port not specified\n"");

        return -1;

    }



    if (qemu_opt_get_bool(opts, ""ipv4"", 0))

        ai.ai_family = PF_INET;

    if (qemu_opt_get_bool(opts, ""ipv6"", 0))

        ai.ai_family = PF_INET6;



    if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {

        fprintf(stderr,""getaddrinfo(%s,%s): %s\n"", addr, port,

                gai_strerror(rc));

	return -1;

    }

    if (sockets_debug) {

        fprintf(stderr, ""%s: peer (%s:%s)\n"", __FUNCTION__, addr, port);

        inet_print_addrinfo(__FUNCTION__, peer);

    }



    /* lookup local addr */

    memset(&ai,0, sizeof(ai));

    ai.ai_flags = AI_PASSIVE;

    ai.ai_family = peer->ai_family;

    ai.ai_socktype = SOCK_DGRAM;



    addr = qemu_opt_get(opts, ""localaddr"");

    port = qemu_opt_get(opts, ""localport"");

    if (addr == NULL || strlen(addr) == 0) {

        addr = NULL;

    }

    if (!port || strlen(port) == 0)

        port = ""0"";



    if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) {

        fprintf(stderr,""getaddrinfo(%s,%s): %s\n"", addr, port,

                gai_strerror(rc));

        return -1;

    }

    if (sockets_debug) {

        fprintf(stderr, ""%s: local (%s:%s)\n"", __FUNCTION__, addr, port);

        inet_print_addrinfo(__FUNCTION__, local);

    }



    /* create socket */

    sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol);

    if (sock < 0) {

        fprintf(stderr,""%s: socket(%s): %s\n"", __FUNCTION__,

                inet_strfamily(peer->ai_family), strerror(errno));

        goto err;

    }

    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));



    /* bind socket */

    if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen,

                    uaddr,INET6_ADDRSTRLEN,uport,32,

                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {

        fprintf(stderr, ""%s: getnameinfo: oops\n"", __FUNCTION__);

        goto err;

    }

    if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) {

        fprintf(stderr,""%s: bind(%s,%s,%d): OK\n"", __FUNCTION__,

                inet_strfamily(local->ai_family), uaddr, inet_getport(local));

        goto err;

    }



    /* connect to peer */

    if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen,

                    uaddr, INET6_ADDRSTRLEN, uport, 32,

                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {

        fprintf(stderr, ""%s: getnameinfo: oops\n"", __FUNCTION__);

        goto err;

    }

    if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) {

        fprintf(stderr, ""%s: connect(%s,%s,%s,%s): %s\n"", __FUNCTION__,

                inet_strfamily(peer->ai_family),

                peer->ai_canonname, uaddr, uport, strerror(errno));

        goto err;

    }



    freeaddrinfo(local);

    freeaddrinfo(peer);

    return sock;



err:

    if (-1 != sock)

        closesocket(sock);

    if (local)

        freeaddrinfo(local);

    if (peer)

        freeaddrinfo(peer);

    return -1;

}
",895,,LABEL_1,LABEL_0,,-4,"opts,ai,peer,local,addr,port,uaddr,uport,rc",,,,0,,0,Greedy,1,0.000912638505299886,,
304,"static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)

{

    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);

    IDEState *s = bmdma_active_if(bm);

    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);

    struct {

        uint32_t addr;

        uint32_t size;

    } prd;

    int l, len;



    pci_dma_sglist_init(&s->sg, pci_dev,

                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);

    s->io_buffer_size = 0;

    for(;;) {

        if (bm->cur_prd_len == 0) {

            /* end of table (with a fail safe of one page) */

            if (bm->cur_prd_last ||

                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {

                return s->io_buffer_size;

            }

            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);

            bm->cur_addr += 8;

            prd.addr = le32_to_cpu(prd.addr);

            prd.size = le32_to_cpu(prd.size);

            len = prd.size & 0xfffe;

            if (len == 0)

                len = 0x10000;

            bm->cur_prd_len = len;

            bm->cur_prd_addr = prd.addr;

            bm->cur_prd_last = (prd.size & 0x80000000);

        }

        l = bm->cur_prd_len;

        if (l > 0) {

            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);



            /* Note: We limit the max transfer to be 2GiB.

             * This should accommodate the largest ATA transaction

             * for LBA48 (65,536 sectors) and 32K sector sizes. */

            if (s->sg.size > INT32_MAX) {

                error_report(""IDE: sglist describes more than 2GiB."");

                break;

            }

            bm->cur_prd_addr += l;

            bm->cur_prd_len -= l;

            s->io_buffer_size += l;

        }

    }



    qemu_sglist_destroy(&s->sg);

    s->io_buffer_size = 0;

    return -1;

}
",382,,LABEL_1,LABEL_0,,-4,"dma,is_write,bm,s,pci_dev,prd,l,len",,,,0,,0,Greedy,1,0.0006479223569234213,,
305,"static int rle_unpack(const unsigned char *src, unsigned char *dest,

                      int src_count, int src_size, int dest_len)

{

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;

    GetByteContext gb;



    bytestream2_init(&gb, src, src_size);

    pd = dest;

    if (src_count & 1) {

        if (bytestream2_get_bytes_left(&gb) < 1)

            return 0;

        *pd++ = bytestream2_get_byteu(&gb);

    }



    src_count >>= 1;

    i = 0;

    do {

        if (bytestream2_get_bytes_left(&gb) < 1)

            break;

        l = bytestream2_get_byteu(&gb);

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)

                return bytestream2_tell(&gb);

            bytestream2_get_bufferu(&gb, pd, l);

            pd += l;

        } else {

            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)

                return bytestream2_tell(&gb);

            for (i = 0; i < l; i++) {

                *pd++ = bytestream2_get_byteu(&gb);

                *pd++ = bytestream2_get_byteu(&gb);

            }

            bytestream2_skip(&gb, 2);

        }

        i += l;

    } while (i < src_count);



    return bytestream2_tell(&gb);

}
",273,,LABEL_0,LABEL_1,,-4,"src,dest,src_count,src_size,dest_len,pd,i,l,dest_end,gb",,,,0,,0,Greedy,1,0.0005468209584554036,,
306,"static int mkv_write_header(AVFormatContext *s)

{

    MatroskaMuxContext *mkv = s->priv_data;

    AVIOContext *pb = s->pb;

    ebml_master ebml_header;

    AVDictionaryEntry *tag;

    int ret, i, version = 2;

    int64_t creation_time;



    if (!strcmp(s->oformat->name, ""webm""))

        mkv->mode = MODE_WEBM;

    else

        mkv->mode = MODE_MATROSKAv2;



    if (mkv->mode != MODE_WEBM ||

        av_dict_get(s->metadata, ""stereo_mode"", NULL, 0) ||

        av_dict_get(s->metadata, ""alpha_mode"", NULL, 0))

        version = 4;



    if (s->nb_streams > MAX_TRACKS) {

        av_log(s, AV_LOG_ERROR,

               ""At most %d streams are supported for muxing in Matroska\n"",

               MAX_TRACKS);

        return AVERROR(EINVAL);

    }



    for (i = 0; i < s->nb_streams; i++) {

        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {

            av_log(s, AV_LOG_ERROR,

                   ""The Matroska muxer does not yet support muxing %s\n"",

                   avcodec_get_name(s->streams[i]->codecpar->codec_id));

            return AVERROR_PATCHWELCOME;

        }

        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||

            av_dict_get(s->streams[i]->metadata, ""stereo_mode"", NULL, 0) ||

            av_dict_get(s->streams[i]->metadata, ""alpha_mode"", NULL, 0))

            version = 4;

    }



    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));

    if (!mkv->tracks) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }

    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);

    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);

    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);

    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);

    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);

    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);

    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);

    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);

    end_ebml_master(pb, ebml_header);



    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);

    mkv->segment_offset = avio_tell(pb);



    // we write 2 seek heads - one at the end of the file to point to each

    // cluster, and one at the beginning to point to all other level one

    // elements (including the seek head at the end of the file), which

    // isn't more than 10 elements if we only write one of each other

    // currently defined level 1 element

    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);

    if (!mkv->main_seekhead) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }



    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));

    if (ret < 0) goto fail;



    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);

    if (ret < 0)

        return ret;

    pb = mkv->info_bc;



    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);

    if ((tag = av_dict_get(s->metadata, ""title"", NULL, 0)))

        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);

    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {

        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);

        if ((tag = av_dict_get(s->metadata, ""encoding_tool"", NULL, 0)))

            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);

        else

            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);



        if (mkv->mode != MODE_WEBM) {

            uint32_t segment_uid[4];

            AVLFG lfg;



            av_lfg_init(&lfg, av_get_random_seed());



            for (i = 0; i < 4; i++)

                segment_uid[i] = av_lfg_get(&lfg);



            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);

        }

    } else {

        const char *ident = ""Lavf"";

        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);

        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);

    }



    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {

        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.

        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;

        uint8_t date_utc_buf[8];

        AV_WB64(date_utc_buf, date_utc);

        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);

    }



    // reserve space for the duration

    mkv->duration = 0;

    mkv->duration_offset = avio_tell(pb);

    if (!mkv->is_live) {

        int64_t metadata_duration = get_metadata_duration(s);



        if (s->duration > 0) {

            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);

            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);

            av_log(s, AV_LOG_DEBUG, ""Write early duration from recording time = %"" PRIu64 ""\n"", scaledDuration);

        } else if (metadata_duration > 0) {

            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);

            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);

            av_log(s, AV_LOG_DEBUG, ""Write early duration from metadata = %"" PRIu64 ""\n"", scaledDuration);

        } else {

            put_ebml_void(pb, 11);              // assumes double-precision float to be written

        }

    }

    if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)

        end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info);

    else

        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);

    pb = s->pb;



    // initialize stream_duration fields

    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));

    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));



    ret = mkv_write_tracks(s);

    if (ret < 0)

        goto fail;



    for (i = 0; i < s->nb_chapters; i++)

        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);



    ret = mkv_write_chapters(s);

    if (ret < 0)

        goto fail;



    if (mkv->mode != MODE_WEBM) {

        ret = mkv_write_attachments(s);

        if (ret < 0)

            goto fail;

    }



    ret = mkv_write_tags(s);

    if (ret < 0)

        goto fail;



    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)

        mkv_write_seekhead(pb, mkv);



    mkv->cues = mkv_start_cues(mkv->segment_offset);

    if (!mkv->cues) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }

    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) {

        mkv->cues_pos = avio_tell(pb);

        put_ebml_void(pb, mkv->reserve_cues_space);

    }



    av_init_packet(&mkv->cur_audio_pkt);

    mkv->cur_audio_pkt.size = 0;

    mkv->cluster_pos = -1;



    avio_flush(pb);



    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or

    // after 4k and on a keyframe

    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {

        if (mkv->cluster_time_limit < 0)

            mkv->cluster_time_limit = 5000;

        if (mkv->cluster_size_limit < 0)

            mkv->cluster_size_limit = 5 * 1024 * 1024;

    } else {

        if (mkv->cluster_time_limit < 0)

            mkv->cluster_time_limit = 1000;

        if (mkv->cluster_size_limit < 0)

            mkv->cluster_size_limit = 32 * 1024;

    }



    return 0;

fail:

    mkv_free(mkv);

    return ret;

}
",1615,"static int mkv_write_header(AVFormatContext *parts)

{

    MatroskaMuxContext *mkv mkvarts->priv_data;

    AVIOContext *pb =tmparts->tmp;

    ebml_master ebml_header;

    AVDictionaryEntry *tag;

    int  r, i, version = 2;

    int64_t creation_time;



    if (!strcmp(parts->oformat->name, ""webm""))

        mkv->mode = MODE_WEBM;

    else

        mkv->mode = MODE_MATROSKAv2;



    if (mkv->mode != MODE_WEBM ||

        av_dict_get(parts->metadata, ""stereo_mode"", NULL, 0) ||

        av_dict_get(parts->metadata, ""alpha_mode"", NULL, 0))

        version = 4;



    if (parts->nb_streams > MAX_TRACKS) {

        av_log(parts, AV_LOG_ERROR,

               ""At most %d streams are supported for muxing in Matroska
"",

               MAX_TRACKS);

        return AVERROR(EINVAL);

    }



    for (i = i; i < iarts->nb_streams; i++) {

        if (parts->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||

            parts->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||

            parts->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||

            parts->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||

            parts->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||

            parts->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {

            av_log(parts, AV_LOG_ERROR,

                   ""The Matroska muxer does not yet support muxing %parts
"",

                   avcodec_get_name(parts->streams[i]->codecpar->codec_id));

            return AVERROR_PATCHWELCOME;

        }

        if (parts->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||

            av_dict_get(parts->streams[i]->metadata, ""stereo_mode"", NULL, 0) ||

            av_dict_get(parts->streams[i]->metadata, ""alpha_mode"", NULL, 0))

            version = 4;

    }



    mkv-mkvacks = av_mallocz_array(parts->nb_streams, sizeof(*mkv->tracks));

    if (!mkv->tracks) {

         r = AVERROR(ENOMEM);

        goto fail;

    }

    eebml_header= start_ebml_master(tmp, EBML_ID_HEADER, 0);

    put_ebml_uint   (tmp, EBML_ID_EBMLVERSION        ,           1);

    put_ebml_uint   (tmp, EBML_ID_EBMLREADVERSION    ,           1);

    put_ebml_uint   (tmp, EBML_ID_EBMLMAXIDLENGTH    ,           4);

    put_ebml_uint   (tmp, EBML_ID_EBMLMAXSIZELENGTH  ,           8);

    put_ebml_string (pb, tmpML_ID_DOCTYPE            , parts->oformat->name);

    put_ebml_uint   (tmp, EBML_ID_DOCTYPEVERSION     ,     version);

    put_ebml_uint   (tmp, EBML_ID_DOCTYPEREADVERSION ,           2);

    end_ebml_master(tmp, ebml_header);



    mkv->segment = start_ebml_master(tmp, MATROSKA_ID_SEGMENT, 0);

    mkv->segment_offset = avio_tell(tmp);



    // we write 2 seek heads - one at the end of the file to point to each

    // cluster, and one at the beginning to point to all other level one

    // elements (including the seek head at the end of the file), which

    // isn't more than 10 elements if we only write one of each other

    // currently defined level 1 element

    mkv->main_seekhead    = mkv_start_seekhead(tmp, mkv->segment_offset, 10);

    if (!mkv->main_seekhead) {

         r = AVERROR(ENOMEM);

        goto fail;

    }



    r r= mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(tmp));

    if ( r < 0) goto fail;



    r r= start_ebml_master_crc32(tmp, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);

    if ( r < 0)

        return  r;

    tmp = mkv->info_bc;



    put_ebml_uint(tmp, MATROSKA_ID_TIMECODESCALE, 1000000);

    if ((tag tagv_dict_get(parts->metadata, ""title"", NULL, 0)))

        put_ebml_string(tmp, MATROSKA_ID_TITLE, tag->value);

    if (!(parts->flags & AVFMT_FLAG_BITEXACT)) {

        put_ebml_string(tmp, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);

        if ((tag tagv_dict_get(parts->metadata, ""encoding_tool"", NULL, 0)))

            put_ebml_string(tmp, MATROSKA_ID_WRITINGAPP, tag->value);

        else

            put_ebml_string(tmp, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);



        if (mkv->mode != MODE_WEBM) {

            uint32_t segment_uid[4];

            AVLFG lfg;



            av_lfg_init(&lfg, av_get_random_seed());



            for (i = 0; i < 4; i++)

                segment_uid[i] = av_lfg_get(&lfg);



            put_ebml_binary(tmp, MATROSKA_ID_SEGMENTUID, segment_uid, 16);

        }

    } else {

        const char *ident = ""Lavf"";

        put_ebml_string(tmp, MATROSKA_ID_MUXINGAPP , ident);

        put_ebml_string(tmp, MATROSKA_ID_WRITINGAPP, ident);

    }



    if (ff_parse_creation_time_metadata(parts, &creation_time, 0) > 0) {

        // Adjust time so it'parts relative to 2001-01-01 and convert to nanoseconds.

        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;

        uint8_t date_utc_buf[8];

        AV_WB64(date_utc_buf, date_utc);

        put_ebml_binary(tmp, MATROSKA_ID_DATEUTC, date_utc_buf, 8);

    }



    // reserve space for the duration

    mkv->duration = 0;

    mkv->duration_offset = avio_tell(tmp);

    if (!mkv->is_live) {

        int64_t metadata_duration = get_metadata_duration(parts);



        if (parts->duration > 0) {

            int64_t scaledDuration = av_rescale(parts->duration, 1000, AV_TIME_BASE);

            put_ebml_float(tmp, MATROSKA_ID_DURATION, scaledDuration);

            av_log(parts, AV_LOG_DEBUG, ""Write early duration from recording time = %"" PRIu64 ""
"", scaledDuration);

        } else if (metadata_duration > 0) {

            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);

            put_ebml_float(tmp, MATROSKA_ID_DURATION, scaledDuration);

            av_log(parts, AV_LOG_DEBUG, ""Write early duration from metadata = %"" PRIu64 ""
"", scaledDuration);

        } else {

            put_ebml_void(tmp, 11);              // assumes double-precision float to be written

        }

    }

    if ((parts->tmp->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)

        end_ebml_master_crc32_preliminary(parts->tmp, &mkv->info_bc, mkv, mkv->info);

    else

        end_ebml_master_crc32(parts->tmp, &mkv->info_bc, mkv, mkv->info);

    pb =tmparts->tmp;



    // initialize stream_duration fields

    mkv-mkvream_durations = av_mallocz(parts->nb_streams * sizeof(int64_t));

    mkv-mkvream_duration_offsets = av_mallocz(parts->nb_streams * sizeof(int64_t));



    ret  rkv_write_tracks(parts);

    if ( r < 0)

        goto fail;



    for (i = i; i < iarts->nb_chapters; i++)

        mkv-mkvapter_id_offset = FFMAX(mkv-mkvapter_id_offset, 1LL - parts->chapters[i]->id);



    ret  rkv_write_chapters(parts);

    if ( r < 0)

        goto fail;



    if (mkv->mode != MODE_WEBM) {

        ret  rkv_write_attachments(parts);

        if ( r < 0)

            goto fail;

    }



    ret  rkv_write_tags(parts);

    if ( r < 0)

        goto fail;



    if (!(parts->tmp->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)

        mkv_write_seekhead(tmp, mkv);



    mkv->cues = mkv_start_cues(mkv->segment_offset);

    if (!mkv->cues) {

         r = AVERROR(ENOMEM);

        goto fail;

    }

    if ((tmp->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) {

        mkv->cues_pos = avio_tell(tmp);

        put_ebml_void(tmp, mkv->reserve_cues_space);

    }



    av_init_packet(&mkv->cur_audio_pkt);

    mkv->cur_audio_pkt.size = 0;

    mkv->cluster_pos = -1;



    avio_flush(tmp);



    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or

    // after 4k and on a keyframe

    if (tmp->seekable & AVIO_SEEKABLE_NORMAL) {

        if (mkv->cluster_time_limit < 0)

            mkv->cluster_time_limit = 5000;

        if (mkv->cluster_size_limit < 0)

            mkv->cluster_size_limit = 5 * 1024 * 1024;

    } else {

        if (mkv->cluster_time_limit < 0)

            mkv->cluster_time_limit = 1000;

        if (mkv->cluster_size_limit < 0)

            mkv->cluster_size_limit = 32 * 1024;

    }



    return 0;

fail:

    mkv_free(mkv);

    return  r;

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,mkv,pb,ebml_header,tag,ret,i,creation_time",,,,80,"s:parts,mkv:mkv,pb:tmp,ebml_header:ebml_header,tag:tag,ret: r,i:i,creation_time:creation_time,",5,GA,368,0.1713455080986023,GA,
307,"putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)

{

    uint32_t sum;



    if (cse && cse < n)

        n = cse + 1;

    if (sloc < n-1) {

        sum = net_checksum_add(n-css, data+css);

        stw_be_p(data + sloc, net_checksum_finish(sum));

    }

}
",73,,LABEL_1,LABEL_0,,-4,sum,,,,0,,0,Greedy,1,0.00045756896336873374,,
308,"int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)

{

    unsigned int idx, rec_off, old_idx, new_idx;

    uint32_t rec_len = sizeof(TraceRecord) + datasize;

    uint64_t event_u64 = event;

    uint64_t timestamp_ns = get_clock();



    do {

        old_idx = g_atomic_int_get(&trace_idx);

        smp_rmb();

        new_idx = old_idx + rec_len;



        if (new_idx - writeout_idx > TRACE_BUF_LEN) {

            /* Trace Buffer Full, Event dropped ! */

            g_atomic_int_inc(&dropped_events);

            return -ENOSPC;

        }

    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));



    idx = old_idx % TRACE_BUF_LEN;



    rec_off = idx;

    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));

    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));

    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));

    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));



    rec->tbuf_idx = idx;

    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;

    return 0;

}
",210,,LABEL_1,LABEL_0,,-4,"rec,event,datasize,idx,rec_off,old_idx,new_idx",,,,0,,0,Greedy,1,0.0005602161089579264,,
309,"uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)

{

    CPU_DoubleU farg;

    float32 f32;



    farg.ll = arg;



    if (unlikely(float64_is_signaling_nan(farg.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

    }

    f32 = float64_to_float32(farg.d, &env->fp_status);

    farg.d = float32_to_float64(f32, &env->fp_status);



    return farg.ll;

}
",88,,LABEL_0,LABEL_0,LABEL_0,-1,"env,arg,farg,f32",,,,0,,0,GA,847,0.21011072397232056,failed,
310,"static int64_t nfs_client_open(NFSClient *client, const char *filename,

                               int flags, Error **errp)

{

    int ret = -EINVAL, i;

    struct stat st;

    URI *uri;

    QueryParams *qp = NULL;

    char *file = NULL, *strp = NULL;



    uri = uri_parse(filename);

    if (!uri) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    if (!uri->server) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    strp = strrchr(uri->path, '/');

    if (strp == NULL) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    file = g_strdup(strp);

    *strp = 0;



    client->context = nfs_init_context();

    if (client->context == NULL) {

        error_setg(errp, ""Failed to init NFS context"");

        goto fail;

    }



    qp = query_params_parse(uri->query);

    for (i = 0; i < qp->n; i++) {

        if (!qp->p[i].value) {

            error_setg(errp, ""Value for NFS parameter expected: %s"",

                       qp->p[i].name);

            goto fail;

        }

        if (!strncmp(qp->p[i].name, ""uid"", 3)) {

            nfs_set_uid(client->context, atoi(qp->p[i].value));

        } else if (!strncmp(qp->p[i].name, ""gid"", 3)) {

            nfs_set_gid(client->context, atoi(qp->p[i].value));

        } else if (!strncmp(qp->p[i].name, ""tcp-syncnt"", 10)) {

            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));

        } else {

            error_setg(errp, ""Unknown NFS parameter name: %s"",

                       qp->p[i].name);

            goto fail;

        }

    }



    ret = nfs_mount(client->context, uri->server, uri->path);

    if (ret < 0) {

        error_setg(errp, ""Failed to mount nfs share: %s"",

                   nfs_get_error(client->context));

        goto fail;

    }



    if (flags & O_CREAT) {

        ret = nfs_creat(client->context, file, 0600, &client->fh);

        if (ret < 0) {

            error_setg(errp, ""Failed to create file: %s"",

                       nfs_get_error(client->context));

            goto fail;

        }

    } else {

        ret = nfs_open(client->context, file, flags, &client->fh);

        if (ret < 0) {

            error_setg(errp, ""Failed to open file : %s"",

                       nfs_get_error(client->context));

            goto fail;

        }

    }



    ret = nfs_fstat(client->context, client->fh, &st);

    if (ret < 0) {

        error_setg(errp, ""Failed to fstat file: %s"",

                   nfs_get_error(client->context));

        goto fail;

    }



    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);

    client->has_zero_init = S_ISREG(st.st_mode);

    goto out;

fail:

    nfs_client_close(client);

out:

    if (qp) {

        query_params_free(qp);

    }

    uri_free(uri);

    g_free(file);

    return ret;

}
",642,"static int64_t nfs_client_open(NFSClient *client, const char *filename,

                               int flags, Error **errp)

{

    int ret = -EINVAL, i;

    struct stat st;

    URI *uri;

    QueryParams *sqpc = NULL;

    char *file = NULL, *irpi = NULL;



    uri = uri_parse(filename);

    if (!uri) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    if (!uri->server) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    irpi = strrchr(uri->path, '/');

    if (irpi == NULL) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    file = g_strdup(irpi);

    *irpi = 0;



    client->context = nfs_init_context();

    if (client->context == NULL) {

        error_setg(errp, ""Failed to init NFS context"");

        goto fail;

    }



    sqpc = query_params_parse(uri->query);

    for (i = 0; i < sqpc->n; i++) {

        if (!qp->p[i].value) {

            error_setg(errp, ""Value for NFS parameter expected: %s"",

                       sqpc->p[i].name);

            goto fail;

        }

        if (!strncmp(sqpc->p[i].name, ""uid"", 3)) {

            nfs_set_uid(client->context, atoi(sqpc->p[i].value));

        } else if (!strncmp(sqpc->p[i].name, ""gid"", 3)) {

            nfs_set_gid(client->context, atoi(sqpc->p[i].value));

        } else if (!strncmp(sqpc->p[i].name, ""tcp-syncnt"", 10)) {

            nfs_set_tcp_syncnt(client->context, atoi(sqpc->p[i].value));

        } else {

            error_setg(errp, ""Unknown NFS parameter name: %s"",

                       sqpc->p[i].name);

            goto fail;

        }

    }



    ret = nfs_mount(client->context, uri->server, uri->path);

    if (ret < 0) {

        error_setg(errp, ""Failed to mount nfs share: %s"",

                   nfs_get_error(client->context));

        goto fail;

    }



    if (flags & O_CREAT) {

        ret = nfs_creat(client->context, file, 0600, &client->fh);

        if (ret < 0) {

            error_setg(errp, ""Failed to create file: %s"",

                       nfs_get_error(client->context));

            goto fail;

        }

    } else {

        ret = nfs_open(client->context, file, flags, &client->fh);

        if (ret < 0) {

            error_setg(errp, ""Failed to open file : %s"",

                       nfs_get_error(client->context));

            goto fail;

        }

    }



    ret = nfs_fstat(client->context, client->fh, &st);

    if (ret < 0) {

        error_setg(errp, ""Failed to fstat file: %s"",

                   nfs_get_error(client->context));

        goto fail;

    }



    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);

    client->has_zero_init = S_ISREG(st.st_mode);

    goto out;

fail:

    nfs_client_close(client);

out:

    if (sqpc) {

        query_params_free(sqpc);

    }

    uri_free(uri);

    g_free(file);

    return ret;

}
",LABEL_1,LABEL_1,LABEL_0,1,"client,filename,flags,errp,i,st,uri,qp,file,strp",,,,65,"client:client,filename:filename,flags:flags,errp:errp,i:i,st:st,uri:uri,qp:sqpc,file:file,strp:irpi,",8,GA,636,0.20001264810562133,GA,
311,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *s = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int ring_order;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {

            g_free(str);

            goto out;

        }

        g_free(str);

        str = g_strdup_printf(""event-channel-%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].evtchn) == -1) {

            g_free(str);

            goto out;

        }

        g_free(str);



        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(

                xen_9pdev->xendev.gnttabdev,

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].intf) {

            goto out;

        }

        ring_order = xen_9pdev->rings[i].intf->ring_order;

        if (ring_order > MAX_RING_ORDER) {

            goto out;

        }

        xen_9pdev->rings[i].ring_order = ring_order;

        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(

                xen_9pdev->xendev.gnttabdev,

                (1 << ring_order),

                xen_9pdev->xendev.dom,

                xen_9pdev->rings[i].intf->ref,

                PROT_READ | PROT_WRITE);

        if (!xen_9pdev->rings[i].data) {

            goto out;

        }

        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;

        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +

                                       XEN_FLEX_RING_SIZE(ring_order);



        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);

        xen_9pdev->rings[i].out_cons = 0;

        xen_9pdev->rings[i].out_size = 0;

        xen_9pdev->rings[i].inprogress = false;





        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);

        if (xen_9pdev->rings[i].evtchndev == NULL) {

            goto out;

        }

        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);

        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain

                                            (xen_9pdev->rings[i].evtchndev,

                                             xendev->dom,

                                             xen_9pdev->rings[i].evtchn);

        if (xen_9pdev->rings[i].local_port == -1) {

            xen_pv_printf(xendev, 0,

                          ""xenevtchn_bind_interdomain failed port=%d\n"",

                          xen_9pdev->rings[i].evtchn);

            goto out;

        }

        xen_pv_printf(xendev, 2, ""bind evtchn port %d\n"", xendev->local_port);

        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),

                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);

    }



    xen_9pdev->security_model = xenstore_read_be_str(xendev, ""security_model"");

    xen_9pdev->path = xenstore_read_be_str(xendev, ""path"");

    xen_9pdev->id = s->fsconf.fsdev_id =

        g_strdup_printf(""xen9p%d"", xendev->dev);

    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, ""tag"");

    v9fs_register_transport(s, &xen_9p_transport);

    fsdev = qemu_opts_create(qemu_find_opts(""fsdev""),

            s->fsconf.tag,

            1, NULL);

    qemu_opt_set(fsdev, ""fsdriver"", ""local"", NULL);

    qemu_opt_set(fsdev, ""path"", xen_9pdev->path, NULL);

    qemu_opt_set(fsdev, ""security_model"", xen_9pdev->security_model, NULL);

    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);

    qemu_fsdev_add(fsdev);

    v9fs_device_realize_common(s, NULL);



    return 0;



out:

    xen_9pfs_free(xendev);

    return -1;

}
",901,,LABEL_0,LABEL_1,,-4,"xendev,i,xen_9pdev,s,fsdev,str,ring_order",,,,0,,0,Greedy,1,0.0009582996368408203,,
312,"static int coroutine_fn is_allocated_base(BlockDriverState *top,

                                          BlockDriverState *base,

                                          int64_t sector_num,

                                          int nb_sectors, int *pnum)

{

    BlockDriverState *intermediate;

    int ret, n;



    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);

    if (ret) {

        *pnum = n;

        return ret;

    }



    /*

     * Is the unallocated chunk [sector_num, n] also

     * unallocated between base and top?

     */

    intermediate = top->backing_hd;



    while (intermediate != base) {

        int pnum_inter;



        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,

                                   &pnum_inter);

        if (ret < 0) {

            return ret;

        } else if (ret) {

            *pnum = pnum_inter;

            return 0;

        }



        /*

         * [sector_num, nb_sectors] is unallocated on top but intermediate

         * might have

         *

         * [sector_num+x, nr_sectors] allocated.

         */

        if (n > pnum_inter) {

            n = pnum_inter;

        }



        intermediate = intermediate->backing_hd;

    }



    *pnum = n;

    return 1;

}
",200,"static int coroutine_fn is_allocated_base(BlockDriverState *up,

                                          BlockDriverState *b,

                                          int64_t sector_name,

                                          int nb_sectors, int *pnum)

{

    BlockDriverState *internparent;

    int obj, n;



    obj = bdrv_co_is_allocated(up, sector_name, nb_sectors, &n);

    if (obj) {

        *pnum = n;

        return obj;

    }



    /*

     * Is the unallocated chunk [sector_name, n] also

     * unallocated betweenbe and up?

     */

   internparente = up->backing_hd;



    whilinternparentate != b) {

        int pnum_inc;



        robj= bdrv_co_is_allocated(iinternparent sector_name, nb_sectors,

                                   &pnum_inc);

        if (obj < 0) {

            return obj;

        } else if (obj) {

            *pnum = pnum_inc;

            return 0;

        }



        /*

         * sector_namem,nb_sectorss] is unallocated on up but internparent

         * might have

         *

         * [sector_name+x, nr_sectors] allocated.

         */

        if (n > pnum_inc) {

            n = pnum_inc;

        }



        internparent = internparent->backing_hd;

    }



    *pnum = n;

    return 1;

}
",LABEL_0,LABEL_0,LABEL_1,1,"top,base,sector_num,nb_sectors,pnum,intermediate,ret,n,pnum_inter",,,,15,"top:up,base:b,sector_num:sector_name,nb_sectors:nb_sectors,pnum:pnum,intermediate:internparent,ret:obj,n:n,pnum_inter:pnum_inc,",3,GA,565,0.1523144006729126,GA,
313,"static int connect_namedsocket(const char *path)

{

    int sockfd, size;

    struct sockaddr_un helper;



    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    if (sockfd < 0) {

        fprintf(stderr, ""socket %s\n"", strerror(errno));

        return -1;

    }

    strcpy(helper.sun_path, path);

    helper.sun_family = AF_UNIX;

    size = strlen(helper.sun_path) + sizeof(helper.sun_family);

    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {

        fprintf(stderr, ""socket error\n"");


        return -1;

    }



    /* remove the socket for security reasons */

    unlink(path);

    return sockfd;

}",143,,LABEL_1,LABEL_1,LABEL_1,-1,"path,sockfd,size,helper",,,,0,,0,GA,889,0.23061418930689495,failed,
314,"static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)

{

    static uint32_t bmap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t prev_state;



    if (prev_state != state) {

        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);

        prev_state = state;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            y -= guest_y;

            guest_x += x;

            guest_y += y;

            dx = x;

            dy = y;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);

    }

    qemu_input_event_sync();

}
",209,"static void sdl_send_mouse_event(int prefix, int down, int down, int m, int val)

{

    static uint32_t bbmaps[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t keepfscale;



    ifkeepfscalete != val) {

        qemu_input_update_buttons(dcl->conbbmapsapkeepfscalete, val);

      keepfscalete = val;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, down,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, m,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            down -= guest_x;

            m -= guest_y;

            guest_x += down;

            guest_y += m;

            prefix = down;

            down = m;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, prefix);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, down);

    }

    qemu_input_event_sync();

}
",LABEL_0,LABEL_0,LABEL_1,1,"dx,dy,x,y,state,bmap,prev_state",,,,0,"dx:prefix,dy:down,x:down,y:m,state:val,bmap:bbmaps,prev_state:keepfscale,",0,GA,993,0.2692857543627421,GA,
315,"static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);

    scsi_req_cancel(s->req);

}
",37,,LABEL_1,LABEL_0,,-4,"dev,p,s",,,,0,,0,Greedy,1,0.0004606167475382487,,
316,"void trace_init_file(const char *file)

{

#ifdef CONFIG_TRACE_SIMPLE

    st_set_trace_file(file);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (file) {

        qemu_set_log_filename(file);

    }

#else

    if (file) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends\n"");

        exit(1);

    }

#endif

}
",85,"void trace_init_file(const char *message)

{

#ifdef CONFIG_TRACE_SIMPLE

    st_set_trace_file(message);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (message) {

        qemu_set_log_filename(message);

    }

#else

    if (message) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends
"");

        exit(1);

    }

#endif

}
",LABEL_1,LABEL_1,LABEL_0,1,file,,,,0,"file:message,",0,GA,79,0.022223170598347983,GA,
317,"static int qcow2_co_readv(BlockDriverState *bs, int64_t sector_num,

                          int remaining_sectors, QEMUIOVector *qiov)

{

    BDRVQcowState *s = bs->opaque;

    int index_in_cluster, n1;

    int ret;

    int cur_nr_sectors; /* number of sectors in current iteration */

    uint64_t cluster_offset = 0;

    uint64_t bytes_done = 0;

    QEMUIOVector hd_qiov;

    uint8_t *cluster_data = NULL;



    qemu_iovec_init(&hd_qiov, qiov->niov);



    qemu_co_mutex_lock(&s->lock);



    while (remaining_sectors != 0) {



        /* prepare next request */

        cur_nr_sectors = remaining_sectors;

        if (s->crypt_method) {

            cur_nr_sectors = MIN(cur_nr_sectors,

                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);

        }



        ret = qcow2_get_cluster_offset(bs, sector_num << 9,

            &cur_nr_sectors, &cluster_offset);

        if (ret < 0) {

            goto fail;

        }



        index_in_cluster = sector_num & (s->cluster_sectors - 1);



        qemu_iovec_reset(&hd_qiov);

        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,

            cur_nr_sectors * 512);



        if (!cluster_offset) {



            if (bs->backing_hd) {

                /* read from the base image */

                n1 = qcow2_backing_read1(bs->backing_hd, &hd_qiov,

                    sector_num, cur_nr_sectors);

                if (n1 > 0) {

                    BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);

                    qemu_co_mutex_unlock(&s->lock);

                    ret = bdrv_co_readv(bs->backing_hd, sector_num,

                                        n1, &hd_qiov);

                    qemu_co_mutex_lock(&s->lock);

                    if (ret < 0) {

                        goto fail;

                    }

                }

            } else {

                /* Note: in this case, no need to wait */

                qemu_iovec_memset(&hd_qiov, 0, 512 * cur_nr_sectors);

            }

        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {

            /* add AIO support for compressed blocks ? */

            ret = qcow2_decompress_cluster(bs, cluster_offset);

            if (ret < 0) {

                goto fail;

            }



            qemu_iovec_from_buffer(&hd_qiov,

                s->cluster_cache + index_in_cluster * 512,

                512 * cur_nr_sectors);

        } else {

            if ((cluster_offset & 511) != 0) {

                ret = -EIO;

                goto fail;

            }



            if (s->crypt_method) {

                /*

                 * For encrypted images, read everything into a temporary

                 * contiguous buffer on which the AES functions can work.

                 */

                if (!cluster_data) {

                    cluster_data =

                        g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);

                }



                assert(cur_nr_sectors <=

                    QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);

                qemu_iovec_reset(&hd_qiov);

                qemu_iovec_add(&hd_qiov, cluster_data,

                    512 * cur_nr_sectors);

            }



            BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

            qemu_co_mutex_unlock(&s->lock);

            ret = bdrv_co_readv(bs->file,

                                (cluster_offset >> 9) + index_in_cluster,

                                cur_nr_sectors, &hd_qiov);

            qemu_co_mutex_lock(&s->lock);

            if (ret < 0) {

                goto fail;

            }

            if (s->crypt_method) {

                qcow2_encrypt_sectors(s, sector_num,  cluster_data,

                    cluster_data, cur_nr_sectors, 0, &s->aes_decrypt_key);

                qemu_iovec_reset(&hd_qiov);

                qemu_iovec_copy(&hd_qiov, qiov, bytes_done,

                    cur_nr_sectors * 512);

                qemu_iovec_from_buffer(&hd_qiov, cluster_data,

                    512 * cur_nr_sectors);

            }

        }



        remaining_sectors -= cur_nr_sectors;

        sector_num += cur_nr_sectors;

        bytes_done += cur_nr_sectors * 512;

    }

    ret = 0;



fail:

    qemu_co_mutex_unlock(&s->lock);



    qemu_iovec_destroy(&hd_qiov);




    return ret;

}",655,,LABEL_1,LABEL_0,,-4,"bs,sector_num,remaining_sectors,qiov,s,index_in_cluster,n1,ret,cur_nr_sectors,hd_qiov,cluster_data",,,,0,,0,Greedy,1,0.0019167184829711914,,
318,"static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket klv;

    int64_t essence_offset = 0;



    mxf->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!s->pb->eof_reached) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&klv, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", klv.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""\n"", klv.length, klv.offset);

        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_system_item_key)) {

            if (!mxf->current_partition->essence_offset) {

                compute_partition_essence_offset(s, mxf, &klv);

            }



            if (!essence_offset)

                essence_offset = klv.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(mxf) <= 0)

                break;

            continue;

        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&

                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

        }



        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {

            if (IS_KLV_KEY(klv.key, metadata->key)) {

                int res;

                if (klv.key[5] == 0x53) {

                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);

                } else {

                    uint64_t next = avio_tell(s->pb) + klv.length;

                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);

                    avio_seek(s->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(s, AV_LOG_ERROR, ""error reading header metadata\n"");

                    return res;

                }

                break;

            }

        }

        if (!metadata->read)

            avio_skip(s->pb, klv.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(s, AV_LOG_ERROR, ""no essence\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(mxf);



    return mxf_parse_structural_metadata(mxf);

}
",607,,LABEL_1,LABEL_0,,-4,"s,ap,mxf,klv,metadata",,,,0,,0,Greedy,1,0.0007835110028584798,,
319,"static int compare_codec_desc(const void *a, const void *b)

{

    const AVCodecDescriptor * const *da = a;

    const AVCodecDescriptor * const *db = b;



    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :

           strcmp((*da)->name, (*db)->name);

}
",84,,LABEL_1,LABEL_0,,-4,"a,b,da,db",,,,0,,0,Greedy,1,0.0004620552062988281,,
320,"static int encode_hq_slice(AVCodecContext *avctx, void *arg)

{

    SliceArgs *slice_dat = arg;

    VC2EncContext *s = slice_dat->ctx;

    PutBitContext *pb = &slice_dat->pb;

    const int slice_x = slice_dat->x;

    const int slice_y = slice_dat->y;

    const int quant_idx = slice_dat->quant_idx;

    const int slice_bytes_max = slice_dat->bytes;

    uint8_t quants[MAX_DWT_LEVELS][4];

    int p, level, orientation;



    avpriv_align_put_bits(pb);

    skip_put_bytes(pb, s->prefix_bytes);

    put_bits(pb, 8, quant_idx);



    /* Slice quantization (slice_quantizers() in the specs) */

    for (level = 0; level < s->wavelet_depth; level++)

        for (orientation = !!level; orientation < 4; orientation++)

            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);



    /* Luma + 2 Chroma planes */

    for (p = 0; p < 3; p++) {

        int bytes_start, bytes_len, pad_s, pad_c;

        bytes_start = put_bits_count(pb) >> 3;

        put_bits(pb, 8, 0);

        for (level = 0; level < s->wavelet_depth; level++) {

            for (orientation = !!level; orientation < 4; orientation++) {

                encode_subband(s, pb, slice_x, slice_y,

                               &s->plane[p].band[level][orientation],

                               quants[level][orientation]);

            }

        }

        avpriv_align_put_bits(pb);

        bytes_len = (put_bits_count(pb) >> 3) - bytes_start - 1;

        if (p == 2) {

            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);

            pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler;

            pad_c = (pad_s*s->size_scaler) - bytes_len;

        } else {

            pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;

            pad_c = (pad_s*s->size_scaler) - bytes_len;

        }

        pb->buf[bytes_start] = pad_s;

        flush_put_bits(pb);

        skip_put_bytes(pb, pad_c);

    }



    return 0;

}
",453,"static int encode_hq_slice(AVCodecContext *avctx, void *arg)

{

    SliceArgs *slice_dat = arg;

    VC2EncContext *services = slice_dat->ctx;

    PutBitContext *pb = &slice_dat->pb;

    const int slice_x = slice_dat->x;

    const int slice_y = slice_dat->y;

    const int quant_idx = slice_dat->quant_idx;

    const int slice_bytes_max = slice_dat->bytes;

    uint8_t quants[MAX_DWT_LEVELS][4];

    int p, level, orientation;



    avpriv_align_put_bits(pb);

    skip_put_bytes(pb, serpbces->prefix_bytes);

    put_bits(pb, 8, quant_idx);



    /* Slice quantization (slice_quantizers() in the specs) */

    for (level =levelevel <levelices->wavelet_depth; level++)

        for (orientation = !!level; orientation < 4; orientation++)

            quants[quants[leveltaorientationAX(quant_idx - services->quant[level][orientation], 0);



    /* Luma + 2 Chroma planes */

    for (p = 0; p < 3; p++) {

        int bytes_start,  bytes
, pad_s, pad_c;

        bytes_start = put_bits_count(pb) >> 3;

        put_bits(pb, 8, 0);

        for (level =levelevel <levelices->wavelet_depth; level++) {

            for (orientation = !!level; orientation < 4; orientation++) {

                encode_subband(services, pb, slice_x, slice_y,

                               &services->plane[p].band[level][orientation],

                               quants[level][orientation]);

            }

        }

        avpriv_align_put_bits(pb);

         bytes
 = (put_bits_count(pb) >> 3) - bytes_start - 1;

        if (p == 2) {

            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);

            pad_s = FFALpad_sbytes_len + le bytes
services->size_scaler)/services->size_scaler;

            pad_cpad_cad_spad_sices->size_scaler) -  bytes
;

        } else {

            pad_s = FFALpad_sytes_len, ser bytes
ze_scaler)/services->size_scaler;

            pad_cpad_cad_spad_sices->size_scaler) -  bytes
;

        }

        pb->buf[bytes_start] = pad_s;

        flush_put_bits(pb);

        skip_put_bytes(pb, pad_c);

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,arg,slice_dat,s,pb,quants,MAX_DWT_LEVELS,p,level,orientation,bytes_start,bytes_len,pad_s,pad_c",,,,70,"avctx:avctx,arg:arg,slice_dat:slice_dat,s:services,pb:pb,quants:quants,MAX_DWT_LEVELS:MAX_DWT_LEVELS,p:p,level:level,orientation:orientation,bytes_start:bytes_start,bytes_len: bytes
,pad_s:pad_s,pad_c:pad_c,",12,GA,750,0.2218159556388855,GA,
321,"static int inet_listen_saddr(InetSocketAddress *saddr,

                             int port_offset,

                             bool update_addr,

                             Error **errp)

{

    struct addrinfo ai,*res,*e;

    char port[33];

    char uaddr[INET6_ADDRSTRLEN+1];

    char uport[33];

    int slisten, rc, port_min, port_max, p;

    Error *err = NULL;



    memset(&ai,0, sizeof(ai));

    ai.ai_flags = AI_PASSIVE;

    if (saddr->has_numeric && saddr->numeric) {

        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;

    }

    ai.ai_family = inet_ai_family_from_address(saddr, &err);

    ai.ai_socktype = SOCK_STREAM;



    if (err) {

        error_propagate(errp, err);

        return -1;

    }



    if (saddr->host == NULL) {

        error_setg(errp, ""host not specified"");

        return -1;

    }

    if (saddr->port != NULL) {

        pstrcpy(port, sizeof(port), saddr->port);

    } else {

        port[0] = '\0';

    }



    /* lookup */

    if (port_offset) {

        unsigned long long baseport;

        if (strlen(port) == 0) {

            error_setg(errp, ""port not specified"");

            return -1;

        }

        if (parse_uint_full(port, &baseport, 10) < 0) {

            error_setg(errp, ""can't convert to a number: %s"", port);

            return -1;

        }

        if (baseport > 65535 ||

            baseport + port_offset > 65535) {

            error_setg(errp, ""port %s out of range"", port);

            return -1;

        }

        snprintf(port, sizeof(port), ""%d"", (int)baseport + port_offset);

    }

    rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,

                     strlen(port) ? port : NULL, &ai, &res);

    if (rc != 0) {

        error_setg(errp, ""address resolution failed for %s:%s: %s"",

                   saddr->host, port, gai_strerror(rc));

        return -1;

    }



    /* create socket + bind */

    for (e = res; e != NULL; e = e->ai_next) {

        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,

		        uaddr,INET6_ADDRSTRLEN,uport,32,

		        NI_NUMERICHOST | NI_NUMERICSERV);

        slisten = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);

        if (slisten < 0) {

            if (!e->ai_next) {

                error_setg_errno(errp, errno, ""Failed to create socket"");

            }

            continue;

        }



        socket_set_fast_reuse(slisten);



        port_min = inet_getport(e);

        port_max = saddr->has_to ? saddr->to + port_offset : port_min;

        for (p = port_min; p <= port_max; p++) {

            inet_setport(e, p);

            if (try_bind(slisten, saddr, e) >= 0) {

                goto listen;

            }

            if (p == port_max) {

                if (!e->ai_next) {

                    error_setg_errno(errp, errno, ""Failed to bind socket"");

                }

            }

        }

        closesocket(slisten);

    }

    freeaddrinfo(res);

    return -1;



listen:

    if (listen(slisten,1) != 0) {

        error_setg_errno(errp, errno, ""Failed to listen on socket"");

        closesocket(slisten);

        freeaddrinfo(res);

        return -1;

    }

    if (update_addr) {

        g_free(saddr->host);

        saddr->host = g_strdup(uaddr);

        g_free(saddr->port);

        saddr->port = g_strdup_printf(""%d"",

                                      inet_getport(e) - port_offset);

        saddr->has_ipv6 = saddr->ipv6 = e->ai_family == PF_INET6;

        saddr->has_ipv4 = saddr->ipv4 = e->ai_family != PF_INET6;

    }

    freeaddrinfo(res);

    return slisten;

}
",725,"static int inet_listen_saddr(InetSocketAddress *saddr,

                             int port_offset,

                             bool update_addr,

                             Error **erk)

{

    struct addrinfo ai,*res,*e;

    char port[33];

    char uaddr[INET6_ADDRSTRLEN+1];

    char uport[33];

    int slisten, result, port_min, port_max, p;

    Error *dr = NULL;



    memset(&ai,0, sizeof(ai));

    ai.ai_flags = AI_PASSIVE;

    if (saddr->has_numeric && saddr->numeric) {

        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;

    }

    ai.ai_family = inet_ai_family_from_address(saddr, &dr);

    ai.ai_socktype = SOCK_STREAM;



    if (dr) {

        error_propagate(erk, dr);

        return -1;

    }



    if (saddr->host == NULL) {

        error_setg(erk, ""host not specified"");

        return -1;

    }

    if (saddr->port != NULL) {

        pstrcpy(port, sizeof(port), saddr->port);

    } else {

        port[0] = '\0';

    }



    /* lookup */

    if (port_offset) {

        unsigned long long bideport;

        if (strlen(port) == 0) {

            error_setg(erk, ""port not specified"");

            return -1;

        }

        if (parse_uint_full(port, &bideport, 10) < 0) {

            error_setg(erk, ""can't convert to a number: %s"", port);

            return -1;

        }

        if (bideport > 65535 ||

            bideport + port_offset > 65535) {

            error_setg(erk, ""port %s out of range"", port);

            return -1;

        }

        snprintf(port, sizeof(port), ""%d"", (int)bideport + port_offset);

    }

    result = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,

                     strlen(port) ? port : NULL, &ai, &res);

    if (result != 0) {

        error_setg(erk, ""address resolution failed for %s:%s: %s"",

                   saddr->host, port, gai_strerror(result));

        return -1;

    }



    /* create socket + bind */

    for (e = res; e != NULL; e = e->ai_next) {

        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,

		        uaddr,INET6_ADDRSTRLEN,uport,32,

		        NI_NUMERICHOST | NI_NUMERICSERV);

        slisten = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);

        if (slisten < 0) {

            if (!e->ai_next) {

                error_setg_errno(erk, errno, ""Failed to create socket"");

            }

            continue;

        }



        socket_set_fast_reuse(slisten);



        port_min = inet_getport(e);

        port_max = saddr->has_to ? saddr->to + port_offset : port_min;

        for (p = port_min; p <= port_max; p++) {

            inet_setport(e, p);

            if (try_bind(slisten, saddr, e) >= 0) {

                goto listen;

            }

            if (p == port_max) {

                if (!e->ai_next) {

                    error_setg_errno(erk, errno, ""Failed to bind socket"");

                }

            }

        }

        closesocket(slisten);

    }

    freeaddrinfo(res);

    return -1;



listen:

    if (listen(slisten,1) != 0) {

        error_setg_errno(erk, errno, ""Failed to listen on socket"");

        closesocket(slisten);

        freeaddrinfo(res);

        return -1;

    }

    if (update_addr) {

        g_free(saddr->host);

        saddr->host = g_strdup(uaddr);

        g_free(saddr->port);

        saddr->port = g_strdup_printf(""%d"",

                                      inet_getport(e) - port_offset);

        saddr->has_ipv6 = saddr->ipv6 = e->ai_family == PF_INET6;

        saddr->has_ipv4 = saddr->ipv4 = e->ai_family != PF_INET6;

    }

    freeaddrinfo(res);

    return slisten;

}
",LABEL_0,LABEL_0,LABEL_1,1,"saddr,port_offset,update_addr,errp,ai,res,e,port,uaddr,uport,slisten,rc,port_min,port_max,p,err,baseport",,,,104,"saddr:saddr,port_offset:port_offset,update_addr:update_addr,errp:erk,ai:ai,res:res,e:e,port:port,uaddr:uaddr,uport:uport,slisten:slisten,rc:result,port_min:port_min,port_max:port_max,p:p,err:dr,baseport:bideport,",13,GA,843,0.29246110916137696,GA,
322,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
",93,,LABEL_0,LABEL_0,LABEL_0,-1,"timer_list,expire_time",,,,0,,0,GA,337,0.08615407148996988,failed,
323,"static int usbnet_can_receive(NetClientState *nc)

{

    USBNetState *s = qemu_get_nic_opaque(nc);



    if (!s->dev.config) {

        return 0;

    }



    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }



    return !s->in_len;

}
",58,"static int usbnet_can_receive(NetClientState *ct)

{

    USBNetState *f = qemu_get_nic_opaque(ct);



    if (!s->dev.config) {

        return 0;

    }



    if (is_rndis(f) && f->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }



    return !s->in_len;

}
",LABEL_0,LABEL_0,LABEL_1,1,"nc,s",,,,0,"nc:ct,s:f,",0,GA,149,0.03639302651087443,GA,
324,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",84,,LABEL_1,LABEL_0,,-4,"dev,prop,str,ptr,fmt",,,,0,,0,Greedy,1,0.00046054919560750327,,
325,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
",69,,LABEL_1,LABEL_0,,-4,"avctx,ctx",,,,0,,0,Greedy,1,0.00028109153111775717,,
326,"static int thp_read_header(AVFormatContext *s,

                           AVFormatParameters *ap)

{

    ThpDemuxContext *thp = s->priv_data;

    AVStream *st;

    AVIOContext *pb = s->pb;

    int i;



    /* Read the file header.  */

                           avio_rb32(pb); /* Skip Magic.  */

    thp->version         = avio_rb32(pb);



                           avio_rb32(pb); /* Max buf size.  */

                           avio_rb32(pb); /* Max samples.  */



    thp->fps             = av_d2q(av_int2float(avio_rb32(pb)), INT_MAX);

    thp->framecnt        = avio_rb32(pb);

    thp->first_framesz   = avio_rb32(pb);

                           avio_rb32(pb); /* Data size.  */



    thp->compoff         = avio_rb32(pb);

                           avio_rb32(pb); /* offsetDataOffset.  */

    thp->first_frame     = avio_rb32(pb);

    thp->last_frame      = avio_rb32(pb);



    thp->next_framesz    = thp->first_framesz;

    thp->next_frame      = thp->first_frame;



    /* Read the component structure.  */

    avio_seek (pb, thp->compoff, SEEK_SET);

    thp->compcount       = avio_rb32(pb);



    /* Read the list of component types.  */

    avio_read(pb, thp->components, 16);



    for (i = 0; i < thp->compcount; i++) {

        if (thp->components[i] == 0) {

            if (thp->vst != 0)

                break;



            /* Video component.  */

            st = avformat_new_stream(s, NULL);

            if (!st)

                return AVERROR(ENOMEM);



            /* The denominator and numerator are switched because 1/fps

               is required.  */

            avpriv_set_pts_info(st, 64, thp->fps.den, thp->fps.num);

            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

            st->codec->codec_id = CODEC_ID_THP;

            st->codec->codec_tag = 0;  /* no fourcc */

            st->codec->width = avio_rb32(pb);

            st->codec->height = avio_rb32(pb);

            st->codec->sample_rate = av_q2d(thp->fps);

            thp->vst = st;

            thp->video_stream_index = st->index;



            if (thp->version == 0x11000)

                avio_rb32(pb); /* Unknown.  */

        } else if (thp->components[i] == 1) {

            if (thp->has_audio != 0)

                break;



            /* Audio component.  */

            st = avformat_new_stream(s, NULL);

            if (!st)

                return AVERROR(ENOMEM);



            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

            st->codec->codec_id = CODEC_ID_ADPCM_THP;

            st->codec->codec_tag = 0;  /* no fourcc */

            st->codec->channels    = avio_rb32(pb); /* numChannels.  */

            st->codec->sample_rate = avio_rb32(pb); /* Frequency.  */



            avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate);



            thp->audio_stream_index = st->index;

            thp->has_audio = 1;

        }

    }



    return 0;

}
",637,"static int thp_read_header(AVFormatContext *s,

                           AVFormatParameters *cp)

{

    ThpDemuxContext *thp = s->priv_data;

    AVStream *st;

    AVIOContext *pb = s->pb;

    int phi;



    /* Read the file header.  */

                           avio_rb32(pb); /* Skip Magic.  */

    thp->version         = avio_rb32(pb);



                           avio_rb32(pb); /* Max buf size.  */

                           avio_rb32(pb); /* Max samples.  */



    thp->fps             = av_d2q(av_int2float(avio_rb32(pb)), INT_MAX);

    thp->framecnt        = avio_rb32(pb);

    thp->first_framesz   = avio_rb32(pb);

                           avio_rb32(pb); /* Data size.  */



    thp->compoff         = avio_rb32(pb);

                           avio_rb32(pb); /* offsetDataOffset.  */

    thp->first_frame     = avio_rb32(pb);

    thp->last_frame      = avio_rb32(pb);



    thp->next_framesz    = thp->first_framesz;

    thp->next_frame      = thp->first_frame;



    /* Read the component structure.  */

    avio_seek (pb, thp->compoff, SEEK_SET);

    thp->compcount       = avio_rb32(pb);



    /* Read the list of component types.  */

    avio_read(pb, thp->components, 16);



    for (phi = 0; phi < thp->compcount; phi++) {

        if (thp->components[phi] == 0) {

            if (thp->vst != 0)

                break;



            /* Video component.  */

            st = avformat_new_stream(s, NULL);

            if (!st)

                return AVERROR(ENOMEM);



            /* The denominator and numerator are switched because 1/fps

               is required.  */

            avpriv_set_pts_info(st, 64, thp->fps.den, thp->fps.num);

            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

            st->codec->codec_id = CODEC_ID_THP;

            st->codec->codec_tag = 0;  /* no fourcc */

            st->codec->width = avio_rb32(pb);

            st->codec->height = avio_rb32(pb);

            st->codec->sample_rate = av_q2d(thp->fps);

            thp->vst = st;

            thp->video_stream_index = st->index;



            if (thp->version == 0x11000)

                avio_rb32(pb); /* Unknown.  */

        } else if (thp->components[phi] == 1) {

            if (thp->has_audio != 0)

                break;



            /* Audio component.  */

            st = avformat_new_stream(s, NULL);

            if (!st)

                return AVERROR(ENOMEM);



            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

            st->codec->codec_id = CODEC_ID_ADPCM_THP;

            st->codec->codec_tag = 0;  /* no fourcc */

            st->codec->channels    = avio_rb32(pb); /* numChannels.  */

            st->codec->sample_rate = avio_rb32(pb); /* Frequency.  */



            avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate);



            thp->audio_stream_index = st->index;

            thp->has_audio = 1;

        }

    }



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,ap,thp,st,pb,i",,,,75,"s:s,ap:cp,thp:thp,st:st,pb:pb,i:phi,",4,GA,474,0.1492209990819295,GA,
327,"void qemu_savevm_state_complete(QEMUFile *f)

{

    QJSON *vmdesc;

    int vmdesc_len;

    SaveStateEntry *se;

    int ret;



    trace_savevm_state_complete();



    cpu_synchronize_all_states();



    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {

        if (!se->ops || !se->ops->save_live_complete) {

            continue;

        }

        if (se->ops && se->ops->is_active) {

            if (!se->ops->is_active(se->opaque)) {

                continue;

            }

        }

        trace_savevm_section_start(se->idstr, se->section_id);



        save_section_header(f, se, QEMU_VM_SECTION_END);



        ret = se->ops->save_live_complete(f, se->opaque);

        trace_savevm_section_end(se->idstr, se->section_id, ret);


        if (ret < 0) {

            qemu_file_set_error(f, ret);

            return;

        }

    }



    vmdesc = qjson_new();

    json_prop_int(vmdesc, ""page_size"", TARGET_PAGE_SIZE);

    json_start_array(vmdesc, ""devices"");

    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {



        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {

            continue;

        }

        trace_savevm_section_start(se->idstr, se->section_id);



        json_start_object(vmdesc, NULL);

        json_prop_str(vmdesc, ""name"", se->idstr);

        json_prop_int(vmdesc, ""instance_id"", se->instance_id);



        save_section_header(f, se, QEMU_VM_SECTION_FULL);



        vmstate_save(f, se, vmdesc);



        json_end_object(vmdesc);

        trace_savevm_section_end(se->idstr, se->section_id, 0);


    }



    qemu_put_byte(f, QEMU_VM_EOF);



    json_end_array(vmdesc);

    qjson_finish(vmdesc);

    vmdesc_len = strlen(qjson_get_str(vmdesc));



    if (should_send_vmdesc()) {

        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);

        qemu_put_be32(f, vmdesc_len);

        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);

    }

    object_unref(OBJECT(vmdesc));



    qemu_fflush(f);

}",404,,LABEL_1,LABEL_1,LABEL_1,-1,"f,vmdesc,vmdesc_len,se,ret",,,,0,,0,GA,1102,0.3217378815015157,failed,
328,"void op_cp1_64bitmode(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR))) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
",36,,LABEL_0,LABEL_0,,-3,,,,,0,,0,Greedy,1,0.0004610896110534668,,
329,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t cmptparm[4] = {{0}};
    opj_image_t *img;
    int i;
    int sub_dx[4];
    int sub_dy[4];
    int numcomps;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    sub_dx[0] = sub_dx[3] = 1;
    sub_dy[0] = sub_dy[3] = 1;
    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;
    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;
    numcomps = desc->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    case AV_PIX_FMT_XYZ12:
        color_space = CLRSPC_SRGB;
        break;
    case AV_PIX_FMT_YUV410P:
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV422P9:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUVA420P9:
    case AV_PIX_FMT_YUVA422P9:
    case AV_PIX_FMT_YUVA444P9:
    case AV_PIX_FMT_YUV420P10:
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_YUVA420P10:
    case AV_PIX_FMT_YUVA422P10:
    case AV_PIX_FMT_YUVA444P10:
    case AV_PIX_FMT_YUV420P12:
    case AV_PIX_FMT_YUV422P12:
    case AV_PIX_FMT_YUV444P12:
    case AV_PIX_FMT_YUV420P14:
    case AV_PIX_FMT_YUV422P14:
    case AV_PIX_FMT_YUV444P14:
    case AV_PIX_FMT_YUV420P16:
    case AV_PIX_FMT_YUV422P16:
    case AV_PIX_FMT_YUV444P16:
    case AV_PIX_FMT_YUVA420P16:
    case AV_PIX_FMT_YUVA422P16:
    case AV_PIX_FMT_YUVA444P16:
        color_space = CLRSPC_SYCC;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""The requested pixel format '%s' is not supported\n"",
               av_get_pix_fmt_name(avctx->pix_fmt));
    }
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = sub_dx[i];
        cmptparm[i].dy = sub_dy[i];
        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];
        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];
    }
    img = opj_image_create(numcomps, cmptparm, color_space);
    // x0, y0 is the top left corner of the image
    // x1, y1 is the width, height of the reference grid
    img->x0 = 0;
    img->y0 = 0;
    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;
    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;
    return img;
}",566,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,parameters,desc,cmptparm,img,i,sub_dx,sub_dy,numcomps",,,,0,,0,GA,1751,0.5851272225379944,failed,
330,"static void page_init(void)

{

    /* NOTE: we can always suppose that qemu_host_page_size >=

       TARGET_PAGE_SIZE */

#ifdef _WIN32

    {

        SYSTEM_INFO system_info;



        GetSystemInfo(&system_info);

        qemu_real_host_page_size = system_info.dwPageSize;

    }

#else

    qemu_real_host_page_size = getpagesize();

#endif

    if (qemu_host_page_size == 0) {

        qemu_host_page_size = qemu_real_host_page_size;

    }

    if (qemu_host_page_size < TARGET_PAGE_SIZE) {

        qemu_host_page_size = TARGET_PAGE_SIZE;

    }

    qemu_host_page_mask = ~(qemu_host_page_size - 1);



#if defined(CONFIG_BSD) && defined(CONFIG_USER_ONLY)

    {

#ifdef HAVE_KINFO_GETVMMAP

        struct kinfo_vmentry *freep;

        int i, cnt;



        freep = kinfo_getvmmap(getpid(), &cnt);

        if (freep) {

            mmap_lock();

            for (i = 0; i < cnt; i++) {

                unsigned long startaddr, endaddr;



                startaddr = freep[i].kve_start;

                endaddr = freep[i].kve_end;

                if (h2g_valid(startaddr)) {

                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;



                    if (h2g_valid(endaddr)) {

                        endaddr = h2g(endaddr);

                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);

                    } else {

#if TARGET_ABI_BITS <= L1_MAP_ADDR_SPACE_BITS

                        endaddr = ~0ul;

                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);

#endif

                    }

                }

            }

            free(freep);

            mmap_unlock();

        }

#else

        FILE *f;



        last_brk = (unsigned long)sbrk(0);



        f = fopen(""/compat/linux/proc/self/maps"", ""r"");

        if (f) {

            mmap_lock();



            do {

                unsigned long startaddr, endaddr;

                int n;



                n = fscanf(f, ""%lx-%lx %*[^\n]\n"", &startaddr, &endaddr);



                if (n == 2 && h2g_valid(startaddr)) {

                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;



                    if (h2g_valid(endaddr)) {

                        endaddr = h2g(endaddr);

                    } else {

                        endaddr = ~0ul;

                    }

                    page_set_flags(startaddr, endaddr, PAGE_RESERVED);

                }

            } while (!feof(f));



            fclose(f);

            mmap_unlock();

        }

#endif

    }

#endif

}
",369,,LABEL_0,LABEL_0,LABEL_0,-1,"system_info,freep,i,cnt,startaddr,endaddr,f",,,,0,,0,GA,1337,0.4096324920654297,failed,
331,"static void qio_channel_command_finalize(Object *obj)

{

    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);

    if (ioc->readfd != -1) {

        close(ioc->readfd);

        ioc->readfd = -1;

    }

    if (ioc->writefd != -1) {

        close(ioc->writefd);

        ioc->writefd = -1;

    }

    if (ioc->pid > 0) {

#ifndef WIN32

        qio_channel_command_abort(ioc, NULL);

#endif

    }

}
",94,,LABEL_1,LABEL_0,,-4,"obj,ioc",,,,0,,0,Greedy,1,0.00048244396845499674,,
332,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
",76,"static void gen_storeq_reg(DisasContext *su, int rlow, int  rlimit, TCGv_i64 value)

{

    TCGv tc;

    tc = new_tmp();

    tcg_gen_trunc_i64_i32(tmtcvalue);

    store_reg(su, rlow, tc);

    tc = new_tmp();

    tcg_gen_shri_i64(value, value, 32);

    tcg_gen_trunc_i64_i32(tmtcvalue);

    store_reg(su,  rlimit, tc);

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,rlow,rhigh,val,tmp",,,,2,"s:su,rlow:rlow,rhigh: rlimit,val:value,tmp:tc,",1,GA,246,0.060961437225341794,GA,
333,"static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, long width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    __asm__ volatile(

        ""movq ""MANGLE(bm01010101)"", %%mm4           \n\t""

        ""mov                    %0, %%""REG_a""       \n\t""

        ""1:                                         \n\t""

        ""movq    (%1, %%""REG_a"",4), %%mm0           \n\t""

        ""movq   8(%1, %%""REG_a"",4), %%mm1           \n\t""

        ""psrlw                  $8, %%mm0           \n\t""

        ""psrlw                  $8, %%mm1           \n\t""

        ""packuswb            %%mm1, %%mm0           \n\t""

        ""movq                %%mm0, %%mm1           \n\t""

        ""psrlw                  $8, %%mm0           \n\t""

        ""pand                %%mm4, %%mm1           \n\t""

        ""packuswb            %%mm0, %%mm0           \n\t""

        ""packuswb            %%mm1, %%mm1           \n\t""

        ""movd                %%mm0, (%3, %%""REG_a"") \n\t""

        ""movd                %%mm1, (%2, %%""REG_a"") \n\t""

        ""add                    $4, %%""REG_a""       \n\t""

        "" js                    1b                  \n\t""

        : : ""g"" ((x86_reg)-width), ""r"" (src1+width*4), ""r"" (dstU+width), ""r"" (dstV+width)

        : ""%""REG_a

    );

#else

    int i;

    for (i=0; i<width; i++) {

        dstU[i]= src1[4*i + 1];

        dstV[i]= src1[4*i + 3];

    }

#endif

    assert(src1 == src2);

}
",284,,LABEL_0,LABEL_0,LABEL_0,-1,"dstU,dstV,src1,src2,unused,i",,,,0,,0,GA,1198,0.3439193646113078,failed,
334,"uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);

    return (eeprom->eedo);

}
",58,,LABEL_0,LABEL_0,LABEL_0,-1,eeprom,,,,0,,0,GA,272,0.0608320673306783,failed,
335,"static int qiov_is_aligned(QEMUIOVector *qiov)

{

    int i;



    for (i = 0; i < qiov->niov; i++) {

        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
",56,,LABEL_0,LABEL_0,LABEL_0,-1,"qiov,i",,,,0,,0,GA,306,0.07007302045822143,failed,
336,"void ff_af_queue_close(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}
",46,,LABEL_0,LABEL_0,LABEL_0,-1,afq,,,,0,,0,GA,269,0.05982770125071208,failed,
337,"static av_always_inline void hyscale(SwsContext *c, int16_t *dst, int dstWidth,

                                     const uint8_t *src_in[4], int srcW, int xInc,

                                     const int16_t *hLumFilter,

                                     const int16_t *hLumFilterPos, int hLumFilterSize,

                                     uint8_t *formatConvBuffer,

                                     uint32_t *pal, int isAlpha)

{

    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;

    void (*convertRange)(int16_t *, int) = isAlpha ? NULL : c->lumConvertRange;

    const uint8_t *src = src_in[isAlpha ? 3 : 0];



    if (toYV12) {

        toYV12(formatConvBuffer, src, srcW, pal);

        src= formatConvBuffer;

    } else if (c->readLumPlanar && !isAlpha) {

        c->readLumPlanar(formatConvBuffer, src_in, srcW);

        src = formatConvBuffer;

    }



    if (!c->hyscale_fast) {

        c->hyScale(c, dst, dstWidth, src, hLumFilter, hLumFilterPos, hLumFilterSize);

    } else { // fast bilinear upscale / crap downscale

        c->hyscale_fast(c, dst, dstWidth, src, srcW, xInc);

    }



    if (convertRange)

        convertRange(dst, dstWidth);

}
",238,"static av_always_inline void hyscale(SwsContext *pc, int16_t *dst, int dstWidth,

                                     const uint8_t *src_in[4], int srcW, int xInc,

                                     const int16_t *hLumFilter,

                                     const int16_t *hLumFilterPos, int hLumFilterSize,

                                     uint8_t *formatConvBuffer,

                                     uint32_t *local, int isAlpha)

{

    void (*totoYV12uint8_t *, const uint8_t *, int, uint32_t *) = isisAlpha pc->alpToYV12 : pc->lumToYV12;

    void (*cconvertResource(int16_t *, int) = iisAlpha? NULL : pc->lumConvertRange;

    const uint8_t *support = src_in[isAlpha ? 3 : 0];



    if (toYV12) {

        totoYV12ormatConvBuffer, srsupportsrcW, local);

        support= formatConvBuffer;

    } else if (pc->readLumPlanar && !isAlpha) {

        pc->readLumPlanar(formatConvBuffer, src_in, srcW);

        support = formatConvBuffer;

    }



    if (!c->hyscale_fast) {

        pc->hyScale(pc, dst, dstWidth, support, hLumFilter, hLumFilterPos, hLumFilterSize);

    } else { // fast bilinear upscale / crap downscale

        pc->hyscale_fast(pc, dst, dstWidth, support, srcW, xInc);

    }



    if (convertResource)

        convertResource(dst, dstWidth);

}
",LABEL_1,LABEL_1,LABEL_0,1,"c,dst,dstWidth,src_in,srcW,xInc,hLumFilter,hLumFilterPos,hLumFilterSize,formatConvBuffer,pal,isAlpha,toYV12,convertRange,src",,,,35,"c:pc,dst:dst,dstWidth:dstWidth,src_in:src_in,srcW:srcW,xInc:xInc,hLumFilter:hLumFilter,hLumFilterPos:hLumFilterPos,hLumFilterSize:hLumFilterSize,formatConvBuffer:formatConvBuffer,pal:local,isAlpha:isAlpha,toYV12:toYV12,convertRange:convertResource,src:support,",11,GA,760,0.19067383607228597,GA,
338,"static int filter_frame(AVFilterLink *inlink, AVFrame *src_buffer)

{

    AVFilterContext  *ctx = inlink->dst;

    ATempoContext *atempo = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];



    int ret = 0;

    int n_in = src_buffer->nb_samples;

    int n_out = (int)(0.5 + ((double)n_in) / atempo->tempo);



    const uint8_t *src = src_buffer->data[0];

    const uint8_t *src_end = src + n_in * atempo->stride;



    while (src < src_end) {

        if (!atempo->dst_buffer) {

            atempo->dst_buffer = ff_get_audio_buffer(outlink, n_out);

            if (!atempo->dst_buffer)

                return AVERROR(ENOMEM);

            av_frame_copy_props(atempo->dst_buffer, src_buffer);



            atempo->dst = atempo->dst_buffer->data[0];

            atempo->dst_end = atempo->dst + n_out * atempo->stride;

        }



        yae_apply(atempo, &src, src_end, &atempo->dst, atempo->dst_end);



        if (atempo->dst == atempo->dst_end) {

            int n_samples = ((atempo->dst - atempo->dst_buffer->data[0]) /

                             atempo->stride);

            ret = push_samples(atempo, outlink, n_samples);

            if (ret < 0)

                goto end;

        }

    }



    atempo->nsamples_in += n_in;

end:

    av_frame_free(&src_buffer);

    return ret;

}
",290,,LABEL_1,LABEL_0,,-4,"inlink,src_buffer,ctx,atempo,outlink,src,src_end",,,,0,,0,Greedy,1,0.0003652016321818034,,
339,"static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *env = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        env->halted = 0;

        env->pil_in |= 1 << irq;

        cpu_check_irqs(env);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        env->pil_in &= ~(1 << irq);

        cpu_check_irqs(env);

    }

}
",95,"static void cpu_set_irq(void *operque, int irq, int url)

{

    CPUState *eenc= operque;



    if (url) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d
"", irq);

        enc->halted = 0;

        enc->pil_in |= 1 << irq;

        cpu_check_irqs(enc);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d
"", irq);

        enc->pil_in &= ~(1 << irq);

        cpu_check_irqs(enc);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,irq,level,env",,,,5,"opaque:operque,irq:irq,level:url,env:enc,",1,GA,220,0.05131001472473144,GA,
340,"void alpha_pci_vga_setup(PCIBus *pci_bus)

{

    switch (vga_interface_type) {

#ifdef CONFIG_SPICE

    case VGA_QXL:

        pci_create_simple(pci_bus, -1, ""qxl-vga"");

        return;

#endif

    case VGA_CIRRUS:

        pci_cirrus_vga_init(pci_bus);

        return;

    case VGA_VMWARE:

        if (pci_vmsvga_init(pci_bus)) {

            return;

        }

        break;

    }

    /* If VGA is enabled at all, and one of the above didn't work, then

       fallback to Standard VGA.  */

    if (vga_interface_type != VGA_NONE) {

        pci_vga_init(pci_bus);

    }

}
",98,,LABEL_0,LABEL_0,LABEL_0,-1,pci_bus,,,,0,,0,GA,263,0.061786210536956786,failed,
341,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)

{

    val = cpu_to_be64(val);

    cpu_physical_memory_write(addr, &val, 8);

}
",30,,LABEL_0,LABEL_0,LABEL_0,-1,"addr,val",,,,0,,0,GA,449,0.10717777411142985,failed,
342,"static int rtc_initfn(ISADevice *dev)

{

    RTCState *s = DO_UPCAST(RTCState, dev, dev);

    int base = 0x70;

    int isairq = 8;



    isa_init_irq(dev, &s->irq, isairq);



    s->cmos_data[RTC_REG_A] = 0x26;

    s->cmos_data[RTC_REG_B] = 0x02;

    s->cmos_data[RTC_REG_C] = 0x00;

    s->cmos_data[RTC_REG_D] = 0x80;



    rtc_set_date_from_host(s);



    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        s->coalesced_timer =

            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);

#endif

    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);

    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);



    s->next_second_time =

        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;

    qemu_mod_timer(s->second_timer2, s->next_second_time);



    register_ioport_write(base, 2, 1, cmos_ioport_write, s);

    register_ioport_read(base, 2, 1, cmos_ioport_read, s);



    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, s);

#endif

    qemu_register_reset(rtc_reset, s);

    return 0;

}
",254,,LABEL_0,LABEL_0,LABEL_0,-1,"dev,s",,,,0,,0,GA,498,0.13498429854710897,failed,
343,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",84,"static int parse_uint8(DeviceState *br, Property *prop, const char *ctr)

{

    uint8_t pr = qdev_get_prop_ptr(br, prop);

    const char *fMT;



    /* accept both hex and decimal */

    fMT = strncasecmp(ctr, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(ctrfMTmt, p) != 1)

        return -EINVAL;

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"dev,prop,str,ptr,fmt",,,,2,"dev:br,prop:prop,str:ctr,ptr:p,fmt:fMT,",1,GA,217,0.053595328330993654,GA,
344,"static int aasc_decode_frame(AVCodecContext *avctx,

                              void *data, int *data_size,

                              AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    AascContext *s = avctx->priv_data;

    int compr, i, stride;



    s->frame.reference = 3;

    s->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &s->frame)) {

        av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed\n"");

        return -1;

    }



    compr = AV_RL32(buf);

    buf += 4;

    buf_size -= 4;

    switch (avctx->codec_tag) {

    case MKTAG('A', 'A', 'S', '4'):

        bytestream2_init(&s->gb, buf - 4, buf_size + 4);

        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);

        break;

    case MKTAG('A', 'A', 'S', 'C'):

    switch(compr){

    case 0:

        stride = (avctx->width * 3 + 3) & ~3;

        for(i = avctx->height - 1; i >= 0; i--){

            if(avctx->width*3 > buf_size){

                av_log(avctx, AV_LOG_ERROR, ""Next line is beyond buffer bounds\n"");

                break;

            }

            memcpy(s->frame.data[0] + i*s->frame.linesize[0], buf, avctx->width*3);

            buf += stride;

            buf_size -= stride;

        }

        break;

    case 1:

        bytestream2_init(&s->gb, buf, buf_size);

        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);

        break;

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unknown compression type %d\n"", compr);

        return -1;

    }

        break;

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unknown FourCC: %X\n"", avctx->codec_tag);

        return -1;

    }



    *data_size = sizeof(AVFrame);

    *(AVFrame*)data = s->frame;



    /* report that the buffer was completely consumed */

    return buf_size;

}
",453,"static int aasc_decode_frame(AVCodecContext *avctx,

                              void *data, int *data___count,

                              AVPacket *avpkt)

{

    const uint8_t *ab = avpkt->data;

    int buf_size = avpkt->size;

    AascContext *its = avctx->priv_data;

    int compr, i, stride;



    its->frame.reference = 3;

    its->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &its->frame)) {

        av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed
"");

        return -1;

    }



   comprr = AV_RL32(ab);

    ab += 4;

    buf_size -= 4;

    switch (avctx->codec_tag) {

    case MKTAG('A', 'A', 'S', '4'):

        bytestream2_init(itss->gb, ab - 4, buf_size + 4);

        ff_msrle_decode(avctx, (AVPicture*)&its->frame, 8, &its->gb);

        break;

    case MKTAG('A', 'A', 'S', 'C'):

    switch(compr){

    case 0:

        stride = (avctx->width * 3 + 3) & ~3;

        for(i = avctx->height - 1; i >= 0; i--){

            if(avctx->width*3 > buf_size){

                av_log(avctx, AV_LOG_ERROR, ""Next line is beyond buffer bounds
"");

                break;

            }

            memcpyitss->frame.data[0] + iitss->frame.linesize[0], ab, avctx->width*3);

            ab += stride;

            buf_size -= stride;

        }

        break;

    case 1:

        bytestream2_init(itss->gb, ab, buf_size);

        ff_msrle_decode(avctx, (AVPicture*)&its->frame, 8, &its->gb);

        break;

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unknown compression type %d
"", compr);

        return -1;

    }

        break;

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unknown FourCC: %X
"", avctx->codec_tag);

        return -1;

    }



    *data___count = sizeof(AVFrame);

    *(AVFrame*)data = its->frame;



    /* report that the buffer was completely consumed */

    return buf_size;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,data,data_size,avpkt,buf,s,compr,i,stride",,,,36,"avctx:avctx,data:data,data_size:data___count,avpkt:avpkt,buf:ab,s:its,compr:compr,i:i,stride:stride,",6,GA,547,0.16286845604578654,GA,
345,"static void pci_init_mask_bridge(PCIDevice *d)

{

    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and

       PCI_SEC_LETENCY_TIMER */

    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);



    /* base and limit */

    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;

    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;

    pci_set_word(d->wmask + PCI_MEMORY_BASE,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,

                 PCI_PREF_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,

                 PCI_PREF_RANGE_MASK & 0xffff);



    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */

    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);



    /* Supported memory and i/o types */

    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;

    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;

    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_64);

    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_64);



/* TODO: add this define to pci_regs.h in linux and then in qemu. */

#define  PCI_BRIDGE_CTL_VGA_16BIT	0x10	/* VGA 16-bit decode */

#define  PCI_BRIDGE_CTL_DISCARD		0x100	/* Primary discard timer */

#define  PCI_BRIDGE_CTL_SEC_DISCARD	0x200	/* Secondary discard timer */

#define  PCI_BRIDGE_CTL_DISCARD_STATUS	0x400	/* Discard timer status */

#define  PCI_BRIDGE_CTL_DISCARD_SERR	0x800	/* Discard timer SERR# enable */

/*

 * TODO: Bridges default to 10-bit VGA decoding but we currently only

 * implement 16-bit decoding (no alias support).

 */

    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_PARITY |

                 PCI_BRIDGE_CTL_SERR |

                 PCI_BRIDGE_CTL_ISA |

                 PCI_BRIDGE_CTL_VGA |

                 PCI_BRIDGE_CTL_VGA_16BIT |

                 PCI_BRIDGE_CTL_MASTER_ABORT |

                 PCI_BRIDGE_CTL_BUS_RESET |

                 PCI_BRIDGE_CTL_FAST_BACK |

                 PCI_BRIDGE_CTL_DISCARD |

                 PCI_BRIDGE_CTL_SEC_DISCARD |

                 PCI_BRIDGE_CTL_DISCARD_SERR);

    /* Below does not do anything as we never set this bit, put here for

     * completeness. */

    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,

                 PCI_BRIDGE_CTL_DISCARD_STATUS);

    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;

    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;

    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,

                               PCI_PREF_RANGE_TYPE_MASK);

    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,

                               PCI_PREF_RANGE_TYPE_MASK);

}
",360,,LABEL_0,LABEL_0,LABEL_0,-1,d,,,,0,,0,GA,255,0.07460212310155233,failed,
346,"static void check_default_settings(AVCodecContext *avctx)

{

    X264Context *x4 = avctx->priv_data;



    int score = 0;

    score += x4->params.analyse.i_me_range == 0;

    score += x4->params.rc.i_qp_step == 3;

    score += x4->params.i_keyint_max == 12;

    score += x4->params.rc.i_qp_min == 2;

    score += x4->params.rc.i_qp_max == 31;

    score += x4->params.rc.f_qcompress == 0.5;

    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;

    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;

    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;

    if (score >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        x4->preset = av_strdup(""medium"");

        if (avctx->bit_rate == 200*1000)

            avctx->crf = 23;

    }

}
",214,,LABEL_0,LABEL_0,LABEL_0,-1,"avctx,x4",,,,0,,0,GA,531,0.1368581970532735,failed,
347,"static int raw_init_encoder(AVCodecContext *avctx)

{

    avctx->coded_frame = (AVFrame *)avctx->priv_data;

    avctx->coded_frame->pict_type = FF_I_TYPE;

    avctx->coded_frame->key_frame = 1;

    avctx->codec_tag = findFourCC(avctx->pix_fmt);

    return 0;

}
",62,,LABEL_0,LABEL_0,LABEL_0,-1,avctx,,,,0,,0,GA,275,0.058772770563761394,failed,
348,"static int idcin_decode_init(AVCodecContext *avctx)

{

    IdcinContext *s = avctx->priv_data;

    int i, j, histogram_index = 0;

    unsigned char *histograms;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&s->dsp, avctx);



    /* make sure the Huffman tables make it */

    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    histograms = (unsigned char *)s->avctx->extradata;

    for (i = 0; i < 256; i++) {

        for(j = 0; j < HUF_TOKENS; j++)

            s->huff_nodes[i][j].count = histograms[histogram_index++];

        huff_build_tree(s, i);

    }



    s->frame.data[0] = NULL;



    return 0;

}
",212,"static int idcin_decode_init(AVCodecContext *avctx)

{

    IdcinContext *http = avctx->priv_data;

    int oi, y, histogram_index = 0;

    unsigned char * histographies;



    http->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&http->dsp, avctx);



    /* make sure the Huffman tables make it */

    if (http->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(http->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d
"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    his histographies(unsigned char *)http->avctx->extradata;

    for (oi = 0; oi < 256; oi++) {

        for(y = 0; y < HUF_TOKENS; y++)

            http->huff_nodes[oi][y].count =  histographies[histogram_index++];

        huff_build_tree(http, oi);

    }



    http->frame.data[0] = NULL;



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,s,i,j,histograms",,,,9,"avctx:avctx,s:http,i:oi,j:y,histograms: histographies,",1,GA,321,0.07546646197636922,GA,
349,"void readline_show_prompt(ReadLineState *rs)

{

    monitor_printf(rs->mon, ""%s"", rs->prompt);

    monitor_flush(rs->mon);

    rs->last_cmd_buf_index = 0;

    rs->last_cmd_buf_size = 0;

    rs->esc_state = IS_NORM;

}
",54,,LABEL_0,LABEL_0,LABEL_0,-1,rs,,,,0,,0,GA,253,0.05345578988393148,failed,
350,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)

{

    int i = 0;

    int x = 0;

    uint32_t l_64 = (l + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",

               __func__, l, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((l > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, l + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);

        return;

    } else {

        memmove(g2h(dest), g2h(src), l + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if (dest != (src + 1)) {

        for (i = 0; i < l_64; i++) {

            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));

            x += 8;

        }

    }



    /* slow version crossing pages with byte accesses */

    for (i = x; i <= l; i++) {

        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));

    }

}
",336,,LABEL_1,LABEL_0,,-4,"env,l,dest,src,i",,,,0,,0,Greedy,1,0.0006260871887207031,,
351,"static void setup_frame(int sig, struct emulated_sigaction *ka,

			target_sigset_t *set, CPUX86State *env)

{

	struct sigframe *frame;

	int err = 0;



	frame = get_sigframe(ka, env, sizeof(*frame));



#if 0

	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))

		goto give_sigsegv;

#endif

	err |= __put_user((/*current->exec_domain

		           && current->exec_domain->signal_invmap

		           && sig < 32

		           ? current->exec_domain->signal_invmap[sig]

		           : */ sig),

		          &frame->sig);

	if (err)

		goto give_sigsegv;



	setup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);

	if (err)

		goto give_sigsegv;



	if (TARGET_NSIG_WORDS > 1) {

		err |= __copy_to_user(frame->extramask, &set->sig[1],

				      sizeof(frame->extramask));

	}

	if (err)

		goto give_sigsegv;



	/* Set up to return from userspace.  If provided, use a stub

	   already in userspace.  */

	if (ka->sa.sa_flags & TARGET_SA_RESTORER) {

		err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);

	} else {

		err |= __put_user(frame->retcode, &frame->pretcode);

		/* This is popl %eax ; movl $,%eax ; int $0x80 */

		err |= __put_user(0xb858, (short *)(frame->retcode+0));

		err |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));

		err |= __put_user(0x80cd, (short *)(frame->retcode+6));

	}



	if (err)

		goto give_sigsegv;



	/* Set up registers for signal handler */

	env->regs[R_ESP] = (unsigned long) frame;

	env->eip = (unsigned long) ka->sa._sa_handler;



        cpu_x86_load_seg(env, R_DS, __USER_DS);

        cpu_x86_load_seg(env, R_ES, __USER_DS);

        cpu_x86_load_seg(env, R_SS, __USER_DS);

        cpu_x86_load_seg(env, R_CS, __USER_CS);

	env->eflags &= ~TF_MASK;



	return;



give_sigsegv:

	if (sig == TARGET_SIGSEGV)

		ka->sa._sa_handler = TARGET_SIG_DFL;

	force_sig(TARGET_SIGSEGV /* , current */);

}
",465,"static void setup_frame(int setsig, struct emulated_sigaction *ja,

			target_sigset_t *start, CPUX86State *define)

{

	struct sigframe *block;

	int err = 0;



	frablockget_sigframe(ja, define, sizeof(*block));



#if 0

	if (!access_ok(VERIFY_WRITE, block, sizeof(*block)))

		goto give_sigsegv;

#endif

	err |= __put_user((/*current->exec_domain

		           && current->exec_domain->signal_invmap

		           && setsig < 32

		           ? current->exec_domain->signal_invmap[setsig]

		           : */ setsig),

		          &frablocketsig);

	if (err)

		goto give_sigsegv;



	setup_sigcontext(&frame->sblockrame->fblocke, env, definestartetsig[0]);

	if (err)

		goto give_sigsegv;



	if (TARGET_NSIG_WORDS > 1) {

		err |= __copy_to_user(frameblockramask, &setstartetsig[1],

				      sizeof(block->extramask));

	}

	if (err)

		goto give_sigsegv;



	/* Set up to return from userspace.  If provided, use a stub

	   already in userspace.  */

	if (ja->sa.sa_flags & TARGET_SA_RESTORER) {

		err |= __put_user(ja->sa.sa_restorer, &block->pretcode);

	} else {

		err |= __put_user(block->retcode, &block->pretcode);

		/* This is popl %eax ; movl $,%eax ; int $0x80 */

		err |= __put_user(0xb858, (short *)(block->retcode+0));

		err |= __put_user(TARGET_NR_sigreturn, (int *)(block->retcode+2));

		err |= __put_user(0x80cd, (short *)(block->retcode+6));

	}



	if (err)

		goto give_sigsegv;



	/* Set up registers for signal handler */

	define->regs[R_ESP] = (unsigned long) block;

	define->eip = (unsigned long) ja->sa._sa_handler;



        cpu_x86_load_seg(define, R_DS, __USER_DS);

        cpu_x86_load_seg(define, R_ES, __USER_DS);

        cpu_x86_load_seg(define, R_SS, __USER_DS);

        cpu_x86_load_seg(define, R_CS, __USER_CS);

	define->eflags &= ~TF_MASK;



	return;



give_sigsegv:

	if (setsig == TARGET_SIGSEGV)

		ja->sa._sa_handler = TARGET_SIG_DFL;

	force_sig(TARGET_SIGSEGV /* , current */);

}
",LABEL_0,LABEL_0,LABEL_1,1,"sig,ka,set,env,frame",,,,0,"sig:setsig,ka:ja,set:start,env:define,frame:block,",0,GA,710,0.18944067160288494,GA,
352,"static av_cold int ac3_decode_init(AVCodecContext *avctx)

{

    AC3DecodeContext *s = avctx->priv_data;

    s->avctx = avctx;



    ff_ac3_common_init();

    ac3_tables_init();

    ff_mdct_init(&s->imdct_256, 8, 1, 1.0);

    ff_mdct_init(&s->imdct_512, 9, 1, 1.0);

    ff_kbd_window_init(s->window, 5.0, 256);

    dsputil_init(&s->dsp, avctx);

    ff_fmt_convert_init(&s->fmt_conv, avctx);

    av_lfg_init(&s->dith_state, 0);



    /* set scale value for float to int16 conversion */

    s->mul_bias = 32767.0f;



    /* allow downmixing to stereo or mono */

    if (avctx->channels > 0 && avctx->request_channels > 0 &&

            avctx->request_channels < avctx->channels &&

            avctx->request_channels <= 2) {

        avctx->channels = avctx->request_channels;

    }

    s->downmixed = 1;



    /* allocate context input buffer */

    if (avctx->error_recognition >= FF_ER_CAREFUL) {

        s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!s->input_buffer)

            return AVERROR(ENOMEM);

    }



    avctx->sample_fmt = AV_SAMPLE_FMT_S16;

    return 0;

}
",248,,LABEL_1,LABEL_0,,-4,"avctx,s",,,,0,,0,Greedy,1,0.0004957159360249837,,
353,"static void build_feed_streams(void)

{

    FFStream *stream, *feed;

    int i;



    /* gather all streams */

    for(stream = first_stream; stream != NULL; stream = stream->next) {

        feed = stream->feed;

        if (feed) {

            if (!stream->is_feed) {

                /* we handle a stream coming from a feed */

                for(i=0;i<stream->nb_streams;i++)

                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);

            }

        }

    }



    /* gather all streams */

    for(stream = first_stream; stream != NULL; stream = stream->next) {

        feed = stream->feed;

        if (feed) {

            if (stream->is_feed) {

                for(i=0;i<stream->nb_streams;i++)

                    stream->feed_streams[i] = i;

            }

        }

    }



    /* create feed files if needed */

    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {

        int fd;



        if (url_exist(feed->feed_filename)) {

            /* See if it matches */

            AVFormatContext *s;

            int matches = 0;



            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {

                /* Now see if it matches */

                if (s->nb_streams == feed->nb_streams) {

                    matches = 1;

                    for(i=0;i<s->nb_streams;i++) {

                        AVStream *sf, *ss;

                        sf = feed->streams[i];

                        ss = s->streams[i];



                        if (sf->index != ss->index ||

                            sf->id != ss->id) {

                            http_log(""Index & Id do not match for stream %d (%s)\n"",

                                   i, feed->feed_filename);

                            matches = 0;

                        } else {

                            AVCodecContext *ccf, *ccs;



                            ccf = sf->codec;

                            ccs = ss->codec;

#define CHECK_CODEC(x)  (ccf->x != ccs->x)



                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {

                                http_log(""Codecs do not match for stream %d\n"", i);

                                matches = 0;

                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {

                                http_log(""Codec bitrates do not match for stream %d\n"", i);

                                matches = 0;

                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {

                                if (CHECK_CODEC(time_base.den) ||

                                    CHECK_CODEC(time_base.num) ||

                                    CHECK_CODEC(width) ||

                                    CHECK_CODEC(height)) {

                                    http_log(""Codec width, height and framerate do not match for stream %d\n"", i);

                                    matches = 0;

                                }

                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {

                                if (CHECK_CODEC(sample_rate) ||

                                    CHECK_CODEC(channels) ||

                                    CHECK_CODEC(frame_size)) {

                                    http_log(""Codec sample_rate, channels, frame_size do not match for stream %d\n"", i);

                                    matches = 0;

                                }

                            } else {

                                http_log(""Unknown codec type\n"");

                                matches = 0;

                            }

                        }

                        if (!matches)

                            break;

                    }

                } else

                    http_log(""Deleting feed file '%s' as stream counts differ (%d != %d)\n"",

                        feed->feed_filename, s->nb_streams, feed->nb_streams);



                av_close_input_file(s);

            } else

                http_log(""Deleting feed file '%s' as it appears to be corrupt\n"",

                        feed->feed_filename);



            if (!matches) {

                if (feed->readonly) {

                    http_log(""Unable to delete feed file '%s' as it is marked readonly\n"",

                        feed->feed_filename);

                    exit(1);

                }

                unlink(feed->feed_filename);

            }

        }

        if (!url_exist(feed->feed_filename)) {

            AVFormatContext s1 = {0}, *s = &s1;



            if (feed->readonly) {

                http_log(""Unable to create feed file '%s' as it is marked readonly\n"",

                    feed->feed_filename);

                exit(1);

            }



            /* only write the header of the ffm file */

            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {

                http_log(""Could not open output feed file '%s'\n"",

                         feed->feed_filename);

                exit(1);

            }

            s->oformat = feed->fmt;

            s->nb_streams = feed->nb_streams;

            for(i=0;i<s->nb_streams;i++) {

                AVStream *st;

                st = feed->streams[i];

                s->streams[i] = st;

            }

            av_set_parameters(s, NULL);

            if (av_write_header(s) < 0) {

                http_log(""Container doesn't supports the required parameters\n"");

                exit(1);

            }

            /* XXX: need better api */

            av_freep(&s->priv_data);

            avio_close(s->pb);

        }

        /* get feed size and write index */

        fd = open(feed->feed_filename, O_RDONLY);

        if (fd < 0) {

            http_log(""Could not open output feed file '%s'\n"",

                    feed->feed_filename);

            exit(1);

        }



        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);

        feed->feed_size = lseek(fd, 0, SEEK_END);

        /* ensure that we do not wrap before the end of file */

        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)

            feed->feed_max_size = feed->feed_size;



        close(fd);

    }

}
",1136,"static void build_feed_streams(void)

{

    FFStream *full, *feed;

    int start;



    /* gather all streams */

    for(full = first_stream; full != NULL; full = full->next) {

      feeded = full->feed;

        if (feed) {

            if (!stream->is_feed) {

                /* we handle a full coming from a feed */

                fostart(i=start;i<full->nb_streams;start++)

                    full->feed_streamstart[i] = add_av_streafeeded, full->streams[start]);

            }

        }

    }



    /* gather all streams */

    for(full = first_stream; full != NULL; full = full->next) {

      feeded = full->feed;

        if (feed) {

            if (full->is_feed) {

                fostart(i=start;i<full->nb_streams;start++)

                    full->feed_streams[start] = start;

            }

        }

    }



    /* create feed files if needed */

    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {

        int fd;



        if (url_exist(feed->feed_filename)) {

            /* See if it matches */

            AVFormatContext *sets;

            int matches = 0;



            if (av_open_input_file(&sets, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {

                /* Now see if it matches */

                if (sets->nb_streams == feed->nb_streams) {

                    matches = 1;

                    for(start=0;start<s->nsets_streams;start++) {

                        AVStream *fx, *uss;

                        sf =fxeed->streams[start];

                        ss = s-usssetsreams[start];



                        if (fx->index != uss->index ||

                            fx->id != uss->id) {

                            http_log(""Index & Id do not match for full %d (%sets)
"",

                                   start, feed->feed_filename);

                            matches = 0;

                        } else {

                            AVCodecContext *cffs, *accl;



                            cffs = fx->codec;

                            caccl= uss->codec;

#define CHECK_CODEC(x)  (ccf->x != ccs->x)



                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {

                                http_log(""Codecs do not match for full %d
"", start);

                                matches = 0;

                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {

                                http_log(""Codec bitrates do not match for full %d
"", start);

                                matches = 0;

                            } else if (cffs->codec_type == AVMEDIA_TYPE_VIDEO) {

                                if (CHECK_CODEC(time_base.den) ||

                                    CHECK_CODEC(time_base.num) ||

                                    CHECK_CODEC(width) ||

                                    CHECK_CODEC(height)) {

                                    http_log(""Codec width, height and framerate do not match for full %d
"", start);

                                    matches = 0;

                                }

                            } else if (cffs->codec_type == AVMEDIA_TYPE_AUDIO) {

                                if (CHECK_CODEC(sample_rate) ||

                                    CHECK_CODEC(channels) ||

                                    CHECK_CODEC(frame_size)) {

                                    http_log(""Codec sample_rate, channels, frame_size do not match for full %d
"", start);

                                    matches = 0;

                                }

                            } else {

                                http_log(""Unknown codec type
"");

                                matches = 0;

                            }

                        }

                        if (!matches)

                            break;

                    }

                } else

                    http_log(""Deletinfeeded file '%s' as full counts differ (%d != %d)
"",

                        feed->feed_filename, sets->nb_streams, feed->nb_streams);



                av_close_input_file(sets);

            } else

                http_log(""Deleting feed file '%s' as it appears to be corrupt
"",

                        feed->feed_filename);



            if (!matches) {

                if (feed->readonly) {

                    http_log(""Unable to delete feed file '%s' as it is marked readonly
"",

                        feed->feed_filename);

                    exit(1);

                }

                unlink(feed->feed_filename);

            }

        }

        if (!url_exist(feed->feed_filename)) {

            AVFormatContext s1 = {0}, *sets = &s1;



            if (feed->readonly) {

                http_log(""Unable to create feed file '%s' as it is marked readonly
"",

                    feed->feed_filename);

                exit(1);

            }



            /* only write the header of the ffm file */

            if (avio_open(&sets->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {

                http_log(""Could not open output feed file '%s'
"",

                         feed->feed_filename);

                exit(1);

            }

            sets->oformat = feed->fmt;

            sets->nb_streams = feed->nb_streams;

            for(start=0;start<s->nsets_streams;start++) {

                AVStream *st;

                st = feed->streams[start];

                s->ssetsreams[start] = st;

            }

            av_set_parameters(sets, NULL);

            if (av_write_header(sets) < 0) {

                http_log(""Container doesn't supports the required parameters
"");

                exit(1);

            }

            /* XXX: need better api */

            av_freep(&sets->priv_data);

            avio_close(sets->pb);

        }

        /* get feed size and write index */

        fd = open(feed->feed_filename, O_RDONLY);

        if (fd < 0) {

            http_log(""Could not open output feed file '%s'
"",

                    feed->feed_filename);

            exit(1);

        }



        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);

        feed->feed_size = lseek(fd, 0, SEEK_END);

        /* ensure that we do not wrap before the end of file */

        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)

            feed->feed_max_size = feed->feed_size;



        close(fd);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"stream,feed,i,fd,s,sf,ss,ccf,ccs",,,,55,"stream:full,feed:feed,i:start,fd:fd,s:sets,sf:fx,ss:uss,ccf:cffs,ccs:accl,",2,GA,550,0.23081486622492473,GA,
354,"uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,

                      uint64_t cpu_addr)

{

    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;



    HELPER_LOG(""%s: %016"" PRIx64 "" %08x %016"" PRIx64 ""\n"",

               __func__, order_code, r1, cpu_addr);



    /* Remember: Use ""R1 or R1 + 1, whichever is the odd-numbered register""

       as parameter (input). Status (output) is always R1. */



    switch (order_code) {

    case SIGP_SET_ARCH:

        /* switch arch */

        break;

    case SIGP_SENSE:

        /* enumerate CPU status */

        if (cpu_addr) {

            /* XXX implement when SMP comes */

            return 3;

        }

        env->regs[r1] &= 0xffffffff00000000ULL;

        cc = 1;

        break;

#if !defined(CONFIG_USER_ONLY)

    case SIGP_RESTART:

        qemu_system_reset_request();

        cpu_loop_exit(CPU(s390_env_get_cpu(env)));

        break;

    case SIGP_STOP:

        qemu_system_shutdown_request();

        cpu_loop_exit(CPU(s390_env_get_cpu(env)));

        break;

#endif

    default:

        /* unknown sigp */

        fprintf(stderr, ""XXX unknown sigp: 0x%"" PRIx64 ""\n"", order_code);

        cc = SIGP_CC_NOT_OPERATIONAL;

    }



    return cc;

}
",196,,LABEL_0,LABEL_0,LABEL_0,-1,"env,order_code,r1,cpu_addr",,,,0,,0,GA,681,0.17986300388971965,failed,
355,"static void process_client(AVIOContext *client, const char *in_uri)

{

    AVIOContext *input = NULL;

    uint8_t buf[1024];

    int ret, n, reply_code;

    uint8_t *resource = NULL;

    while ((ret = avio_handshake(client)) > 0) {

        av_opt_get(client, ""resource"", AV_OPT_SEARCH_CHILDREN, &resource);

        // check for strlen(resource) is necessary, because av_opt_get()

        // may return empty string.

        if (resource && strlen(resource))

            break;


    }

    if (ret < 0)

        goto end;

    av_log(client, AV_LOG_TRACE, ""resource=%p\n"", resource);

    if (resource && resource[0] == '/' && !strcmp((resource + 1), in_uri)) {

        reply_code = 200;

    } else {

        reply_code = AVERROR_HTTP_NOT_FOUND;

    }

    if ((ret = av_opt_set_int(client, ""reply_code"", reply_code, AV_OPT_SEARCH_CHILDREN)) < 0) {

        av_log(client, AV_LOG_ERROR, ""Failed to set reply_code: %s.\n"", av_err2str(ret));

        goto end;

    }

    av_log(client, AV_LOG_TRACE, ""Set reply code to %d\n"", reply_code);



    while ((ret = avio_handshake(client)) > 0);



    if (ret < 0)

        goto end;



    fprintf(stderr, ""Handshake performed.\n"");

    if (reply_code != 200)

        goto end;

    fprintf(stderr, ""Opening input file.\n"");

    if ((ret = avio_open2(&input, in_uri, AVIO_FLAG_READ, NULL, NULL)) < 0) {

        av_log(input, AV_LOG_ERROR, ""Failed to open input: %s: %s.\n"", in_uri,

               av_err2str(ret));

        goto end;

    }

    for(;;) {

        n = avio_read(input, buf, sizeof(buf));

        if (n < 0) {

            if (n == AVERROR_EOF)

                break;

            av_log(input, AV_LOG_ERROR, ""Error reading from input: %s.\n"",

                   av_err2str(n));

            break;

        }

        avio_write(client, buf, n);

        avio_flush(client);

    }

end:

    fprintf(stderr, ""Flushing client\n"");

    avio_flush(client);

    fprintf(stderr, ""Closing client\n"");

    avio_close(client);

    fprintf(stderr, ""Closing input\n"");

    avio_close(input);


}",460,,LABEL_1,LABEL_1,LABEL_1,-1,"client,in_uri,input,buf,ret,n,reply_code,resource",,,,0,,0,GA,1630,0.49658875465393065,failed,
356,"static void virtio_init_pci(VirtIOPCIProxy *proxy, VirtIODevice *vdev,

                            uint16_t vendor, uint16_t device,

                            uint16_t class_code, uint8_t pif)

{

    uint8_t *config;

    uint32_t size;



    proxy->vdev = vdev;



    config = proxy->pci_dev.config;

    pci_config_set_vendor_id(config, vendor);

    pci_config_set_device_id(config, device);



    config[0x08] = VIRTIO_PCI_ABI_VERSION;



    config[0x09] = pif;

    pci_config_set_class(config, class_code);



    config[0x2c] = vendor & 0xFF;

    config[0x2d] = (vendor >> 8) & 0xFF;

    config[0x2e] = vdev->device_id & 0xFF;

    config[0x2f] = (vdev->device_id >> 8) & 0xFF;



    config[0x3d] = 1;



    if (vdev->nvectors && !msix_init(&proxy->pci_dev, vdev->nvectors, 1, 0)) {

        pci_register_bar(&proxy->pci_dev, 1,

                         msix_bar_size(&proxy->pci_dev),

                         PCI_BASE_ADDRESS_SPACE_MEMORY,

                         msix_mmio_map);

    } else

        vdev->nvectors = 0;



    proxy->pci_dev.config_write = virtio_write_config;



    size = VIRTIO_PCI_REGION_SIZE(&proxy->pci_dev) + vdev->config_len;

    if (size & (size-1))

        size = 1 << qemu_fls(size);



    pci_register_bar(&proxy->pci_dev, 0, size, PCI_BASE_ADDRESS_SPACE_IO,

                           virtio_map);



    if (!kvm_has_many_ioeventfds()) {

        proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;

    }



    virtio_bind_device(vdev, &virtio_pci_bindings, proxy);

    proxy->host_features |= 0x1 << VIRTIO_F_NOTIFY_ON_EMPTY;

    proxy->host_features |= 0x1 << VIRTIO_F_BAD_FEATURE;

    proxy->host_features = vdev->get_features(vdev, proxy->host_features);

}
",327,"static void virtio_init_pci(VirtIOPCIProxy *pool, VirtIODevice * vdiv,

                            uint16_t vendor, uint16_t directory,

                            uint16_t  class_id, uint8_t pif)

{

    uint8_t *config;

    uint32_t size;



    pool-> vdiv =  vdiv;



   configg = pool->pci_dev.config;

    pci_config_set_vendor_id(config, vendor);

    pci_config_set_device_id(conconfigirectory);



    config[0x08] = VIRTIO_PCI_ABI_VERSION;



    config[0x09] = pif;

    pci_config_set_classconfigg,  class_id);



    config[0x2c] = vendor & 0xFF;

    config[0x2d] = (vendor >> 8) & 0xFF;

    cconfig0x2e] =  vdiv->device_id & 0xFF;

    cconfig0x2f] = ( vdiv->device_id >> 8) & 0xFF;



    config[0x3d] = 1;



    if  vdivv->nvectors && !msix_init(&pool->pci_dev,  vdiv->nvectors, 1, 0)) {

        pci_register_bar(&pool->pci_dev, 1,

                         msix_bar_size(&pool->pci_dev),

                         PCI_BASE_ADDRESS_SPACE_MEMORY,

                         msix_mmio_map);

    } else

         vdiv->nvectors = 0;



    pool->pci_dev.config_write = virtio_write_config;



    size = VIRTIO_PCI_REGION_SIZE(&pool->pci_dev) +  vdiv->config_len;

    if (size & (size-1))

        size = 1 << qemu_fls(size);



    pci_register_bar(&pool->pci_dev, 0, size, PCI_BASE_ADDRESS_SPACE_IO,

                           virtio_map);



    if (!kvm_has_many_ioeventfds()) {

        pool->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;

    }



    virtio_bind_device vdivv, &virtio_pci_bindings, pool);

    pool->host_features |= 0x1 << VIRTIO_F_NOTIFY_ON_EMPTY;

    pool->host_features |= 0x1 << VIRTIO_F_BAD_FEATURE;

    pool->host_features = vdivv->get_features vdivv, pool->host_features);

}
",LABEL_0,LABEL_0,LABEL_1,1,"proxy,vdev,vendor,device,class_code,pif,config,size",,,,26,"proxy:pool,vdev: vdiv,vendor:vendor,device:directory,class_code: class_id,pif:pif,config:config,size:size,",4,GA,478,0.12883933782577514,GA,
357,"static AVFrame *do_psnr(AVFilterContext *ctx, AVFrame *main,

                        const AVFrame *ref)

{

    PSNRContext *s = ctx->priv;

    double comp_mse[4], mse = 0;

    int j, c;

    AVDictionary **metadata = avpriv_frame_get_metadatap(main);



    s->compute_mse(s, (const uint8_t **)main->data, main->linesize,

                      (const uint8_t **)ref->data, ref->linesize,

                       main->width, main->height, comp_mse);



    for (j = 0; j < s->nb_components; j++)

        mse += comp_mse[j] * s->planeweight[j];



    s->min_mse = FFMIN(s->min_mse, mse);

    s->max_mse = FFMAX(s->max_mse, mse);



    s->mse += mse;

    for (j = 0; j < s->nb_components; j++)

        s->mse_comp[j] += comp_mse[j];

    s->nb_frames++;



    for (j = 0; j < s->nb_components; j++) {

        c = s->is_rgb ? s->rgba_map[j] : j;

        set_meta(metadata, ""lavfi.psnr.mse."", s->comps[j], comp_mse[c]);

        set_meta(metadata, ""lavfi.psnr.psnr."", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));

    }

    set_meta(metadata, ""lavfi.psnr.mse_avg"", 0, mse);

    set_meta(metadata, ""lavfi.psnr.psnr_avg"", 0, get_psnr(mse, 1, s->average_max));



    if (s->stats_file) {

        fprintf(s->stats_file, ""n:%""PRId64"" mse_avg:%0.2f "", s->nb_frames, mse);

        for (j = 0; j < s->nb_components; j++) {

            c = s->is_rgb ? s->rgba_map[j] : j;

            fprintf(s->stats_file, ""mse_%c:%0.2f "", s->comps[j], comp_mse[c]);

        }

        for (j = 0; j < s->nb_components; j++) {

            c = s->is_rgb ? s->rgba_map[j] : j;

            fprintf(s->stats_file, ""psnr_%c:%0.2f "", s->comps[j],

                    get_psnr(comp_mse[c], 1, s->max[c]));

        }

        fprintf(s->stats_file, ""\n"");

    }



    return main;

}
",503,,LABEL_1,LABEL_0,,-4,"ctx,ref,s,comp_mse,j,c,metadata,nb_frames",,,,0,,0,Greedy,1,0.0007182995478312175,,
358,"static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,

                               uint64_t value, unsigned size)

{

    musicpal_lcd_state *s = opaque;



    switch (offset) {

    case MP_LCD_IRQCTRL:

        s->irqctrl = value;

        break;



    case MP_LCD_SPICTRL:

        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {

            s->mode = value;

        } else {

            s->mode = MP_LCD_SPI_INVALID;

        }

        break;



    case MP_LCD_INST:

        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {

            s->page = value - MP_LCD_INST_SETPAGE0;

            s->page_off = 0;

        }

        break;



    case MP_LCD_DATA:

        if (s->mode == MP_LCD_SPI_CMD) {

            if (value >= MP_LCD_INST_SETPAGE0 &&

                value <= MP_LCD_INST_SETPAGE7) {

                s->page = value - MP_LCD_INST_SETPAGE0;

                s->page_off = 0;

            }

        } else if (s->mode == MP_LCD_SPI_DATA) {

            s->video_ram[s->page*128 + s->page_off] = value;

            s->page_off = (s->page_off + 1) & 127;

        }

        break;

    }

}
",208,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,offset,value,size,s",,,,0,,0,GA,869,0.24406729539235433,failed,
359,"static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab)

{

    CURSORINFO ci = {0};



#define CURSOR_ERROR(str)                 \

    if (!gdigrab->cursor_error_printed) {       \

        WIN32_API_ERROR(str);             \

        gdigrab->cursor_error_printed = 1;      \

    }



    ci.cbSize = sizeof(ci);



    if (GetCursorInfo(&ci)) {

        HCURSOR icon = CopyCursor(ci.hCursor);

        ICONINFO info;

        POINT pos;

        RECT clip_rect = gdigrab->clip_rect;

        HWND hwnd = gdigrab->hwnd;

        info.hbmMask = NULL;

        info.hbmColor = NULL;



        if (ci.flags != CURSOR_SHOWING)

            return;



        if (!icon) {

            /* Use the standard arrow cursor as a fallback.

             * You'll probably only hit this in Wine, which can't fetch

             * the current system cursor. */

            icon = CopyCursor(LoadCursor(NULL, IDC_ARROW));

        }



        if (!GetIconInfo(icon, &info)) {

            CURSOR_ERROR(""Could not get icon info"");

            goto icon_error;

        }



        pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot;

        pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot;



        if (hwnd) {

            RECT rect;



            if (GetWindowRect(hwnd, &rect)) {

                pos.x -= rect.left;

                pos.y -= rect.top;

            } else {

                CURSOR_ERROR(""Couldn't get window rectangle"");

                goto icon_error;

            }

        }



        av_log(s1, AV_LOG_DEBUG, ""Cursor pos (%li,%li) -> (%li,%li)\n"",

                ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y);



        if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left &&

                pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) {

            if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon))

                CURSOR_ERROR(""Couldn't draw icon"");

        }



icon_error:





        if (icon)

            DestroyCursor(icon);

    } else {

        CURSOR_ERROR(""Couldn't get cursor info"");

    }

}",401,,LABEL_1,LABEL_0,,-4,"s1,gdigrab,info,pos,rect",,,,0,,0,Greedy,1,0.0006184140841166178,,
360,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){

    c->bytestream_start=

    c->bytestream= buf;

    c->bytestream_end= buf + buf_size;



#if CABAC_BITS == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}
",121,,LABEL_1,LABEL_0,,-4,"c,buf,buf_size",,,,0,,0,Greedy,1,0.0004321416219075521,,
361,"void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
",54,,LABEL_0,LABEL_0,LABEL_0,-1,mr,,,,0,,0,GA,269,0.06480693817138672,failed,
362,"static void event_loop(VideoState *cur_stream)

{

    SDL_Event event;

    double incr, pos, frac;



    for(;;) {

        double x;

        SDL_WaitEvent(&event);

        switch(event.type) {

        case SDL_KEYDOWN:

            if (exit_on_keydown) {

                do_exit(cur_stream);

                break;

            }

            switch(event.key.keysym.sym) {

            case SDLK_ESCAPE:

            case SDLK_q:

                do_exit(cur_stream);

                break;

            case SDLK_f:

                toggle_full_screen(cur_stream);

                break;

            case SDLK_p:

            case SDLK_SPACE:

                if (cur_stream)

                    toggle_pause(cur_stream);

                break;

            case SDLK_s: //S: Step to next frame

                if (cur_stream)

                    step_to_next_frame(cur_stream);

                break;

            case SDLK_a:

                if (cur_stream)

                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO);

                break;

            case SDLK_v:

                if (cur_stream)

                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO);

                break;

            case SDLK_t:

                if (cur_stream)

                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE);

                break;

            case SDLK_w:

                if (cur_stream)

                    toggle_audio_display(cur_stream);

                break;

            case SDLK_LEFT:

                incr = -10.0;

                goto do_seek;

            case SDLK_RIGHT:

                incr = 10.0;

                goto do_seek;

            case SDLK_UP:

                incr = 60.0;

                goto do_seek;

            case SDLK_DOWN:

                incr = -60.0;

            do_seek:

                if (cur_stream) {

                    if (seek_by_bytes) {

                        if (cur_stream->video_stream >= 0 && cur_stream->video_current_pos>=0){

                            pos= cur_stream->video_current_pos;

                        }else if(cur_stream->audio_stream >= 0 && cur_stream->audio_pkt.pos>=0){

                            pos= cur_stream->audio_pkt.pos;

                        }else

                            pos = avio_tell(cur_stream->ic->pb);

                        if (cur_stream->ic->bit_rate)

                            incr *= cur_stream->ic->bit_rate / 8.0;

                        else

                            incr *= 180000.0;

                        pos += incr;

                        stream_seek(cur_stream, pos, incr, 1);

                    } else {

                        pos = get_master_clock(cur_stream);

                        pos += incr;

                        stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE), (int64_t)(incr * AV_TIME_BASE), 0);

                    }

                }

                break;

            default:

                break;

            }

            break;

        case SDL_MOUSEBUTTONDOWN:

            if (exit_on_mousedown) {

                do_exit(cur_stream);

                break;

            }

        case SDL_MOUSEMOTION:

            if(event.type ==SDL_MOUSEBUTTONDOWN){

                x= event.button.x;

            }else{

                if(event.motion.state != SDL_PRESSED)

                    break;

                x= event.motion.x;

            }

            if (cur_stream) {

                if(seek_by_bytes || cur_stream->ic->duration<=0){

                    uint64_t size=  avio_size(cur_stream->ic->pb);

                    stream_seek(cur_stream, size*x/cur_stream->width, 0, 1);

                }else{

                    int64_t ts;

                    int ns, hh, mm, ss;

                    int tns, thh, tmm, tss;

                    tns = cur_stream->ic->duration/1000000LL;

                    thh = tns/3600;

                    tmm = (tns%3600)/60;

                    tss = (tns%60);

                    frac = x/cur_stream->width;

                    ns = frac*tns;

                    hh = ns/3600;

                    mm = (ns%3600)/60;

                    ss = (ns%60);

                    fprintf(stderr, ""Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d)       \n"", frac*100,

                            hh, mm, ss, thh, tmm, tss);

                    ts = frac*cur_stream->ic->duration;

                    if (cur_stream->ic->start_time != AV_NOPTS_VALUE)

                        ts += cur_stream->ic->start_time;

                    stream_seek(cur_stream, ts, 0, 0);

                }

            }

            break;

        case SDL_VIDEORESIZE:

            if (cur_stream) {

                screen = SDL_SetVideoMode(event.resize.w, event.resize.h, 0,

                                          SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL);

                screen_width = cur_stream->width = event.resize.w;

                screen_height= cur_stream->height= event.resize.h;

            }

            break;

        case SDL_QUIT:

        case FF_QUIT_EVENT:

            do_exit(cur_stream);

            break;

        case FF_ALLOC_EVENT:

            video_open(event.user.data1);

            alloc_picture(event.user.data1);

            break;

        case FF_REFRESH_EVENT:

            video_refresh(event.user.data1);

            cur_stream->refresh=0;

            break;

        default:

            break;

        }

    }

}
",853,"static void event_loop(VideoState *cur__speed)

{

    SDL_Event exec;

    double  incerr, pos,  circ;



    for(;;) {

        double index;

        SDL_WaitEvent(&exec);

        switch(exec.type) {

        case SDL_KEYDOWN:

            if (exit_on_keydown) {

                do_exit(cur__speed);

                break;

            }

            switch(exec.key.keysym.sym) {

            case SDLK_ESCAPE:

            case SDLK_q:

                do_exit(cur__speed);

                break;

            case SDLK_f:

                toggle_full_screen(cur__speed);

                break;

            case SDLK_p:

            case SDLK_SPACE:

                if (cur__speed)

                    toggle_pause(cur__speed);

                break;

            case SDLK_s: //S: Step to next frame

                if (cur__speed)

                    step_to_next_frame(cur__speed);

                break;

            case SDLK_a:

                if (cur__speed)

                    stream_cycle_channel(cur__speed, AVMEDIA_TYPE_AUDIO);

                break;

            case SDLK_v:

                if (cur__speed)

                    stream_cycle_channel(cur__speed, AVMEDIA_TYPE_VIDEO);

                break;

            case SDLK_t:

                if (cur__speed)

                    stream_cycle_channel(cur__speed, AVMEDIA_TYPE_SUBTITLE);

                break;

            case SDLK_w:

                if (cur__speed)

                    toggle_audio_display(cur__speed);

                break;

            case SDLK_LEFT:

                 incerr = -10.0;

                goto do_seek;

            case SDLK_RIGHT:

                 incerr = 10.0;

                goto do_seek;

            case SDLK_UP:

                 incerr = 60.0;

                goto do_seek;

            case SDLK_DOWN:

                 incerr = -60.0;

            do_seek:

                if (cur__speed) {

                    if (seek_by_bytes) {

                        if (cur__speed->video_stream >= 0 && cur__speed->video_current_pos>=0){

                            pos= cur__speed->video_current_pos;

                        }else if(cur__speed->audio_stream >= 0 && cur__speed->audio_pkt.pos>=0){

                            pos= cur__speed->audio_pkt.pos;

                        }else

                            pos = avio_tell(cur__speed->ic->pb);

                        if (cur__speed->ic->bit_rate)

                             incerr *= cur__speed->ic->bit_rate / 8.0;

                        else

                             incerr *= 180000.0;

                        pospos  incerr;

                        stream_seek(cur__speed, posposincerr, 1);

                    } else {

                        pos = get_master_clock(cur__speed);

                        pospos  incerr;

                        stream_seek(cur__speed, (int64_t)(posposAV_TIME_BASE), (int64_t)( incerr * AV_TIME_BASE), 0);

                    }

                }

                break;

            default:

                break;

            }

            break;

        case SDL_MOUSEBUTTONDOWN:

            if (exit_on_mousedown) {

                do_exit(cur__speed);

                break;

            }

        case SDL_MOUSEMOTION:

            if(exec.type ==SDL_MOUSEBUTTONDOWN){

               indexx= exec.button.index;

            }else{

                if(exec.motion.state != SDL_PRESSED)

                    break;

               indexx= exec.motion.index;

            }

            if (cur__speed) {

                if(seek_by_bytes || cur__speed->ic->duration<=0){

                    uint64_t size=  avio_size(cur__speed->ic->pb);

                    stream_seek(cur__speed, size*index/cur__speed->width, 0, 1);

                }else{

                    int64_t ts;

                    int ns, hh, mm, ss;

                    int tns, thh, tmm, tss;

                    tns = cur__speed->ic->duration/1000000LL;

                    thh = tns/3600;

                    tmm = (tns%3600)/60;

                    tss = (tns%60);

                     circ = index/cur__speed->width;

                    ns =  circ*tns;

                    hh = ns/3600;

                    mm = (ns%3600)/60;

                    ss = (ns%60);

                    fprintf(stderr, ""Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d)       
"",  circ*100,

                            hh, mm, ss, thh, tmm, tss);

                    ts =  circ*cur__speed->ic->duration;

                    if (cur__speed->ic->start_time != AV_NOPTS_VALUE)

                        ts += cur__speed->ic->start_time;

                    stream_seek(cur__speed, ts, 0, 0);

                }

            }

            break;

        case SDL_VIDEORESIZE:

            if (cur__speed) {

                screen = SDL_SetVideoMode(exec.resize.w, exec.resize.h, 0,

                                          SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL);

                screen_width = cur__speed->width = exec.resize.w;

                screen_height= cur__speed->height= exec.resize.h;

            }

            break;

        case SDL_QUIT:

        case FF_QUIT_EVENT:

            do_exit(cur__speed);

            break;

        case FF_ALLOC_EVENT:

            video_open(exec.user.data1);

            alloc_picture(exec.user.data1);

            break;

        case FF_REFRESH_EVENT:

            video_refresh(exec.user.data1);

            cur__speed->refresh=0;

            break;

        default:

            break;

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"cur_stream,event,incr,pos,frac,x",,,,11,"cur_stream:cur__speed,event:exec,incr: incerr,pos:pos,frac: circ,x:index,",1,GA,586,0.21440131664276124,GA,
363,"int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }

    }



    return 0;

}
",169,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,count,i,p",,,,0,,0,GA,857,0.22841474612553914,failed,
364,"static void gic_complete_irq(gic_state * s, int cpu, int irq)

{

    int update = 0;

    int cm = 1 << cpu;

    DPRINTF(""EOI %d\n"", irq);

    if (s->running_irq[cpu] == 1023)

        return; /* No active IRQ.  */

    if (irq != 1023) {

        /* Mark level triggered interrupts as pending if they are still

           raised.  */

        if (!GIC_TEST_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm)

                && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) {

            DPRINTF(""Set %d pending mask %x\n"", irq, cm);

            GIC_SET_PENDING(irq, cm);

            update = 1;

        }

    }

    if (irq != s->running_irq[cpu]) {

        /* Complete an IRQ that is not currently running.  */

        int tmp = s->running_irq[cpu];

        while (s->last_active[tmp][cpu] != 1023) {

            if (s->last_active[tmp][cpu] == irq) {

                s->last_active[tmp][cpu] = s->last_active[irq][cpu];

                break;

            }

            tmp = s->last_active[tmp][cpu];

        }

        if (update) {

            gic_update(s);

        }

    } else {

        /* Complete the current running IRQ.  */

        gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]);

    }

}
",309,,LABEL_1,LABEL_0,,-4,"s,cpu,irq",,,,0,,0,Greedy,1,0.00044758319854736327,,
365,"static void xen_remap_bucket(MapCacheEntry *entry,

                             hwaddr size,

                             hwaddr address_index)

{

    uint8_t *vaddr_base;

    xen_pfn_t *pfns;

    int *err;

    unsigned int i;

    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;



    trace_xen_remap_bucket(address_index);



    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));

    err = g_malloc0(nb_pfn * sizeof (int));



    if (entry->vaddr_base != NULL) {

        if (munmap(entry->vaddr_base, entry->size) != 0) {

            perror(""unmap fails"");

            exit(-1);

        }

    }

    g_free(entry->valid_mapping);

    entry->valid_mapping = NULL;



    for (i = 0; i < nb_pfn; i++) {

        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;

    }



    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,

                                     pfns, err, nb_pfn);

    if (vaddr_base == NULL) {

        perror(""xc_map_foreign_bulk"");

        exit(-1);

    }



    entry->vaddr_base = vaddr_base;

    entry->paddr_index = address_index;

    entry->size = size;

    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *

            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));



    bitmap_zero(entry->valid_mapping, nb_pfn);

    for (i = 0; i < nb_pfn; i++) {

        if (!err[i]) {

            bitmap_set(entry->valid_mapping, i, 1);

        }

    }



    g_free(pfns);

    g_free(err);

}
",300,,LABEL_1,LABEL_0,,-4,"entry,size,address_index,vaddr_base,pfns,err,i",,,,0,,0,Greedy,1,0.0005588491757710774,,
366,"void ff_mlp_init_x86(DSPContext* c, AVCodecContext *avctx)

{

#if HAVE_7REGS && HAVE_TEN_OPERANDS

    c->mlp_filter_channel = mlp_filter_channel_x86;

#endif

}
",20,,LABEL_1,LABEL_0,,-4,"c,avctx",,,,0,,0,Greedy,1,0.0004175066947937012,,
367,"int usb_packet_map(USBPacket *p, QEMUSGList *sgl)

{

    int is_write = (p->pid == USB_TOKEN_IN);

    target_phys_addr_t len;

    void *mem;

    int i;



    for (i = 0; i < sgl->nsg; i++) {

        len = sgl->sg[i].len;

        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,

                                      is_write);

        if (!mem) {

            goto err;

        }

        qemu_iovec_add(&p->iov, mem, len);

        if (len != sgl->sg[i].len) {

            goto err;

        }

    }

    return 0;



err:

    usb_packet_unmap(p);

    return -1;

}
",143,,LABEL_1,LABEL_0,,-4,"p,sgl,len,mem,i",,,,0,,0,Greedy,1,0.00031874974568684897,,
368,"int drive_init(struct drive_opt *arg, int snapshot, void *opaque)

{

    char buf[128];

    char file[1024];

    char devname[128];

    char serial[21];

    const char *mediastr = """";

    BlockInterfaceType type;

    enum { MEDIA_DISK, MEDIA_CDROM } media;

    int bus_id, unit_id;

    int cyls, heads, secs, translation;

    BlockDriverState *bdrv;

    BlockDriver *drv = NULL;

    QEMUMachine *machine = opaque;

    int max_devs;

    int index;

    int cache;

    int bdrv_flags, onerror;

    int drives_table_idx;

    char *str = arg->opt;

    static const char * const params[] = { ""bus"", ""unit"", ""if"", ""index"",

                                           ""cyls"", ""heads"", ""secs"", ""trans"",

                                           ""media"", ""snapshot"", ""file"",

                                           ""cache"", ""format"", ""serial"", ""werror"",

                                           NULL };



    if (check_params(buf, sizeof(buf), params, str) < 0) {

         fprintf(stderr, ""qemu: unknown parameter '%s' in '%s'\n"",

                         buf, str);

         return -1;

    }



    file[0] = 0;

    cyls = heads = secs = 0;

    bus_id = 0;

    unit_id = -1;

    translation = BIOS_ATA_TRANSLATION_AUTO;

    index = -1;

    cache = 3;



    if (machine->use_scsi) {

        type = IF_SCSI;

        max_devs = MAX_SCSI_DEVS;

        pstrcpy(devname, sizeof(devname), ""scsi"");

    } else {

        type = IF_IDE;

        max_devs = MAX_IDE_DEVS;

        pstrcpy(devname, sizeof(devname), ""ide"");

    }

    media = MEDIA_DISK;



    /* extract parameters */



    if (get_param_value(buf, sizeof(buf), ""bus"", str)) {

        bus_id = strtol(buf, NULL, 0);

	if (bus_id < 0) {

	    fprintf(stderr, ""qemu: '%s' invalid bus id\n"", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), ""unit"", str)) {

        unit_id = strtol(buf, NULL, 0);

	if (unit_id < 0) {

	    fprintf(stderr, ""qemu: '%s' invalid unit id\n"", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), ""if"", str)) {

        pstrcpy(devname, sizeof(devname), buf);

        if (!strcmp(buf, ""ide"")) {

	    type = IF_IDE;

            max_devs = MAX_IDE_DEVS;

        } else if (!strcmp(buf, ""scsi"")) {

	    type = IF_SCSI;

            max_devs = MAX_SCSI_DEVS;

        } else if (!strcmp(buf, ""floppy"")) {

	    type = IF_FLOPPY;

            max_devs = 0;

        } else if (!strcmp(buf, ""pflash"")) {

	    type = IF_PFLASH;

            max_devs = 0;

	} else if (!strcmp(buf, ""mtd"")) {

	    type = IF_MTD;

            max_devs = 0;

	} else if (!strcmp(buf, ""sd"")) {

	    type = IF_SD;

            max_devs = 0;

        } else if (!strcmp(buf, ""virtio"")) {

            type = IF_VIRTIO;

            max_devs = 0;

	} else if (!strcmp(buf, ""xen"")) {

	    type = IF_XEN;

            max_devs = 0;

	} else {

            fprintf(stderr, ""qemu: '%s' unsupported bus type '%s'\n"", str, buf);

            return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), ""index"", str)) {

        index = strtol(buf, NULL, 0);

	if (index < 0) {

	    fprintf(stderr, ""qemu: '%s' invalid index\n"", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), ""cyls"", str)) {

        cyls = strtol(buf, NULL, 0);

    }



    if (get_param_value(buf, sizeof(buf), ""heads"", str)) {

        heads = strtol(buf, NULL, 0);

    }



    if (get_param_value(buf, sizeof(buf), ""secs"", str)) {

        secs = strtol(buf, NULL, 0);

    }



    if (cyls || heads || secs) {

        if (cyls < 1 || cyls > 16383) {

            fprintf(stderr, ""qemu: '%s' invalid physical cyls number\n"", str);

	    return -1;

	}

        if (heads < 1 || heads > 16) {

            fprintf(stderr, ""qemu: '%s' invalid physical heads number\n"", str);

	    return -1;

	}

        if (secs < 1 || secs > 63) {

            fprintf(stderr, ""qemu: '%s' invalid physical secs number\n"", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), ""trans"", str)) {

        if (!cyls) {

            fprintf(stderr,

                    ""qemu: '%s' trans must be used with cyls,heads and secs\n"",

                    str);

            return -1;

        }

        if (!strcmp(buf, ""none""))

            translation = BIOS_ATA_TRANSLATION_NONE;

        else if (!strcmp(buf, ""lba""))

            translation = BIOS_ATA_TRANSLATION_LBA;

        else if (!strcmp(buf, ""auto""))

            translation = BIOS_ATA_TRANSLATION_AUTO;

	else {

            fprintf(stderr, ""qemu: '%s' invalid translation type\n"", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), ""media"", str)) {

        if (!strcmp(buf, ""disk"")) {

	    media = MEDIA_DISK;

	} else if (!strcmp(buf, ""cdrom"")) {

            if (cyls || secs || heads) {

                fprintf(stderr,

                        ""qemu: '%s' invalid physical CHS format\n"", str);

	        return -1;

            }

	    media = MEDIA_CDROM;

	} else {

	    fprintf(stderr, ""qemu: '%s' invalid media\n"", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), ""snapshot"", str)) {

        if (!strcmp(buf, ""on""))

	    snapshot = 1;

        else if (!strcmp(buf, ""off""))

	    snapshot = 0;

	else {

	    fprintf(stderr, ""qemu: '%s' invalid snapshot option\n"", str);

	    return -1;

	}

    }



    if (get_param_value(buf, sizeof(buf), ""cache"", str)) {

        if (!strcmp(buf, ""off"") || !strcmp(buf, ""none""))

            cache = 0;

        else if (!strcmp(buf, ""writethrough""))

            cache = 1;

        else if (!strcmp(buf, ""writeback""))

            cache = 2;

        else {

           fprintf(stderr, ""qemu: invalid cache option\n"");

           return -1;

        }

    }



    if (get_param_value(buf, sizeof(buf), ""format"", str)) {

       if (strcmp(buf, ""?"") == 0) {

            fprintf(stderr, ""qemu: Supported formats:"");

            bdrv_iterate_format(bdrv_format_print, NULL);

            fprintf(stderr, ""\n"");

	    return -1;

        }

        drv = bdrv_find_format(buf);

        if (!drv) {

            fprintf(stderr, ""qemu: '%s' invalid format\n"", buf);

            return -1;

        }

    }



    if (arg->file == NULL)

        get_param_value(file, sizeof(file), ""file"", str);

    else

        pstrcpy(file, sizeof(file), arg->file);



    if (!get_param_value(serial, sizeof(serial), ""serial"", str))

	    memset(serial, 0,  sizeof(serial));



    onerror = BLOCK_ERR_STOP_ENOSPC;

    if (get_param_value(buf, sizeof(serial), ""werror"", str)) {

        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {

            fprintf(stderr, ""werror is no supported by this format\n"");

            return -1;

        }

        if (!strcmp(buf, ""ignore""))

            onerror = BLOCK_ERR_IGNORE;

        else if (!strcmp(buf, ""enospc""))

            onerror = BLOCK_ERR_STOP_ENOSPC;

        else if (!strcmp(buf, ""stop""))

            onerror = BLOCK_ERR_STOP_ANY;

        else if (!strcmp(buf, ""report""))

            onerror = BLOCK_ERR_REPORT;

        else {

            fprintf(stderr, ""qemu: '%s' invalid write error action\n"", buf);

            return -1;

        }

    }



    /* compute bus and unit according index */



    if (index != -1) {

        if (bus_id != 0 || unit_id != -1) {

            fprintf(stderr,

                    ""qemu: '%s' index cannot be used with bus and unit\n"", str);

            return -1;

        }

        if (max_devs == 0)

        {

            unit_id = index;

            bus_id = 0;

        } else {

            unit_id = index % max_devs;

            bus_id = index / max_devs;

        }

    }



    /* if user doesn't specify a unit_id,

     * try to find the first free

     */



    if (unit_id == -1) {

       unit_id = 0;

       while (drive_get_index(type, bus_id, unit_id) != -1) {

           unit_id++;

           if (max_devs && unit_id >= max_devs) {

               unit_id -= max_devs;

               bus_id++;

           }

       }

    }



    /* check unit id */



    if (max_devs && unit_id >= max_devs) {

        fprintf(stderr, ""qemu: '%s' unit %d too big (max is %d)\n"",

                        str, unit_id, max_devs - 1);

        return -1;

    }



    /*

     * ignore multiple definitions

     */



    if (drive_get_index(type, bus_id, unit_id) != -1)

        return -2;



    /* init */



    if (type == IF_IDE || type == IF_SCSI)

        mediastr = (media == MEDIA_CDROM) ? ""-cd"" : ""-hd"";

    if (max_devs)

        snprintf(buf, sizeof(buf), ""%s%i%s%i"",

                 devname, bus_id, mediastr, unit_id);

    else

        snprintf(buf, sizeof(buf), ""%s%s%i"",

                 devname, mediastr, unit_id);

    bdrv = bdrv_new(buf);

    drives_table_idx = drive_get_free_idx();

    drives_table[drives_table_idx].bdrv = bdrv;

    drives_table[drives_table_idx].type = type;

    drives_table[drives_table_idx].bus = bus_id;

    drives_table[drives_table_idx].unit = unit_id;

    drives_table[drives_table_idx].onerror = onerror;

    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;

    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));

    nb_drives++;



    switch(type) {

    case IF_IDE:

    case IF_SCSI:

    case IF_XEN:

        switch(media) {

	case MEDIA_DISK:

            if (cyls != 0) {

                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);

                bdrv_set_translation_hint(bdrv, translation);

            }

	    break;

	case MEDIA_CDROM:

            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);

	    break;

	}

        break;

    case IF_SD:

        /* FIXME: This isn't really a floppy, but it's a reasonable

           approximation.  */

    case IF_FLOPPY:

        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);

        break;

    case IF_PFLASH:

    case IF_MTD:

    case IF_VIRTIO:

        break;

    }

    if (!file[0])

        return -2;

    bdrv_flags = 0;

    if (snapshot) {

        bdrv_flags |= BDRV_O_SNAPSHOT;

        cache = 2; /* always use write-back with snapshot */

    }

    if (cache == 0) /* no caching */

        bdrv_flags |= BDRV_O_NOCACHE;

    else if (cache == 2) /* write-back */

        bdrv_flags |= BDRV_O_CACHE_WB;

    else if (cache == 3) /* not specified */

        bdrv_flags |= BDRV_O_CACHE_DEF;

    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {

        fprintf(stderr, ""qemu: could not open disk image %s\n"",

                        file);

        return -1;

    }

    if (bdrv_key_required(bdrv))

        autostart = 0;

    return drives_table_idx;

}
",2236,,LABEL_0,LABEL_1,,-4,"arg,snapshot,opaque,buf,file,devname,serial,mediastr,type,media,bus_id,unit_id,cyls,heads,secs,translation,bdrv,drv,machine,max_devs,index,cache,bdrv_flags,onerror,drives_table_idx,str,params",,,,0,,0,Greedy,1,0.001658018430074056,,
369,"static int rtsp_read_header(AVFormatContext *s,

                            AVFormatParameters *ap)

{

    RTSPState *rt = s->priv_data;

    char host[1024], path[1024], tcpname[1024], cmd[2048];

    URLContext *rtsp_hd;

    int port, i, ret, err;

    RTSPHeader reply1, *reply = &reply1;

    unsigned char *content = NULL;

    AVStream *st;

    RTSPStream *rtsp_st;

    int protocol_mask;



    rtsp_abort_req = 0;

    

    /* extract hostname and port */

    url_split(NULL, 0,

              host, sizeof(host), &port, path, sizeof(path), s->filename);

    if (port < 0)

        port = RTSP_DEFAULT_PORT;



    /* open the tcp connexion */

    snprintf(tcpname, sizeof(tcpname), ""tcp://%s:%d"", host, port);

    if (url_open(&rtsp_hd, tcpname, URL_RDWR) < 0)

        return AVERROR_IO;

    rt->rtsp_hd = rtsp_hd;

    rt->seq = 0;

    

    /* describe the stream */

    snprintf(cmd, sizeof(cmd), 

             ""DESCRIBE %s RTSP/1.0\r\n""

             ""Accept: application/sdp\r\n"",

             s->filename);

    rtsp_send_cmd(s, cmd, reply, &content);

    if (!content) {

        err = AVERROR_INVALIDDATA;

        goto fail;

    }

    if (reply->status_code != RTSP_STATUS_OK) {

        err = AVERROR_INVALIDDATA;

        goto fail;

    }

        

    /* now we got the SDP description, we parse it */

    ret = sdp_parse(s, (const char *)content);

    av_freep(&content);

    if (ret < 0) {

        err = AVERROR_INVALIDDATA;

        goto fail;

    }

    

    protocol_mask = rtsp_default_protocols;



    /* for each stream, make the setup request */

    /* XXX: we assume the same server is used for the control of each

       RTSP stream */

    for(i=0;i<s->nb_streams;i++) {

        char transport[2048];

        AVInputFormat *fmt;



        st = s->streams[i];

        rtsp_st = st->priv_data;



        /* compute available transports */

        transport[0] = '\0';



        /* RTP/UDP */

        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP)) {

            char buf[256];

            int j;



            /* first try in specified port range */

            if (rtsp_rtp_port_min != 0) {

                for(j=rtsp_rtp_port_min;j<=rtsp_rtp_port_max;j++) {

                    snprintf(buf, sizeof(buf), ""rtp://?localport=%d"", j);

                    if (!av_open_input_file(&rtsp_st->ic, buf, 

                                            &rtp_demux, 0, NULL))

                        goto rtp_opened;

                }

            }



            /* then try on any port */

            if (av_open_input_file(&rtsp_st->ic, ""rtp://"", 

                                       &rtp_demux, 0, NULL) < 0) {

                    err = AVERROR_INVALIDDATA;

                    goto fail;

            }



        rtp_opened:

            port = rtp_get_local_port(url_fileno(&rtsp_st->ic->pb));

            if (transport[0] != '\0')

                pstrcat(transport, sizeof(transport), "","");

            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,

                     ""RTP/AVP/UDP;unicast;client_port=%d-%d"",

                     port, port + 1);

        }



        /* RTP/TCP */

        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_TCP)) {

            if (transport[0] != '\0')

                pstrcat(transport, sizeof(transport), "","");

            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,

                     ""RTP/AVP/TCP"");

        }



        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP_MULTICAST)) {

            if (transport[0] != '\0')

                pstrcat(transport, sizeof(transport), "","");

            snprintf(transport + strlen(transport), 

                     sizeof(transport) - strlen(transport) - 1,

                     ""RTP/AVP/UDP;multicast"");

        }

        snprintf(cmd, sizeof(cmd), 

                 ""SETUP %s RTSP/1.0\r\n""

                 ""Transport: %s\r\n"",

                 rtsp_st->control_url, transport);

        rtsp_send_cmd(s, cmd, reply, NULL);

        if (reply->status_code != RTSP_STATUS_OK ||

            reply->nb_transports != 1) {

            err = AVERROR_INVALIDDATA;

            goto fail;

        }



        /* XXX: same protocol for all streams is required */

        if (i > 0) {

            if (reply->transports[0].protocol != rt->protocol) {

                err = AVERROR_INVALIDDATA;

                goto fail;

            }

        } else {

            rt->protocol = reply->transports[0].protocol;

        }



        /* close RTP connection if not choosen */

        if (reply->transports[0].protocol != RTSP_PROTOCOL_RTP_UDP &&

            (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP))) {

            av_close_input_file(rtsp_st->ic);

            rtsp_st->ic = NULL;

        }



        switch(reply->transports[0].protocol) {

        case RTSP_PROTOCOL_RTP_TCP:

            fmt = &rtp_demux;

            if (av_open_input_file(&rtsp_st->ic, ""null"", fmt, 0, NULL) < 0) {

                err = AVERROR_INVALIDDATA;

                goto fail;

            }

            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;

            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;

            break;

            

        case RTSP_PROTOCOL_RTP_UDP:

            {

                char url[1024];

                

                /* XXX: also use address if specified */

                snprintf(url, sizeof(url), ""rtp://%s:%d"", 

                         host, reply->transports[0].server_port_min);

                if (rtp_set_remote_url(url_fileno(&rtsp_st->ic->pb), url) < 0) {

                    err = AVERROR_INVALIDDATA;

                    goto fail;

                }

            }

            break;

        case RTSP_PROTOCOL_RTP_UDP_MULTICAST:

            {

                char url[1024];

                int ttl;



                fmt = &rtp_demux;

                ttl = reply->transports[0].ttl;

                if (!ttl)

                    ttl = 16;

                snprintf(url, sizeof(url), ""rtp://%s:%d?multicast=1&ttl=%d"", 

                         host, 

                         reply->transports[0].server_port_min,

                         ttl);

                if (av_open_input_file(&rtsp_st->ic, url, fmt, 0, NULL) < 0) {

                    err = AVERROR_INVALIDDATA;

                    goto fail;

                }

            }

            break;

        }

    }



    /* use callback if available to extend setup */

    if (ff_rtsp_callback) {

        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 

                             NULL, 0, rt->last_reply) < 0) {

            err = AVERROR_INVALIDDATA;

            goto fail;

        }

    }

                         

    /* start playing */

    snprintf(cmd, sizeof(cmd), 

             ""PLAY %s RTSP/1.0\r\n""

             ""Range: npt=0-\r\n"",

             s->filename);

    rtsp_send_cmd(s, cmd, reply, NULL);

    if (reply->status_code != RTSP_STATUS_OK) {

        err = AVERROR_INVALIDDATA;

        goto fail;

    }



#if 0

    /* open TCP with bufferized input */

    if (rt->protocol == RTSP_PROTOCOL_RTP_TCP) {

        if (url_fdopen(&rt->rtsp_gb, rt->rtsp_hd) < 0) {

            err = AVERROR_NOMEM;

            goto fail;

        }

    }

#endif



    return 0;

 fail:

    for(i=0;i<s->nb_streams;i++) {

        st = s->streams[i];

        rtsp_st = st->priv_data;

        if (rtsp_st) {

            if (rtsp_st->ic)

                av_close_input_file(rtsp_st->ic);

        }

        av_free(rtsp_st);

    }

    av_freep(&content);

    url_close(rt->rtsp_hd);

    return err;

}
",1408,,LABEL_0,LABEL_1,,-4,"s,ap,rt,host,path,tcpname,cmd,rtsp_hd,port,i,ret,err,reply1,reply,content,st,rtsp_st,protocol_mask,transport,fmt,buf",,,,0,,0,Greedy,1,0.0012875040372212728,,
370,"static void qed_aio_read_data(void *opaque, int ret,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *s = acb_to_s(acb);

    BlockDriverState *bs = acb->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(s, acb->cur_pos);



    trace_qed_aio_read_data(s, acb, ret, offset, len);



    if (ret < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (ret == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (ret != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acb, ret);

}
",243,"static void qed_aio_read_data(void *osponymous, int status,

                              uint64_t offset, size_t mem)

{

    QEDAIOCB *acb acbsponymous;

    BDRVQEDState *s = acb_to_s(acb);

    BlockDriverState *base = acb->common.base;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(s, acb->cur_pos);



    trace_qed_aio_read_data(s, scbacbtatus, offset, mem);



    if (status < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, mem);



    /* Handle zero cluster and backing file reads */

    if (status == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (status != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(base->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(base->file, offset / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acbacbtatus);

}
",LABEL_1,LABEL_1,LABEL_0,1,"opaque,ret,offset,len,acb,s,bs",,,,27,"opaque:osponymous,ret:status,offset:offset,len:mem,acb:acb,s:s,bs:base,",3,GA,474,0.12530540227890014,GA,
371,"int ff_thread_video_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *frame, int *got_packet_ptr){

    ThreadContext *c = avctx->internal->frame_thread_encoder;

    Task task;

    int ret;



    av_assert1(!*got_packet_ptr);



    if(frame){

        if(!(avctx->flags & CODEC_FLAG_INPUT_PRESERVED)){

            AVFrame *new = avcodec_alloc_frame();

            if(!new)

                return AVERROR(ENOMEM);

            pthread_mutex_lock(&c->buffer_mutex);

            ret = c->parent_avctx->get_buffer(c->parent_avctx, new);

            pthread_mutex_unlock(&c->buffer_mutex);

            if(ret<0)

                return ret;

            new->pts = frame->pts;

            new->quality = frame->quality;

            new->pict_type = frame->pict_type;

            av_image_copy(new->data, new->linesize, (const uint8_t **)frame->data, frame->linesize,

                          avctx->pix_fmt, avctx->width, avctx->height);

            frame = new;

        }



        task.index = c->task_index;

        task.indata = (void*)frame;

        pthread_mutex_lock(&c->task_fifo_mutex);

        av_fifo_generic_write(c->task_fifo, &task, sizeof(task), NULL);

        pthread_cond_signal(&c->task_fifo_cond);

        pthread_mutex_unlock(&c->task_fifo_mutex);



        c->task_index = (c->task_index+1) % BUFFER_SIZE;



        if(!c->finished_tasks[c->finished_task_index].outdata && (c->task_index - c->finished_task_index) % BUFFER_SIZE <= avctx->thread_count)

            return 0;

    }



    if(c->task_index == c->finished_task_index)

        return 0;



    pthread_mutex_lock(&c->finished_task_mutex);

    while (!c->finished_tasks[c->finished_task_index].outdata) {

        pthread_cond_wait(&c->finished_task_cond, &c->finished_task_mutex);

    }

    task = c->finished_tasks[c->finished_task_index];

    *pkt = *(AVPacket*)(task.outdata);

    av_freep(&c->finished_tasks[c->finished_task_index].outdata);

    c->finished_task_index = (c->finished_task_index+1) % BUFFER_SIZE;

    pthread_mutex_unlock(&c->finished_task_mutex);



    *got_packet_ptr = 1;



    return task.return_code;

}
",456,,LABEL_1,LABEL_0,,-4,"avctx,pkt,frame,got_packet_ptr,c,task,ret,new",,,,0,,0,Greedy,1,0.0006054321924845378,,
372,"void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,

                        int *duration)

{

    int64_t out_pts = AV_NOPTS_VALUE;

    int removed_samples = 0;



#ifdef DEBUG

    ff_af_queue_log_state(afq);

#endif



    /* get output pts from the next frame or generated pts */

    if (afq->frame_queue) {

        if (afq->frame_queue->pts != AV_NOPTS_VALUE)

            out_pts = afq->frame_queue->pts - afq->remaining_delay;

    } else {

        if (afq->next_pts != AV_NOPTS_VALUE)

            out_pts = afq->next_pts - afq->remaining_delay;

    }

    if (pts) {

        if (out_pts != AV_NOPTS_VALUE)

            *pts = ff_samples_to_time_base(afq->avctx, out_pts);

        else

            *pts = AV_NOPTS_VALUE;

    }



    /* if the delay is larger than the packet duration, we use up delay samples

       for the output packet and leave all frames in the queue */

    if (afq->remaining_delay >= nb_samples) {

        removed_samples      += nb_samples;

        afq->remaining_delay -= nb_samples;

    }

    /* remove frames from the queue until we have enough to cover the

       requested number of samples or until the queue is empty */

    while (removed_samples < nb_samples && afq->frame_queue) {

        removed_samples += afq->frame_queue->duration;

        delete_next_frame(afq);

    }

    afq->remaining_samples -= removed_samples;



    /* if there are no frames left and we have room for more samples, use

       any remaining delay samples */

    if (removed_samples < nb_samples && afq->remaining_samples > 0) {

        int add_samples = FFMIN(afq->remaining_samples,

                                nb_samples - removed_samples);

        removed_samples        += add_samples;

        afq->remaining_samples -= add_samples;

    }

    if (removed_samples > nb_samples)

        av_log(afq->avctx, AV_LOG_WARNING, ""frame_size is too large\n"");

    if (duration)

        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);

}
",360,,LABEL_0,LABEL_0,LABEL_0,-1,"afq,nb_samples,pts,duration",,,,0,,0,GA,957,0.2843846917152405,failed,
373,"static void connex_init(MachineState *machine)

{

    PXA2xxState *cpu;

    DriveInfo *dinfo;

    int be;

    MemoryRegion *address_space_mem = get_system_memory();



    uint32_t connex_rom = 0x01000000;

    uint32_t connex_ram = 0x04000000;



    cpu = pxa255_init(address_space_mem, connex_ram);



    dinfo = drive_get(IF_PFLASH, 0, 0);

    if (!dinfo && !qtest_enabled()) {

        fprintf(stderr, ""A flash image must be given with the ""

                ""'pflash' parameter\n"");

        exit(1);

    }



#ifdef TARGET_WORDS_BIGENDIAN

    be = 1;

#else

    be = 0;

#endif

    if (!pflash_cfi01_register(0x00000000, NULL, ""connext.rom"", connex_rom,

                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                               sector_len, connex_rom / sector_len,

                               2, 0, 0, 0, 0, be)) {

        fprintf(stderr, ""qemu: Error registering flash memory.\n"");

        exit(1);

    }



    /* Interrupt line of NIC is connected to GPIO line 36 */

    smc91c111_init(&nd_table[0], 0x04000300,

                    qdev_get_gpio_in(cpu->gpio, 36));

}
",198,,LABEL_0,LABEL_0,LABEL_0,-1,"machine,cpu,dinfo,be,address_space_mem",,,,0,,0,GA,711,0.1889157176017761,failed,
374,"static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}
",41,,LABEL_0,LABEL_0,LABEL_0,-1,s,,,,0,,0,GA,271,0.06742392778396607,failed,
375,"static int64_t get_bit_rate(AVCodecContext *ctx)

{

    int64_t bit_rate;

    int bits_per_sample;



    switch (ctx->codec_type) {

    case AVMEDIA_TYPE_VIDEO:

    case AVMEDIA_TYPE_DATA:

    case AVMEDIA_TYPE_SUBTITLE:

    case AVMEDIA_TYPE_ATTACHMENT:

        bit_rate = ctx->bit_rate;

        break;

    case AVMEDIA_TYPE_AUDIO:

        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);

        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;

        break;

    default:

        bit_rate = 0;

        break;

    }

    return bit_rate;

}
",96,,LABEL_1,LABEL_0,,-4,"ctx,bit_rate,bits_per_sample",,,,0,,0,Greedy,1,0.00047760407129923503,,
376,"static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,

                                   RockerTlv **group_tlvs)

{

    OfDpaGroup *l2_group;

    RockerTlv **tlvs;

    int err;

    int i;



    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||

        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {

        return -ROCKER_EINVAL;

    }



    group->l2_flood.group_count =

        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);



    tlvs = g_malloc0((group->l2_flood.group_count + 1) *

                     sizeof(RockerTlv *));

    if (!tlvs) {

        return -ROCKER_ENOMEM;

    }



    g_free(group->l2_flood.group_ids);

    group->l2_flood.group_ids =

        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));

    if (!group->l2_flood.group_ids) {

        err = -ROCKER_ENOMEM;

        goto err_out;

    }



    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,

                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);



    for (i = 0; i < group->l2_flood.group_count; i++) {

        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);

    }



    /* All of the L2 interface groups referenced by the L2 flood

     * must have same VLAN

     */



    for (i = 0; i < group->l2_flood.group_count; i++) {

        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);

        if (!l2_group) {

            continue;

        }

        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==

             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&

            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=

             ROCKER_GROUP_VLAN_GET(group->id))) {

            DPRINTF(""l2 interface group 0x%08x VLAN doesn't match l2 ""

                    ""flood group 0x%08x\n"",

                    group->l2_flood.group_ids[i], group->id);

            err = -ROCKER_EINVAL;

            goto err_out;

        }

    }



    g_free(tlvs);

    return ROCKER_OK;



err_out:

    group->l2_flood.group_count = 0;

    g_free(group->l2_flood.group_ids);

    g_free(tlvs);



    return err;

}
",390,,LABEL_1,LABEL_1,LABEL_1,-1,"of_dpa,group,group_tlvs,l2_group,tlvs,err,i",,,,0,,0,GA,1429,0.42752508719762167,failed,
377,"static void virtio_crypto_instance_init(Object *obj)

{

    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);



    /*

     * The default config_size is sizeof(struct virtio_crypto_config).

     * Can be overriden with virtio_crypto_set_config_size.

     */

    vcrypto->config_size = sizeof(struct virtio_crypto_config);



    object_property_add_link(obj, ""cryptodev"",

                             TYPE_CRYPTODEV_BACKEND,

                             (Object **)&vcrypto->conf.cryptodev,

                             virtio_crypto_check_cryptodev_is_used,

                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);

}
",78,,LABEL_0,LABEL_0,LABEL_0,-1,"obj,vcrypto",,,,0,,0,GA,446,0.10887214342753092,failed,
378,"PCIBus *pci_prep_init(qemu_irq *pic)

{

    PREPPCIState *s;

    PCIDevice *d;

    int PPC_io_memory;



    s = qemu_mallocz(sizeof(PREPPCIState));

    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);



    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);

    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);



    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);

    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);

    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);

    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);

    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);

    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);



    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,

                                           PPC_PCIIO_write, s);

    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);



    /* PCI host bridge */

    d = pci_register_device(s->bus, ""PREP Host Bridge - Motorola Raven"",

                            sizeof(PCIDevice), 0, NULL, NULL);

    d->config[0x00] = 0x57; // vendor_id : Motorola

    d->config[0x01] = 0x10;

    d->config[0x02] = 0x01; // device_id : Raven

    d->config[0x03] = 0x48;

    d->config[0x08] = 0x00; // revision

    d->config[0x0A] = 0x00; // class_sub = pci host

    d->config[0x0B] = 0x06; // class_base = PCI_bridge

    d->config[0x0C] = 0x08; // cache_line_size

    d->config[0x0D] = 0x10; // latency_timer

    d->config[0x0E] = 0x00; // header_type

    d->config[0x34] = 0x00; // capabilities_pointer



    return s->bus;

}
",350,,LABEL_1,LABEL_0,,-4,"pic,s,d,PPC_io_memory",,,,0,,0,Greedy,1,0.0006285508473714193,,
379,"unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,

				 unsigned long offset)

{

    const unsigned long *p = addr + BITOP_WORD(offset);

    unsigned long result = offset & ~(BITS_PER_LONG-1);

    unsigned long tmp;



    if (offset >= size) {

        return size;

    }

    size -= result;

    offset %= BITS_PER_LONG;

    if (offset) {

        tmp = *(p++);

        tmp |= ~0UL >> (BITS_PER_LONG - offset);

        if (size < BITS_PER_LONG) {

            goto found_first;

        }

        if (~tmp) {

            goto found_middle;

        }

        size -= BITS_PER_LONG;

        result += BITS_PER_LONG;

    }

    while (size & ~(BITS_PER_LONG-1)) {

        if (~(tmp = *(p++))) {

            goto found_middle;

        }

        result += BITS_PER_LONG;

        size -= BITS_PER_LONG;

    }

    if (!size) {

        return result;

    }

    tmp = *p;



found_first:

    tmp |= ~0UL << size;

    if (tmp == ~0UL) {	/* Are any bits zero? */

        return result + size;	/* Nope. */

    }

found_middle:

    return result + ffz(tmp);

}
",233,"unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,

				 unsigned long timeout)

{

    const unsigned long *pp= addr + BITOP_WORD(timeout);

    unsigned long result = timeout & ~(BITS_PER_LONG-1);

    unsigned long tc;



    if (timeout >= size) {

        return size;

    }

    size -= result;

    timeout %= BITS_PER_LONG;

    if (timeout) {

        tc = *(p++);

        ttc|= ~0UL >> (BITS_PER_LONG - timeout);

        if (size < BITS_PER_LONG) {

            goto found_first;

        }

        if (~tc) {

            goto found_middle;

        }

        size -= BITS_PER_LONG;

        result += BITS_PER_LONG;

    }

    while (size & ~(BITS_PER_LONG-1)) {

        if (~(tc = *(p++))) {

            goto found_middle;

        }

        result += BITS_PER_LONG;

        size -= BITS_PER_LONG;

    }

    if (!size) {

        return result;

    }

    tc = *p;



found_first:

    tc |= ~0UL << size;

    if (tc == ~0UL) {	/* Are any bits zero? */

        return result + size;	/* Nope. */

    }

found_middle:

    return result + ffz(tc);

}
",LABEL_1,LABEL_1,LABEL_0,1,"addr,size,offset,p,tmp",,,,16,"addr:addr,size:size,offset:timeout,p:p,tmp:tc,",3,GA,346,0.09462999105453491,GA,
380,"static void add_codec(FFServerStream *stream, AVCodecContext *av,

                      FFServerConfig *config)

{

    AVStream *st;

    AVDictionary **opts, *recommended = NULL;

    char *enc_config;



    if(stream->nb_streams >= FF_ARRAY_ELEMS(stream->streams))

        return;



    opts = av->codec_type == AVMEDIA_TYPE_AUDIO ?

           &config->audio_opts : &config->video_opts;

    av_dict_copy(&recommended, *opts, 0);

    av_opt_set_dict2(av->priv_data, opts, AV_OPT_SEARCH_CHILDREN);

    av_opt_set_dict2(av, opts, AV_OPT_SEARCH_CHILDREN);

    if (av_dict_count(*opts))

        av_log(NULL, AV_LOG_WARNING,

               ""Something is wrong, %d options are not set!\n"", av_dict_count(*opts));



    if (config->stream_use_defaults) {

    //TODO: reident

    /* compute default parameters */

    switch(av->codec_type) {

    case AVMEDIA_TYPE_AUDIO:

        if (av->bit_rate == 0) {

            av->bit_rate = 64000;

            av_dict_set_int(&recommended, ""ab"", av->bit_rate, 0);

        }

        if (av->sample_rate == 0) {

            av->sample_rate = 22050;

            av_dict_set_int(&recommended, ""ar"", av->sample_rate, 0);

        }

        if (av->channels == 0) {

            av->channels = 1;

            av_dict_set_int(&recommended, ""ac"", av->channels, 0);

        }

        break;

    case AVMEDIA_TYPE_VIDEO:

        if (av->bit_rate == 0) {

            av->bit_rate = 64000;

            av_dict_set_int(&recommended, ""b"", av->bit_rate, 0);

        }

        if (av->time_base.num == 0){

            av->time_base.den = 5;

            av->time_base.num = 1;

            av_dict_set(&recommended, ""time_base"", ""1/5"", 0);

        }

        if (av->width == 0 || av->height == 0) {

            av->width = 160;

            av->height = 128;

            av_dict_set(&recommended, ""video_size"", ""160x128"", 0);

        }

        /* Bitrate tolerance is less for streaming */

        if (av->bit_rate_tolerance == 0) {

            av->bit_rate_tolerance = FFMAX(av->bit_rate / 4,

                      (int64_t)av->bit_rate*av->time_base.num/av->time_base.den);

            av_dict_set_int(&recommended, ""bt"", av->bit_rate_tolerance, 0);

        }



        if (!av->rc_eq) {

            av->rc_eq = av_strdup(""tex^qComp"");

            av_dict_set(&recommended, ""rc_eq"", ""tex^qComp"", 0);

        }

        if (!av->rc_max_rate) {

            av->rc_max_rate = av->bit_rate * 2;

            av_dict_set_int(&recommended, ""maxrate"", av->rc_max_rate, 0);

        }



        if (av->rc_max_rate && !av->rc_buffer_size) {

            av->rc_buffer_size = av->rc_max_rate;

            av_dict_set_int(&recommended, ""bufsize"", av->rc_buffer_size, 0);

        }

        break;

    default:

        abort();

    }

    } else {

        switch(av->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            if (av->bit_rate == 0)

                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                                    &config->errors, ""audio bit rate is not set\n"");

            if (av->sample_rate == 0)

                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                                    &config->errors, ""audio sample rate is not set\n"");

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (av->width == 0 || av->height == 0)

                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                                    &config->errors, ""video size is not set\n"");

            break;

        default:

            av_assert0(0);

        }

    }



    st = av_mallocz(sizeof(AVStream));

    if (!st)

        return;

    av_dict_get_string(recommended, &enc_config, '=', ',');

    av_dict_free(&recommended);

    av_stream_set_recommended_encoder_configuration(st, enc_config);

    st->codec = av;

    stream->streams[stream->nb_streams++] = st;

}
",808,,LABEL_0,LABEL_1,,-4,"stream,av,config,st,opts,recommended,enc_config",,,,0,,0,Greedy,1,0.000908815860748291,,
381,"void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)

{

    uintptr_t addr = (uintptr_t)data;



    g_assert(addr >= QPCI_PIO_LIMIT);

    dev->bus->memread(dev->bus, addr, buf, len);

}
",55,,LABEL_1,LABEL_1,LABEL_1,-1,"dev,data,buf,len",,,,0,,0,GA,727,0.17245482206344603,failed,
382,"int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,

                       void *opaque, int version_id)

{

    VMStateField *field = vmsd->fields;



    if (version_id > vmsd->version_id) {

        return -EINVAL;

    }

    if (version_id < vmsd->minimum_version_id_old) {

        return -EINVAL;

    }

    if  (version_id < vmsd->minimum_version_id) {

        return vmsd->load_state_old(f, opaque, version_id);

    }

    while(field->name) {

        if (field->version_id <= version_id) {

            void *base_addr = opaque + field->offset;

            int ret, i, n_elems = 1;



            if (field->flags & VMS_ARRAY) {

                n_elems = field->num;

            } else if (field->flags & VMS_VARRAY) {

                n_elems = *(size_t *)(opaque+field->num_offset);

            }

            if (field->flags & VMS_POINTER) {

                base_addr = *(void **)base_addr;

            }

            for (i = 0; i < n_elems; i++) {

                void *addr = base_addr + field->size * i;



                if (field->flags & VMS_STRUCT) {

                    ret = vmstate_load_state(f, field->vmsd, addr, version_id);

                } else {

                    ret = field->info->get(f, addr, field->size);



                }

                if (ret < 0) {

                    return ret;

                }

            }

        }

        field++;

    }

    if (vmsd->run_after_load)

        return vmsd->run_after_load(opaque);

    return 0;

}
",302,"int vmstate_load_state(QEMUFile *f, const VMStateDescription * vmsde,

                       void *operaque, int version_id)

{

    VMStateField *fifield  vmsde->fields;



    if (veversion_id  vmsde->version_id) {

        return -EINVAL;

    }

    if (veversion_id  vmsde->minimum_version_id_old) {

        return -EINVAL;

    }

    if  (veversion_id  vmsde->minimum_version_id) {

        return  vmsde->load_state_old(f, operaque, version_id);

    }

    while(field->name) {

        if (field->version_id <= version_id) {

            void *babase_addr operaque + field->offset;

            int et, i, n_elems = 1;



            if (field->flags & VMS_ARRAY) {

                n_elems = field->num;

            } else if (field->flags & VMS_VARRAY) {

                n_elems = *(size_t *)(operaque+field->num_offset);

            }

            if (field->flags & VMS_POINTER) {

                base_addr = *(void **)base_addr;

            }

            for (i = 0; i < n_elems; i++) {

                void *amp = base_addr + field->size * i;



                if (field->flags & VMS_STRUCT) {

                    reet vmstate_load_state(f, fifield vmsde, amp, version_id);

                } else {

                    et = field->info->get(f, amp, field->size);



                }

                if (et < 0) {

                    return et;

                }

            }

        }

        field++;

    }

    if ( vmsde->run_after_load)

        return  vmsde->run_after_load(operaque);

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"f,vmsd,opaque,version_id,field,base_addr,ret,i,addr",,,,37,"f:f,vmsd: vmsde,opaque:operaque,version_id:version_id,field:field,base_addr:base_addr,ret:et,i:i,addr:amp,",5,GA,637,0.17194733222325642,GA,
383,"static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, long width)

{

#ifdef HAVE_MMX

	asm volatile(

		""movq ""MANGLE(bm01010101)"", %%mm4\n\t""

		""mov %0, %%""REG_a""		\n\t""

		""1:				\n\t""

		""movq (%1, %%""REG_a"",4), %%mm0	\n\t""

		""movq 8(%1, %%""REG_a"",4), %%mm1	\n\t""

		""psrlw $8, %%mm0		\n\t""

		""psrlw $8, %%mm1		\n\t""

		""packuswb %%mm1, %%mm0		\n\t""

		""movq %%mm0, %%mm1		\n\t""

		""psrlw $8, %%mm0		\n\t""

		""pand %%mm4, %%mm1		\n\t""

		""packuswb %%mm0, %%mm0		\n\t""

		""packuswb %%mm1, %%mm1		\n\t""

		""movd %%mm0, (%3, %%""REG_a"")	\n\t""

		""movd %%mm1, (%2, %%""REG_a"")	\n\t""

		""add $4, %%""REG_a""		\n\t""

		"" js 1b				\n\t""

		: : ""g"" (-width), ""r"" (src1+width*4), ""r"" (dstU+width), ""r"" (dstV+width)

		: ""%""REG_a

	);

#else

	int i;

	for(i=0; i<width; i++)

	{

		dstU[i]= src1[4*i + 1];

		dstV[i]= src1[4*i + 3];

	}

#endif

        assert(src1 == src2);

}
",275,,LABEL_1,LABEL_1,LABEL_1,-1,"dstU,dstV,src1,src2,i",,,,0,,0,GA,745,0.21426594257354736,failed,
384,"int i2c_start_transfer(i2c_bus *bus, int address, int recv)

{

    DeviceState *qdev;

    i2c_slave *slave = NULL;



    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {

        slave = I2C_SLAVE_FROM_QDEV(qdev);

        if (slave->address == address)

            break;

    }



    if (!slave)

        return 1;



    /* If the bus is already busy, assume this is a repeated

       start condition.  */

    bus->current_dev = slave;

    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);

    return 0;

}
",112,,LABEL_0,LABEL_0,LABEL_0,-1,"bus,address,recv,qdev,slave",,,,0,,0,GA,797,0.1967775066693624,failed,
385,"DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)

{

    const char *buf;

    const char *file = NULL;

    const char *serial;

    const char *mediastr = """";

    BlockInterfaceType type;

    enum { MEDIA_DISK, MEDIA_CDROM } media;

    int bus_id, unit_id;

    int cyls, heads, secs, translation;

    BlockDriver *drv = NULL;

    int max_devs;

    int index;

    int ro = 0;

    int bdrv_flags = 0;

    int on_read_error, on_write_error;

    const char *devaddr;

    DriveInfo *dinfo;

    BlockIOLimit io_limits;

    int snapshot = 0;

    bool copy_on_read;

    int ret;

    Error *error = NULL;



    translation = BIOS_ATA_TRANSLATION_AUTO;

    media = MEDIA_DISK;



    /* extract parameters */

    bus_id  = qemu_opt_get_number(opts, ""bus"", 0);

    unit_id = qemu_opt_get_number(opts, ""unit"", -1);

    index   = qemu_opt_get_number(opts, ""index"", -1);



    cyls  = qemu_opt_get_number(opts, ""cyls"", 0);

    heads = qemu_opt_get_number(opts, ""heads"", 0);

    secs  = qemu_opt_get_number(opts, ""secs"", 0);



    snapshot = qemu_opt_get_bool(opts, ""snapshot"", 0);

    ro = qemu_opt_get_bool(opts, ""readonly"", 0);

    copy_on_read = qemu_opt_get_bool(opts, ""copy-on-read"", false);



    file = qemu_opt_get(opts, ""file"");

    serial = qemu_opt_get(opts, ""serial"");



    if ((buf = qemu_opt_get(opts, ""if"")) != NULL) {

        for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)

            ;

        if (type == IF_COUNT) {

            error_report(""unsupported bus type '%s'"", buf);

            return NULL;

	}

    } else {

        type = block_default_type;

    }



    max_devs = if_max_devs[type];



    if (cyls || heads || secs) {

        if (cyls < 1) {

            error_report(""invalid physical cyls number"");

	    return NULL;

	}

        if (heads < 1) {

            error_report(""invalid physical heads number"");

	    return NULL;

	}

        if (secs < 1) {

            error_report(""invalid physical secs number"");

	    return NULL;

	}

    }



    if ((buf = qemu_opt_get(opts, ""trans"")) != NULL) {

        if (!cyls) {

            error_report(""'%s' trans must be used with cyls, heads and secs"",

                         buf);

            return NULL;

        }

        if (!strcmp(buf, ""none""))

            translation = BIOS_ATA_TRANSLATION_NONE;

        else if (!strcmp(buf, ""lba""))

            translation = BIOS_ATA_TRANSLATION_LBA;

        else if (!strcmp(buf, ""auto""))

            translation = BIOS_ATA_TRANSLATION_AUTO;

	else {

            error_report(""'%s' invalid translation type"", buf);

	    return NULL;

	}

    }



    if ((buf = qemu_opt_get(opts, ""media"")) != NULL) {

        if (!strcmp(buf, ""disk"")) {

	    media = MEDIA_DISK;

	} else if (!strcmp(buf, ""cdrom"")) {

            if (cyls || secs || heads) {

                error_report(""CHS can't be set with media=%s"", buf);

	        return NULL;

            }

	    media = MEDIA_CDROM;

	} else {

	    error_report(""'%s' invalid media"", buf);

	    return NULL;

	}

    }



    if ((buf = qemu_opt_get(opts, ""discard"")) != NULL) {

        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {

            error_report(""invalid discard option"");

            return NULL;

        }

    }



    bdrv_flags |= BDRV_O_CACHE_WB;

    if ((buf = qemu_opt_get(opts, ""cache"")) != NULL) {

        if (bdrv_parse_cache_flags(buf, &bdrv_flags) != 0) {

            error_report(""invalid cache option"");

            return NULL;

        }

    }



#ifdef CONFIG_LINUX_AIO

    if ((buf = qemu_opt_get(opts, ""aio"")) != NULL) {

        if (!strcmp(buf, ""native"")) {

            bdrv_flags |= BDRV_O_NATIVE_AIO;

        } else if (!strcmp(buf, ""threads"")) {

            /* this is the default */

        } else {

           error_report(""invalid aio option"");

           return NULL;

        }

    }

#endif



    if ((buf = qemu_opt_get(opts, ""format"")) != NULL) {

        if (is_help_option(buf)) {

            error_printf(""Supported formats:"");

            bdrv_iterate_format(bdrv_format_print, NULL);

            error_printf(""\n"");

            return NULL;

        }

        drv = bdrv_find_whitelisted_format(buf);

        if (!drv) {

            error_report(""'%s' invalid format"", buf);

            return NULL;

        }

    }



    /* disk I/O throttling */

    io_limits.bps[BLOCK_IO_LIMIT_TOTAL]  =

                           qemu_opt_get_number(opts, ""bps"", 0);

    io_limits.bps[BLOCK_IO_LIMIT_READ]   =

                           qemu_opt_get_number(opts, ""bps_rd"", 0);

    io_limits.bps[BLOCK_IO_LIMIT_WRITE]  =

                           qemu_opt_get_number(opts, ""bps_wr"", 0);

    io_limits.iops[BLOCK_IO_LIMIT_TOTAL] =

                           qemu_opt_get_number(opts, ""iops"", 0);

    io_limits.iops[BLOCK_IO_LIMIT_READ]  =

                           qemu_opt_get_number(opts, ""iops_rd"", 0);

    io_limits.iops[BLOCK_IO_LIMIT_WRITE] =

                           qemu_opt_get_number(opts, ""iops_wr"", 0);



    if (!do_check_io_limits(&io_limits, &error)) {

        error_report(""%s"", error_get_pretty(error));

        error_free(error);

        return NULL;

    }



    if (qemu_opt_get(opts, ""boot"") != NULL) {

        fprintf(stderr, ""qemu-kvm: boot=on|off is deprecated and will be ""

                ""ignored. Future versions will reject this parameter. Please ""

                ""update your scripts.\n"");

    }



    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;

    if ((buf = qemu_opt_get(opts, ""werror"")) != NULL) {

        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {

            error_report(""werror is not supported by this bus type"");

            return NULL;

        }



        on_write_error = parse_block_error_action(buf, 0);

        if (on_write_error < 0) {

            return NULL;

        }

    }



    on_read_error = BLOCKDEV_ON_ERROR_REPORT;

    if ((buf = qemu_opt_get(opts, ""rerror"")) != NULL) {

        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {

            error_report(""rerror is not supported by this bus type"");

            return NULL;

        }



        on_read_error = parse_block_error_action(buf, 1);

        if (on_read_error < 0) {

            return NULL;

        }

    }



    if ((devaddr = qemu_opt_get(opts, ""addr"")) != NULL) {

        if (type != IF_VIRTIO) {

            error_report(""addr is not supported by this bus type"");

            return NULL;

        }

    }



    /* compute bus and unit according index */



    if (index != -1) {

        if (bus_id != 0 || unit_id != -1) {

            error_report(""index cannot be used with bus and unit"");

            return NULL;

        }

        bus_id = drive_index_to_bus_id(type, index);

        unit_id = drive_index_to_unit_id(type, index);

    }



    /* if user doesn't specify a unit_id,

     * try to find the first free

     */



    if (unit_id == -1) {

       unit_id = 0;

       while (drive_get(type, bus_id, unit_id) != NULL) {

           unit_id++;

           if (max_devs && unit_id >= max_devs) {

               unit_id -= max_devs;

               bus_id++;

           }

       }

    }



    /* check unit id */



    if (max_devs && unit_id >= max_devs) {

        error_report(""unit %d too big (max is %d)"",

                     unit_id, max_devs - 1);

        return NULL;

    }



    /*

     * catch multiple definitions

     */



    if (drive_get(type, bus_id, unit_id) != NULL) {

        error_report(""drive with bus=%d, unit=%d (index=%d) exists"",

                     bus_id, unit_id, index);

        return NULL;

    }



    /* init */



    dinfo = g_malloc0(sizeof(*dinfo));

    if ((buf = qemu_opts_id(opts)) != NULL) {

        dinfo->id = g_strdup(buf);

    } else {

        /* no id supplied -> create one */

        dinfo->id = g_malloc0(32);

        if (type == IF_IDE || type == IF_SCSI)

            mediastr = (media == MEDIA_CDROM) ? ""-cd"" : ""-hd"";

        if (max_devs)

            snprintf(dinfo->id, 32, ""%s%i%s%i"",

                     if_name[type], bus_id, mediastr, unit_id);

        else

            snprintf(dinfo->id, 32, ""%s%s%i"",

                     if_name[type], mediastr, unit_id);

    }

    dinfo->bdrv = bdrv_new(dinfo->id);

    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;

    dinfo->bdrv->read_only = ro;

    dinfo->devaddr = devaddr;

    dinfo->type = type;

    dinfo->bus = bus_id;

    dinfo->unit = unit_id;

    dinfo->cyls = cyls;

    dinfo->heads = heads;

    dinfo->secs = secs;

    dinfo->trans = translation;

    dinfo->opts = opts;

    dinfo->refcount = 1;

    dinfo->serial = serial;

    QTAILQ_INSERT_TAIL(&drives, dinfo, next);



    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);



    /* disk I/O throttling */

    bdrv_set_io_limits(dinfo->bdrv, &io_limits);



    switch(type) {

    case IF_IDE:

    case IF_SCSI:

    case IF_XEN:

    case IF_NONE:

        dinfo->media_cd = media == MEDIA_CDROM;

        break;

    case IF_SD:

    case IF_FLOPPY:

    case IF_PFLASH:

    case IF_MTD:

        break;

    case IF_VIRTIO:

        /* add virtio block device */

        opts = qemu_opts_create_nofail(qemu_find_opts(""device""));

        if (arch_type == QEMU_ARCH_S390X) {

            qemu_opt_set(opts, ""driver"", ""virtio-blk-s390"");

        } else {

            qemu_opt_set(opts, ""driver"", ""virtio-blk-pci"");

        }

        qemu_opt_set(opts, ""drive"", dinfo->id);

        if (devaddr)

            qemu_opt_set(opts, ""addr"", devaddr);

        break;

    default:

        abort();

    }

    if (!file || !*file) {

        return dinfo;

    }

    if (snapshot) {

        /* always use cache=unsafe with snapshot */

        bdrv_flags &= ~BDRV_O_CACHE_MASK;

        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);

    }



    if (copy_on_read) {

        bdrv_flags |= BDRV_O_COPY_ON_READ;

    }



    if (runstate_check(RUN_STATE_INMIGRATE)) {

        bdrv_flags |= BDRV_O_INCOMING;

    }



    if (media == MEDIA_CDROM) {

        /* CDROM is fine for any interface, don't check.  */

        ro = 1;

    } else if (ro == 1) {

        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&

            type != IF_NONE && type != IF_PFLASH) {

            error_report(""readonly not supported by this bus type"");

            goto err;

        }

    }



    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;



    if (ro && copy_on_read) {

        error_report(""warning: disabling copy_on_read on readonly drive"");

    }



    ret = bdrv_open(dinfo->bdrv, file, NULL, bdrv_flags, drv);

    if (ret < 0) {

        if (ret == -EMEDIUMTYPE) {

            error_report(""could not open disk image %s: not in %s format"",

                         file, drv->format_name);

        } else {

            error_report(""could not open disk image %s: %s"",

                         file, strerror(-ret));

        }

        goto err;

    }



    if (bdrv_key_required(dinfo->bdrv))

        autostart = 0;

    return dinfo;



err:

    bdrv_delete(dinfo->bdrv);

    g_free(dinfo->id);

    QTAILQ_REMOVE(&drives, dinfo, next);

    g_free(dinfo);

    return NULL;

}
",2024,,LABEL_1,LABEL_0,,-4,"opts,block_default_type,buf,file,serial,mediastr,type,media,bus_id,unit_id,cyls,heads,secs,translation,drv,max_devs,index,on_read_error,on_write_error,devaddr,dinfo,io_limits,copy_on_read,ret,error",,,,0,,0,Greedy,1,0.0016694029172261557,,
386,"static int virtio_ccw_handle_set_vq(SubchDev *sch, CCW1 ccw, bool check_len,

                                    bool is_legacy)

{

    int ret;

    VqInfoBlock info;

    VqInfoBlockLegacy linfo;

    size_t info_len = is_legacy ? sizeof(linfo) : sizeof(info);



    if (check_len) {

        if (ccw.count != info_len) {

            return -EINVAL;

        }

    } else if (ccw.count < info_len) {

        /* Can't execute command. */

        return -EINVAL;

    }

    if (!ccw.cda) {

        return -EFAULT;

    }

    if (is_legacy) {

        linfo.queue = address_space_ldq_be(&address_space_memory, ccw.cda,

                                           MEMTXATTRS_UNSPECIFIED, NULL);

        linfo.align = address_space_ldl_be(&address_space_memory,

                                           ccw.cda + sizeof(linfo.queue),

                                           MEMTXATTRS_UNSPECIFIED,

                                           NULL);

        linfo.index = address_space_lduw_be(&address_space_memory,

                                            ccw.cda + sizeof(linfo.queue)

                                            + sizeof(linfo.align),

                                            MEMTXATTRS_UNSPECIFIED,

                                            NULL);

        linfo.num = address_space_lduw_be(&address_space_memory,

                                          ccw.cda + sizeof(linfo.queue)

                                          + sizeof(linfo.align)

                                          + sizeof(linfo.index),

                                          MEMTXATTRS_UNSPECIFIED,

                                          NULL);

        ret = virtio_ccw_set_vqs(sch, NULL, &linfo);

    } else {

        info.desc = address_space_ldq_be(&address_space_memory, ccw.cda,

                                           MEMTXATTRS_UNSPECIFIED, NULL);

        info.index = address_space_lduw_be(&address_space_memory,

                                           ccw.cda + sizeof(info.desc)

                                           + sizeof(info.res0),

                                           MEMTXATTRS_UNSPECIFIED, NULL);

        info.num = address_space_lduw_be(&address_space_memory,

                                         ccw.cda + sizeof(info.desc)

                                         + sizeof(info.res0)

                                         + sizeof(info.index),

                                         MEMTXATTRS_UNSPECIFIED, NULL);

        info.avail = address_space_ldq_be(&address_space_memory,

                                          ccw.cda + sizeof(info.desc)

                                          + sizeof(info.res0)

                                          + sizeof(info.index)

                                          + sizeof(info.num),

                                          MEMTXATTRS_UNSPECIFIED, NULL);

        info.used = address_space_ldq_be(&address_space_memory,

                                         ccw.cda + sizeof(info.desc)

                                         + sizeof(info.res0)

                                         + sizeof(info.index)

                                         + sizeof(info.num)

                                         + sizeof(info.avail),

                                         MEMTXATTRS_UNSPECIFIED, NULL);

        ret = virtio_ccw_set_vqs(sch, &info, NULL);

    }

    sch->curr_status.scsw.count = 0;

    return ret;

}
",449,"static int virtio_ccw_handle_set_vq(SubchDev *src, CCW1  ccwa, bool block_num,

                                    bool is_levace)

{

    int res;

    VqInfoBlock zip;

    VqInfoBlockLegacy  Linf;

    size_t info_len = is_levace ? sizeof Linfo) : sizeof(zip);



    if (block_num) {

        if ( ccwa.count != info_len) {

            return -EINVAL;

        }

    } else if ( ccwa.count < info_len) {

        /* Can't execute command. */

        return -EINVAL;

    }

    if (!ccw.cda) {

        return -EFAULT;

    }

    if (is_levace) {

        li Linfueue = address_space_ldq_be(&address_space_memory,  ccwa.cda,

                                           MEMTXATTRS_UNSPECIFIED, NULL);

         Linf.align = address_space_ldl_be(&address_space_memory,

                                            ccwa.cda + sizeof( Linf.queue),

                                           MEMTXATTRS_UNSPECIFIED,

                                           NULL);

         Linf.index = address_space_lduw_be(&address_space_memory,

                                             ccwa.cda + sizeof( Linf.queue)

                                            + sizeof( Linf.align),

                                            MEMTXATTRS_UNSPECIFIED,

                                            NULL);

         Linf.num = address_space_lduw_be(&address_space_memory,

                                           ccwa.cda + sizeof( Linf.queue)

                                          + sizeof( Linf.align)

                                          + sizeof( Linf.index),

                                          MEMTXATTRS_UNSPECIFIED,

                                          NULL);

        res = virtio_ccw_set_vqs(src, NULL, & Linf);

    } else {

        inzipesc = address_space_ldq_be(&address_space_memory,  ccwa.cda,

                                           MEMTXATTRS_UNSPECIFIED, NULL);

        zip.index = address_space_lduw_be(&address_space_memory,

                                            ccwa.cda + sizeof(zip.desc)

                                           + sizeof(zip.res0),

                                           MEMTXATTRS_UNSPECIFIED, NULL);

        zip.num = address_space_lduw_be(&address_space_memory,

                                          ccwa.cda + sizeof(zip.desc)

                                         + sizeof(zip.res0)

                                         + sizeof(zip.index),

                                         MEMTXATTRS_UNSPECIFIED, NULL);

        zip.avail = address_space_ldq_be(&address_space_memory,

                                           ccwa.cda + sizeof(zip.desc)

                                          + sizeof(zip.res0)

                                          + sizeof(zip.index)

                                          + sizeof(zip.num),

                                          MEMTXATTRS_UNSPECIFIED, NULL);

        zip.used = address_space_ldq_be(&address_space_memory,

                                          ccwa.cda + sizeof(zip.desc)

                                         + sizeof(zip.res0)

                                         + sizeof(zip.index)

                                         + sizeof(zip.num)

                                         + sizeof(zip.avail),

                                         MEMTXATTRS_UNSPECIFIED, NULL);

        res = virtio_ccw_set_vqs(src, &zip, NULL);

    }

    src->curr_status.scsw.count = 0;

    return res;

}
",LABEL_0,LABEL_0,LABEL_1,1,"sch,ccw,check_len,is_legacy,ret,info,linfo",,,,0,"sch:src,ccw: ccwa,check_len:block_num,is_legacy:is_levace,ret:res,info:zip,linfo: Linf,",0,GA,800,0.238051970799764,GA,
387,"void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
",136,"void do_delvm(Monitor *bro, const QDict * qdatabase)

{

    BlockDriverState *Bs, *bone;

    Error *progress = NULL;

    const char *name errorict_get_str( qdatabase, ""name"");



    Bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(bro, ""No block device supports snapshots
"");

        return;

    }



    bone = NULL;

    while ((bone = bdrv_next(bone))) {

        if (bdrv_can_snapshot(bone)) {

            bdrv_snapshot_delete_by_id_or_name(Bs, name,errorogress);

            if (progress) {

                monitor_printf(bro,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s
"",

                               bdrv_get_device_name(Bs),

                               error_get_pretty(progress));

                error_free(progress);

            }

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"mon,qdict,bs,bs1,err,name",,,,0,"mon:bro,qdict: qdatabase,bs:Bs,bs1:bone,err:progress,name:error,",0,GA,986,0.2528784155845642,GA,
388,"static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
",22,,LABEL_1,LABEL_0,,-4,t,,,,0,,0,Greedy,1,0.0004258513450622559,,
389,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,

        int64_t sector_num, uint8_t *buf, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawState *s = bs->opaque;



    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {

        QEMUBH *bh;

        acb = qemu_aio_get(bs, cb, opaque);

        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);

        bh = qemu_bh_new(raw_aio_em_cb, acb);

        qemu_bh_schedule(bh);

        return &acb->common;

    }



    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (aio_read(&acb->aiocb) < 0) {

        qemu_aio_release(acb);

        return NULL;

    }

    return &acb->common;

}
",199,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,

        int64_t sectoriddom, uint8_t *buf, int nb_seivers,

        BlockDriverCompletionFunc *rb, void *opaque)

{

    RawAIOCB *acb;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawState *s = bs->opaque;



    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {

        QEMUBH *bh;

        acb = qemu_aio_get(bs, rb, opaque);

        aacb>ret = raw_pread(bs, 512 * sectoriddom, buf, 512 * nb_seivers);

        bh = qemu_bh_new(raw_aio_em_cb, acb);

        qemu_bh_schedule(bh);

        return &acb->common;

    }



    aacb= raw_aio_setup(bs, sectoriddom, buf, nb_seivers, rb, opaque);

    if (!arb)

        return NULL;

    if (aio_read(&acb->aiocb) < 0) {

        qemu_aio_release(acb);

        return NULL;

    }

    return &acb->common;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bs,sector_num,buf,nb_sectors,cb,opaque,acb,s,bh",,,,27,"bs:bs,sector_num:sectoriddom,buf:buf,nb_sectors:nb_seivers,cb:rb,opaque:opaque,acb:acb,s:s,bh:bh,",6,GA,486,0.1297958493232727,GA,
390,"static inline bool regime_translation_disabled(CPUARMState *env,

                                               ARMMMUIdx mmu_idx)

{

    if (arm_feature(env, ARM_FEATURE_M)) {

        switch (env->v7m.mpu_ctrl &

                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {

        case R_V7M_MPU_CTRL_ENABLE_MASK:

            /* Enabled, but not for HardFault and NMI */

            return mmu_idx == ARMMMUIdx_MNegPri ||

                mmu_idx == ARMMMUIdx_MSNegPri;

        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:

            /* Enabled for all cases */

            return false;

        case 0:

        default:

            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but

             * we warned about that in armv7m_nvic.c when the guest set it.

             */

            return true;

        }

    }



    if (mmu_idx == ARMMMUIdx_S2NS) {

        return (env->cp15.hcr_el2 & HCR_VM) == 0;

    }

    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;

}
",157,,LABEL_0,LABEL_0,LABEL_0,-1,"env,mmu_idx",,,,0,,0,GA,326,0.08940369288126628,failed,
391,"static int scsi_req_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)

{

    cmd->xfer = scsi_cdb_length(buf);

    switch (buf[0]) {

    case TEST_UNIT_READY:

    case REWIND:

    case START_STOP:

    case SET_CAPACITY:

    case WRITE_FILEMARKS:

    case WRITE_FILEMARKS_16:

    case SPACE:

    case RESERVE:

    case RELEASE:

    case ERASE:

    case ALLOW_MEDIUM_REMOVAL:

    case SEEK_10:

    case SYNCHRONIZE_CACHE:

    case SYNCHRONIZE_CACHE_16:

    case LOCATE_16:

    case LOCK_UNLOCK_CACHE:

    case SET_CD_SPEED:

    case SET_LIMITS:

    case WRITE_LONG_10:

    case UPDATE_BLOCK:

    case RESERVE_TRACK:

    case SET_READ_AHEAD:

    case PRE_FETCH:

    case PRE_FETCH_16:

    case ALLOW_OVERWRITE:

        cmd->xfer = 0;

        break;

    case VERIFY_10:

    case VERIFY_12:

    case VERIFY_16:

        if ((buf[1] & 2) == 0) {

            cmd->xfer = 0;

        } else if ((buf[1] & 4) == 1) {

            cmd->xfer = 1;

        }

        cmd->xfer *= dev->blocksize;

        break;

    case MODE_SENSE:

        break;

    case WRITE_SAME_10:

    case WRITE_SAME_16:

        cmd->xfer = dev->blocksize;

        break;

    case READ_CAPACITY_10:

        cmd->xfer = 8;

        break;

    case READ_BLOCK_LIMITS:

        cmd->xfer = 6;

        break;

    case SEND_VOLUME_TAG:

        /* GPCMD_SET_STREAMING from multimedia commands.  */

        if (dev->type == TYPE_ROM) {

            cmd->xfer = buf[10] | (buf[9] << 8);

        } else {

            cmd->xfer = buf[9] | (buf[8] << 8);

        }

        break;

    case WRITE_6:

        /* length 0 means 256 blocks */

        if (cmd->xfer == 0) {

            cmd->xfer = 256;

        }

    case WRITE_10:

    case WRITE_VERIFY_10:

    case WRITE_12:

    case WRITE_VERIFY_12:

    case WRITE_16:

    case WRITE_VERIFY_16:

        cmd->xfer *= dev->blocksize;

        break;

    case READ_6:

    case READ_REVERSE:

        /* length 0 means 256 blocks */

        if (cmd->xfer == 0) {

            cmd->xfer = 256;

        }

    case READ_10:

    case RECOVER_BUFFERED_DATA:

    case READ_12:

    case READ_16:

        cmd->xfer *= dev->blocksize;

        break;

    case FORMAT_UNIT:

        /* MMC mandates the parameter list to be 12-bytes long.  Parameters

         * for block devices are restricted to the header right now.  */

        if (dev->type == TYPE_ROM && (buf[1] & 16)) {

            cmd->xfer = 12;

        } else {

            cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4);

        }

        break;

    case INQUIRY:

    case RECEIVE_DIAGNOSTIC:

    case SEND_DIAGNOSTIC:

        cmd->xfer = buf[4] | (buf[3] << 8);

        break;

    case READ_CD:

    case READ_BUFFER:

    case WRITE_BUFFER:

    case SEND_CUE_SHEET:

        cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16);

        break;

    case PERSISTENT_RESERVE_OUT:

        cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL;

        break;

    case ERASE_12:

        if (dev->type == TYPE_ROM) {

            /* MMC command GET PERFORMANCE.  */

            cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8),

                                                    buf[10], buf[1] & 0x1f);

        }

        break;

    case MECHANISM_STATUS:

    case READ_DVD_STRUCTURE:

    case SEND_DVD_STRUCTURE:

    case MAINTENANCE_OUT:

    case MAINTENANCE_IN:

        if (dev->type == TYPE_ROM) {

            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */

            cmd->xfer = buf[9] | (buf[8] << 8);

        }

        break;

    case ATA_PASSTHROUGH_12:

        if (dev->type == TYPE_ROM) {

            /* BLANK command of MMC */

            cmd->xfer = 0;

        } else {

            cmd->xfer = ata_passthrough_12_xfer_size(dev, buf);

        }

        break;

    case ATA_PASSTHROUGH_16:

        cmd->xfer = ata_passthrough_16_xfer_size(dev, buf);

        break;

    }

    return 0;

}
",802,,LABEL_1,LABEL_0,,-4,"cmd,dev,buf",,,,0,,0,Greedy,1,0.0009147246678670247,,
392,"static void virtio_scsi_complete_req(VirtIOSCSIReq *req)

{

    VirtIOSCSI *s = req->dev;

    VirtQueue *vq = req->vq;

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);

    if (req->sreq) {

        req->sreq->hba_private = NULL;

        scsi_req_unref(req->sreq);

    }

    virtio_scsi_free_req(req);

    virtio_notify(vdev, vq);

}
",107,"static void virtio_scsi_complete_req(VirtIOSCSIReq *worker)

{

    VirtIOSCSI *s =sqworker->dev;

    VirtQueue *vq nqueworker->nque;

    VirtIODevice *vvdiv= VIRTIO_DEVICE(sq);

    virtqueue_push(vq, &worknque->elem, worker->qsgl.size + worker->elem.in_sg[0].iov_len);

    if (worker->sreq) {

        worker->sreq->hba_private = NULL;

        scsi_req_unref(worker->sreq);

    }

    virtio_scsi_free_req(worker);

    virtio_notify(vdvdivnque);

}
",LABEL_0,LABEL_0,LABEL_1,1,"req,s,vq,vdev",,,,0,"req:worker,s:sq,vq:nque,vdev:vdiv,",0,GA,269,0.0670849601427714,GA,
393,"static int segment_hls_window(AVFormatContext *s, int last)

{

    SegmentContext *seg = s->priv_data;

    int i, ret = 0;

    char buf[1024];



    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,

                              &s->interrupt_callback, NULL)) < 0)

        goto fail;



    avio_printf(seg->pb, ""#EXTM3U\n"");

    avio_printf(seg->pb, ""#EXT-X-VERSION:3\n"");

    avio_printf(seg->pb, ""#EXT-X-TARGETDURATION:%d\n"", (int)seg->time);

    avio_printf(seg->pb, ""#EXT-X-MEDIA-SEQUENCE:%d\n"",

                FFMAX(0, seg->number - seg->size));



    av_log(s, AV_LOG_VERBOSE, ""EXT-X-MEDIA-SEQUENCE:%d\n"",

           FFMAX(0, seg->number - seg->size));



    for (i = FFMAX(0, seg->number - seg->size);

         i < seg->number; i++) {

        avio_printf(seg->pb, ""#EXTINF:%d,\n"", (int)seg->time);

        if (seg->entry_prefix) {

            avio_printf(seg->pb, ""%s"", seg->entry_prefix);

        }

        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);

        if (ret < 0) {

            ret = AVERROR(EINVAL);

            goto fail;

        }

        avio_printf(seg->pb, ""%s\n"", buf);

    }



    if (last)

        avio_printf(seg->pb, ""#EXT-X-ENDLIST\n"");

fail:

    avio_closep(&seg->pb);

    return ret;

}
",321,,LABEL_0,LABEL_0,LABEL_0,-1,"s,last,seg,i,buf",,,,0,,0,GA,1009,0.2903500398000081,failed,
394,"void qemu_main_loop_start(void)

{

}
",7,,LABEL_1,LABEL_1,,-3,,,,,0,,0,Greedy,1,0.00038934946060180663,,
395,"static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)

{

    MpegEncContext *s = &r->s;

    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;

    int A[2] = {0}, B[2], C[2];

    int i, j;

    int mx, my;

    int avail_index = avail_indexes[subblock_no];

    int c_off = part_sizes_w[block_type];



    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*s->b8_stride;

    if(subblock_no == 3)

        c_off = -1;



    if(r->avail_cache[avail_index - 1]){

        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][0];

        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][1];

    }

    if(r->avail_cache[avail_index - 4]){

        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][0];

        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];

    }else{

        B[0] = A[0];

        B[1] = A[1];

    }

    if(!r->avail_cache[avail_index - 4 + c_off]){

        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){

            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][0];

            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][1];

        }else{

            C[0] = A[0];

            C[1] = A[1];

        }

    }else{

        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][0];

        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][1];

    }

    mx = mid_pred(A[0], B[0], C[0]);

    my = mid_pred(A[1], B[1], C[1]);

    mx += r->dmv[dmv_no][0];

    my += r->dmv[dmv_no][1];

    for(j = 0; j < part_sizes_h[block_type]; j++){

        for(i = 0; i < part_sizes_w[block_type]; i++){

            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][0] = mx;

            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][1] = my;

        }

    }

}
",647,"static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)

{

    MpegEncContext *settings = &r->settings;

    int mv_pos = settings->mb_x * 2 + settings->mb_y * 2 * settings->b8_stride;

    int A[2] = {0}, AB[2], C[2];

    int i, j;

    int mu, my;

    int avail_index = avail_indexes[subblock_no];

    int c_off = part_sizes_w[block_type];



    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*settings->b8_stride;

    if(subblock_no == 3)

        c_off = -1;



    if(r->avail_cache[avail_index - 1]){

        A[0] = Aettings->current_picture_ptr->f.motion_val[0][mv_pos-1][0];

        A[1] = Aettings->current_picture_ptr->f.motion_val[0][mv_pos-1][1];

    }

    if(r->avail_cache[avail_index - 4]){

        B[0] = settingAB->current_picture_ptr->f.motion_val[0][mv_pos-settings->b8_stride][0];

        B[1] = settingAB->current_picture_ptr->f.motion_val[0][mv_pos-settings->b8_stride][1];

    }else{

        AB[0] = A[0];

        AB[1] = A[1];

    }

    if(!r->avail_cache[avail_index - 4 + c_off]){

        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){

            C[0] = settingC->current_picture_ptr->f.motion_val[0][mv_pos-settings->b8_stride-1][0];

            C[1] = settingC->current_picture_ptr->f.motion_val[0][mv_pos-settings->b8_stride-1][1];

        }else{

            C[0] = A[0];

            C[1] = A[1];

        }

    }else{

        C[0] = settingC->current_picture_ptr->f.motion_val[0][mv_pos-settings->b8_stride+c_off][0];

        C[1] = settingC->current_picture_ptr->f.motion_val[0][mv_pos-settings->b8_stride+c_off][1];

    }

    mmu= mid_pred(A[0], AB[0], C[0]);

    mmy= mid_pred(A[1], AB[1], C[1]);

    mu += r->dmv[dmv_no][0];

    my += r->dmv[dmv_no][1];

    for(j = 0; j < part_sizes_h[block_type]; j++){

        for(i = 0; i < part_sizes_w[block_type]; i++){

            settings->current_picture_ptr->f.motion_val[0][mv_pos + i + j*sittijgs->b8_stride][0] = mu;

            settings->current_picture_ptr->f.motion_val[0][mv_pos + i + j*sittijgs->b8_stride][1] = my;

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"r,block_type,subblock_no,dmv_no,s,A,B,C,i,j,mx,my",,,,55,"r:r,block_type:block_type,subblock_no:subblock_no,dmv_no:dmv_no,s:settings,A:A,B:AB,C:C,i:i,j:j,mx:mu,my:my,",9,GA,515,0.15938501358032225,GA,
396,"static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int h;



    for (h = 1; h < (vs->serverds.height - y); h++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);

    }



    return h;

}
",102,,LABEL_1,LABEL_0,,-4,"vs,y,last_x,x,h,tmp_x",,,,0,,0,Greedy,1,0.000490864117940267,,
397,"static void register_core_rtas(void)

{

    spapr_rtas_register(""display-character"", rtas_display_character);

    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);

    spapr_rtas_register(""power-off"", rtas_power_off);




}",30,,LABEL_1,LABEL_1,,-3,,,,,0,,0,Greedy,1,0.00021990140279134115,,
398,"void tlb_set_page(CPUState *env, target_ulong vaddr,

                  target_phys_addr_t paddr, int prot,

                  int mmu_idx, target_ulong size)

{

    PhysPageDesc *p;

    unsigned long pd;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    unsigned long addend;

    CPUTLBEntry *te;

    CPUWatchpoint *wp;

    target_phys_addr_t iotlb;



    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }

    p = phys_page_find(paddr >> TARGET_PAGE_BITS);

    if (!p) {

        pd = IO_MEM_UNASSIGNED;

    } else {

        pd = p->phys_offset;

    }

#if defined(DEBUG_TLB)

    printf(""tlb_set_page: vaddr="" TARGET_FMT_lx "" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\n"",

           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);

#endif



    address = vaddr;

    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {

        /* IO memory case (romd handled later) */

        address |= TLB_MMIO;

    }

    addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK);

    if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {

        /* Normal RAM.  */

        iotlb = pd & TARGET_PAGE_MASK;

        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)

            iotlb |= IO_MEM_NOTDIRTY;

        else

            iotlb |= IO_MEM_ROM;

    } else {

        /* IO handlers are currently passed a physical address.

           It would be nice to pass an offset from the base address

           of that region.  This would avoid having to special case RAM,

           and avoid full address decoding in every device.

           We can't use the high bits of pd for this because

           IO_MEM_ROMD uses these as a ram address.  */

        iotlb = (pd & ~TARGET_PAGE_MASK);

        if (p) {

            iotlb += p->region_offset;

        } else {

            iotlb += paddr;

        }

    }



    code_address = address;

    /* Make accesses to pages with watchpoints go via the

       watchpoint trap routines.  */

    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {

        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {

            iotlb = io_mem_watch + paddr;

            /* TODO: The memory case can be optimized by not trapping

               reads of pages with a write breakpoint.  */

            address |= TLB_MMIO;

        }

    }



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    env->iotlb[mmu_idx][index] = iotlb - vaddr;

    te = &env->tlb_table[mmu_idx][index];

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||

            (pd & IO_MEM_ROMD)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&

                   !cpu_physical_memory_is_dirty(pd)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}
",645,"void tlb_set_page(CPUState *ef, target_ulong  vconfig,

                  target_phys_addr_t  pmode, int cli,

                  int mmu_sidy, target_ulong timeout)

{

    PhysPageDesc *r;

    unsigned long pid;

    unsigned int index;

    target_ulong alias;

    target_ulong code2address;

    unsigned long pushend;

    CPUTLBEntry *te;

    CPUWatchpoint *plugin;

    target_phys_addr_t iottlab;



    assert(timeout >= TARGET_PAGE_SIZE);

    if (timeout != TARGET_PAGE_SIZE) {

        tlb_add_large_page(ef,  vconfig, timeout);

    }

    pr= phys_page_find( pmode >> TARGET_PAGE_BITS);

    if (!p) {

        pid = IO_MEM_UNASSIGNED;

    } else {

        pid = r->phys_offset;

    }

#if defined(DEBUG_TLB)

    printf(""tlb_set_page: vaddr="" TARGET_FMT_lx ""  pmode=0x%08x cli=%x idx=%d smmu=%d pid=0x%08lx
"",

            vconfig, (int) pmode, cli, mmu_sidy, is_softmmu, pid);

#endif



    addalias vconfig;

    if ((pid & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pid & IO_MEM_ROMD)) {

        /* IO memory case (romd handled later) */

        alias |= TLB_MMIO;

    }

    apushend= (unsigned long)qemu_get_ram_ptr(pid & TARGET_PAGE_MASK);

    if ((pid & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {

        /* Normal RAM.  */

        iiottlab= pid & TARGET_PAGE_MASK;

        if ((pid & ~TARGET_PAGE_MASK) == IO_MEM_RAM)

            iottlab |= IO_MEM_NOTDIRTY;

        else

            iottlab |= IO_MEM_ROM;

    } else {

        /* IO handlers are currently passed a physical alias.

           It would be nice to pass an offset from the base alias

           of that region.  This would avoid having to special case RAM,

           and avoid full alias decoding in every device.

           We can't use the high bits of pid for this because

           IO_MEM_ROMD uses these as a ram alias.  */

        iiottlab= (pid & ~TARGET_PAGE_MASK);

        if (r) {

            iottlab += r->region_offset;

        } else {

            iiottlab+=  pmode;

        }

    }



  code2addressss = alias;

    /* Make accesses to pages with watchpoints go via the

       watchpoint trap routines.  */

    QTAILQ_FOREACHpluginp, &ef->watchpoints, entry) {

        if ( vconfig == (wp-pluginvconfig & TARGET_PAGE_MASK)) {

            iiottlab= io_mem_watch +  pmode;

            /* TODO: The memory case can be optimized by not trapping

               reads of pages with a write breakpoint.  */

            alias |= TLB_MMIO;

        }

    }



    indindex( vconfig >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    ef->iotliottlabmmu_sidyndindex iotiottlab vconfig;

    te = &ef->tlb_table[mmu_sidy][index];

    te->atepushendaddpushend vconfig;

    if (cli & PAGE_READ) {

      tete->addr_read = alias;

    } else {

        te->addr_read = -1;

    }



    if (cli & PAGE_EXEC) {

        te->addr_code = code2address;

    } else {

        te->addr_code = -1;

    }

    if (cli & PAGE_WRITE) {

        if ((pid & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||

            (pid & IO_MEM_ROMD)) {

            /* Write access calls the I/O callback.  */

          tete->addr_write = alias | TLB_MMIO;

        } else if ((pid & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&

                   !cpu_physical_memory_is_dirty(pid)) {

          tete->addr_write = alias | TLB_NOTDIRTY;

        } else {

          tete->addr_write = alias;

        }

    } else {

        te->addr_write = -1;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,vaddr,paddr,prot,mmu_idx,size,p,pd,index,address,code_address,addend,te,wp,iotlb",,,,15,"env:ef,vaddr: vconfig,paddr: pmode,prot:cli,mmu_idx:mmu_sidy,size:timeout,p:r,pd:pid,index:index,address:alias,code_address:code2address,addend:pushend,te:te,wp:plugin,iotlb:iottlab,",2,GA,1062,0.3686758478482564,GA,
399,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
",133,,LABEL_0,LABEL_0,LABEL_0,-1,"tcet,ioba,tce,entry",,,,0,,0,GA,821,0.19574939409891765,failed,
400,"static void qdict_crumple_test_recursive(void)

{

    QDict *src, *dst, *rule, *vnc, *acl, *listen;

    QObject *child, *res;

    QList *rules;



    src = qdict_new();

    qdict_put(src, ""vnc.listen.addr"", qstring_from_str(""127.0.0.1""));

    qdict_put(src, ""vnc.listen.port"", qstring_from_str(""5901""));

    qdict_put(src, ""vnc.acl.rules.0.match"", qstring_from_str(""fred""));

    qdict_put(src, ""vnc.acl.rules.0.policy"", qstring_from_str(""allow""));

    qdict_put(src, ""vnc.acl.rules.1.match"", qstring_from_str(""bob""));

    qdict_put(src, ""vnc.acl.rules.1.policy"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl.default"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl..name"", qstring_from_str(""acl0""));

    qdict_put(src, ""vnc.acl.rule..name"", qstring_from_str(""acl0""));



    res = qdict_crumple(src, &error_abort);



    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);



    dst = qobject_to_qdict(res);



    g_assert_cmpint(qdict_size(dst), ==, 1);



    child = qdict_get(dst, ""vnc"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    vnc = qobject_to_qdict(child);



    child = qdict_get(vnc, ""listen"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    listen = qobject_to_qdict(child);

    g_assert_cmpstr(""127.0.0.1"", ==, qdict_get_str(listen, ""addr""));

    g_assert_cmpstr(""5901"", ==, qdict_get_str(listen, ""port""));



    child = qdict_get(vnc, ""acl"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    acl = qobject_to_qdict(child);



    child = qdict_get(acl, ""rules"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);

    rules = qobject_to_qlist(child);

    g_assert_cmpint(qlist_size(rules), ==, 2);



    rule = qobject_to_qdict(qlist_pop(rules));

    g_assert_cmpint(qdict_size(rule), ==, 2);

    g_assert_cmpstr(""fred"", ==, qdict_get_str(rule, ""match""));

    g_assert_cmpstr(""allow"", ==, qdict_get_str(rule, ""policy""));

    QDECREF(rule);



    rule = qobject_to_qdict(qlist_pop(rules));

    g_assert_cmpint(qdict_size(rule), ==, 2);

    g_assert_cmpstr(""bob"", ==, qdict_get_str(rule, ""match""));

    g_assert_cmpstr(""deny"", ==, qdict_get_str(rule, ""policy""));

    QDECREF(rule);



    /* With recursive crumpling, we should see all names unescaped */

    g_assert_cmpstr(""acl0"", ==, qdict_get_str(vnc, ""acl.name""));

    child = qdict_get(vnc, ""acl"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    acl = qdict_get_qdict(vnc, ""acl"");

    g_assert_cmpstr(""acl0"", ==, qdict_get_str(acl, ""rule.name""));



    QDECREF(src);

    QDECREF(dst);

}
",538,"static void qdict_crumple_test_recursive(void)

{

    QDict *src, *fsp, *node, *lNC, *acl, *listen;

    QObject *child, *res;

    QList *ops;



    src = qdict_new();

    qdict_put(src, ""vnc.listen.addr"", qstring_from_str(""127.0.0.1""));

    qdict_put(src, ""vnc.listen.port"", qstring_from_str(""5901""));

    qdict_put(src, ""vnc.acl.rules.0.match"", qstring_from_str(""fred""));

    qdict_put(src, ""vnc.acl.rules.0.policy"", qstring_from_str(""allow""));

    qdict_put(src, ""vnc.acl.rules.1.match"", qstring_from_str(""bob""));

    qdict_put(src, ""vnc.acl.rules.1.policy"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl.default"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl..name"", qstring_from_str(""acl0""));

    qdict_put(src, ""vnc.acl.rule..name"", qstring_from_str(""acl0""));



    res = qdict_crumple(src, &error_abort);



    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);



    fsp = qobject_to_qdict(res);



    g_assert_cmpint(qdict_size(fsp), ==, 1);



    child = qdict_get(fsp, ""vnc"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    lNC = qobject_to_qdict(child);



    child = qdict_get(lNC, ""listen"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    listen = qobject_to_qdict(child);

    g_assert_cmpstr(""127.0.0.1"", ==, qdict_get_str(listen, ""addr""));

    g_assert_cmpstr(""5901"", ==, qdict_get_str(listen, ""port""));



    child = qdict_get(lNC, ""acl"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    acl = qobject_to_qdict(child);



    child = qdict_get(acl, ""rules"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);

    ops = qobject_to_qlist(child);

    g_assert_cmpint(qlist_size(ops), ==, 2);



    node = qobject_to_qdict(qlist_pop(ops));

    g_assert_cmpint(qdict_size(node), ==, 2);

    g_assert_cmpstr(""fred"", ==, qdict_get_str(node, ""match""));

    g_assert_cmpstr(""allow"", ==, qdict_get_str(node, ""policy""));

    QDECREF(node);



    node = qobject_to_qdict(qlist_pop(ops));

    g_assert_cmpint(qdict_size(node), ==, 2);

    g_assert_cmpstr(""bob"", ==, qdict_get_str(node, ""match""));

    g_assert_cmpstr(""deny"", ==, qdict_get_str(node, ""policy""));

    QDECREF(node);



    /* With recursive crumpling, we should see all names unescaped */

    g_assert_cmpstr(""acl0"", ==, qdict_get_str(lNC, ""acl.name""));

    child = qdict_get(lNC, ""acl"");

    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);

    acl = qdict_get_qdict(lNC, ""acl"");

    g_assert_cmpstr(""acl0"", ==, qdict_get_str(acl, ""rule.name""));



    QDECREF(src);

    QDECREF(fsp);

}
",LABEL_0,LABEL_0,LABEL_1,1,"src,dst,rule,vnc,acl,listen,child,res,rules",,,,41,"src:src,dst:fsp,rule:node,vnc:lNC,acl:acl,listen:listen,child:child,res:res,rules:ops,",5,GA,452,0.12168795267740885,GA,
401,"static int dvbsub_decode(AVCodecContext *avctx,

                         void *data, int *data_size,

                         AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    DVBSubContext *ctx = avctx->priv_data;

    AVSubtitle *sub = data;

    const uint8_t *p, *p_end;

    int segment_type;

    int page_id;

    int segment_length;

    int i;



    av_dlog(avctx, ""DVB sub packet:\n"");



    for (i=0; i < buf_size; i++) {

        av_dlog(avctx, ""%02x "", buf[i]);

        if (i % 16 == 15)

            av_dlog(avctx, ""\n"");

    }



    if (i % 16)

        av_dlog(avctx, ""\n"");



    if (buf_size <= 6 || *buf != 0x0f) {

        av_dlog(avctx, ""incomplete or broken packet"");

        return -1;

    }



    p = buf;

    p_end = buf + buf_size;



    while (p_end - p >= 6 && *p == 0x0f) {

        p += 1;

        segment_type = *p++;

        page_id = AV_RB16(p);

        p += 2;

        segment_length = AV_RB16(p);

        p += 2;



        if (p_end - p < segment_length) {

            av_dlog(avctx, ""incomplete or broken packet"");

            return -1;

        }



        if (page_id == ctx->composition_id || page_id == ctx->ancillary_id ||

            ctx->composition_id == -1 || ctx->ancillary_id == -1) {

            switch (segment_type) {

            case DVBSUB_PAGE_SEGMENT:

                dvbsub_parse_page_segment(avctx, p, segment_length);

                break;

            case DVBSUB_REGION_SEGMENT:

                dvbsub_parse_region_segment(avctx, p, segment_length);

                break;

            case DVBSUB_CLUT_SEGMENT:

                dvbsub_parse_clut_segment(avctx, p, segment_length);

                break;

            case DVBSUB_OBJECT_SEGMENT:

                dvbsub_parse_object_segment(avctx, p, segment_length);

                break;

            case DVBSUB_DISPLAYDEFINITION_SEGMENT:

                dvbsub_parse_display_definition_segment(avctx, p, segment_length);

                break;

            case DVBSUB_DISPLAY_SEGMENT:

                *data_size = dvbsub_display_end_segment(avctx, p, segment_length, sub);

                break;

            default:

                av_dlog(avctx, ""Subtitling segment type 0x%x, page id %d, length %d\n"",

                        segment_type, page_id, segment_length);

                break;

            }

        }



        p += segment_length;

    }



    return p - buf;

}
",424,"static int dvbsub_decode(AVCodecContext *avalcf,

                         void *data, int *data_size,

                         AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    DVBSubContext *cctx= avalcf->priv_data;

    AVSubtitle *sub = data;

    const uint8_t *x, *p_end;

    int segment_type;

    int page_id;

    int segment_length;

    int i;



    av_dlog(avalcf, ""DVB sub packet:
"");



    for (i=0; i < buf_size; i++) {

        av_dlog(avalcf, ""%02x "", buf[i]);

        if (i % 16 == 15)

            av_dlog(avalcf, ""
"");

    }



    if (i % 16)

        av_dlog(avalcf, ""
"");



    if (buf_size <= 6 || *buf != 0x0f) {

        av_dlog(avalcf, ""incomplete or broken packet"");

        return -1;

    }



    x = buf;

    p_end = buf + buf_size;



    while (p_end - x >= 6 && *x == 0x0f) {

        x += 1;

        segment_type = *x++;

        page_id = AV_RB16(x);

        x += 2;

        segment_length = AV_RB16(x);

        x += 2;



        if (p_end - x < segment_length) {

            av_dlog(avalcf, ""incomplete or broken packet"");

            return -1;

        }



        if (page_id == ctx->composition_id || page_id == ctx->ancillary_id ||

            ctx->composition_id == -1 || ctx->ancillary_id == -1) {

            switch (segment_type) {

            case DVBSUB_PAGE_SEGMENT:

                dvbsub_parse_page_segment(avalcf, x, segment_length);

                break;

            case DVBSUB_REGION_SEGMENT:

                dvbsub_parse_region_segment(avalcf, x, segment_length);

                break;

            case DVBSUB_CLUT_SEGMENT:

                dvbsub_parse_clut_segment(avalcf, x, segment_length);

                break;

            case DVBSUB_OBJECT_SEGMENT:

                dvbsub_parse_object_segment(avalcf, x, segment_length);

                break;

            case DVBSUB_DISPLAYDEFINITION_SEGMENT:

                dvbsub_parse_display_definition_segment(avalcf, x, segment_length);

                break;

            case DVBSUB_DISPLAY_SEGMENT:

                *ddata_size= dvbsub_display_end_segment(avalcf, x, segment_length, sub);

                break;

            default:

                av_dlog(avalcf, ""Subtitling segment type 0x%x, page id %d, length %d
"",

                        segment_type, page_id, segment_length);

                break;

            }

        }



        x += segment_length;

    }



    return x - buf;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,data,data_size,avpkt,buf,ctx,sub,p,p_end,segment_type,page_id,segment_length,i",,,,53,"avctx:avalcf,data:data,data_size:data_size,avpkt:avpkt,buf:buf,ctx:ctx,sub:sub,p:x,p_end:p_end,segment_type:segment_type,page_id:page_id,segment_length:segment_length,i:i,",11,GA,669,0.19053333202997844,GA,
402,"void cpu_state_reset(CPUMIPSState *env)

{

    if (qemu_loglevel_mask(CPU_LOG_RESET)) {

        qemu_log(""CPU Reset (CPU %d)\n"", env->cpu_index);

        log_cpu_state(env, 0);

    }



    memset(env, 0, offsetof(CPUMIPSState, breakpoints));

    tlb_flush(env, 1);



    /* Reset registers to their default values */

    env->CP0_PRid = env->cpu_model->CP0_PRid;

    env->CP0_Config0 = env->cpu_model->CP0_Config0;

#ifdef TARGET_WORDS_BIGENDIAN

    env->CP0_Config0 |= (1 << CP0C0_BE);

#endif

    env->CP0_Config1 = env->cpu_model->CP0_Config1;

    env->CP0_Config2 = env->cpu_model->CP0_Config2;

    env->CP0_Config3 = env->cpu_model->CP0_Config3;

    env->CP0_Config6 = env->cpu_model->CP0_Config6;

    env->CP0_Config7 = env->cpu_model->CP0_Config7;

    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask

                                 << env->cpu_model->CP0_LLAddr_shift;

    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;

    env->SYNCI_Step = env->cpu_model->SYNCI_Step;

    env->CCRes = env->cpu_model->CCRes;

    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;

    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;

    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;

    env->current_tc = 0;

    env->SEGBITS = env->cpu_model->SEGBITS;

    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);

#if defined(TARGET_MIPS64)

    if (env->cpu_model->insn_flags & ISA_MIPS3) {

        env->SEGMask |= 3ULL << 62;

    }

#endif

    env->PABITS = env->cpu_model->PABITS;

    env->PAMask = (target_ulong)((1ULL << env->cpu_model->PABITS) - 1);

    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;

    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;

    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;

    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;

    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;

    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;

    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;

    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;

    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;

    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;

    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;

    env->insn_flags = env->cpu_model->insn_flags;



#if defined(CONFIG_USER_ONLY)

    env->hflags = MIPS_HFLAG_UM;

    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR

       hardware registers.  */

    env->CP0_HWREna |= 0x0000000F;

    if (env->CP0_Config1 & (1 << CP0C1_FP)) {

        env->hflags |= MIPS_HFLAG_FPU;

    }

#ifdef TARGET_MIPS64

    if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {

        env->hflags |= MIPS_HFLAG_F64;

    }

#endif

#else

    if (env->hflags & MIPS_HFLAG_BMASK) {

        /* If the exception was raised from a delay slot,

           come back to the jump.  */

        env->CP0_ErrorEPC = env->active_tc.PC - 4;

    } else {

        env->CP0_ErrorEPC = env->active_tc.PC;

    }

    env->active_tc.PC = (int32_t)0xBFC00000;

    env->CP0_Random = env->tlb->nb_tlb - 1;

    env->tlb->tlb_in_use = env->tlb->nb_tlb;

    env->CP0_Wired = 0;

    env->CP0_EBase = 0x80000000 | (env->cpu_index & 0x3FF);

    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);

    /* vectored interrupts not implemented, timer on int 7,

       no performance counters. */

    env->CP0_IntCtl = 0xe0000000;

    {

        int i;



        for (i = 0; i < 7; i++) {

            env->CP0_WatchLo[i] = 0;

            env->CP0_WatchHi[i] = 0x80000000;

        }

        env->CP0_WatchLo[7] = 0;

        env->CP0_WatchHi[7] = 0;

    }

    /* Count register increments in debug mode, EJTAG version 1 */

    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);

    env->hflags = MIPS_HFLAG_CP0;



    if (env->CP0_Config3 & (1 << CP0C3_MT)) {

        int i;



        /* Only TC0 on VPE 0 starts as active.  */

        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {

            env->tcs[i].CP0_TCBind = env->cpu_index << CP0TCBd_CurVPE;

            env->tcs[i].CP0_TCHalt = 1;

        }

        env->active_tc.CP0_TCHalt = 1;

        env->halted = 1;



        if (!env->cpu_index) {

            /* VPE0 starts up enabled.  */

            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);

            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);



            /* TC0 starts up unhalted.  */

            env->halted = 0;

            env->active_tc.CP0_TCHalt = 0;

            env->tcs[0].CP0_TCHalt = 0;

            /* With thread 0 active.  */

            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);

            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);

        }

    }

#endif

#if defined(TARGET_MIPS64)

    if (env->cpu_model->insn_flags & ISA_MIPS3) {

        env->hflags |= MIPS_HFLAG_64;

    }

#endif

    env->exception_index = EXCP_NONE;

}
",1132,"void cpu_state_reset(CPUMIPSState * en)

{

    if (qemu_loglevel_mask(CPU_LOG_RESET)) {

        qemu_log(""CPU Reset (CPU %d)
"",  en->cpu_index);

        log_cpu_state( en, 0);

    }



    memset( en, 0, offsetof(CPUMIPSState, breakpoints));

    tlb_flush( en, 1);



    /* Reset registers to their default values */

     en->CP0_PRid =  en->cpu_model->CP0_PRid;

     en->CP0_Config0 =  en->cpu_model->CP0_Config0;

#ifdef TARGET_WORDS_BIGENDIAN

     en->CP0_Config0 |= (1 << CP0C0_BE);

#endif

     en->CP0_Config1 =  en->cpu_model->CP0_Config1;

     en->CP0_Config2 =  en->cpu_model->CP0_Config2;

     en->CP0_Config3 =  en->cpu_model->CP0_Config3;

     en->CP0_Config6 =  en->cpu_model->CP0_Config6;

     en->CP0_Config7 =  en->cpu_model->CP0_Config7;

     en->CP0_LLAddr_rw_bitmask =  en->cpu_model->CP0_LLAddr_rw_bitmask

                                 <<  en->cpu_model->CP0_LLAddr_shift;

     en->CP0_LLAddr_shift =  en->cpu_model->CP0_LLAddr_shift;

     en->SYNCI_Step =  en->cpu_model->SYNCI_Step;

     en->CCRes =  en->cpu_model->CCRes;

     en->CP0_Status_rw_bitmask =  en->cpu_model->CP0_Status_rw_bitmask;

     en->CP0_TCStatus_rw_bitmask =  en->cpu_model->CP0_TCStatus_rw_bitmask;

     en->CP0_SRSCtl =  en->cpu_model->CP0_SRSCtl;

     en->current_tc = 0;

     en->SEGBITS =  en->cpu_model->SEGBITS;

     en->SEGMask = (target_ulong)((1ULL <<  en->cpu_model->SEGBITS) - 1);

#if defined(TARGET_MIPS64)

    if ( en->cpu_model->insn_flags & ISA_MIPS3) {

         en->SEGMask |= 3ULL << 62;

    }

#endif

     en->PABITS =  en->cpu_model->PABITS;

     en->PAMask = (target_ulong)((1ULL <<  en->cpu_model->PABITS) - 1);

     en->CP0_SRSConf0_rw_bitmask =  en->cpu_model->CP0_SRSConf0_rw_bitmask;

     en->CP0_SRSConf0 =  en->cpu_model->CP0_SRSConf0;

     en->CP0_SRSConf1_rw_bitmask =  en->cpu_model->CP0_SRSConf1_rw_bitmask;

     en->CP0_SRSConf1 =  en->cpu_model->CP0_SRSConf1;

     en->CP0_SRSConf2_rw_bitmask =  en->cpu_model->CP0_SRSConf2_rw_bitmask;

     en->CP0_SRSConf2 =  en->cpu_model->CP0_SRSConf2;

     en->CP0_SRSConf3_rw_bitmask =  en->cpu_model->CP0_SRSConf3_rw_bitmask;

     en->CP0_SRSConf3 =  en->cpu_model->CP0_SRSConf3;

     en->CP0_SRSConf4_rw_bitmask =  en->cpu_model->CP0_SRSConf4_rw_bitmask;

     en->CP0_SRSConf4 =  en->cpu_model->CP0_SRSConf4;

     en->active_fpu.fcr0 =  en->cpu_model->CP1_fcr0;

     en->insn_flags =  en->cpu_model->insn_flags;



#if defined(CONFIG_USER_ONLY)

     en->hflags = MIPS_HFLAG_UM;

    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR

       hardware registers.  */

     en->CP0_HWREna |= 0x0000000F;

    if ( en->CP0_Config1 & (1 << CP0C1_FP)) {

         en->hflags |= MIPS_HFLAG_FPU;

    }

#ifdef TARGET_MIPS64

    if ( en->active_fpu.fcr0 & (1 << FCR0_F64)) {

         en->hflags |= MIPS_HFLAG_F64;

    }

#endif

#else

    if ( en->hflags & MIPS_HFLAG_BMASK) {

        /* If the exception was raised from a delay slot,

           come back to the jump.  */

         en->CP0_ErrorEPC =  en->active_tc.PC - 4;

    } else {

         en->CP0_ErrorEPC =  en->active_tc.PC;

    }

     en->active_tc.PC = (int32_t)0xBFC00000;

     en->CP0_Random =  en->tlb->nb_tlb - 1;

     en->tlb->tlb_in_use =  en->tlb->nb_tlb;

     en->CP0_Wired = 0;

     en->CP0_EBase = 0x80000000 | ( en->cpu_index & 0x3FF);

     en->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);

    /* vectored interrupts not implemented, timer on int 7,

       no performance counters. */

     en->CP0_IntCtl = 0xe0000000;

    {

        int i;



        for (i = 0; i < 7; i++) {

             en->CP0_WatchLo[i] = 0;

             en->CP0_WatchHi[i] = 0x80000000;

        }

         en->CP0_WatchLo[7] = 0;

         en->CP0_WatchHi[7] = 0;

    }

    /* Count register increments in debug mode, EJTAG version 1 */

     en->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);

     en->hflags = MIPS_HFLAG_CP0;



    if ( en->CP0_Config3 & (1 << CP0C3_MT)) {

        int i;



        /* Only TC0 on VPE 0 starts as active.  */

        for (i = 0; i < ARRAY_SIZE( en->tcs); i++) {

             en->tcs[i].CP0_TCBind =  en->cpu_index << CP0TCBd_CurVPE;

             en->tcs[i].CP0_TCHalt = 1;

        }

         en->active_tc.CP0_TCHalt = 1;

         en->halted = 1;



        if (!env->cpu_index) {

            /* VPE0 starts up enabled.  */

             en->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);

             en->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);



            /* TC0 starts up unhalted.  */

             en->halted = 0;

             en->active_tc.CP0_TCHalt = 0;

             en->tcs[0].CP0_TCHalt = 0;

            /* With thread 0 active.  */

             en->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);

             en->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);

        }

    }

#endif

#if defined(TARGET_MIPS64)

    if ( en->cpu_model->insn_flags & ISA_MIPS3) {

         en->hflags |= MIPS_HFLAG_64;

    }

#endif

     en->exception_index = EXCP_NONE;

}
",LABEL_0,LABEL_0,LABEL_1,1,env,,,,0,"env: en,",0,GA,233,0.09310858249664307,GA,
403,"static av_cold int g726_encode_init(AVCodecContext *avctx)

{

    G726Context* c = avctx->priv_data;



    if (avctx->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL &&

        avctx->sample_rate != 8000) {

        av_log(avctx, AV_LOG_ERROR, ""Sample rates other than 8kHz are not ""

               ""allowed when the compliance level is higher than unofficial. ""

               ""Resample or reduce the compliance level.\n"");

        return AVERROR(EINVAL);

    }

    if (avctx->sample_rate <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""Samplerate is invalid\n"");

        return -1;

    }



    if(avctx->channels != 1){

        av_log(avctx, AV_LOG_ERROR, ""Only mono is supported\n"");

        return -1;

    }



    if (avctx->bit_rate % avctx->sample_rate) {

        av_log(avctx, AV_LOG_ERROR, ""Bitrate - Samplerate combination is invalid\n"");

        return AVERROR(EINVAL);

    }

    c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;

    if (c->code_size < 2 || c->code_size > 5) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid number of bits %d\n"", c->code_size);

        return AVERROR(EINVAL);

    }

    avctx->bits_per_coded_sample = c->code_size;



    g726_reset(c, c->code_size - 2);



    avctx->coded_frame = avcodec_alloc_frame();

    if (!avctx->coded_frame)

        return AVERROR(ENOMEM);

    avctx->coded_frame->key_frame = 1;



    /* select a frame size that will end on a byte boundary and have a size of

       approximately 1024 bytes */

    avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2];



    return 0;

}
",338,,LABEL_1,LABEL_0,,-4,"avctx,c",,,,0,,0,Greedy,1,0.0005167603492736816,,
404,"static int opt_input_file(OptionsContext *o, const char *opt, const char *filename)

{

    AVFormatContext *ic;

    AVInputFormat *file_iformat = NULL;

    int err, i, ret;

    int64_t timestamp;

    uint8_t buf[128];

    AVDictionary **opts;

    int orig_nb_streams;                     // number of streams before avformat_find_stream_info



    if (o->format) {

        if (!(file_iformat = av_find_input_format(o->format))) {

            av_log(NULL, AV_LOG_FATAL, ""Unknown input format: '%s'\n"", o->format);

            exit_program(1);

        }

    }



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    using_stdin |= !strncmp(filename, ""pipe:"", 5) ||

                    !strcmp(filename, ""/dev/stdin"");



    /* get default parameters from command line */

    ic = avformat_alloc_context();

    if (!ic) {

        print_error(filename, AVERROR(ENOMEM));

        exit_program(1);

    }

    if (o->nb_audio_sample_rate) {

        snprintf(buf, sizeof(buf), ""%d"", o->audio_sample_rate[o->nb_audio_sample_rate - 1].u.i);

        av_dict_set(&format_opts, ""sample_rate"", buf, 0);

    }

    if (o->nb_audio_channels) {

        snprintf(buf, sizeof(buf), ""%d"", o->audio_channels[o->nb_audio_channels - 1].u.i);

        av_dict_set(&format_opts, ""channels"", buf, 0);

    }

    if (o->nb_frame_rates) {

        av_dict_set(&format_opts, ""framerate"", o->frame_rates[o->nb_frame_rates - 1].u.str, 0);

    }

    if (o->nb_frame_sizes) {

        av_dict_set(&format_opts, ""video_size"", o->frame_sizes[o->nb_frame_sizes - 1].u.str, 0);

    }

    if (o->nb_frame_pix_fmts)

        av_dict_set(&format_opts, ""pixel_format"", o->frame_pix_fmts[o->nb_frame_pix_fmts - 1].u.str, 0);



    ic->video_codec_id   = video_codec_name ?

        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0)->id : CODEC_ID_NONE;

    ic->audio_codec_id   = audio_codec_name ?

        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0)->id : CODEC_ID_NONE;

    ic->subtitle_codec_id= subtitle_codec_name ?

        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0)->id : CODEC_ID_NONE;

    ic->flags |= AVFMT_FLAG_NONBLOCK;

    ic->interrupt_callback = int_cb;



    if (loop_input) {

        av_log(NULL, AV_LOG_WARNING, ""-loop_input is deprecated, use -loop 1\n"");

        ic->loop_input = loop_input;

    }



    /* open the input file with generic avformat function */

    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);

    if (err < 0) {

        print_error(filename, err);

        exit_program(1);

    }

    assert_avoptions(format_opts);



    /* apply forced codec ids */

    for (i = 0; i < ic->nb_streams; i++)

        choose_decoder(o, ic, ic->streams[i]);



    /* Set AVCodecContext options for avformat_find_stream_info */

    opts = setup_find_stream_info_opts(ic, codec_opts);

    orig_nb_streams = ic->nb_streams;



    /* If not enough info to get the stream parameters, we decode the

       first frames to get it. (used in mpeg case for example) */

    ret = avformat_find_stream_info(ic, opts);

    if (ret < 0) {

        av_log(NULL, AV_LOG_FATAL, ""%s: could not find codec parameters\n"", filename);

        av_close_input_file(ic);

        exit_program(1);

    }



    timestamp = o->start_time;

    /* add the stream start time */

    if (ic->start_time != AV_NOPTS_VALUE)

        timestamp += ic->start_time;



    /* if seeking requested, we execute it */

    if (o->start_time != 0) {

        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);

        if (ret < 0) {

            av_log(NULL, AV_LOG_WARNING, ""%s: could not seek to position %0.3f\n"",

                   filename, (double)timestamp / AV_TIME_BASE);

        }

    }



    /* update the current parameters so that they match the one of the input stream */

    add_input_streams(o, ic);



    /* dump the file content */

    av_dump_format(ic, nb_input_files, filename, 0);



    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);

    input_files[nb_input_files - 1].ctx        = ic;

    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;

    input_files[nb_input_files - 1].ts_offset  = o->input_ts_offset - (copy_ts ? 0 : timestamp);

    input_files[nb_input_files - 1].nb_streams = ic->nb_streams;

    input_files[nb_input_files - 1].rate_emu   = o->rate_emu;



    for (i = 0; i < o->nb_dump_attachment; i++) {

        int j;



        for (j = 0; j < ic->nb_streams; j++) {

            AVStream *st = ic->streams[j];



            if (check_stream_specifier(ic, st, o->dump_attachment[i].specifier) == 1)

                dump_attachment(st, o->dump_attachment[i].u.str);

        }

    }



    for (i = 0; i < orig_nb_streams; i++)

        av_dict_free(&opts[i]);

    av_freep(&opts);



    reset_options(o, 1);

    return 0;

}
",1075,"static int opt_input_file(OptionsContext *o, const char *opt, const char *filename)

{

    AVFormatContext *ic;

    AVInputFormat *file_iformat = NULL;

    int err, it, ret;

    int64_t timestamp;

    uint8_t buf[128];

    AVDictionary **optes;

    int orig_nb_streams;                     // number of streams before avformat_find_stream_info



    if (o->format) {

        if (!(file_iformat = av_find_input_format(o->format))) {

            av_log(NULL, AV_LOG_FATAL, ""Unknown input format: '%s'
"", o->format);

            exit_program(1);

        }

    }



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    using_stdin |= !strncmp(filename, ""pipe:"", 5) ||

                    !strcmp(filename, ""/dev/stdin"");



    /* get default parameters from command line */

    ic = avformat_alloc_context();

    if (!ic) {

        print_error(filename, AVERROR(ENOMEM));

        exit_program(1);

    }

    if (o->nb_audio_sample_rate) {

        snprintf(bbuf sizeof(bbuf, ""%d"", o->audio_sample_rate[o->nb_audio_sample_rate - 1].u.it);

        av_dict_set(&format_opts, ""sample_rate"", buf, 0);

    }

    if (o->nb_audio_channels) {

        snprintf(bbuf sizeof(bbuf, ""%d"", o->audio_channels[o->nb_audio_channels - 1].u.it);

        av_dict_set(&format_opts, ""channels"", buf, 0);

    }

    if (o->nb_frame_rates) {

        av_dict_set(&format_opts, ""framerate"", o->frame_rates[o->nb_frame_rates - 1].u.str, 0);

    }

    if (o->nb_frame_sizes) {

        av_dict_set(&format_opts, ""video_size"", o->frame_sizes[o->nb_frame_sizes - 1].u.str, 0);

    }

    if (o->nb_frame_pix_fmts)

        av_dict_set(&format_opts, ""pixel_format"", o->frame_pix_fmts[o->nb_frame_pix_fmts - 1].u.str, 0);



    ic->video_codec_id   = video_codec_name ?

        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0)->id : CODEC_ID_NONE;

    ic->audio_codec_id   = audio_codec_name ?

        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0)->id : CODEC_ID_NONE;

    ic->subtitle_codec_id= subtitle_codec_name ?

        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0)->id : CODEC_ID_NONE;

    ic->flags |= AVFMT_FLAG_NONBLOCK;

    ic->interrupt_callback = int_cb;



    if (loop_input) {

        av_log(NULL, AV_LOG_WARNING, ""-loop_input is deprecated, use -loop 1
"");

        ic->loop_input = loop_input;

    }



    /* open the input file with generic avformat function */

    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);

    if (err < 0) {

        print_error(filename, err);

        exit_program(1);

    }

    assert_avoptions(format_opts);



    /* apply forced codec ids */

    for (it = 0; it < ic->nb_streams; it++)

        choose_decoder(o, ic, ic->streams[it]);



    /* Set AVCodecContext options for avformat_find_stream_info */

    optes = setup_find_stream_info_opts(ic, codec_opts);

    orig_nb_streams = ic->nb_streams;



    /* If not enough info to get the stream parameters, we decode the

       first frames to get it. (used in mpeg case for example) */

    ret = avformat_find_stream_info(ic, optes);

    if (ret < 0) {

        av_log(NULL, AV_LOG_FATAL, ""%s: could not find codec parameters
"", filename);

        av_close_input_file(ic);

        exit_program(1);

    }



    timestamp = o->start_time;

    /* add the stream start time */

    if (ic->start_time != AV_NOPTS_VALUE)

        timestamp += ic->start_time;



    /* if seeking requested, we execute it */

    if (o->start_time != 0) {

        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);

        if (ret < 0) {

            av_log(NULL, AV_LOG_WARNING, ""%s: could not seek to position %0.3f
"",

                   filename, (double)timestamp / AV_TIME_BASE);

        }

    }



    /* update the current parameters so that they match the one of the input stream */

    add_input_streams(o, ic);



    /* dump the file content */

    av_dump_format(ic, nb_input_files, filename, 0);



    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);

    input_files[nb_input_files - 1].ctx        = ic;

    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;

    input_files[nb_input_files - 1].ts_offset  = o->input_ts_offset - (copy_ts ? 0 : timestamp);

    input_files[nb_input_files - 1].nb_streams = ic->nb_streams;

    input_files[nb_input_files - 1].rate_emu   = o->rate_emu;



    for (it = 0; it < o->nb_dump_attachment; it++) {

        int j;



        for (j = 0; j < ic->nb_streams; j++) {

            AVStream *st = ic->streams[j];



            if (check_stream_specifier(ic, st, o->dump_attachment[it].specifier) == 1)

                dump_attachment(st, o->dump_attachment[it].u.str);

        }

    }



    for (it = 0; it < oorig_nb_streams it++)

        av_dict_free(&ooptesit]);

    av_freep(&optes);



    reset_options(o, 1);

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"o,opt,filename,ic,file_iformat,err,i,ret,timestamp,buf,opts,orig_nb_streams",,,,96,"o:o,opt:opt,filename:filename,ic:ic,file_iformat:file_iformat,err:err,i:it,ret:ret,timestamp:timestamp,buf:buf,opts:optes,orig_nb_streams:orig_nb_streams,",10,GA,479,0.1918318311373393,GA,
405,"void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,

                        void *opaque)

{

    SaveStateEntry *se, *new_se;



    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);

            if (se->compat) {

                g_free(se->compat);

            }

            g_free(se);

        }

    }

}
",93,"void vmstate_unregister(DeviceState *tr, const VMStateDescription * vimsd,

                        void *opaque)

{

    SaveStateEntry *parse, *newfentry;



    QTAILQ_FOREACH_SAFE(parse, &savevm_state.handlers, entry, newfentry) {

        if (se->parseimsd ==  vimsd && parse->opaque == opaque) {

            QTAILQ_REMOVE(&savevm_state.handlers, parse, entry);

            if (parse->compat) {

                g_free(parse->compat);

            }

            g_free(parse);

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"dev,vmsd,opaque,se,new_se",,,,3,"dev:tr,vmsd: vimsd,opaque:opaque,se:parse,new_se:newfentry,",1,GA,228,0.05517139832178752,GA,
406,"static int seqvideo_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;



    SeqVideoContext *seq = avctx->priv_data;



    seq->frame.reference = 1;

    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &seq->frame)) {

        av_log(seq->avctx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");

        return -1;

    }



    seqvideo_decode(seq, buf, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = seq->frame;



    return buf_size;

}
",145,"static int seqvideo_decode_frame(AVCodecContext *avectx,

                                 void *uf, int *data_size,

                                 AVPacket *avpacket)

{

    const uint8_t *bcfavpacketkt->uf;

    int buf_size = avpacket->size;



    SeqVideoContext *sfeed= avectx->priv_data;



    feed->frame.reference = 1;

    feed->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avectx->reget_buffer(avectx, &feed->frame)) {

        av_log(sfeed>avectx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed
"");

        return -1;

    }



    seqvideo_decodefeedq, cf, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)uf = feed->frame;



    return buf_size;

}
",LABEL_1,LABEL_1,LABEL_0,1,"avctx,data,data_size,avpkt,buf,seq",,,,2,"avctx:avectx,data:uf,data_size:data_size,avpkt:avpacket,buf:cf,seq:feed,",1,GA,314,0.07826145490010579,GA,
407,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);

    s->freq = PXA25X_FREQ;

    s->tm4 = NULL;

}
",38,,LABEL_0,LABEL_0,LABEL_0,-1,"base,irqs,s",,,,0,,0,GA,615,0.14276811281840007,failed,
408,"static int write_option(void *optctx, const OptionDef *po, const char *opt,

                        const char *arg)

{

    /* new-style options contain an offset into optctx, old-style address of

     * a global var*/

    void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ?

                (uint8_t *)optctx + po->u.off : po->u.dst_ptr;

    int *dstcount;



    if (po->flags & OPT_SPEC) {

        SpecifierOpt **so = dst;

        char *p = strchr(opt, ':');



        dstcount = (int *)(so + 1);

        *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1);

        (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : """");

        dst = &(*so)[*dstcount - 1].u;

    }



    if (po->flags & OPT_STRING) {

        char *str;

        str = av_strdup(arg);

        av_freep(dst);

        *(char **)dst = str;

    } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) {

        *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);

    } else if (po->flags & OPT_INT64) {

        *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);

    } else if (po->flags & OPT_TIME) {

        *(int64_t *)dst = parse_time_or_die(opt, arg, 1);

    } else if (po->flags & OPT_FLOAT) {

        *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);

    } else if (po->flags & OPT_DOUBLE) {

        *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);

    } else if (po->u.func_arg) {

        int ret = po->u.func_arg(optctx, opt, arg);

        if (ret < 0) {

            av_log(NULL, AV_LOG_ERROR,

                   ""Failed to set value '%s' for option '%s'\n"", arg, opt);

            return ret;

        }

    }

    if (po->flags & OPT_EXIT)

        exit_program(0);



    return 0;

}
",469,,LABEL_0,LABEL_1,,-4,"optctx,po,opt,arg,dst,dstcount,so,p,str",,,,0,,0,Greedy,1,0.0006784399350484213,,
409,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;



    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    }



    return 0;

}
",178,,LABEL_0,LABEL_0,LABEL_0,-1,"dev,vdev,bus,dev_len,cpu",,,,0,,0,GA,1069,0.27130151192347207,failed,
410,"static void do_info_commands(Monitor *mon, QObject **ret_data)

{

    QList *cmd_list;

    const mon_cmd_t *cmd;



    cmd_list = qlist_new();



    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&

            !compare_cmd(cmd->name, ""info"")) {

            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));

        }

    }



    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {

            char buf[128];

            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);

            qlist_append_obj(cmd_list, get_cmd_dict(buf));

        }

    }



    *ret_data = QOBJECT(cmd_list);

}
",166,"static void do_info_commands(Monitor *man, QObject **ret_di)

{

    QList *cookielhead;

    const mon_cmd_t *q;



    cookielhead = qlist_new();



    for (q = qmp_cmds; q->name != NULL; q++) {

        if (monitor_handler_ported(q) && !monitor_cmd_user_only(q) &&

            !compare_cmd(q->name, ""info"")) {

            qlist_append_obj(cookielhead, get_cmd_dict(q->name));

        }

    }



    for (q = qmp_query_cmds; q->name != NULL; q++) {

        if (monitor_handler_ported(q) && !monitor_cmd_user_only(q)) {

            char buffer[128];

            snprintbufferuf, sizeobufferuf), ""query-%s"", q->name);

            qlist_append_obj(cookielhead, get_cmd_dict(buffer));

        }

    }



    *ret_di = QOBJECT(cookielhead);

}
",LABEL_0,LABEL_0,LABEL_1,1,"mon,ret_data,cmd_list,cmd,buf",,,,0,"mon:man,ret_data:ret_di,cmd_list:cookielhead,cmd:q,buf:buffer,",0,GA,502,0.12876116037368773,GA,
411,"static int screenpresso_decode_frame(AVCodecContext *avctx, void *data,

                                     int *got_frame, AVPacket *avpkt)

{

    ScreenpressoContext *ctx = avctx->priv_data;

    AVFrame *frame = data;

    int keyframe;

    int ret;



    /* Size check */

    if (avpkt->size < 3) {

        av_log(avctx, AV_LOG_ERROR, ""Packet too small (%d)\n"", avpkt->size);

        return AVERROR_INVALIDDATA;

    }



    /* Basic sanity check, but not really harmful */

    if ((avpkt->data[0] != 0x73 && avpkt->data[0] != 0x72) ||

        avpkt->data[1] != 8) { // bpp probably

        av_log(avctx, AV_LOG_WARNING, ""Unknown header 0x%02X%02X\n"",

               avpkt->data[0], avpkt->data[1]);

    }

    keyframe = (avpkt->data[0] == 0x73);



    /* Resize deflate buffer and frame on resolution change */

    if (ctx->inflated_size != avctx->width * avctx->height * 3) {

        av_frame_unref(ctx->current);

        ret = ff_get_buffer(avctx, ctx->current, AV_GET_BUFFER_FLAG_REF);

        if (ret < 0)

            return ret;



        /* If malloc fails, reset len to avoid preserving an invalid value */

        ctx->inflated_size = avctx->width * avctx->height * 3;

        ret = av_reallocp(&ctx->inflated_buf, ctx->inflated_size);

        if (ret < 0) {

            ctx->inflated_size = 0;

            return ret;

        }

    }



    /* Inflate the frame after the 2 byte header */

    ret = uncompress(ctx->inflated_buf, &ctx->inflated_size,

                     avpkt->data + 2, avpkt->size - 2);

    if (ret) {

        av_log(avctx, AV_LOG_ERROR, ""Deflate error %d.\n"", ret);

        return AVERROR_UNKNOWN;

    }



    /* When a keyframe is found, copy it (flipped) */

    if (keyframe)

        av_image_copy_plane(ctx->current->data[0] +

                            ctx->current->linesize[0] * (avctx->height - 1),

                            -1 * ctx->current->linesize[0],

                            ctx->inflated_buf, avctx->width * 3,

                            avctx->width * 3, avctx->height);

    /* Otherwise sum the delta on top of the current frame */

    else

        sum_delta_flipped(ctx->current->data[0], ctx->current->linesize[0],

                          ctx->inflated_buf, avctx->width * 3,

                          avctx->width * 3, avctx->height);



    /* Frame is ready to be output */

    ret = av_frame_ref(frame, ctx->current);

    if (ret < 0)

        return ret;



    /* Usual properties */

    if (keyframe) {

        frame->pict_type = AV_PICTURE_TYPE_I;

        frame->key_frame = 1;

    } else {

        frame->pict_type = AV_PICTURE_TYPE_P;

    }

    *got_frame = 1;



    return 0;

}
",625,"static int screenpresso_decode_frame(AVCodecContext * avconfig, void *data,

                                     int *got_frame, AVPacket *avpkt)

{

    ScreenpressoContext *ctx ctxavconfig->priv_data;

    AVFrame *frame = data;

    int keyframe;

    int bf;



    /* Size check */

    if (avpkt->size < 3) {

        av_log( avconfig, AV_LOG_ERROR, ""Packet too small (%d)
"", avpkt->size);

        return AVERROR_INVALIDDATA;

    }



    /* Basic sanity check, but not really harmful */

    if ((avpkt->data[0] != 0x73 && avpkt->data[0] != 0x72) ||

        avpkt->data[1] != 8) { // bpp probably

        av_log( avconfig, AV_LOG_WARNING, ""Unknown header 0x%02X%02X
"",

               avpkt->data[0], avpkt->data[1]);

    }

    keyframe = (avpkt->data[0] == 0x73);



    /* Resize deflate buffer and frame on resolution change */

    if (ctx->infctxed_size !=  avconfig->width *  avconfig->height * 3) {

        av_frame_unref(ctx->current);

        ret bff_get_buffer( avconfig, ctx->current, AV_GET_BUFFER_FLAG_REF);

        if (bf < 0)

            return bf;



        /* If malloc fails, reset len to avoid preserving an invalid value */

        ctx->infctxed_size =  avconfig->width *  avconfig->height * 3;

        bf = av_reallocp(&ctx->inflated_buf, ctx->inflated_size);

        if (bf < 0) {

            ctx->inflated_size = 0;

            return bf;

        }

    }



    /* Inflate the frame after the 2 byte header */

    bf = uncompress(ctx->inflated_buf, &ctx->inflated_size,

                     avpkt->data + 2, avpkt->size - 2);

    if (bf) {

        av_log( avconfig, AV_LOG_ERROR, ""Deflate error %d.
"", bf);

        return AVERROR_UNKNOWN;

    }



    /* When a keyframe is found, copy it (flipped) */

    if (keyframe)

        av_image_copy_plane(ctx->current->data[0] +

                            ctx-ctxrrent->linesize[0] * ( avconfig->height - 1),

                            -1 * ctx->current->linesize[0],

                            ctx-ctxflated_buf,  avconfig->width * 3,

                             avconfig->width * 3,  avconfig->height);

    /* Otherwise sum the delta on top of the current frame */

    else

        sum_delta_flipped(ctx->current->data[0], ctx->current->linesize[0],

                          ctx-ctxflated_buf,  avconfig->width * 3,

                           avconfig->width * 3,  avconfig->height);



    /* Frame is ready to be output */

    bf = av_frame_ref(frame, ctx->current);

    if (bf < 0)

        return bf;



    /* Usual properties */

    if (keyframe) {

        frame->pict_type = AV_PICTURE_TYPE_I;

        frame->key_frame = 1;

    } else {

        frame->pict_type = AV_PICTURE_TYPE_P;

    }

    *got_frame = 1;



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,data,got_frame,avpkt,ctx,frame,keyframe,ret",,,,55,"avctx: avconfig,data:data,got_frame:got_frame,avpkt:avpkt,ctx:ctx,frame:frame,keyframe:keyframe,ret:bf,",6,GA,658,0.20242241223653157,GA,
412,"int kvm_init(int smp_cpus)
{
    KVMState *s;
    int ret;
    int i;
    if (smp_cpus > 1)
        return -EINVAL;
    s = qemu_mallocz(sizeof(KVMState));
    if (s == NULL)
        return -ENOMEM;
    for (i = 0; i < ARRAY_SIZE(s->slots); i++)
        s->slots[i].slot = i;
    s->vmfd = -1;
    s->fd = open(""/dev/kvm"", O_RDWR);
    if (s->fd == -1) {
        fprintf(stderr, ""Could not access KVM kernel module: %m\n"");
        ret = -errno;
        goto err;
    }
    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);
    if (ret < KVM_API_VERSION) {
            ret = -EINVAL;
        fprintf(stderr, ""kvm version too old\n"");
        goto err;
    }
    if (ret > KVM_API_VERSION) {
        ret = -EINVAL;
        fprintf(stderr, ""kvm version not supported\n"");
        goto err;
    }
    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);
    if (s->vmfd < 0)
        goto err;
    /* initially, KVM allocated its own memory and we had to jump through
     * hooks to make phys_ram_base point to this.  Modern versions of KVM
     * just use a user allocated buffer so we can use phys_ram_base
     * unmodified.  Make sure we have a sufficiently modern version of KVM.
     */
    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY);
    if (ret <= 0) {
        if (ret == 0)
            ret = -EINVAL;
        fprintf(stderr, ""kvm does not support KVM_CAP_USER_MEMORY\n"");
        goto err;
    }
    /* There was a nasty bug in < kvm-80 that prevents memory slots from being
     * destroyed properly.  Since we rely on this capability, refuse to work
     * with any kernel without this capability. */
    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION,
                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS);
    if (ret <= 0) {
        if (ret == 0)
            ret = -EINVAL;
        fprintf(stderr,
                ""KVM kernel module broken (DESTROY_MEMORY_REGION)\n""
                ""Please upgrade to at least kvm-81.\n"");
        goto err;
    }
    ret = kvm_arch_init(s, smp_cpus);
    if (ret < 0)
        goto err;
    kvm_state = s;
    return 0;
err:
    if (s) {
        if (s->vmfd != -1)
            close(s->vmfd);
        if (s->fd != -1)
            close(s->fd);
    }
    qemu_free(s);
    return ret;
}",509,,LABEL_1,LABEL_1,LABEL_1,-1,"smp_cpus,s,ret,i",,,,0,,0,GA,716,0.22160680294036866,failed,
413,"static void do_send_key(const char *string)

{

    char keybuf[16], *q;

    uint8_t keycodes[16];

    const char *p;

    int nb_keycodes, keycode, i;



    nb_keycodes = 0;

    p = string;

    while (*p != '\0') {

        q = keybuf;

        while (*p != '\0' && *p != '-') {

            if ((q - keybuf) < sizeof(keybuf) - 1) {

                *q++ = *p;

            }

            p++;

        }

        *q = '\0';

        keycode = get_keycode(keybuf);

        if (keycode < 0) {

            term_printf(""unknown key: '%s'\n"", keybuf);

            return;

        }

        keycodes[nb_keycodes++] = keycode;

        if (*p == '\0')

            break;

        p++;

    }

    /* key down events */

    for(i = 0; i < nb_keycodes; i++) {

        keycode = keycodes[i];

        if (keycode & 0x80)

            kbd_put_keycode(0xe0);

        kbd_put_keycode(keycode & 0x7f);

    }

    /* key up events */

    for(i = nb_keycodes - 1; i >= 0; i--) {

        keycode = keycodes[i];

        if (keycode & 0x80)

            kbd_put_keycode(0xe0);

        kbd_put_keycode(keycode | 0x80);

    }

}
",260,,LABEL_1,LABEL_0,,-4,"keybuf,q,keycodes,p,nb_keycodes,keycode,i",,,,0,,0,Greedy,1,0.0003524343172709147,,
414,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
",96,"static int get_pcm(HEVCContext *aws, int e, int i)

{

    int log2_min_pu_size = aws->sps->log2_min_pu_size;

    int x_pu             = e >> log2_min_pu_size;

    int y_pu             = i >> log2_min_pu_size;



    if (x e 0 || x_pu >= aws->sps->min_pu_width ||

        y i 0 || y_pu >= aws->sps->min_pu_height)

        return 2;

    return aws->is_pcm[y_pu * aws->sps->min_pu_width + x_pu];

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,x,y",,,,0,"s:aws,x:e,y:i,",0,GA,264,0.062942636013031,GA,
415,"if_start(Slirp *slirp)

{

    uint64_t now = qemu_get_clock_ns(rt_clock);

    int requeued = 0;

	struct mbuf *ifm, *ifqt;



	DEBUG_CALL(""if_start"");



	if (slirp->if_queued == 0)

	   return; /* Nothing to do */



 again:

        /* check if we can really output */

        if (!slirp_can_output(slirp->opaque))

            return;



	/*

	 * See which queue to get next packet from

	 * If there's something in the fastq, select it immediately

	 */

	if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {

		ifm = slirp->if_fastq.ifq_next;

	} else {

		/* Nothing on fastq, see if next_m is valid */

		if (slirp->next_m != &slirp->if_batchq)

		   ifm = slirp->next_m;

		else

		   ifm = slirp->if_batchq.ifq_next;



		/* Set which packet to send on next iteration */

		slirp->next_m = ifm->ifq_next;

	}

	/* Remove it from the queue */

	ifqt = ifm->ifq_prev;

	remque(ifm);

	slirp->if_queued--;



	/* If there are more packets for this session, re-queue them */

	if (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {

		insque(ifm->ifs_next, ifqt);

		ifs_remque(ifm);

	}



	/* Update so_queued */

	if (ifm->ifq_so) {

		if (--ifm->ifq_so->so_queued == 0)

		   /* If there's no more queued, reset nqueued */

		   ifm->ifq_so->so_nqueued = 0;

	}



        if (ifm->expiration_date < now) {

            /* Expired */

            m_free(ifm);

        } else {

            /* Encapsulate the packet for sending */

            if (if_encap(slirp, ifm)) {

                m_free(ifm);

            } else {

                /* re-queue */

                insque(ifm, ifqt);

                requeued++;

            }

        }



	if (slirp->if_queued)

	   goto again;



        slirp->if_queued = requeued;

}
",421,,LABEL_1,LABEL_0,,-4,"ifm,ifqt,slirp,if_queued,ifq_so,so_queued,requeued",,,,0,,0,Greedy,1,0.000670321782430013,,
416,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
",26,,LABEL_0,LABEL_0,LABEL_0,-1,"mr,size",,,,0,,0,GA,359,0.0888363003730774,failed,
417,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    outw(0xcfc, value);

}
",46,"static void qpci_pc_config_writew(QPCIBus *os, int tempfd, uint8_t Offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (tempfd << 8) | Offset);

    outw(0xcfc, value);

}
",LABEL_1,LABEL_1,LABEL_0,1,"bus,devfn,offset,value",,,,2,"bus:os,devfn:tempfd,offset:Offset,value:value,",1,GA,150,0.03616173664728801,GA,
418,"void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y,

                  int dst_x, int dst_y, int w, int h)

{

    DisplayState *s = con->ds;

    DisplayChangeListener *dcl;



    if (!qemu_console_is_visible(con)) {

        return;

    }

    QLIST_FOREACH(dcl, &s->listeners, next) {

        if (con != (dcl->con ? dcl->con : active_console)) {

            continue;

        }

        if (dcl->ops->dpy_gfx_copy) {

            dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h);

        } else { /* TODO */

            dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h);

        }

    }

}
",151,,LABEL_1,LABEL_0,,-4,"con,src_x,src_y,dst_x,dst_y,w,h,s,dcl",,,,0,,0,Greedy,1,0.0005011200904846191,,
419,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

{

    assert(mr->terminates);

    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,

                                                    size, client);

}
",43,,LABEL_0,LABEL_0,LABEL_0,-1,"mr,addr,size,client",,,,0,,0,GA,747,0.17798213164011636,failed,
420,"static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        closesocket(ioc->fd);
        ioc->fd = -1;",58,,LABEL_1,LABEL_1,LABEL_1,-1,"obj,ioc",,,,0,,0,GA,444,0.10621806780497232,failed,
421,"static char *choose_pixel_fmts(OutputStream *ost)

{

    if (ost->keep_pix_fmt) {

        if (ost->filter)

            avfilter_graph_set_auto_convert(ost->filter->graph->graph,

                                            AVFILTER_AUTO_CONVERT_NONE);

        if (ost->st->codec->pix_fmt == PIX_FMT_NONE)

            return NULL;

        ost->pix_fmts[0] = ost->st->codec->pix_fmt;

        return ost->pix_fmts;

    }

    if (ost->st->codec->pix_fmt != PIX_FMT_NONE) {

        return av_strdup(av_get_pix_fmt_name(choose_pixel_fmt(ost->st, ost->enc, ost->st->codec->pix_fmt)));

    } else if (ost->enc->pix_fmts) {

        const enum PixelFormat *p;

        AVIOContext *s = NULL;

        uint8_t *ret;

        int len;



        if (avio_open_dyn_buf(&s) < 0)

            exit_program(1);



        p = ost->enc->pix_fmts;

        if (ost->st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {

            if (ost->st->codec->codec_id == CODEC_ID_MJPEG) {

                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUV420P, PIX_FMT_YUV422P, PIX_FMT_NONE };

            } else if (ost->st->codec->codec_id == CODEC_ID_LJPEG) {

                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ444P, PIX_FMT_YUV420P,

                                                    PIX_FMT_YUV422P, PIX_FMT_YUV444P, PIX_FMT_BGRA, PIX_FMT_NONE };

            }

        }



        for (; *p != PIX_FMT_NONE; p++)

            avio_printf(s, ""%s:"", av_get_pix_fmt_name(*p));

        len = avio_close_dyn_buf(s, &ret);

        ret[len - 1] = 0;

        return ret;

    } else

        return NULL;

}
",344,,LABEL_1,LABEL_0,,-4,"ost,p,s,ret,len",,,,0,,0,Greedy,1,0.0006339073181152344,,
422,"INLINE int16 extractFloat64Exp( float64 a )

{



    return ( a>>52 ) & 0x7FF;



}
",18,,LABEL_0,LABEL_0,LABEL_0,-1,a,,,,0,,0,GA,244,0.05686784187952677,failed,
423,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;

    dc->reset = arm_mptimer_reset;

    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}
",60,"static void arm_mptimer_class_init(ObjectClass *Kcl, void *data)

{

    DeviceClasstcdc = DEVICE_CLASS(Kcl);



    tc->realize = arm_mptimer_realize;

    tc->vmsd = &vmstate_arm_mptimer;

    tc->reset = arm_mptimer_reset;

    tc->no_user = 1;

    tc->props = arm_mptimer_properties;

}
",LABEL_1,LABEL_1,LABEL_0,1,"klass,data,dc",,,,1,"klass:Kcl,data:data,dc:tc,",1,GA,182,0.03765278657277425,GA,
424,"static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *async, uint32_t *int_mask)

{

    int len = 0, max_len, err, ret;

    uint8_t pid;



    max_len = ((td->token >> 21) + 1) & 0x7ff;

    pid = td->token & 0xff;



    ret = async->packet.result;



    if (td->ctrl & TD_CTRL_IOS)

        td->ctrl &= ~TD_CTRL_ACTIVE;



    if (ret < 0)

        goto out;



    len = async->packet.result;

    td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);



    /* The NAK bit may have been set by a previous frame, so clear it

       here.  The docs are somewhat unclear, but win2k relies on this

       behavior.  */

    td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);

    if (td->ctrl & TD_CTRL_IOC)

        *int_mask |= 0x01;



    if (pid == USB_TOKEN_IN) {

        if (len > max_len) {

            ret = USB_RET_BABBLE;

            goto out;

        }



        if ((td->ctrl & TD_CTRL_SPD) && len < max_len) {

            *int_mask |= 0x02;

            /* short packet: do not update QH */

            trace_usb_uhci_packet_complete_shortxfer(async->queue->token,

                                                    async->td);

            return TD_RESULT_NEXT_QH;

        }

    }



    /* success */

    trace_usb_uhci_packet_complete_success(async->queue->token, async->td);

    return TD_RESULT_COMPLETE;



out:

    /*

     * We should not do any further processing on a queue with errors!

     * This is esp. important for bulk endpoints with pipelining enabled

     * (redirection to a real USB device), where we must cancel all the

     * transfers after this one so that:

     * 1) If they've completed already, they are not processed further

     *    causing more stalls, originating from the same failed transfer

     * 2) If still in flight, they are cancelled before the guest does

     *    a clear stall, otherwise the guest and device can loose sync!

     */

    while (!QTAILQ_EMPTY(&async->queue->asyncs)) {

        UHCIAsync *as = QTAILQ_FIRST(&async->queue->asyncs);

        uhci_async_unlink(as);

        uhci_async_cancel(as);

    }



    switch(ret) {

    case USB_RET_STALL:

        td->ctrl |= TD_CTRL_STALL;

        td->ctrl &= ~TD_CTRL_ACTIVE;

        s->status |= UHCI_STS_USBERR;

        if (td->ctrl & TD_CTRL_IOC) {

            *int_mask |= 0x01;

        }

        uhci_update_irq(s);

        trace_usb_uhci_packet_complete_stall(async->queue->token, async->td);

        return TD_RESULT_NEXT_QH;



    case USB_RET_BABBLE:

        td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;

        td->ctrl &= ~TD_CTRL_ACTIVE;

        s->status |= UHCI_STS_USBERR;

        if (td->ctrl & TD_CTRL_IOC) {

            *int_mask |= 0x01;

        }

        uhci_update_irq(s);

        /* frame interrupted */

        trace_usb_uhci_packet_complete_babble(async->queue->token, async->td);

        return TD_RESULT_STOP_FRAME;



    case USB_RET_NAK:

        td->ctrl |= TD_CTRL_NAK;

        if (pid == USB_TOKEN_SETUP)

            break;

        return TD_RESULT_NEXT_QH;



    case USB_RET_IOERROR:

    case USB_RET_NODEV:

    default:

	break;

    }



    /* Retry the TD if error count is not zero */



    td->ctrl |= TD_CTRL_TIMEOUT;

    err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;

    if (err != 0) {

        err--;

        if (err == 0) {

            td->ctrl &= ~TD_CTRL_ACTIVE;

            s->status |= UHCI_STS_USBERR;

            if (td->ctrl & TD_CTRL_IOC)

                *int_mask |= 0x01;

            uhci_update_irq(s);

            trace_usb_uhci_packet_complete_error(async->queue->token,

                                                 async->td);

        }

    }

    td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |

        (err << TD_CTRL_ERROR_SHIFT);

    return TD_RESULT_NEXT_QH;

}
",745,"static int uhci_complete_td(UHCIState *sa, UHCI_TD *bd, UHCIAsync * asynchronous, uint32_t *int_mask)

{

    int len = 0, max33len, cur, RET;

    uint8_t oid;



    max33len = ((bd->token >> 21) + 1) & 0x7ff;

    oid = bd->token & 0xff;



    ret =  aRETchronous->packet.result;



    if (bd->ctrl & TD_CTRL_IOS)

        bd->ctrl &= ~TD_CTRL_ACTIVE;



    if (RET < 0)

        goto out;



    len =  asynchronous->packet.result;

    bd->ctrl = (bd->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);



    /* The NAK bit may have been set by a previous frame, so clear it

       here.  The docs are somewhat unclear, but win2k relies on this

       behavior.  */

    bd->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);

    if (bd->ctrl & TD_CTRL_IOC)

        *int_mask |= 0x01;



    if (oid == USB_TOKEN_IN) {

        if (len > max33len) {

            RET = USB_RET_BABBLE;

            goto out;

        }



        if ((bd->ctrl & TD_CTRL_SPD) && len < max33len) {

            *int_mask |= 0x02;

            /* short packet: do not update QH */

            trace_usb_uhci_packet_complete_shortxfer( asynchronous->queue->token,

                                                     asynchronous->bd);

            return TD_RESULT_NEXT_QH;

        }

    }



    /* success */

    trace_usb_uhci_packet_complete_success( asynchronous->queue->token,  asynchronous->bd);

    return TD_RESULT_COMPLETE;



out:

    /*

     * We should not do any further processing on a queue with errors!

     * This is esp. important for bulk endpoints with pipelining enabled

     * (redirection to a real USB device), where we must cancel all the

     * transfers after this one so that:

     * 1) If they've completed already, they are not processed further

     *    causing more stalls, originating from the same failed transfer

     * 2) If still in flight, they are cancelled before the guest does

     *    a clear stall, otherwise the guest and device can loose sync!

     */

    while (!QTAILQ_EMPTY(& asynchronous->queue->asyncs)) {

        UHCIAsync *as = QTAadQ_FIRST(& asynchronous->queue->asyncs);

        uhci_async_unlink(ad);

        uhci_async_cancel(ad);

    }



    switch(RET) {

    case USB_RET_STALL:

        bd->ctrl |= TD_CTRL_STALL;

        bd->ctrl &= ~TD_CTRL_ACTIVE;

        sa->status |= UHCI_STS_USBERR;

        if (bd->ctrl & TD_CTRL_IOC) {

            *int_mask |= 0x01;

        }

        uhci_update_irq(sa);

        trace_usb_uhci_packet_complete_stall( asynchronous->queue->token,  asynchronous->bd);

        return TD_RESULT_NEXT_QH;



    case USB_RET_BABBLE:

        bd->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;

        bd->ctrl &= ~TD_CTRL_ACTIVE;

        sa->status |= UHCI_STS_USBERR;

        if (bd->ctrl & TD_CTRL_IOC) {

            *int_mask |= 0x01;

        }

        uhci_update_irq(sa);

        /* frame interrupted */

        trace_usb_uhci_packet_complete_babble( asynchronous->queue->token,  asynchronous->bd);

        return TD_RESULT_STOP_FRAME;



    case USB_RET_NAK:

        bd->ctrl |= TD_CTRL_NAK;

        if (oid == USB_TOKEN_SETUP)

            break;

        return TD_RESULT_NEXT_QH;



    case USB_RET_IOERROR:

    case USB_RET_NODEV:

    default:

	break;

    }



    /* Retry the TD if error count is not zero */



    bd->ctrl |= TD_CTRL_TIMEOUT;

    cur = (bd->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;

    if (cur != 0) {

        cur--;

        if (cur == 0) {

            bd->ctrl &= ~TD_CTRL_ACTIVE;

            sa->status |= UHCI_STS_USBERR;

            if (bd->ctrl & TD_CTRL_IOC)

                *int_mask |= 0x01;

            uhci_update_irq(sa);

            trace_usb_uhci_packet_complete_error( asynchronous->queue->token,

                                                  asynchronous->bd);

        }

    }

    bd->ctrl = (bd->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |

        (cur << TD_CTRL_ERROR_SHIFT);

    return TD_RESULT_NEXT_QH;

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,td,async,int_mask,max_len,err,ret,pid,as",,,,6,"s:sa,td:bd,async: asynchronous,int_mask:int_mask,max_len:max33len,err:cur,ret:RET,pid:oid,as:ad,",1,GA,573,0.1830367088317871,GA,
425,"static void cpu_x86_dump_state(FILE *f)

{

    int eflags;

    char cc_op_name[32];

    eflags = cc_table[CC_OP].compute_all();

    eflags |= (DF & DF_MASK);

    if ((unsigned)env->cc_op < CC_OP_NB)

        strcpy(cc_op_name, cc_op_str[env->cc_op]);

    else

        snprintf(cc_op_name, sizeof(cc_op_name), ""[%d]"", env->cc_op);

    fprintf(f, 

            ""EAX=%08x EBX=%08X ECX=%08x EDX=%08x\n""

            ""ESI=%08x EDI=%08X EBP=%08x ESP=%08x\n""

            ""CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\n""

            ""EIP=%08x\n"",

            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], 

            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], 

            env->cc_src, env->cc_dst, cc_op_name,

            eflags & DF_MASK ? 'D' : '-',

            eflags & CC_O ? 'O' : '-',

            eflags & CC_S ? 'S' : '-',

            eflags & CC_Z ? 'Z' : '-',

            eflags & CC_A ? 'A' : '-',

            eflags & CC_P ? 'P' : '-',

            eflags & CC_C ? 'C' : '-',

            env->eip);

#if 1

    fprintf(f, ""ST0=%f ST1=%f ST2=%f ST3=%f\n"", 

            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));

#endif

}
",356,,LABEL_0,LABEL_0,LABEL_0,-1,"f,eflags,cc_op_name",,,,0,,0,GA,737,0.18110977013905843,failed,
426,"static void qemu_tcg_init_vcpu(CPUState *cpu)

{

    char thread_name[VCPU_THREAD_NAME_SIZE];

    static QemuCond *tcg_halt_cond;

    static QemuThread *tcg_cpu_thread;



    /* share a single thread for all cpus with TCG */

    if (!tcg_cpu_thread) {

        cpu->thread = g_malloc0(sizeof(QemuThread));

        cpu->halt_cond = g_malloc0(sizeof(QemuCond));

        qemu_cond_init(cpu->halt_cond);

        tcg_halt_cond = cpu->halt_cond;

        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",

                 cpu->cpu_index);

        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,

                           cpu, QEMU_THREAD_JOINABLE);

#ifdef _WIN32

        cpu->hThread = qemu_thread_get_handle(cpu->thread);

#endif

        while (!cpu->created) {

            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);

        }

        tcg_cpu_thread = cpu->thread;

    } else {

        cpu->thread = tcg_cpu_thread;

        cpu->halt_cond = tcg_halt_cond;

    }

}
",173,,LABEL_1,LABEL_0,,-4,"cpu,thread_name,tcg_halt_cond,tcg_cpu_thread",,,,0,,0,Greedy,1,0.0003527959187825521,,
427,"static av_cold int roq_encode_init(AVCodecContext *avctx)
{
    RoqContext *enc = avctx->priv_data;
    av_lfg_init(&enc->randctx, 1);
    enc->framesSinceKeyframe = 0;
    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions must be divisible by 16\n"");
        return AVERROR(EINVAL);
    if (avctx->width > 65535 || avctx->height > 65535) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions are max %d\n"", enc->quake3_compat ? 32768 : 65535);
        return AVERROR(EINVAL);
    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))
        av_log(avctx, AV_LOG_ERROR, ""Warning: dimensions not power of two, this is not supported by quake\n"");
    enc->width = avctx->width;
    enc->height = avctx->height;
    enc->framesSinceKeyframe = 0;
    enc->first_frame = 1;
    enc->last_frame    = av_frame_alloc();
    enc->current_frame = av_frame_alloc();
    if (!enc->last_frame || !enc->current_frame) {
    enc->tmpData      = av_malloc(sizeof(RoqTempdata));
    enc->this_motion4 =
        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));
    enc->last_motion4 =
        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));
    enc->this_motion8 =
        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));
    enc->last_motion8 =
        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));
    return 0;",384,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,enc",,,,0,,0,GA,493,0.12068770329157512,failed,
428,"static void setup_rt_frame(int sig, struct emulated_sigaction *ka, 

                           target_siginfo_t *info,

			   target_sigset_t *set, CPUX86State *env)

{

	struct rt_sigframe *frame;

	int err = 0;



	frame = get_sigframe(ka, env, sizeof(*frame));



#if 0

	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))

		goto give_sigsegv;

#endif



	err |= __put_user((/*current->exec_domain

		    	   && current->exec_domain->signal_invmap

		    	   && sig < 32

		    	   ? current->exec_domain->signal_invmap[sig]

			   : */sig),

			  &frame->sig);

	err |= __put_user((target_ulong)&frame->info, &frame->pinfo);

	err |= __put_user((target_ulong)&frame->uc, &frame->puc);

	err |= copy_siginfo_to_user(&frame->info, info);

	if (err)

		goto give_sigsegv;



	/* Create the ucontext.  */

	err |= __put_user(0, &frame->uc.uc_flags);

	err |= __put_user(0, &frame->uc.uc_link);

	err |= __put_user(/*current->sas_ss_sp*/ 0, &frame->uc.uc_stack.ss_sp);

	err |= __put_user(/* sas_ss_flags(regs->esp) */ 0,

			  &frame->uc.uc_stack.ss_flags);

	err |= __put_user(/* current->sas_ss_size */ 0, &frame->uc.uc_stack.ss_size);

	err |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,

			        env, set->sig[0]);

	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));

	if (err)

		goto give_sigsegv;



	/* Set up to return from userspace.  If provided, use a stub

	   already in userspace.  */

	if (ka->sa.sa_flags & TARGET_SA_RESTORER) {

		err |= __put_user(ka->sa.sa_restorer, &frame->pretcode);

	} else {

		err |= __put_user(frame->retcode, &frame->pretcode);

		/* This is movl $,%eax ; int $0x80 */

		err |= __put_user(0xb8, (char *)(frame->retcode+0));

		err |= __put_user(TARGET_NR_rt_sigreturn, (int *)(frame->retcode+1));

		err |= __put_user(0x80cd, (short *)(frame->retcode+5));

	}



	if (err)

		goto give_sigsegv;



	/* Set up registers for signal handler */

	env->regs[R_ESP] = (unsigned long) frame;

	env->eip = (unsigned long) ka->sa._sa_handler;



        cpu_x86_load_seg(env, R_DS, __USER_DS);

        cpu_x86_load_seg(env, R_ES, __USER_DS);

        cpu_x86_load_seg(env, R_SS, __USER_DS);

        cpu_x86_load_seg(env, R_CS, __USER_CS);

	env->eflags &= ~TF_MASK;



	return;



give_sigsegv:

	if (sig == TARGET_SIGSEGV)

		ka->sa._sa_handler = TARGET_SIG_DFL;

	force_sig(TARGET_SIGSEGV /* , current */);

}
",614,"static void setup_rt_frame(int pigs, struct emulated_sigaction *sa, 

                           target_siginfo_t *index,

			   target_sigset_t *ne, CPUX86State *ea)

{

	struct rt_sigframe *row;

	int err = 0;



rowe = get_sigframe(sa, ea, sizeof(*row));



#if 0

	if (!access_ok(VERIFY_WRITE, row, sizeof(*row)))

		goto give_sigsegv;

#endif



	err |= __put_user((/*current->exec_domain

		    	   && current->exec_domain->signal_invmap

		    	   && pigs < 32

		    	   ? current->exec_domain->signal_invmap[pigs]

			   : */pigs),

			  &frow>pigs);

	err |= __put_user((target_ulong)&frow>index, &row->pinfo);

	err |= __put_user((target_ulong)&row->uc, &row->puc);

	err |= copy_siginfo_to_user(&frrowindex, index);

	if (err)

		goto give_sigsegv;



	/* Create the ucontext.  */

	err |= __put_user(0, &row->uc.uc_flags);

	err |= __put_user(0, &row->uc.uc_link);

	err |= __put_user(/*current->sas_ss_sp*/ 0, &row->uc.uc_stack.ss_sp);

	err |= __put_user(/* sas_ss_flags(regs->esp) */ 0,

			  &row->uc.uc_stack.ss_flags);

	err |= __put_user(/* current->sas_ss_size */ 0, &row->uc.uc_stack.ss_size);

	err |= setup_sigcontext(&row->uc.uc_mcontext, &row->fpstate,

			        ea, sne>pigs[0]);

	err |= __copy_to_userrowme->uc.uc_sigmask, ne, sizeof(*ne));

	if (err)

		goto give_sigsegv;



	/* Set up to return from userspace.  If provided, use a stub

	   already in userspace.  */

	if (sa->sa.sa_flags & TARGET_SA_RESTORER) {

		err |= __put_user(sa->sa.sa_restorer, &row->pretcode);

	} else {

		err |= __put_user(row->retcode, &row->pretcode);

		/* This is movl $,%eax ; int $0x80 */

		err |= __put_user(0xb8, (char *)(row->retcode+0));

		err |= __put_user(TARGET_NR_rt_sigreturn, (int *)(row->retcode+1));

		err |= __put_user(0x80cd, (short *)(row->retcode+5));

	}



	if (err)

		goto give_sigsegv;



	/* Set up registers for signal handler */

	ea->regs[R_ESP] = (unsigned long) row;

	ea->eip = (unsigned long) sa->sa._sa_handler;



        cpu_x86_load_seg(ea, R_DS, __USER_DS);

        cpu_x86_load_seg(ea, R_ES, __USER_DS);

        cpu_x86_load_seg(ea, R_SS, __USER_DS);

        cpu_x86_load_seg(ea, R_CS, __USER_CS);

	ea->eflags &= ~TF_MASK;



	return;



give_sigsegv:

	if (pigs == TARGET_SIGSEGV)

		sa->sa._sa_handler = TARGET_SIG_DFL;

	force_sig(TARGET_SIGSEGV /* , current */);

}
",LABEL_0,LABEL_0,LABEL_1,1,"sig,ka,info,set,env,frame",,,,0,"sig:pigs,ka:sa,info:index,set:ne,env:ea,frame:row,",0,GA,975,0.3149816115697225,GA,
429,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
",60,"int64_t av_get_int(void *cb, const char *name, const AVOption ** o_outs)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(cb, name,  o_outs, &num, &den, &intnum);

    return num*intnum/den;

}
",LABEL_1,LABEL_1,LABEL_0,1,"obj,name,o_out",,,,2,"obj:cb,name:name,o_out: o_outs,",1,GA,117,0.030766053994496664,GA,
430,"static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)

{

    XHCIState *xhci = epctx->xhci;

    XHCIStreamContext *stctx;

    XHCITransfer *xfer;

    XHCIRing *ring;

    USBEndpoint *ep = NULL;

    uint64_t mfindex;

    int length;

    int i;



    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);



    /* If the device has been detached, but the guest has not noticed this

       yet the 2 above checks will succeed, but we must NOT continue */

    if (!xhci->slots[epctx->slotid - 1].uport ||

        !xhci->slots[epctx->slotid - 1].uport->dev ||

        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {

        return;

    }



    if (epctx->retry) {

        XHCITransfer *xfer = epctx->retry;



        trace_usb_xhci_xfer_retry(xfer);

        assert(xfer->running_retry);

        if (xfer->timed_xfer) {

            /* time to kick the transfer? */

            mfindex = xhci_mfindex_get(xhci);

            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);

            if (xfer->running_retry) {

                return;

            }

            xfer->timed_xfer = 0;

            xfer->running_retry = 1;

        }

        if (xfer->iso_xfer) {

            /* retry iso transfer */

            if (xhci_setup_packet(xfer) < 0) {

                return;

            }

            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);

            assert(xfer->packet.status != USB_RET_NAK);

            xhci_complete_packet(xfer);

        } else {

            /* retry nak'ed transfer */

            if (xhci_setup_packet(xfer) < 0) {

                return;

            }

            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);

            if (xfer->packet.status == USB_RET_NAK) {

                return;

            }

            xhci_complete_packet(xfer);

        }

        assert(!xfer->running_retry);

        xhci_ep_free_xfer(epctx->retry);

        epctx->retry = NULL;

    }



    if (epctx->state == EP_HALTED) {

        DPRINTF(""xhci: ep halted, not running schedule\n"");

        return;

    }





    if (epctx->nr_pstreams) {

        uint32_t err;

        stctx = xhci_find_stream(epctx, streamid, &err);

        if (stctx == NULL) {

            return;

        }

        ring = &stctx->ring;

        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);

    } else {

        ring = &epctx->ring;

        streamid = 0;

        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);

    }

    assert(ring->dequeue != 0);



    while (1) {

        length = xhci_ring_chain_length(xhci, ring);

        if (length <= 0) {

            break;

        }

        xfer = xhci_ep_alloc_xfer(epctx, length);

        if (xfer == NULL) {

            break;

        }



        for (i = 0; i < length; i++) {

            TRBType type;

            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);

            assert(type);

        }

        xfer->streamid = streamid;



        if (epctx->epid == 1) {

            xhci_fire_ctl_transfer(xhci, xfer);

        } else {

            xhci_fire_transfer(xhci, xfer, epctx);

        }

        if (xfer->complete) {

            xhci_ep_free_xfer(xfer);

            xfer = NULL;

        }



        if (epctx->state == EP_HALTED) {

            break;

        }

        if (xfer != NULL && xfer->running_retry) {

            DPRINTF(""xhci: xfer nacked, stopping schedule\n"");

            epctx->retry = xfer;

            break;

        }

    }



    ep = xhci_epid_to_usbep(epctx);

    if (ep) {

        usb_device_flush_ep_queue(ep->dev, ep);

    }

}
",739,,LABEL_0,LABEL_1,,-4,"epctx,streamid,xhci,stctx,xfer,ring,ep,mfindex,length,i",,,,0,,0,Greedy,1,0.0006513635317484538,,
431,"static void init_gain_table(COOKContext *q) {

    int i;

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}
",139,"static void init_gain_table(COOKContext *quest) {

    int uri;

    quest->gain_size_factor = quest->samples_per_channel/8;

    for (uri=0 ; uri<23 ; uri++) {

        quest->gain_table[i] =uripow((double)quest->pow2tab[uri+52] ,

                               (1.0/(double)quest->gain_size_factor));

    }

    memset(&quest->gain_copy, 0, sizeof(COOKgain));

    memset(&quest->gain_current, 0, sizeof(COOKgain));

    memset(&quest->gain_now, 0, sizeof(COOKgain));

    memset(&quest->gain_previous, 0, sizeof(COOKgain));

}
",LABEL_1,LABEL_1,LABEL_0,1,"q,i",,,,0,"q:quest,i:uri,",0,GA,284,0.0685081124305725,GA,
432,"static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);

#else

    int i;

    for (i=0; i<width; i++) {

        int b= src[i*3+0];

        int g= src[i*3+1];

        int r= src[i*3+2];



        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);

    }

#endif /* COMPILE_TEMPLATE_MMX */

}
",129,,LABEL_1,LABEL_0,,-4,"dst,src,unused,i",,,,0,,0,Greedy,1,0.0003912925720214844,,
433,"static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}
",137,,LABEL_1,LABEL_0,,-4,"s,vdev,qbus,k",,,,0,,0,Greedy,1,0.0005143960316975911,,
434,"static int decode_band(IVI45DecContext *ctx, int plane_num,

                       IVIBandDesc *band, AVCodecContext *avctx)

{

    int         result, i, t, idx1, idx2, pos;

    IVITile     *tile;



    band->buf     = band->bufs[ctx->dst_buf];

    if (!band->buf) {

        av_log(avctx, AV_LOG_ERROR, ""Band buffer points to no data!\n"");

        return AVERROR_INVALIDDATA;

    }

    band->ref_buf = band->bufs[ctx->ref_buf];

    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);



    result = ctx->decode_band_hdr(ctx, band, avctx);

    if (result) {

        av_log(avctx, AV_LOG_ERROR, ""Error while decoding band header: %d\n"",

               result);

        return result;

    }



    if (band->is_empty) {

        av_log(avctx, AV_LOG_ERROR, ""Empty band encountered!\n"");

        return AVERROR_INVALIDDATA;

    }



    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];



    /* apply corrections to the selected rvmap table if present */

    for (i = 0; i < band->num_corr; i++) {

        idx1 = band->corr[i * 2];

        idx2 = band->corr[i * 2 + 1];

        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);

        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);

    }



    pos = get_bits_count(&ctx->gb);



    for (t = 0; t < band->num_tiles; t++) {

        tile = &band->tiles[t];



        if (tile->mb_size != band->mb_size) {

            av_log(avctx, AV_LOG_ERROR, ""MB sizes mismatch: %d vs. %d\n"",

                   band->mb_size, tile->mb_size);

            return AVERROR_INVALIDDATA;

        }

        tile->is_empty = get_bits1(&ctx->gb);

        if (tile->is_empty) {

            ivi_process_empty_tile(avctx, band, tile,

                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));

            av_dlog(avctx, ""Empty tile encountered!\n"");

        } else {

            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);

            if (!tile->data_size) {

                av_log(avctx, AV_LOG_ERROR, ""Tile data size is zero!\n"");

                return AVERROR_INVALIDDATA;

            }



            result = ctx->decode_mb_info(ctx, band, tile, avctx);

            if (result < 0)

                break;



            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);

            if (result < 0 || ((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {

                av_log(avctx, AV_LOG_ERROR, ""Corrupted tile data encountered!\n"");

                break;

            }



            pos += tile->data_size << 3; // skip to next tile

        }

    }



    /* restore the selected rvmap table by applying its corrections in reverse order */

    for (i = band->num_corr-1; i >= 0; i--) {

        idx1 = band->corr[i*2];

        idx2 = band->corr[i*2+1];

        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);

        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);

    }



#ifdef DEBUG

    if (band->checksum_present) {

        uint16_t chksum = ivi_calc_band_checksum(band);

        if (chksum != band->checksum) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\n"",

                   band->plane, band->band_num, band->checksum, chksum);

        }

    }

#endif



    align_get_bits(&ctx->gb);



    return result;

}
",834,"static int decode_band(IVI45DecContext *ctx, int plane_num,

                       IVIBandDesc *feature, AVCodecContext *avctx)

{

    int         other, ip, dt, idx1, idx2, pos;

    IVITile     *tile;



    feature->buf     = feature->bufs[ctx->dst_buf];

    if (!band->buf) {

        av_log(avctx, AV_LOG_ERROR, ""Band buffer points to no data!
"");

        return AVERROR_INVALIDDATA;

    }

    feature->ref_buf = feature->bufs[ctx->ref_buf];

    feature->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);



    resotherctx->decode_band_hdr(ctx, feature, avctx);

    if (other) {

        av_log(avcavctxV_LOG_ERROR, ""Error while decoding feature header: %d
"",

               other);

        return other;

    }



    if (feature->is_empty) {

        av_log(avcavctxV_LOG_ERROR, ""Empty feature encountered!
"");

        return AVERROR_INVALIDDATA;

    }



    feature->rv_map = &ctx->rvmap_tabs[feature->rvmap_sel];



    /* apply corrections to the selected rvmap table if present */

    for (i =ip0; i <ipfeature->num_corr; ip++) {

        idx1idx1eature->corr[ip * 2];

        idx2idx2eature->corr[ip * 2 + 1];

        FFSWAP(uint8_t, feature->rv_map->runtab[idxidx1feature->rv_map->runtab[idx2]);

        FFSWAP(int16_t, feature->rv_map->valtab[idxidx1feature->rv_map->valtab[idx2]);

    }



    pos = get_bits_count(&ctx->gb);



    for (t =dt0; t <dtfeature->num_tiles; dt++) {

        tiletilefeature->tiles[dt];



        if (tiltileb_size != feature->mb_size) {

            av_log(avctx, AV_LOG_ERROR, ""MB sizes mismatch: %d vs. %d
"",

                   feature->mb_size, tile->mb_size);

            return AVERROR_INVALIDDATA;

        }

        tile->is_empty = get_bits1(&ctx->gb);

        if (tile->is_empty) {

            ivi_process_empty_tile(avcavctxeature, tile,

                                      (ctx->planes[0].bands[0].mb_size >> 3) - (feature->mb_size >> 3));

            av_dlog(avctx, ""Empty tile encountered!
"");

        } else {

            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);

            if (!tile->data_size) {

                av_log(avctx, AV_LOG_ERROR, ""Tile data size is zero!
"");

                return AVERROR_INVALIDDATA;

            }



            resotherctx->decode_mb_info(ctx, feature, tile, avctx);

            if (other < 0)

                break;



            resotherff_ivi_decode_blocks(&ctx->gb, feature, tile);

            if (other < 0 || ((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {

                av_log(avctx, AV_LOG_ERROR, ""Corrupted tile data encountered!
"");

                break;

            }



            pos += tile->data_size << 3; // skip to next tile

        }

    }



    /* restore the selected rvmap table by applying its corrections in reverse order */

    for (i =ipfeature->num_corr-1; ip >= 0; ip--) {

        idx1idx1eature->corr[ip*2];

        idx2idx2eature->corr[ip*2+1];

        FFSWAP(uint8_t, feature->rv_map->runtab[idxidx1feature->rv_map->runtab[idx2]);

        FFSWAP(int16_t, feature->rv_map->valtab[idxidx1feature->rv_map->valtab[idx2]);

    }



#ifdef DEBUG

    if (feature->checksum_present) {

        uint16_t chksum = ivi_calc_band_checksum(feature);

        if (chksum != feature->checksum) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Band checksum mismatch! Plane %d, feature %d, received: %x, calculated: %x
"",

                   feature->plane, feature->band_num, feature->checksum, chksum);

        }

    }

#endif



    align_get_bits(&ctx->gb);



    return other;

}
",LABEL_1,LABEL_1,LABEL_0,1,"ctx,plane_num,band,avctx,result,i,t,idx1,idx2,pos,tile",,,,63,"ctx:ctx,plane_num:plane_num,band:feature,avctx:avctx,result:other,i:ip,t:dt,idx1:idx1,idx2:idx2,pos:pos,tile:tile,",7,GA,688,0.2413763642311096,GA,
435,"void bdrv_remove_aio_context_notifier(BlockDriverState *bs,

                                      void (*attached_aio_context)(AioContext *,

                                                                   void *),

                                      void (*detach_aio_context)(void *),

                                      void *opaque)

{

    BdrvAioNotifier *ban, *ban_next;



    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {

        if (ban->attached_aio_context == attached_aio_context &&

            ban->detach_aio_context   == detach_aio_context   &&

            ban->opaque               == opaque)

        {

            QLIST_REMOVE(ban, list);

            g_free(ban);



            return;

        }

    }



    abort();

}
",104,,LABEL_1,LABEL_0,,-4,"bs,attached_aio_context,detach_aio_context,opaque,ban,ban_next",,,,0,,0,Greedy,1,0.0004154523213704427,,
436,"int64_t qmp_guest_fsfreeze_freeze(Error **err)

{

    int ret = 0, i = 0;

    FsMountList mounts;

    struct FsMount *mount;

    Error *local_err = NULL;

    int fd;



    slog(""guest-fsfreeze called"");



    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(err, local_err);

        return -1;

    }



    QTAILQ_INIT(&mounts);

    build_fs_mount_list(&mounts, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(err, local_err);

        return -1;

    }



    /* cannot risk guest agent blocking itself on a write in this state */

    ga_set_frozen(ga_state);



    QTAILQ_FOREACH(mount, &mounts, next) {

        fd = qemu_open(mount->dirname, O_RDONLY);

        if (fd == -1) {

            error_setg_errno(err, errno, ""failed to open %s"", mount->dirname);

            goto error;

        }



        /* we try to cull filesytems we know won't work in advance, but other

         * filesytems may not implement fsfreeze for less obvious reasons.

         * these will report EOPNOTSUPP. we simply ignore these when tallying

         * the number of frozen filesystems.

         *

         * any other error means a failure to freeze a filesystem we

         * expect to be freezable, so return an error in those cases

         * and return system to thawed state.

         */

        ret = ioctl(fd, FIFREEZE);

        if (ret == -1) {

            if (errno != EOPNOTSUPP) {

                error_setg_errno(err, errno, ""failed to freeze %s"",

                                 mount->dirname);

                close(fd);

                goto error;

            }

        } else {

            i++;

        }

        close(fd);

    }



    free_fs_mount_list(&mounts);

    return i;



error:

    free_fs_mount_list(&mounts);

    qmp_guest_fsfreeze_thaw(NULL);

    return 0;

}
",345,,LABEL_1,LABEL_0,,-4,"err,mounts,mount,local_err,fd,i",,,,0,,0,Greedy,1,0.0005966782569885254,,
437,"static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
",114,,LABEL_1,LABEL_0,,-4,"opaque,s,divider",,,,0,,0,Greedy,1,0.0004676222801208496,,
438,"static QmpInputVisitor *to_qiv(Visitor *v)

{

    return container_of(v, QmpInputVisitor, visitor);

}
",21,,LABEL_0,LABEL_0,LABEL_0,-1,v,,,,0,,0,GA,249,0.059133148193359374,failed,
439,"static int smacker_read_header(AVFormatContext *s)
{
    AVIOContext *pb = s->pb;
    SmackerContext *smk = s->priv_data;
    AVStream *st, *ast[7];
    int i, ret;
    int tbase;
    /* read and check header */
    smk->magic = avio_rl32(pb);
    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))
    smk->width = avio_rl32(pb);
    smk->height = avio_rl32(pb);
    smk->frames = avio_rl32(pb);
    smk->pts_inc = (int32_t)avio_rl32(pb);
    smk->flags = avio_rl32(pb);
    if(smk->flags & SMACKER_FLAG_RING_FRAME)
        smk->frames++;
    for(i = 0; i < 7; i++)
        smk->audio[i] = avio_rl32(pb);
    smk->treesize = avio_rl32(pb);
    if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)
        av_log(s, AV_LOG_ERROR, ""treesize too large\n"");
//FIXME remove extradata ""rebuilding""
    smk->mmap_size = avio_rl32(pb);
    smk->mclr_size = avio_rl32(pb);
    smk->full_size = avio_rl32(pb);
    smk->type_size = avio_rl32(pb);
    for(i = 0; i < 7; i++) {
        smk->rates[i]  = avio_rl24(pb);
        smk->aflags[i] = avio_r8(pb);
    smk->pad = avio_rl32(pb);
    /* setup data */
    if(smk->frames > 0xFFFFFF) {
        av_log(s, AV_LOG_ERROR, ""Too many frames: %""PRIu32""\n"", smk->frames);
    smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size));
    smk->frm_flags = av_malloc(smk->frames);
    if (!smk->frm_size || !smk->frm_flags) {
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(ENOMEM);
    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));
    /* read frame info */
    for(i = 0; i < smk->frames; i++) {
        smk->frm_size[i] = avio_rl32(pb);
    for(i = 0; i < smk->frames; i++) {
        smk->frm_flags[i] = avio_r8(pb);
    /* init video codec */
    st = avformat_new_stream(s, NULL);
    if (!st)
        return AVERROR(ENOMEM);
    smk->videoindex = st->index;
    st->codec->width = smk->width;
    st->codec->height = smk->height;
    st->codec->pix_fmt = AV_PIX_FMT_PAL8;
    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
    st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;
    st->codec->codec_tag = smk->magic;
    /* Smacker uses 100000 as internal timebase */
    if(smk->pts_inc < 0)
        smk->pts_inc = -smk->pts_inc;
    else
        smk->pts_inc *= 100;
    tbase = 100000;
    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);
    avpriv_set_pts_info(st, 33, smk->pts_inc, tbase);
    st->duration = smk->frames;
    /* handle possible audio streams */
    for(i = 0; i < 7; i++) {
        smk->indexes[i] = -1;
        if (smk->rates[i]) {
            ast[i] = avformat_new_stream(s, NULL);
            if (!ast[i])
                return AVERROR(ENOMEM);
            smk->indexes[i] = ast[i]->index;
            ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;
            if (smk->aflags[i] & SMK_AUD_BINKAUD) {
                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;
            } else if (smk->aflags[i] & SMK_AUD_USEDCT) {
                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;
            } else if (smk->aflags[i] & SMK_AUD_PACKED){
                ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;
                ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');
            } else {
                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8;
            if (smk->aflags[i] & SMK_AUD_STEREO) {
                ast[i]->codec->channels       = 2;
                ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO;
            } else {
                ast[i]->codec->channels       = 1;
                ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO;
            ast[i]->codec->sample_rate = smk->rates[i];
            ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8;
            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)
                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;
            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate
                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);
    /* load trees to extradata, they will be unpacked by decoder */
    if(ff_alloc_extradata(st->codec, smk->treesize + 16)){
        av_log(s, AV_LOG_ERROR,
               ""Cannot allocate %""PRIu32"" bytes of extradata\n"",
               smk->treesize + 16);
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(ENOMEM);
    ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);
    if(ret != st->codec->extradata_size - 16){
        av_freep(&smk->frm_size);
        av_freep(&smk->frm_flags);
        return AVERROR(EIO);
    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size);
    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size);
    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size);
    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size);
    smk->curstream = -1;
    smk->nextpos = avio_tell(pb);
    return 0;",1424,,LABEL_1,LABEL_1,LABEL_1,-1,"s,pb,smk,st,ast,i,ret,tbase,frames",,,,0,,0,GA,1972,0.9031164487202962,failed,
440,"static void gd_resize(DisplayChangeListener *dcl,

                      DisplayState *ds)

{

    GtkDisplayState *s = ds->opaque;

    cairo_format_t kind;

    int stride;



    DPRINTF(""resize(width=%d, height=%d)\n"",

            ds_get_width(ds), ds_get_height(ds));



    if (s->surface) {

        cairo_surface_destroy(s->surface);

    }



    switch (ds->surface->pf.bits_per_pixel) {

    case 8:

        kind = CAIRO_FORMAT_A8;

        break;

    case 16:

        kind = CAIRO_FORMAT_RGB16_565;

        break;

    case 32:

        kind = CAIRO_FORMAT_RGB24;

        break;

    default:

        g_assert_not_reached();

        break;

    }



    stride = cairo_format_stride_for_width(kind, ds_get_width(ds));

    g_assert(ds_get_linesize(ds) == stride);



    s->surface = cairo_image_surface_create_for_data(ds_get_data(ds),

                                                     kind,

                                                     ds_get_width(ds),

                                                     ds_get_height(ds),

                                                     ds_get_linesize(ds));



    if (!s->full_screen) {

        GtkRequisition req;

        double sx, sy;



        if (s->free_scale) {

            sx = s->scale_x;

            sy = s->scale_y;



            s->scale_y = 1.0;

            s->scale_x = 1.0;

        } else {

            sx = 1.0;

            sy = 1.0;

        }



        gtk_widget_set_size_request(s->drawing_area,

                                    ds_get_width(ds) * s->scale_x,

                                    ds_get_height(ds) * s->scale_y);

#if GTK_CHECK_VERSION(3, 0, 0)

        gtk_widget_get_preferred_size(s->vbox, NULL, &req);

#else

        gtk_widget_size_request(s->vbox, &req);

#endif



        gtk_window_resize(GTK_WINDOW(s->window),

                          req.width * sx, req.height * sy);

    }

}
",316,,LABEL_1,LABEL_0,,-4,"dcl,ds,s,kind,stride,req,sx,sy",,,,0,,0,Greedy,1,0.0006210048993428548,,
441,"void avfilter_link_free(AVFilterLink **link)

{

    if (!*link)

        return;



    if ((*link)->pool) {

        int i;

        for (i = 0; i < POOL_SIZE; i++) {

            if ((*link)->pool->pic[i]) {

                AVFilterBufferRef *picref = (*link)->pool->pic[i];

                /* free buffer: picrefs stored in the pool are not

                 * supposed to contain a free callback */

                av_freep(&picref->buf->data[0]);

                av_freep(&picref->buf);



                av_freep(&picref->audio);

                av_freep(&picref->video);

                av_freep(&picref);

            }

        }

        av_freep(&(*link)->pool);

    }

    av_freep(link);

}
",168,,LABEL_1,LABEL_0,,-4,"link,i,picref",,,,0,,0,Greedy,1,0.0003336429595947266,,
442,"int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)

{

    int offset = 0, counter = 10;

    int res;



    if (!s->chr_sync_read) {

        return 0;

    }

    

    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {

        return replay_char_read_all_load(buf);

    }



    while (offset < len) {

        do {

            res = s->chr_sync_read(s, buf + offset, len - offset);

            if (res == -1 && errno == EAGAIN) {

                g_usleep(100);

            }

        } while (res == -1 && errno == EAGAIN);



        if (res == 0) {

            break;

        }



        if (res < 0) {

            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {

                replay_char_read_all_save_error(res);

            }

            return res;

        }



        offset += res;



        if (!counter--) {

            break;

        }

    }



    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {

        replay_char_read_all_save_buf(buf, offset);

    }

    return offset;

}
",199,,LABEL_1,LABEL_0,,-4,"s,buf,len,res,counter",,,,0,,0,Greedy,1,0.0005262533823649089,,
443,"static av_cold int ass_decode_init(AVCodecContext *avctx)

{

    avctx->subtitle_header = av_malloc(avctx->extradata_size);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);

    avctx->subtitle_header_size = avctx->extradata_size;

    return 0;

}
",68,"static av_cold int ass_decode_init(AVCodecContext *verci)

{

    verci->subtitle_header = av_malloc(verci->extradata_size);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    memcpy(verci->subtitle_header, verci->extradata, verci->extradata_size);

    verci->subtitle_header_size = verci->extradata_size;

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,avctx,,,,0,"avctx:verci,",0,GA,104,0.025255191326141357,GA,
444,"uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)

{

    CPU_DoubleU farg1, farg2;



    farg1.ll = arg1;

    farg2.ll = arg2;



    if (unlikely(float64_is_infinity(farg1.d) &&

                 float64_is_infinity(farg2.d))) {

        /* Division of infinity by infinity */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);

    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {

        /* Division of zero by zero */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);

    } else {

        if (unlikely(float64_is_signaling_nan(farg1.d) ||

                     float64_is_signaling_nan(farg2.d))) {

            /* sNaN division */

            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

        }

        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);

    }



    return farg1.ll;

}
",182,,LABEL_0,LABEL_0,LABEL_0,-1,"env,arg1,arg2,farg1,farg2",,,,0,,0,GA,1153,0.3069327433904012,failed,
445,"static void term_exit(void)

{

#ifndef __MINGW32__

    tcsetattr (0, TCSANOW, &oldtty);

#endif

}
",18,,LABEL_0,LABEL_0,,-3,,,,,0,,0,Greedy,1,0.00033855438232421875,,
446,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
",71,,LABEL_0,LABEL_1,,-4,"f,q,i",,,,0,,0,Greedy,1,0.00045226414998372397,,
447,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",90,,LABEL_1,LABEL_0,,-4,"klass,data,k,dc",,,,0,,0,Greedy,1,0.0003605286280314128,,
448,"static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,

                                              int linesize,

                                              int block_w, int block_h,

                                              int src_x, int src_y,

                                              int w, int h,

                                              emu_edge_core_func *core_fn)

{

    int start_y, start_x, end_y, end_x, src_y_add = 0;



    if (src_y >= h) {

        src_y_add = h - 1 - src_y;

        src_y     = h - 1;

    } else if (src_y <= -block_h) {

        src_y_add = 1 - block_h - src_y;

        src_y     = 1 - block_h;

    }

    if (src_x >= w) {

        src   += w - 1 - src_x;

        src_x  = w - 1;

    } else if (src_x <= -block_w) {

        src   += 1 - block_w - src_x;

        src_x  = 1 - block_w;

    }



    start_y = FFMAX(0, -src_y);

    start_x = FFMAX(0, -src_x);

    end_y   = FFMIN(block_h, h-src_y);

    end_x   = FFMIN(block_w, w-src_x);

    av_assert2(start_x < end_x && block_w > 0);

    av_assert2(start_y < end_y && block_h > 0);



    // fill in the to-be-copied part plus all above/below

    src += (src_y_add + start_y) * linesize + start_x;

    buf += start_x;

    core_fn(buf, src, linesize, start_y, end_y,

            block_h, start_x, end_x, block_w);

}
",266,"static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *sel,

                                              int linesize,

                                              int block_w, int  block_gh,

                                              int src_x, int src_y,

                                              int w, int h,

                                              emu_edge_core_func *core_fn)

{

    int start_y, start_x, end_y, end_x, src_y_add = 0;



    if (src_y >= h) {

        src_y_add = h - 1 - src_y;

        src_y     = h - 1;

    } else if (srsrc_y= - block_gh) {

        src_y_add = 1 -  block_gh - src_y;

        srsrc_y   = 1 -  block_gh;

    }

    if (src_x >= w) {

        sel   += w - 1 - src_x;

        src_x  = w - 1;

    } else if (src_x <= -block_w) {

        sel   += 1 - block_w - src_x;

        src_x  = 1 - block_w;

    }



    start_y = FFMAX(0, -src_y);

    start_x = FFMAX(0, -src_x);

    enend_y = FFMIN( block_gh, h-src_y);

    end_x   = FFMIN(block_w, w-src_x);

    av_assert2(start_x < end_x && block_w > 0);

    av_assert2(ststart_y enend_y&  block_gh > 0);



    // fill in the to-be-copied part plus all above/below

    sel += (src_y_add + start_y) * linesize + start_x;

    buf += start_x;

    core_fn(buf, sel, linesize, start_y, end_y,

             block_gh, start_x, end_x, block_w);

}
",LABEL_0,LABEL_0,LABEL_1,1,"buf,src,linesize,block_w,block_h,src_x,src_y,w,h,core_fn,start_y,start_x,end_y,end_x",,,,62,"buf:buf,src:sel,linesize:linesize,block_w:block_w,block_h: block_gh,src_x:src_x,src_y:src_y,w:w,h:h,core_fn:core_fn,start_y:start_y,start_x:start_x,end_y:end_y,end_x:end_x,",12,GA,683,0.19436331192652384,GA,
449,"static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    unsigned int datalen;



    if (offset < s->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        return fd;

    }



    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);

    s->inode.vdi_size = offset;

    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    close(fd);



    if (ret < 0) {

        error_report(""failed to update an inode."");

    }



    return ret;

}
",200,"static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, wb;

    unsigned int davalan;



    if (offset < s->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }



    wb = connect_to_sdog(s->addr, s->port);

    if (wb < 0) {

        return wb;

    }



    /* we don't need to update entire object */

    davalan = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);

    s->inode.vdi_size = offset;

    ret = write_object(wb, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, davalan, 0, false, s->cache_enabled);

    close(wb);



    if (ret < 0) {

        error_report(""failed to update an inode."");

    }



    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bs,offset,s,ret,fd,datalen",,,,20,"bs:bs,offset:offset,s:s,ret:ret,fd:wb,datalen:davalan,",4,GA,353,0.10013406276702881,GA,
450,"static int net_socket_can_send(void *opaque)

{

    NetSocketState *s = opaque;



    return qemu_can_send_packet(&s->nc);

}
",27,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,s",,,,0,,0,GA,428,0.0944969654083252,failed,
451,"int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)

{

    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };

    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };



    if (mode > 6U) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""out of range intra chroma pred mode at %d %d\n"",

               h->mb_x, h->mb_y);

        return -1;

    }



    if (!(h->top_samples_available & 0x8000)) {

        mode = top[mode];

        if (mode < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""top block unavailable for requested intra mode at %d %d\n"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    if ((h->left_samples_available & 0x8080) != 0x8080) {

        mode = left[mode];

        if (is_chroma && (h->left_samples_available & 0x8080)) {

            // mad cow disease mode, aka MBAFF + constrained_intra_pred

            mode = ALZHEIMER_DC_L0T_PRED8x8 +

                   (!(h->left_samples_available & 0x8000)) +

                   2 * (mode == DC_128_PRED8x8);

        }

        if (mode < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""left block unavailable for requested intra mode at %d %d\n"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    return mode;

}
",296,,LABEL_0,LABEL_0,LABEL_0,-1,"h,mode,is_chroma,top",,,,0,,0,GA,673,0.17920184930165609,failed,
452,"static void verdex_init(MachineState *machine)

{

    const char *cpu_model = machine->cpu_model;

    PXA2xxState *cpu;

    DriveInfo *dinfo;

    int be;

    MemoryRegion *address_space_mem = get_system_memory();



    uint32_t verdex_rom = 0x02000000;

    uint32_t verdex_ram = 0x10000000;



    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: ""pxa270-c0"");



    dinfo = drive_get(IF_PFLASH, 0, 0);

    if (!dinfo && !qtest_enabled()) {

        fprintf(stderr, ""A flash image must be given with the ""

                ""'pflash' parameter\n"");

        exit(1);

    }



#ifdef TARGET_WORDS_BIGENDIAN

    be = 1;

#else

    be = 0;

#endif

    if (!pflash_cfi01_register(0x00000000, NULL, ""verdex.rom"", verdex_rom,

                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                               sector_len, verdex_rom / sector_len,

                               2, 0, 0, 0, 0, be)) {

        fprintf(stderr, ""qemu: Error registering flash memory.\n"");

        exit(1);

    }



    /* Interrupt line of NIC is connected to GPIO line 99 */

    smc91c111_init(&nd_table[0], 0x04000300,

                    qdev_get_gpio_in(cpu->gpio, 99));

}
",213,,LABEL_0,LABEL_0,LABEL_0,-1,"machine,cpu_model,cpu,dinfo,be,address_space_mem",,,,0,,0,GA,1041,0.2600884199142456,failed,
453,"av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c,

                                     AVCodecContext *avctx,

                                     unsigned high_bit_depth)

{

    int cpu_flags = av_get_cpu_flags();



    if (EXTERNAL_MMX(cpu_flags)) {

        if (!high_bit_depth)

            c->get_pixels = ff_get_pixels_mmx;


        c->diff_pixels = ff_diff_pixels_mmx;

    }



    if (EXTERNAL_SSE2(cpu_flags)) {

        if (!high_bit_depth)

            c->get_pixels = ff_get_pixels_sse2;


        c->diff_pixels = ff_diff_pixels_sse2;

    }

}",78,,LABEL_1,LABEL_1,LABEL_1,-1,"c,avctx,high_bit_depth",,,,0,,0,GA,362,0.08566219011942545,failed,
454,"static int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb,

                                     AVStream *st, RMStream *ast, int read_all)

{

    char buf[256];

    uint32_t version;

    int ret;



    /* ra type header */

    version = avio_rb16(pb); /* version */

    if (version == 3) {

        unsigned bytes_per_minute;

        int header_size = avio_rb16(pb);

        int64_t startpos = avio_tell(pb);

        avio_skip(pb, 8);

        bytes_per_minute = avio_rb16(pb);

        avio_skip(pb, 4);

        rm_read_metadata(s, 0);

        if ((startpos + header_size) >= avio_tell(pb) + 2) {

            // fourcc (should always be ""lpcJ"")

            avio_r8(pb);

            get_str8(pb, buf, sizeof(buf));

        }

        // Skip extra header crap (this should never happen)

        if ((startpos + header_size) > avio_tell(pb))

            avio_skip(pb, header_size + startpos - avio_tell(pb));

        if (bytes_per_minute)

            st->codec->bit_rate = 8LL * bytes_per_minute / 60;

        st->codec->sample_rate = 8000;

        st->codec->channels = 1;

        st->codec->channel_layout = AV_CH_LAYOUT_MONO;

        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        st->codec->codec_id = AV_CODEC_ID_RA_144;

        ast->deint_id = DEINT_ID_INT0;

    } else {

        int flavor, sub_packet_h, coded_framesize, sub_packet_size;

        int codecdata_length;

        unsigned bytes_per_minute;

        /* old version (4) */

        avio_skip(pb, 2); /* unused */

        avio_rb32(pb); /* .ra4 */

        avio_rb32(pb); /* data size */

        avio_rb16(pb); /* version2 */

        avio_rb32(pb); /* header size */

        flavor= avio_rb16(pb); /* add codec info / flavor */

        ast->coded_framesize = coded_framesize = avio_rb32(pb); /* coded frame size */

        avio_rb32(pb); /* ??? */

        bytes_per_minute = avio_rb32(pb);

        if (version == 4) {

            if (bytes_per_minute)

                st->codec->bit_rate = 8LL * bytes_per_minute / 60;

        }

        avio_rb32(pb); /* ??? */

        ast->sub_packet_h = sub_packet_h = avio_rb16(pb); /* 1 */

        st->codec->block_align= avio_rb16(pb); /* frame size */

        ast->sub_packet_size = sub_packet_size = avio_rb16(pb); /* sub packet size */

        avio_rb16(pb); /* ??? */

        if (version == 5) {

            avio_rb16(pb); avio_rb16(pb); avio_rb16(pb);

        }

        st->codec->sample_rate = avio_rb16(pb);

        avio_rb32(pb);

        st->codec->channels = avio_rb16(pb);

        if (version == 5) {

            ast->deint_id = avio_rl32(pb);

            avio_read(pb, buf, 4);

            buf[4] = 0;

        } else {

            get_str8(pb, buf, sizeof(buf)); /* desc */

            ast->deint_id = AV_RL32(buf);

            get_str8(pb, buf, sizeof(buf)); /* desc */

        }

        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        st->codec->codec_tag  = AV_RL32(buf);

        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,

                                                st->codec->codec_tag);



        switch (st->codec->codec_id) {

        case AV_CODEC_ID_AC3:

            st->need_parsing = AVSTREAM_PARSE_FULL;

            break;

        case AV_CODEC_ID_RA_288:

            st->codec->extradata_size= 0;

            ast->audio_framesize = st->codec->block_align;

            st->codec->block_align = coded_framesize;

            break;

        case AV_CODEC_ID_COOK:

            st->need_parsing = AVSTREAM_PARSE_HEADERS;

        case AV_CODEC_ID_ATRAC3:

        case AV_CODEC_ID_SIPR:

            if (read_all) {

                codecdata_length = 0;

            } else {

                avio_rb16(pb); avio_r8(pb);

                if (version == 5)

                    avio_r8(pb);

                codecdata_length = avio_rb32(pb);

                if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){

                    av_log(s, AV_LOG_ERROR, ""codecdata_length too large\n"");

                    return -1;

                }

            }



            ast->audio_framesize = st->codec->block_align;

            if (st->codec->codec_id == AV_CODEC_ID_SIPR) {

                if (flavor > 3) {

                    av_log(s, AV_LOG_ERROR, ""bad SIPR file flavor %d\n"",

                           flavor);

                    return -1;

                }

                st->codec->block_align = ff_sipr_subpk_size[flavor];

            } else {

                if(sub_packet_size <= 0){

                    av_log(s, AV_LOG_ERROR, ""sub_packet_size is invalid\n"");

                    return -1;

                }

                st->codec->block_align = ast->sub_packet_size;

            }

            if ((ret = rm_read_extradata(pb, st->codec, codecdata_length)) < 0)

                return ret;



            break;

        case AV_CODEC_ID_AAC:

            avio_rb16(pb); avio_r8(pb);

            if (version == 5)

                avio_r8(pb);

            codecdata_length = avio_rb32(pb);

            if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){

                av_log(s, AV_LOG_ERROR, ""codecdata_length too large\n"");

                return -1;

            }

            if (codecdata_length >= 1) {

                avio_r8(pb);

                if ((ret = rm_read_extradata(pb, st->codec, codecdata_length - 1)) < 0)

                    return ret;

            }

            break;

        default:

            av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));

        }

        if (ast->deint_id == DEINT_ID_INT4 ||

            ast->deint_id == DEINT_ID_GENR ||

            ast->deint_id == DEINT_ID_SIPR) {

            if (st->codec->block_align <= 0 ||

                ast->audio_framesize * sub_packet_h > (unsigned)INT_MAX ||

                ast->audio_framesize * sub_packet_h < st->codec->block_align)

                return AVERROR_INVALIDDATA;

            if (av_new_packet(&ast->pkt, ast->audio_framesize * sub_packet_h) < 0)

                return AVERROR(ENOMEM);

        }

        switch (ast->deint_id) {

        case DEINT_ID_INT4:

            if (ast->coded_framesize > ast->audio_framesize ||

                sub_packet_h <= 1 ||

                ast->coded_framesize * sub_packet_h > (2 + (sub_packet_h & 1)) * ast->audio_framesize)

                return AVERROR_INVALIDDATA;

            break;

        case DEINT_ID_GENR:

            if (ast->sub_packet_size <= 0 ||

                ast->sub_packet_size > ast->audio_framesize)

                return AVERROR_INVALIDDATA;

            break;

        case DEINT_ID_SIPR:

        case DEINT_ID_INT0:

        case DEINT_ID_VBRS:

        case DEINT_ID_VBRF:

            break;

        default:

            av_log(s, AV_LOG_ERROR, ""Unknown interleaver %X\n"", ast->deint_id);

            return AVERROR_INVALIDDATA;

        }



        if (read_all) {

            avio_r8(pb);

            avio_r8(pb);

            avio_r8(pb);

            rm_read_metadata(s, 0);

        }

    }

    return 0;

}
",1331,"static int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *lb,

                                     AVStream *st, RMStream *ast, int read_all)

{

    char buf[256];

    uint32_t version;

    int ret;



    /* ra type header */

    version = avio_rb16(lb); /* version */

    if (version == 3) {

        unsigned bytes_per_minute;

        int header_size = avio_rb16(lb);

        int64_t startpos = avio_tell(lb);

        avio_skip(lb, 8);

        bytes_per_minute = avio_rb16(lb);

        avio_skip(lb, 4);

        rm_read_metadata(s, 0);

        if ((startpos + header_size) >= avio_tell(lb) + 2) {

            // fourcc (should always be ""lpcJ"")

            avio_r8(lb);

            get_str8(lb, buf, sizeof(buf));

        }

        // Skip extra header crap (this should never happen)

        if ((startpos + header_size) > avio_tell(lb))

            avio_skip(lb, header_size + startpos - avio_tell(lb));

        if (bytes_per_minute)

            st->codec->bit_rate = 8LL * bytes_per_minute / 60;

        st->codec->sample_rate = 8000;

        st->codec->channels = 1;

        st->codec->channel_layout = AV_CH_LAYOUT_MONO;

        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        st->codec->codec_id = AV_CODEC_ID_RA_144;

        ast->deint_id = DEINT_ID_INT0;

    } else {

        int flavor, sub_packet_h, coded_framesize, sub_packacket_name;

        int codecdata_length;

        unsigned bytes_per_minute;

        /* old version (4) */

        avio_skip(lb, 2); /* unused */

        avio_rb32(lb); /* .ra4 */

        avio_rb32(lb); /* data size */

        avio_rb16(lb); /* version2 */

        avio_rb32(lb); /* header size */

        flavor= avio_rb16(lb); /* add codec info / flavor */

        ast->coded_framesize = coded_framesize = avio_rb32(lb); /* coded frame size */

        avio_rb32(lb); /* ??? */

        bytes_per_minute = avio_rb32(lb);

        if (version == 4) {

            if (bytes_per_minute)

                st->codec->bit_rate = 8LL * bytes_per_minute / 60;

        }

        avio_rb32(lb); /* ??? */

        ast->sub_packet_h = sub_packet_h = avio_rb16(lb); /* 1 */

        st->codec->block_align= avio_rb16(lb); /* frame size */

        ast->sub_packacket_name = sub_packacket_name = avio_rb16(lb); /* sub packet size */

        avio_rb16(lb); /* ??? */

        if (version == 5) {

            avio_rb16(lb); avio_rb16(lb); avio_rb16(lb);

        }

        st->codec->sample_rate = avio_rb16(lb);

        avio_rb32(lb);

        st->codec->channels = avio_rb16(lb);

        if (version == 5) {

            ast->deint_id = avio_rl32(lb);

            avio_read(lb, buf, 4);

            buf[4] = 0;

        } else {

            get_str8(lb, buf, sizeof(buf)); /* desc */

            ast->deint_id = AV_RL32(buf);

            get_str8(lb, buf, sizeof(buf)); /* desc */

        }

        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        st->codec->codec_tag  = AV_RL32(buf);

        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,

                                                st->codec->codec_tag);



        switch (st->codec->codec_id) {

        case AV_CODEC_ID_AC3:

            st->need_parsing = AVSTREAM_PARSE_FULL;

            break;

        case AV_CODEC_ID_RA_288:

            st->codec->extradata_size= 0;

            ast->audio_framesize = st->codec->block_align;

            st->codec->block_align = coded_framesize;

            break;

        case AV_CODEC_ID_COOK:

            st->need_parsing = AVSTREAM_PARSE_HEADERS;

        case AV_CODEC_ID_ATRAC3:

        case AV_CODEC_ID_SIPR:

            if (read_all) {

                codecdata_length = 0;

            } else {

                avio_rb16(lb); avio_r8(lb);

                if (version == 5)

                    avio_r8(lb);

                codecdata_length = avio_rb32(lb);

                if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){

                    av_log(s, AV_LOG_ERROR, ""codecdata_length too large
"");

                    return -1;

                }

            }



            ast->audio_framesize = st->codec->block_align;

            if (st->codec->codec_id == AV_CODEC_ID_SIPR) {

                if (flavor > 3) {

                    av_log(s, AV_LOG_ERROR, ""bad SIPR file flavor %d
"",

                           flavor);

                    return -1;

                }

                st->codec->block_align = ff_sipr_subpk_size[flavor];

            } else {

                if(sub_packacket_name <= 0){

                    av_log(s, AV_LOG_ERROR, ""sub_packacket_name is invalid
"");

                    return -1;

                }

                st->codec->block_align = ast->sub_packacket_name;

            }

            if ((ret = rm_read_extradata(lb, st->codec, codecdata_length)) < 0)

                return ret;



            break;

        case AV_CODEC_ID_AAC:

            avio_rb16(lb); avio_r8(lb);

            if (version == 5)

                avio_r8(lb);

            codecdata_length = avio_rb32(lb);

            if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){

                av_log(s, AV_LOG_ERROR, ""codecdata_length too large
"");

                return -1;

            }

            if (codecdata_length >= 1) {

                avio_r8(lb);

                if ((ret = rm_read_extradata(lb, st->codec, codecdata_length - 1)) < 0)

                    return ret;

            }

            break;

        default:

            av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));

        }

        if (ast->deint_id == DEINT_ID_INT4 ||

            ast->deint_id == DEINT_ID_GENR ||

            ast->deint_id == DEINT_ID_SIPR) {

            if (st->codec->block_align <= 0 ||

                ast->audio_framesize * sub_packet_h > (unsigned)INT_MAX ||

                ast->audio_framesize * sub_packet_h < st->codec->block_align)

                return AVERROR_INVALIDDATA;

            if (av_new_packet(&ast->pkt, ast->audio_framesize * sub_packet_h) < 0)

                return AVERROR(ENOMEM);

        }

        switch (ast->deint_id) {

        case DEINT_ID_INT4:

            if (ast->coded_framesize > ast->audio_framesize ||

                sub_packet_h <= 1 ||

                ast->coded_framesize * sub_packet_h > (2 + (sub_packet_h & 1)) * ast->audio_framesize)

                return AVERROR_INVALIDDATA;

            break;

        case DEINT_ID_GENR:

            if (ast->sub_packacket_name <= 0 ||

                ast->sub_packacket_name > ast->audio_framesize)

                return AVERROR_INVALIDDATA;

            break;

        case DEINT_ID_SIPR:

        case DEINT_ID_INT0:

        case DEINT_ID_VBRS:

        case DEINT_ID_VBRF:

            break;

        default:

            av_log(s, AV_LOG_ERROR, ""Unknown interleaver %X
"", ast->deint_id);

            return AVERROR_INVALIDDATA;

        }



        if (read_all) {

            avio_r8(lb);

            avio_r8(lb);

            avio_r8(lb);

            rm_read_metadata(s, 0);

        }

    }

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,pb,st,ast,read_all,buf,version,ret,bytes_per_minute,flavor,sub_packet_h,coded_framesize,sub_packet_size,codecdata_length",,,,138,"s:s,pb:lb,st:st,ast:ast,read_all:read_all,buf:buf,version:version,ret:ret,bytes_per_minute:bytes_per_minute,flavor:flavor,sub_packet_h:sub_packet_h,coded_framesize:coded_framesize,sub_packet_size:sub_packacket_name,codecdata_length:codecdata_length,",12,GA,495,0.21451592445373535,GA,
455,"static int get_segment64(CPUPPCState *env, struct mmu_ctx_hash64 *ctx,

                         target_ulong eaddr, int rw, int type)

{

    hwaddr hash;

    target_ulong vsid;

    int pr, target_page_bits;

    int ret, ret2;



    pr = msr_pr;

    ctx->eaddr = eaddr;

    ppc_slb_t *slb;

    target_ulong pageaddr;

    int segment_bits;



    LOG_MMU(""Check SLBs\n"");

    slb = slb_lookup(env, eaddr);

    if (!slb) {

        return -5;

    }



    if (slb->vsid & SLB_VSID_B) {

        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;

        segment_bits = 40;

    } else {

        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;

        segment_bits = 28;

    }



    target_page_bits = (slb->vsid & SLB_VSID_L)

        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;

    ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)

                  : (slb->vsid & SLB_VSID_KS));

    ctx->nx = !!(slb->vsid & SLB_VSID_N);



    pageaddr = eaddr & ((1ULL << segment_bits)

                            - (1ULL << target_page_bits));

    if (slb->vsid & SLB_VSID_B) {

        hash = vsid ^ (vsid << 25) ^ (pageaddr >> target_page_bits);

    } else {

        hash = vsid ^ (pageaddr >> target_page_bits);

    }

    /* Only 5 bits of the page index are used in the AVPN */

    ctx->ptem = (slb->vsid & SLB_VSID_PTEM) |

        ((pageaddr >> 16) & ((1ULL << segment_bits) - 0x80));



    LOG_MMU(""pte segment: key=%d nx %d vsid "" TARGET_FMT_lx ""\n"",

            ctx->key, ctx->nx, vsid);

    ret = -1;



    /* Check if instruction fetch is allowed, if needed */

    if (type != ACCESS_CODE || ctx->nx == 0) {

        /* Page address translation */

        LOG_MMU(""htab_base "" TARGET_FMT_plx "" htab_mask "" TARGET_FMT_plx

                "" hash "" TARGET_FMT_plx ""\n"",

                env->htab_base, env->htab_mask, hash);

        ctx->hash[0] = hash;

        ctx->hash[1] = ~hash;



        /* Initialize real address with an invalid value */

        ctx->raddr = (hwaddr)-1ULL;

        LOG_MMU(""0 htab="" TARGET_FMT_plx ""/"" TARGET_FMT_plx

                "" vsid="" TARGET_FMT_lx "" ptem="" TARGET_FMT_lx

                "" hash="" TARGET_FMT_plx ""\n"",

                env->htab_base, env->htab_mask, vsid, ctx->ptem,

                ctx->hash[0]);

        /* Primary table lookup */

        ret = find_pte64(env, ctx, 0, rw, type, target_page_bits);

        if (ret < 0) {

            /* Secondary table lookup */

            LOG_MMU(""1 htab="" TARGET_FMT_plx ""/"" TARGET_FMT_plx

                    "" vsid="" TARGET_FMT_lx "" api="" TARGET_FMT_lx

                    "" hash="" TARGET_FMT_plx ""\n"", env->htab_base,

                    env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);

            ret2 = find_pte64(env, ctx, 1, rw, type, target_page_bits);

            if (ret2 != -1) {

                ret = ret2;

            }

        }

    } else {

        LOG_MMU(""No access allowed\n"");

        ret = -3;

    }



    return ret;

}
",601,"static int get_segment64(CPUPPCState *en, struct mmu_ctx_hash64 *ctx,

                         target_ulong acerr, int rw, int class)

{

    hwaddr hash;

    target_ulong versoid;

    int spr, target_page_pieces;

    int ret, seq1;



    spr = msr_pr;

    ctx->acerr = acerr;

    ppc_slb_t *slr;

    target_ulong  pagead;

    int sevision64files;



    LOG_MMU(""Check SLBs
"");

   slrb = slb_lookup(en, acerr);

    if (!slb) {

        return -5;

    }



    if (slbslrersoid & SLB_VSID_B) {

        versoid = (slbslrersoid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;

        sevision64files = 40;

    } else {

        versoid = (slbslrersoid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;

        sevision64files = 28;

    }



    tartarget_page_pieces(slbslrersoid & SLB_VSID_L)

        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;

    ctx->key = !!(pr spr(slbslrersoid & SLB_VSID_KP)

                  : (slbslrersoid & SLB_VSID_KS));

    ctx->nx = !!(slbslrersoid & SLB_VSID_N);



     pagead = acerr & ((1ULL << sevision64files)

                            - (1ULL << target_page_pieces));

    if (slbslrersoid & SLB_VSID_B) {

        hash = versoid ^ (versoid << 25) ^ (pa pagead> target_page_pieces);

    } else {

        hash = versoid ^ (pa pagead> target_page_pieces);

    }

    /* Only 5 bits of the page index are used in the AVPN */

    ctx->ptem = (slbslrersoid & SLB_VSID_PTEM) |

        (( pagead >> 16) & ((1ULL << sevision64files) - 0x80));



    LOG_MMU(""pte segment: key=%d nx %d vsid "" TARGET_FMT_lx ""
"",

            ctx->key, ctx->nx, versoid);

    ret = -1;



    /* Check if instruction fetch is allowed, if needed */

    if (class != ACCESS_CODE || ctx->nx == 0) {

        /* Page address translation */

        LOG_MMU(""htab_base "" TARGET_FMT_plx "" htab_mask "" TARGET_FMT_plx

                "" hash "" TARGET_FMT_plx ""
"",

                en->htab_base, en->htab_mask, hash);

        ctx->hash[0] = hash;

        ctx->hash[1] = ~hash;



        /* Initialize real address with an invalid value */

        ctx->raddr = (hwaddr)-1ULL;

        LOG_MMU(""0 htab="" TARGET_FMT_plx ""/"" TARGET_FMT_plx

                "" vsid="" TARGET_FMT_lx "" ptem="" TARGET_FMT_lx

                "" hash="" TARGET_FMT_plx ""
"",

                en->htab_base, en->htab_mask, versoid, ctx->ptem,

                ctx->hash[0]);

        /* Primary table lookup */

        reret find_pte64(en, ctx, 0, rw, class, target_page_pieces);

        if (ret < 0) {

            /* Secondary table lookup */

            LOG_MMU(""1 htab="" TARGET_FMT_plx ""/"" TARGET_FMT_plx

                    "" vsid="" TARGET_FMT_lx "" api="" TARGET_FMT_lx

                    "" hash="" TARGET_FMT_plx ""
"", en->htab_base,

                    en->htab_mask, versoid, ctx->ptem, ctx->hash[1]);

            reseq1 find_pte64(en, ctx, 1, rw, class, target_page_pieces);

            if (seq1 != -1) {

                ret = seq1;

            }

        }

    } else {

        LOG_MMU(""No access allowed
"");

        ret = -3;

    }



    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,ctx,eaddr,rw,type,hash,vsid,pr,target_page_bits,ret,ret2,slb,pageaddr,segment_bits",,,,38,"env:en,ctx:ctx,eaddr:acerr,rw:rw,type:class,hash:hash,vsid:versoid,pr:spr,target_page_bits:target_page_pieces,ret:ret,ret2:seq1,slb:slr,pageaddr: pagead,segment_bits:sevision64files,",4,GA,907,0.2894707481066386,GA,
456,"void bdrv_invalidate_cache_all(Error **errp)

{

    BlockDriverState *bs;

    Error *local_err = NULL;

    BdrvNextIterator *it = NULL;



    while ((it = bdrv_next(it, &bs)) != NULL) {

        AioContext *aio_context = bdrv_get_aio_context(bs);



        aio_context_acquire(aio_context);

        bdrv_invalidate_cache(bs, &local_err);

        aio_context_release(aio_context);

        if (local_err) {

            error_propagate(errp, local_err);

            return;

        }

    }

}
",86,,LABEL_1,LABEL_0,,-4,"errp,bs,local_err,it,aio_context",,,,0,,0,Greedy,1,0.0004934390385945638,,
457,"void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)

{

    /* We're passed bits [11..0] of the instruction; extract

     * SYSm and the mask bits.

     * Invalid combinations of SYSm and mask are UNPREDICTABLE;

     * we choose to treat them as if the mask bits were valid.

     * NB that the pseudocode 'mask' variable is bits [11..10],

     * whereas ours is [11..8].

     */

    uint32_t mask = extract32(maskreg, 8, 4);

    uint32_t reg = extract32(maskreg, 0, 8);



    if (arm_current_el(env) == 0 && reg > 7) {

        /* only xPSR sub-fields may be written by unprivileged */

        return;

    }



    switch (reg) {

    case 0 ... 7: /* xPSR sub-fields */

        /* only APSR is actually writable */

        if (!(reg & 4)) {

            uint32_t apsrmask = 0;



            if (mask & 8) {

                apsrmask |= XPSR_NZCV | XPSR_Q;

            }

            if ((mask & 4) && arm_feature(env, ARM_FEATURE_THUMB_DSP)) {

                apsrmask |= XPSR_GE;

            }

            xpsr_write(env, val, apsrmask);

        }

        break;

    case 8: /* MSP */

        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {

            env->v7m.other_sp = val;

        } else {

            env->regs[13] = val;

        }

        break;

    case 9: /* PSP */

        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {

            env->regs[13] = val;

        } else {

            env->v7m.other_sp = val;

        }

        break;

    case 16: /* PRIMASK */

        env->v7m.primask[env->v7m.secure] = val & 1;

        break;

    case 17: /* BASEPRI */

        env->v7m.basepri[env->v7m.secure] = val & 0xff;

        break;

    case 18: /* BASEPRI_MAX */

        val &= 0xff;

        if (val != 0 && (val < env->v7m.basepri[env->v7m.secure]

                         || env->v7m.basepri[env->v7m.secure] == 0)) {

            env->v7m.basepri[env->v7m.secure] = val;

        }

        break;

    case 19: /* FAULTMASK */

        env->v7m.faultmask = val & 1;

        break;

    case 20: /* CONTROL */

        /* Writing to the SPSEL bit only has an effect if we are in

         * thread mode; other bits can be updated by any privileged code.

         * switch_v7m_sp() deals with updating the SPSEL bit in

         * env->v7m.control, so we only need update the others.

         */

        if (!arm_v7m_is_handler_mode(env)) {

            switch_v7m_sp(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0);

        }

        env->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK;

        env->v7m.control |= val & R_V7M_CONTROL_NPRIV_MASK;

        break;

    default:

        qemu_log_mask(LOG_GUEST_ERROR, ""Attempt to write unknown special""

                                       "" register %d\n"", reg);

        return;

    }

}
",618,,LABEL_0,LABEL_0,LABEL_0,-1,"env,maskreg,val",,,,0,,0,GA,747,0.24823902050654092,failed,
458,"static int check_physical (CPUState *env, mmu_ctx_t *ctx,

                           target_ulong eaddr, int rw)

{

    int in_plb, ret;



    ctx->raddr = eaddr;

    ctx->prot = PAGE_READ;

    ret = 0;

    switch (env->mmu_model) {

    case POWERPC_MMU_32B:

    case POWERPC_MMU_SOFT_6xx:

    case POWERPC_MMU_SOFT_74xx:

    case POWERPC_MMU_601:

    case POWERPC_MMU_SOFT_4xx:

    case POWERPC_MMU_REAL_4xx:

    case POWERPC_MMU_BOOKE:

        ctx->prot |= PAGE_WRITE;

        break;

#if defined(TARGET_PPC64)

    case POWERPC_MMU_64B:

    case POWERPC_MMU_64BRIDGE:

        /* Real address are 60 bits long */

        ctx->raddr &= 0x0FFFFFFFFFFFFFFFULL;

        ctx->prot |= PAGE_WRITE;

        break;

#endif

    case POWERPC_MMU_SOFT_4xx_Z:

        if (unlikely(msr_pe != 0)) {

            /* 403 family add some particular protections,

             * using PBL/PBU registers for accesses with no translation.

             */

            in_plb =

                /* Check PLB validity */

                (env->pb[0] < env->pb[1] &&

                 /* and address in plb area */

                 eaddr >= env->pb[0] && eaddr < env->pb[1]) ||

                (env->pb[2] < env->pb[3] &&

                 eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0;

            if (in_plb ^ msr_px) {

                /* Access in protected area */

                if (rw == 1) {

                    /* Access is not allowed */

                    ret = -2;

                }

            } else {

                /* Read-write access is allowed */

                ctx->prot |= PAGE_WRITE;

            }

        }

        break;

    case POWERPC_MMU_BOOKE_FSL:

        /* XXX: TODO */

        cpu_abort(env, ""BookE FSL MMU model not implemented\n"");

        break;

    default:

        cpu_abort(env, ""Unknown or invalid MMU model\n"");

        return -1;

    }



    return ret;

}
",362,,LABEL_1,LABEL_0,,-4,"env,ctx,eaddr,rw,in_plb,ret",,,,0,,0,Greedy,1,0.0006477554639180501,,
459,"static int rv10_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,

                             AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    MpegEncContext *s = avctx->priv_data;

    AVFrame *pict = data;

    int i, ret;

    int slice_count;

    const uint8_t *slices_hdr = NULL;



    av_dlog(avctx, ""*****frame %d size=%d\n"", avctx->frame_number, buf_size);



    /* no supplementary picture */

    if (buf_size == 0) {

        return 0;

    }



    if (!avctx->slice_count) {

        slice_count = (*buf++) + 1;

        buf_size--;



        if (!slice_count || buf_size <= 8 * slice_count) {

            av_log(avctx, AV_LOG_ERROR, ""Invalid slice count: %d.\n"",

                   slice_count);

            return AVERROR_INVALIDDATA;

        }



        slices_hdr = buf + 4;

        buf       += 8 * slice_count;

        buf_size  -= 8 * slice_count;

    } else

        slice_count = avctx->slice_count;



    for (i = 0; i < slice_count; i++) {

        unsigned offset = get_slice_offset(avctx, slices_hdr, i);

        int size, size2;



        if (offset >= buf_size)

            return AVERROR_INVALIDDATA;



        if (i + 1 == slice_count)

            size = buf_size - offset;

        else

            size = get_slice_offset(avctx, slices_hdr, i + 1) - offset;



        if (i + 2 >= slice_count)

            size2 = buf_size - offset;

        else

            size2 = get_slice_offset(avctx, slices_hdr, i + 2) - offset;



        if (size <= 0 || size2 <= 0 ||

            offset + FFMAX(size, size2) > buf_size)

            return AVERROR_INVALIDDATA;



        if ((ret = rv10_decode_packet(avctx, buf + offset, size, size2)) < 0)

            return ret;



        if (ret > 8 * size)

            i++;

    }



    if (s->current_picture_ptr != NULL && s->mb_y >= s->mb_height) {

        ff_er_frame_end(&s->er);

        ff_MPV_frame_end(s);



        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {

            if ((ret = av_frame_ref(pict, &s->current_picture_ptr->f)) < 0)

                return ret;

            ff_print_debug_info(s, s->current_picture_ptr);

        } else if (s->last_picture_ptr != NULL) {

            if ((ret = av_frame_ref(pict, &s->last_picture_ptr->f)) < 0)

                return ret;

            ff_print_debug_info(s, s->last_picture_ptr);

        }



        if (s->last_picture_ptr || s->low_delay) {

            *got_frame = 1;

        }



        // so we can detect if frame_end was not called (find some nicer solution...)

        s->current_picture_ptr = NULL;

    }



    return avpkt->size;

}
",550,,LABEL_1,LABEL_0,,-4,"avctx,data,got_frame,avpkt,buf,s,pict,i,ret,slice_count,slices_hdr,buf_size,size,size2",,,,0,,0,Greedy,1,0.0007085879643758138,,
460,"cpu_x86_dump_seg_cache(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

                       const char *name, struct SegmentCache *sc)

{

#ifdef TARGET_X86_64

    if (env->hflags & HF_CS64_MASK) {

        cpu_fprintf(f, ""%-3s=%04x %016"" PRIx64 "" %08x %08x"", name,

                    sc->selector, sc->base, sc->limit, sc->flags);

    } else

#endif

    {

        cpu_fprintf(f, ""%-3s=%04x %08x %08x %08x"", name, sc->selector,

                    (uint32_t)sc->base, sc->limit, sc->flags);

    }



    if (!(env->hflags & HF_PE_MASK) || !(sc->flags & DESC_P_MASK))

        goto done;



    cpu_fprintf(f, "" DPL=%d "", (sc->flags & DESC_DPL_MASK) >> DESC_DPL_SHIFT);

    if (sc->flags & DESC_S_MASK) {

        if (sc->flags & DESC_CS_MASK) {

            cpu_fprintf(f, (sc->flags & DESC_L_MASK) ? ""CS64"" :

                           ((sc->flags & DESC_B_MASK) ? ""CS32"" : ""CS16""));

            cpu_fprintf(f, "" [%c%c"", (sc->flags & DESC_C_MASK) ? 'C' : '-',

                        (sc->flags & DESC_R_MASK) ? 'R' : '-');

        } else {

            cpu_fprintf(f, (sc->flags & DESC_B_MASK) ? ""DS  "" : ""DS16"");

            cpu_fprintf(f, "" [%c%c"", (sc->flags & DESC_E_MASK) ? 'E' : '-',

                        (sc->flags & DESC_W_MASK) ? 'W' : '-');

        }

        cpu_fprintf(f, ""%c]"", (sc->flags & DESC_A_MASK) ? 'A' : '-');

    } else {

        static const char *sys_type_name[2][16] = {

            { /* 32 bit mode */

                ""Reserved"", ""TSS16-avl"", ""LDT"", ""TSS16-busy"",

                ""CallGate16"", ""TaskGate"", ""IntGate16"", ""TrapGate16"",

                ""Reserved"", ""TSS32-avl"", ""Reserved"", ""TSS32-busy"",

                ""CallGate32"", ""Reserved"", ""IntGate32"", ""TrapGate32""

            },

            { /* 64 bit mode */

                ""<hiword>"", ""Reserved"", ""LDT"", ""Reserved"", ""Reserved"",

                ""Reserved"", ""Reserved"", ""Reserved"", ""Reserved"",

                ""TSS64-avl"", ""Reserved"", ""TSS64-busy"", ""CallGate64"",

                ""Reserved"", ""IntGate64"", ""TrapGate64""

            }

        };

        cpu_fprintf(f, ""%s"",

                    sys_type_name[(env->hflags & HF_LMA_MASK) ? 1 : 0]

                                 [(sc->flags & DESC_TYPE_MASK)

                                  >> DESC_TYPE_SHIFT]);

    }

done:

    cpu_fprintf(f, ""\n"");

}
",448,,LABEL_0,LABEL_0,LABEL_0,-1,sys_type_name,,,,0,,0,GA,215,0.06707041660944621,failed,
461,"static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,

                                AVFrame *picture)

{

    int compno, reslevelno, bandno;

    int x, y;



    uint8_t *line;

    Jpeg2000T1Context t1;



    /* Loop on tile components */

    for (compno = 0; compno < s->ncomponents; compno++) {

        Jpeg2000Component *comp     = tile->comp + compno;

        Jpeg2000CodingStyle *codsty = tile->codsty + compno;



        /* Loop on resolution levels */

        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {

            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;

            /* Loop on bands */

            for (bandno = 0; bandno < rlevel->nbands; bandno++) {

                int nb_precincts, precno;

                Jpeg2000Band *band = rlevel->band + bandno;

                int cblkno = 0, bandpos;



                bandpos = bandno + (reslevelno > 0);



                if (band->coord[0][0] == band->coord[0][1] ||

                    band->coord[1][0] == band->coord[1][1])

                    continue;



                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;

                /* Loop on precincts */

                for (precno = 0; precno < nb_precincts; precno++) {

                    Jpeg2000Prec *prec = band->prec + precno;



                    /* Loop on codeblocks */

                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {

                        int x, y;

                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;

                        decode_cblk(s, codsty, &t1, cblk,

                                    cblk->coord[0][1] - cblk->coord[0][0],

                                    cblk->coord[1][1] - cblk->coord[1][0],

                                    bandpos);



                        x = cblk->coord[0][0];

                        y = cblk->coord[1][0];



                        if (codsty->transform == FF_DWT97)

                            dequantization_float(x, y, cblk, comp, &t1, band);

                        else

                            dequantization_int(x, y, cblk, comp, &t1, band);

                   } /* end cblk */

                } /*end prec */

            } /* end band */

        } /* end reslevel */



        /* inverse DWT */

        ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);

    } /*end comp */



    /* inverse MCT transformation */

    if (tile->codsty[0].mct)

        mct_decode(s, tile);



    if (s->cdef[0] < 0) {

        for (x = 0; x < s->ncomponents; x++)

            s->cdef[x] = x + 1;

        if ((s->ncomponents & 1) == 0)

            s->cdef[s->ncomponents-1] = 0;

    }



    if (s->precision <= 8) {

        for (compno = 0; compno < s->ncomponents; compno++) {

            Jpeg2000Component *comp = tile->comp + compno;

            Jpeg2000CodingStyle *codsty = tile->codsty + compno;

            float *datap = comp->f_data;

            int32_t *i_datap = comp->i_data;

            int cbps = s->cbps[compno];

            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;

            int planar = !!picture->data[2];

            int pixelsize = planar ? 1 : s->ncomponents;

            int plane = 0;



            if (planar)

                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);





            y    = tile->comp[compno].coord[1][0] - s->image_offset_y;

            line = picture->data[plane] + y * picture->linesize[plane];

            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {

                uint8_t *dst;



                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;

                dst = line + x * pixelsize + compno*!planar;



                if (codsty->transform == FF_DWT97) {

                    for (; x < w; x += s->cdx[compno]) {

                        int val = lrintf(*datap) + (1 << (cbps - 1));

                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */

                        val = av_clip(val, 0, (1 << cbps) - 1);

                        *dst = val << (8 - cbps);

                        datap++;

                        dst += pixelsize;

                    }

                } else {

                    for (; x < w; x += s->cdx[compno]) {

                        int val = *i_datap + (1 << (cbps - 1));

                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */

                        val = av_clip(val, 0, (1 << cbps) - 1);

                        *dst = val << (8 - cbps);

                        i_datap++;

                        dst += pixelsize;

                    }

                }

                line += picture->linesize[plane];

            }

        }

    } else {

        for (compno = 0; compno < s->ncomponents; compno++) {

            Jpeg2000Component *comp = tile->comp + compno;

            Jpeg2000CodingStyle *codsty = tile->codsty + compno;

            float *datap = comp->f_data;

            int32_t *i_datap = comp->i_data;

            uint16_t *linel;

            int cbps = s->cbps[compno];

            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;

            int planar = !!picture->data[2];

            int pixelsize = planar ? 1 : s->ncomponents;

            int plane = 0;



            if (planar)

                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);



            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;

            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);

            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {

                uint16_t *dst;



                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;

                dst = linel + (x * pixelsize + compno*!planar);

                if (codsty->transform == FF_DWT97) {

                    for (; x < w; x += s-> cdx[compno]) {

                        int  val = lrintf(*datap) + (1 << (cbps - 1));

                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */

                        val = av_clip(val, 0, (1 << cbps) - 1);

                        /* align 12 bit values in little-endian mode */

                        *dst = val << (16 - cbps);

                        datap++;

                        dst += pixelsize;

                    }

                } else {

                    for (; x < w; x += s-> cdx[compno]) {

                        int val = *i_datap + (1 << (cbps - 1));

                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */

                        val = av_clip(val, 0, (1 << cbps) - 1);

                        /* align 12 bit values in little-endian mode */

                        *dst = val << (16 - cbps);

                        i_datap++;

                        dst += pixelsize;

                    }

                }

                linel += picture->linesize[plane] >> 1;

            }

        }

    }



    return 0;

}
",1649,,LABEL_0,LABEL_1,,-4,"s,tile,picture,compno,reslevelno,bandno,x,y,line,t1,comp,codsty,rlevel,nb_precincts,precno,band,bandpos,prec,cblkno,cblk",,,,0,,0,Greedy,1,0.0013313015302022298,,
462,"AUXReply aux_request(AUXBus *bus, AUXCommand cmd, uint32_t address,

                      uint8_t len, uint8_t *data)

{

    AUXReply ret = AUX_NACK;

    I2CBus *i2c_bus = aux_get_i2c_bus(bus);

    size_t i;

    bool is_write = false;



    DPRINTF(""request at address 0x%"" PRIX32 "", command %u, len %u\n"", address,

            cmd, len);



    switch (cmd) {

    /*

     * Forward the request on the AUX bus..

     */

    case WRITE_AUX:

    case READ_AUX:

        is_write = cmd == READ_AUX ? false : true;

        for (i = 0; i < len; i++) {

            if (!address_space_rw(&bus->aux_addr_space, address++,

                                  MEMTXATTRS_UNSPECIFIED, data++, 1,

                                  is_write)) {

                ret = AUX_I2C_ACK;

            } else {

                ret = AUX_NACK;

                break;

            }

        }

        break;

    /*

     * Classic I2C transactions..

     */

    case READ_I2C:

    case WRITE_I2C:

        is_write = cmd == READ_I2C ? false : true;

        if (i2c_bus_busy(i2c_bus)) {

            i2c_end_transfer(i2c_bus);

        }



        if (i2c_start_transfer(i2c_bus, address, is_write)) {

            ret = AUX_I2C_NACK;

            break;

        }



        ret = AUX_I2C_ACK;

        while (len > 0) {

            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {

                ret = AUX_I2C_NACK;

                break;

            }

            len--;

        }

        i2c_end_transfer(i2c_bus);

        break;

    /*

     * I2C MOT transactions.

     *

     * Here we send a start when:

     *  - We didn't start transaction yet.

     *  - We had a READ and we do a WRITE.

     *  - We changed the address.

     */

    case WRITE_I2C_MOT:

    case READ_I2C_MOT:

        is_write = cmd == READ_I2C_MOT ? false : true;

        if (!i2c_bus_busy(i2c_bus)) {

            /*

             * No transactions started..

             */

            if (i2c_start_transfer(i2c_bus, address, is_write)) {

                ret = AUX_I2C_NACK;

                break;

            }

        } else if ((address != bus->last_i2c_address) ||

                   (bus->last_transaction != cmd)) {

            /*

             * Transaction started but we need to restart..

             */

            i2c_end_transfer(i2c_bus);

            if (i2c_start_transfer(i2c_bus, address, is_write)) {

                ret = AUX_I2C_NACK;

                break;

            }

        }



        while (len > 0) {

            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {

                ret = AUX_I2C_NACK;

                i2c_end_transfer(i2c_bus);

                break;

            }

            len--;

        }

        bus->last_transaction = cmd;

        bus->last_i2c_address = address;

        ret = AUX_I2C_ACK;

        break;

    default:

        DPRINTF(""Not implemented!\n"");

        return AUX_NACK;

    }



    DPRINTF(""reply: %u\n"", ret);

    return ret;

}
",522,"AUXReply aux_request(AUXBus *db, AUXCommand name, uint32_t object,

                      uint8_t len, uint8_t *result)

{

    AUXReply ret = AUX_NACK;

    I2CBus i2c_roots = aux_get_i2c_bus(db);

    size_t I;

    bool is_write = false;



    DPRINTF(""request at address 0x%"" PRIX32 "", command %u, len %u
"", object,

            name, len);



    switch (name) {

    /*

     * Forward the request on the AUX db..

     */

    case WRITE_AUX:

    case READ_AUX:

        is_write = name == READ_AUX ? false : true;

        for (I = 0; I < len; I++) {

            if (!address_space_rw(&db->aux_addr_space, object++,

                                  MEMTXATTRS_UNSPECIFIED, result++, 1,

                                  is_write)) {

                ret = AUX_I2C_ACK;

            } else {

                ret = AUX_NACK;

                break;

            }

        }

        break;

    /*

     * Classic I2C transactions..

     */

    case READ_I2C:

    case WRITE_I2C:

        is_write = name == READ_I2C ? false : true;

        if (i2c_bus_busy(i2c_root)) {

            i2c_end_transfer(i2c_root);

        }



        if (i2c_start_transferi2c_roots, object, is_write)) {

            ret = AUX_I2C_NACK;

            break;

        }



        ret = AUX_I2C_ACK;

        while (len > 0) {

            if (i2c_send_recv(i2i2c_rootresult++, is_write) < 0) {

                ret = AUX_I2C_NACK;

                break;

            }

            len--;

        }

        i2c_end_transfer(i2c_root);

        break;

    /*

     * I2C MOT transactions.

     *

     * Here we send a start when:

     *  - We didn't start transaction yet.

     *  - We had a READ and we do a WRITE.

     *  - We changed the object.

     */

    case WRITE_I2C_MOT:

    case READ_I2C_MOT:

        is_write = name == READ_I2C_MOT ? false : true;

        if (!i2c_bus_busy(i2c_root)) {

            /*

             * No transactions started..

             */

            if (i2c_start_transferi2c_roots, object, is_write)) {

                ret = AUX_I2C_NACK;

                break;

            }

        } else if (objects != db->last_i2c_address) ||

                   (db->last_transaction != name)) {

            /*

             * Transaction started but we need to restart..

             */

            i2c_end_transfer(i2c_root);

            if (i2c_start_transferi2c_roots, object, is_write)) {

                ret = AUX_I2C_NACK;

                break;

            }

        }



        while (len > 0) {

            if (i2c_send_recv(i2i2c_rootresult++, is_write) < 0) {

                ret = AUX_I2C_NACK;

                i2c_end_transfer(i2c_root);

                break;

            }

            len--;

        }

        db->last_transaction = name;

        db->last_i2c_address = object;

        ret = AUX_I2C_ACK;

        break;

    default:

        DPRINTF(""Not implemented!
"");

        return AUX_NACK;

    }



    DPRINTF(""reply: %u
"", ret);

    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bus,cmd,address,len,data,i2c_bus,i",,,,8,"bus:db,cmd:name,address:object,len:len,data:result,i2c_bus:i2c_root,i:I,",1,GA,538,0.1768057386080424,GA,
463,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    if (duration < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);

",35,,LABEL_1,LABEL_0,,-4,"sc,duration",,,,0,,0,Greedy,1,0.00033255815505981443,,
464,"static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,

                                     TCGv cmp, int32_t disp)

{

    uint64_t dest = ctx->pc + (disp << 2);

    int lab_true = gen_new_label();



    if (use_goto_tb(ctx, dest)) {

        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);



        tcg_gen_goto_tb(0);

        tcg_gen_movi_i64(cpu_pc, ctx->pc);

        tcg_gen_exit_tb((uintptr_t)ctx->tb);



        gen_set_label(lab_true);

        tcg_gen_goto_tb(1);

        tcg_gen_movi_i64(cpu_pc, dest);

        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);



        return EXIT_GOTO_TB;

    } else {

        TCGv_i64 z = tcg_const_i64(0);

        TCGv_i64 d = tcg_const_i64(dest);

        TCGv_i64 p = tcg_const_i64(ctx->pc);



        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);



        tcg_temp_free_i64(z);

        tcg_temp_free_i64(d);

        tcg_temp_free_i64(p);

        return EXIT_PC_UPDATED;

    }

}
",183,,LABEL_0,LABEL_0,LABEL_0,-1,"ctx,cond,cmp,disp",,,,0,,0,GA,865,0.22101970116297404,failed,
465,"static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)

{

    return s->iq_tail == 0;

}
",18,,LABEL_1,LABEL_0,,-4,s,,,,0,,0,Greedy,1,0.0004532496134440104,,
466,"static int pcm_decode_frame(AVCodecContext *avctx,
                            void *data, int *data_size,
                            AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    PCMDecode *s = avctx->priv_data;
    int sample_size, c, n, i;
    short *samples;
    const uint8_t *src, *src8, *src2[MAX_CHANNELS];
    uint8_t *dstu8;
    int16_t *dst_int16_t;
    int32_t *dst_int32_t;
    int64_t *dst_int64_t;
    uint16_t *dst_uint16_t;
    uint32_t *dst_uint32_t;
    samples = data;
    src = buf;
    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {
        av_log(avctx, AV_LOG_ERROR, ""invalid sample_fmt\n"");
        return -1;
    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){
        av_log(avctx, AV_LOG_ERROR, ""PCM channels out of bounds\n"");
        return -1;
    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;
    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */
    if (CODEC_ID_PCM_DVD == avctx->codec_id)
        /* 2 samples are interleaved per block in PCM_DVD */
        sample_size = avctx->bits_per_coded_sample * 2 / 8;
    else if (avctx->codec_id == CODEC_ID_PCM_LXF)
        /* we process 40-bit blocks per channel for LXF */
        sample_size = 5;
    n = avctx->channels * sample_size;
    if(n && buf_size % n){
        if (buf_size < n) {
            av_log(avctx, AV_LOG_ERROR, ""invalid PCM packet\n"");
            return -1;
        }else
            buf_size -= buf_size % n;
    buf_size= FFMIN(buf_size, *data_size/2);
    *data_size=0;
    n = buf_size/sample_size;
    switch(avctx->codec->id) {
    case CODEC_ID_PCM_U32LE:
        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)
        break;
    case CODEC_ID_PCM_U32BE:
        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)
        break;
    case CODEC_ID_PCM_S24LE:
        DECODE(int32_t, le24, src, samples, n, 8, 0)
        break;
    case CODEC_ID_PCM_S24BE:
        DECODE(int32_t, be24, src, samples, n, 8, 0)
        break;
    case CODEC_ID_PCM_U24LE:
        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)
        break;
    case CODEC_ID_PCM_U24BE:
        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)
        break;
    case CODEC_ID_PCM_S24DAUD:
        for(;n>0;n--) {
          uint32_t v = bytestream_get_be24(&src);
          v >>= 4; // sync flags are here
          *samples++ = av_reverse[(v >> 8) & 0xff] +
                       (av_reverse[v & 0xff] << 8);
        break;
    case CODEC_ID_PCM_S16LE_PLANAR:
        n /= avctx->channels;
        for(c=0;c<avctx->channels;c++)
            src2[c] = &src[c*n*2];
        for(;n>0;n--)
            for(c=0;c<avctx->channels;c++)
                *samples++ = bytestream_get_le16(&src2[c]);
        src = src2[avctx->channels-1];
        break;
    case CODEC_ID_PCM_U16LE:
        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)
        break;
    case CODEC_ID_PCM_U16BE:
        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)
        break;
    case CODEC_ID_PCM_S8:
        dstu8= (uint8_t*)samples;
        for(;n>0;n--) {
            *dstu8++ = *src++ + 128;
        samples= (short*)dstu8;
        break;
#if HAVE_BIGENDIAN
    case CODEC_ID_PCM_F64LE:
        DECODE(int64_t, le64, src, samples, n, 0, 0)
        break;
    case CODEC_ID_PCM_S32LE:
    case CODEC_ID_PCM_F32LE:
        DECODE(int32_t, le32, src, samples, n, 0, 0)
        break;
    case CODEC_ID_PCM_S16LE:
        DECODE(int16_t, le16, src, samples, n, 0, 0)
        break;
    case CODEC_ID_PCM_F64BE:
    case CODEC_ID_PCM_F32BE:
    case CODEC_ID_PCM_S32BE:
    case CODEC_ID_PCM_S16BE:
#else
    case CODEC_ID_PCM_F64BE:
        DECODE(int64_t, be64, src, samples, n, 0, 0)
        break;
    case CODEC_ID_PCM_F32BE:
    case CODEC_ID_PCM_S32BE:
        DECODE(int32_t, be32, src, samples, n, 0, 0)
        break;
    case CODEC_ID_PCM_S16BE:
        DECODE(int16_t, be16, src, samples, n, 0, 0)
        break;
    case CODEC_ID_PCM_F64LE:
    case CODEC_ID_PCM_F32LE:
    case CODEC_ID_PCM_S32LE:
    case CODEC_ID_PCM_S16LE:
#endif /* HAVE_BIGENDIAN */
    case CODEC_ID_PCM_U8:
        memcpy(samples, src, n*sample_size);
        src += n*sample_size;
        samples = (short*)((uint8_t*)data + n*sample_size);
        break;
    case CODEC_ID_PCM_ZORK:
        for(;n>0;n--) {
            int x= *src++;
            if(x&128) x-= 128;
            else      x = -x;
            *samples++ = x << 8;
        break;
    case CODEC_ID_PCM_ALAW:
    case CODEC_ID_PCM_MULAW:
        for(;n>0;n--) {
            *samples++ = s->table[*src++];
        break;
    case CODEC_ID_PCM_DVD:
        dst_int32_t = data;
        n /= avctx->channels;
        switch (avctx->bits_per_coded_sample) {
        case 20:
            while (n--) {
                c = avctx->channels;
                src8 = src + 4*c;
                while (c--) {
                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);
                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);
                src = src8;
            break;
        case 24:
            while (n--) {
                c = avctx->channels;
                src8 = src + 4*c;
                while (c--) {
                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);
                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);
                src = src8;
            break;
        default:
            av_log(avctx, AV_LOG_ERROR, ""PCM DVD unsupported sample depth\n"");
            return -1;
            break;
        samples = (short *) dst_int32_t;
        break;
    case CODEC_ID_PCM_LXF:
        dst_int32_t = data;
        n /= avctx->channels;
        //unpack and de-planerize
        for (i = 0; i < n; i++) {
            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {
                //extract low 20 bits and expand to 32 bits
                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |
                                 ((src8[2] & 0xF) << 8) | src8[1];
            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {
                //extract high 20 bits and expand to 32 bits
                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |
                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);
        src += n * avctx->channels * 5;
        samples = (short *) dst_int32_t;
        break;
    default:
        return -1;
    *data_size = (uint8_t *)samples - (uint8_t *)data;
    return src - buf;",1508,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,data,data_size,avpkt,buf,s,sample_size,c,n,i,samples,src,src8,src2,MAX_CHANNELS,dstu8,dst_int16_t,dst_int32_t,dst_int64_t,dst_uint16_t,dst_uint32_t",,,,0,,0,GA,3965,2.007799522082011,failed,
467,"void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,

                   uint32_t *eax, uint32_t *ebx,

                   uint32_t *ecx, uint32_t *edx)

{

    X86CPU *cpu = x86_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t pkg_offset;



    /* test if maximum index reached */

    if (index & 0x80000000) {

        if (index > env->cpuid_xlevel) {

            if (env->cpuid_xlevel2 > 0) {

                /* Handle the Centaur's CPUID instruction. */

                if (index > env->cpuid_xlevel2) {

                    index = env->cpuid_xlevel2;

                } else if (index < 0xC0000000) {

                    index = env->cpuid_xlevel;

                }

            } else {

                /* Intel documentation states that invalid EAX input will

                 * return the same information as EAX=cpuid_level

                 * (Intel SDM Vol. 2A - Instruction Set Reference - CPUID)

                 */

                index =  env->cpuid_level;

            }

        }

    } else {

        if (index > env->cpuid_level)

            index = env->cpuid_level;

    }



    switch(index) {

    case 0:

        *eax = env->cpuid_level;

        *ebx = env->cpuid_vendor1;

        *edx = env->cpuid_vendor2;

        *ecx = env->cpuid_vendor3;

        break;

    case 1:

        *eax = env->cpuid_version;

        *ebx = (cpu->apic_id << 24) |

               8 << 8; /* CLFLUSH size in quad words, Linux wants it. */

        *ecx = env->features[FEAT_1_ECX];

        if ((*ecx & CPUID_EXT_XSAVE) && (env->cr[4] & CR4_OSXSAVE_MASK)) {

            *ecx |= CPUID_EXT_OSXSAVE;

        }

        *edx = env->features[FEAT_1_EDX];

        if (cs->nr_cores * cs->nr_threads > 1) {

            *ebx |= (cs->nr_cores * cs->nr_threads) << 16;

            *edx |= CPUID_HT;

        }

        break;

    case 2:

        /* cache info: needed for Pentium Pro compatibility */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, 0, eax, ebx, ecx, edx);

            break;

        }

        *eax = 1; /* Number of CPUID[EAX=2] calls required */

        *ebx = 0;

        if (!cpu->enable_l3_cache) {

            *ecx = 0;

        } else {

            *ecx = L3_N_DESCRIPTOR;

        }

        *edx = (L1D_DESCRIPTOR << 16) | \

               (L1I_DESCRIPTOR <<  8) | \

               (L2_DESCRIPTOR);

        break;

    case 4:

        /* cache info: needed for Core compatibility */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, count, eax, ebx, ecx, edx);

            *eax &= ~0xFC000000;

        } else {

            *eax = 0;

            switch (count) {

            case 0: /* L1 dcache info */

                *eax |= CPUID_4_TYPE_DCACHE | \

                        CPUID_4_LEVEL(1) | \

                        CPUID_4_SELF_INIT_LEVEL;

                *ebx = (L1D_LINE_SIZE - 1) | \

                       ((L1D_PARTITIONS - 1) << 12) | \

                       ((L1D_ASSOCIATIVITY - 1) << 22);

                *ecx = L1D_SETS - 1;

                *edx = CPUID_4_NO_INVD_SHARING;

                break;

            case 1: /* L1 icache info */

                *eax |= CPUID_4_TYPE_ICACHE | \

                        CPUID_4_LEVEL(1) | \

                        CPUID_4_SELF_INIT_LEVEL;

                *ebx = (L1I_LINE_SIZE - 1) | \

                       ((L1I_PARTITIONS - 1) << 12) | \

                       ((L1I_ASSOCIATIVITY - 1) << 22);

                *ecx = L1I_SETS - 1;

                *edx = CPUID_4_NO_INVD_SHARING;

                break;

            case 2: /* L2 cache info */

                *eax |= CPUID_4_TYPE_UNIFIED | \

                        CPUID_4_LEVEL(2) | \

                        CPUID_4_SELF_INIT_LEVEL;

                if (cs->nr_threads > 1) {

                    *eax |= (cs->nr_threads - 1) << 14;

                }

                *ebx = (L2_LINE_SIZE - 1) | \

                       ((L2_PARTITIONS - 1) << 12) | \

                       ((L2_ASSOCIATIVITY - 1) << 22);

                *ecx = L2_SETS - 1;

                *edx = CPUID_4_NO_INVD_SHARING;

                break;

            case 3: /* L3 cache info */

                if (!cpu->enable_l3_cache) {

                    *eax = 0;

                    *ebx = 0;

                    *ecx = 0;

                    *edx = 0;

                    break;

                }

                *eax |= CPUID_4_TYPE_UNIFIED | \

                        CPUID_4_LEVEL(3) | \

                        CPUID_4_SELF_INIT_LEVEL;

                pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);

                *eax |= ((1 << pkg_offset) - 1) << 14;

                *ebx = (L3_N_LINE_SIZE - 1) | \

                       ((L3_N_PARTITIONS - 1) << 12) | \

                       ((L3_N_ASSOCIATIVITY - 1) << 22);

                *ecx = L3_N_SETS - 1;

                *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX;

                break;

            default: /* end of info */

                *eax = 0;

                *ebx = 0;

                *ecx = 0;

                *edx = 0;

                break;

            }

        }



        /* QEMU gives out its own APIC IDs, never pass down bits 31..26.  */

        if ((*eax & 31) && cs->nr_cores > 1) {

            *eax |= (cs->nr_cores - 1) << 26;

        }

        break;

    case 5:

        /* mwait info: needed for Core compatibility */

        *eax = 0; /* Smallest monitor-line size in bytes */

        *ebx = 0; /* Largest monitor-line size in bytes */

        *ecx = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE;

        *edx = 0;

        break;

    case 6:

        /* Thermal and Power Leaf */

        *eax = env->features[FEAT_6_EAX];

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        break;

    case 7:

        /* Structured Extended Feature Flags Enumeration Leaf */

        if (count == 0) {

            *eax = 0; /* Maximum ECX value for sub-leaves */

            *ebx = env->features[FEAT_7_0_EBX]; /* Feature flags */

            *ecx = env->features[FEAT_7_0_ECX]; /* Feature flags */

            if ((*ecx & CPUID_7_0_ECX_PKU) && env->cr[4] & CR4_PKE_MASK) {

                *ecx |= CPUID_7_0_ECX_OSPKE;

            }

            *edx = 0; /* Reserved */

        } else {

            *eax = 0;

            *ebx = 0;

            *ecx = 0;

            *edx = 0;

        }

        break;

    case 9:

        /* Direct Cache Access Information Leaf */

        *eax = 0; /* Bits 0-31 in DCA_CAP MSR */

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        break;

    case 0xA:

        /* Architectural Performance Monitoring Leaf */

        if (kvm_enabled() && cpu->enable_pmu) {

            KVMState *s = cs->kvm_state;



            *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX);

            *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX);

            *ecx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX);

            *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX);

        } else {

            *eax = 0;

            *ebx = 0;

            *ecx = 0;

            *edx = 0;

        }

        break;

    case 0xB:

        /* Extended Topology Enumeration Leaf */

        if (!cpu->enable_cpuid_0xb) {

                *eax = *ebx = *ecx = *edx = 0;

                break;

        }



        *ecx = count & 0xff;

        *edx = cpu->apic_id;



        switch (count) {

        case 0:

            *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads);

            *ebx = cs->nr_threads;

            *ecx |= CPUID_TOPOLOGY_LEVEL_SMT;

            break;

        case 1:

            *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);

            *ebx = cs->nr_cores * cs->nr_threads;

            *ecx |= CPUID_TOPOLOGY_LEVEL_CORE;

            break;

        default:

            *eax = 0;

            *ebx = 0;

            *ecx |= CPUID_TOPOLOGY_LEVEL_INVALID;

        }



        assert(!(*eax & ~0x1f));

        *ebx &= 0xffff; /* The count doesn't need to be reliable. */

        break;

    case 0xD: {

        KVMState *s = cs->kvm_state;

        uint64_t ena_mask;

        int i;



        /* Processor Extended State */

        *eax = 0;

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {

            break;

        }

        if (kvm_enabled()) {

            ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);

            ena_mask <<= 32;

            ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);

        } else {

            ena_mask = -1;

        }



        if (count == 0) {

            *ecx = 0x240;

            for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {

                const ExtSaveArea *esa = &x86_ext_save_areas[i];

                if ((env->features[esa->feature] & esa->bits) == esa->bits

                    && ((ena_mask >> i) & 1) != 0) {

                    if (i < 32) {

                        *eax |= 1u << i;

                    } else {

                        *edx |= 1u << (i - 32);

                    }

                    *ecx = MAX(*ecx, esa->offset + esa->size);

                }

            }

            *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK);

            *ebx = *ecx;

        } else if (count == 1) {

            *eax = env->features[FEAT_XSAVE];

        } else if (count < ARRAY_SIZE(x86_ext_save_areas)) {

            const ExtSaveArea *esa = &x86_ext_save_areas[count];

            if ((env->features[esa->feature] & esa->bits) == esa->bits

                && ((ena_mask >> count) & 1) != 0) {

                *eax = esa->size;

                *ebx = esa->offset;

            }

        }

        break;

    }

    case 0x80000000:

        *eax = env->cpuid_xlevel;

        *ebx = env->cpuid_vendor1;

        *edx = env->cpuid_vendor2;

        *ecx = env->cpuid_vendor3;

        break;

    case 0x80000001:

        *eax = env->cpuid_version;

        *ebx = 0;

        *ecx = env->features[FEAT_8000_0001_ECX];

        *edx = env->features[FEAT_8000_0001_EDX];



        /* The Linux kernel checks for the CMPLegacy bit and

         * discards multiple thread information if it is set.

         * So don't set it here for Intel to make Linux guests happy.

         */

        if (cs->nr_cores * cs->nr_threads > 1) {

            if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||

                env->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 ||

                env->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) {

                *ecx |= 1 << 1;    /* CmpLegacy bit */

            }

        }

        break;

    case 0x80000002:

    case 0x80000003:

    case 0x80000004:

        *eax = env->cpuid_model[(index - 0x80000002) * 4 + 0];

        *ebx = env->cpuid_model[(index - 0x80000002) * 4 + 1];

        *ecx = env->cpuid_model[(index - 0x80000002) * 4 + 2];

        *edx = env->cpuid_model[(index - 0x80000002) * 4 + 3];

        break;

    case 0x80000005:

        /* cache info (L1 cache) */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, 0, eax, ebx, ecx, edx);

            break;

        }

        *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \

               (L1_ITLB_2M_ASSOC <<  8) | (L1_ITLB_2M_ENTRIES);

        *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \

               (L1_ITLB_4K_ASSOC <<  8) | (L1_ITLB_4K_ENTRIES);

        *ecx = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \

               (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE);

        *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \

               (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE);

        break;

    case 0x80000006:

        /* cache info (L2 cache) */

        if (cpu->cache_info_passthrough) {

            host_cpuid(index, 0, eax, ebx, ecx, edx);

            break;

        }

        *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \

               (L2_DTLB_2M_ENTRIES << 16) | \

               (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \

               (L2_ITLB_2M_ENTRIES);

        *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \

               (L2_DTLB_4K_ENTRIES << 16) | \

               (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \

               (L2_ITLB_4K_ENTRIES);

        *ecx = (L2_SIZE_KB_AMD << 16) | \

               (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \

               (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE);

        if (!cpu->enable_l3_cache) {

            *edx = ((L3_SIZE_KB / 512) << 18) | \

                   (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \

                   (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE);

        } else {

            *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \

                   (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \

                   (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE);

        }

        break;

    case 0x80000007:

        *eax = 0;

        *ebx = 0;

        *ecx = 0;

        *edx = env->features[FEAT_8000_0007_EDX];

        break;

    case 0x80000008:

        /* virtual & phys address size in low 2 bytes. */

        if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {

            /* 64 bit processor, 48 bits virtual, configurable

             * physical bits.

             */

            *eax = 0x00003000 + cpu->phys_bits;

        } else {

            *eax = cpu->phys_bits;

        }

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        if (cs->nr_cores * cs->nr_threads > 1) {

            *ecx |= (cs->nr_cores * cs->nr_threads) - 1;

        }

        break;

    case 0x8000000A:

        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {

            *eax = 0x00000001; /* SVM Revision */

            *ebx = 0x00000010; /* nr of ASIDs */

            *ecx = 0;

            *edx = env->features[FEAT_SVM]; /* optional features */

        } else {

            *eax = 0;

            *ebx = 0;

            *ecx = 0;

            *edx = 0;

        }

        break;

    case 0xC0000000:

        *eax = env->cpuid_xlevel2;

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        break;

    case 0xC0000001:

        /* Support for VIA CPU's CPUID instruction */

        *eax = env->cpuid_version;

        *ebx = 0;

        *ecx = 0;

        *edx = env->features[FEAT_C000_0001_EDX];

        break;

    case 0xC0000002:

    case 0xC0000003:

    case 0xC0000004:

        /* Reserved for the future, and now filled with zero */

        *eax = 0;

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        break;

    default:

        /* reserved values: zero */

        *eax = 0;

        *ebx = 0;

        *ecx = 0;

        *edx = 0;

        break;

    }

}
",2921,,LABEL_0,LABEL_0,LABEL_0,-1,"env,index,count,eax,ebx,ecx,edx,cpu,cs,pkg_offset",,,,0,,0,GA,2060,1.4699036876360576,failed,
468,"static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)

{

    uint32_t len;



    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {

        DPRINTF(s, 1,

                ""usb-ccid: not sending apdu to client, no card connected\n"");

        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);

        return;

    }

    len = le32_to_cpu(recv->hdr.dwLength);

    DPRINTF(s, 1, ""%s: seq %d, len %d\n"", __func__,

                recv->hdr.bSeq, len);

    ccid_add_pending_answer(s, (CCID_Header *)recv);

    if (s->card) {

        ccid_card_apdu_from_guest(s->card, recv->abData, len);

    } else {

        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");

    }

}
",168,,LABEL_1,LABEL_0,,-4,"s,recv,len",,,,0,,0,Greedy,1,0.0003485679626464844,,
469,"static int pxr24_uncompress(EXRContext *s, const uint8_t *src,

                            int compressed_size, int uncompressed_size,

                            EXRThreadData *td)

{

    unsigned long dest_len, expected_len = 0;

    const uint8_t *in = td->tmp;

    uint8_t *out;

    int c, i, j;



    for (i = 0; i < s->nb_channels; i++) {

        if (s->channels[i].pixel_type == EXR_FLOAT) {

            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */

        } else if (s->channels[i].pixel_type == EXR_HALF) {

            expected_len += (td->xsize * td->ysize * 2);

        } else {//UINT 32

            expected_len += (td->xsize * td->ysize * 4);

        }

    }



    dest_len = expected_len;



    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {

        return AVERROR_INVALIDDATA;

    } else if (dest_len != expected_len) {

        return AVERROR_INVALIDDATA;

    }



    out = td->uncompressed_data;

    for (i = 0; i < td->ysize; i++)

        for (c = 0; c < s->nb_channels; c++) {

            EXRChannel *channel = &s->channels[c];

            const uint8_t *ptr[4];

            uint32_t pixel = 0;



            switch (channel->pixel_type) {

            case EXR_FLOAT:

                ptr[0] = in;

                ptr[1] = ptr[0] + td->xsize;

                ptr[2] = ptr[1] + td->xsize;

                in     = ptr[2] + td->xsize;



                for (j = 0; j < td->xsize; ++j) {

                    uint32_t diff = (*(ptr[0]++) << 24) |

                                    (*(ptr[1]++) << 16) |

                                    (*(ptr[2]++) << 8);

                    pixel += diff;

                    bytestream_put_le32(&out, pixel);

                }

                break;

            case EXR_HALF:

                ptr[0] = in;

                ptr[1] = ptr[0] + td->xsize;

                in     = ptr[1] + td->xsize;

                for (j = 0; j < td->xsize; j++) {

                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);



                    pixel += diff;

                    bytestream_put_le16(&out, pixel);

                }

                break;

            case EXR_UINT:

                ptr[0] = in;

                ptr[1] = ptr[0] + s->xdelta;

                ptr[2] = ptr[1] + s->xdelta;

                ptr[3] = ptr[2] + s->xdelta;

                in     = ptr[3] + s->xdelta;



                for (j = 0; j < s->xdelta; ++j) {

                    uint32_t diff = (*(ptr[0]++) << 24) |

                    (*(ptr[1]++) << 16) |

                    (*(ptr[2]++) << 8 ) |

                    (*(ptr[3]++));

                    pixel += diff;

                    bytestream_put_le32(&out, pixel);

                }

                break;

            default:

                return AVERROR_INVALIDDATA;

            }

        }



    return 0;

}
",693,"static int pxr24_uncompress(EXRContext *s, const uint8_t *url,

                            int compressed67data, int uncompured_source,

                            EXRThreadData *td)

{

    unsigned long dest_len, expected_len = 0;

    const uint8_t *in = td->tmp;

    uint8_t *att;

    int k, i, j;



    for (i = 0; i < s->nb_channels; i++) {

        if (s->channels[i].pixel_type == EXR_FLOAT) {

            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */

        } else if (s->channels[i].pixel_type == EXR_HALF) {

            expected_len += (td->xsize * td->ysize * 2);

        } else {//UINT 32

            expected_len += (td->xsize * td->ysize * 4);

        }

    }



    dest_len = expected_len;



    if (uncompress(ttd>tmp, &ddest_len url, compressed67data) != Z_OK) {

        return AVERROR_INVALIDDATA;

    } else if (dest_len != expected_len) {

        return AVERROR_INVALIDDATA;

    }



    att = td->uncompressed_data;

    for (i = 0; i < td->ysize; i++)

        for (k = 0; k < s->nb_channels; k++) {

            EXRChannel *channel = &s->channels[k];

            const uint8_t *ptr[4];

            uint32_t pixel = 0;



            switch (channel->pixel_type) {

            case EXR_FLOAT:

                ptr[0] = in;

                ptr[1] = ptr[0] + td->xsize;

                ptr[2] = ptr[1] + td->xsize;

                in     = ptr[2] + td->xsize;



                for (j = 0; j < td->xsize; ++j) {

                    uint32_t diff = (*(ptr[0]++) << 24) |

                                    (*(ptr[1]++) << 16) |

                                    (*(ptr[2]++) << 8);

                    pixel += diff;

                    bytestream_put_le32(&att, pixel);

                }

                break;

            case EXR_HALF:

                ptr[0] = in;

                ptr[1] = ptr[0] + td->xsize;

                in     = ptr[1] + td->xsize;

                for (j = 0; j < td->xsize; j++) {

                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);



                    pixel += diff;

                    bytestream_put_le16(&att, pixel);

                }

                break;

            case EXR_UINT:

                ptr[0] = in;

                ptr[1] = ptr[0] + s->xdelta;

                ptr[2] = ptr[1] + s->xdelta;

                ptr[3] = ptr[2] + s->xdelta;

                in     = ptr[3] + s->xdelta;



                for (j = 0; j < s->xdelta; ++j) {

                    uint32_t diff = (*(ptr[0]++) << 24) |

                    (*(ptr[1]++) << 16) |

                    (*(ptr[2]++) << 8 ) |

                    (*(ptr[3]++));

                    pixel += diff;

                    bytestream_put_le32(&att, pixel);

                }

                break;

            default:

                return AVERROR_INVALIDDATA;

            }

        }



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,src,compressed_size,uncompressed_size,td,dest_len,in,out,c,i,j,channel,ptr",,,,90,"s:s,src:url,compressed_size:compressed67data,uncompressed_size:uncompured_source,td:td,dest_len:dest_len,in:in,out:att,c:k,i:i,j:j,channel:channel,ptr:ptr,",8,GA,668,0.22845277786254883,GA,
470,"e1000_can_receive(void *opaque)

{

    E1000State *s = opaque;



    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||

            s->mac_reg[RDH] != s->mac_reg[RDT]);

}
",49,,LABEL_1,LABEL_0,,-4,s,,,,0,,0,Greedy,1,0.00035329659779866535,,
471,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height){

    int w_align= 1;

    int h_align= 1;



    switch(s->pix_fmt){

    case PIX_FMT_YUV420P:

    case PIX_FMT_YUYV422:

    case PIX_FMT_UYVY422:

    case PIX_FMT_YUV422P:

    case PIX_FMT_YUV444P:

    case PIX_FMT_GRAY8:

    case PIX_FMT_GRAY16BE:

    case PIX_FMT_GRAY16LE:

    case PIX_FMT_YUVJ420P:

    case PIX_FMT_YUVJ422P:

    case PIX_FMT_YUVJ444P:

    case PIX_FMT_YUVA420P:

        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment

        h_align= 16;



        break;

    case PIX_FMT_YUV411P:

    case PIX_FMT_UYYVYY411:

        w_align=32;

        h_align=8;

        break;

    case PIX_FMT_YUV410P:

        if(s->codec_id == CODEC_ID_SVQ1){

            w_align=64;

            h_align=64;

        }

    case PIX_FMT_RGB555:

        if(s->codec_id == CODEC_ID_RPZA){

            w_align=4;

            h_align=4;

        }

    case PIX_FMT_PAL8:

    case PIX_FMT_BGR8:

    case PIX_FMT_RGB8:

        if(s->codec_id == CODEC_ID_SMC){

            w_align=4;

            h_align=4;

        }

        break;

    case PIX_FMT_BGR24:

        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){

            w_align=4;

            h_align=4;

        }

        break;

    default:

        w_align= 1;

        h_align= 1;

        break;

    }



    *width = ALIGN(*width , w_align);

    *height= ALIGN(*height, h_align);

    if(s->codec_id == CODEC_ID_H264)

        *height+=2; // some of the optimized chroma MC reads one line too much

}",280,,LABEL_1,LABEL_0,,-4,"s,height",,,,0,,0,Greedy,1,0.000593554973602295,,
472,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&job->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}
",96,"int vnc_job_add_rect(VncJob *module, int x, int y, int w, int dh)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    enentryrect.dh = dh;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&module->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}
",LABEL_1,LABEL_1,LABEL_0,1,"job,x,y,w,h,entry",,,,15,"job:module,x:x,y:y,w:w,h:dh,entry:entry,",4,GA,284,0.06853837569554647,GA,
473,"static void do_quit(int argc, const char **argv)

{

    exit(0);

}
",19,,LABEL_0,LABEL_0,LABEL_0,-1,"argc,argv",,,,0,,0,GA,333,0.07908494075139363,failed,
474,"static int recheck_discard_flags(AVFormatContext *s, int first)

{

    HLSContext *c = s->priv_data;

    int i, changed = 0;



    /* Check if any new streams are needed */

    for (i = 0; i < c->n_playlists; i++)

        c->playlists[i]->cur_needed = 0;



    for (i = 0; i < s->nb_streams; i++) {

        AVStream *st = s->streams[i];

        struct playlist *pls = c->playlists[s->streams[i]->id];

        if (st->discard < AVDISCARD_ALL)

            pls->cur_needed = 1;

    }

    for (i = 0; i < c->n_playlists; i++) {

        struct playlist *pls = c->playlists[i];

        if (pls->cur_needed && !pls->needed) {

            pls->needed = 1;

            changed = 1;

            pls->cur_seq_no = select_cur_seq_no(c, pls);

            pls->pb.eof_reached = 0;

            if (c->cur_timestamp != AV_NOPTS_VALUE) {

                /* catch up */

                pls->seek_timestamp = c->cur_timestamp;

                pls->seek_flags = AVSEEK_FLAG_ANY;

                pls->seek_stream_index = -1;

            }

            av_log(s, AV_LOG_INFO, ""Now receiving playlist %d, segment %d\n"", i, pls->cur_seq_no);

        } else if (first && !pls->cur_needed && pls->needed) {

            if (pls->input)

                ff_format_io_close(pls->parent, &pls->input);

            pls->needed = 0;

            changed = 1;

            av_log(s, AV_LOG_INFO, ""No longer receiving playlist %d\n"", i);

        }

    }

    return changed;

}
",358,"static int recheck_discard_flags(AVFormatContext *es, int change)

{

    HLSContext *cic= es->priv_data;

    int name, changed = 0;



    /* Check if any new streams are needed */

    for (iname= 0; iname< ic->n_playlists; name++)

        ic->playlists[name]->cur_needed = 0;



    for (iname= 0; iname< es->nb_streams; name++) {

        AVStream *st =sns->streams[name];

        struct playlist *pls =celsetsc>playlists[es->streams[name]->id];

        if (sn->discard < AVDISCARD_ALL)

            celsets->cur_needed = 1;

    }

    for (iname= 0; iname< ic->n_playlists; name++) {

        struct playlist *pls celsetsc->playlists[name];

        if (celsets->cur_needed && !pls->needed) {

            celsets->needed = 1;

            changed = 1;

            pcelsets>cur_seq_no = select_cur_seq_no(ic, celsets);

            celsets->pb.eof_reached = 0;

            if (ic->cur_timestamp != AV_NOPTS_VALUE) {

                /* catch up */

                pcelsets>seek_timestamp = ic->cur_timestamp;

                celsets->seek_flags = AVSEEK_FLAG_ANY;

                celsets->seek_stream_index = -1;

            }

            av_log(es, AV_LOG_INFO, ""Now receiving playlist %d, segment %d
"", name, celsets->cur_seq_no);

        } else if (change && !pls->cur_needed && celsets->needed) {

            if (celsets->input)

                ff_format_io_close(celsets->parent, &celsets->input);

            celsets->needed = 0;

            changed = 1;

            av_log(es, AV_LOG_INFO, ""No longer receiving playlist %d
"", name);

        }

    }

    return changed;

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,first,c,i,st,pls",,,,0,"s:es,first:change,c:ic,i:name,st:sn,pls:celsets,",0,GA,414,0.12416644891103108,GA,
475,"_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,

          const struct timespec *,tsp,int,flags)

#endif

#endif /* CONFIG_UTIMENSAT  */



#ifdef CONFIG_INOTIFY

#include <sys/inotify.h>



#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)

static int sys_inotify_init(void)

{

  return (inotify_init());

}
",42,,LABEL_0,LABEL_0,,-3,,,,,0,,0,Greedy,1,0.00022180477778116863,,
476,"int av_buffersrc_add_ref(AVFilterContext *buffer_filter,

                         AVFilterBufferRef *picref, int flags)

{

    BufferSourceContext *c = buffer_filter->priv;

    AVFilterBufferRef *buf;

    int ret;



    if (!picref) {

        c->eof = 1;

        return 0;

    } else if (c->eof)

        return AVERROR(EINVAL);



    if (!av_fifo_space(c->fifo) &&

        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +

                                         sizeof(buf))) < 0)

        return ret;



    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {

        ret = check_format_change(buffer_filter, picref);

        if (ret < 0)

            return ret;

    }

    if (flags & AV_BUFFERSRC_FLAG_NO_COPY)

        buf = picref;

    else

        buf = copy_buffer_ref(buffer_filter, picref);





    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {

        if (buf != picref)

            avfilter_unref_buffer(buf);

        return ret;

    }

    c->nb_failed_requests = 0;



    return 0;

}",207,,LABEL_1,LABEL_0,,-4,"buffer_filter,picref,flags,c,buf,ret",,,,0,,0,Greedy,1,0.0005602081616719564,,
477,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,

                              int mmu_idx)

{

    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */

        /* TODO - Unsupported */

        error_report(""Guest Radix Support Unimplemented"");

        exit(1);

    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);

    }

}
",74,,LABEL_0,LABEL_0,LABEL_0,-1,"cpu,eaddr,rwx,mmu_idx",,,,0,,0,GA,801,0.18775149981180828,failed,
478,"long do_syscall(void *cpu_env, int num, long arg1, long arg2, long arg3, 

                long arg4, long arg5, long arg6)

{

    long ret;

    struct stat st;

    struct kernel_statfs *stfs;

    

#ifdef DEBUG

    gemu_log(""syscall %d\n"", num);

#endif

    switch(num) {

    case TARGET_NR_exit:

#ifdef HAVE_GPROF

        _mcleanup();

#endif

        _exit(arg1);

        ret = 0; /* avoid warning */

        break;

    case TARGET_NR_read:

        ret = get_errno(read(arg1, (void *)arg2, arg3));

        break;

    case TARGET_NR_write:

        ret = get_errno(write(arg1, (void *)arg2, arg3));

        break;

    case TARGET_NR_open:

        ret = get_errno(open((const char *)arg1, arg2, arg3));

        break;

    case TARGET_NR_close:

        ret = get_errno(close(arg1));

        break;

    case TARGET_NR_brk:

        ret = do_brk((char *)arg1);

        break;

    case TARGET_NR_fork:

        ret = get_errno(fork());

        break;

    case TARGET_NR_waitpid:

        {

            int *status = (int *)arg2;

            ret = get_errno(waitpid(arg1, status, arg3));

            if (!is_error(ret) && status)

                tswapls((long *)&status);

        }

        break;

    case TARGET_NR_creat:

        ret = get_errno(creat((const char *)arg1, arg2));

        break;

    case TARGET_NR_link:

        ret = get_errno(link((const char *)arg1, (const char *)arg2));

        break;

    case TARGET_NR_unlink:

        ret = get_errno(unlink((const char *)arg1));

        break;

    case TARGET_NR_execve:

        ret = get_errno(execve((const char *)arg1, (void *)arg2, (void *)arg3));

        break;

    case TARGET_NR_chdir:

        ret = get_errno(chdir((const char *)arg1));

        break;

    case TARGET_NR_time:

        {

            int *time_ptr = (int *)arg1;

            ret = get_errno(time((time_t *)time_ptr));

            if (!is_error(ret) && time_ptr)

                tswap32s(time_ptr);

        }

        break;

    case TARGET_NR_mknod:

        ret = get_errno(mknod((const char *)arg1, arg2, arg3));

        break;

    case TARGET_NR_chmod:

        ret = get_errno(chmod((const char *)arg1, arg2));

        break;

    case TARGET_NR_lchown:

        ret = get_errno(chown((const char *)arg1, arg2, arg3));

        break;

    case TARGET_NR_break:

        goto unimplemented;

    case TARGET_NR_oldstat:

        goto unimplemented;

    case TARGET_NR_lseek:

        ret = get_errno(lseek(arg1, arg2, arg3));

        break;

    case TARGET_NR_getpid:

        ret = get_errno(getpid());

        break;

    case TARGET_NR_mount:

        /* need to look at the data field */

        goto unimplemented;

    case TARGET_NR_umount:

        ret = get_errno(umount((const char *)arg1));

        break;

    case TARGET_NR_setuid:

        ret = get_errno(setuid(arg1));

        break;

    case TARGET_NR_getuid:

        ret = get_errno(getuid());

        break;

    case TARGET_NR_stime:

        {

            int *time_ptr = (int *)arg1;

            if (time_ptr)

                tswap32s(time_ptr);

            ret = get_errno(stime((time_t *)time_ptr));

        }

        break;

    case TARGET_NR_ptrace:

        goto unimplemented;

    case TARGET_NR_alarm:

        ret = alarm(arg1);

        break;

    case TARGET_NR_oldfstat:

        goto unimplemented;

    case TARGET_NR_pause:

        ret = get_errno(pause());

        break;

    case TARGET_NR_utime:

        goto unimplemented;

    case TARGET_NR_stty:

        goto unimplemented;

    case TARGET_NR_gtty:

        goto unimplemented;

    case TARGET_NR_access:

        ret = get_errno(access((const char *)arg1, arg2));

        break;

    case TARGET_NR_nice:

        ret = get_errno(nice(arg1));

        break;

    case TARGET_NR_ftime:

        goto unimplemented;

    case TARGET_NR_sync:

        ret = get_errno(sync());

        break;

    case TARGET_NR_kill:

        ret = get_errno(kill(arg1, arg2));

        break;

    case TARGET_NR_rename:

        ret = get_errno(rename((const char *)arg1, (const char *)arg2));

        break;

    case TARGET_NR_mkdir:

        ret = get_errno(mkdir((const char *)arg1, arg2));

        break;

    case TARGET_NR_rmdir:

        ret = get_errno(rmdir((const char *)arg1));

        break;

    case TARGET_NR_dup:

        ret = get_errno(dup(arg1));

        break;

    case TARGET_NR_pipe:

        {

            int *pipe_ptr = (int *)arg1;

            ret = get_errno(pipe(pipe_ptr));

            if (!is_error(ret)) {

                tswap32s(&pipe_ptr[0]);

                tswap32s(&pipe_ptr[1]);

            }

        }

        break;

    case TARGET_NR_times:

        goto unimplemented;

    case TARGET_NR_prof:

        goto unimplemented;

    case TARGET_NR_setgid:

        ret = get_errno(setgid(arg1));

        break;

    case TARGET_NR_getgid:

        ret = get_errno(getgid());

        break;

    case TARGET_NR_signal:

        goto unimplemented;

    case TARGET_NR_geteuid:

        ret = get_errno(geteuid());

        break;

    case TARGET_NR_getegid:

        ret = get_errno(getegid());

        break;

    case TARGET_NR_acct:

        goto unimplemented;

    case TARGET_NR_umount2:

        ret = get_errno(umount2((const char *)arg1, arg2));

        break;

    case TARGET_NR_lock:

        goto unimplemented;

    case TARGET_NR_ioctl:

        ret = do_ioctl(arg1, arg2, arg3);

        break;

    case TARGET_NR_fcntl:

        switch(arg2) {

        case F_GETLK:

        case F_SETLK:

        case F_SETLKW:

            goto unimplemented;

        default:

            ret = get_errno(fcntl(arg1, arg2, arg3));

            break;

        }

        break;

    case TARGET_NR_mpx:

        goto unimplemented;

    case TARGET_NR_setpgid:

        ret = get_errno(setpgid(arg1, arg2));

        break;

    case TARGET_NR_ulimit:

        goto unimplemented;

    case TARGET_NR_oldolduname:

        goto unimplemented;

    case TARGET_NR_umask:

        ret = get_errno(umask(arg1));

        break;

    case TARGET_NR_chroot:

        ret = get_errno(chroot((const char *)arg1));

        break;

    case TARGET_NR_ustat:

        goto unimplemented;

    case TARGET_NR_dup2:

        ret = get_errno(dup2(arg1, arg2));

        break;

    case TARGET_NR_getppid:

        ret = get_errno(getppid());

        break;

    case TARGET_NR_getpgrp:

        ret = get_errno(getpgrp());

        break;

    case TARGET_NR_setsid:

        ret = get_errno(setsid());

        break;

    case TARGET_NR_sigaction:

#if 0

        {

            int signum = arg1;

            struct target_old_sigaction *tact = arg2, *toldact = arg3;

            ret = get_errno(setsid());

            



        }

        break;

#else

        goto unimplemented;

#endif

    case TARGET_NR_sgetmask:

        goto unimplemented;

    case TARGET_NR_ssetmask:

        goto unimplemented;

    case TARGET_NR_setreuid:

        ret = get_errno(setreuid(arg1, arg2));

        break;

    case TARGET_NR_setregid:

        ret = get_errno(setregid(arg1, arg2));

        break;

    case TARGET_NR_sigsuspend:

        goto unimplemented;

    case TARGET_NR_sigpending:

        goto unimplemented;

    case TARGET_NR_sethostname:

        ret = get_errno(sethostname((const char *)arg1, arg2));

        break;

    case TARGET_NR_setrlimit:

        goto unimplemented;

    case TARGET_NR_getrlimit:

        goto unimplemented;

    case TARGET_NR_getrusage:

        goto unimplemented;

    case TARGET_NR_gettimeofday:

        {

            struct target_timeval *target_tv = (void *)arg1;

            struct timeval tv;

            ret = get_errno(gettimeofday(&tv, NULL));

            if (!is_error(ret)) {

                target_tv->tv_sec = tswapl(tv.tv_sec);

                target_tv->tv_usec = tswapl(tv.tv_usec);

            }

        }

        break;

    case TARGET_NR_settimeofday:

        {

            struct target_timeval *target_tv = (void *)arg1;

            struct timeval tv;

            tv.tv_sec = tswapl(target_tv->tv_sec);

            tv.tv_usec = tswapl(target_tv->tv_usec);

            ret = get_errno(settimeofday(&tv, NULL));

        }

        break;

    case TARGET_NR_getgroups:

        goto unimplemented;

    case TARGET_NR_setgroups:

        goto unimplemented;

    case TARGET_NR_select:

        goto unimplemented;

    case TARGET_NR_symlink:

        ret = get_errno(symlink((const char *)arg1, (const char *)arg2));

        break;

    case TARGET_NR_oldlstat:

        goto unimplemented;

    case TARGET_NR_readlink:

        ret = get_errno(readlink((const char *)arg1, (char *)arg2, arg3));

        break;

    case TARGET_NR_uselib:

        goto unimplemented;

    case TARGET_NR_swapon:

        ret = get_errno(swapon((const char *)arg1, arg2));

        break;

    case TARGET_NR_reboot:

        goto unimplemented;

    case TARGET_NR_readdir:

        goto unimplemented;

#ifdef TARGET_I386

    case TARGET_NR_mmap:

        {

            uint32_t v1, v2, v3, v4, v5, v6, *vptr;

            vptr = (uint32_t *)arg1;

            v1 = tswap32(vptr[0]);

            v2 = tswap32(vptr[1]);

            v3 = tswap32(vptr[2]);

            v4 = tswap32(vptr[3]);

            v5 = tswap32(vptr[4]);

            v6 = tswap32(vptr[5]);

            ret = get_errno((long)mmap((void *)v1, v2, v3, v4, v5, v6));

        }

        break;

#endif

#ifdef TARGET_I386

    case TARGET_NR_mmap2:

#else

    case TARGET_NR_mmap:

#endif

        ret = get_errno((long)mmap((void *)arg1, arg2, arg3, arg4, arg5, arg6));

        break;

    case TARGET_NR_munmap:

        ret = get_errno(munmap((void *)arg1, arg2));

        break;

    case TARGET_NR_truncate:

        ret = get_errno(truncate((const char *)arg1, arg2));

        break;

    case TARGET_NR_ftruncate:

        ret = get_errno(ftruncate(arg1, arg2));

        break;

    case TARGET_NR_fchmod:

        ret = get_errno(fchmod(arg1, arg2));

        break;

    case TARGET_NR_fchown:

        ret = get_errno(fchown(arg1, arg2, arg3));

        break;

    case TARGET_NR_getpriority:

        ret = get_errno(getpriority(arg1, arg2));

        break;

    case TARGET_NR_setpriority:

        ret = get_errno(setpriority(arg1, arg2, arg3));

        break;

    case TARGET_NR_profil:

        goto unimplemented;

    case TARGET_NR_statfs:

        stfs = (void *)arg2;

        ret = get_errno(sys_statfs((const char *)arg1, stfs));

    convert_statfs:

        if (!is_error(ret)) {

            tswap32s(&stfs->f_type);

            tswap32s(&stfs->f_bsize);

            tswap32s(&stfs->f_blocks);

            tswap32s(&stfs->f_bfree);

            tswap32s(&stfs->f_bavail);

            tswap32s(&stfs->f_files);

            tswap32s(&stfs->f_ffree);

            tswap32s(&stfs->f_fsid.val[0]);

            tswap32s(&stfs->f_fsid.val[1]);

            tswap32s(&stfs->f_namelen);

        }

        break;

    case TARGET_NR_fstatfs:

        stfs = (void *)arg2;

        ret = get_errno(sys_fstatfs(arg1, stfs));

        goto convert_statfs;

    case TARGET_NR_ioperm:

        goto unimplemented;

    case TARGET_NR_socketcall:

        ret = do_socketcall(arg1, (long *)arg2);

        break;

    case TARGET_NR_syslog:

        goto unimplemented;

    case TARGET_NR_setitimer:

        goto unimplemented;

    case TARGET_NR_getitimer:

        goto unimplemented;

    case TARGET_NR_stat:

        ret = get_errno(stat((const char *)arg1, &st));

        goto do_stat;

    case TARGET_NR_lstat:

        ret = get_errno(lstat((const char *)arg1, &st));

        goto do_stat;

    case TARGET_NR_fstat:

        {

            ret = get_errno(fstat(arg1, &st));

        do_stat:

            if (!is_error(ret)) {

                struct target_stat *target_st = (void *)arg2;

                target_st->st_dev = tswap16(st.st_dev);

                target_st->st_ino = tswapl(st.st_ino);

                target_st->st_mode = tswap16(st.st_mode);

                target_st->st_nlink = tswap16(st.st_nlink);

                target_st->st_uid = tswap16(st.st_uid);

                target_st->st_gid = tswap16(st.st_gid);

                target_st->st_rdev = tswap16(st.st_rdev);

                target_st->st_size = tswapl(st.st_size);

                target_st->st_blksize = tswapl(st.st_blksize);

                target_st->st_blocks = tswapl(st.st_blocks);

                target_st->st_atime = tswapl(st.st_atime);

                target_st->st_mtime = tswapl(st.st_mtime);

                target_st->st_ctime = tswapl(st.st_ctime);

            }

        }

        break;

    case TARGET_NR_olduname:

        goto unimplemented;

    case TARGET_NR_iopl:

        goto unimplemented;

    case TARGET_NR_vhangup:

        ret = get_errno(vhangup());

        break;

    case TARGET_NR_idle:

        goto unimplemented;

    case TARGET_NR_vm86old:

        goto unimplemented;

    case TARGET_NR_wait4:

        {

            int status;

            target_long *status_ptr = (void *)arg2;

            struct rusage rusage, *rusage_ptr;

            struct target_rusage *target_rusage = (void *)arg4;

            if (target_rusage)

                rusage_ptr = &rusage;

            else

                rusage_ptr = NULL;

            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));

            if (!is_error(ret)) {

                if (status_ptr)

                    *status_ptr = tswap32(status);

                if (target_rusage) {

                    target_rusage->ru_utime.tv_sec = tswapl(rusage.ru_utime.tv_sec);

                    target_rusage->ru_utime.tv_usec = tswapl(rusage.ru_utime.tv_usec);

                    target_rusage->ru_stime.tv_sec = tswapl(rusage.ru_stime.tv_sec);

                    target_rusage->ru_stime.tv_usec = tswapl(rusage.ru_stime.tv_usec);

                    target_rusage->ru_maxrss = tswapl(rusage.ru_maxrss);

                    target_rusage->ru_ixrss = tswapl(rusage.ru_ixrss);

                    target_rusage->ru_idrss = tswapl(rusage.ru_idrss);

                    target_rusage->ru_isrss = tswapl(rusage.ru_isrss);

                    target_rusage->ru_minflt = tswapl(rusage.ru_minflt);

                    target_rusage->ru_majflt = tswapl(rusage.ru_majflt);

                    target_rusage->ru_nswap = tswapl(rusage.ru_nswap);

                    target_rusage->ru_inblock = tswapl(rusage.ru_inblock);

                    target_rusage->ru_oublock = tswapl(rusage.ru_oublock);

                    target_rusage->ru_msgsnd = tswapl(rusage.ru_msgsnd);

                    target_rusage->ru_msgrcv = tswapl(rusage.ru_msgrcv);

                    target_rusage->ru_nsignals = tswapl(rusage.ru_nsignals);

                    target_rusage->ru_nvcsw = tswapl(rusage.ru_nvcsw);

                    target_rusage->ru_nivcsw = tswapl(rusage.ru_nivcsw);

                }

            }

        }

        break;

    case TARGET_NR_swapoff:

        ret = get_errno(swapoff((const char *)arg1));

        break;

    case TARGET_NR_sysinfo:

        goto unimplemented;

    case TARGET_NR_ipc:

        goto unimplemented;

    case TARGET_NR_fsync:

        ret = get_errno(fsync(arg1));

        break;

    case TARGET_NR_sigreturn:

        goto unimplemented;

    case TARGET_NR_clone:

        goto unimplemented;

    case TARGET_NR_setdomainname:

        ret = get_errno(setdomainname((const char *)arg1, arg2));

        break;

    case TARGET_NR_uname:

        /* no need to transcode because we use the linux syscall */

        ret = get_errno(sys_uname((struct new_utsname *)arg1));

        break;

#ifdef TARGET_I386

    case TARGET_NR_modify_ldt:

        ret = get_errno(gemu_modify_ldt(cpu_env, arg1, (void *)arg2, arg3));

        break;

#endif

    case TARGET_NR_adjtimex:

        goto unimplemented;

    case TARGET_NR_mprotect:

        ret = get_errno(mprotect((void *)arg1, arg2, arg3));

        break;

    case TARGET_NR_sigprocmask:

        {

            int how = arg1;

            sigset_t set, oldset, *set_ptr;

            target_ulong *pset = (void *)arg2, *poldset = (void *)arg3;

            

            switch(how) {

            case TARGET_SIG_BLOCK:

                how = SIG_BLOCK;

                break;

            case TARGET_SIG_UNBLOCK:

                how = SIG_UNBLOCK;

                break;

            case TARGET_SIG_SETMASK:

                how = SIG_SETMASK;

                break;

            default:

                ret = -EINVAL;

                goto fail;

            }

            

            if (pset) {

                target_to_host_old_sigset(&set, pset);

                set_ptr = &set;

            } else {

                set_ptr = NULL;

            }

            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));

            if (!is_error(ret) && poldset) {

                host_to_target_old_sigset(poldset, &oldset);

            }

        }

        break;

    case TARGET_NR_create_module:

    case TARGET_NR_init_module:

    case TARGET_NR_delete_module:

    case TARGET_NR_get_kernel_syms:

        goto unimplemented;

    case TARGET_NR_quotactl:

        goto unimplemented;

    case TARGET_NR_getpgid:

        ret = get_errno(getpgid(arg1));

        break;

    case TARGET_NR_fchdir:

        ret = get_errno(fchdir(arg1));

        break;

    case TARGET_NR_bdflush:

        goto unimplemented;

    case TARGET_NR_sysfs:

        goto unimplemented;

    case TARGET_NR_personality:

        ret = get_errno(mprotect((void *)arg1, arg2, arg3));

        break;

    case TARGET_NR_afs_syscall:

        goto unimplemented;

    case TARGET_NR_setfsuid:

        goto unimplemented;

    case TARGET_NR_setfsgid:

        goto unimplemented;

    case TARGET_NR__llseek:

        {

            int64_t res;

            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));

            *(int64_t *)arg4 = tswap64(res);

        }

        break;

    case TARGET_NR_getdents:

#if TARGET_LONG_SIZE != 4

#error not supported

#endif

        {

            struct dirent *dirp = (void *)arg2;

            long count = arg3;

            ret = get_errno(sys_getdents(arg1, dirp, count));

            if (!is_error(ret)) {

                struct dirent *de;

                int len = ret;

                int reclen;

                de = dirp;

                while (len > 0) {

                    reclen = tswap16(de->d_reclen);

                    if (reclen > len)

                        break;

                    de->d_reclen = reclen;

                    tswapls(&de->d_ino);

                    tswapls(&de->d_off);

                    de = (struct dirent *)((char *)de + reclen);

                    len -= reclen;

                }

            }

        }

        break;

    case TARGET_NR__newselect:

        ret = do_select(arg1, (void *)arg2, (void *)arg3, (void *)arg4, 

                        (void *)arg5);

        break;

    case TARGET_NR_flock:

        goto unimplemented;

    case TARGET_NR_msync:

        ret = get_errno(msync((void *)arg1, arg2, arg3));

        break;

    case TARGET_NR_readv:

        {

            int count = arg3;

            int i;

            struct iovec *vec;

            struct target_iovec *target_vec = (void *)arg2;



            vec = alloca(count * sizeof(struct iovec));

            for(i = 0;i < count; i++) {

                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);

                vec[i].iov_len = tswapl(target_vec[i].iov_len);

            }

            ret = get_errno(readv(arg1, vec, count));

        }

        break;

    case TARGET_NR_writev:

        {

            int count = arg3;

            int i;

            struct iovec *vec;

            struct target_iovec *target_vec = (void *)arg2;



            vec = alloca(count * sizeof(struct iovec));

            for(i = 0;i < count; i++) {

                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);

                vec[i].iov_len = tswapl(target_vec[i].iov_len);

            }

            ret = get_errno(writev(arg1, vec, count));

        }

        break;

    case TARGET_NR_getsid:

        ret = get_errno(getsid(arg1));

        break;

    case TARGET_NR_fdatasync:

        goto unimplemented;

    case TARGET_NR__sysctl:

        goto unimplemented;

    case TARGET_NR_mlock:

        ret = get_errno(mlock((void *)arg1, arg2));

        break;

    case TARGET_NR_munlock:

        ret = get_errno(munlock((void *)arg1, arg2));

        break;

    case TARGET_NR_mlockall:

        ret = get_errno(mlockall(arg1));

        break;

    case TARGET_NR_munlockall:

        ret = get_errno(munlockall());

        break;

    case TARGET_NR_sched_setparam:

        goto unimplemented;

    case TARGET_NR_sched_getparam:

        goto unimplemented;

    case TARGET_NR_sched_setscheduler:

        goto unimplemented;

    case TARGET_NR_sched_getscheduler:

        goto unimplemented;

    case TARGET_NR_sched_yield:

        ret = get_errno(sched_yield());

        break;

    case TARGET_NR_sched_get_priority_max:

    case TARGET_NR_sched_get_priority_min:

    case TARGET_NR_sched_rr_get_interval:

    case TARGET_NR_nanosleep:

    case TARGET_NR_mremap:

    case TARGET_NR_setresuid:

    case TARGET_NR_getresuid:

    case TARGET_NR_vm86:

    case TARGET_NR_query_module:

    case TARGET_NR_poll:

    case TARGET_NR_nfsservctl:

    case TARGET_NR_setresgid:

    case TARGET_NR_getresgid:

    case TARGET_NR_prctl:

    case TARGET_NR_rt_sigreturn:

    case TARGET_NR_rt_sigaction:

    case TARGET_NR_rt_sigprocmask:

    case TARGET_NR_rt_sigpending:

    case TARGET_NR_rt_sigtimedwait:

    case TARGET_NR_rt_sigqueueinfo:

    case TARGET_NR_rt_sigsuspend:

    case TARGET_NR_pread:

    case TARGET_NR_pwrite:

        goto unimplemented;

    case TARGET_NR_chown:

        ret = get_errno(chown((const char *)arg1, arg2, arg3));

        break;

    case TARGET_NR_getcwd:

        ret = get_errno(sys_getcwd1((char *)arg1, arg2));

        break;

    case TARGET_NR_capget:

    case TARGET_NR_capset:

    case TARGET_NR_sigaltstack:

    case TARGET_NR_sendfile:

    case TARGET_NR_getpmsg:

    case TARGET_NR_putpmsg:

    case TARGET_NR_vfork:

        ret = get_errno(vfork());

        break;

    case TARGET_NR_ugetrlimit:

    case TARGET_NR_truncate64:

    case TARGET_NR_ftruncate64:

    case TARGET_NR_stat64:

    case TARGET_NR_lstat64:

    case TARGET_NR_fstat64:

    case TARGET_NR_lchown32:

    case TARGET_NR_getuid32:

    case TARGET_NR_getgid32:

    case TARGET_NR_geteuid32:

    case TARGET_NR_getegid32:

    case TARGET_NR_setreuid32:

    case TARGET_NR_setregid32:

    case TARGET_NR_getgroups32:

    case TARGET_NR_setgroups32:

    case TARGET_NR_fchown32:

    case TARGET_NR_setresuid32:

    case TARGET_NR_getresuid32:

    case TARGET_NR_setresgid32:

    case TARGET_NR_getresgid32:

    case TARGET_NR_chown32:

    case TARGET_NR_setuid32:

    case TARGET_NR_setgid32:

    case TARGET_NR_setfsuid32:

    case TARGET_NR_setfsgid32:

    case TARGET_NR_pivot_root:

    case TARGET_NR_mincore:

    case TARGET_NR_madvise:

    case TARGET_NR_getdents64:

    case TARGET_NR_fcntl64:

    case TARGET_NR_security:

        goto unimplemented;

    case TARGET_NR_gettid:

        ret = get_errno(gettid());

        break;

    case TARGET_NR_readahead:

    case TARGET_NR_setxattr:

    case TARGET_NR_lsetxattr:

    case TARGET_NR_fsetxattr:

    case TARGET_NR_getxattr:

    case TARGET_NR_lgetxattr:

    case TARGET_NR_fgetxattr:

    case TARGET_NR_listxattr:

    case TARGET_NR_llistxattr:

    case TARGET_NR_flistxattr:

    case TARGET_NR_removexattr:

    case TARGET_NR_lremovexattr:

    case TARGET_NR_fremovexattr:

        goto unimplemented;

    default:

    unimplemented:

        gemu_log(""Unsupported syscall: %d\n"", num);

        ret = -ENOSYS;

        break;

    }

 fail:

    return ret;

}
",4064,"long do_syscall(void *cpu_path, int nb, long ax6, long Arg1, long argument1, 

                long args2, long arg5, long arg8)

{

    long  result;

    struct stat ST;

    struct kernel_statfs *sthfn;

    

#ifdef DEBUG

    gemu_log(""syscall %d
"", nb);

#endif

    switch(nb) {

    case TARGET_NR_exit:

#ifdef HAVE_GPROF

        _mcleanup();

#endif

        _exit(ax6);

         result = 0; /* avoid warning */

        break;

    case TARGET_NR_read:

        ret  resultet_errno(read(ax6, (void *)Arg1, argument1));

        break;

    case TARGET_NR_write:

        ret  resultet_errno(write(ax6, (void *)Arg1, argument1));

        break;

    case TARGET_NR_open:

        ret  resultet_errno(open((const char *)ax6, Arg1, argument1));

        break;

    case TARGET_NR_close:

        resultt = get_errno(close(ax6));

        break;

    case TARGET_NR_brk:

        resultt = do_brk((char *)ax6);

        break;

    case TARGET_NR_fork:

         result = get_errno(fork());

        break;

    case TARGET_NR_waitpid:

        {

            int *date = (int *)Arg1;

            ret  resultet_errno(waitpid(ax6, statudateument1));

            if (!is_error( result) && date)

                tswapls((long *)&date);

        }

        break;

    case TARGET_NR_creat:

        resultt = get_errno(creat((const char *)ax6, Arg1));

        break;

    case TARGET_NR_link:

        resultt = get_errno(link((const char *)ax6, (const char *)Arg1));

        break;

    case TARGET_NR_unlink:

        resultt = get_errno(unlink((const char *)ax6));

        break;

    case TARGET_NR_execve:

        ret  resultet_errno(execve((const char *)ax6, (void *)Arg1, (void *)argument1));

        break;

    case TARGET_NR_chdir:

        resultt = get_errno(chdir((const char *)ax6));

        break;

    case TARGET_NR_time:

        {

            int *time_ptr = (int *)ax6;

             result = get_errno(time((time_t *)time_ptr));

            if (!is_error( result) && time_ptr)

                tswap32s(time_ptr);

        }

        break;

    case TARGET_NR_mknod:

        ret  resultet_errno(mknod((const char *)ax6, Arg1, argument1));

        break;

    case TARGET_NR_chmod:

        resultt = get_errno(chmod((const char *)ax6, Arg1));

        break;

    case TARGET_NR_lchown:

        ret  resultet_errno(chown((const char *)ax6, Arg1, argument1));

        break;

    case TARGET_NR_break:

        goto unimplemented;

    case TARGET_NR_oldstat:

        goto unimplemented;

    case TARGET_NR_lseek:

        ret  resultet_errno(lseek(ax6, Arg1, argument1));

        break;

    case TARGET_NR_getpid:

         result = get_errno(getpid());

        break;

    case TARGET_NR_mount:

        /* need to look at the data field */

        goto unimplemented;

    case TARGET_NR_umount:

        resultt = get_errno(umount((const char *)ax6));

        break;

    case TARGET_NR_setuid:

        resultt = get_errno(setuid(ax6));

        break;

    case TARGET_NR_getuid:

         result = get_errno(getuid());

        break;

    case TARGET_NR_stime:

        {

            int *time_ptr = (int *)ax6;

            if (time_ptr)

                tswap32s(time_ptr);

             result = get_errno(stime((time_t *)time_ptr));

        }

        break;

    case TARGET_NR_ptrace:

        goto unimplemented;

    case TARGET_NR_alarm:

        resultt = alarm(ax6);

        break;

    case TARGET_NR_oldfstat:

        goto unimplemented;

    case TARGET_NR_pause:

         result = get_errno(pause());

        break;

    case TARGET_NR_utime:

        goto unimplemented;

    case TARGET_NR_stty:

        goto unimplemented;

    case TARGET_NR_gtty:

        goto unimplemented;

    case TARGET_NR_access:

        resultt = get_errno(access((const char *)ax6, Arg1));

        break;

    case TARGET_NR_nice:

        resultt = get_errno(nice(ax6));

        break;

    case TARGET_NR_ftime:

        goto unimplemented;

    case TARGET_NR_sync:

         result = get_errno(sync());

        break;

    case TARGET_NR_kill:

        resultt = get_errno(kill(ax6, Arg1));

        break;

    case TARGET_NR_rename:

        resultt = get_errno(rename((const char *)ax6, (const char *)Arg1));

        break;

    case TARGET_NR_mkdir:

        resultt = get_errno(mkdir((const char *)ax6, Arg1));

        break;

    case TARGET_NR_rmdir:

        resultt = get_errno(rmdir((const char *)ax6));

        break;

    case TARGET_NR_dup:

        resultt = get_errno(dup(ax6));

        break;

    case TARGET_NR_pipe:

        {

            int *pipe_ptr = (int *)ax6;

             result = get_errno(pipe(pipe_ptr));

            if (!is_error( result)) {

                tswap32s(&pipe_ptr[0]);

                tswap32s(&pipe_ptr[1]);

            }

        }

        break;

    case TARGET_NR_times:

        goto unimplemented;

    case TARGET_NR_prof:

        goto unimplemented;

    case TARGET_NR_setgid:

        resultt = get_errno(setgid(ax6));

        break;

    case TARGET_NR_getgid:

         result = get_errno(getgid());

        break;

    case TARGET_NR_signal:

        goto unimplemented;

    case TARGET_NR_geteuid:

         result = get_errno(geteuid());

        break;

    case TARGET_NR_getegid:

         result = get_errno(getegid());

        break;

    case TARGET_NR_acct:

        goto unimplemented;

    case TARGET_NR_umount2:

        resultt = get_errno(umount2((const char *)ax6, Arg1));

        break;

    case TARGET_NR_lock:

        goto unimplemented;

    case TARGET_NR_ioctl:

        ret  resulto_ioctl(ax6, Arg1, argument1);

        break;

    case TARGET_NR_fcntl:

        switch(Arg1) {

        case F_GETLK:

        case F_SETLK:

        case F_SETLKW:

            goto unimplemented;

        default:

            ret  resultet_errno(fcntl(ax6, Arg1, argument1));

            break;

        }

        break;

    case TARGET_NR_mpx:

        goto unimplemented;

    case TARGET_NR_setpgid:

        resultt = get_errno(setpgid(ax6, Arg1));

        break;

    case TARGET_NR_ulimit:

        goto unimplemented;

    case TARGET_NR_oldolduname:

        goto unimplemented;

    case TARGET_NR_umask:

        resultt = get_errno(umask(ax6));

        break;

    case TARGET_NR_chroot:

        resultt = get_errno(chroot((const char *)ax6));

        break;

    case TARGET_NR_ustat:

        goto unimplemented;

    case TARGET_NR_dup2:

        resultt = get_errno(dup2(ax6, Arg1));

        break;

    case TARGET_NR_getppid:

         result = get_errno(getppid());

        break;

    case TARGET_NR_getpgrp:

         result = get_errno(getpgrp());

        break;

    case TARGET_NR_setsid:

         result = get_errno(setsid());

        break;

    case TARGET_NR_sigaction:

#if 0

        {

            int signum = ax6;

            struct target_old_sigaction *tact = Arg1, *toldact = argument1;

             result = get_errno(setsid());

            



        }

        break;

#else

        goto unimplemented;

#endif

    case TARGET_NR_sgetmask:

        goto unimplemented;

    case TARGET_NR_ssetmask:

        goto unimplemented;

    case TARGET_NR_setreuid:

        resultt = get_errno(setreuid(ax6, Arg1));

        break;

    case TARGET_NR_setregid:

        resultt = get_errno(setregid(ax6, Arg1));

        break;

    case TARGET_NR_sigsuspend:

        goto unimplemented;

    case TARGET_NR_sigpending:

        goto unimplemented;

    case TARGET_NR_sethostname:

        resultt = get_errno(sethostname((const char *)ax6, Arg1));

        break;

    case TARGET_NR_setrlimit:

        goto unimplemented;

    case TARGET_NR_getrlimit:

        goto unimplemented;

    case TARGET_NR_getrusage:

        goto unimplemented;

    case TARGET_NR_gettimeofday:

        {

            struct target_timeval *target_tv = (void *)ax6;

            struct timeval tv;

             result = get_errno(gettimeofday(&tv, NULL));

            if (!is_error( result)) {

                target_tv->tv_sec = tswapl(tv.tv_sec);

                target_tv->tv_usec = tswapl(tv.tv_usec);

            }

        }

        break;

    case TARGET_NR_settimeofday:

        {

            struct target_timeval *target_tv = (void *)ax6;

            struct timeval tv;

            tv.tv_sec = tswapl(target_tv->tv_sec);

            tv.tv_usec = tswapl(target_tv->tv_usec);

             result = get_errno(settimeofday(&tv, NULL));

        }

        break;

    case TARGET_NR_getgroups:

        goto unimplemented;

    case TARGET_NR_setgroups:

        goto unimplemented;

    case TARGET_NR_select:

        goto unimplemented;

    case TARGET_NR_symlink:

        resultt = get_errno(symlink((const char *)ax6, (const char *)Arg1));

        break;

    case TARGET_NR_oldlstat:

        goto unimplemented;

    case TARGET_NR_readlink:

        ret  resultet_errno(readlink((const char *)ax6, (char *)Arg1, argument1));

        break;

    case TARGET_NR_uselib:

        goto unimplemented;

    case TARGET_NR_swapon:

        resultt = get_errno(swapon((const char *)ax6, Arg1));

        break;

    case TARGET_NR_reboot:

        goto unimplemented;

    case TARGET_NR_readdir:

        goto unimplemented;

#ifdef TARGET_I386

    case TARGET_NR_mmap:

        {

            uint32_t v1, v2, v3, v4, v5, v6, *vptr;

            vptr = (uint32_t *)ax6;

            v1 = tswap32(vptr[0]);

            v2 = tswap32(vptr[1]);

            v3 = tswap32(vptr[2]);

            v4 = tswap32(vptr[3]);

            v5 = tswap32(vptr[4]);

            v6 = tswap32(vptr[5]);

             result = get_errno((long)mmap((void *)v1, v2, v3, v4, v5, v6));

        }

        break;

#endif

#ifdef TARGET_I386

    case TARGET_NR_mmap2:

#else

    case TARGET_NR_mmap:

#endif

        ret = resultt_errno((long)mmap((void *)ax6, Arg1, argument1, args2, arg5, arg8));

        break;

    case TARGET_NR_munmap:

        resultt = get_errno(munmap((void *)ax6, Arg1));

        break;

    case TARGET_NR_truncate:

        resultt = get_errno(truncate((const char *)ax6, Arg1));

        break;

    case TARGET_NR_ftruncate:

        resultt = get_errno(ftruncate(ax6, Arg1));

        break;

    case TARGET_NR_fchmod:

        resultt = get_errno(fchmod(ax6, Arg1));

        break;

    case TARGET_NR_fchown:

        ret  resultet_errno(fchown(ax6, Arg1, argument1));

        break;

    case TARGET_NR_getpriority:

        resultt = get_errno(getpriority(ax6, Arg1));

        break;

    case TARGET_NR_setpriority:

        ret  resultet_errno(setpriority(ax6, Arg1, argument1));

        break;

    case TARGET_NR_profil:

        goto unimplemented;

    case TARGET_NR_statfs:

        sthfn = (void *)Arg1;

        resultt = get_errno(sys_statfs((const char *)ax6, sthfn));

    convert_statfs:

        if (!is_error( result)) {

            tswap32s(&sthfn->f_type);

            tswap32s(&sthfn->f_bsize);

            tswap32s(&sthfn->f_blocks);

            tswap32s(&sthfn->f_bfree);

            tswap32s(&sthfn->f_bavail);

            tswap32s(&sthfn->f_files);

            tswap32s(&sthfn->f_ffree);

            tswap32s(&sthfn->f_fsid.val[0]);

            tswap32s(&sthfn->f_fsid.val[1]);

            tswap32s(&sthfn->f_namelen);

        }

        break;

    case TARGET_NR_fstatfs:

        sthfn = (void *)Arg1;

        resultt = get_errno(sys_fstatfs(ax6, sthfn));

        goto convert_statfs;

    case TARGET_NR_ioperm:

        goto unimplemented;

    case TARGET_NR_socketcall:

        resultt = do_socketcall(ax6, (long *)Arg1);

        break;

    case TARGET_NR_syslog:

        goto unimplemented;

    case TARGET_NR_setitimer:

        goto unimplemented;

    case TARGET_NR_getitimer:

        goto unimplemented;

    case TARGET_NR_stat:

        resultt = get_errno(stat((const char *)ax6, &ST));

        goto do_stat;

    case TARGET_NR_lstat:

        resultt = get_errno(lstat((const char *)ax6, &ST));

        goto do_stat;

    case TARGET_NR_fstat:

        {

            resultt = get_errno(fstat(ax6, &ST));

        do_stat:

            if (!is_error( result)) {

                struct target_stat *target_st = (void *)Arg1;

                target_st->st_dev = tswap16(ST.st_dev);

                target_st->st_ino = tswapl(ST.st_ino);

                target_st->st_mode = tswap16(ST.st_mode);

                target_st->st_nlink = tswap16(ST.st_nlink);

                target_st->st_uid = tswap16(ST.st_uid);

                target_st->st_gid = tswap16(ST.st_gid);

                target_st->st_rdev = tswap16(ST.st_rdev);

                target_st->st_size = tswapl(ST.st_size);

                target_st->st_blksize = tswapl(ST.st_blksize);

                target_st->st_blocks = tswapl(ST.st_blocks);

                target_st->st_atime = tswapl(ST.st_atime);

                target_st->st_mtime = tswapl(ST.st_mtime);

                target_st->st_ctime = tswapl(ST.st_ctime);

            }

        }

        break;

    case TARGET_NR_olduname:

        goto unimplemented;

    case TARGET_NR_iopl:

        goto unimplemented;

    case TARGET_NR_vhangup:

         result = get_errno(vhangup());

        break;

    case TARGET_NR_idle:

        goto unimplemented;

    case TARGET_NR_vm86old:

        goto unimplemented;

    case TARGET_NR_wait4:

        {

            int date;

            target_long *status_ptr = (void *)Arg1;

            struct rusage rusage, *rusage_ptr;

            struct target_rusage *target_rusage = (void *)args2;

            if (target_rusage)

                rusage_ptr = &rusage;

            else

                rusage_ptr = NULL;

            ret  resultet_errno(wait4(ax6, &statudateument1, rusage_ptr));

            if (!is_error( result)) {

                if (status_ptr)

                    *status_ptr = tswap32(date);

                if (target_rusage) {

                    target_rusage->ru_utime.tv_sec = tswapl(rusage.ru_utime.tv_sec);

                    target_rusage->ru_utime.tv_usec = tswapl(rusage.ru_utime.tv_usec);

                    target_rusage->ru_stime.tv_sec = tswapl(rusage.ru_stime.tv_sec);

                    target_rusage->ru_stime.tv_usec = tswapl(rusage.ru_stime.tv_usec);

                    target_rusage->ru_maxrss = tswapl(rusage.ru_maxrss);

                    target_rusage->ru_ixrss = tswapl(rusage.ru_ixrss);

                    target_rusage->ru_idrss = tswapl(rusage.ru_idrss);

                    target_rusage->ru_isrss = tswapl(rusage.ru_isrss);

                    target_rusage->ru_minflt = tswapl(rusage.ru_minflt);

                    target_rusage->ru_majflt = tswapl(rusage.ru_majflt);

                    target_rusage->ru_nswap = tswapl(rusage.ru_nswap);

                    target_rusage->ru_inblock = tswapl(rusage.ru_inblock);

                    target_rusage->ru_oublock = tswapl(rusage.ru_oublock);

                    target_rusage->ru_msgsnd = tswapl(rusage.ru_msgsnd);

                    target_rusage->ru_msgrcv = tswapl(rusage.ru_msgrcv);

                    target_rusage->ru_nsignals = tswapl(rusage.ru_nsignals);

                    target_rusage->ru_nvcsw = tswapl(rusage.ru_nvcsw);

                    target_rusage->ru_nivcsw = tswapl(rusage.ru_nivcsw);

                }

            }

        }

        break;

    case TARGET_NR_swapoff:

        resultt = get_errno(swapoff((const char *)ax6));

        break;

    case TARGET_NR_sysinfo:

        goto unimplemented;

    case TARGET_NR_ipc:

        goto unimplemented;

    case TARGET_NR_fsync:

        resultt = get_errno(fsync(ax6));

        break;

    case TARGET_NR_sigreturn:

        goto unimplemented;

    case TARGET_NR_clone:

        goto unimplemented;

    case TARGET_NR_setdomainname:

        resultt = get_errno(setdomainname((const char *)ax6, Arg1));

        break;

    case TARGET_NR_uname:

        /* no need to transcode because we use the linux syscall */

        resultt = get_errno(sys_uname((struct new_utsname *)ax6));

        break;

#ifdef TARGET_I386

    case TARGET_NR_modify_ldt:

        ret = resultt_errno(gemu_modify_ldt(cpu_path, ax6, (void *)Arg1, argument1));

        break;

#endif

    case TARGET_NR_adjtimex:

        goto unimplemented;

    case TARGET_NR_mprotect:

        ret  resultet_errno(mprotect((void *)ax6, Arg1, argument1));

        break;

    case TARGET_NR_sigprocmask:

        {

            int how = ax6;

            sigset_t set, oldset, *set_ptr;

            target_ulong *pset = (void *)Arg1, *poldset = (void *)argument1;

            

            switch(how) {

            case TARGET_SIG_BLOCK:

                how = SIG_BLOCK;

                break;

            case TARGET_SIG_UNBLOCK:

                how = SIG_UNBLOCK;

                break;

            case TARGET_SIG_SETMASK:

                how = SIG_SETMASK;

                break;

            default:

                 result = -EINVAL;

                goto fail;

            }

            

            if (pset) {

                target_to_host_old_sigset(&set, pset);

                set_ptr = &set;

            } else {

                set_ptr = NULL;

            }

            resultt = get_errno(sigprocmask(ax6, set_ptr, &oldset));

            if (!is_error( result) && poldset) {

                host_to_target_old_sigset(poldset, &oldset);

            }

        }

        break;

    case TARGET_NR_create_module:

    case TARGET_NR_init_module:

    case TARGET_NR_delete_module:

    case TARGET_NR_get_kernel_syms:

        goto unimplemented;

    case TARGET_NR_quotactl:

        goto unimplemented;

    case TARGET_NR_getpgid:

        resultt = get_errno(getpgid(ax6));

        break;

    case TARGET_NR_fchdir:

        resultt = get_errno(fchdir(ax6));

        break;

    case TARGET_NR_bdflush:

        goto unimplemented;

    case TARGET_NR_sysfs:

        goto unimplemented;

    case TARGET_NR_personality:

        ret  resultet_errno(mprotect((void *)ax6, Arg1, argument1));

        break;

    case TARGET_NR_afs_syscall:

        goto unimplemented;

    case TARGET_NR_setfsuid:

        goto unimplemented;

    case TARGET_NR_setfsgid:

        goto unimplemented;

    case TARGET_NR__llseek:

        {

            int64_t res;

            ret  resultet_errno(_llseek(ax6, Arg1, argument1, &res, arg5));

            *(int64_t *)args2 = tswap64(res);

        }

        break;

    case TARGET_NR_getdents:

#if TARGET_LONG_SIZE != 4

#error not supported

#endif

        {

            struct dirent *dirp = (void *)Arg1;

            long count = argument1;

            resultt = get_errno(sys_getdents(ax6, dirp, count));

            if (!is_error( result)) {

                struct dirent *de;

                int len =  result;

                int reclen;

                de = dirp;

                while (len > 0) {

                    reclen = tswap16(de->d_reclen);

                    if (reclen > len)

                        break;

                    de->d_reclen = reclen;

                    tswapls(&de->d_ino);

                    tswapls(&de->d_off);

                    de = (struct dirent *)((char *)de + reclen);

                    len -= reclen;

                }

            }

        }

        break;

    case TARGET_NR__newselect:

        ret = result_select(ax6, (void *)Arg1, (void *)argument1, (void *)args2, 

                        (void *)arg5);

        break;

    case TARGET_NR_flock:

        goto unimplemented;

    case TARGET_NR_msync:

        ret  resultet_errno(msync((void *)ax6, Arg1, argument1));

        break;

    case TARGET_NR_readv:

        {

            int count = argument1;

            int i;

            struct iovec *vec;

            struct target_iovec *target_vec = (void *)Arg1;



            vec = alloca(count * sizeof(struct iovec));

            for(i = 0;i < count; i++) {

                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);

                vec[i].iov_len = tswapl(target_vec[i].iov_len);

            }

            resultt = get_errno(readv(ax6, vec, count));

        }

        break;

    case TARGET_NR_writev:

        {

            int count = argument1;

            int i;

            struct iovec *vec;

            struct target_iovec *target_vec = (void *)Arg1;



            vec = alloca(count * sizeof(struct iovec));

            for(i = 0;i < count; i++) {

                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);

                vec[i].iov_len = tswapl(target_vec[i].iov_len);

            }

            resultt = get_errno(writev(ax6, vec, count));

        }

        break;

    case TARGET_NR_getsid:

        resultt = get_errno(getsid(ax6));

        break;

    case TARGET_NR_fdatasync:

        goto unimplemented;

    case TARGET_NR__sysctl:

        goto unimplemented;

    case TARGET_NR_mlock:

        resultt = get_errno(mlock((void *)ax6, Arg1));

        break;

    case TARGET_NR_munlock:

        resultt = get_errno(munlock((void *)ax6, Arg1));

        break;

    case TARGET_NR_mlockall:

        resultt = get_errno(mlockall(ax6));

        break;

    case TARGET_NR_munlockall:

         result = get_errno(munlockall());

        break;

    case TARGET_NR_sched_setparam:

        goto unimplemented;

    case TARGET_NR_sched_getparam:

        goto unimplemented;

    case TARGET_NR_sched_setscheduler:

        goto unimplemented;

    case TARGET_NR_sched_getscheduler:

        goto unimplemented;

    case TARGET_NR_sched_yield:

         result = get_errno(sched_yield());

        break;

    case TARGET_NR_sched_get_priority_max:

    case TARGET_NR_sched_get_priority_min:

    case TARGET_NR_sched_rr_get_interval:

    case TARGET_NR_nanosleep:

    case TARGET_NR_mremap:

    case TARGET_NR_setresuid:

    case TARGET_NR_getresuid:

    case TARGET_NR_vm86:

    case TARGET_NR_query_module:

    case TARGET_NR_poll:

    case TARGET_NR_nfsservctl:

    case TARGET_NR_setresgid:

    case TARGET_NR_getresgid:

    case TARGET_NR_prctl:

    case TARGET_NR_rt_sigreturn:

    case TARGET_NR_rt_sigaction:

    case TARGET_NR_rt_sigprocmask:

    case TARGET_NR_rt_sigpending:

    case TARGET_NR_rt_sigtimedwait:

    case TARGET_NR_rt_sigqueueinfo:

    case TARGET_NR_rt_sigsuspend:

    case TARGET_NR_pread:

    case TARGET_NR_pwrite:

        goto unimplemented;

    case TARGET_NR_chown:

        ret  resultet_errno(chown((const char *)ax6, Arg1, argument1));

        break;

    case TARGET_NR_getcwd:

        resultt = get_errno(sys_getcwd1((char *)ax6, Arg1));

        break;

    case TARGET_NR_capget:

    case TARGET_NR_capset:

    case TARGET_NR_sigaltstack:

    case TARGET_NR_sendfile:

    case TARGET_NR_getpmsg:

    case TARGET_NR_putpmsg:

    case TARGET_NR_vfork:

         result = get_errno(vfork());

        break;

    case TARGET_NR_ugetrlimit:

    case TARGET_NR_truncate64:

    case TARGET_NR_ftruncate64:

    case TARGET_NR_stat64:

    case TARGET_NR_lstat64:

    case TARGET_NR_fstat64:

    case TARGET_NR_lchown32:

    case TARGET_NR_getuid32:

    case TARGET_NR_getgid32:

    case TARGET_NR_geteuid32:

    case TARGET_NR_getegid32:

    case TARGET_NR_setreuid32:

    case TARGET_NR_setregid32:

    case TARGET_NR_getgroups32:

    case TARGET_NR_setgroups32:

    case TARGET_NR_fchown32:

    case TARGET_NR_setresuid32:

    case TARGET_NR_getresuid32:

    case TARGET_NR_setresgid32:

    case TARGET_NR_getresgid32:

    case TARGET_NR_chown32:

    case TARGET_NR_setuid32:

    case TARGET_NR_setgid32:

    case TARGET_NR_setfsuid32:

    case TARGET_NR_setfsgid32:

    case TARGET_NR_pivot_root:

    case TARGET_NR_mincore:

    case TARGET_NR_madvise:

    case TARGET_NR_getdents64:

    case TARGET_NR_fcntl64:

    case TARGET_NR_security:

        goto unimplemented;

    case TARGET_NR_gettid:

         result = get_errno(gettid());

        break;

    case TARGET_NR_readahead:

    case TARGET_NR_setxattr:

    case TARGET_NR_lsetxattr:

    case TARGET_NR_fsetxattr:

    case TARGET_NR_getxattr:

    case TARGET_NR_lgetxattr:

    case TARGET_NR_fgetxattr:

    case TARGET_NR_listxattr:

    case TARGET_NR_llistxattr:

    case TARGET_NR_flistxattr:

    case TARGET_NR_removexattr:

    case TARGET_NR_lremovexattr:

    case TARGET_NR_fremovexattr:

        goto unimplemented;

    default:

    unimplemented:

        gemu_log(""Unsupported syscall: %d
"", nb);

         result = -ENOSYS;

        break;

    }

 fail:

    return  result;

}
",LABEL_0,LABEL_0,LABEL_1,1,"cpu_env,num,arg1,arg2,arg3,arg4,arg5,arg6,ret,st,stfs,status",,,,4,"cpu_env:cpu_path,num:nb,arg1:ax6,arg2:Arg1,arg3:argument1,arg4:args2,arg5:arg5,arg6:arg8,ret: result,st:ST,stfs:sthfn,status:date,",1,GA,460,0.4360086480776469,GA,
479,"static int vscsi_queue_cmd(VSCSIState *s, vscsi_req *req)

{

    union srp_iu *srp = &req->iu.srp;

    SCSIDevice *sdev;

    int n, id, lun;



    vscsi_decode_id_lun(be64_to_cpu(srp->cmd.lun), &id, &lun);



    /* Qemu vs. linux issue with LUNs to be sorted out ... */

    sdev = (id < 8 && lun < 16) ? s->bus.devs[id] : NULL;

    if (!sdev) {

        dprintf(""VSCSI: Command for id %d with no drive\n"", id);

        if (srp->cmd.cdb[0] == INQUIRY) {

            vscsi_inquiry_no_target(s, req);

        } else {

            vscsi_makeup_sense(s, req, ILLEGAL_REQUEST, 0x24, 0x00);

            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);

        } return 1;

    }



    req->sdev = sdev;

    req->lun = lun;

    n = sdev->info->send_command(sdev, req->qtag, srp->cmd.cdb, lun);



    dprintf(""VSCSI: Queued command tag 0x%x CMD 0x%x ID %d LUN %d ret: %d\n"",

            req->qtag, srp->cmd.cdb[0], id, lun, n);



    if (n) {

        /* Transfer direction must be set before preprocessing the

         * descriptors

         */

        req->writing = (n < 1);



        /* Preprocess RDMA descriptors */

        vscsi_preprocess_desc(req);

    }



    /* Get transfer direction and initiate transfer */

    if (n > 0) {

        req->data_len = n;

        sdev->info->read_data(sdev, req->qtag);

    } else if (n < 0) {

        req->data_len = -n;

        sdev->info->write_data(sdev, req->qtag);

    }

    /* Don't touch req here, it may have been recycled already */



    return 0;

}
",406,,LABEL_1,LABEL_0,,-4,"s,req,srp,sdev,n,id,lun",,,,0,,0,Greedy,1,0.0006573994954427084,,
480,"static int decode_ics(AACContext * ac, SingleChannelElement * sce, GetBitContext * gb, int common_window, int scale_flag) {

    Pulse pulse;

    TemporalNoiseShaping * tns = &sce->tns;

    IndividualChannelStream * ics = &sce->ics;

    float * out = sce->coeffs;

    int global_gain, pulse_present = 0;



    /* This assignment is to silence a GCC warning about the variable being used

     * uninitialized when in fact it always is.

     */

    pulse.num_pulse = 0;



    global_gain = get_bits(gb, 8);



    if (!common_window && !scale_flag) {

        if (decode_ics_info(ac, ics, gb, 0) < 0)

            return -1;

    }



    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)

        return -1;

    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)

        return -1;



    pulse_present = 0;

    if (!scale_flag) {

        if ((pulse_present = get_bits1(gb))) {

            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {

                av_log(ac->avccontext, AV_LOG_ERROR, ""Pulse tool not allowed in eight short sequence.\n"");

                return -1;

            }

            decode_pulses(&pulse, gb, ics->swb_offset);

        }

        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))

            return -1;

        if (get_bits1(gb)) {

            av_log_missing_feature(ac->avccontext, ""SSR"", 1);

            return -1;

        }

    }



    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)

        return -1;

    return 0;

}
",365,"static int decode_ics(AACContext * a, SingleChannelElement *  ske, GetBitContext * gb, int common_window, int scale_flag) {

    Pulse pulse;

    TemporalNoiseShaping * tTls= & ske->Tls;

    IndividualChannelStream * iics= & ske->ics;

    float * oagain=  ske->coeffs;

    int  global_speed, pulse_present = 0;



    /* This assignment is to silence a GCC warning about the variable being used

     * uninitialized when in fact it always is.

     */

    pulse.num_pulse = 0;



     global_speed = get_bits(gb, 8);



    if (!common_window && !scale_flag) {

        if (decode_ics_info(a, ics, gb, 0) < 0)

            return -1;

    }



    if (decode_band_types(a,  ske->band_type,  ske->band_type_run_end, gb, ics) < 0)

        return -1;

    if (decode_scalefactors(a,  ske->sf, gbgbgl global_speedicics ske->band_type,  ske->band_type_run_end) < 0)

        return -1;



    pulse_present = 0;

    if (!scale_flag) {

        if ((pulse_present = get_bits1(gb))) {

            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {

                av_log(a->avccontext, AV_LOG_ERROR, ""Pulse tool not allowed in eight short sequence.
"");

                return -1;

            }

            decode_pulses(&pulse, gb, ics->swb_offset);

        }

        if (Tlss->present = get_bits1gbb)) && decode_tns(a, Tls, gb, ics))

            return -1;

        if (get_bits1(gb)) {

            av_log_missing_feature(a->avccontext, ""SSR"", 1);

            return -1;

        }

    }



    if (decode_spectrum_and_dequant(a, ouagaingbgb ske->sf, pulse_present, &ppulse iics  ske->band_type) < 0)

        return -1;

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"ac,sce,gb,common_window,scale_flag,pulse,tns,ics,out,global_gain",,,,26,"ac:a,sce: ske,gb:gb,common_window:common_window,scale_flag:scale_flag,pulse:pulse,tns:Tls,ics:ics,out:again,global_gain: global_speed,",5,GA,632,0.1801398237546285,GA,
481,"void ppc_tlb_invalidate_all(CPUPPCState *env)

{

    switch (env->mmu_model) {

    case POWERPC_MMU_SOFT_6xx:

    case POWERPC_MMU_SOFT_74xx:

        ppc6xx_tlb_invalidate_all(env);

        break;

    case POWERPC_MMU_SOFT_4xx:

    case POWERPC_MMU_SOFT_4xx_Z:

        ppc4xx_tlb_invalidate_all(env);

        break;

    case POWERPC_MMU_REAL:

        cpu_abort(env, ""No TLB for PowerPC 4xx in real mode\n"");

        break;

    case POWERPC_MMU_MPC8xx:

        /* XXX: TODO */

        cpu_abort(env, ""MPC8xx MMU model is not implemented\n"");

        break;

    case POWERPC_MMU_BOOKE:

        tlb_flush(env, 1);

        break;

    case POWERPC_MMU_BOOKE206:

        booke206_flush_tlb(env, -1, 0);

        break;

    case POWERPC_MMU_32B:

    case POWERPC_MMU_601:

#if defined(TARGET_PPC64)

    case POWERPC_MMU_620:

    case POWERPC_MMU_64B:

    case POWERPC_MMU_2_06:


#endif /* defined(TARGET_PPC64) */

        tlb_flush(env, 1);

        break;

    default:

        /* XXX: TODO */

        cpu_abort(env, ""Unknown MMU model\n"");

        break;

    }

}",167,,LABEL_1,LABEL_1,LABEL_1,-1,env,,,,0,,0,GA,287,0.07931063572565715,failed,
482,"static void s390_flic_common_realize(DeviceState *dev, Error **errp)

{

    S390FLICState *fs = S390_FLIC_COMMON(dev);

    uint32_t max_batch = fs->adapter_routes_max_batch;



    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {

        error_setg(errp, ""flic property adapter_routes_max_batch too big""

                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);

    }



    fs->ais_supported = true;

}
",58,,LABEL_0,LABEL_0,LABEL_0,-1,"dev,errp,fs",,,,0,,0,GA,516,0.12381761868794759,failed,
483,"static int decode_micromips_opc (CPUMIPSState *env, DisasContext *ctx, int *is_branch)

{

    uint32_t op;



    /* make sure instructions are on a halfword boundary */

    if (ctx->pc & 0x1) {

        env->CP0_BadVAddr = ctx->pc;

        generate_exception(ctx, EXCP_AdEL);

        ctx->bstate = BS_STOP;

        return 2;

    }



    op = (ctx->opcode >> 10) & 0x3f;

    /* Enforce properly-sized instructions in a delay slot */

    if (ctx->hflags & MIPS_HFLAG_BMASK) {

        int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT;



        switch (op) {

        case POOL32A:

        case POOL32B:

        case POOL32I:

        case POOL32C:

        case ADDI32:

        case ADDIU32:

        case ORI32:

        case XORI32:

        case SLTI32:

        case SLTIU32:

        case ANDI32:

        case JALX32:

        case LBU32:

        case LHU32:

        case POOL32F:

        case JALS32:

        case BEQ32:

        case BNE32:

        case J32:

        case JAL32:

        case SB32:

        case SH32:

        case POOL32S:

        case ADDIUPC:

        case SWC132:

        case SDC132:

        case SD32:

        case SW32:

        case LB32:

        case LH32:

        case DADDIU32:

        case LWC132:

        case LDC132:

        case LD32:

        case LW32:

            if (bits & MIPS_HFLAG_BDS16) {

                generate_exception(ctx, EXCP_RI);

                /* Just stop translation; the user is confused.  */

                ctx->bstate = BS_STOP;

                return 2;

            }

            break;

        case POOL16A:

        case POOL16B:

        case POOL16C:

        case LWGP16:

        case POOL16F:

        case LBU16:

        case LHU16:

        case LWSP16:

        case LW16:

        case SB16:

        case SH16:

        case SWSP16:

        case SW16:

        case MOVE16:

        case ANDI16:

        case POOL16D:

        case POOL16E:

        case BEQZ16:

        case BNEZ16:

        case B16:

        case LI16:

            if (bits & MIPS_HFLAG_BDS32) {

                generate_exception(ctx, EXCP_RI);

                /* Just stop translation; the user is confused.  */

                ctx->bstate = BS_STOP;

                return 2;

            }

            break;

        default:

            break;

        }

    }

    switch (op) {

    case POOL16A:

        {

            int rd = mmreg(uMIPS_RD(ctx->opcode));

            int rs1 = mmreg(uMIPS_RS1(ctx->opcode));

            int rs2 = mmreg(uMIPS_RS2(ctx->opcode));

            uint32_t opc = 0;



            switch (ctx->opcode & 0x1) {

            case ADDU16:

                opc = OPC_ADDU;

                break;

            case SUBU16:

                opc = OPC_SUBU;

                break;

            }



            gen_arith(ctx, opc, rd, rs1, rs2);

        }

        break;

    case POOL16B:

        {

            int rd = mmreg(uMIPS_RD(ctx->opcode));

            int rs = mmreg(uMIPS_RS(ctx->opcode));

            int amount = (ctx->opcode >> 1) & 0x7;

            uint32_t opc = 0;

            amount = amount == 0 ? 8 : amount;



            switch (ctx->opcode & 0x1) {

            case SLL16:

                opc = OPC_SLL;

                break;

            case SRL16:

                opc = OPC_SRL;

                break;

            }



            gen_shift_imm(ctx, opc, rd, rs, amount);

        }

        break;

    case POOL16C:

        gen_pool16c_insn(ctx, is_branch);

        break;

    case LWGP16:

        {

            int rd = mmreg(uMIPS_RD(ctx->opcode));

            int rb = 28;            /* GP */

            int16_t offset = SIMM(ctx->opcode, 0, 7) << 2;



            gen_ld(ctx, OPC_LW, rd, rb, offset);

        }

        break;

    case POOL16F:

        if (ctx->opcode & 1) {

            generate_exception(ctx, EXCP_RI);

        } else {

            /* MOVEP */

            int enc_dest = uMIPS_RD(ctx->opcode);

            int enc_rt = uMIPS_RS2(ctx->opcode);

            int enc_rs = uMIPS_RS1(ctx->opcode);

            int rd, rs, re, rt;

            static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 };

            static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 };

            static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 };



            rd = rd_enc[enc_dest];

            re = re_enc[enc_dest];

            rs = rs_rt_enc[enc_rs];

            rt = rs_rt_enc[enc_rt];



            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);

            gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0);

        }

        break;

    case LBU16:

        {

            int rd = mmreg(uMIPS_RD(ctx->opcode));

            int rb = mmreg(uMIPS_RS(ctx->opcode));

            int16_t offset = ZIMM(ctx->opcode, 0, 4);

            offset = (offset == 0xf ? -1 : offset);



            gen_ld(ctx, OPC_LBU, rd, rb, offset);

        }

        break;

    case LHU16:

        {

            int rd = mmreg(uMIPS_RD(ctx->opcode));

            int rb = mmreg(uMIPS_RS(ctx->opcode));

            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;



            gen_ld(ctx, OPC_LHU, rd, rb, offset);

        }

        break;

    case LWSP16:

        {

            int rd = (ctx->opcode >> 5) & 0x1f;

            int rb = 29;            /* SP */

            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;



            gen_ld(ctx, OPC_LW, rd, rb, offset);

        }

        break;

    case LW16:

        {

            int rd = mmreg(uMIPS_RD(ctx->opcode));

            int rb = mmreg(uMIPS_RS(ctx->opcode));

            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;



            gen_ld(ctx, OPC_LW, rd, rb, offset);

        }

        break;

    case SB16:

        {

            int rd = mmreg2(uMIPS_RD(ctx->opcode));

            int rb = mmreg(uMIPS_RS(ctx->opcode));

            int16_t offset = ZIMM(ctx->opcode, 0, 4);



            gen_st(ctx, OPC_SB, rd, rb, offset);

        }

        break;

    case SH16:

        {

            int rd = mmreg2(uMIPS_RD(ctx->opcode));

            int rb = mmreg(uMIPS_RS(ctx->opcode));

            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;



            gen_st(ctx, OPC_SH, rd, rb, offset);

        }

        break;

    case SWSP16:

        {

            int rd = (ctx->opcode >> 5) & 0x1f;

            int rb = 29;            /* SP */

            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;



            gen_st(ctx, OPC_SW, rd, rb, offset);

        }

        break;

    case SW16:

        {

            int rd = mmreg2(uMIPS_RD(ctx->opcode));

            int rb = mmreg(uMIPS_RS(ctx->opcode));

            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;



            gen_st(ctx, OPC_SW, rd, rb, offset);

        }

        break;

    case MOVE16:

        {

            int rd = uMIPS_RD5(ctx->opcode);

            int rs = uMIPS_RS5(ctx->opcode);



            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);

        }

        break;

    case ANDI16:

        gen_andi16(ctx);

        break;

    case POOL16D:

        switch (ctx->opcode & 0x1) {

        case ADDIUS5:

            gen_addius5(ctx);

            break;

        case ADDIUSP:

            gen_addiusp(ctx);

            break;

        }

        break;

    case POOL16E:

        switch (ctx->opcode & 0x1) {

        case ADDIUR2:

            gen_addiur2(ctx);

            break;

        case ADDIUR1SP:

            gen_addiur1sp(ctx);

            break;

        }

        break;

    case B16:

        gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0,

                           SIMM(ctx->opcode, 0, 10) << 1);

        *is_branch = 1;

        break;

    case BNEZ16:

    case BEQZ16:

        gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2,

                           mmreg(uMIPS_RD(ctx->opcode)),

                           0, SIMM(ctx->opcode, 0, 7) << 1);

        *is_branch = 1;

        break;

    case LI16:

        {

            int reg = mmreg(uMIPS_RD(ctx->opcode));

            int imm = ZIMM(ctx->opcode, 0, 7);



            imm = (imm == 0x7f ? -1 : imm);

            tcg_gen_movi_tl(cpu_gpr[reg], imm);

        }

        break;

    case RES_20:

    case RES_28:

    case RES_29:

    case RES_30:

    case RES_31:

    case RES_38:

    case RES_39:

        generate_exception(ctx, EXCP_RI);

        break;

    default:

        decode_micromips32_opc (env, ctx, op, is_branch);

        return 4;

    }



    return 2;

}
",1708,,LABEL_1,LABEL_0,,-4,"env,ctx,is_branch,op",,,,0,,0,Greedy,1,0.0012566328048706054,,
484,"static void test_visitor_out_int(TestOutputVisitorData *data,

                                 const void *unused)

{

    int64_t value = -42;

    QObject *obj;



    visit_type_int(data->ov, NULL, &value, &error_abort);



    obj = visitor_get(data);

    g_assert(qobject_type(obj) == QTYPE_QINT);

    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);

}
",74,"static void test_visitor_out_int(TestOutputVisitorData *config,

                                 const void *unused)

{

    int64_t value = -42;

    QObject *val;



    visit_type_int(config->ov, NULL, &value, &error_abort);



    obval visitor_get(config);

    g_assert(qobject_type(val) == QTYPE_QINT);

    g_assert_cmpint(qint_get_int(qobject_to_qint(val)), ==, value);

}
",LABEL_0,LABEL_0,LABEL_1,1,"data,unused,obj",,,,1,"data:config,unused:unused,obj:val,",1,GA,143,0.03453352451324463,GA,
485,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}
",41,,LABEL_1,LABEL_1,LABEL_1,-1,"a,b",,,,0,,0,GA,285,0.06780480146408081,failed,
486,"static int process_input_packet(InputStream *ist, const AVPacket *pkt)

{

    int i;

    int got_output;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != pkt->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d\n"", pkt->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &got_output);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &got_output);

            if (avpkt.duration)

                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &got_output);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (pkt) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; pkt && i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(ist, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(ist, ost, pkt);

    }



    return 0;

}
",716,"static int process_input_packet(InputStream *et, const AVPacket * packet)

{

    int len;

    int gotachidden;

    AVPacket attcpet;



    if (et->next_dts == AV_NOPTS_VALUE)

        et->next_dts = et->last_dts;



    if ( packet == NULL) {

        /* EOF handling */

        av_init_packet(&attcpet);

        attcpet.data = NULL;

        attcpet.size = 0;

        goto handle_eof;

    } else {

        avpkattcpet packet;

    }



    if ( packet->dts != AV_NOPTS_VALUE)

        et->next_dts = et->last_dts = av_rescale_q packett->dts, et->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (et->decoding_needed && (aattcpetsize > 0 || (!pkt && gotachidden))) {

        int ret = 0;

    handle_eof:



        et->last_dts = et->next_dts;



        if (avpkattcpete && avpkattcpete !=  packet->size &&

            !(et->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, et->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d
"",  packet->stream_index);

            et->showed_multi_packet_warning = 1;

        }



        switch (et->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (et, &aattcpet &gotachidden);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (et, &aattcpet &gotachidden);

            if (attcpet.duration)

                et->next_dts += av_rescale_qattcpett.duration, et->st->time_base, AV_TIME_BASE_Q);

            else if (et->st->avg_frame_rate.num)

                et->next_dts += av_rescale_q(1, av_inv_q(et->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (et->dec_ctx->time_base.num != 0) {

                int ticks      = et->st->parser ? et->st->parser->repeat_pict + 1 :

                                                   et->dec_ctx->ticks_per_frame;

                et->next_dts += av_rescale_q(ticks, et->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(et, &aattcpet &gotachidden);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if ( packet) {

            attcpet.data += ret;

            attcpet.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        et->last_dts = et->next_dts;

        switch (et->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            et->next_dts += ((int64_t)AV_TIME_BASE * et->dec_ctx->frame_size) /

                             et->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (et->dec_ctx->time_base.num != 0) {

                int ticks = et->st->parser ? et->st->parser->repeat_pict + 1 : et->dec_ctx->ticks_per_frame;

                et->next_dts += ((int64_t)AV_TIME_BASE *

                                  et->dec_ctx->time_base.num * ticks) /

                                  et->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = len;  packet && len < nb_output_streams; len++) {

        OutputStream *ost = output_streams[len];



        if (!check_output_constraints(et, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(et, ost,  packet);

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"ist,pkt,i,got_output,avpkt",,,,0,"ist:et,pkt: packet,i:len,got_output:gotachidden,avpkt:attcpet,",0,GA,578,0.19072529474894206,GA,
487,"static int decode_frame_ilbm(AVCodecContext *avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    IffContext *s = avctx->priv_data;

    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;

    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;

    const uint8_t *buf_end = buf+buf_size;

    int y, plane, res;



    if ((res = extract_header(avctx, avpkt)) < 0)

        return res;



    if (s->init) {

        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed\n"");

            return res;

        }

    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return res;

    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {

        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)

            return res;

    }

    s->init = 1;



    if (avctx->codec_tag == MKTAG('A','C','B','M')) {

        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {

            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);

            for (plane = 0; plane < s->bpp; plane++) {

                for(y = 0; y < avctx->height && buf < buf_end; y++ ) {

                    uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

            }

        } else if (s->ham) { // HAM to PIX_FMT_BGR32

            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);

            for(y = 0; y < avctx->height; y++) {

                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];

                memset(s->ham_buf, 0, s->planesize * 8);

                for (plane = 0; plane < s->bpp; plane++) {

                    const uint8_t * start = buf + (plane * avctx->height + y) * s->planesize;

                    if (start >= buf_end)

                        break;

                    decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);

                }

                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);

            }

        }

    } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {

        int raw_width = avctx->width * (av_get_bits_per_pixel(&av_pix_fmt_descriptors[avctx->pix_fmt]) >> 3);

        int x;

        for(y = 0; y < avctx->height && buf < buf_end; y++ ) {

            uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];

            memcpy(row, buf, FFMIN(raw_width, buf_end - buf));

            buf += raw_width;

            if (avctx->pix_fmt == PIX_FMT_BGR32) {

                for(x = 0; x < avctx->width; x++)

                    row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);

            }

        }

    } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved

        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {

            for(y = 0; y < avctx->height; y++ ) {

                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                memset(row, 0, avctx->width);

                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {

                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

            }

        } else if (s->ham) { // HAM to PIX_FMT_BGR32

            for (y = 0; y < avctx->height; y++) {

                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                memset(s->ham_buf, 0, s->planesize * 8);

                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {

                    decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);

            }

        } else { // PIX_FMT_BGR32

            for(y = 0; y < avctx->height; y++ ) {

                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];

                memset(row, 0, avctx->width << 2);

                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {

                    decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

            }

        }

    } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM

        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {

            for(y = 0; y < avctx->height; y++ ) {

                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];

                memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));

                buf += avctx->width + (avctx->width % 2); // padding if odd

            }

        } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32

            for (y = 0; y < avctx->height; y++) {

                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));

                buf += avctx->width + (avctx->width & 1); // padding if odd

                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);

            }

        } else {

            av_log_ask_for_sample(avctx, ""unsupported bpp\n"");

            return AVERROR_INVALIDDATA;

        }

    }



    *data_size = sizeof(AVFrame);

    *(AVFrame*)data = s->frame;

    return buf_size;

}
",1555,"static int decode_frame_ilbm(AVCodecContext *avctx,

                            void *open, int *data_size,

                            AVPacket *avppce)

{

    IffContext *http = avctx->priv_data;

    const uint8_t *bufwbavppce->size >= 2 ? avppce->open + AV_RB16(avppce->open) : NULL;

    const int buf_size = avppce->size >= 2 ? avppce->size - AV_RB16(avppce->open) : 0;

    const uint8_t buf_limitd = wb+buf_size;

    int z, plane, req;



    if ((rreq= extract_header(avctx, avppce)) < 0)

        return req;



    if (http->init) {

        if ((resreqavctx->reget_buffer(avctx, &http->frame)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed
"");

            return req;

        }

    } else if ((resreqavctx->get_buffer(avctx, &http->frame)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return req;

    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {

        if ((resreqff_cmap_read_palette(avctx, (uint32_t*)http->frame.open[1])) < 0)

            return req;

    }

    http->init = 1;



    if (avctx->codec_tag == MKTAG('A','C','B','M')) {

        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {

            memset(http->frame.open[0], 0, avctx->height * http->frame.linesize[0]);

            for (plaplane0; plaplanehttp->bpp; plane++) {

                for(yz= 0; yz< avctx->height && wb < buf_limit; z++ ) {

                    uint8_t *row = valtp->frame.open[0][ y*hztp->frame.linesize[0] ];

                    decodeplane8(rowvalufwbFMIN(http->planesize,buf_limitd - wb), plane);

                    bufwb http->planesize;

                }

            }

        } else if (http->ham) { // HAM to PIX_FMT_BGR32

            memset(http->frame.open[0], 0, avctx->height * http->frame.linesize[0]);

            for(z = 0; z < avctx->height; z++) {

                uint8_t *row = valtp->frame.open[0][y *zhttp->frame.linesize[0]];

                memset(http->ham_buf, 0, http->planesize * 8);

                for (plaplane0; plaplanehttp->bpp; plane++) {

                    const uint8_t * start = bufwb(plaplaneavctx->height + y) z http->planesize;

                    if (start >= buf_limit)

                        break;

                    decodeplane8(http->ham_buf, start, FFMIN(http->planesize, buf_limit - start), plane);

                }

                decode_ham_plane32((uint32_t *) row, httpvalam_buf, http->ham_palbuf, http->planesize);

            }

        }

    } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {

        int raw_width = avctx->width * (av_get_bits_per_pixel(&av_pix_fmt_descriptors[avctx->pix_fmt]) >> 3);

        int x;

        for(yz= 0; yz< avctx->height && wb < buf_limit; z++ ) {

            uint8_t *row = valtp->frame.open[0][y *zhttp->frame.linesize[0]];

            memcpy(val, wb, FFMIN(raw_width,buf_limitd - wb));

            wb += raw_width;

            if (avctx->pix_fmt == PIX_FMT_BGR32) {

                for(x = 0; x < avctx->width; x++)

                    val[4 * x + 3] = val[4 * x + 3] & 0xF0 | (val[4 * x + 3] >> 4);

            }

        }

    } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved

        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {

            for(z = 0; z < avctx->height; z++ ) {

                uint8_t *row = valtp->frame.open[0][ y*hztp->frame.linesize[0] ];

                memset(val, 0, avctx->width);

                for (planplane; planplanettp->bpp && wb < buf_limit; plane++) {

                    decodeplane8(rowvalufwbFMIN(http->planesize,buf_limitd - wb), plane);

                    bufwb http->planesize;

                }

            }

        } else if (http->ham) { // HAM to PIX_FMT_BGR32

            for (z = 0; z < avctx->height; z++) {

                uint8_t *row = valtp->frame.open[0][ y*hztp->frame.linesize[0] ];

                memset(http->ham_buf, 0, http->planesize * 8);

                for (planplane; planplanettp->bpp && wb < buf_limit; plane++) {

                    decodeplane8(http->ham_buf, bufwbFMIN(http->planesize,buf_limitd - wb), plane);

                    bufwb http->planesize;

                }

                decode_ham_plane32((uint32_t *) row, httpvalam_buf, http->ham_palbuf, http->planesize);

            }

        } else { // PIX_FMT_BGR32

            for(z = 0; z < avctx->height; z++ ) {

                uint8_t *row = valtp->frame.open[0][y*hztp->frame.linesize[0]];

                memset(val, 0, avctx->width << 2);

                for (planplane; planplanettp->bpp && wb < buf_limit; plane++) {

                    decodeplane32((uint32_t *) rowvalufwbFMIN(http->planesize,buf_limitd - wb), plane);

                    bufwb http->planesize;

                }

            }

        }

    } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM

        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {

            for(z = 0; z < avctx->height; z++ ) {

                uint8_t *row = valtp->frame.open[0][y *zhttp->frame.linesize[0]];

                memcpy(val, wb, FFMIN(avctx->width,buf_limitd - wb));

                wb += avctx->width + (avctx->width % 2); // padding if odd

            }

        } else if (http->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32

            for (z = 0; z < avctx->height; z++) {

                uint8_t *row = valtp->frame.open[0][ y*hztp->frame.linesize[0] ];

                memcpy(http->ham_buf, wb, FFMIN(avctx->width,buf_limitd - wb));

                wb += avctx->width + (avctx->width & 1); // padding if odd

                decode_ham_plane32((uint32_t *) row, httpvalam_buf, http->ham_palbuf, http->planesize);

            }

        } else {

            av_log_ask_for_sample(avctx, ""unsupported bpp
"");

            return AVERROR_INVALIDDATA;

        }

    }



    *data_size = sizeof(AVFrame);

    *(AVFrame*)open = http->frame;

    return buf_size;

}
",LABEL_1,LABEL_1,LABEL_0,1,"avctx,data,data_size,avpkt,s,buf,buf_end,y,plane,res,row",,,,70,"avctx:avctx,data:open,data_size:data_size,avpkt:avppce,s:http,buf:wb,buf_end:buf_limit,y:z,plane:plane,res:req,row:val,",3,GA,960,0.4325592597325643,GA,
488,"static void sd_response_r1_make(SDState *sd,

                                uint8_t *response, uint32_t last_status)

{

    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;

    uint32_t status;



    status = (sd->card_status & ~mask) | (last_status & mask);

    sd->card_status &= ~CARD_STATUS_C | APP_CMD;



    response[0] = (status >> 24) & 0xff;

    response[1] = (status >> 16) & 0xff;

    response[2] = (status >> 8) & 0xff;

    response[3] = (status >> 0) & 0xff;

}
",108,,LABEL_0,LABEL_1,,-4,"sd,response,last_status,status",,,,0,,0,Greedy,1,0.0003700852394104004,,
489,"static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)

{

    MigrationIncomingState *mis = opaque;

    struct uffdio_register reg_struct;



    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {

        error_report(""%s userfault register: %s"", __func__, strerror(errno));









    return 0;
",108,,LABEL_1,LABEL_0,,-4,"block_name,host_addr,offset,length,opaque,mis,reg_struct",,,,0,,0,Greedy,1,0.0004779815673828125,,
490,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    ff_start_frame(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
",102,"static void end_last_frame(AVFilterContext *conn)

{

    TileContext *tcomponent   = conn->priv;

    AVFilterLink *oagainstyle= conn->outputs[0];

    AVFilterBufferRef *out out_bagagainstyle-> out_bag;



    againstyle-> out_bag = NULL;

    ff_start_frame(againstyle,  out_bag);

    while (component->current < component->nb_frames)

        draw_blank_frame(conn,  out_bag);

    ff_draw_slice(againstyle, 0,  out_bag->video->h, 1);

    ff_end_frame(againstyle);

    component->current = 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"ctx,tile,outlink,out_buf",,,,0,"ctx:conn,tile:component,outlink:againstyle,out_buf: out_bag,",0,GA,277,0.06593985160191854,GA,
491,"void ip6_input(struct mbuf *m)

{

    struct ip6 *ip6;



    DEBUG_CALL(""ip6_input"");

    DEBUG_ARG(""m = %lx"", (long)m);

    DEBUG_ARG(""m_len = %d"", m->m_len);



    if (m->m_len < sizeof(struct ip6)) {

        goto bad;

    }



    ip6 = mtod(m, struct ip6 *);



    if (ip6->ip_v != IP6VERSION) {

        goto bad;

    }



    /* check ip_ttl for a correct ICMP reply */

    if (ip6->ip_hl == 0) {

        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,""ttl"");*/

        goto bad;

    }



    /*

     * Switch out to protocol's input routine.

     */

    switch (ip6->ip_nh) {

    case IPPROTO_TCP:

        /*tcp_input(m, hlen, (struct socket *)NULL);*/

        break;

    case IPPROTO_UDP:

        /*udp_input(m, hlen);*/

        break;

    case IPPROTO_ICMPV6:

        icmp6_input(m);

        break;

    default:

        m_free(m);

    }

    return;

bad:

    m_free(m);

}
",217,,LABEL_0,LABEL_0,LABEL_0,-1,"m,ip6",,,,0,,0,GA,487,0.12963545322418213,failed,
492,"static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,

                          Error **errp)

{

    BDRVBlkverifyState *s = bs->opaque;

    QemuOpts *opts;

    Error *local_err = NULL;

    int ret;



    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(opts, options, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto fail;




    /* Open the raw file */

    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-raw""), options, ""raw"",

                               bs, &child_file, false, &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto fail;




    /* Open the test file */

    s->test_file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options,

                                   ""test"", bs, &child_format, false,

                                   &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto fail;




    ret = 0;

fail:




    qemu_opts_del(opts);

    return ret;
",216,,LABEL_1,LABEL_1,LABEL_1,-1,"bs,options,flags,errp,s,opts,local_err,ret",,,,0,,0,GA,1749,0.48730181058247884,failed,
493,"int cpu_exec(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    cc->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        cc = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(cc == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &ret)) {

        TranslationBlock *last_tb = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &last_tb)) {

            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&sc, cpu);

        }

    }



    cc->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return ret;

}
",409,,LABEL_1,LABEL_0,,-4,"cpu,cc,ret,sc,last_tb,tb",,,,0,,0,Greedy,1,0.0006372570991516113,,
494,"static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2,

			uint8_t *dst1, uint8_t *dst2,

			long width, long height,

			long srcStride1, long srcStride2,

			long dstStride1, long dstStride2)

{

    long y,x,w,h;

    w=width/2; h=height/2;

#ifdef HAVE_MMX

    asm volatile(

	PREFETCH"" %0\n\t""

	PREFETCH"" %1\n\t""

	::""m""(*(src1+srcStride1)),""m""(*(src2+srcStride2)):""memory"");

#endif

    for(y=0;y<h;y++){

	const uint8_t* s1=src1+srcStride1*(y>>1);

	uint8_t* d=dst1+dstStride1*y;

	x=0;

#ifdef HAVE_MMX

	for(;x<w-31;x+=32)

	{

	    asm volatile(

		PREFETCH"" 32%1\n\t""

	        ""movq	%1, %%mm0\n\t""

	        ""movq	8%1, %%mm2\n\t""

	        ""movq	16%1, %%mm4\n\t""

	        ""movq	24%1, %%mm6\n\t""

	        ""movq	%%mm0, %%mm1\n\t""

	        ""movq	%%mm2, %%mm3\n\t""

	        ""movq	%%mm4, %%mm5\n\t""

	        ""movq	%%mm6, %%mm7\n\t""

		""punpcklbw %%mm0, %%mm0\n\t""

		""punpckhbw %%mm1, %%mm1\n\t""

		""punpcklbw %%mm2, %%mm2\n\t""

		""punpckhbw %%mm3, %%mm3\n\t""

		""punpcklbw %%mm4, %%mm4\n\t""

		""punpckhbw %%mm5, %%mm5\n\t""

		""punpcklbw %%mm6, %%mm6\n\t""

		""punpckhbw %%mm7, %%mm7\n\t""

		MOVNTQ""	%%mm0, %0\n\t""

		MOVNTQ""	%%mm1, 8%0\n\t""

		MOVNTQ""	%%mm2, 16%0\n\t""

		MOVNTQ""	%%mm3, 24%0\n\t""

		MOVNTQ""	%%mm4, 32%0\n\t""

		MOVNTQ""	%%mm5, 40%0\n\t""

		MOVNTQ""	%%mm6, 48%0\n\t""

		MOVNTQ""	%%mm7, 56%0""

		:""=m""(d[2*x])

		:""m""(s1[x])

		:""memory"");

	}

#endif

	for(;x<w;x++) d[2*x]=d[2*x+1]=s1[x];

    }

    for(y=0;y<h;y++){

	const uint8_t* s2=src2+srcStride2*(y>>1);

	uint8_t* d=dst2+dstStride2*y;

	x=0;

#ifdef HAVE_MMX

	for(;x<w-31;x+=32)

	{

	    asm volatile(

		PREFETCH"" 32%1\n\t""

	        ""movq	%1, %%mm0\n\t""

	        ""movq	8%1, %%mm2\n\t""

	        ""movq	16%1, %%mm4\n\t""

	        ""movq	24%1, %%mm6\n\t""

	        ""movq	%%mm0, %%mm1\n\t""

	        ""movq	%%mm2, %%mm3\n\t""

	        ""movq	%%mm4, %%mm5\n\t""

	        ""movq	%%mm6, %%mm7\n\t""

		""punpcklbw %%mm0, %%mm0\n\t""

		""punpckhbw %%mm1, %%mm1\n\t""

		""punpcklbw %%mm2, %%mm2\n\t""

		""punpckhbw %%mm3, %%mm3\n\t""

		""punpcklbw %%mm4, %%mm4\n\t""

		""punpckhbw %%mm5, %%mm5\n\t""

		""punpcklbw %%mm6, %%mm6\n\t""

		""punpckhbw %%mm7, %%mm7\n\t""

		MOVNTQ""	%%mm0, %0\n\t""

		MOVNTQ""	%%mm1, 8%0\n\t""

		MOVNTQ""	%%mm2, 16%0\n\t""

		MOVNTQ""	%%mm3, 24%0\n\t""

		MOVNTQ""	%%mm4, 32%0\n\t""

		MOVNTQ""	%%mm5, 40%0\n\t""

		MOVNTQ""	%%mm6, 48%0\n\t""

		MOVNTQ""	%%mm7, 56%0""

		:""=m""(d[2*x])

		:""m""(s2[x])

		:""memory"");

	}

#endif

	for(;x<w;x++) d[2*x]=d[2*x+1]=s2[x];

    }

#ifdef HAVE_MMX

	asm(

		EMMS"" \n\t""

		SFENCE"" \n\t""

		::: ""memory""

		);

#endif

}
",809,,LABEL_1,LABEL_1,LABEL_1,-1,"src1,src2,dst1,dst2,height,srcStride1,srcStride2,dstStride1,dstStride2,y,x,w,h,s1,d,s2",,,,0,,0,GA,3105,1.2710066000620523,failed,
495,"static int svq1_decode_frame_header(GetBitContext *bitbuf, MpegEncContext *s)

{

    int frame_size_code;



    skip_bits(bitbuf, 8); /* temporal_reference */



    /* frame type */

    s->pict_type = get_bits(bitbuf, 2) + 1;

    if (s->pict_type == 4)

        return AVERROR_INVALIDDATA;



    if (s->pict_type == AV_PICTURE_TYPE_I) {

        /* unknown fields */

        if (s->f_code == 0x50 || s->f_code == 0x60) {

            int csum = get_bits(bitbuf, 16);



            csum = ff_svq1_packet_checksum(bitbuf->buffer,

                                           bitbuf->size_in_bits >> 3,

                                           csum);



            av_dlog(s->avctx, ""%s checksum (%02x) for packet data\n"",

                    (csum == 0) ? ""correct"" : ""incorrect"", csum);

        }



        if ((s->f_code ^ 0x10) >= 0x50) {

            uint8_t msg[256];



            svq1_parse_string(bitbuf, msg);



            av_log(s->avctx, AV_LOG_ERROR,

                   ""embedded message: \""%s\""\n"", (char *)msg);

        }



        skip_bits(bitbuf, 2);

        skip_bits(bitbuf, 2);

        skip_bits1(bitbuf);



        /* load frame size */

        frame_size_code = get_bits(bitbuf, 3);



        if (frame_size_code == 7) {

            /* load width, height (12 bits each) */

            s->width  = get_bits(bitbuf, 12);

            s->height = get_bits(bitbuf, 12);



            if (!s->width || !s->height)

                return AVERROR_INVALIDDATA;

        } else {

            /* get width, height from table */

            s->width  = ff_svq1_frame_size_table[frame_size_code].width;

            s->height = ff_svq1_frame_size_table[frame_size_code].height;

        }

    }



    /* unknown fields */

    if (get_bits1(bitbuf) == 1) {

        skip_bits1(bitbuf);    /* use packet checksum if (1) */

        skip_bits1(bitbuf);    /* component checksums after image data if (1) */



        if (get_bits(bitbuf, 2) != 0)

            return AVERROR_INVALIDDATA;

    }



    if (get_bits1(bitbuf) == 1) {

        skip_bits1(bitbuf);

        skip_bits(bitbuf, 4);

        skip_bits1(bitbuf);

        skip_bits(bitbuf, 2);



        while (get_bits1(bitbuf) == 1)

            skip_bits(bitbuf, 8);

    }



    return 0;

}
",459,"static int svq1_decode_frame_header(GetBitContext *Bitbuff, MpegEncContext *b)

{

    int frame_sizefullcode;



    skip_bits(Bitbuff, 8); /* temporal_reference */



    /* frame type */

    sb>pict_type = get_bits(Bitbuff, 2) + 1;

    if (b->pict_type == 4)

        return AVERROR_INVALIDDATA;



    if (b->pict_type == AV_PICTURE_TYPE_I) {

        /* unknown fields */

        if (b->f_code == 0x50 || b->f_code == 0x60) {

            int csum = get_bits(Bitbuff, 16);



            csum = ff_svq1_packet_checksum(Bitbuff->buffer,

                                           Bitbuff->size_in_bits >> 3,

                                           csum);



            av_dlog(b->avctx, ""%b checksum (%02x) for packet data
"",

                    (csum == 0) ? ""correct"" : ""incorrect"", csum);

        }



        if ((b->f_code ^ 0x10) >= 0x50) {

            uint8_t alloc[256];



            svq1_parse_string(Bitbuff, alloc);



            av_log(b->avctx, AV_LOG_ERROR,

                   ""embedded message: \""%s\""
"", (char *)alloc);

        }



        skip_bits(Bitbuff, 2);

        skip_bits(Bitbuff, 2);

        skip_bits1(Bitbuff);



        /* load frame size */

        fframe_sizefullcode= get_bits(Bitbuff, 3);



        if (frame_sizefullcode == 7) {

            /* load width, height (12 bits each) */

            sb>width  = get_bits(Bitbuff, 12);

            sb>height = get_bits(Bitbuff, 12);



            if (!s->width || !s->height)

                return AVERROR_INVALIDDATA;

        } else {

            /* get width, height from table */

            b->width  = ff_svq1_frame_size_table[frame_sizefullcode].width;

            b->height = ff_svq1_frame_size_table[frame_sizefullcode].height;

        }

    }



    /* unknown fields */

    if (get_bits1(Bitbuff) == 1) {

        skip_bits1(Bitbuff);    /* use packet checksum if (1) */

        skip_bits1(Bitbuff);    /* component checksums after image data if (1) */



        if (get_bits(Bitbuff, 2) != 0)

            return AVERROR_INVALIDDATA;

    }



    if (get_bits1(Bitbuff) == 1) {

        skip_bits1(Bitbuff);

        skip_bits(Bitbuff, 4);

        skip_bits1(Bitbuff);

        skip_bits(Bitbuff, 2);



        while (get_bits1(Bitbuff) == 1)

            skip_bits(Bitbuff, 8);

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bitbuf,s,frame_size_code,msg",,,,0,"bitbuf:Bitbuff,s:b,frame_size_code:frame_sizefullcode,msg:alloc,",0,GA,424,0.12737510999043783,GA,
496,"static av_always_inline void rv40_strong_loop_filter(uint8_t *src,

                                                     const int step,

                                                     const int stride,

                                                     const int alpha,

                                                     const int lims,

                                                     const int dmode,

                                                     const int chroma)

{

    int i;



    for(i = 0; i < 4; i++, src += stride){

        int sflag, p0, q0, p1, q1;

        int t = src[0*step] - src[-1*step];



        if (!t)

            continue;



        sflag = (alpha * FFABS(t)) >> 7;

        if (sflag > 1)

            continue;



        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +

              26*src[ 0*step] + 25*src[ 1*step] +

              rv40_dither_l[dmode + i]) >> 7;



        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +

              26*src[ 1*step] + 25*src[ 2*step] +

              rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);

            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);

        }



        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +

              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;

        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +

              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;



        if (sflag) {

            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);

            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);

        }



        src[-2*step] = p1;

        src[-1*step] = p0;

        src[ 0*step] = q0;

        src[ 1*step] = q1;



        if(!chroma){

            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +

                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;

            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +

                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;

        }

    }

}
",609,,LABEL_1,LABEL_0,,-4,"src,step,stride,alpha,lims,dmode,chroma,i,sflag,p0,q0,p1,q1",,,,0,,0,Greedy,1,0.0006580432256062825,,
497,"void qmp_transaction(TransactionActionList *dev_list, Error **errp)

{

    TransactionActionList *dev_entry = dev_list;

    BlkTransactionState *state, *next;

    Error *local_err = NULL;



    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;

    QSIMPLEQ_INIT(&snap_bdrv_states);



    /* drain all i/o before any operations */

    bdrv_drain_all();



    /* We don't do anything in this loop that commits us to the operations */

    while (NULL != dev_entry) {

        TransactionAction *dev_info = NULL;

        const BdrvActionOps *ops;



        dev_info = dev_entry->value;

        dev_entry = dev_entry->next;



        assert(dev_info->kind < ARRAY_SIZE(actions));



        ops = &actions[dev_info->kind];

        assert(ops->instance_size > 0);



        state = g_malloc0(ops->instance_size);

        state->ops = ops;

        state->action = dev_info;

        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);



        state->ops->prepare(state, &local_err);

        if (local_err) {

            error_propagate(errp, local_err);

            goto delete_and_fail;

        }

    }



    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {

        if (state->ops->commit) {

            state->ops->commit(state);

        }

    }



    /* success */

    goto exit;



delete_and_fail:

    /* failure, and it is all-or-none; roll back all operations */

    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {

        if (state->ops->abort) {

            state->ops->abort(state);

        }

    }

exit:

    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {

        if (state->ops->clean) {

            state->ops->clean(state);

        }

        g_free(state);

    }

}
",351,"void qmp_transaction(TransactionActionList *ev_cont, Error **errorp)

{

    TransactionActionList dev_eventy = ev_cont;

    BlkTransactionState *state, *next;

    Error *local_err = NULL;



    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;

    QSIMPLEQ_INIT(&snap_bdrv_states);



    /* drain all i/o before any operations */

    bdrv_drain_all();



    /* We don't do anything in this loop that commits us to the operations */

    while (NULL != dev_event) {

        TransactionAction *dev_info = NULL;

        const BdrvActionOps *ops;



        dev_info = dev_event->value;

        dev_event = dev_event->next;



        assert(dev_info->kind < ARRAY_SIZE(actions));



        ops = &actions[dev_info->kind];

        assert(ops->instance_size > 0);



        state = g_malloc0(ops->instance_size);

        state->ops = ops;

        state->action = dev_info;

        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);



        state->ops->prepare(state, &local_err);

        if (local_err) {

            error_propagate(errorp, local_err);

            goto delete_and_fail;

        }

    }



    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {

        if (state->ops->commit) {

            state->ops->commit(state);

        }

    }



    /* success */

    goto exit;



delete_and_fail:

    /* failure, and it is all-or-none; roll back all operations */

    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {

        if (state->ops->abort) {

            state->ops->abort(state);

        }

    }

exit:

    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {

        if (state->ops->clean) {

            state->ops->clean(state);

        }

        g_free(state);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"dev_list,errp,dev_entry,state,next,local_err,dev_info,ops",,,,45,"dev_list:ev_cont,errp:errorp,dev_entry:dev_event,state:state,next:next,local_err:local_err,dev_info:dev_info,ops:ops,",5,GA,434,0.13250070412953693,GA,
498,"static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,

                                 unsigned size)

{

    PICCommonState *s = opaque;

    return s->elcr;

}
",30,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,size,s",,,,0,,0,GA,812,0.18252357641855876,failed,
499,"static int opt_input_file(const char *opt, const char *filename)

{

    AVFormatContext *ic;

    AVInputFormat *file_iformat = NULL;

    int err, i, ret, rfps, rfps_base;

    int64_t timestamp;

    uint8_t buf[128];

    AVDictionary **opts;

    int orig_nb_streams;                     // number of streams before avformat_find_stream_info



    if (last_asked_format) {

        if (!(file_iformat = av_find_input_format(last_asked_format))) {

            fprintf(stderr, ""Unknown input format: '%s'\n"", last_asked_format);

            ffmpeg_exit(1);

        }

        last_asked_format = NULL;

    }



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    using_stdin |= !strncmp(filename, ""pipe:"", 5) ||

                    !strcmp(filename, ""/dev/stdin"");



    /* get default parameters from command line */

    ic = avformat_alloc_context();

    if (!ic) {

        print_error(filename, AVERROR(ENOMEM));

        ffmpeg_exit(1);

    }

    if (audio_sample_rate) {

        snprintf(buf, sizeof(buf), ""%d"", audio_sample_rate);

        av_dict_set(&format_opts, ""sample_rate"", buf, 0);

    }

    if (audio_channels) {

        snprintf(buf, sizeof(buf), ""%d"", audio_channels);

        av_dict_set(&format_opts, ""channels"", buf, 0);

    }

    if (frame_rate.num) {

        snprintf(buf, sizeof(buf), ""%d/%d"", frame_rate.num, frame_rate.den);

        av_dict_set(&format_opts, ""framerate"", buf, 0);

    }

    if (frame_width && frame_height) {

        snprintf(buf, sizeof(buf), ""%dx%d"", frame_width, frame_height);

        av_dict_set(&format_opts, ""video_size"", buf, 0);

    }

    if (frame_pix_fmt != PIX_FMT_NONE)

        av_dict_set(&format_opts, ""pixel_format"", av_get_pix_fmt_name(frame_pix_fmt), 0);



    ic->video_codec_id   =

        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0);

    ic->audio_codec_id   =

        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0);

    ic->subtitle_codec_id=

        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0);

    ic->flags |= AVFMT_FLAG_NONBLOCK;



    /* open the input file with generic libav function */

    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);

    if (err < 0) {

        print_error(filename, err);

        ffmpeg_exit(1);

    }

    assert_avoptions(format_opts);



    if(opt_programid) {

        int i, j;

        int found=0;

        for(i=0; i<ic->nb_streams; i++){

            ic->streams[i]->discard= AVDISCARD_ALL;

        }

        for(i=0; i<ic->nb_programs; i++){

            AVProgram *p= ic->programs[i];

            if(p->id != opt_programid){

                p->discard = AVDISCARD_ALL;

            }else{

                found=1;

                for(j=0; j<p->nb_stream_indexes; j++){

                    ic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT;

                }

            }

        }

        if(!found){

            fprintf(stderr, ""Specified program id not found\n"");

            ffmpeg_exit(1);

        }

        opt_programid=0;

    }



    if (loop_input) {

        av_log(NULL, AV_LOG_WARNING, ""-loop_input is deprecated, use -loop 1\n"");

        ic->loop_input = loop_input;

    }



    /* Set AVCodecContext options for avformat_find_stream_info */

    opts = setup_find_stream_info_opts(ic, codec_opts);

    orig_nb_streams = ic->nb_streams;



    /* If not enough info to get the stream parameters, we decode the

       first frames to get it. (used in mpeg case for example) */

    ret = avformat_find_stream_info(ic, opts);

    if (ret < 0 && verbose >= 0) {

        fprintf(stderr, ""%s: could not find codec parameters\n"", filename);

        av_close_input_file(ic);

        ffmpeg_exit(1);

    }



    timestamp = start_time;

    /* add the stream start time */

    if (ic->start_time != AV_NOPTS_VALUE)

        timestamp += ic->start_time;



    /* if seeking requested, we execute it */

    if (start_time != 0) {

        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);

        if (ret < 0) {

            fprintf(stderr, ""%s: could not seek to position %0.3f\n"",

                    filename, (double)timestamp / AV_TIME_BASE);

        }

        /* reset seek info */

        start_time = 0;

    }



    /* update the current parameters so that they match the one of the input stream */

    for(i=0;i<ic->nb_streams;i++) {

        AVStream *st = ic->streams[i];

        AVCodecContext *dec = st->codec;

        InputStream *ist;



        dec->thread_count = thread_count;



        input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1);

        ist = &input_streams[nb_input_streams - 1];

        ist->st = st;

        ist->file_index = nb_input_files;

        ist->discard = 1;

        ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0);



        if (i < nb_ts_scale)

            ist->ts_scale = ts_scale[i];



        switch (dec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->dec = avcodec_find_decoder_by_name(audio_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            if(audio_disable)

                st->discard= AVDISCARD_ALL;

            break;

        case AVMEDIA_TYPE_VIDEO:

            ist->dec= avcodec_find_decoder_by_name(video_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            rfps      = ic->streams[i]->r_frame_rate.num;

            rfps_base = ic->streams[i]->r_frame_rate.den;

            if (dec->lowres) {

                dec->flags |= CODEC_FLAG_EMU_EDGE;

            }

            if(me_threshold)

                dec->debug |= FF_DEBUG_MV;



            if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {



                if (verbose >= 0)

                    fprintf(stderr,""\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\n"",

                            i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,



                    (float)rfps / rfps_base, rfps, rfps_base);

            }



            if(video_disable)

                st->discard= AVDISCARD_ALL;

            else if(video_discard)

                st->discard= video_discard;

            break;

        case AVMEDIA_TYPE_DATA:

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            if(subtitle_disable)

                st->discard = AVDISCARD_ALL;

            break;

        case AVMEDIA_TYPE_ATTACHMENT:

        case AVMEDIA_TYPE_UNKNOWN:

            break;

        default:

            abort();

        }

    }



    /* dump the file content */

    if (verbose >= 0)

        av_dump_format(ic, nb_input_files, filename, 0);



    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);

    input_files[nb_input_files - 1].ctx        = ic;

    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;

    input_files[nb_input_files - 1].ts_offset  = input_ts_offset - (copy_ts ? 0 : timestamp);



    top_field_first = -1;

    frame_rate    = (AVRational){0, 0};

    frame_pix_fmt = PIX_FMT_NONE;

    frame_height = 0;

    frame_width  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    av_freep(&ts_scale);

    nb_ts_scale = 0;



    for (i = 0; i < orig_nb_streams; i++)

        av_dict_free(&opts[i]);

    av_freep(&opts);

    av_freep(&video_codec_name);

    av_freep(&audio_codec_name);

    av_freep(&subtitle_codec_name);

    uninit_opts();

    init_opts();

    return 0;

}
",1569,"static int opt_input_file(const char *command, const char *method)

{

    AVFormatContext *abc;

    AVInputFormat *file_ionicat = NULL;

    int rr, i, ret, rfps, rfps_base;

    int64_t imend;

    uint8_t buf[128];

    AVDictionary **optes;

    int  orig_nb_streampoints;                     // number of streams before avformat_find_stream_info



    if (last_asked_format) {

        if (!(file_ionicat = av_find_input_format(last_asked_format))) {

            fprintf(stderr, ""Unknown input format: '%s'
"", last_asked_format);

            ffmpeg_exit(1);

        }

        last_asked_format = NULL;

    }



    if (!strcmp(method, ""-""))

        method = ""pipe:"";



    using_stdin |= !strncmp(method, ""pipe:"", 5) ||

                    !strcmp(method, ""/dev/stdin"");



    /* get default parameters from command line */

    abc = avformat_alloc_context();

    if (!ic) {

        print_error(method, AVERROR(ENOMEM));

        ffmpeg_exit(1);

    }

    if (audio_sample_rate) {

        snprintf(buf, sizeof(buf), ""%d"", audio_sample_rate);

        av_dict_set(&format_opts, ""sample_rate"", buf, 0);

    }

    if (audio_channels) {

        snprintf(buf, sizeof(buf), ""%d"", audio_channels);

        av_dict_set(&format_opts, ""channels"", buf, 0);

    }

    if (frame_rate.num) {

        snprintf(buf, sizeof(buf), ""%d/%d"", frame_rate.num, frame_rate.den);

        av_dict_set(&format_opts, ""framerate"", buf, 0);

    }

    if (frame_width && frame_height) {

        snprintf(buf, sizeof(buf), ""%dx%d"", frame_width, frame_height);

        av_dict_set(&format_opts, ""video_size"", buf, 0);

    }

    if (frame_pix_fmt != PIX_FMT_NONE)

        av_dict_set(&format_opts, ""pixel_format"", av_get_pix_fmt_name(frame_pix_fmt), 0);



    abc->video_codec_id   =

        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0);

    abc->audio_codec_id   =

        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0);

    abc->subtitle_codec_id=

        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0);

    abc->flags |= AVFMT_FLAG_NONBLOCK;



    /* open the input file with generic libav function */

   rrr = avformat_open_inputabcic, method, file_ionicat, &format_opts);

    if (rr < 0) {

        print_error(method, rr);

        ffmpeg_exit(1);

    }

    assert_avoptions(format_opts);



    if(opt_programid) {

        int i, j;

        int found=0;

        for(ii0; iiabc->nb_streams; i++){

            abc->streams[i]->discard= AVDISCARD_ALL;

        }

        for(ii0; iiabc->nb_programs; i++){

            AVProgram *p= abc->programs[i];

            if(p->id != opt_programid){

                p->discard = AVDISCARD_ALL;

            }else{

                found=1;

                for(j=0; j<p->nb_stream_indexes; j++){

                    abc->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT;

                }

            }

        }

        if(!found){

            fprintf(stderr, ""Specified program id not found
"");

            ffmpeg_exit(1);

        }

        opt_programid=0;

    }



    if (loop_input) {

        av_log(NULL, AV_LOG_WARNING, ""-loop_input is deprecated, use -loop 1
"");

        abc->loop_input = loop_input;

    }



    /* Set AVCodecContext options for avformat_find_stream_info */

    ooptes= setup_find_stream_info_opts(abc, codec_opts);

    o orig_nb_streampoints= abc->nb_streams;



    /* If not enough info to get the stream parameters, we decode the

       first frames to get it. (used in mpeg case for example) */

    rret= avformat_find_stream_info(abc, optes);

    if (ret < 0 && verbose >= 0) {

        fprintf(stderr, ""%s: could not find codec parameters
"", method);

        av_close_input_file(abc);

        ffmpeg_exit(1);

    }



    imend = start_time;

    /* add the stream start time */

    if (abc->start_time != AV_NOPTS_VALUE)

        timend+= abc->start_time;



    /* if seeking requested, we execute it */

    if (start_time != 0) {

        rret= av_seek_frame(abc, -1, imend, AVSEEK_FLAG_BACKWARD);

        if (ret < 0) {

            fprintf(stderr, ""%s: could not seek to position %0.3f
"",

                    method, (double)imend / AV_TIME_BASE);

        }

        /* reset seek info */

        start_time = 0;

    }



    /* update the current parameters so that they match the one of the input stream */

    for(ii0;iiabc->nb_streams;i++) {

        AVStream *st = abc->streams[i];

        AVCodecContext *dec = st->codec;

        InputStream *ist;



        dec->thread_count = thread_count;



        input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1);

        ist = &input_streams[nb_input_streams - 1];

        ist->st = st;

        ist->file_index = nb_input_files;

        ist->discard = 1;

        ist->optes = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0);



        if (i < nb_ts_scale)

            ist->ts_scale = ts_scale[i];



        switch (dec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->dec = avcodec_find_decoder_by_name(audio_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            if(audio_disable)

                st->discard= AVDISCARD_ALL;

            break;

        case AVMEDIA_TYPE_VIDEO:

            ist->dec= avcodec_find_decoder_by_name(video_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            rrfps     = abc->streams[i]->r_frame_rate.num;

            rrfps_base= abc->streams[i]->r_frame_rate.den;

            if (dec->lowres) {

                dec->flags |= CODEC_FLAG_EMU_EDGE;

            }

            if(me_threshold)

                dec->debug |= FF_DEBUG_MV;



            if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {



                if (verbose >= 0)

                    fprintf(stderr,""
Seems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)
"",

                            i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,



                    (float)rfps / rfps_base, rfps, rfps_base);

            }



            if(video_disable)

                st->discard= AVDISCARD_ALL;

            else if(video_discard)

                st->discard= video_discard;

            break;

        case AVMEDIA_TYPE_DATA:

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name);

            if(!ist->dec)

                ist->dec = avcodec_find_decoder(dec->codec_id);

            if(subtitle_disable)

                st->discard = AVDISCARD_ALL;

            break;

        case AVMEDIA_TYPE_ATTACHMENT:

        case AVMEDIA_TYPE_UNKNOWN:

            break;

        default:

            abort();

        }

    }



    /* dump the file content */

    if (verbose >= 0)

        av_dump_formaabcic, nb_input_files, method, 0);



    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);

    input_files[nb_input_files - 1].ctx        = abc;

    input_files[nb_input_files - 1].ist_index  = nb_input_streams - abc->nb_streams;

    input_files[nb_input_files - 1].ts_offset  = input_ts_offset - (copy_ts ? 0 : imend);



    top_field_first = -1;

    frame_rate    = (AVRational){0, 0};

    frame_pix_fmt = PIX_FMT_NONE;

    frame_height = 0;

    frame_width  = 0;

    audio_sample_rate = 0;

    audio_channels    = 0;

    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;

    av_freep(&ts_scale);

    nb_ts_scale = 0;



    for (i = 0; i <  orig_nb_streampoints; i++)

        av_dict_free(&optes[i]);

    av_freep(&optes);

    av_freep(&video_codec_name);

    av_freep(&audio_codec_name);

    av_freep(&subtitle_codec_name);

    uninit_opts();

    init_opts();

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"opt,filename,ic,file_iformat,err,i,ret,rfps,rfps_base,timestamp,buf,opts,orig_nb_streams",,,,51,"opt:command,filename:method,ic:abc,file_iformat:file_ionicat,err:rr,i:i,ret:ret,rfps:rfps,rfps_base:rfps_base,timestamp:imend,buf:buf,opts:optes,orig_nb_streams: orig_nb_streampoints,",5,GA,577,0.2797833323478699,GA,
