{"project": "FFmpeg", "commit_id": "2f6ec9fdd7808c8ed045ae0ca4134ab21fb785e6", "target": 1, "func": "static int alloc_sequence_buffers(DiracContext *s)\n\n{\n\n    int sbwidth  = DIVRNDUP(s->source.width,  4);\n\n    int sbheight = DIVRNDUP(s->source.height, 4);\n\n    int i, w, h, top_padding;\n\n\n\n    /* todo: think more about this / use or set Plane here */\n\n    for (i = 0; i < 3; i++) {\n\n        int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0);\n\n        int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0);\n\n        w = s->source.width  >> (i ? s->chroma_x_shift : 0);\n\n        h = s->source.height >> (i ? s->chroma_y_shift : 0);\n\n\n\n        /* we allocate the max we support here since num decompositions can\n\n         * change from frame to frame. Stride is aligned to 16 for SIMD, and\n\n         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding\n\n         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that\n\n         * on each side */\n\n        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);\n\n        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Should this be 16 for SSE??? */\n\n        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;\n\n\n\n        s->plane[i].idwt_buf_base = av_mallocz((w+max_xblen)*h * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_tmp      = av_malloc((w+16) * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_buf      = s->plane[i].idwt_buf_base + top_padding*w;\n\n        if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    w = s->source.width;\n\n    h = s->source.height;\n\n\n\n    /* fixme: allocate using real stride here */\n\n    s->sbsplit  = av_malloc(sbwidth * sbheight);\n\n    s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion));\n\n    s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    s->mctmp     = av_malloc((w+64+MAX_BLOCKSIZE) * (h*MAX_BLOCKSIZE) * sizeof(*s->mctmp));\n\n    s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    if (!s->sbsplit || !s->blmotion)\n\n        return AVERROR(ENOMEM);\n\n    return 0;\n\n}\n", "idx": 13899, "substitutes": {"s": ["native", "rs", "qs", "x", "js", "si", "ps", "params", "spec", "c", "is", "sc", "sv", "states", "aws", "args", "m", "self", "d", "sync", "t", "sg", "fs", "ins", "sym", "sup", "g", "cs", "uses", "es", "session", "u", "b", "sf", "ns", "ops", "r", "ks", "secondary", "sys", "parts", "service", "os", "sets", "o", "e", "site", "sb", "features", "f", "ans", "services", "ls", "ses", "l", "a", "S", "settings", "its", "uns", "sq", "conf", "ss", "p", "se", "n", "gs", "xs", "ssl", "ds", "src", "su", "ts", "us", "vs", "y"], "i": ["ish", "oi", "image", "x", "si", "phi", "is", "ji", "zi", "in", "index", "hi", "m", "part", "d", "xi", "id", "iu", "iv", "io", "di", "u", "fi", "inst", "ti", "ski", "ip", "eni", "inner", "bi", "mu", "qi", "ni", "ini", "ci", "ie", "init", "o", "iii", "e", "info", "li", "ix", "multi", "j", "f", "ij", "it", "ui", "I", "input", "ai", "l", "gi", "ii", "v", "uri", "yi", "p", "mini", "cli", "mi", "n", "pi", "chi", "ic", "ri", "ik", "ei", "y", "esi", "start"], "w": ["m", "wh", "d", "t", "iw", "l", "ww", "ew", "g", "wan", "weight", "wx", "sw", "wt", "x", "how", "v", " W", "nw", "wn", "kw", "win", "u", "z", "wave", "p", "wal", "aw", "max", "b", "wb", "n", "f", "rw", "wp", "c", "W", "tw", "ow", "wa", "q", "wen", "r", "wall", "we", "hw", "work", "wrap", "wo", "wl", "wd", "y", "fw"], "h": ["hi", "m", "en", "wh", "ha", "d", "t", "hr", "oh", "l", "ah", "g", "hs", "sw", "x", "gh", "v", "rh", "o", "uh", "ul", "z", "u", "p", "e", "he", "max", "b", "n", "f", "padding", "hm", "bh", "c", "ht", "wa", "q", "r", "H", "sh", "hw", "ph", "y", "height"], "top_padding": ["TOP_adding", "TOP_margin", "Top_inning", "TOP__adding", " top_margin", "bottom_adding", "top_inning", "Top_pad", "Top_padding", "bottom_margin", "bottom_padding", "top__margin", " top_adding", "TOP_padding", "TOP__margin", "top_margin", "TOP_pad", "TOP__padding", "top_pad", "top_adding", "Top_margin", "top__adding", "top__pad", "bottom_pad", "top__padding", "TOP__pad", " top_pad"]}}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void con_disconnect(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n\n\n    if (con->chr) {\n\n        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);\n\n        qemu_chr_fe_release(con->chr);\n\n    }\n\n    xen_be_unbind_evtchn(&con->xendev);\n\n\n\n    if (con->sring) {\n\n        if (!xendev->dev) {\n\n            munmap(con->sring, XC_PAGE_SIZE);\n\n        } else {\n\n            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);\n\n        }\n\n        con->sring = NULL;\n\n    }\n\n}\n", "idx": 6650, "substitutes": {"xendev": ["xEndow", "xendingow", "xenddev", "xendedever", "xendingdev", "xEnderv", "xentdev", "xendr", "ystartep", "xndown", "xentown", "exenddev", "xendsep", "xendedev", "wxentown", "xendown", "xendep", "xendedr", "xendingr", "xendsdev", "xendingev", "xestdev", "exnddev", "txendingow", "exendee", " xenddev", "exndever", "xndove", "xstartdev", "xentee", "ystartev", "yendev", "xenderv", "Xendedev", " xestee", "exndee", "txendr", "xstartev", "txendingev", "exendever", "yendoc", "xstartoc", "xinddev", "xnderv", "txenderv", "xndee", "xestever", "ystartoc", "xendever", "Xendove", "yendep", "xndever", "xendedown", "Xendedove", " xendee", "xendedove", "wxentev", " xendever", "xentep", "xendove", " xestdev", "exndev", "xindever", "Xendeddev", "xendsoc", "xendederv", "txendingr", "xendingerv", "wxendev", "xEndr", "xestev", "xendeddev", "Xendederv", "txendow", "xentever", "xendee", "xenterv", "xendsev", "Xendev", " xestev", "yenddev", "xndev", "xentoc", "exendev", "wxenderv", "xendow", "xendedow", "xendingove", " xestever", "wxenterv", "xstartep", "wxendown", "xendoc", "Xenderv", "ystartdev", "xendedee", "wxenddev", "txendev", "txendingerv", "xnddev", "xestee", "xindev", "xentev", "wxentdev", "Xenddev", "xEndev", "xindee"], "con": ["fat", "Con", "cr", "pan", "ann", "sec", "open", "pen", "pin", "wan", "non", "cat", "co", "canon", "uc", "CON", "ran", "hel", "cm", "cl", "client", "conv", "ain", "gin", "pc", "cc", "connect", "conf", "cons", "acon", "col", "close", "connection", "en", "an", "scan", "func", "fn", "ocon", "fac", "exec", "container", "fa", "common", "ctrl", "ca", "ec", "run", "un", "don", "fun", "c", "can", "cn", "cf", "core", "fc", "ban", "ac", "cache", "syn", "bn", "conn"]}}
{"project": "qemu", "commit_id": "654598c944aa31cdbea435bd468055af9c918d16", "target": 1, "func": "static void pc_fw_add_pflash_drv(void)\n\n{\n\n    QemuOpts *opts;\n\n    QEMUMachine *machine;\n\n    char *filename;\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = BIOS_FILENAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n\n\n    opts = drive_add(IF_PFLASH, -1, filename, \"readonly=on\");\n\n\n\n    g_free(filename);\n\n\n\n    if (opts == NULL) {\n\n      return;\n\n    }\n\n\n\n    machine = find_default_machine();\n\n    if (machine == NULL) {\n\n      return;\n\n    }\n\n\n\n    drive_init(opts, machine->use_scsi);\n\n}\n", "idx": 22615, "substitutes": {"opts": [" optt", "opments", "OPta", "opcs", "otta", "OPts", "operts", "otments", " opats", "OPcs", " opt", "opta", "operta", "opttes", "opt", " opcs", "optments", " optats", " optcs", "opTS", "operTS", " optts", " opTS", "opttt", "otts", "ottes", "optt", "optats", "optes", " opta", "OPt", "optTS", " optes", "opats", "optcs", " opments", "optta", " optments", "optts", "opertt"], "machine": ["computer", "name", "object", "app", "controller", "project", "message", "connection", "mode", "file", "handler", "plugin", "company", "engine", "node", "device", "mobile", "model", "host", "builder", "slave", "info", "m", "bug", "mc", "oper", "mac", "record", "module", "source", "money", "b", "office", "loader", "service", "rule", "window", "mage", "session", "media", "division", "editor", "element", "database", "parent", "boot", "template", "manager", "vm", "user", "instance", "folder", "image", "Machine", "server", "base", "interface", "creator"], "filename": ["package", "name", "binary", "txt", "password", "download", "il", "message", "utf", "file", "metadata", "phrase", "fax", "fp", "mpeg", "f", "path", "original", "sequence", "full", "nil", "wl", "kl", "prefix", "sheet", "directory", "word", "kn", "buf", "title", "document", "ema", "b", "rl", "location", "fd", "length", "sf", "jpg", "dll", "database", "ppa", "bf", "fil", "fn", "SourceFile", "username", "files", "folder", "l", "Filename", "url"]}}
{"project": "qemu", "commit_id": "d2ca7c0b0d876cf0e219ae7a92252626b0913a28", "target": 0, "func": "void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)\n\n{\n\n    lexer->emit = func;\n\n    lexer->state = IN_START;\n\n    lexer->token = qstring_new();\n\n    lexer->x = lexer->y = 0;\n\n}\n", "idx": 402, "substitutes": {"lexer": ["Lexer", "signer", "exe", "sexe", " lexger", "lexor", "exter", "sexener", "Lexter", "flexator", " lexler", " lexor", "sexer", "exener", "Lexler", " lexter", "signger", "sexler", " lexe", "flexter", "flexor", "exger", "sexger", "signator", "lexler", "Lexger", "flexe", "lexe", "flexger", "sexter", "exer", "exler", "lexator", "lexener", "signe", "flexler", "flexener", "lexger", "Lexe", "lexter", " lexener", "flexer", "sexor", "Lexor", " lexator"], "func": ["parser", "this", "ctx", "conn", "context", "data", "class", "callback", "fn", "tc", "buf", "instance", "package", "super", "proc", "util", "parse", "function", "x", "c", "reader", "e", "self", "unc", "f", "lc", "attr", "token", "text", "Function", "handler", "obj", "node", "as", "pc", "lib", "prefix", "b", "xxx"]}}
{"project": "qemu", "commit_id": "b9c532903fa528891c0eceb34ea40a0c47bfb5db", "target": 0, "func": "static int qemu_rbd_snap_list(BlockDriverState *bs,\n\n                              QEMUSnapshotInfo **psn_tab)\n\n{\n\n    BDRVRBDState *s = bs->opaque;\n\n    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;\n\n    int i, snap_count;\n\n    rbd_snap_info_t *snaps;\n\n    int max_snaps = RBD_MAX_SNAPS;\n\n\n\n    do {\n\n        snaps = g_malloc(sizeof(*snaps) * max_snaps);\n\n        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);\n\n        if (snap_count < 0) {\n\n            g_free(snaps);\n\n        }\n\n    } while (snap_count == -ERANGE);\n\n\n\n    if (snap_count <= 0) {\n\n        return snap_count;\n\n    }\n\n\n\n    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));\n\n\n\n    for (i = 0; i < snap_count; i++) {\n\n        const char *snap_name = snaps[i].name;\n\n\n\n        sn_info = sn_tab + i;\n\n        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);\n\n        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);\n\n\n\n        sn_info->vm_state_size = snaps[i].size;\n\n        sn_info->date_sec = 0;\n\n        sn_info->date_nsec = 0;\n\n        sn_info->vm_clock_nsec = 0;\n\n    }\n\n    rbd_snap_list_end(snaps);\n\n\n\n    *psn_tab = sn_tab;\n\n    return snap_count;\n\n}\n", "idx": 11303, "substitutes": {"bs": ["vs", "ts", "bb", "ds", "bp", "b", "gs", "iss", "fb", "ls", "pb", "qs", "gb", "ins", "outs", "rs", "us", "BS", "os", "bc", "js", "obs", "cs", "aws", "bl", "bh", "state", "lb", "ns", "sb", "ps", "ses", "fs", "ss", "bos"], "psn_tab": ["psn2ab", "psn2tab", "psrn_loop", "psrn_tab", "pssn_ab", "psn_ab", "pssn_buf", "pssn_tmp", "psrn_Tab", "psn_Tab", "psn2loop", "pssn_tab", "psn2Tab", "psrn_ab", "psn_tmp", "psn_buf", "psn_loop"], "s": ["conf", "session", "is", "ds", "g", "m", "b", "ops", "sa", "c", "service", "p", "ls", "e", "js", "os", "f", "cs", "sym", "o", "aws", "S", "south", "states", "sl", "state", "services", "sup", "bis", "sn", "ns", "sb", "storage", "spec", "sys", "ses", "ps", "ss", "settings", "ssl"], "sn_info": ["sn_INFO", "nsJfo", "snpinfo", "snapappInfo", "snappinfo", "snJfo", "nsJinfo", "wn_info", "sw_part", "snametab", "wn_error", "snacinfo", "snpfo", "snacdata", "snninfo", "snap_Info", "snameinf", "sl_private", "sn_data", "nn_data", "snapJinit", "snactab", "snJinf", "sn_error", "snacinf", "snJinit", "snalldata", "snappstart", "sn__tab", "snapappinfo", "sn_init", "snap_inf", "sn_Info", "wn_field", "ns_inner", "sn_field", "nn_hand", "sw_info", "snapJinfo", "sn__manager", "snapJinf", "sw_start", "snperror", "snapacinfo", "sn_start", "ns_error", "nn_info", "snJinner", "ns_open", "snapJdata", "snamedata", "snap_data", "ns_comment", "sn_part", "snapacdata", "nsJerror", "sn_open", "snapappname", "sn__info", "snerinfo", "snapperror", "snncomment", "snnmanager", "snPinfo", " sn_manager", "snpinner", "sn_private", "swPpart", "sn_hand", "snappid", "ns_manager", "sl_error", "snallhand", "wn_id", "swPstart", "snap_init", "sn_manager", "snJinfo", "snerprivate", "snerINFO", "snJdata", "swPinfo", "snappfield", "sn_comment", "ns_info", "snapappstart", "snap_info", "snameinfo", "sn_fo", "sn_id", "sn__inf", "snappInfo", "sn_inf", "snPpart", "snererror", "swPid", "snnopen", "snallinfo", "snappname", "snapactab", "sn_inner", " sn_inf", "nsJinner", "ns_fo", "snap_tab", "snPid", "snapacinf", "snJerror", "snPstart", "sn_name", "sl_INFO", "snap_start", "sl_info", "sw_id"], "sn_tab": ["snPab", "sn__account", "sn_count", "snnapp", "nn_account", "sn_loc", "sn_app", "nn_app", "snPaccount", "sn__tab", "nn_count", "swPaccount", "nn_tab", "sw_info", "sw_account", "snncount", "pn_tab", "pn_space", "sn__info", "sw_ab", "sn_space", "snPinfo", "sw_loc", "swPab", "snntab", "sn_lab", "pn_info", "swPinfo", "sw_tab", "snPtab", "sn__ab", "sn_ab", "swPtab", "sn_account", "snnaccount", "pn_lab"], "i": ["oi", "l", "hi", "gu", "ui", "di", "it", "start", "n", "si", "zi", "m", "id", "info", "xi", "iw", "k", "x", "b", "z", "ami", "ini", "d", "pointer", "c", "ji", "p", "ix", "uri", "e", "yi", "mu", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "v", "name", "ti", "phi", "gi", "mi", "isin", "r", "abi", "qi", "ij", "pi", "bi", "ii", "u", "h", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu"], "snap_count": ["snap_check", "gap_size", "record_count", "snapfcount", " snap_weight", "spot_count", "sn_number", "snapfaddress", "capt_check", "sn_count", " snap_check", "snap_force", "gap_check", "snapfsize", "snap67index", "snap_depth", "recordfcount", "snapPloop", "snapPhandle", "spotxtotal", "snap_limit", "snap_number", "snap_index", "gap_force", "snap_address", "snapPcheck", "snapPlimit", "recordfindex", "snap_total", "snapNloop", "snapNcheck", "recordfsize", "capt_handle", "spot_time", "spot_total", "spotxtime", "snapFtotal", "record_size", "snapNhandle", "snap67address", "snapencast", "snapPcount", " snap_number", "snapFcount", "gap_count", "snapPweight", "snap_handle", " snap_size", "snapJcount", " snap_len", "snap_weight", "snap64check", "snap64size", "snapencount", " snap_depth", "spotxcount", " snap_cast", "snap67size", "snap64force", "snap_loop", "snapJcast", "snapFtime", "snap_size", "snap64count", "capt_count", "recordfaddress", "snapencheck", "snapxcount", "snap_time", "snap_cast", "snapNcount", "snapxtotal", "capt_loop", "snapxtime", "sn_cast", " snap_limit", "snapJcheck", "snap_len", "snap67count", "record_index", "record_address", "snapfindex"], "snaps": ["knats", "knapps", "snap", "slips", "snops", "snps", "synaps", "knaps", "spps", "clips", "synapses", "swabs", "knapes", "snats", "swapses", "snapes", "naps", "slap", "knapses", "nips", "snabs", "knops", " snops", "swap", "knabs", "swapes", "snapps", " snabs", "slapses", "nap", "snasts", " snips", "snapping", "sliffs", "snips", "sniffs", "swips", "swiffs", "slasts", " snapping", "spapps", "swops", "cliffs", "nps", "spaps", "spasts", "slapping", "clabs", "slabs", "slapps", "swats", " snats", "slops", "slapes", "synps", "synapes", "swps", "swaps", "knapping", "nasts", "snapses", "slps", "slaps", "napps", "napes", " snapps", "claps", "knips"], "snap_name": ["switch_source", "snapJsize", "pgfalias", "snapfcount", "snappcount", "gap_ni", "gap_key", "snap64key", "switch_size", "snapJanc", "snapJcount", "snappalias", "pgfstr", "snap_key", "snapJstr", "snap_source", "snappstr", "pg_name", "switch_anc", "snapfstr", "snappname", "snapfalias", "snap_anc", "snap_alias", "snap_ni", "switch_name", "snap___name", "snapJalias", "snap64id", "gap_name", "pg_alias", "gap_id", "snap_id", "pgfcount", "snapfname", "snap___source", "pg_count", "snap64name", "snapJname", "pg_str", "snapJsource", "pgfname", "snap___anc", "snap_str", "snap64ni", "snap___size", "snap_size"]}}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static int ehci_process_itd(EHCIState *ehci,\n\n                            EHCIitd *itd)\n\n{\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n    int ret;\n\n    uint32_t i, j, len, pid, dir, devaddr, endp;\n\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n\n\n    for(i = 0; i < 8; i++) {\n\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n\n\n            if (len > max * mult) {\n\n                len = max * mult;\n\n            }\n\n\n\n            if (len > BUFF_SIZE) {\n\n                return USB_RET_PROCERR;\n\n            }\n\n\n\n            qemu_sglist_init(&ehci->isgl, 2);\n\n            if (off + len > 4096) {\n\n                /* transfer crosses page border */\n\n                uint32_t len2 = off + len - 4096;\n\n                uint32_t len1 = len - len2;\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n\n            } else {\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n\n            }\n\n\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n\n\n            usb_packet_setup(&ehci->ipacket, pid, devaddr, endp);\n\n            usb_packet_map(&ehci->ipacket, &ehci->isgl);\n\n\n\n            ret = USB_RET_NODEV;\n\n            for (j = 0; j < NB_PORTS; j++) {\n\n                port = &ehci->ports[j];\n\n                dev = port->dev;\n\n\n\n                if (!(ehci->portsc[j] &(PORTSC_CONNECT))) {\n\n                    continue;\n\n                }\n\n\n\n                ret = usb_handle_packet(dev, &ehci->ipacket);\n\n\n\n                if (ret != USB_RET_NODEV) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            usb_packet_unmap(&ehci->ipacket);\n\n            qemu_sglist_destroy(&ehci->isgl);\n\n\n\n#if 0\n\n            /*  In isoch, there is no facility to indicate a NAK so let's\n\n             *  instead just complete a zero-byte transaction.  Setting\n\n             *  DBERR seems too draconian.\n\n             */\n\n\n\n            if (ret == USB_RET_NAK) {\n\n                if (ehci->isoch_pause > 0) {\n\n                    DPRINTF(\"ISOCH: received a NAK but paused so returning\\n\");\n\n                    ehci->isoch_pause--;\n\n                    return 0;\n\n                } else if (ehci->isoch_pause == -1) {\n\n                    DPRINTF(\"ISOCH: recv NAK & isoch pause inactive, setting\\n\");\n\n                    // Pause frindex for up to 50 msec waiting for data from\n\n                    // remote\n\n                    ehci->isoch_pause = 50;\n\n                    return 0;\n\n                } else {\n\n                    DPRINTF(\"ISOCH: isoch pause timeout! return 0\\n\");\n\n                    ret = 0;\n\n                }\n\n            } else {\n\n                DPRINTF(\"ISOCH: received ACK, clearing pause\\n\");\n\n                ehci->isoch_pause = -1;\n\n            }\n\n#else\n\n            if (ret == USB_RET_NAK) {\n\n                ret = 0;\n\n            }\n\n#endif\n\n\n\n            if (ret >= 0) {\n\n                if (!dir) {\n\n                    /* OUT */\n\n                    set_field(&itd->transact[i], len - ret, ITD_XACT_LENGTH);\n\n                } else {\n\n                    /* IN */\n\n                    set_field(&itd->transact[i], ret, ITD_XACT_LENGTH);\n\n                }\n\n\n\n                if (itd->transact[i] & ITD_XACT_IOC) {\n\n                    ehci_record_interrupt(ehci, USBSTS_INT);\n\n                }\n\n            }\n\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 15077, "substitutes": {"ehci": ["ehcu", "ahcin", "ihc", "ahdi", "evc", "ekCI", "ehdi", "ehc", "ekcu", "ecki", "ihcin", "ohco", "ecc", "ohdi", "ahli", "ehCI", "ahki", "ihci", "ecci", "evci", "ohcu", "ihdi", "ehli", "ahCI", "ecdi", "ihcu", "ahci", "evki", "ehcin", "hessci", "ehki", "ekci", "hesscu", "ahcu", "ihco", "ohcin", "ahc", "ehco", "ohc", "ohci", "hessli", "hessCI", "ahco", "ekli", "evdi"], "itd": [" ite", "iterdj", "ithdd", "mitds", "itsdn", "ithds", "idds", "ithl", "ITdd", "itdn", " itl", "itsd", "ittingds", "itds", "ITD", "editds", "iterd", "editl", "ctdn", "ctdj", "ittingd", "mitl", "itdj", "ide", "ite", "pitds", "ipl", "ipD", "ctd", "itl", " itds", "ipds", "ctds", "pitd", "pitD", "ITd", "itdat", "itsds", "ITl", "ctD", "idl", "ITdj", "itsdd", "ctl", "ITds", " itdat", "pitl", "mitd", "ITe", "itsD", "idD", "iddat", "ithd", "itD", "ittingdn", "itsl", "itdd", " itD", "ipd", "ittingD", "ITdat", "idd", "iterds", "mitD", "iterD", "editd"], "port": ["proc", "config", "pc", "Port", "pt", "iv", "test", "pp", "ind", "plugin", "select", "http", "op", "ort", "wp", "apter", "ip", "type", "ports", "dp", "cp", "host", "rest", "pos", "post", "tun", "gp"], "dev": ["plug", "device", "proc", "pkg", "cam", "dist", "priv", " device", "def", "Dev", "app", "conf", "gu", "conn", "w", "pub", "grad", "ad", "ver", "diff", " priv", "debug", "pro", "disk", "ev", "reg", "pad"], "ret": ["proc", "_", "rc", "val", "code", " resp", "lit", " reply", "conn", "mem", "mi", "Ret", "count", "result", " RET", " result", "eth", "nt", "re", "out", "all", "resp", "RET", "res", "no"], "i": ["ani", "qi", "it", "ui", "adi", "I", "t", "ni", "ai", "xi", "id", "iu", "ini", "gi", "l", "oi", "io", "iv", "ci", "ki", "di", "x", "si", "ie", "ii", "uri", "v", "o", "yi", "u", "ind", "p", "e", "fi", "info", "mi", "li", "cli", "b", "ix", "multi", "k", "phi", "n", "ti", "ip", "c", "is", "inner", "ji", "pi", "chi", "uli", "bi", "ri", "ori", "zi", "y", "in", "index"], "j": ["adj", "uni", "it", "en", "vision", "aj", "slice", "sync", "ni", "ai", "jp", "ii", "loc", "slave", "job", "ind", "li", "eni", "ji", "pi", "r", "pri", "ori", "rel", "pos", "ami", "delay", "index"], "len": ["en", "rev", "lin", "non", "fl", "Len", "l", "lan", "lon", "un", "val", "nn", "lc", "fun", "dl", "lang", "full", "lit", "fat", "loc", "ld", "valid", "limit", "fn", "lib", "vert", "size", "ll", "la", "fin", "lt", "li", "min", "length", "n", "lf", "count", "ann", "line", "ler", "f", "span", "url", "il", "lu", "ell", "nt", "sl", "le", "coll", "elt", "den", "all", "pos", "el", "bl", "ln", "lim"], "pid": ["path", "proc", "po", "ai", "ni", "pc", "ini", "id", "vid", "di", "pp", "pu", "ind", "mi", "pa", "ix", "mode", "ip", "pm", "pi", "cp", "pri", "pos", "ori", "delay", "pad", "pn", "uid"], "dir": ["path", "pkg", "part", "d", "dist", "fd", "level", "req", "di", "ref", "det", "Dir", "mod", "dest", "loc", "der", "grad", "orient", "dy", "ind", "doc", "direct", "direction", "desc", "mode", "dep", "diff", "md", "iter", "sl", "dn", "dr", "pos", "rel", "prefix", "order", "dim", "wd"], "devaddr": ["deviceptr", " devptr", "testaddress", "deviceaddress", "deviceaddr", " devAddress", "devaddress", "verptr", "testdr", "evaddress", "deviceAddress", "veraddress", "devAddress", "testaddr", "devdr", "verdr", "testptr", "evAddress", "veraddr", "evaddr", "evptr", " devdr", "devptr", " devaddress"], "endp": ["idpoint", "endedp", "endf", "idvp", "startf", "endpoint", "endedpoint", "endedf", "endpc", "idp", " endf", "startp", "startpc", "webp", "webpoint", "endvp", "webvp", " endvp", "startpoint", "webpc", " endpoint", " endpc", "idpc", "endedpc"], "pg": ["jj", "pse", "ff", "pkg", "ha", "ijk", "PG", "qa", "config", "pc", "cc", "mp", "bb", "ww", "pt", "g", "ig", "tg", "rg", "pool", "pp", "eg", "gh", "xp", "peg", "ager", "sq", "kk", "og", "ct", "ps", "gn", "pu", "conn", "mb", "ss", "col", "pub", "quad", "p", "gg", "pb", "pa", "pl", "k", "ag", "mg", "wp", "rog", "neg", "round", "pe", "ng", "gen", "ph", "ht", "cmd", "mag", "org", "cp", "db", "seq", "tag", "reg", "pad", "post", "pn", "gp"], "off": ["ord", "alt", "ff", "non", "on", "art", "id", "shift", "lon", "style", "oa", "pt", "def", "front", "low", "Off", "option", "offer", "raw", "OFF", "slave", "value", "output", "o", "open", "oc", "online", "own", "op", "opp", "mode", "ask", "rol", "anon", "length", "ip", "diff", "block", "end", "down", "offs", "type", "offset", "pull", "md", "ng", "now", "cmd", "out", "load", "half", "pos", "num", "addr", "no", "post", "over", "start"], "ptr1": [" ptrU", "padU", "len3", "pointerU", "pointer1", " ptr01", "ptrn", "pointer2", "pointer01", "pointern", "pad2", "pt100", "pointerone", "ptone", " ptr100", "ptrone", "pointer100", "ptr01", "pt1", "len2", "pad3", " ptrn", "ptrU", "ptr100", "ptr3", "pointer3", "pad1", " ptrone", "len1", "padn", "pt01"], "ptr2": [" ptr5", " ptrb", "plugTwo", "pointer182", "pointerTwo", "pointer2", "pt2", "pointer5", "reqtwo", " ptr182", "ptr52", "plug52", "req52", "ptrb", "req2", "sthb", "pointer52", "plugtwo", "ptr5", "reqTwo", " ptr4", "plug2", "ptr4", "pointerL", "ptr182", "pointertwo", "pointer4", "pt4", "sth5", "pointer62", " ptrL", "pointerb", "ptrL", "ptrtwo", "sth182", "pt62", "ptr62", "ptL", "sth2", "ptrTwo", " ptr62"], "max": ["depth", "wh", "part", "po", "dist", "on", "id", "def", "name", "range", "x", "post", "MAX", "total", "sum", "mod", "con", "opt", "patch", "limit", "conf", "strip", "w", "col", "pass", "size", "p", "ver", "k", "min", "Max", "length", "count", "n", "none", "parent", "ax", "c", "only", "cat", "end", "ph", "q", "scale", "comb", "out", "r", "last", "cache", "pos", "num", "order", "pad", "no", "cl", "height"], "mult": ["zip", "wh", "part", "dist", "batch", "mount", "util", "quant", "gap", "fun", "req", "multipl", "low", "pool", "mod", "sum", "master", "patch", "mot", "vert", "grad", "phase", "ul", "mut", "compl", "mun", "temp", "ver", "pl", "multi", "length", "mode", "count", "dom", "multiple", "parent", "pair", "diff", "per", "pull", "common", "man", "coll", "seq", "Mult", "prefix", "delay", "lat", "pad", "cur", "comb", "mu"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n", "idx": 4479, "substitutes": {"avctx": ["axcu", "avcn", "avca", "akcontext", "awctx", "AVcam", "axcontext", "afca", "avcam", "apcontext", "avectx", "afcv", "aflc", "awclient", "ajlc", "vrclient", "ajcv", "avcu", "AVctx", "AVcontext", "ajcp", "avecp", "vrcv", "akctx", "afcn", "afctx", "akcn", "axcam", "apctx", "abcontext", "avcv", "avcontext", "afcp", "afclient", "avcp", "ajcu", "avclient", "awcontext", "avecontext", "avlc", "afcontext", "ajctx", "afcam", "axctx", "ajcontext", "abcv", "apcn", "AVcu", "awcv", "akca", "apca", "vrcontext", "avelc", "afcu", "abcu", "abctx", "vrctx"], "afq": ["alfquery", "affz", "affdq", "awu", "alfq", " afqu", "awiq", "awl", "effqa", " afquery", "faQ", "afct", " afk", "awdq", " afqa", "avqa", "awQ", "effquest", " afl", "awquery", "afck", "awquest", "AFl", "effq", "ajq", "alfqa", "ajck", "afdq", "alfk", "affqt", "awq", "alfck", "fadq", "faq", "ampqu", "affqa", "faqt", " afct", "ampqa", "affq", "AFu", "afz", "awqt", "alfct", "alfquest", "affqu", "afqt", " afu", "effck", "AFq", "ampck", "awct", "afiq", "ampquest", "afk", "avquest", "avck", "afqa", "afl", "affQ", "afquery", "avq", "ampz", "awck", "afQ", "afquest", "afu", "awk", "afqu", "ajiq", "ampiq", " afz", "ampq", "ajquest", "AFk"]}}
{"project": "FFmpeg", "commit_id": "f43a16049ef07585789d311f314f236a314f91f7", "target": 0, "func": "int opt_cpuflags(const char *opt, const char *arg)\n\n{\n\n#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)\n\n#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)\n\n#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)\n\n#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)\n\n#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)\n\n#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)\n\n#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)\n\n#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)\n\n#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)\n\n#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)\n\n    static const AVOption cpuflags_opts[] = {\n\n        { \"flags\"   , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = \"flags\" },\n\n        { \"altivec\" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC  },    .unit = \"flags\" },\n\n        { \"mmx\"     , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX      },    .unit = \"flags\" },\n\n        { \"mmx2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2         },    .unit = \"flags\" },\n\n        { \"sse\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE          },    .unit = \"flags\" },\n\n        { \"sse2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2         },    .unit = \"flags\" },\n\n        { \"sse2slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW     },    .unit = \"flags\" },\n\n        { \"sse3\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3         },    .unit = \"flags\" },\n\n        { \"sse3slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW     },    .unit = \"flags\" },\n\n        { \"ssse3\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = \"flags\" },\n\n        { \"atom\"    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = \"flags\" },\n\n        { \"sse4.1\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = \"flags\" },\n\n        { \"sse4.2\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = \"flags\" },\n\n        { \"avx\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = \"flags\" },\n\n        { \"xop\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = \"flags\" },\n\n        { \"fma4\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = \"flags\" },\n\n        { \"3dnow\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = \"flags\" },\n\n        { \"3dnowext\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = \"flags\" },\n\n        { NULL },\n\n    };\n\n    static const AVClass class = {\n\n        .class_name = \"cpuflags\",\n\n        .item_name  = av_default_item_name,\n\n        .option     = cpuflags_opts,\n\n        .version    = LIBAVUTIL_VERSION_INT,\n\n    };\n\n    int flags = av_get_cpu_flags();\n\n    int ret;\n\n    const AVClass *pclass = &class;\n\n\n\n    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0)\n\n        return ret;\n\n\n\n    av_force_cpu_flags(flags);\n\n    return 0;\n\n}\n", "idx": 3054, "substitutes": {"opt": ["pl", "name", "ext", "Opt", "bit", "spec", "optim", "cat", "prop", "alt", "ord", "buf", "op", "pair", "options", "proc", "Option", "config", "attr", "oc", "text", "cmd", "var", "path", "val", "OP", "option"], "arg": ["argument", "call", "ig", "name", "bit", "cat", "Arg", "end", "op", "enc", "param", "mac", "proc", "args", "config", "len", "flag", "ar", "cmd", "lib", "var", "gen", "val", "load", "inc", "mem"], "cpuflags_opts": ["cpuflags_opcs", "cpuflags_optcs", "cpuflags_ops", "cpuflags_optionts", "cpuflags_optioncs", "cpuflags_opencs", "cpuflags_opc", "cpuflags_opents", "cpuflags_optc", "cpuflags_options", "cpuflags_openc", "cpuflags_optionc", "cpuflags_opens", "cpuflags_optts"]}}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static void apply_tns_filter(float *out, float *in, int order, int direction,\n\n                             float *tns_coefs, int ltp_used, int w, int filt,\n\n                             int start_i, int len)\n\n{\n\n    int i, j, inc, start = start_i;\n\n    float tmp[TNS_MAX_ORDER+1];\n\n    if (direction) {\n\n        inc = -1;\n\n        start = (start + len) - 1;\n\n    } else {\n\n        inc = 1;\n\n    }\n\n    if (!ltp_used) {    /* AR filter */\n\n        for (i = 0; i < len; i++, start += inc)\n\n            out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tns_coefs[j]*in[start - j*inc];\n\n    } else {            /* MA filter */\n\n        for (i = 0; i < len; i++, start += inc) {\n\n            tmp[0] = out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tmp[j]*tns_coefs[j];\n\n            for (j = order; j > 0; j--)\n\n                tmp[j] = tmp[j - 1];\n\n        }\n\n    }\n\n}\n", "idx": 24761, "substitutes": {"out": ["ref", "temp", "code", "call", "OUT", "obj", "bin", "p", "m", "b", "c", "app", "image", "filter", "flag", "other", "data", "doc", "again", "up", "Out", "outs", "pass", "sync", "op", "all", "line", "o", "outside", "outer", "input", "at", "process", "inner", "flat", "object", "output", "group", "append", "parent", "copy", "new", "vert", "client", "cache", "co", "conv", "update", "array", "dot", "part", "source", "n", "list", "v", "init", "pre", "result"], "in": ["exec", "ref", "inside", "IN", "din", "bin", "this", "p", "m", "b", "c", "image", "In", "data", "config", "up", "again", "ins", "pass", "id", "ani", "rec", "orig", "line", "con", "arr", "work", "min", "input", "ic", "at", "inner", "ini", "inf", "ii", "ai", "nin", "binary", "new", "inn", "isin", "win", "update", "before", "part", "source", "n", "index", "a", "init", "ind", "pre", "ac", "table"], "order": ["use", "code", "er", "page", "info", "en", "next", "Order", "error", "end", "id", "rec", "orig", "iter", "seed", "reverse", "max", "min", "err", "dir", "ord", "oder", "start", "inner", "ini", "ii", "si", "ai", "grade", "sort", "rank", "asc", "record", "level", "first", "length", "orders", "part", "count", "rule", "limit", "list", "index", "init", "ind", "ordered", "r", "pos"], "direction": ["orient", "dc", "dim", "dy", "d", "oriented", "weight", "phase", "diff", "rec", "range", "directory", "depth", "step", "reverse", "linear", "unit", "dir", "di", "ii", "forward", "mode", "wd", "vert", "sort", "period", "ward", "quad", "length", "dist", "round", "gradient", "directed", "dest", "ind", "degree", "normal", "irection", "direct", "dn", "desc"], "tns_coefs": ["tns_coefds", "tns_coecs", "tns_coafs", "tns_coffsets", "tns_Coefs", "tns_coefments", "tns_coeffsets", "tns_Coefments", "tns_coeffments", "tns_coreferences", "tns_coffors", "tns_corefsets", "tns_coeffds", "tns_coefsets", "tns_cofferences", "tns_coecments", "tns_coffds", "tns_coffnames", "tns_coecds", "tns_coefnames", "tns_coecsets", "tns_coefors", "tns_coafds", "tns_Coffments", "tns_Coffs", "tns_Coefsets", "tns_coefferences", "tns_corefnames", "tns_corefs", "tns_coffments", "tns_coafors", "tns_Coffds", "tns_coffs", "tns_coeferences", "tns_coeffnames", "tns_coafsets", "tns_Coefds", "tns_coeffs", "tns_coeffors", "tns_Coffsets"], "ltp_used": ["ltnp_enabled", "ltps_used", "ltps_active", "ltp_using", "ltp_needed", "ltp_active", "ltnp_use", "ltnp_used", "ltnp_needed", "ltp_enabled", "ltps_using", "ltp_use"], "w": ["ow", "kw", "z", "c", "d", "sw", "wave", "weight", "wh", "wx", "iw", "wl", "wd", "wind", "win", "wp", "h", "aw", "f", "wt", "nw", "W", "v", "r", "nc", "wa", "wait"], "filt": ["ofilt", "tflt", "ofitter", "oflet", "tfilt", "tfitter", "flt", "efilt", "fitter", "tflet", "eflet", "eflt", "oflt", "flet", "efitter"], "start_i": [" start_p", "start_start", "end_j", "start_j", "start_I", " start_in", "start_p", "end_I", "end_i", "end_start", "start_in", " start_j"], "len": ["L", "seq", "fin", "z", "ll", "base", "en", "non", "end", "lon", "lf", "line", "el", "li", "Len", "min", "lu", "la", "start", "loc", "dl", "lib", "lin", "ii", "size", "ln", "length", "lc", "win", "part", "lp", "count", "f", "limit", "n", "list", "net", "lim", "ind", "pos", "l", "val", "lock"], "i": ["my", "k", "z", "yi", "p", "b", "m", "c", "ie", "info", "ix", "x", "api", "mi", "phi", "qi", "it", "ri", "id", "io", "u", "e", "li", "gi", "ic", "o", "zi", "ji", "start", "xi", "uri", "ii", "ini", "si", "ai", "di", "ni", "bi", "cli", "ci", "fi", "eni", "I", "f", "y", "oi", "n", "ip", "index", "a", "mini", "iu", "ind", "v", "pi", "r", "ui", "l", "hi", "init"], "j": ["obj", "jit", "k", "z", "ie", "p", "m", "b", "uj", "adj", "c", "d", "pt", "x", "job", "jing", "je", "jo", "jp", "py", "next", "aj", "qi", "jj", "it", "u", "jam", "key", "e", "bj", "ji", "o", "li", "start", "jc", "ii", "journal", "ij", "jet", "oj", "length", "note", "json", "h", "f", "y", "jl", "js", "n", "pr", "t", "jon", "index", "q", "v", "J", "ind", "ui", "l", "dj", "jen", "ja", "g"], "inc": ["acc", "pp", "k", "z", "dc", "p", "page", "keep", "c", "adj", "d", "enc", "circ", "diff", "ins", "inst", "end", "cycle", "num", "rec", "fr", "step", "sp", "iter", "INC", "min", "zi", "start", "dir", "loc", "inner", "ii", "inf", "ini", "lin", "sign", "ci", "sort", "rc", "Inc", "inn", "req", "asc", "lc", "update", "win", "zip", "ir", "f", "count", "n", "index", "incre", "inter", "init", "ind", "r", "alpha", "nc", "pack"], "tmp": ["temp", "pp", "txt", "code", "obj", "done", "np", "slice", "nm", "page", "b", "p", "emp", "stuff", "app", "rup", "data", "test", "job", "frac", "img", "rb", "py", "area", "jp", "cb", "up", "front", "proc", "pad", "cmp", "ppo", "mp", "sp", "amp", "ff", "input", "dat", "start", "nb", "prep", "flat", "st", "output", "copy", "cp", "sb", "fb", "pm", "cache", "now", "sup", "zip", "wp", "part", "perm", "src", "fp", "v", "dest", "pre", "map", "result", "attr", "post", "table", "params"]}}
{"project": "qemu", "commit_id": "acfb23ad3dd8d0ab385a10e483776ba7dcf927ad", "target": 0, "func": "static void *iothread_run(void *opaque)\n\n{\n\n    IOThread *iothread = opaque;\n\n\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    iothread->thread_id = qemu_get_thread_id();\n\n    qemu_cond_signal(&iothread->init_done_cond);\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n\n\n    while (!iothread->stopping) {\n\n        aio_context_acquire(iothread->ctx);\n\n        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {\n\n            /* Progress was made, keep going */\n\n        }\n\n        aio_context_release(iothread->ctx);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 16410, "substitutes": {"opaque": ["appca", "operaco", "appacity", " opacity", "OPaco", " opca", "iopca", "opacity", "iopaque", "OPque", "operaque", "oplque", "oplaco", "appaque", "oplaque", "opoc", "oploc", "opca", "operque", "opaco", "OPaque", "operoc", "iopacity", "appaques", "OPoc", "opaques", "iopaques", "opque", " opaques"], "iothread": ["uuthread", "iothlock", "uothcheck", "iouthread", "uuthwait", "iithwrite", "iothreads", "iighthread", "iuthcheck", "iuthscan", "iohwrite", "atiothread", "iometscan", "iopterread", "iopterwrite", "uuthwrite", "icothreader", "icoshsync", "aophreader", "aoretload", "ioughreader", "ioretwrite", "xiuthread", "xiuthstart", "ioretsync", "atiothwrite", "iuthlock", "icoshwrite", "ithmode", "iopterreader", "iothreader", "ioshreader", "ioothwrite", "iuthwait", "ihedwrite", "iothrank", "iuthread", "iuthadd", "iithlock", "iometload", "icothwait", "iothsync", "xiothmode", "aoretsync", "iohreader", "xiothreader", "atiithlock", "iophadd", "icothloop", "ioenwrite", "iothcheck", "iohread", "icoshread", "aophwrite", "aothreader", "aophadd", "ioothreader", "icoothreads", "ioothreads", "aothadd", "xiothstart", "ithread", "iuthrank", "iopathwait", "ioughread", "ioughwrite", "icoothread", "ioshcheck", "ihedreads", "aoretwrite", "icothsync", "atiithrank", "iuthstart", "uothscan", "icoothreader", "iopterscan", "iophwrite", "iophreads", "iothmode", "iophread", "iothloop", "xiothread", "iuthsync", "xiuthmode", "ithreader", "aothsync", "icothwrite", "icoshwait", "atiothlock", "xiuthwrite", "icoshloop", "iophstart", "iothload", "iouthsync", "iuthmode", "iithrank", "uuthreader", "ioshwrite", "uothread", "iometwrite", "icoshreader", "iighthreader", "xiuthreader", "iophreader", "iothwait", "atiithread", "atiithwrite", "iouthloop", "uuthscan", "aothwrite", "aothload", "uothwrite", "iuthwrite", "iopathwrite", "iohmode", "icoothwrite", "ioenrank", "ioretloop", "ihedreader", "iuthload", "uothreader", "ioretreader", "iopathstart", "iothstart", "ioshwait", "iothwrite", "iothadd", "ithwrite", "iopathreader", "ioretread", "ioshread", "aothread", "ioshloop", "iometreader", "uuthcheck", "iophwait", "ioshsync", "ihedread", "xiothwrite", "iometsync", "ioenlock", "iithread", "iothscan", "ioughwait", "ioretload", "aophread", "iouthreader", "ioenread", "aoretread", "iometread", "iighthadd", "ioothread", "iopathread", "uothwait", "icothread", "iighthwrite", "icothreads", "atiothrank", "iuthreader", "iopathcheck"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int svq1_encode_plane(SVQ1Context *s, int plane,\n\n                             unsigned char *src_plane,\n\n                             unsigned char *ref_plane,\n\n                             unsigned char *decoded_plane,\n\n                             int width, int height, int src_stride, int stride)\n\n{\n\n    const AVFrame *f = s->avctx->coded_frame;\n\n    int x, y;\n\n    int i;\n\n    int block_width, block_height;\n\n    int level;\n\n    int threshold[6];\n\n    uint8_t *src     = s->scratchbuf + stride * 16;\n\n    const int lambda = (f->quality * f->quality) >>\n\n                       (2 * FF_LAMBDA_SHIFT);\n\n\n\n    /* figure out the acceptable level thresholds in advance */\n\n    threshold[5] = QUALITY_THRESHOLD;\n\n    for (level = 4; level >= 0; level--)\n\n        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;\n\n\n\n    block_width  = (width  + 15) / 16;\n\n    block_height = (height + 15) / 16;\n\n\n\n    if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n        s->m.avctx                         = s->avctx;\n\n        s->m.current_picture_ptr           = &s->m.current_picture;\n\n        s->m.last_picture_ptr              = &s->m.last_picture;\n\n        s->m.last_picture.f.data[0]        = ref_plane;\n\n        s->m.linesize                      =\n\n        s->m.last_picture.f.linesize[0]    =\n\n        s->m.new_picture.f.linesize[0]     =\n\n        s->m.current_picture.f.linesize[0] = stride;\n\n        s->m.width                         = width;\n\n        s->m.height                        = height;\n\n        s->m.mb_width                      = block_width;\n\n        s->m.mb_height                     = block_height;\n\n        s->m.mb_stride                     = s->m.mb_width + 1;\n\n        s->m.b8_stride                     = 2 * s->m.mb_width + 1;\n\n        s->m.f_code                        = 1;\n\n        s->m.pict_type                     = f->pict_type;\n\n        s->m.me_method                     = s->avctx->me_method;\n\n        s->m.me.scene_change_score         = 0;\n\n        s->m.flags                         = s->avctx->flags;\n\n        // s->m.out_format                    = FMT_H263;\n\n        // s->m.unrestricted_mv               = 1;\n\n        s->m.lambda                        = f->quality;\n\n        s->m.qscale                        = s->m.lambda * 139 +\n\n                                             FF_LAMBDA_SCALE * 64 >>\n\n                                             FF_LAMBDA_SHIFT + 7;\n\n        s->m.lambda2                       = s->m.lambda * s->m.lambda +\n\n                                             FF_LAMBDA_SCALE / 2 >>\n\n                                             FF_LAMBDA_SHIFT;\n\n\n\n        if (!s->motion_val8[plane]) {\n\n            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *\n\n                                                 block_height * 2 + 2) *\n\n                                                2 * sizeof(int16_t));\n\n            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *\n\n                                                 (block_height + 2) + 1) *\n\n                                                2 * sizeof(int16_t));\n\n        }\n\n\n\n        s->m.mb_type = s->mb_type;\n\n\n\n        // dummies, to avoid segfaults\n\n        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;\n\n        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mb_type = s->dummy;\n\n\n\n        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;\n\n        s->m.p_mv_table                      = s->motion_val16[plane] +\n\n                                               s->m.mb_stride + 1;\n\n        s->m.dsp                             = s->dsp; // move\n\n        ff_init_me(&s->m);\n\n\n\n        s->m.me.dia_size      = s->avctx->dia_size;\n\n        s->m.first_slice_line = 1;\n\n        for (y = 0; y < block_height; y++) {\n\n            s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly\n\n            s->m.mb_y                  = y;\n\n\n\n            for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                       width);\n\n                for (x = width; x < 16 * block_width; x++)\n\n                    src[i * stride + x] = src[i * stride + x - 1];\n\n            }\n\n            for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n                memcpy(&src[i * stride], &src[(i - 1) * stride],\n\n                       16 * block_width);\n\n\n\n            for (x = 0; x < block_width; x++) {\n\n                s->m.mb_x = x;\n\n                ff_init_block_index(&s->m);\n\n                ff_update_block_index(&s->m);\n\n\n\n                ff_estimate_p_frame_motion(&s->m, x, y);\n\n            }\n\n            s->m.first_slice_line = 0;\n\n        }\n\n\n\n        ff_fix_long_p_mvs(&s->m);\n\n        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,\n\n                        CANDIDATE_MB_TYPE_INTER, 0);\n\n    }\n\n\n\n    s->m.first_slice_line = 1;\n\n    for (y = 0; y < block_height; y++) {\n\n        for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                   width);\n\n            for (x = width; x < 16 * block_width; x++)\n\n                src[i * stride + x] = src[i * stride + x - 1];\n\n        }\n\n        for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);\n\n\n\n        s->m.mb_y = y;\n\n        for (x = 0; x < block_width; x++) {\n\n            uint8_t reorder_buffer[3][6][7 * 32];\n\n            int count[3][6];\n\n            int offset       = y * 16 * stride + x * 16;\n\n            uint8_t *decoded = decoded_plane + offset;\n\n            uint8_t *ref     = ref_plane + offset;\n\n            int score[4]     = { 0, 0, 0, 0 }, best;\n\n            uint8_t *temp    = s->scratchbuf;\n\n\n\n            if (s->pb.buf_end - s->pb.buf -\n\n                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n\n\n            s->m.mb_x = x;\n\n            ff_init_block_index(&s->m);\n\n            ff_update_block_index(&s->m);\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_I ||\n\n                (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                 CANDIDATE_MB_TYPE_INTRA)) {\n\n                for (i = 0; i < 6; i++)\n\n                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],\n\n                                  7 * 32);\n\n                if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n                    score[0] = vlc[1] * lambda;\n\n                }\n\n                score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,\n\n                                         5, 64, lambda, 1);\n\n                for (i = 0; i < 6; i++) {\n\n                    count[0][i] = put_bits_count(&s->reorder_pb[i]);\n\n                    flush_put_bits(&s->reorder_pb[i]);\n\n                }\n\n            } else\n\n                score[0] = INT_MAX;\n\n\n\n            best = 0;\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];\n\n                int mx, my, pred_x, pred_y, dxy;\n\n                int16_t *motion_ptr;\n\n\n\n                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);\n\n                if (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                    CANDIDATE_MB_TYPE_INTER) {\n\n                    for (i = 0; i < 6; i++)\n\n                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],\n\n                                      7 * 32);\n\n\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n\n\n                    s->m.pb = s->reorder_pb[5];\n\n                    mx      = motion_ptr[0];\n\n                    my      = motion_ptr[1];\n\n                    assert(mx     >= -32 && mx     <= 31);\n\n                    assert(my     >= -32 && my     <= 31);\n\n                    assert(pred_x >= -32 && pred_x <= 31);\n\n                    assert(pred_y >= -32 && pred_y <= 31);\n\n                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);\n\n                    ff_h263_encode_motion(&s->m, my - pred_y, 1);\n\n                    s->reorder_pb[5] = s->m.pb;\n\n                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);\n\n\n\n                    dxy = (mx & 1) + 2 * (my & 1);\n\n\n\n                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,\n\n                                                   ref + (mx >> 1) +\n\n                                                   stride * (my >> 1),\n\n                                                   stride, 16);\n\n\n\n                    score[1] += encode_block(s, src + 16 * x, temp + 16,\n\n                                             decoded, stride, 5, 64, lambda, 0);\n\n                    best      = score[1] <= score[0];\n\n\n\n                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];\n\n                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,\n\n                                              stride, 16);\n\n                    score[2] += vlc[1] * lambda;\n\n                    if (score[2] < score[best] && mx == 0 && my == 0) {\n\n                        best = 2;\n\n                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);\n\n                        for (i = 0; i < 6; i++)\n\n                            count[2][i] = 0;\n\n                        put_bits(&s->pb, vlc[1], vlc[0]);\n\n                    }\n\n                }\n\n\n\n                if (best == 1) {\n\n                    for (i = 0; i < 6; i++) {\n\n                        count[1][i] = put_bits_count(&s->reorder_pb[i]);\n\n                        flush_put_bits(&s->reorder_pb[i]);\n\n                    }\n\n                } else {\n\n                    motion_ptr[0]                      =\n\n                    motion_ptr[1]                      =\n\n                    motion_ptr[2]                      =\n\n                    motion_ptr[3]                      =\n\n                    motion_ptr[0 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[1 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[2 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;\n\n                }\n\n            }\n\n\n\n            s->rd_total += score[best];\n\n\n\n            for (i = 5; i >= 0; i--)\n\n                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],\n\n                                 count[best][i]);\n\n            if (best == 0)\n\n                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);\n\n        }\n\n        s->m.first_slice_line = 0;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4062, "substitutes": {"s": ["sg", "js", "this", "qs", "sa", "n", "sl", "client", "g", "ses", "ls", "sf", "us", "secondary", "sys", "sc", "u", "sum", "fs", "parts", "sup", "spec", "ts", "context", "sb", "sv", "sets", "p", "e", "lines", "conf", "as", "v", "su", "site", "S", "t", "session", "os", "ks", "its", "in", "sym", "ssl", "cs", "ss", "rs", "a", "r", "is", "ins", "m", "ds", "ps", "gs", "native", "ns", "h", "c", "es", "south", "o", "sim", "res", "si", "service", "ops", "strings", "d", "ans", "ms", "sync", "status", "l", "services", "w", "sq", "b", "states"], "plane": ["flow", "layer", "clip", "flat", "pe", "dim", "image", "axis", "weight", "fl", "code", "slice", "source", "lane", "planes", "ide", "core", "plan", "card", "scale", "plate", "qa", "ane", "path", "line", "mode", "limit", "port"], "src_plane": ["ref_layer", "srcwlayer", "srcwlane", "srcwplane", "srcwplanes", "src_layer", "ref_lane", "ref_planes", "src_lane", "src_planes"], "ref_plane": [" ref_sea", " ref_channel", "refacplane", "referenceacplane", "referenceacsea", "refinglane", "refingsea", "referenceaclane", "refingchannel", "reference_lane", "referenceacline", "refacsea", "reference_plane", "reference_line", "refacline", "ref_pose", "ref_channel", "ref_lane", "refaclane", " ref_pose", "ref_line", "reference_sea", "refalsea", "refalpose", "refalplane", "refalchannel", "refingpose", "refingline", "ref_sea", "refingplane"], "decoded_plane": ["decodedensource", "decodedegerscreen", "decode_plane", "decoded_source", "decodedenplane", "decode_source", "decodedegersource", "decoded_lane", "decoded_screen", "decodedegerlane", "decode_screen", "decodedenscreen", "decode_lane", "decodedenlane", "decodedegerplane"], "height": ["media", "resolution", "missing", "crop", "capacity", "build", "above", "def", "dim", "tight", "memory", "ht", "gain", "high", "window", "distance", "stroke", "ty", "bottom", "gravity", "huge", "hold", "direction", "style", "holes", " heights", "h", "thin", "hi", "layout", "deep", "rank", "east", "length", "size", "inches", "history", "rows", "density", "definition", "padding", "pull", "depth", "ashes", "location", "times", "hang", "volume", "shape", "rh", "gh", "Height"], "src_stride": ["src_bride", "src_frided", "src_strided", "src_drider", "src_frider", "src_brider", "src_drision", "src_strider", "src_strision", "src_dride", "src_drided", "src_brision", "src_frision", "src_brided", "src_fride"], "stride": ["strided", "shride", "tride", "trider", " strride", "strride", "drider", "strandi", "Strided", "strider", "drride", "drision", "trandi", "strision", "dride", "Stride", "Strision", "Strride", "shrision", "trided", "trision", "shrider", "drandi", " strided", " strision", "shrided", "drided", " strandi"], "f": ["flow", "fc", "fo", "tf", "q", "def", "fen", "fac", "form", "data", "fa", "image", "d", "n", "fl", "lf", "field", "page", "frame", "rf", "F", "j", "g", "api", "m", "file", "info", "fp", "df", "sf", "fr", "config", "fe", "bf", "feature", "feed", "h", "l", "c", "p", "fi", "w", "e", "aff", "self", "conf", "u", "fx", "of", "o", "v", "fb", "b", "t", "cf", "af", "full", "part", "fs", "inf"], "x": ["base", "image", "d", "n", "px", "xy", "pos", "dx", "m", "pixel", "X", "z", "index", "h", "c", "p", "l", "w", "e", "ax", "o", "ix", "view", "ex"], "y": ["row", "d", "n", "type", "cy", "j", "pos", "m", "dy", "z", "index", "h", "c", "p", "w", "e", "vy", "col", "size", "o", "Y", "ym"], "i": ["unit", "channel", "ii", "pi", "d", "I", "n", "di", "type", "id", "j", "pos", "m", "index", "z", "h", "l", "c", "p", "qi", "uri", "line", "ci", "io", "limit", "in"], "block_width": ["ref48width", "block67lon", " block_maximum", "ref_lon", "block_income", " block_income", "block\u00b7width", "block_length", "block67wen", "ref48wen", "ref48lon", "ref_width", "block_wen", "layout_size", "block_size", "layout48size", "layout_length", "block48wen", "layout48sw", "block48size", "layout48width", "layout48length", "block\u00b7maximum", "block_sw", "ref_wen", "block48sw", "block_maximum", "block67width", "block48length", "block\u00b7income", "block48lon", " block_size", "layout_width", "block48width", "block\u00b7size", "layout_sw", "block_lon"], "block_height": ["block_right", "block00height", "layout_thin", "block_resolution", " block_right", "block67height", "blockinglayout", "blockingresolution", "plugin67health", "block48right", "layout_right", "block_layout", "plugin_layout", "blockinghealth", "block_thin", "block67resolution", "plugin_health", "block67health", "block00right", "plugin_resolution", "block48height", "block67layout", "block_health", "plugin67layout", "plugin67resolution", "layout_height", "blockingheight", "plugin_height", "block00width", "layout_width", "block48width", "block00thin", "plugin67height"], "level": ["unit", "layer", "stage", "syn", "lock", "letter", "server", "q", "local", "channel", "key", "cl", "d", "n", "weight", "type", "lvl", "id", "parent", "wl", "list", "loop", "pass", "model", "code", "file", "coll", "style", "source", "index", "VEL", "vel", "step", "l", "lc", "length", "condition", "child", "col", "where", "all", "value", "other", "Level", "quality", "round", "scale", "way", "thread", "levels", "clean", "depth", "full", "line", "val", "mode", "lo", "limit", "inc", "pri", "day"], "threshold": ["THrift", "ethreshold", " thresh", "shcondition", "THreshold", "shresh", "ethrail", "THensor", "Thresh", " thrail", "rethrift", "rethresh", "thresh", " thensor", "thareshold", "thrift", "sthreshold", "Threshold", "sthumbnail", "ethensor", "shumbnail", "thrust", "Thrust", "sthresh", "thcondition", "ithreshold", "Thumbnail", "tharail", "shreshold", "thumbnail", "rethrail", "THresh", "ithcondition", "thensor", "tharesh", "ithresh", "sthrust", "rethrust", "ithumbnail", "rethreshold", "thrail", "THrail", "tharift", "Thcondition", "rethumbnail", "ethresh"], "src": ["sub", "ctx", "filename", "url", "image", "loc", "sl", "fn", "tmp", "rb", "secure", "dest", "cb", "slice", "source", "feat", "config", "ctr", "sc", "gb", "stream", "seq", "conv", "img", "input", "rc", "ssl"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int fourxm_probe(AVProbeData *p)\n\n{\n\n    if (p->buf_size < 12)\n\n        return 0;\n\n\n\n    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||\n\n        (AV_RL32(&p->buf[8]) != _4XMV_TAG))\n\n        return 0;\n\n\n\n    return AVPROBE_SCORE_MAX;\n\n}\n", "idx": 25091, "substitutes": {"p": ["pp", "pa", "np", "k", "i", "m", "b", "c", "d", "data", "api", "P", "jp", "ps", "bp", "op", "proc", "u", "e", "sp", "patch", "o", "pb", "s", "http", "per", "progress", "wp", "lp", "f", "n", "j", "tp", "t", "fp", "a", "v", "r", "pre", "l", "post", "pc", "ap", "g"]}}
{"project": "qemu", "commit_id": "161c4f20bfbd54f0b77426adccb68ee831678af0", "target": 1, "func": "static void vnc_disconnect_finish(VncState *vs)\n{\n    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);\n    buffer_free(&vs->input);\n    buffer_free(&vs->output);\n    qobject_decref(vs->info);\n#ifdef CONFIG_VNC_TLS\n    vnc_tls_client_cleanup(vs);\n#endif /* CONFIG_VNC_TLS */\n#ifdef CONFIG_VNC_SASL\n    vnc_sasl_client_cleanup(vs);\n#endif /* CONFIG_VNC_SASL */\n    audio_del(vs);\n    QTAILQ_REMOVE(&vs->vd->clients, vs, next);\n    if (QTAILQ_EMPTY(&vs->vd->clients)) {\n        dcl->idle = 1;\n    }\n    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);\n    vnc_remove_timer(vs->vd);\n    if (vs->vd->lock_key_sync)\n        qemu_remove_led_event_handler(vs->led);\n    qemu_free(vs);\n}", "idx": 22980, "substitutes": {"vs": ["sv", "VS", "es", "config", "vt", "xs", "css", "ds", "ils", "os", "cs", "vals", "Vs", "stats", "js", "sts", "ov", "ms", "ns", "iss", "vas", "rs", "ins", "v", "http", "grades", "pages", "ss", "obs", "nav", "iv", "ses", "cv", "nas", "services", "pg", "s", "state", "ports", "wp", "va", "changes", "views", "utils", "vc", "prev", "qs", "fs", "lines", "flags", "ves", "vi", "ver", "ps", "gs", "alls", "vid", "ums", "versions", "vers", "sk", "lv", "ops", "vg", "plugins", "ks", "plugin", "env", "ls", "vr", "verts", "ues", "vm", "bs", "vp"]}}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,\n\n                             int width, int height)\n\n{\n\n    int src_wrap, x, y;\n\n    int r, g, b;\n\n    uint8_t *lum, *cb, *cr;\n\n    const uint8_t *p;\n\n\n\n    lum = dst->data[0];\n\n    cb = dst->data[1];\n\n    cr = dst->data[2];\n\n\n\n    src_wrap = src->linesize[0] - width * BPP;\n\n    p = src->data[0];\n\n    for(y=0;y<height;y++) {\n\n        for(x=0;x<width;x++) {\n\n            RGB_IN(r, g, b, p);\n\n            lum[0] = RGB_TO_Y_CCIR(r, g, b);\n\n            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);\n\n            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);\n\n            cb++;\n\n            cr++;\n\n            lum++;\n\n        }\n\n        p += src_wrap;\n\n        lum += dst->linesize[0] - width;\n\n        cb += dst->linesize[1] - width;\n\n        cr += dst->linesize[2] - width;\n\n    }\n\n}\n", "idx": 15321, "substitutes": {"dst": [" dsts", "lost", "tsc", "sstd", "fsts", " dST", "stest", "adst", "adsts", "idgest", "dnd", " dnd", "tnd", "sst", "dbl", "Drc", "stsc", "dST", "lgest", "dsts", " dest", "lsts", "sttd", "tost", "dost", "lsc", "idst", "idest", "stst", "dgest", " dost", " dgest", "drc", "adsc", "Dst", "delst", "Dsts", "ltd", "ssts", "lnd", "lst", "dcast", "fput", "adrc", " dtd", " dstd", "tbl", "fst", "sost", "delsc", "Dsc", "idput", "lcast", "lbl", " dsc", " drc", "fest", "dtd", "tcast", " dput", "dest", "lest", "dstd", "tst", "dsc", "delbl", "delcast", "idST", "lST", "dput", "idsts"], "src": ["rss", "gz", "uc", "slice", "dist", "cv", "tmp", "rc", "config", "rs", "sup", "source", "sr", "dest", "loc", "grad", "img", "rb", "s", "sb", "inst", "stat", "gb", "spec", "rl", "url", "sn", "sc", "ssl", "rob", "sl", "sur", "sub", "sel", "ruby", "st", "support", "ctx"], "height": ["Height", "build", "d", "thin", "bottom", "grow", "level", "density", "shape", "row", "h", "gh", "crop", "rows", "kw", "w", "hang", "dy", "size", "z", "s", "direction", "length", "flow", "padding", "resolution", "wp", "inches", "pull", "margin", "ht", "wall", "center", "layout", "work", "window", "depth"], "src_wrap": ["src_break", "src_wrapper", " src_break", " src_work", " src_wrapper", "srclexwrap", "srclexwrapper", "src_scroll", "srclexwork", "rc_scroll", "rc_wrap", "rc_margin", "rc_wrapper", "src_margin", "src_work"], "x": ["m", "d", "t", "on", "id", "l", "i", "image", "h", "px", "v", "w", "yx", "dx", "dy", "u", "z", "ady", "e", "s", "rx", "ix", "n", "f", "ax", "c", "X", "ya", "xy", "wy", "pos", "el", "ph", "in", "index"], "y": ["ny", "d", "t", "id", "l", "i", "ey", "py", "h", "gy", "cy", "ym", "ye", "v", "o", "w", "dy", "z", "u", "yl", "e", "yr", "yo", "j", "n", "f", "oy", "c", "vy", "ay", "ry", "type", "Y", "ya", "xy", "yy", "wy", "ty", "sy"], "r": ["rr", "m", "ru", "R", "d", "hr", "rc", "tr", "l", "i", "rs", "a", "ra", "er", "h", "rg", "sr", "v", "br", "rh", "fr", "o", "w", "u", "e", "s", "rb", "rx", "n", "f", "rl", "c", " w", "ro", "ur", "re", "ri", "pr", "nr", "dr", "usr", "err"], "g": ["ge", "m", "d", "sg", "gr", "l", "G", "i", "gi", "ig", "h", "rg", "v", "gn", "w", "group", "z", "gm", "u", "e", "s", "gg", "k", "j", "n", "f", "gs", "cfg", "c", "gen", "bg", "q", "go"], "b": ["m", "d", "t", "bs", "l", "i", "fb", "a", "h", "nb", "v", "o", "bp", "w", "u", "e", "s", "rb", "boot", "be", "pb", "base", "wb", "j", "sb", "n", "f", "ab", "bh", "c", "eb", "bi", "db", "B", "lb"], "lum": ["slum", "blumb", "lumption", " lub", " luf", "plam", "ylam", " lup", "bluf", "llum", "Lumb", "llums", "lumb", "lup", "Lup", " lumb", "lul", "ulums", " lumption", "ulumption", "slums", "lums", "llup", "lub", "luf", "ylul", "blam", "slam", "llam", "ulum", "ylum", "jlums", " lam", " lums", "Luf", "plumb", "Lum", "ulub", "plums", "slumb", "jlumption", "Lums", " lul", "blum", "ylumb", "plum", "Lam", "lam", "jlub", "Lul", "jlum"], "cb": ["rib", "ff", "uc", "bc", "cv", "ob", "ca", "rc", "cc", "bb", "fb", "ctr", "bd", "ctrl", "ci", "lc", "ub", "cor", "cn", "cmp", "kk", "abc", "mb", "conf", "cd", "CB", "ba", "gg", "rb", "bm", "pb", "buf", "nc", "sb", "co", "bf", "gb", "ab", "c", "cu", "dc", "lab", "eb", "cf", "nv", "cp", "abb", "db", "xc", "lb", "cur", "rf", "core", "cpp"], "cr": ["rr", "ch", "bc", "ca", "cv", "rc", "cc", "pc", "tr", "ctr", "Cr", "kr", "pre", "lc", "ci", "sp", "cor", "sr", "ref", "cy", "ct", "v", "br", "rh", "cd", "CR", "rb", "rx", "pb", "wp", "rm", "c", "cat", "pe", "sc", "cf", "cp", "db", "pr", "nr", "ar", "dr", "cro", "cur", "ph", "core", "err"], "p": ["m", "po", "d", "t", "pc", "jp", "i", "l", "pt", "pre", "api", "sp", "py", "lp", "h", "pp", "fp", "v", "ps", "o", "np", "w", "bp", "u", "z", "e", "pb", "pa", "j", "n", "f", "c", "pm", "pin", "per", "par", "pe", "pi", "q", "cache", "pr", "ar", "pos", "P", "tp"]}}
{"project": "qemu", "commit_id": "84ebd3e8c7d4fe955b359b9aac84395907b0412e", "target": 1, "func": "static void wdt_diag288_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    DIAG288Class *diag288 = DIAG288_CLASS(klass);\n\n\n\n    dc->realize = wdt_diag288_realize;\n\n    dc->unrealize = wdt_diag288_unrealize;\n\n    dc->reset = wdt_diag288_reset;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->vmsd = &vmstate_diag288;\n\n    diag288->handle_timer = wdt_diag288_handle_timer;\n\n}", "idx": 19716, "substitutes": {"klass": ["klf", " kcl", "kazz", "sklass", "Kazz", "skazz", "cklasses", "skclass", "Klass", " kazz", "Klasses", "klasses", "kcl", "sklasses", "Kclass", "sklf", " klasses", "skcl", "kclass", "cklass", "ckcl", "Klf", " klf", " kclass", "ckclass"], "data": ["Data", "dd", "info", "buffer", "result", "loader", "i", "cb", "bc", "def", "after", "exec", "load", "array", "ui", "config", "parent", "da", "ata", "cache", "dat", "DATA", "ds", "input"], "dc": ["pc", "jc", "cc", "spec", "cfg", "db", "cdn", "deck", "cca", "vc", "rc", "gc", "cm", "cf", "enter", "bc", "dt", "fc", "mc", "di", "abc", "ctrl", "controller", "dp", "design", " DC", "d", "df", "std", "nc", "ac", "disc", "DC", "tc", "config", "sc", "ga", "dr", "lc", "c", "da", "uc", "doc", "cache", "ec", "cd", "dk", "conn", "ds", "director"], "diag288": ["Diag280", "adiag288", "Diig288", "diag128", "diagger142", "adiarg128", "diagger280", "adiag280", "diig280", "diac280", "diig142", "diac188", "adiarg280", "diang28", "adiag188", "diag28", "diig28", "diag188", "diarg188", "diac128", "diang142", "diag280", "diarg280", "diagger288", "Diag142", "diag142", "diarg128", "diig128", "diang280", "diang288", "adiag128", "Diig280", "diig188", "adiarg288", "diig288", "diac288", "Diag28", "Diig142", "diagger28", "Diag288", "adiarg188", "Diig28", "diarg288"]}}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_alternate(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefAlternate *tmp;\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAlternate(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefAlternate(tmp);\n\n}\n", "idx": 5121, "substitutes": {"data": ["writer", "base", "a", "parent", "done", "dat", "config", "ada", "format", "database", "ad", "m", "valid", "f", "media", "d", "DATA", "buffer", "iterator", "parser", "da", "Data", "empty", "self", "result", "p", "input", "temp", "array", "this", "reader", "xxx", "start", "txt", "video", "api", "text", "cache", "test"], "unused": ["Unusable", " Unchecked", "Unuse", " Unused", " Unuse", "unchecked", " unuse", "Unused", "unuse", "Unchecked", " Unusable", "unusable", " unusable", " unchecked"], "tmp": ["verb", "nv", "base", "st", "copy", "vm", "rb", "vt", "b", "kk", "uv", "buf", "f", "mp", "j", "obj", "tv", "cpp", "e", "t", "cu", "result", "p", "array", "temp", "output", "this", "vp", "ptr", "c", "var", "txt", "api", "video", "tp", "vv", "cv", "vc", "pb", "test", "r", "img", "tc"], "v": ["vim", "nv", "o", "vd", "vm", "s", "V", "vt", "b", "i", "m", "uv", "l", "f", "j", "ve", "d", "obj", "tv", "u", "vi", "vs", "e", "ev", "w", "t", "k", "n", "p", "temp", "h", "vp", "sv", "iv", "c", "g", "api", "lv", "vv", "cv", "test"], "err": ["dr", "fr", "er", "cr", "iter", "rr", "aster", "bug", "i", "der", "rh", "tx", "rage", "f", "ler", "order", "acer", "ev", "e", "error", "ar", "oe", "arr", "t", "n", "str", "self", "rev", "p", "temp", "req", "z", "erer", "doc", "ver", "var", "c", "ind", "resp", "Er", "ref", "test", "rs", "fi", "r", "Error"]}}
{"project": "qemu", "commit_id": "846424350b292f16b732b573273a5c1f195cd7a3", "target": 1, "func": "static bool scsi_target_emulate_inquiry(SCSITargetReq *r)\n\n{\n\n    assert(r->req.dev->lun != r->req.lun);\n\n    if (r->req.cmd.buf[1] & 0x2) {\n\n        /* Command support data - optional, not implemented */\n\n        return false;\n\n    }\n\n\n\n    if (r->req.cmd.buf[1] & 0x1) {\n\n        /* Vital product data */\n\n        uint8_t page_code = r->req.cmd.buf[2];\n\n        r->buf[r->len++] = page_code ; /* this page */\n\n        r->buf[r->len++] = 0x00;\n\n\n\n        switch (page_code) {\n\n        case 0x00: /* Supported page codes, mandatory */\n\n        {\n\n            int pages;\n\n            pages = r->len++;\n\n            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */\n\n            r->buf[pages] = r->len - pages - 1; /* number of pages */\n\n            break;\n\n        }\n\n        default:\n\n            return false;\n\n        }\n\n        /* done with EVPD */\n\n        assert(r->len < sizeof(r->buf));\n\n        r->len = MIN(r->req.cmd.xfer, r->len);\n\n        return true;\n\n    }\n\n\n\n    /* Standard INQUIRY data */\n\n    if (r->req.cmd.buf[2] != 0) {\n\n        return false;\n\n    }\n\n\n\n    /* PAGE CODE == 0 */\n\n    r->len = MIN(r->req.cmd.xfer, 36);\n\n    memset(r->buf, 0, r->len);\n\n    if (r->req.lun != 0) {\n\n        r->buf[0] = TYPE_NO_LUN;\n\n    } else {\n\n        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;\n\n        r->buf[2] = 5; /* Version */\n\n        r->buf[3] = 2 | 0x10; /* HiSup, response data format */\n\n        r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */\n\n        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */\n\n        memcpy(&r->buf[8], \"QEMU    \", 8);\n\n        memcpy(&r->buf[16], \"QEMU TARGET     \", 16);\n\n        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());\n\n    }\n\n    return true;\n\n}\n", "idx": 12789, "substitutes": {"r": ["rr", "m", "self", "ru", "R", "d", "hr", "t", "tr", "rc", "gr", "l", "i", "rs", "or", "kr", "range", "rar", "ra", "er", "g", "req", "h", "rg", "this", "sr", "str", "x", "br", "fr", "rh", "cr", "request", "o", "u", "mr", "rec", "p", "e", "ir", "rb", "s", "lr", "rx", "k", "b", "rw", "result", "f", "c", "arr", "ur", "re", "rt", "pr", "nr", "ar", "dr", "res", "usr", "cur", "run", "rf", "wr", "err"], "pages": ["codes", "types", "users", "cats", "planes", "blocks", "posts", "cycles", "packages", "qa", "workers", "ins", "docs", "fields", "sites", "classes", "bytes", "seconds", "words", "points", "devices", "total", "rows", "pid", " page", "files", "items", "limit", "Pages", "views", "groups", "breaks", "s", "packs", "images", "plugins", "members", "page", "books", "sections", "apps", "length", "lines", "count", "heads", "frames", "n", "features", "days", "c", "cells", "ages", "per", "objects", "links", "events", "ips", "steps", "num", "comments", "ks"]}}
{"project": "FFmpeg", "commit_id": "5a412a5c3cc216ae1d15e6b884bda7214b73a5b0", "target": 1, "func": "static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,\n\n                                   uint8_t **data, int *size)\n\n{\n\n    static const int extradata_nal_types_hevc[] = {\n\n        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,\n\n    };\n\n    static const int extradata_nal_types_h264[] = {\n\n        H264_NAL_SPS, H264_NAL_PPS,\n\n    };\n\n\n\n    ExtractExtradataContext *s = ctx->priv_data;\n\n\n\n    H2645Packet h2645_pkt = { 0 };\n\n    int extradata_size = 0;\n\n    const int *extradata_nal_types;\n\n    int nb_extradata_nal_types;\n\n    int i, has_sps = 0, has_vps = 0, ret = 0;\n\n\n\n    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n        extradata_nal_types    = extradata_nal_types_hevc;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);\n\n    } else {\n\n        extradata_nal_types    = extradata_nal_types_h264;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);\n\n    }\n\n\n\n    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,\n\n                                ctx, 0, 0, ctx->par_in->codec_id, 1);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n        H2645NAL *nal = &h2645_pkt.nals[i];\n\n        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {\n\n            extradata_size += nal->raw_size + 3;\n\n            if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n                if (nal->type == HEVC_NAL_SPS) has_sps = 1;\n\n                if (nal->type == HEVC_NAL_VPS) has_vps = 1;\n\n            } else {\n\n                if (nal->type == H264_NAL_SPS) has_sps = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (extradata_size &&\n\n        ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||\n\n         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {\n\n        AVBufferRef *filtered_buf;\n\n        uint8_t *extradata, *filtered_data;\n\n\n\n        if (s->remove) {\n\n            filtered_buf = av_buffer_alloc(pkt->size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!filtered_buf) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            filtered_data = filtered_buf->data;\n\n        }\n\n\n\n        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!extradata) {\n\n            av_buffer_unref(&filtered_buf);\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        *data = extradata;\n\n        *size = extradata_size;\n\n\n\n        for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n            H2645NAL *nal = &h2645_pkt.nals[i];\n\n            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n\n                             nal->type)) {\n\n                AV_WB24(extradata, 1); // startcode\n\n                memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n\n                extradata += 3 + nal->raw_size;\n\n            } else if (s->remove) {\n\n                AV_WB24(filtered_data, 1); // startcode\n\n                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n\n                filtered_data += 3 + nal->raw_size;\n\n            }\n\n        }\n\n\n\n        if (s->remove) {\n\n            av_buffer_unref(&pkt->buf);\n\n            pkt->buf  = filtered_buf;\n\n            pkt->data = filtered_buf->data;\n\n            pkt->size = filtered_data - filtered_buf->data;\n\n        }\n\n    }\n\n\n\nfail:\n\n    ff_h2645_packet_uninit(&h2645_pkt);\n\n    return ret;\n\n}\n", "idx": 25179, "substitutes": {"ctx": ["exec", "txt", "tk", "sc", "cm", "kw", "np", "cca", "p", " context", "anc", "c", "pkg", "context", "cv", "qa", "qt", "sq", "config", "conf", "jp", "cb", "ct", "bc", "concept", "sync", "kb", "cmp", "fc", "cmd", "cms", "grad", "vc", "wcs", "Context", "cc", "cp", "ci", "cf", "client", "rc", "sci", "conv", "req", "cas", "git", "lc", "ctrl", "ca", "qs", "tc", "cu", "conn", "fp", "q", "ck", "tx", "cs", "cam", "pc", "kt"], "pkt": ["het", "pct", "Pelt", " packet", "pkg", "cpacket", "pke", "psth", "helt", "Psth", " pelt", "hkg", "packet", " pet", " pct", "hacket", "Pkg", "Packet", "pelt", "hke", "Pke", "pet", " pke", "cpkt", "cpct", " pkg", " psth", "Pkt", "hkt", "Pct", "Pet", "cpsth"], "data": ["load", "Data", "body", "args", "slice", "bin", "p", "batch", "name", "d", "buffer", "media", "read", "config", "next", "address", "type", "reader", "id", "message", "input", "dat", "start", "sample", "accept", "binary", "parent", "response", "cache", "missing", "device", "zip", "ata", "window", "bytes", "value", "DATA", "content", "memory", "draw", "result", "connection"], "size": ["code", "body", "args", "slice", "ize", "c", "empty", "sized", "name", "storage", "send", "sum", "capacity", "address", "type", "version", "Size", "depth", "SIZE", "cap", "small", "offset", "mode", "sec", "scale", "shape", "channel", "length", "bytes", "n", "len"], "extradata_nal_types_hevc": ["extradata_nal_types_kell", "extradata_nal_types_sheVC", "extradata_nal_types_shevc", "extradata_nal_types_peVC", "extradata_nal_types_shexc", "extradata_nal_types_shec", "extradata_nal_types_pell", "extradata_nal_types_kec", "extradata_nal_types_keVC", "extradata_nal_types_pexc", "extradata_nal_types_hec", "extradata_nal_types_hxc", "extradata_nal_types_pec", "extradata_nal_types_hell", "extradata_nal_types_hVC", "extradata_nal_types_hexc", "extradata_nal_types_hll", "extradata_nal_types_hc", "extradata_nal_types_pevc", "extradata_nal_types_hvc", "extradata_nal_types_heVC", "extradata_nal_types_kevc"], "extradata_nal_types_h264": ["extradata_nal_types_v24", "extradata_nal_types_H24", "extradata_nal_types_phavi", "extradata_nal_types_havi", "extradata_nal_types_ph24", "extradata_nal_types_he128", "extradata_nal_types_H64", "extradata_nal_types_ph64", "extradata_nal_types_H264", "extradata_nal_types_H265", "extradata_nal_types_ph128", "extradata_nal_types_he264", "extradata_nal_types_he24", "extradata_nal_types_h64", "extradata_nal_types_v264", "extradata_nal_types_ph264", "extradata_nal_types_he64", "extradata_nal_types_v64", "extradata_nal_types_h24", "extradata_nal_types_v128", "extradata_nal_types_p24", "extradata_nal_types_ph265", "extradata_nal_types_h128", "extradata_nal_types_v265", "extradata_nal_types_Havi", "extradata_nal_types_p264", "extradata_nal_types_pavi", "extradata_nal_types_p64", "extradata_nal_types_h265"], "s": ["sc", "ses", "w", "ss", "p", "parser", "c", "ns", "d", "sq", "sac", "sg", "e", "gs", "session", "spec", "sec", "sa", "h", "f", "qs", "n", "a", "t", "csv", "ssl", "cs", "g"], "extradata_nal_types": ["extradata_nals_type", "extradata_nal_properties", "extradata_nals_types", "extradata_nal_styles", "extradata_nal_resources", "extradata_nal_times", "extradata_nals_properties", "extradata_nals_ypes", "extradata_nal_ypes", "extradata_nal_pes", "extradata_nal_type", "extradata_nals_names", "extradata_naled_type", "extradata_naled_times", "extradata_nals_styles", "extradata_naled_types", "extradata_naled_pes", "extradata_nal_names", "extradata_nals_resources"], "nb_extradata_nal_types": ["nb_extradata_naler_ids", "nb_extradata_naled_types", "nb_extradata_nal_type", "nb_extradata_nals_types", "nb_extradata_naler_resources", "nb_extradata_naler_type", "nb_extradata_naled_plugins", "nb_extradata_nal_resources", "nb_extradata_nals_type", "nb_extradata_naled_ids", "nb_extradata_naler_types", "nb_extradata_naled_type", "nb_extradata_nals_names", "nb_extradata_nal_names", "nb_extradata_nal_ids", "nb_extradata_nals_ids", "nb_extradata_nal_plugins"], "i": ["gu", "jit", "k", "ie", "p", "b", "m", "yi", "c", "d", "ix", "x", "adi", "ti", "mi", "type", "phi", "qi", "it", "ri", "id", "num", "ani", "io", "ki", "u", "e", "key", "li", "gi", "zi", "multi", "start", "xi", "uri", "ii", "di", "ini", "ai", "si", "bi", "result", "ret", "ik", "fi", "eni", "im", "I", "f", "count", "mini", "n", "j", "ip", "index", "a", "chi", "y", "oi", "iu", "v", "ind", "pi", "in", "ui", "hi", "len"], "nal": ["namal", "neal", "ynale", "nanals", "nanal", "ynals", "nonals", " nals", "nalis", "naal", "rnmal", "nonal", " neal", "ynal", "nonale", "rnalis", "nanale", " nale", "naale", "neale", "naneal", "ynAL", "pnal", "nale", " nAL", "nealis", "rnale", "nmal", "pnals", "naalis", "nemal", "rnal", "nAL", "pnale", "pnAL", "noneal", "nals"]}}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_fini_out (HWVoiceOut *hw)\n\n{\n\n    void *ret;\n\n    PAVoiceOut *pa = (PAVoiceOut *) hw;\n\n\n\n    audio_pt_lock (&pa->pt, AUDIO_FUNC);\n\n    pa->done = 1;\n\n    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);\n\n    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);\n\n\n\n    if (pa->s) {\n\n        pa_simple_free (pa->s);\n\n        pa->s = NULL;\n\n    }\n\n\n\n    audio_pt_fini (&pa->pt, AUDIO_FUNC);\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n}\n", "idx": 7004, "substitutes": {"hw": ["hp", "gp", "rw", "nw", "fw", "wx", "qq", "sw", "ow", "wm", "wa", "wk", "wb", "wy", "wo", "wd", "hm", "w", "we", "tw", "hh", "ctx", "zh", "hop", "voc", "work", "ou", "kw", "iw", "h", "vp", "wu", "ht", "ha", "pkg"], "ret": ["reg", "rt", "mem", "al", "alt", "pin", "pat", "value", "vt", "val", "data", "et", "art", "reply", " RET", "fin", " Ret", "att", "sil", "res", "match", "def", "len", "det", "RET", "func", "ben", "lib", "pass", "result", "seq", "lex", "Ret", "ft", "re", "fun", "Return", "ref", "rep", "aux", "fi", "rets"], "pa": ["opa", "gp", "bp", "na", "pan", "python", "arta", "pai", "pr", "a", "ka", "PA", "la", "ua", "va", "pre", "po", "pse", "pas", "oa", "cca", "pe", "lp", "ena", "ya", "appa", "lia", "pm", "ma", " Pa", "pi", "ga", "pc", "per", "pn", "SPA", "pha", "sea", "jp", "ba", "p", "ama", "qua", "Pa", "ca", "qa", "ampa", "fa", "ista", "ana", "bank", "ppa", "ta", "sa", "ja", "tta", "apa", " PA", "pb", "au", "audio"]}}
{"project": "qemu", "commit_id": "28b70c9dbdce0d517ade9c04c7d7ae05c8b76d2f", "target": 0, "func": "static int scsi_req_stream_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    switch (buf[0]) {\n\n    /* stream commands */\n\n    case ERASE_12:\n\n    case ERASE_16:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case WRITE_6:\n\n        cmd->len = 6;\n\n        cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case READ_16:\n\n    case READ_REVERSE_16:\n\n    case VERIFY_16:\n\n    case WRITE_16:\n\n        cmd->len = 16;\n\n        cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case REWIND:\n\n    case LOAD_UNLOAD:\n\n        cmd->len = 6;\n\n        cmd->xfer = 0;\n\n        break;\n\n    case SPACE_16:\n\n        cmd->xfer = buf[13] | (buf[12] << 8);\n\n        break;\n\n    case READ_POSITION:\n\n        cmd->xfer = buf[8] | (buf[7] << 8);\n\n        break;\n\n    case FORMAT_UNIT:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    /* generic commands */\n\n    default:\n\n        return scsi_req_length(cmd, dev, buf);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5676, "substitutes": {"cmd": ["cp", "plugin", "cmp", "cfg", "hw", "clean", "block", "md", "comm", "cdn", "device", "config", "Cmd", "nc", "cat", "module", "cm", "window", "mac", "client", "carry", "child", "call", "add", "cli", "ctr", "cc", "dom", "conf", "code", "ck", "auth", "func", "dc", "ctx", "cb", "input", "ctrl", "req", "mode", "node", "c", "head", "custom", "cf", "cod", "cookie", "vc", "host", "command", "grad", "conn", "pkg", "cd", "msg"], "dev": ["hw", "dm", "block", "v", "md", "nov", "rad", "prof", "mem", "Dev", "dd", "device", "nt", "di", "data", "info", "der", "debug", "valid", "de", "client", "d", "ve", "mod", "server", "conf", "ev", "def", "DEV", "dom", "priv", "wd", "w", "cam", "die", "driver", "pad", " device", "exec", "self", "serial", "root", "reader", "mode", "ver", "proc", "var", "off", "orig", "node", "gd", "engine", "app", "grad", "conn", "diff", "end"], "buf": ["band", "rb", "bg", "b", "data", "queue", "uc", "f", "tab", "buffer", "bag", "func", "bc", "ab", "nb", "array", "proc", "off", "pb", "img", "bh", "msg", "fam", "header", "cur", "config", "fb", "uf", "port", "ctx", "pad", "batch", "doc", "cap", "cf", "text", "bn", "vec", "block", "box", "bd", "exc", "rc", "cat", "loc", "grab", "wb", "db", "conv", "usb", "Buffer", "bound", "feat", "border", "begin", "fab", "gb", "prop", "fd", "bo", "cache", "aux", "app", "src", "buff", "v", "uber", "Buff", "uv", "mac", "bu", "bb", "cb", "result", "seq", "ptr", "alloc", "comb", "br", "utf", "cv", "ha"]}}
{"project": "qemu", "commit_id": "338c25b6929b5436a42aaa106c7e9136cf1ff4dc", "target": 1, "func": "static int htab_save_later_pass(QEMUFile *f, sPAPREnvironment *spapr,\n\n                                int64_t max_ns)\n\n{\n\n    bool final = max_ns < 0;\n\n    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;\n\n    int examined = 0, sent = 0;\n\n    int index = spapr->htab_save_index;\n\n    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n\n\n    assert(!spapr->htab_first_pass);\n\n\n\n    do {\n\n        int chunkstart, invalidstart;\n\n\n\n        /* Consume non-dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && !HPTE_DIRTY(HPTE(spapr->htab, index))) {\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        chunkstart = index;\n\n        /* Consume valid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        invalidstart = index;\n\n        /* Consume invalid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && !HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        if (index > chunkstart) {\n\n            int n_valid = invalidstart - chunkstart;\n\n            int n_invalid = index - invalidstart;\n\n\n\n            qemu_put_be32(f, chunkstart);\n\n            qemu_put_be16(f, n_valid);\n\n            qemu_put_be16(f, n_invalid);\n\n            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),\n\n                            HASH_PTE_SIZE_64 * n_valid);\n\n            sent += index - chunkstart;\n\n\n\n            if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (examined >= htabslots) {\n\n            break;\n\n        }\n\n\n\n        if (index >= htabslots) {\n\n            assert(index == htabslots);\n\n            index = 0;\n\n        }\n\n    } while ((examined < htabslots) && (!qemu_file_rate_limit(f) || final));\n\n\n\n    if (index >= htabslots) {\n\n        assert(index == htabslots);\n\n        index = 0;\n\n    }\n\n\n\n    spapr->htab_save_index = index;\n\n\n\n    return (examined >= htabslots) && (sent == 0) ? 1 : 0;\n\n}\n", "idx": 10180, "substitutes": {"f": ["l", "uf", "rf", "conf", "xf", "fo", "fen", "g", "ff", "af", "sf", "w", "m", "fr", "fd", "t", "b", "files", "fw", "d", "i", "c", "fb", "s", "p", "e", "fp", "exec", "feed", "cf", "df", "fm", "bf", "tf", "v", "r", "framework", "elf", "this", "fn", "form", "F", "file", "fs", "func", "fi", "fe", "fc"], "spapr": ["sphapri", "Spaperb", "scaprb", "spapener", "spakr", "yparpner", "chapr", "scapsra", "sppplr", "spaperr", "scapprn", "ypapner", "sparpner", "spavner", "sessionaprs", "sppprc", "spopril", "spaprb", "paprb", "spaperrb", "spakrb", "spafR", "spapar", "spaptrar", "slarprc", "chapar", "spacrar", "sparpra", "spappR", "slapri", "spashrn", "spaplr", "spapersr", "asphapri", "spappner", "spappri", "sppprs", "slapr", "spashrar", "scaprc", "spippr", "spakrn", "spAPrc", "scapprg", "sessionapru", "spapran", "spapsrc", "spajrar", "yparpra", "spaperR", "spajra", "papR", "spacrc", "Spapr", "spashra", "asphapru", "chaprar", "spappr", "sphapr", "spAPsr", "sessionppr", "spoprar", "spacar", "sparprar", "chopril", "pAPrb", "pAPr", "spaptri", "yparpr", "spppru", "spAPr", "Spaperc", "spapsrin", "spaprin", "pAPR", "spafra", "spaptr", "papsr", "sessionpprs", "spapsra", "spapsri", "spapprn", "scaprn", "ypapr", "sessionaplr", "spashr", "spacra", "scapprb", "papr", "aspapri", "sparpru", "sessionpplr", "spaptar", "aspapr", "slarpri", "spaper", "sparprg", "ypapra", "spafrc", "scaprg", "spaprc", "slaprc", "spapplr", "spappsr", "spaprs", "spacner", "spavr", "spavrc", "speprs", "speplr", "spepru", "ypaprar", "sessionppru", "spappru", "slarpr", "sparpri", "spajrn", "spampran", "spapru", "sphaprs", "scapsR", "spipprin", "spacril", "Spapran", "spapprs", "spapsran", "spapprc", "spappra", "aspapru", "spppr", "spippran", "scappr", "Spapsrin", "asphaprs", "scapprc", "spapner", "Spaper", "Spapsran", "spacr", "scapru", "Spapner", "chopr", "pAPsr", "yparprc", "sppprg", "scapsrc", "spapri", "choprar", "spapprg", "spajr", "spapril", "ypaprc", "spAPrn", "scapR", "chapril", "spapsr", "aspaprs", "asphapr", "spAPR", "sessionapr", "spapra", "spopr", "spaprar", "scapsr", "spopar", "ypaprn", "yparprar", "spapsR", "sparpr", "spaprn", "Spaprb", "sphapru", "spapR", "spAPra", "spepr", "scapra", "spakrc", "spapprb", "yparprn", "sparprc", "spaperc", "spamprin", "spavrb", "sparprn", "spaperb", "scappru", "spafr", "scapr", "spaprg", "Spaprin", "spaptril", "Spapsr", "spaptru", "Spapener", "spaptrs", "spampr", "Spaprc", "spAPrb", "chopar"], "max_ns": ["max_nas", "max_bs", "max__ls", " max_mins", "max_ls", "maxFbs", " max_nas", " max_ls", "maxFls", " max_rss", "max__rss", "max__ns", "maxFnas", "max_mins", "max__mins", " max_bs", "max_rss", "maxFns"], "chunkstart": [" chorkstop", " chorkstart", "Chunksstart", " ChunkStart", "chiffstyle", "chiffstarting", "Chunkstart", "shankend", "chanstop", " Chunkend", "chaultstarting", "chacketsize", " chunkinit", " chaultstyle", "chashstop", "chankst", "chacketinit", "chunkstop", " chunkstarting", "chanstart", "ChunksStart", "chacketStart", " Chanstart", "chacketstop", " ChanStart", "chaultstyle", " chunkpad", "chipstart", "hacketset", "Chunksize", "hunkend", "chaultstop", "chacksize", "Chunkend", "Chunksset", "shankst", "chacketpad", " chaultstart", "Chunksend", "chanStart", "chackst", "chackStart", " Chunkstop", "chunkpad", "chunksstop", "chunkend", "chackend", "hunkset", "chunksset", " Chunkstart", "chunkset", "chackset", "chunksstart", " chaultstop", "shankStart", "chunkstarting", "chorkpad", "chunkssize", " chorkpad", "chunksend", "chackstart", " Chanstop", "chashstart", "shunkst", "chankstart", " Chanend", "chipStart", "chorkstart", "chorkstyle", "chipend", "chorkstarting", "chorkstop", "chashpad", "chanend", "chankStart", "hunkStart", "chiffstop", " chunkstyle", "chankset", "chaultstart", "hunkstart", "chunksStart", "hacketend", " chaultstarting", "chunkst", " chunkstop", "chacketend", "chunkStart", "shunkstart", "chankend", "Chunkssize", "chacketstart", "chunksize", "chunkstyle", "hacketstart", "chorkinit", " chorkinit", "ChunkStart", "chiffstart", "shankstart", "chipset", "hacketStart", "shunkStart", "chunkinit", "Chunkset", "chacketset", "chashinit", "shunkend"], "invalidstart": ["inbrokenoffset", "Incompleteend", "Incompletestar", "invalidstop", "invalidindex", "nvalstop", "INcompatiblestarted", "Invalidend", "insecurestart", "nvalidend", "incompletestop", "inasticend", "invalidend", "nvalstart", "incompatibleindex", "nvalidstop", "inlegalStart", "infreshstart", "invalidoffset", "INvalidoffset", "INcompatibleoffset", "inlegalindex", "invalend", "inbrokenstarted", " inbrokenStart", " invalidset", "INvalidstart", " invalidindex", "incompatiblestarted", "nvalidstart", "infreshstarted", "incompleteset", "insecureset", "infreshindex", "invalidset", "INcompatibleindex", "inbadset", "insecureend", "insecurestar", "inasticoffset", "incompleteoffset", "Invalidstar", "incompleteend", "inbrokenset", "Incompleteset", "INvalidstarted", "INvalidindex", "incompletestart", "inbrokenstart", "nvalend", "Invalidstart", "inbadindex", "inasticstart", "inregularset", "INcompatiblestart", "nvaloffset", "inbrokenindex", "invaloffset", "inregularstar", "invalidStart", "inbadStart", "invalstart", "inasticstop", "inregularend", "Invalidset", "nvalidoffset", "incompatibleoffset", "incompletestar", "inlegalset", "inregularstart", "inbrokenStart", "inbadstart", "invalidstar", "infreshoffset", " inbrokenindex", " inbrokenset", "inlegalstart", "invalidstarted", " inbrokenstart", "Incompletestart", " invalidStart", "invalstop", "incompatiblestart"], "index": ["count", "updated", "connect", "section", "find", "point", "connected", "path", "x", "de", "block", "config", "thread", "set", "condition", "loc", "body", "found", "connection", "end", "document", "offset", "form", "type", "online", "localhost", "element", "dim", "si", "n", "date", "key", "view", "id", "open", "total", "i", "expression", "output", "request", "value", "unit", "slice", "ind", "input", "current", "example", "position", "list", "error", "ticket", "root", "insert", "fix", "opened", "context", "initial", "len", "temp", "second", "page", "num", "add", "action", "socket", "alpha", "version", "column", "sync", "old", "part", "available", "cache", "engine", "weight", "diff", "original", "active", "start", "axis", "ini", "Index", "update", "run", "ix", "search", "route", "inc", "name", "address", "option", "pos", "length", "match", "pattern"], "examined": ["exAMine", "exambining", "xambined", "exAMinated", "examritten", "examine", "exummented", "xamided", "exambinated", "exasmritten", "examinated", " exummented", "exAMining", " exambined", " examinated", " examine", "ExAMined", " exambritten", "exAMored", "xambine", " exambinated", "exAMmented", "exAMined", "examinining", "exambored", "exameinated", "exambmented", "examining", "ExAMored", " exumined", "examinined", "exambined", "Examined", "exasmmented", "Examine", "Examining", "examinored", "xamine", "examored", "exameine", " exammented", " exumine", " examritten", "xaminated", "exameided", "exAMritten", " exuminated", "exameined", "examinine", "exambided", "xamined", "exAMided", "exasminated", " exambmented", "exumine", "xambided", "exambine", "xambinated", "ExAMine", "exasmined", "exuminated", "ExAMining", "examided", "exammented", "Examored", "exambritten", "exumined"]}}
{"project": "qemu", "commit_id": "0c9390d978cbf61e8f16c9f580fa96b305c43568", "target": 1, "func": "static void nbd_client_closed(NBDClient *client)\n\n{\n\n    nb_fds--;\n\n    if (nb_fds == 0 && !persistent && state == RUNNING) {\n\n        state = TERMINATE;\n\n    }\n\n    nbd_update_server_watch();\n\n    nbd_client_put(client);\n\n}\n", "idx": 26745, "substitutes": {"client": ["head", "remote", "call", "cod", "Client", "public", "close", "server", "c", "name", "manager", "api", "config", "request", "address", "prefix", "port", "id", "self", "plugin", "cell", "con", "cmd", "resource", "command", "session", "cli", "worker", "handler", "parent", "agent", "cache", "proxy", "service", "child", "conn", "host", "core", "container", "connection", "pc"], "nb_fds": ["nb_fdcs", "nb_Fns", "nb_fDS", "nb_Fds", "nb2Fdds", "nb_fks", "nb_cdds", "nb_fdds", "nb_rfDS", "nb_cDS", "nb_fdns", "nb_cns", "nb_Fcs", "nb2Fns", "nb_fcs", "nb_rfcs", "nb_fddds", "nb_ccs", "nb_cks", "nb_rfks", "nb2fds", "nb2fcs", "nb2fdds", "nb_cds", "nb2fns", "nb2Fcs", "nb_Fdds", "nb_fns", "nb2Fds", "nb_rfds"]}}
{"project": "qemu", "commit_id": "302d9d6fd8cb34e393cc9bb101a1748bd53899d3", "target": 1, "func": "void vnc_sasl_client_cleanup(VncState *vs)\n\n{\n\n    if (vs->sasl.conn) {\n\n        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;\n\n        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;\n\n        vs->sasl.encoded = NULL;\n\n        g_free(vs->sasl.username);\n\n        free(vs->sasl.mechlist);\n\n        vs->sasl.username = vs->sasl.mechlist = NULL;\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n    }\n\n}\n", "idx": 19633, "substitutes": {"vs": ["ns", "ves", "ms", "values", "ums", "vas", "ts", "s", "bs", "stats", "rs", "words", "sv", "otes", "services", "ports", "vp", "ils", "vals", "cf", "forces", "ys", "ss", "ls", "as", "ii", "ops", "utils", "fs", "vi", "xs", "cons", "vers", "sk", "cs", "css", "VS", "als", "ins", "Vs", "obs", "args", "iss", "qs", "ov", "ses", "verts", "v", "alls", "ps", "js", "ets", "orts", "versions", "sts", "vt", "ks", "events", "gs", "va", "ues", "its", "iv", "es", "os", "state", "flags", "env", "eps", "ds", "oss"]}}
{"project": "qemu", "commit_id": "a87f39543a9259f671c5413723311180ee2ad2a8", "target": 0, "func": "static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)\n\n{\n\n    if (memory_region_is_ram(mr)) {\n\n        return !(is_write && mr->readonly);\n\n    }\n\n    if (memory_region_is_romd(mr)) {\n\n        return !is_write;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 11674, "substitutes": {"mr": ["rh", "rf", "adr", "mk", "mn", "tr", "hr", "m", "fr", "rr", "kr", "mm", "gr", "wk", "MR", "attr", "usr", "ir", "rb", "rs", "lr", "er", "dr", "mid", "rt", "mir", "fm", "rc", "mi", "r", "pr", "nr", "shr", "ur", "yr", "tm", "vr", "rg", "mt", "Mr", "sr", "br", "eu", "mc", "rl", "rm"], "is_write": [" is_written", "is_flow", "any_line", "any_writing", " is_read", "is_read", "any_write", " is_left", "isPubleft", "isPubread", " is_flow", "is_writing", "is_written", "is_left", "is_line", "any_read", "isPubwrite"]}}
{"project": "FFmpeg", "commit_id": "e3123856c79c36507772ada1bcda6cfe36a1e297", "target": 1, "func": "static int wsvqa_read_header(AVFormatContext *s,\n\n                             AVFormatParameters *ap)\n\n{\n\n    WsVqaDemuxContext *wsvqa = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char *header;\n\n    unsigned char scratch[VQA_PREAMBLE_SIZE];\n\n    unsigned int chunk_tag;\n\n    unsigned int chunk_size;\n\n\n\n    /* initialize the video decoder stream */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n    wsvqa->video_stream_index = st->index;\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_WS_VQA;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n\n\n    /* skip to the start of the VQA header */\n\n    avio_seek(pb, 20, SEEK_SET);\n\n\n\n    /* the VQA header needs to go to the decoder */\n\n    st->codec->extradata_size = VQA_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    header = (unsigned char *)st->codec->extradata;\n\n    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=\n\n        VQA_HEADER_SIZE) {\n\n        av_free(st->codec->extradata);\n\n        return AVERROR(EIO);\n\n    }\n\n    st->codec->width = AV_RL16(&header[6]);\n\n    st->codec->height = AV_RL16(&header[8]);\n\n\n\n    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */\n\n    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        if (AV_RL16(&header[0]) == 1)\n\n            st->codec->codec_id = CODEC_ID_WESTWOOD_SND1;\n\n        else\n\n            st->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;\n\n        st->codec->codec_tag = 0;  /* no tag */\n\n        st->codec->sample_rate = AV_RL16(&header[24]);\n\n        if (!st->codec->sample_rate)\n\n            st->codec->sample_rate = 22050;\n\n        st->codec->channels = header[26];\n\n        if (!st->codec->channels)\n\n            st->codec->channels = 1;\n\n        st->codec->bits_per_coded_sample = 16;\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample / 4;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n\n\n        wsvqa->audio_stream_index = st->index;\n\n        wsvqa->audio_samplerate = st->codec->sample_rate;\n\n        wsvqa->audio_channels = st->codec->channels;\n\n        wsvqa->audio_frame_counter = 0;\n\n    }\n\n\n\n    /* there are 0 or more chunks before the FINF chunk; iterate until\n\n     * FINF has been skipped and the file will be ready to be demuxed */\n\n    do {\n\n        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {\n\n            av_free(st->codec->extradata);\n\n            return AVERROR(EIO);\n\n        }\n\n        chunk_tag = AV_RB32(&scratch[0]);\n\n        chunk_size = AV_RB32(&scratch[4]);\n\n\n\n        /* catch any unknown header tags, for curiousity */\n\n        switch (chunk_tag) {\n\n        case CINF_TAG:\n\n        case CINH_TAG:\n\n        case CIND_TAG:\n\n        case PINF_TAG:\n\n        case PINH_TAG:\n\n        case PIND_TAG:\n\n        case FINF_TAG:\n\n        case CMDS_TAG:\n\n            break;\n\n\n\n        default:\n\n            av_log (s, AV_LOG_ERROR, \" note: unknown chunk seen (%c%c%c%c)\\n\",\n\n                scratch[0], scratch[1],\n\n                scratch[2], scratch[3]);\n\n            break;\n\n        }\n\n\n\n        avio_skip(pb, chunk_size);\n\n    } while (chunk_tag != FINF_TAG);\n\n\n\n    return 0;\n\n}\n", "idx": 19892, "substitutes": {"s": ["ns", "ans", "spec", "ts", "sg", "bs", "t", "rs", "aws", "f", "sv", "services", "service", "sb", "g", "sl", "ss", "src", "ls", "sec", "sim", "fs", "xs", "is", "cs", "su", "ins", "sn", "w", "bis", "qs", "sc", "ssl", "sr", "fts", "ses", "vs", "c", "si", "p", "S", "sts", "sci", "ks", "gs", "sys", "its", "es", "os", "us", "sets", "se", "sq", "sa", "ds", "sf"], "ap": ["pc", "wp", "au", "al", "sp", "pl", "ar", "ams", "ast", "am", "cp", "np", "pac", "att", "aps", "pp", "AP", "ac", "pi", "pa", "capt", "mp", "cap", "api", "pro", "tp", "arp", "attr", "amp"], "wsvqa": ["wssvcca", "wssvqa", "wordsvcca", "Wssvasa", "wsvqi", "Wsvqa", "wsVqi", "Wssvq", "wsvq", "wsvraga", "wsvasa", "wsvrq", "wsVcca", "Wssvaga", "wslvqa", "wsvcqi", "wsvcaga", "Wssvqa", "wssvq", "wssvaga", "wordsvqi", "wslvq", "Wsvasa", "wslvaga", "wordsvcqa", "wsvccca", "wordsvccca", "wordsvqa", "Wsvaga", "wslvasa", "wordsvaga", "Wsvq", "wsvrasa", "wssvasa", "wsVaga", "wsvaga", "wsVqa", "wssvqi", "wordsvcaga", "wsvcqa", "wsvrqa", "wsvcca", "wordsvcqi"], "pb": ["pc", "wp", "ab", "eb", "db", "bs", "aph", "fp", "platform", "vp", "pit", "pl", "bm", "ib", "sb", "pm", "bp", "cpp", "cb", "bc", "hub", "cp", "lp", "wb", "src", "fc", "xb", "lb", "PB", "dp", "prop", "pg", "gb", "rob", "summary", "bf", "bps", "queue", "pa", "bh", "fb", "buf", "rb", "afi", "p", "mp", "ppa", "orb", "param", "tp", "prot", "ub", "pt", "amp", "typ"], "st": ["set", "ist", "stat", "dd", "nt", "str", "ss", "ut", "ST", "store", "d", "sh", "irst", "stack", " est", "sts", "mt", "end", "pt", "sa", "est", "tt", "ts", "nd", "stim", "rest", "dest", "ste", "td", "ld", "stand", "art", "stop", "tta", "sc", "bl", "sth", "stress", "cr", "stage", "play", "St", "et", "ft", "fr", "sv", "ct", "ess", "fe", "sb", "src", "th", "sd", "sta", "l", "std", "back", "sn", "ad", "start", "sr", " St", "post", "ust", "put", "inst", "ace", "t", "sp", "ost", "sw", "sl", "ast", "lt", "cl", "cur", "kt", "storage", "se"], "header": ["offset", "user", "comment", "result", "num", "padding", "Header", "layer", "protection", "feature", "h", "carry", "input", "column", "bin", "content", "metadata", "name", "handle", "bridge", "document", "description", "summary", "title", "parent", "table", "tail", "iter", "port", "ver", "status", "code", "hash", "border", "block", "type", "match", "player", "byte", "filename", "date", "head", "page", "host", "digit", "yer", "position", "detail", "filter", "er", "frame", "version", "request", "data", "buffer", "option", "pixel", "channel", "headers", "index", "tag", "her", "cover", "event", "response", "dr", "driver", "error", "body", "message", "server", "section", "gender"], "scratch": ["encores", "ncores", " scores", "ncratch", "scores", "encratch"], "chunk_tag": ["chunk_length", "chunk_count", "chack2count", "chack_mode", "chack_tag", "chunk2length", "chack2tag", "chunk2mode", "chack_length", "chunk2tag", "chunk_mode", "chunk2count", "chack2length", "chack_count", "chack2mode"], "chunk_size": ["chunk_count", "chunks_SIZE", "chunk2weight", "chunk2size", "chunk_weight", "chunks_count", "chunk_SIZE", "chunk2count", "chunk2SIZE", "chunks_weight", "chunks_size"]}}
{"project": "qemu", "commit_id": "2ebafc854d109ff09b66fb4dd62c2c53fc29754a", "target": 1, "func": "static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,\n\n                                 uint64_t end_offset, void **p_feature_table,\n\n                                 Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowExtension ext;\n\n    uint64_t offset;\n\n    int ret;\n\n\n\n#ifdef DEBUG_EXT\n\n    printf(\"qcow2_read_extensions: start=%ld end=%ld\\n\", start_offset, end_offset);\n\n#endif\n\n    offset = start_offset;\n\n    while (offset < end_offset) {\n\n\n\n#ifdef DEBUG_EXT\n\n        /* Sanity check */\n\n        if (offset > s->cluster_size)\n\n            printf(\"qcow2_read_extension: suspicious offset %lu\\n\", offset);\n\n\n\n        printf(\"attempting to read extended header in offset %lu\\n\", offset);\n\n#endif\n\n\n\n        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"qcow2_read_extension: ERROR: \"\n\n                             \"pread fail from offset %\" PRIu64, offset);\n\n            return 1;\n\n        }\n\n        be32_to_cpus(&ext.magic);\n\n        be32_to_cpus(&ext.len);\n\n        offset += sizeof(ext);\n\n#ifdef DEBUG_EXT\n\n        printf(\"ext.magic = 0x%x\\n\", ext.magic);\n\n#endif\n\n        if (ext.len > end_offset - offset) {\n\n            error_setg(errp, \"Header extension too large\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        switch (ext.magic) {\n\n        case QCOW2_EXT_MAGIC_END:\n\n            return 0;\n\n\n\n        case QCOW2_EXT_MAGIC_BACKING_FORMAT:\n\n            if (ext.len >= sizeof(bs->backing_format)) {\n\n                error_setg(errp, \"ERROR: ext_backing_format: len=%\" PRIu32\n\n                           \" too large (>=%zu)\", ext.len,\n\n                           sizeof(bs->backing_format));\n\n                return 2;\n\n            }\n\n            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"ERROR: ext_backing_format: \"\n\n                                 \"Could not read format name\");\n\n                return 3;\n\n            }\n\n            bs->backing_format[ext.len] = '\\0';\n\n#ifdef DEBUG_EXT\n\n            printf(\"Qcow2: Got format extension %s\\n\", bs->backing_format);\n\n#endif\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_FEATURE_TABLE:\n\n            if (p_feature_table != NULL) {\n\n                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));\n\n                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: ext_feature_table: \"\n\n                                     \"Could not read table\");\n\n                    return ret;\n\n                }\n\n\n\n                *p_feature_table = feature_table;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            /* unknown magic - save it in case we need to rewrite the header */\n\n            {\n\n                Qcow2UnknownHeaderExtension *uext;\n\n\n\n                uext = g_malloc0(sizeof(*uext)  + ext.len);\n\n                uext->magic = ext.magic;\n\n                uext->len = ext.len;\n\n                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);\n\n\n\n                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: unknown extension: \"\n\n                                     \"Could not read data\");\n\n                    return ret;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        offset += ((ext.len + 7) & ~7);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13097, "substitutes": {"bs": ["bt", "ses", "blocks", "bis", "bc", "sync", "BS", "ins", "fs", "iss", "bb", "lbs", "rs", "fb", "bn", "utils", "cs", "qs", "bytes", "cms", "its", "js", "abc", "ros", "boxes", "ras", "ps", "ss", "obj", "obs", "vals", "plugins", "pb", "bm", "b", "sb", "base", "bing", "gs", "gb", "bits", "bh", "ab", "ns", "bps", "cb", "outs", "bes", "bas", "org", "blog", "ds", "bi", "db", "sa", "ls", "css", "lb", "bos", "ubs", "las", "bl", "vs", "abi", "aws"], "start_offset": ["begin_offset", "begin_size", "start67slot", "start00offset", "begin_align", " start_size", "start_position", "start___start", "start__size", "begin___offset", "start_align", "end_slot", "start67offset", "start_start", "start__slot", "begin_start", "start67position", "begin___start", "start_index", "start_area", "end_size", " start_area", "end_position", "start67size", "start00area", " start_index", "start__offset", "start_slot", "start00index", "start_size", "start00size", "start___align", "begin___size", "start___size", "start___offset", "start__position", "begin___align"], "end_offset": ["end_addr", "end_Offset", "stop_format", "start_off", "end_end", "start_start", "stop00Offset", "end00Offset", "end_area", "stop_Offset", "start_area", "end_size", "end_off", "end_format", "start_end", "end00offset", "end00format", "start_addr", "start_size", "stop00format", "end_start", "stop_offset", "stop00offset"], "p_feature_table": ["p_features_details", "p_featureingtable", "p_feature_list", "p_featurelogdetails", "p_featurelogtable", "p_features_file", "p_featurelogfile", "P_\n", "p_features_table", "p_str", "p_featureloglist", "p_featureinglist", "p_features_list", "P_str", "p_feature_details", "p_\n", "p_feature_file", "p_featureingfile", "p_featureingdetails"], "errp": ["nerP", " errr", "ierp", "erfp", "acert", "erpatch", "errjp", "Erpoint", "erpre", "errorp", "errorjp", "erjp", "errr", " erp", "dert", "errpatch", "iterpc", " errt", "iterb", "derp", "errfp", " erpre", "ierr", "errorP", "errP", " errP", "erp", " erfp", "nerp", "errpre", "Err", "derpc", "erP", "errpoint", "ierP", "errt", "errorpc", "errorb", "errpc", "acerp", "nerb", "iterp", "nerpc", "derP", "iterP", "Erp", "Erpatch", "erpoint", "errb", "Erpre", " errjp", "acerP", "ErP", "acerpc", "Erfp", "ierpoint", " errpc", " erpatch", "errorr", "err"], "s": ["sys", "ses", "t", "fs", "rs", "cs", "qs", "S", "settings", "os", "si", "js", "sq", "storage", "ss", "ps", "p", "e", "sb", "b", "sf", "stat", "gs", "spec", "state", "c", "ns", "xs", "is", "stats", "ssl", "sv", "sl", "states", "ops", "ds", "sa", "ls", "ts"], "ext": ["word", " EXT", "dist", "art", " extent", "def", "x", "xt", "str", "fp", "append", " extend", "br", "vert", "obj", "ind", "temp", "tf", "cb", "text", "aux", "ec", "off", "ef", " extended", "ft", "inter", "lc", "req", "txt", "full", "fr", " aux", "lib", "img", "cut", " parent", "exec", "Ext", " ep", "zip", "ch", "config", "external", "extra", "test", "section", "fx", "xp", "init", "eff", "app", "z", " aug", "e", "sec", "info", "desc", "eng", "ix", "f", " intr", "diff", "cf", "EXT", " fmt", "ord", " cont", " orig", " instr", "code", "ex", "later", "abc", "feat", "p", "fit", "next", "org", "seq"], "offset": ["bound", "align", "offer", "fp", "loc", "append", "limit", "af", "base", "count", "skip", "padding", "timeout", "end", "afi", "fee", "off", "num", "order", "index", "Offset", "part", "slice", "id", "api", "optional", "operation", "error", "ut", "entry", "abi", "length", "origin", "url", "layout", "et", "addr", "alias", "ptr", "alt", "format", "slot", "absolute", "section", "null", "ref", "adjust", "output", "o", "stop", "online", "f", "address", "scroll", "reset", "type", "nt", "hop", "pos", "prefix", "ui", "adjusted", "location", "position", "set", "size", "pointer", "next", "outer", "attribute", "initial", "seq", "len", "exclusive", "start"], "ret": ["alt", "ft", "en", "rev", "part", "let", "reply", "art", "id", "val", "back", "def", "rets", "gt", "fun", "str", "ref", "det", "arg", "lit", "key", "job", "conn", "obj", "mt", "mem", "info", "desc", "success", "match", "af", "Ret", "count", "bf", "f", "result", " RET", "att", "url", "cat", "arr", " Ret", "nt", "re", "out", "rt", "et", "pat", "RET", "res", "num", "reg", "usr", "flag", "no", "len", "opt", "bit"]}}
{"project": "FFmpeg", "commit_id": "a150bad4062a29fc11b32117bc1ade38115cd95b", "target": 0, "func": "AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,\n\n                                                            int perms)\n\n{\n\n    AVFilterBufferRef *picref =\n\n        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,\n\n                                                  frame->width, frame->height,\n\n                                                  frame->format);\n\n    if (!picref)\n\n        return NULL;\n\n    avfilter_copy_frame_props(picref, frame);\n\n    return picref;\n\n}\n", "idx": 7659, "substitutes": {"frame": ["game", "base", "scene", "flow", "fr", "row", "build", "feed", "position", "el", "component", "flower", "config", "layout", "update", "object", "iframe", "data", "slice", "style", "module", "za", "image", "Frame", "draw", "window", "fb", "live", "rame", "state", "series", "fe", "property", "buffer", "e", "point", "part", "file", "fram", "motion", "view", "plane", "feat", "framework", "filename", "coll", "parse", "scale", "ground", "line", "filter", "node", "setup", "video", "model", "frames", "figure", "cf", "element", "panel", "feature"], "perms": ["PERmissions", " perm", "percs", "arm", " permm", "arms", "Perm", "arps", " perps", "perm", " percs", "Perps", "perfs", "Percs", "Perms", "perps", " perfs", "arfs", "Permm", " permissions", "permm", "Permissions", "PERcs", "PERms", "PERmm", "Perfs", "permissions"], "picref": ["fcref", "picurl", "icRef", "lcRef", "fcurl", " picbf", "icreference", "picval", " picurl", "lcreference", "picreference", "fcval", "icurl", "pcref", "fcbf", "picRef", "camref", "fcdef", "fcreference", "cambf", "pcreference", "icref", "icdef", "picdef", " picval", " picdef", "lcval", " picreference", "camRef", " picRef", "fcRef", "picbf", "pcRef", "pcdef", "lcref", "camreference"]}}
{"project": "qemu", "commit_id": "299f80130401153af1a6ddb3cc011781bcd47600", "target": 0, "func": "static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,\n\n                            TCGArg dst, TCGArg src)\n\n{\n\n    if (temps_are_copies(dst, src)) {\n\n        tcg_op_remove(s, op);\n\n        return;\n\n    }\n\n\n\n    if (temp_is_const(src)) {\n\n        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);\n\n        return;\n\n    }\n\n\n\n    TCGOpcode new_op = op_to_mov(op->opc);\n\n    tcg_target_ulong mask;\n\n\n\n    op->opc = new_op;\n\n\n\n    reset_temp(dst);\n\n    mask = temps[src].mask;\n\n    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {\n\n        /* High bits of the destination are now garbage.  */\n\n        mask |= ~0xffffffffull;\n\n    }\n\n    temps[dst].mask = mask;\n\n\n\n    assert(!temp_is_const(src));\n\n\n\n    if (s->temps[src].type == s->temps[dst].type) {\n\n        temps[dst].next_copy = temps[src].next_copy;\n\n        temps[dst].prev_copy = src;\n\n        temps[temps[dst].next_copy].prev_copy = dst;\n\n        temps[src].next_copy = dst;\n\n        temps[dst].is_const = false;\n\n    }\n\n\n\n    args[0] = dst;\n\n    args[1] = src;\n\n}\n", "idx": 19492, "substitutes": {"s": ["ns", "spec", "m", "sup", "session", "sg", "bs", "t", "stats", "obj", "f", "sv", "services", "settings", "service", "r", "n", "sb", "g", "i", "ops", "scope", "self", "xs", "is", "o", "cs", "d", "space", "new", "site", "e", "ssl", "ses", "client", "sync", "c", "ps", "js", "sym", "p", "S", "b", "http", "sys", "h", "os", "us", "sq", "source", "u"], "op": ["ic", "oc", "wp", "init", "info", "obj", "omp", "jp", "sp", "ob", "hop", "option", "num", "or", "block", "type", "Op", "app", "oper", "node", "ops", "top", "root", "opus", "vert", "opp", "o", "ip", "oop", "prop", "exec", "arg", "pp", "up", "prev", "cop", "open", "cmd", "p", "mp", "cmp", "pop", "http", "OP", "opt", "inst", "operation", "operator"], "args": ["ans", "ns", "ms", "oc", "extra", "stats", "data", "ras", "err", "obj", "fields", "options", "sp", "vals", "objects", "ams", "g", "ips", "loc", "points", "ops", "acl", "pos", "ass", "arg", "arr", "changes", "cs", "parse", "ins", "ig", "config", "ics", "vs", "ars", "uments", "ps", "atts", "js", "p", "ids", "gs", "ants", " arguments", "parts", "flags", "pres", "py", "states", "dict", "Args", "params", "ds"], "dst": ["prest", "idrc", "dstr", "indsp", "dset", "ndsth", "jST", "DST", "indst", "didist", "dsc", "Dsts", "datst", "idsc", "pst", "Dput", " dsrc", "dost", "datsts", " dstr", " dST", "ydsc", "frc", "idput", "nsth", "ldsc", "ndsts", "indrest", "ldst", "dsp", " dsp", "addist", "ddist", "idsts", "Dsp", "ndST", "fsrc", " dsth", "dsrc", "frest", "fsc", "Dsrc", "jst", " drest", "bdost", "indsth", "idbl", " dsc", "disc", "bdsc", "addest", "datput", "jost", "idST", "idset", "adsc", "psp", "drc", "idsp", "bdst", "datsth", "Dst", "adset", "hst", "nsp", "hdest", "adsrc", "idst", "ndst", "prc", "yddest", "datST", "ldost", "diost", " ddest", " drc", "dput", "jsrc", "iddest", "ydst", " dsts", "fdest", "nrest", "fST", "jstr", "adost", " dbl", "jsc", "fst", "fbl", "hST", " ddist", " dost", "ddest", "ldrest", "adst", "adST", "nst", "ydset", "fsp", "drest", "hsp", "dist", "dST", "fsts", "dsts", "dbl", "bdstr", "dsth"], "src": ["spec", "obj", "usb", "supp", "ptr", "sec", "reverse", "rec", "secure", "new", "config", "impl", "lib", "resource", "hh", "source", "cv", "target", "sup", "rs", "rest", "dest", "rc", "hr", "stream", "bc", "scope", "share", "rob", "usc", "sub", "sc", "tmp", "uc", "gz", "null", "iv", "desc", " dest", "fp", "core", "RC", "r", "sb", "cpp", "cb", "loc", "sel", "filename", "host", "sn", "sr", "ruby", "sync", "rl", "obl", "sys", "inst", "origin", "sq", "params", "dep", "sl", "ctx", "fc", "low", "conv", "site", "img", "st", "front", "ssl", "bh", "ource", "req", "cur", "rb", "support", "url", "cmp", "http", "proc", "server", "usr", "attr", "dist"], "mask": ["scale", "offset", "skip", "shape", "code", "shadow", "info", "conf", "bit", "image", "comment", "reg", "mark", "result", "pack", "flag", "block", "clean", "match", "Mask", "max", "type", "index", "ck", "hack", "tag", "count", "copy", "sk", "ask", "ack", "cover", "cost", "iq", "stack", "size", "length", "key", "delay", "asm", "fix", "map", "bits", "qa", "patch", "pad", "sum", "lock", "arch", "filter", "depth", "black", "field", "ban", "feature", "cache", "cap", "weight", "sign", "cast", "allow", "flags", "scan", "target", "bug"]}}
{"project": "qemu", "commit_id": "9bbd4843c052a0a467c7a3363046b0c95c0e5fc0", "target": 1, "func": "gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,\n\n             uint32_t up_shift, CPUTriCoreState *env)\n\n{\n\n    TCGv temp = tcg_temp_new();\n\n    TCGv temp2 = tcg_temp_new();\n\n    TCGv temp3 = tcg_temp_new();\n\n    TCGv_i64 t1 = tcg_temp_new_i64();\n\n    TCGv_i64 t2 = tcg_temp_new_i64();\n\n    TCGv_i64 t3 = tcg_temp_new_i64();\n\n    TCGv_i64 t4 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_ext_i32_i64(t2, arg2);\n\n    tcg_gen_ext_i32_i64(t3, arg3);\n\n\n\n    tcg_gen_mul_i64(t2, t2, t3);\n\n\n\n    tcg_gen_ext_i32_i64(t1, arg1);\n\n    /* if we shift part of the fraction out, we need to round up */\n\n    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);\n\n    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);\n\n    tcg_gen_sari_i64(t2, t2, up_shift - n);\n\n    tcg_gen_add_i64(t2, t2, t4);\n\n\n\n    tcg_gen_sub_i64(t3, t1, t2);\n\n    tcg_gen_trunc_i64_i32(temp3, t3);\n\n    /* calc v bit */\n\n    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);\n\n    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);\n\n    tcg_gen_or_i64(t1, t1, t2);\n\n    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);\n\n    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);\n\n    /* We produce an overflow on the host if the mul before was\n\n       (0x80000000 * 0x80000000) << 1). If this is the\n\n       case, we negate the ovf. */\n\n    if (n == 1) {\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);\n\n        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);\n\n        tcg_gen_and_tl(temp, temp, temp2);\n\n        tcg_gen_shli_tl(temp, temp, 31);\n\n        /* negate v bit, if special condition */\n\n        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);\n\n    }\n\n    /* Calc SV bit */\n\n    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);\n\n    /* Calc AV/SAV bits */\n\n    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);\n\n    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);\n\n    /* calc SAV */\n\n    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);\n\n    /* write back result */\n\n    tcg_gen_mov_tl(ret, temp3);\n\n\n\n    tcg_temp_free(temp);\n\n    tcg_temp_free(temp2);\n\n    tcg_temp_free(temp3);\n\n    tcg_temp_free_i64(t1);\n\n    tcg_temp_free_i64(t2);\n\n    tcg_temp_free_i64(t3);\n\n    tcg_temp_free_i64(t4);\n\n}\n", "idx": 22058, "substitutes": {"ret": ["reg", "expr", "wrapper", "result", "ctr", "tr", "prep", "Ret", "buffer", "fit", "model", "path", "final", "cache", "prefix", "active", "ctx", "aux", "seq", "test", "iter", "req", "alt", "template", "output"], "TCGv": ["TCGlvv", "OCGuvv", "TCGuvr", "TCGvr", "TCGlf", "PGGMv", "TCCGv", "PCgvs", "TCgver", "PCGvan", "TCGenerv", "PCgv", "TCGarf", "TCgvv", "TCGsV", "PGGMV", "TCGMvm", "TCMGvv", "TCGroupvc", "TCGenevv", "TCGWf", "TCMGver", "TCGarv", "TCGroupev", "TCGlvan", "TCGef", "PCGvs", "TCGenevan", "TCGuvv", "PGGMvr", "TCGvan", "TCGMv", "TCGatep", "OCGuver", "PCGcv", "TCGenef", "PCgvc", "TCGenervc", "OCGuvr", "TCGsv", "TCGsvr", "TCGatev", "TCGeneralvc", "TCGvm", "TCgvan", "PGGMvm", "OCGv", "PCGp", "TCgev", "TCGarev", "PCgvan", "TCGvv", "PGGvm", "TCGarvs", "TCgf", "PCgev", "TCGsvm", "TCGWev", "PCgcv", "OCGvr", "TCgvr", "PGGV", "TCGWvc", "TCgvs", "TCGV", "TCGev", "TCGenerf", "TCGeneralf", "PGGvr", "OCGver", "TCGver", "TCGeneralvs", "PCGvc", "TCCGvm", "TCGep", "TCGWvs", "PCgvv", "PGGv", "TCCGV", "TCGcv", "TCGlv", "TCGMV", "PCGf", "TCMGv", "TCGuver", "OCGvv", "OCGuv", "TCgvc", "TCGatecv", "PCgp", "TCGenev", "TCGf", "PCGvv", "TCgp", "TCgcv", "PCGv", "TCGWv", "TCMGvr", "TCGeneralv", "TCGecv", "PCgf", "TCGroupv", "TCGuv", "PCGev", "TCGp", "TCGvc", "TCGvs", "TCGenervs", "TCCGvr", "TCGatef", "TCGMvr", "TCGroupf", "TCgv"], "uint32_t": ["uint32_n", "uint8_f", "uint32_int", "uint8_t", "uint16_n", "uint16_T", "uint8_T", "uint32_f", "uint32_T", "uint32_p", "uint16_p", "uint16_t", "uint8_int"]}}
{"project": "qemu", "commit_id": "b36d24b6c3708413f1174e34bd86b4bf5116012f", "target": 1, "func": "static void host_cpuid(uint32_t function, uint32_t count,\n\n                       uint32_t *eax, uint32_t *ebx,\n\n                       uint32_t *ecx, uint32_t *edx)\n\n{\n\n#if defined(CONFIG_KVM)\n\n    uint32_t vec[4];\n\n\n\n#ifdef __x86_64__\n\n    asm volatile(\"cpuid\"\n\n                 : \"=a\"(vec[0]), \"=b\"(vec[1]),\n\n                   \"=c\"(vec[2]), \"=d\"(vec[3])\n\n                 : \"0\"(function), \"c\"(count) : \"cc\");\n\n#else\n\n    asm volatile(\"pusha \\n\\t\"\n\n                 \"cpuid \\n\\t\"\n\n                 \"mov %%eax, 0(%1) \\n\\t\"\n\n                 \"mov %%ebx, 4(%1) \\n\\t\"\n\n                 \"mov %%ecx, 8(%1) \\n\\t\"\n\n                 \"mov %%edx, 12(%1) \\n\\t\"\n\n                 \"popa\"\n\n                 : : \"a\"(function), \"c\"(count), \"S\"(vec)\n\n                 : \"memory\", \"cc\");\n\n#endif\n\n\n\n    if (eax)\n\n\t*eax = vec[0];\n\n    if (ebx)\n\n\t*ebx = vec[1];\n\n    if (ecx)\n\n\t*ecx = vec[2];\n\n    if (edx)\n\n\t*edx = vec[3];\n\n#endif\n\n}\n", "idx": 21034, "substitutes": {"function": ["package", "name", "functional", "class", "object", "unc", "file", "func", "feature", "handler", "f", "section", "size", "program", "version", "cycle", "unit", "number", "code", "operation", "word", "filename", "module", "document", "family", "value", "python", "library", "math", "call", "Function", "length", "expression", "parent", "array", "fn", "resource", "variable", "command", "format", "fun", "letter"], "count": ["col", "name", "start", "config", "loop", "coll", "val", "time", "file", "fold", "process", "f", "use", "Count", "size", "cache", "score", "cycle", "id", "number", "code", "depth", "context", "c", "index", "num", "counter", "seq", "error", "call", "length", "child", "len", "test", "base", "array", "repeat", "max", "type"], "eax": ["ebex", " eaz", "fau", "Eau", "Eex", "eix", "eap", "ieix", " ease", "fax", "eas", " eex", "Eae", "fae", "peax", "eeaz", "Ead", " eix", "fas", "eae", " eap", "peas", "eau", " ead", "eex", "eaz", "ebap", "ease", "ieax", "ieaz", "ead", "peau", "iease", "eease", "peae", "eeix", "eeax", "ebax", "Eap", "Eax", "ebad", "Eas"], "ebx": ["eedX", "ecc", "efX", "ebX", "eby", "ibz", "ecid", "ebp", "efax", "evx", "egid", "efx", "ecX", "ibp", "ebid", "evz", "ecp", "ibb", "eedax", "evy", "ecz", "ibX", "egp", "ebz", "iby", "ibid", "efc", "ecb", "egx", "ecy", "eedc", "ebc", "evb", "egX", "ibx", "ebax", "eedx", "ecax", "ebb"], "ecx": ["ecc", "ebX", "eby", "exe", "eqX", "exX", "exxx", "emy", "eff", "ef", "ex", "efx", "eqe", "ecX", "ep", "ecp", "eqxx", "efb", "egp", "ebxx", "egc", "emx", "efy", "efc", "egx", "eqx", "ebe", "ecb", "ecy", "ece", "ecf", "ebc", "egf", "emc", "ecxx", "ebb", "exx", "efp", "ec", "emb"], "edx": ["pedx", "gedc", "gedz", "sdp", "pedz", "gedx", "pedc", "sdz", "pedp", "aedy", "aedx", "aidz", "odx", "endedax", "nedx", "gedp", "nedax", "odc", "aidex", "nedc", " edex", "edex", "sdx", "aedex", "sdc", "nedex", "aidy", "edy", "aedz", "aidx", "edax", " edz", "odex", "edc", "endedc", "odax", "edz", "endedx", "endedex", " edy", "edp"], "vec": ["bc", "uint", "sv", "expr", "val", "xy", "cube", "digit", "buffer", "vre", "sequence", "data", "nec", "list", "cs", "vals", "context", "var", "js", "later", "window", "vor", "proc", "v", "pointer", "factor", "this", "feat", "str", "binary", "name", "iv", "text", "coll", "ctr", "file", "contin", "ef", "term", "op", "coord", "opt", "cer", "unit", "buf", "filename", "life", "soc", "winner", "video", "vc", "lc", "prev", "flat", "serv", "time", "verb", "crit", "func", "bytes", "fit", "arr", "uv", "score", "cf", "depth", "ver", "length", "req", "script", "cod", "voc", "variable", "ec", "fun", "nv", "kt", "feature", "json", "entry", "version", "cycle", "id", "word", "ctx", "index", "frame", "vr", "seq", "editor", "vert", "array", "chrom", "fn", "vp", "vector", "zero"]}}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_max_ns);\n\n\n\n        if (max_ns) {\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 6206, "substitutes": {"ctx": ["cp", "cmp", "gc", "anc", "cr", "fw", "ci", "config", "nc", "rc", "cca", "sync", "cus", "comp", "loc", "cm", "support", "tx", "cl", "event", "client", "ga", "call", "pc", "cc", "cli", "cs", "ck", "sc", "connection", "conn", "cmd", "instance", "bc", "cb", "cms", "Context", "cu", "jp", "context", "kw", "ca", "qa", "css", "req", "c", "ct", "cn", "cf", "lc", "thread", "util", "fc", "cv", "vc", "cas", "grad", "ctrl", "pkg", "xc", "tc"], "blocking": ["padding", "using", "regular", "block", "testing", "http", "complete", "starting", "including", "loading", "successful", "rolling", "ocking", "cl", "client", "background", "enabled", "cli", "locking", "buffer", "exclusive", "full", "calling", "bc", "working", "exec", "interrupted", "running", "blocks", "restricted", "protected", "locked", "ssl", "bl", "partial", "quiet", "prefix"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_srlq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    TCGv t0 = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    TCGv t2 = tcg_temp_local_new();\n\n    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_movi_tl(t1, 0xFFFFFFFF);\n\n    tcg_gen_shr_tl(t2, t1, t2);\n\n    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);\n\n    gen_load_spr(t0, SPR_MQ);\n\n    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_and_tl(t0, t0, t2);\n\n    gen_load_spr(t1, SPR_MQ);\n\n    tcg_gen_andc_tl(t1, t1, t2);\n\n    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);\n\n    gen_set_label(l2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 5219, "substitutes": {"ctx": ["cp", "cmp", "cfg", "anc", "hw", "pai", "ci", "gru", "component", "config", "qt", "cus", "rc", "cca", "sync", "sys", "concept", "loc", "cm", "tx", "client", "conv", "JC", "cc", "cli", "cs", "sci", "crit", "kt", "np", "ck", "sc", "mc", "que", "connection", "cam", "cmd", "bc", "cb", "cu", "Context", "cms", "exec", "context", "input", "ctrl", "ca", "qa", "cpu", "kb", "utils", "c", "txt", "cn", "cf", "chan", "cv", "vc", " cx", "git", "src", "cpp", "cas", "conn", "pkg", "tc"]}}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "void address_space_destroy_dispatch(AddressSpace *as)\n\n{\n\n    AddressSpaceDispatch *d = as->dispatch;\n\n\n\n    memory_listener_unregister(&d->listener);\n\n    g_free(d);\n\n    as->dispatch = NULL;\n\n}\n", "idx": 11624, "substitutes": {"as": ["As", "asc", "is", "asp", "b", "x", "instance", "bs", "gs", "var", "sa", "ad", "s", "asu", "asse", "at", "amd", "or", "ass", "rs", "os", "ac", "an", "cs", "aws", "acs", "al", "parse", "ras", "ars", "cas", "ar", "r", "las", "am", "asha", "nas", "ident", "ans", "asm", "ast", "this", "ash", "a", "pas", "ps", "ss", "ap", "atts", "AS", "any", "with"], "d": ["ld", "l", "gd", "mad", "dh", "ds", "did", "g", "da", "m", "dt", "dos", "fd", "b", "dj", "z", "data", "ad", "s", "bd", "p", "c", "e", "pd", "cd", "driver", "dn", "ded", "dl", "db", "dat", "nd", "md", "dd", "patch", "dc", "sd", "od", "a", "del", "dx", "D"]}}
{"project": "FFmpeg", "commit_id": "42361bdf51c4495ca71a532efbb7769475c1822c", "target": 0, "func": "int ff_MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n\n{\n\n    int i, ret;\n\n    Picture *pic;\n\n    s->mb_skipped = 0;\n\n\n\n    if (!ff_thread_can_start_frame(avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Attempt to start a frame outside SETUP state\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* mark & release old frames */\n\n    if (s->pict_type != AV_PICTURE_TYPE_B && s->last_picture_ptr &&\n\n        s->last_picture_ptr != s->next_picture_ptr &&\n\n        s->last_picture_ptr->f.buf[0]) {\n\n        ff_mpeg_unref_picture(s, s->last_picture_ptr);\n\n    }\n\n\n\n    /* release forgotten pictures */\n\n    /* if (mpeg124/h263) */\n\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n\n        if (&s->picture[i] != s->last_picture_ptr &&\n\n            &s->picture[i] != s->next_picture_ptr &&\n\n            s->picture[i].reference && !s->picture[i].needs_realloc) {\n\n            if (!(avctx->active_thread_type & FF_THREAD_FRAME))\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"releasing zombie picture\\n\");\n\n            ff_mpeg_unref_picture(s, &s->picture[i]);\n\n        }\n\n    }\n\n\n\n    ff_mpeg_unref_picture(s, &s->current_picture);\n\n\n\n    release_unused_pictures(s);\n\n\n\n    if (s->current_picture_ptr &&\n\n        s->current_picture_ptr->f.buf[0] == NULL) {\n\n        // we already have a unused image\n\n        // (maybe it was set before reading the header)\n\n        pic = s->current_picture_ptr;\n\n    } else {\n\n        i   = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        pic = &s->picture[i];\n\n    }\n\n\n\n    pic->reference = 0;\n\n    if (!s->droppable) {\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            pic->reference = 3;\n\n    }\n\n\n\n    pic->f.coded_picture_number = s->coded_picture_number++;\n\n\n\n    if (ff_alloc_picture(s, pic, 0) < 0)\n\n        return -1;\n\n\n\n    s->current_picture_ptr = pic;\n\n    // FIXME use only the vars from current_pic\n\n    s->current_picture_ptr->f.top_field_first = s->top_field_first;\n\n    if (s->codec_id == AV_CODEC_ID_MPEG1VIDEO ||\n\n        s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        if (s->picture_structure != PICT_FRAME)\n\n            s->current_picture_ptr->f.top_field_first =\n\n                (s->picture_structure == PICT_TOP_FIELD) == s->first_field;\n\n    }\n\n    s->current_picture_ptr->f.interlaced_frame = !s->progressive_frame &&\n\n                                                 !s->progressive_sequence;\n\n    s->current_picture_ptr->field_picture      =  s->picture_structure != PICT_FRAME;\n\n\n\n    s->current_picture_ptr->f.pict_type = s->pict_type;\n\n    // if (s->flags && CODEC_FLAG_QSCALE)\n\n    //     s->current_picture_ptr->quality = s->new_picture_ptr->quality;\n\n    s->current_picture_ptr->f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n\n\n    if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,\n\n                                   s->current_picture_ptr)) < 0)\n\n        return ret;\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_B) {\n\n        s->last_picture_ptr = s->next_picture_ptr;\n\n        if (!s->droppable)\n\n            s->next_picture_ptr = s->current_picture_ptr;\n\n    }\n\n    av_dlog(s->avctx, \"L%p N%p C%p L%p N%p C%p type:%d drop:%d\\n\",\n\n            s->last_picture_ptr, s->next_picture_ptr,s->current_picture_ptr,\n\n            s->last_picture_ptr    ? s->last_picture_ptr->f.data[0]    : NULL,\n\n            s->next_picture_ptr    ? s->next_picture_ptr->f.data[0]    : NULL,\n\n            s->current_picture_ptr ? s->current_picture_ptr->f.data[0] : NULL,\n\n            s->pict_type, s->droppable);\n\n\n\n    if ((s->last_picture_ptr == NULL ||\n\n         s->last_picture_ptr->f.buf[0] == NULL) &&\n\n        (s->pict_type != AV_PICTURE_TYPE_I ||\n\n         s->picture_structure != PICT_FRAME)) {\n\n        int h_chroma_shift, v_chroma_shift;\n\n        av_pix_fmt_get_chroma_sub_sample(s->avctx->pix_fmt,\n\n                                         &h_chroma_shift, &v_chroma_shift);\n\n        if (s->pict_type == AV_PICTURE_TYPE_B && s->next_picture_ptr && s->next_picture_ptr->f.buf[0])\n\n            av_log(avctx, AV_LOG_DEBUG,\n\n                   \"allocating dummy last picture for B frame\\n\");\n\n        else if (s->pict_type != AV_PICTURE_TYPE_I)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"warning: first frame is no keyframe\\n\");\n\n        else if (s->picture_structure != PICT_FRAME)\n\n            av_log(avctx, AV_LOG_DEBUG,\n\n                   \"allocate dummy last picture for field based first keyframe\\n\");\n\n\n\n        /* Allocate a dummy frame */\n\n        i = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        s->last_picture_ptr = &s->picture[i];\n\n\n\n        s->last_picture_ptr->reference   = 3;\n\n        s->last_picture_ptr->f.key_frame = 0;\n\n        s->last_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        if (ff_alloc_picture(s, s->last_picture_ptr, 0) < 0) {\n\n            s->last_picture_ptr = NULL;\n\n            return -1;\n\n        }\n\n\n\n        memset(s->last_picture_ptr->f.data[0], 0x80,\n\n               avctx->height * s->last_picture_ptr->f.linesize[0]);\n\n        memset(s->last_picture_ptr->f.data[1], 0x80,\n\n               (avctx->height >> v_chroma_shift) *\n\n               s->last_picture_ptr->f.linesize[1]);\n\n        memset(s->last_picture_ptr->f.data[2], 0x80,\n\n               (avctx->height >> v_chroma_shift) *\n\n               s->last_picture_ptr->f.linesize[2]);\n\n\n\n        if(s->codec_id == AV_CODEC_ID_FLV1 || s->codec_id == AV_CODEC_ID_H263){\n\n            for(i=0; i<avctx->height; i++)\n\n            memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, avctx->width);\n\n        }\n\n\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 0);\n\n        ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 1);\n\n    }\n\n    if ((s->next_picture_ptr == NULL ||\n\n         s->next_picture_ptr->f.buf[0] == NULL) &&\n\n        s->pict_type == AV_PICTURE_TYPE_B) {\n\n        /* Allocate a dummy frame */\n\n        i = ff_find_unused_picture(s, 0);\n\n        if (i < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"no frame buffer available\\n\");\n\n            return i;\n\n        }\n\n        s->next_picture_ptr = &s->picture[i];\n\n\n\n        s->next_picture_ptr->reference   = 3;\n\n        s->next_picture_ptr->f.key_frame = 0;\n\n        s->next_picture_ptr->f.pict_type = AV_PICTURE_TYPE_P;\n\n\n\n        if (ff_alloc_picture(s, s->next_picture_ptr, 0) < 0) {\n\n            s->next_picture_ptr = NULL;\n\n            return -1;\n\n        }\n\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 0);\n\n        ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 1);\n\n    }\n\n\n\n#if 0 // BUFREF-FIXME\n\n    memset(s->last_picture.f.data, 0, sizeof(s->last_picture.f.data));\n\n    memset(s->next_picture.f.data, 0, sizeof(s->next_picture.f.data));\n\n#endif\n\n    if (s->last_picture_ptr) {\n\n        ff_mpeg_unref_picture(s, &s->last_picture);\n\n        if (s->last_picture_ptr->f.buf[0] &&\n\n            (ret = ff_mpeg_ref_picture(s, &s->last_picture,\n\n                                       s->last_picture_ptr)) < 0)\n\n            return ret;\n\n    }\n\n    if (s->next_picture_ptr) {\n\n        ff_mpeg_unref_picture(s, &s->next_picture);\n\n        if (s->next_picture_ptr->f.buf[0] &&\n\n            (ret = ff_mpeg_ref_picture(s, &s->next_picture,\n\n                                       s->next_picture_ptr)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    av_assert0(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&\n\n                                                 s->last_picture_ptr->f.buf[0]));\n\n\n\n    if (s->picture_structure!= PICT_FRAME) {\n\n        int i;\n\n        for (i = 0; i < 4; i++) {\n\n            if (s->picture_structure == PICT_BOTTOM_FIELD) {\n\n                s->current_picture.f.data[i] +=\n\n                    s->current_picture.f.linesize[i];\n\n            }\n\n            s->current_picture.f.linesize[i] *= 2;\n\n            s->last_picture.f.linesize[i]    *= 2;\n\n            s->next_picture.f.linesize[i]    *= 2;\n\n        }\n\n    }\n\n\n\n    s->err_recognition = avctx->err_recognition;\n\n\n\n    /* set dequantizer, we can't do it during init as\n\n     * it might change for mpeg4 and we can't do it in the header\n\n     * decode as init is not called for mpeg4 there yet */\n\n    if (s->mpeg_quant || s->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg2_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg2_inter;\n\n    } else if (s->out_format == FMT_H263 || s->out_format == FMT_H261) {\n\n        s->dct_unquantize_intra = s->dct_unquantize_h263_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_h263_inter;\n\n    } else {\n\n        s->dct_unquantize_intra = s->dct_unquantize_mpeg1_intra;\n\n        s->dct_unquantize_inter = s->dct_unquantize_mpeg1_inter;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24881, "substitutes": {"s": ["comments", "sys", "ns", "ts", "vs", "sites", "sq", "ps", "states", "sync", "self", "sis", "u", "es", "gs", "stats", "http", "sym", "xs", "f", "fs", "qs", "js", "n", "service", "t", "j", "r", "ops", "S", "p", "b", "m", "c", "se", "sports", "storage", "ds", "ans", "us", "ins", "css", "is", "su", "sets", "ions", "spec", "aws", "new", "services", "h", "details", "settings", "its", "g", "times", "rs", "ses", "args", "ss", "bis", "d", "ms", "conf", "sg", "ks", "e", "session", "hs", "client", "sb", "full", "sf", "ssl", "sv", "cs", "plugins", "o", "si", "words", "os", "uns", "as", "ls", "a", "v", "parts", "l"], "avctx": ["afctl", "armcmp", "aucca", "vrloc", "avcoll", "navcontext", "vrctrl", "afctrl", "AVconfig", "avecontext", "avcca", "vrcontext", "mpctx", "AVcmp", "absync", "abcontext", "avcmp", "mpcoll", "mpcontext", "armctl", "mpcmp", "afcmp", "Avconnection", "aucontext", "avcontext", "avsync", "armcontext", "auctx", "aveconfig", "afctx", "avconfig", "afcontext", "armctx", "avectx", "avctl", "ajctx", "avectrl", "abconfig", "AVsync", "avconnection", "avloc", "avecoll", "abctx", "aveconnection", "avctrl", "afxc", "navsync", "Avcontext", "AVconnection", "navconfig", "aveloc", "AVctx", "afcoll", "avxc", "AVctl", "avecmp", "Avconfig", "afloc", "ajcontext", "auxc", "afcca", "navctx", "ajxc", "AVcontext", "Avctx", "ajcca", "vrctx"], "i": ["ski", "z", "ie", "name", "ei", "it", "io", "u", "li", "start", "bi", "ini", "ai", "f", "n", "j", "t", "r", "chi", "val", "code", "k", "slice", "p", "m", "b", "c", "x", "ti", "mi", "phi", "qi", "ri", "line", "di", "ci", "eni", "ki", "in", "g", "abi", "yi", "d", "data", "adi", "e", "err", "uri", "ii", "cli", "fi", "lc", "I", "count", "ori", "iu", "info", "ix", "api", "type", "end", "id", "gi", "ji", "o", "zi", "multi", "xi", "si", "ni", "iv", "aci", "y", "mini", "oi", "ip", "index", "a", "v", "ind", "pi", "ui", "l", "hi"], "ret": ["ru", "obj", "res", "bis", "jp", "ri", "num", "arr", "RET", "fi", "reply", "rc", "feat", "arg", "Ret", "gc", "resp", "J", "r", "result", "len", "val"], "pic": ["picture", "pa", "pins", "Picture", "photos", "p", "pot", "parse", "cat", "image", "fn", "doc", "capt", "study", "photo", "img", "config", "vec", "style", "jp", "feature", "cus", "bc", "mac", "piece", "fc", "li", "pse", "ic", "zi", "str", "xi", "spec", "lib", "bi", "si", "ig", "pin", "avi", "fi", "sec", "fat", "sci", "feat", "cache", "sa", "lc", "Pic", "mini", "pict", "fp", " picture", "ac", "pc", "file"]}}
{"project": "qemu", "commit_id": "e5f34cdd2da54f28d90889a3afd15fad2d6105ff", "target": 1, "func": "static void vnc_set_share_mode(VncState *vs, VncShareMode mode)\n\n{\n\n#ifdef _VNC_DEBUG\n\n    static const char *mn[] = {\n\n        [0]                           = \"undefined\",\n\n        [VNC_SHARE_MODE_CONNECTING]   = \"connecting\",\n\n        [VNC_SHARE_MODE_SHARED]       = \"shared\",\n\n        [VNC_SHARE_MODE_EXCLUSIVE]    = \"exclusive\",\n\n        [VNC_SHARE_MODE_DISCONNECTED] = \"disconnected\",\n\n    };\n\n    fprintf(stderr, \"%s/%d: %s -> %s\\n\", __func__,\n\n            vs->csock, mn[vs->share_mode], mn[mode]);\n\n#endif\n\n\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive--;\n\n    }\n\n    vs->share_mode = mode;\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive++;\n\n    }\n\n}\n", "idx": 5314, "substitutes": {"vs": ["fg", "views", "verts", "vr", "posts", "vg", "v", "http", "vm", "docs", "s", "alls", "plugins", "va", "values", "vt", "ums", "VS", "wp", "ses", "vas", "services", "obs", "sts", "vals", "sk", "pg", "ns", "state", "stats", "ls", "ports", "bs", "ss", "cs", "net", "sb", "gs", "ks", "ds", "qs", "ts", "oss", "ils", "self", "eps", "vers", "vp", "sv", "Vs", "fs", "ves", "var", "ys", "changes", "utils", "ms", "lv", "ov", "blogs", "env", "cv", "vc", "es", "rs", "versions", "events", "lines", "ps", "flags"], "mode": ["address", "option", "MODE", "name", "dm", "id", "md", "method", "vm", "scope", "Mode", "device", "language", "username", "value", "op", "object", "password", "alias", "module", "m", "map", "status", "route", "key", "de", "project", "mp", "state", "nm", "grade", "mod", "version", "operator", "member", "purpose", "size", "kind", "cmd", "path", "me", "source", "scale", "prop", "mr", "direction", "node", "rule", "slave", "mm", "type", "ms", "move", "manager", "ui", "role"], "mn": ["ml", "nor", "na", "dm", "ann", "md", "nn", "dn", "vm", "pin", "wm", "bm", "m", "rm", "pm", "mp", "ns", "nm", "Mi", "man", "mc", "MN", "mis", "fn", "n", "ains", "mi", "mb", "misc", "fm", "mr", "ln", "mm", "ms", "mx", "cn", "MC", "gn", "cm", "mins"], "vd": ["nv", "vg", "od", "md", "bd", "dn", "vid", "dd", "va", "vt", "pd", "eddy", "uv", "dk", "hov", "adder", "uds", "vision", "wd", "sd", "xd", "ant", "sv", "ld", "gd", "lv", "fd", "dl", "vv", "ud", "cv", "vc", "VD", "hd", "nd"], "num_exclusive": ["num_clusive", "max_external", "number_exclusive", "numAllexclusive", "number_sharing", "numAllshared", "number_clusive", "max_clusive", "numAllsharing", "num_external", "num_seconds", "numwseconds", "max_exclusive", "numwclusive", "numwexclusive", "numAllclusive", "number_shared", "num_shared", "numwexternal", "max_seconds", "num_sharing"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_tco1_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = NULL;\n\n    d.noreboot = true;\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(false);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC);\n\n\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);\n\n    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);\n\n    qtest_end();\n\n}\n", "idx": 20835, "substitutes": {"d": ["md", "dos", "i", "e", "cd", "rd", "ind", "g", "driver", "ded", "db", "ed", "wd", "dad", "xd", "de", " dd", "pd", "dh", "vd", "ds", "ld", "f", "gd", "done", "t", "u", "cmd", "m", "s", "da", "dd", "nd", "data", "ad", "j", "p", "did", "diff", "id", "dict", "o", "mod", "q", "dy", "od", "c", "dr", "module", "sd", "dx", "dom", "self", "dt", "b", "dc", "w", "in", "draw", "dm", "mad", "dl", "n", "fd", "ard", "bd", "D", "di", "dat", "h", "l", "x", "k"], "val": ["ival", "reg", "sel", "end", "err", "ref", "ind", "valid", "sl", "arg", "part", "cond", "Ret", "bl", "al", "pre", "bit", "args", "data", "dev", "stat", "vals", "unit", "slot", "elt", "live", "rot", "el", "fe", "aval", "rt", "x", "seq", "vol", "len", "VAL", "Val", "v", "alt", "sec", "eval", "all", "pt", "base", "value"], "ret": ["sat", "ut", "reg", "sel", " alt", "gt", "valid", "result", "part", "arg", "aud", "det", "rep", "pit", "Ret", "ben", "bit", " arg", "res", " pat", "rets", "fin", " RET", "rot", "out", "rc", "pin", "et", "match", "let", "RET", "rt", " Ret", "value", "flag", "rev", "pat", "re", "len", "lt", "vert", "alt", "nt", "lit", "eval", " result", "ft"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static int vaapi_encode_h264_init_sequence_params(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext                 *ctx = avctx->priv_data;\n\n    VAEncSequenceParameterBufferH264  *vseq = ctx->codec_sequence_params;\n\n    VAEncPictureParameterBufferH264   *vpic = ctx->codec_picture_params;\n\n    VAAPIEncodeH264Context            *priv = ctx->priv_data;\n\n    VAAPIEncodeH264MiscSequenceParams *mseq = &priv->misc_sequence_params;\n\n    int i;\n\n\n\n    {\n\n        vseq->seq_parameter_set_id = 0;\n\n\n\n        vseq->level_idc = avctx->level;\n\n\n\n        vseq->max_num_ref_frames = 2;\n\n\n\n        vseq->picture_width_in_mbs  = priv->mb_width;\n\n        vseq->picture_height_in_mbs = priv->mb_height;\n\n\n\n        vseq->seq_fields.bits.chroma_format_idc = 1;\n\n        vseq->seq_fields.bits.frame_mbs_only_flag = 1;\n\n        vseq->seq_fields.bits.direct_8x8_inference_flag = 1;\n\n        vseq->seq_fields.bits.log2_max_frame_num_minus4 = 4;\n\n        vseq->seq_fields.bits.pic_order_cnt_type = 0;\n\n\n\n        if (ctx->input_width  != ctx->aligned_width ||\n\n            ctx->input_height != ctx->aligned_height) {\n\n            vseq->frame_cropping_flag = 1;\n\n\n\n            vseq->frame_crop_left_offset   = 0;\n\n            vseq->frame_crop_right_offset  =\n\n                (ctx->aligned_width - ctx->input_width) / 2;\n\n            vseq->frame_crop_top_offset    = 0;\n\n            vseq->frame_crop_bottom_offset =\n\n                (ctx->aligned_height - ctx->input_height) / 2;\n\n        } else {\n\n            vseq->frame_cropping_flag = 0;\n\n        }\n\n\n\n        vseq->vui_parameters_present_flag = 1;\n\n        if (avctx->sample_aspect_ratio.num != 0) {\n\n            vseq->vui_fields.bits.aspect_ratio_info_present_flag = 1;\n\n            // There is a large enum of these which we could support\n\n            // individually rather than using the generic X/Y form?\n\n            if (avctx->sample_aspect_ratio.num ==\n\n                avctx->sample_aspect_ratio.den) {\n\n                vseq->aspect_ratio_idc = 1;\n\n            } else {\n\n                vseq->aspect_ratio_idc = 255; // Extended SAR.\n\n                vseq->sar_width  = avctx->sample_aspect_ratio.num;\n\n                vseq->sar_height = avctx->sample_aspect_ratio.den;\n\n            }\n\n        }\n\n        if (avctx->color_primaries != AVCOL_PRI_UNSPECIFIED ||\n\n            avctx->color_trc       != AVCOL_TRC_UNSPECIFIED ||\n\n            avctx->colorspace      != AVCOL_SPC_UNSPECIFIED) {\n\n            mseq->video_signal_type_present_flag = 1;\n\n            mseq->video_format             = 5; // Unspecified.\n\n            mseq->video_full_range_flag    = 0;\n\n            mseq->colour_description_present_flag = 1;\n\n            // These enums are derived from the standard and hence\n\n            // we can just use the values directly.\n\n            mseq->colour_primaries         = avctx->color_primaries;\n\n            mseq->transfer_characteristics = avctx->color_trc;\n\n            mseq->matrix_coefficients      = avctx->colorspace;\n\n        }\n\n\n\n        vseq->bits_per_second = avctx->bit_rate;\n\n\n\n        vseq->vui_fields.bits.timing_info_present_flag = 1;\n\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {\n\n            vseq->num_units_in_tick = avctx->framerate.num;\n\n            vseq->time_scale        = 2 * avctx->framerate.den;\n\n            mseq->fixed_frame_rate_flag = 1;\n\n        } else {\n\n            vseq->num_units_in_tick = avctx->time_base.num;\n\n            vseq->time_scale        = 2 * avctx->time_base.den;\n\n            mseq->fixed_frame_rate_flag = 0;\n\n        }\n\n\n\n        if (ctx->va_rc_mode == VA_RC_CBR) {\n\n            priv->send_timing_sei = 1;\n\n            mseq->nal_hrd_parameters_present_flag = 1;\n\n\n\n            mseq->cpb_cnt_minus1 = 0;\n\n\n\n            // Try to scale these to a sensible range so that the\n\n            // golomb encode of the value is not overlong.\n\n            mseq->bit_rate_scale =\n\n                av_clip_uintp2(av_log2(avctx->bit_rate) - 15 - 6, 4);\n\n            mseq->bit_rate_value_minus1[0] =\n\n                (avctx->bit_rate >> mseq->bit_rate_scale + 6) - 1;\n\n\n\n            mseq->cpb_size_scale =\n\n                av_clip_uintp2(av_log2(priv->hrd_params.hrd.buffer_size) - 15 - 4, 4);\n\n            mseq->cpb_size_value_minus1[0] =\n\n                (priv->hrd_params.hrd.buffer_size >> mseq->cpb_size_scale + 4) - 1;\n\n\n\n            // CBR mode isn't actually available here, despite naming.\n\n            mseq->cbr_flag[0] = 0;\n\n\n\n            mseq->initial_cpb_removal_delay_length_minus1 = 23;\n\n            mseq->cpb_removal_delay_length_minus1         = 23;\n\n            mseq->dpb_output_delay_length_minus1          = 7;\n\n            mseq->time_offset_length = 0;\n\n\n\n            // This calculation can easily overflow 32 bits.\n\n            mseq->initial_cpb_removal_delay = 90000 *\n\n                (uint64_t)priv->hrd_params.hrd.initial_buffer_fullness /\n\n                priv->hrd_params.hrd.buffer_size;\n\n\n\n            mseq->initial_cpb_removal_delay_offset = 0;\n\n        } else {\n\n            priv->send_timing_sei = 0;\n\n            mseq->nal_hrd_parameters_present_flag = 0;\n\n        }\n\n\n\n        vseq->intra_period     = ctx->p_per_i * (ctx->b_per_p + 1);\n\n        vseq->intra_idr_period = vseq->intra_period;\n\n        vseq->ip_period        = ctx->b_per_p + 1;\n\n    }\n\n\n\n    {\n\n        vpic->CurrPic.picture_id = VA_INVALID_ID;\n\n        vpic->CurrPic.flags      = VA_PICTURE_H264_INVALID;\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(vpic->ReferenceFrames); i++) {\n\n            vpic->ReferenceFrames[i].picture_id = VA_INVALID_ID;\n\n            vpic->ReferenceFrames[i].flags      = VA_PICTURE_H264_INVALID;\n\n        }\n\n\n\n        vpic->coded_buf = VA_INVALID_ID;\n\n\n\n        vpic->pic_parameter_set_id = 0;\n\n        vpic->seq_parameter_set_id = 0;\n\n\n\n        vpic->num_ref_idx_l0_active_minus1 = 0;\n\n        vpic->num_ref_idx_l1_active_minus1 = 0;\n\n\n\n        vpic->pic_fields.bits.entropy_coding_mode_flag =\n\n            ((avctx->profile & 0xff) != 66);\n\n        vpic->pic_fields.bits.weighted_pred_flag = 0;\n\n        vpic->pic_fields.bits.weighted_bipred_idc = 0;\n\n        vpic->pic_fields.bits.transform_8x8_mode_flag =\n\n            ((avctx->profile & 0xff) >= 100);\n\n\n\n        vpic->pic_init_qp = priv->fixed_qp_idr;\n\n    }\n\n\n\n    {\n\n        mseq->profile_idc = avctx->profile & 0xff;\n\n\n\n        if (avctx->profile & FF_PROFILE_H264_CONSTRAINED)\n\n            mseq->constraint_set1_flag = 1;\n\n        if (avctx->profile & FF_PROFILE_H264_INTRA)\n\n            mseq->constraint_set3_flag = 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 17128, "substitutes": {"avctx": ["avectx", "devctx", "avconfig", "Avkb", "AVconfig", "varcm", "afcu", "varcmp", "aveconn", "devkb", "avkb", "avcm", "vcm", "abctrl", "AVkb", "AVcmp", "AVcu", "avctrl", "afcontext", " avcu", "AVcm", "Avcontext", "devconfig", "Avcu", "avconn", "afctx", "abctx", "abcontext", "afctrl", "vcmp", "abkb", "abconfig", "avecontext", " avkb", "varctx", "afconn", "avectrl", "AVctx", " avcontext", "AVconn", "abconn", "AVcontext", "Avconn", "avcmp", "vctx", "avcu", "vcontext", "Avctx", "avcontext", "varcontext", "devcontext"], "ctx": ["pc", "rx", "instance", "cfg", "cdn", "fp", "cca", "cus", "vc", "conn", "concept", "rc", "cm", "cf", "cb", "anc", "bc", "cp", "loc", "wcs", "utils", "mc", "scope", "ctrl", "cas", "Context", "ca", "cs", "exec", "context", "hw", "cms", "conv", "kb", "pkg", "common", "tx", "nc", "ci", "tc", "config", "xc", "qs", "sc", "cu", "cam", "client", "cli", "lc", "c", "req", "sync", "qa", "cmd", "uc", "lib", "ck", "sci", "cmp", "fn", "sys", "cn", "sq", "cv", "cc"], "vseq": [" vsequ", "variseq", "Vsequ", "revsequ", " vsequence", "nsequence", "lzip", "vstruct", "Vclus", "vref", "voltseq", "fvec", "evclus", "nvsequence", "revna", "guvec", "msequence", "tvseq", "ssequ", "gumodel", " vzip", "mfeat", "lvec", "vna", "varimodel", "svsequ", "revvec", "lparent", "voltsequ", "Vsequence", "fsequence", "tvzip", "vctx", "svstruct", "sref", "lseq", "lvcomplete", "guiq", "msequ", "lref", " vctx", "revseq", "vsequ", " vstruct", "lcomplete", "nseq", "varisem", "nstruct", " viq", "hsem", "vsem", "lvsequence", "mclus", "voltsequence", "vbuf", "svsem", "fctx", "lsequence", "svsequence", "wsequ", "ssequence", "nvvec", "lsequ", "voltsem", "fsequ", "evfeat", "sseq", "revscript", "tvsequence", " vna", "wseq", "psequence", "Vseq", "guseq", "Vvec", "versequ", "wsem", "wsequence", "versequence", "evsequence", "Vbuf", "viq", "tvclus", "evframe", "svbuf", "psequ", "svseq", "liq", "lclus", "vscript", "hscript", "hseq", "fseq", "vervec", "revfile", "fsem", "lna", "varivec", "hclus", "vframe", "svclus", "Vfeat", "fstruct", "nvfile", " vref", "evsequ", "Vmodel", "vgen", "vparent", "vmodel", "Vframe", " vgen", " vfeat", "pscript", "vcomplete", "vclus", " vframe", "pseq", "hsequ", "verseq", "vsequence", "lvseq", "Vfile", " vparent", "vfeat", "gusequence", "revsequence", "vvec", "nvseq", " vvec", "hgen", " vclus", "varisequence", "Vctx", "Vstruct", "lvsequ", "evseq", "variclus", "vfile", "vzip", "revparent", " vcomplete", "nbuf", "mgen", " vsem", "hsequence"], "vpic": [" vstruct", "mpic", "vstruct", "svmac", "mstruct", "svctx", "mmac", "vctx", "svstruct", "vmac", " vmac", " vctx", "mctx", "svpic"], "priv": ["util", "cfg", "txt", "ch", "data", "pub", "conf", "obj", "cca", "vc", "reader", "rc", "Priv", "acc", "cb", "anc", "auth", "cp", "loc", "ocr", "fac", "utils", "mc", "sec", "pb", "kw", "sk", "ca", "auc", "roc", "gb", "pkg", "tx", "aux", "pri", "ci", "config", "soc", "prof", "cam", "voc", "client", "private", "req", "lc", "ki", "ram", "uc", "access", "cache", "cmp", "rate", "sys", "proc", "riv", "prem", "conn", "cci"], "mseq": ["vmsequ", "mmsequ", "fmsequ", "mmsequence", "fmseq", "vmsel", "fmsequence", "mmseq", "msel", "msequ", "mmsel", "vmseq", "vmsequence", "msequence", "fmsel"], "i": ["ti", "m", "bi", "j", "x", "f", "qi", "ai", "n", "ii", "iu", "index", "I", "count", "ip", "d", "pi", "ui", "ci", "id", "k", "batch", "v", "c", "si", "p", "a", "li"]}}
{"project": "qemu", "commit_id": "debaaa114a8877a939533ba846e64168fb287b7b", "target": 0, "func": "static void test_hba_enable(void)\n\n{\n\n    AHCIQState *ahci;\n\n\n\n    ahci = ahci_boot();\n\n    ahci_pci_enable(ahci);\n\n    ahci_hba_enable(ahci);\n\n    ahci_shutdown(ahci);\n\n}\n", "idx": 20562, "substitutes": {"ahci": ["AHcu", "ehcu", "avecu", "accium", "aphcia", "ahcin", "akcin", "ahcium", "yahcu", "ehci", "yahcci", "lahcin", "akcium", "avec", "avecium", "akcu", "lahcu", "earci", "AHcin", "akcci", "ahc", "lahcia", "akrc", "accu", "lahcci", "acc", "earcium", "AHcia", "ahrc", "yahrc", "earcci", "acci", "ahcci", "lahci", "lahcium", "yahcin", "ehcin", "akci", "ahcia", "earcu", "AHci", "ehcci", "amcium", "aphcin", "amci", "aphci", "yahci", "aphcu", "aveci", "amcu", "amc", "ehrc", "ahcu"]}}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_passive_mode_epsv(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    static const char d = '|';\n\n    static const char *command = \"EPSV\\r\\n\";\n\n    static const int epsv_codes[] = {229, 0};\n\n\n\n    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '(') {\n\n            start = res + i + 1;\n\n        } else if (res[i] == ')') {\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n    if (!start || !end)\n\n        goto fail;\n\n\n\n    *end = '\\0';\n\n    if (strlen(start) < 5)\n\n        goto fail;\n\n    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)\n\n        goto fail;\n\n    start += 3;\n\n    end[-1] = '\\0';\n\n\n\n    s->server_data_port = atoi(start);\n\n    av_dlog(s, \"Server data port: %d\\n\", s->server_data_port);\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    s->server_data_port = -1;\n\n    return AVERROR(ENOSYS);\n\n}\n", "idx": 18583, "substitutes": {"s": ["ns", "m", "ts", "session", "t", "rates", "aws", "core", "f", "conf", "settings", "services", "service", "r", "n", "sb", "g", "ss", "ls", "ops", "fs", "self", "xs", "is", "o", "cs", "d", "su", "socket", "w", "fts", "qs", "e", "ssl", "ses", "sync", "client", "c", "js", "ps", "si", "sym", "p", "secondary", "S", "b", "ks", "gs", "sys", "u", "storage", "your", "a", "es", "os", "us", "hs", "south", "sets", "ds", "sf"], "res": ["rx", "ms", "ros", "ret", "content", "rs", "info", "rest", "ras", "err", "ix", "rc", "r", "results", "reg", "result", "vals", "details", "rh", "resolution", "Res", "des", "RES", "ry", "resp", "def", "arr", "changes", "cs", "ris", "range", "rec", "ray", "re", "ress", "gr", "pre", "ins", "args", "reset", "blocks", "response", "prev", "id", "remote", "ries", "e", "rev", "req", "rus", "rows", "resource", "rez", "ids", "error", "ons", "rep", "errors", "es", "os", "pres", "rem", "reply", "progress", "params"], "start": ["offset", "x", "str", "show", "max", "ie", "pos", "started", "range", "d", "length", "id", "mid", "p", "test", "next", "source", "part", "init", "work", "rest", "name", "from", "in", "min", "count", "art", "parse", "size", "pre", "stop", "style", "key", "k", "open", "patch", "shift", "time", "r", "root", "Start", "type", "ind", "date", "grade", "starting", "ad", "check", "info", "sp", "get", "old", "step", "first", "space", "cost", "seed", "use", "add", "e", "error", "se", "diff"], "end": ["ion", "inner", "est", "set", "offset", "code", "info", "rest", "name", "all", "r", "n", "then", "END", "max", "index", "pos", "en", "after", "enc", "range", "End", "d", "change", "begin", "stop", "value", "add", "last", "use", "id", "e", "send", "open", "v", "ad", "c", "post", "p", "address", "b", "append", "next", "length", "h", "ension", "edge", "ending", "order", "ended"], "i": ["ti", "gi", "uri", "m", "bi", "j", "code", "t", "x", "f", "ix", "ini", "qi", "r", "ai", "mi", "n", "io", "hi", "ii", "in", "ori", "di", "index", "ind", "iu", "I", "ie", "min", "multi", "is", "o", "ip", "l", "d", "rec", "oi", "pi", "ui", "ci", "pri", "w", "abi", "id", "e", "rev", "v", "c", "si", "ri", "xi", "p", "shift", "b", "u", "iv", "api", "it", "eni", "iter", "fi", "one", "y", "li", "len"], "command": ["pattern", "m", "content", "code", "request", "data", "mode", "text", "call", "comment", "attribute", "script", "document", "query", "method", "function", "password", "game", "execute", "description", "exec", "array", "directory", "event", "prefix", "response", "Command", "send", "power", "c", "cmd", "resource", "connection", "message", "sequence", "usage", "operation", "custom"], "epsv_codes": ["epsv_flags", "epsv_errors", "epsv_lines", "epsi_codes", "epsi_lines", "epsi_code", "epsi_errors", "epsi_cod", "epsi_flags", "epsv_code", "epsv_cod"]}}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static void show_stream(AVFormatContext *fmt_ctx, int stream_idx)\n\n{\n\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n\n    AVCodecContext *dec_ctx;\n\n    AVCodec *dec;\n\n    char val_str[128];\n\n    AVDictionaryEntry *tag = NULL;\n\n    AVRational display_aspect_ratio;\n\n\n\n    printf(\"[STREAM]\\n\");\n\n\n\n    printf(\"index=%d\\n\", stream->index);\n\n\n\n    if ((dec_ctx = stream->codec)) {\n\n        if ((dec = dec_ctx->codec)) {\n\n            printf(\"codec_name=%s\\n\", dec->name);\n\n            printf(\"codec_long_name=%s\\n\", dec->long_name);\n\n        } else {\n\n            printf(\"codec_name=unknown\\n\");\n\n        }\n\n\n\n        printf(\"codec_type=%s\\n\", media_type_string(dec_ctx->codec_type));\n\n        printf(\"codec_time_base=%d/%d\\n\",\n\n               dec_ctx->time_base.num, dec_ctx->time_base.den);\n\n\n\n        /* print AVI/FourCC tag */\n\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n\n        printf(\"codec_tag_string=%s\\n\", val_str);\n\n        printf(\"codec_tag=0x%04x\\n\", dec_ctx->codec_tag);\n\n\n\n        switch (dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            printf(\"width=%d\\n\", dec_ctx->width);\n\n            printf(\"height=%d\\n\", dec_ctx->height);\n\n            printf(\"has_b_frames=%d\\n\", dec_ctx->has_b_frames);\n\n            if (dec_ctx->sample_aspect_ratio.num) {\n\n                printf(\"sample_aspect_ratio=%d:%d\\n\",\n\n                       dec_ctx->sample_aspect_ratio.num,\n\n                       dec_ctx->sample_aspect_ratio.den);\n\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n\n                          dec_ctx->width  * dec_ctx->sample_aspect_ratio.num,\n\n                          dec_ctx->height * dec_ctx->sample_aspect_ratio.den,\n\n                          1024*1024);\n\n                printf(\"display_aspect_ratio=%d:%d\\n\",\n\n                       display_aspect_ratio.num, display_aspect_ratio.den);\n\n            }\n\n            printf(\"pix_fmt=%s\\n\",\n\n                   dec_ctx->pix_fmt != PIX_FMT_NONE ? av_pix_fmt_descriptors[dec_ctx->pix_fmt].name\n\n                                                    : \"unknown\");\n\n            printf(\"level=%d\\n\", dec_ctx->level);\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            printf(\"sample_rate=%s\\n\", value_string(val_str, sizeof(val_str),\n\n                                                    dec_ctx->sample_rate,\n\n                                                    unit_hertz_str));\n\n            printf(\"channels=%d\\n\", dec_ctx->channels);\n\n            printf(\"bits_per_sample=%d\\n\",\n\n                   av_get_bits_per_sample(dec_ctx->codec_id));\n\n            break;\n\n        }\n\n    } else {\n\n        printf(\"codec_type=unknown\\n\");\n\n    }\n\n\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS)\n\n        printf(\"id=0x%x\\n\", stream->id);\n\n    printf(\"r_frame_rate=%d/%d\\n\",\n\n           stream->r_frame_rate.num, stream->r_frame_rate.den);\n\n    printf(\"avg_frame_rate=%d/%d\\n\",\n\n           stream->avg_frame_rate.num, stream->avg_frame_rate.den);\n\n    printf(\"time_base=%d/%d\\n\",\n\n           stream->time_base.num, stream->time_base.den);\n\n    printf(\"start_time=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->start_time, &stream->time_base));\n\n    printf(\"duration=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->duration, &stream->time_base));\n\n    if (stream->nb_frames)\n\n        printf(\"nb_frames=%\"PRId64\"\\n\", stream->nb_frames);\n\n\n\n    while ((tag = av_dict_get(stream->metadata, \"\", tag,\n\n                              AV_DICT_IGNORE_SUFFIX)))\n\n        printf(\"TAG:%s=%s\\n\", tag->key, tag->value);\n\n\n\n    printf(\"[/STREAM]\\n\");\n\n}\n", "idx": 20005, "substitutes": {"fmt_ctx": ["fmt_context", "fmt_loc", "fmp_loc", "fmt_lc", "fmt2ca", "fmp2hw", "fmp_hw", "fmp_context", "fmp2ctx", "fmt2hw", "fmt2lc", "fmp_ctx", "fmp_lc", "fmt2ctx", "fmp2ca", "fmp2lc", "fmt_ca", "fmp_ca", "fmt_hw"], "stream_idx": ["stream_idsx", "stream_needx", "stream_lenindex", "stream_lenx", "stream_Idx", "stream_needxes", "stream_Idxes", "stream_idsy", "stream_party", "stream_lenxes", "stream_idxs", "stream_partxes", "stream_idindex", "stream_needy", "stream_partx", "stream_partindex", "stream_idy", "stream_leny", "stream_idxes", "stream_Idindex", "stream_Idy", "stream_idsxes", "stream_needxs", "stream_idsxs"], "stream": ["draft", "time", "func", "view", "reader", "track", "image", "round", "pool", "feed", "channel", "ream", "document", "src", "model", "Stream", "object", "context", "rec", "draw", "path", "length", "wave", "unk", "client", "hook", "stage", "uc", "filter", "output", "form", "loop", "transform", "row", "sign", "valid", "writer", "source", "down", "input"], "dec_ctx": ["devalllc", "decalloc", "ec_loc", "decallcontext", "dec_cb", "decaccf", "decalctx", "decallcmp", "decacloc", "Dec_cb", "decacsrc", "del_cn", "Dec_ctx", "decalllc", "ec_cmp", "decaccu", "decjqa", "loc_cu", "delLcn", "decjcb", "decalcas", "devallloc", "decPctx", " dec_loc", "delLcus", "dec__loc", "dec_cca", "dec1cn", "decPscope", "dev_anc", "decaccas", "loc_hw", "decallcas", " dec_context", "dev_cf", "decjproc", "decjscope", "decaccontext", "ec_hw", "devallctx", "decpcontext", "ec_tx", "dec__gal", "Dec_loc", "decallsrc", "dec_cf", "dec_gal", "ec_gal", " dec_sync", "dec1ctx", " dec_ci", "dec_src", "dev_loc", "decpctx", "loc_loc", " dec_cu", "dec__canon", "decscontext", " dec_fc", "del_ctx", "decallcf", "dec_vc", "ec_sys", "devacctx", "decLanc", "dec_cu", " dec_qa", "devacanc", "decjcontext", "decLcca", "dec__ctx", "decPcb", "dec_cas", "dec1lc", "dec_anc", "dec_scope", " dec_proc", "decalsci", "decLctx", "ec_lc", " dec_sci", "decLfact", "ec_ctx", "dec1cca", "decingsync", "decLcus", " dec_cmp", "devalltx", "decjctx", "dec_canon", " dec_tx", "dec_sci", "dec_ci", "decallfc", "dec_proc", "dec1cus", "dec1loc", "decacanc", "decallanc", "dev_src", "dec_voc", "decallctx", "dec_cus", "decacfc", "decalltx", "dec_cmp", "decLcn", "dec_fc", "decPcontext", "dec_sync", "decpproc", "del_cca", "dec_lc", "delLctx", "dec_cn", "Dec_context", "decingloc", "decsctx", "dev_tx", "decLsrc", "ec_canon", " dec_voc", "dec_fact", "Dec_scope", "decpqa", " dec_cas", "decacctx", " dec_fact", "devaccf", "decingcu", "Dec_rec", "decLcontext", "dec_context", "dec_sys", "loc_ctx", " dec_vc", "dec1sys", "ec_context", "dec_qa", "decallloc", "decLloc", "dev_ctx", "delLcca", "dec_hw", "dec_conn", "dec_tx", "decallrec", "del_cus", "dec_loc", "decingctx", "dev_lc", " dec_conn", "decLcf", "devacsrc", "decsloc", "dec_rec", "decstx", "Dec_tx", "decacsync"], "val_str": ["valxlen", "val_len", "valingSTR", "str_len", "strxset", "valpStr", "str_exec", "val_STR", "val64str", "val_exec", "val_text", "str_str", " val_STR", "val24seq", "val_seq", "val64STR", "val_set", "val2text", "eval_name", " val_tr", "strxlen", "valxstr", "val_tr", "strxexec", "strxstr", "val_string", "val2Str", "valingarr", "valptext", "eval_string", "valxstring", "val24name", " val_arr", "val24exec", " val_Str", "val2arr", "val24len", "val_Str", "val64tr", "valpstr", "valingtr", "valxname", "val24str", "eval_seq", "valparr", "val64arr", "valingstr", "val_arr", " val_text", "val_name", "str_set", "valxexec", "eval_str", "val24string", "val2str", "valxset", "val24set", "valxseq"], "tag": ["mod", "code", "category", "comment", "reg", "year", "block", "match", "type", "pos", "count", "date", "Tag", "enc", "val", "format", "length", "key", "id", "ag", "TAG", "cat", "doc", "cache", "col", "row", "attr"], "display_aspect_ratio": ["display_aspect_ratios", "display_aspect_ratior", "display_aspect_radios", "display_aspect_Ratio", "display_aspect_rad0", "display_aspect_rat0", "display_aspectingbasiod", "display_aspect_tagior", "display_aspect_ratelo", "display_aspect_basatio", "display_aspect_accios", "display_aspect_tagi", "display_aspect_statlo", "display_aspect_latiod", "display_aspect_Rat0", "display_aspect_reportatio", "display_aspect_reportiod", "display_aspect_ratogram", "display_aspectingratiod", "display_aspect_acc0", "display_aspect_Rati", "display_aspect_latio", "display_aspectingratios", "display_aspect_atio", "display_aspectingbasios", "display_aspect_dimio", "display_aspect_basiod", "display_aspect_Ratios", "display_aspect_rotlo", "display_aspect_rotio", "display_aspect_rateogram", "display_aspect_dimi", "display_aspect_accio", "display_aspect_ratric", "display_aspect_ratlo", "display_aspect_ratatio", "display_aspectingbasatio", "display_aspect_dimior", "display_aspect_dimric", "display_aspect_accii", "display_aspect_radio", "display_aspect_rateios", "display_aspect_tagio", "display_aspect_dimios", "display_aspect_ratiod", "display_aspect_rati", "display_aspect_Ratial", "display_aspect_statios", "display_aspect_statogram", "display_aspect_dimial", "display_aspect_rotios", "display_aspect_ratii", "display_aspect_Ratior", "display_aspect_latios", "display_aspect_basio", "display_aspectingratio", "display_aspect_Ratric", "display_aspect_latatio", "display_aspectingbasio", "display_aspect_atial", "display_aspect_reportio", "display_aspect_reportios", "display_aspect_statio", "display_aspect_rotogram", "display_aspect_Ratii", "display_aspect_atios", "display_aspect_ratial", "display_aspect_basios", "display_aspectingratatio", "display_aspect_radii", "display_aspect_tagric", "display_aspect_rateio"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int usb_device_delete_addr(int busnr, int addr)\n\n{\n\n    USBBus *bus;\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n\n\n    bus = usb_bus_find(busnr);\n\n    if (!bus)\n\n        return -1;\n\n\n\n    TAILQ_FOREACH(port, &bus->used, next) {\n\n        if (port->dev->addr == addr)\n\n            break;\n\n    }\n\n    if (!port)\n\n        return -1;\n\n\n\n    dev = port->dev;\n\n    TAILQ_REMOVE(&bus->used, port, next);\n\n    bus->nused--;\n\n\n\n    usb_attach(port, NULL);\n\n    dev->info->handle_destroy(dev);\n\n\n\n    TAILQ_INSERT_TAIL(&bus->free, port, next);\n\n    bus->nfree++;\n\n    return 0;\n\n}\n", "idx": 1121, "substitutes": {"busnr": ["usbnl", "bridgenl", "bridgenor", "bootnr", "usbnor", "pluginnb", "pluginsn", "bootnb", "bridgern", "usbnr", "busnor", "portnb", "booteno", " busnor", " busrn", "bussn", "bridgenr", "busnl", "usbrn", "busrn", "portnr", "pluginnr", "plugineno", " busnl", "bootsn", "porteno", "buseno", "portsn", "busnb"], "addr": ["oa", "route", "dr", "layer", "name", "src", "att", "lan", "offset", "ext", "inter", "dd", "conn", "alias", "host", "sid", "rr", "loc", "ad", "add", "id", "ord", "adr", "pos", "code", "nr", "aid", "address", "ange", "pad", "ip", "ptr", "hop", "len", "ref", "attr", "arm", "ar", "eth", "wd", "amp", "nm", "prefix", "amd", "at", "rx", "uri", "rt", "mode", "vr", "ace", "rc"], "bus": ["pl", "base", "mount", "service", "lock", "this", "http", "ass", "bit", "device", "Bus", "host", "class", "ver", "use", "cat", "BUS", "ash", "bc", "bin", "parent", "boot", "loop", "pos", "ac", "proc", "plug", "pod", "nt", "bug", "sync", "config", "bas", "feed", "home", "block", "p", "book", "us", "self", "band", "pu", "front", "cache", "vc", "lib", "bridge", "b", "plugin", "os", "session", "bs", "usb", "lab", "root", "io", "se", "board", "db", "pack"], "port": ["ort", "test", "mount", "service", "target", "device", "host", "class", "tag", "ver", "type", "prop", "id", "parent", "op", "api", "pre", "next", "po", "component", "proxy", "Port", "pipe", "proc", "forward", "pod", "project", "bug", "ports", "pid", "pool", "config", "pointer", "post", "address", "step", "ip", "trans", "p", "pr", "pad", "hop", "per", "patch", "contract", "object", "fat", "wd", "art", "driver", "pc", "point", "cp", "PORT", "t", "plugin", "option", "path", "pro", "pt", "part", "export", "pp", "user"], "dev": ["fo", "flow", "test", "adv", "name", "cam", "def", "dd", "conn", "device", "mod", "host", "mem", "data", "desc", "ver", "ad", "di", "d", "prop", "av", "priv", "der", "dom", "Dev", "DEV", "ve", "info", "bug", "md", "ch", "pub", "gu", "p", "w", "prom", "pu", "ref", "app", "conf", " info", "own", "cache", " device", "wd", "driver", "v", "comment", "ev", "rad", "inst", "var", "od", "error", "pro", "dist", "debug", "diff", "fi", "user"], "nused": ["snusage", "snusable", "nactive", "nusable", "snused", "Nused", "nusage", "Nusage", " nusable", " nusage", " nactive", "Nactive", "Nusable", "snactive"], "nfree": ["nbavailable", "nbfree", "pavailable", " nFree", "nFree", "nusable", "nbFree", "navailable", "pFree", " nusable", "nbusable", "pfree", " navailable", "pusable"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom,\n\n                               Error **errp)\n\n{\n\n    int size;\n\n    char *path;\n\n    void *ptr;\n\n    char name[32];\n\n    const VMStateDescription *vmsd;\n\n\n\n    if (!pdev->romfile)\n\n        return;\n\n    if (strlen(pdev->romfile) == 0)\n\n        return;\n\n\n\n    if (!pdev->rom_bar) {\n\n        /*\n\n         * Load rom via fw_cfg instead of creating a rom bar,\n\n         * for 0.11 compatibility.\n\n         */\n\n        int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE);\n\n\n\n        /*\n\n         * Hot-plugged devices can't use the option ROM\n\n         * if the rom bar is disabled.\n\n         */\n\n        if (DEVICE(pdev)->hotplugged) {\n\n            error_setg(errp, \"Hot-plugged device without ROM bar\"\n\n                       \" can't have an option ROM\");\n\n            return;\n\n        }\n\n\n\n        if (class == 0x0300) {\n\n            rom_add_vga(pdev->romfile);\n\n        } else {\n\n            rom_add_option(pdev->romfile, -1);\n\n        }\n\n        return;\n\n    }\n\n\n\n    path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);\n\n    if (path == NULL) {\n\n        path = g_strdup(pdev->romfile);\n\n    }\n\n\n\n    size = get_image_size(path);\n\n    if (size < 0) {\n\n        error_setg(errp, \"failed to find romfile \\\"%s\\\"\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    } else if (size == 0) {\n\n        error_setg(errp, \"romfile \\\"%s\\\" is empty\", pdev->romfile);\n\n        g_free(path);\n\n        return;\n\n    }\n\n    size = pow2ceil(size);\n\n\n\n    vmsd = qdev_get_vmsd(DEVICE(pdev));\n\n\n\n    if (vmsd) {\n\n        snprintf(name, sizeof(name), \"%s.rom\", vmsd->name);\n\n    } else {\n\n        snprintf(name, sizeof(name), \"%s.rom\", object_get_typename(OBJECT(pdev)));\n\n    }\n\n    pdev->has_rom = true;\n\n    memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort);\n\n    vmstate_register_ram(&pdev->rom, &pdev->qdev);\n\n    ptr = memory_region_get_ram_ptr(&pdev->rom);\n\n    load_image(path, ptr);\n\n    g_free(path);\n\n\n\n    if (is_default_rom) {\n\n        /* Only the default rom images will be patched (if needed). */\n\n        pci_patch_ids(pdev, ptr, size);\n\n    }\n\n\n\n    pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom);\n\n}\n", "idx": 3602, "substitutes": {"pdev": ["opdevice", "fdef", "jev", "sprad", "nvar", "pdebug", "qdebug", "ppdevice", "Peng", "nde", "pdef", "Pdevice", "pdevice", "lpdc", "cpdev", "copdevice", "prad", "nprad", "fdd", "prcam", "fdevice", "prev", " pdevice", "qver", "copdev", "ndevelopment", "ndef", " pvalid", "vserv", "ndiv", "pconn", "ipdevice", "npdebug", "spdebug", "nDEV", " pdf", "pde", "ppdevelopment", "prvalid", "lpdebug", "qdev", " pcam", "vrad", "cev", " pconf", "Pver", "qconf", "ppdc", "opdef", "ipdiv", "lprav", "lpvar", "fde", " pdiv", "ppdi", "lpengine", "ceng", "preconn", "prdef", "pwd", "qdef", "vdebug", "preev", "Pdevelopment", "lpdev", "cdc", " pdebug", "cpdevice", "cpdef", "updev", "opdev", "pedev", "ppvar", "updiv", "pcdevice", "fdev", "peng", "fdiv", "pcdiv", "ndc", "jde", "Pev", "cdiv", "cengine", "ndd", "vdev", "cdef", "pcam", "prediv", "prdevice", "pedebug", "prwd", "opdiv", "Pdev", "ppdev", "tdevice", "pconf", "copdevelopment", "ndevice", "jdev", "preng", "Pdiv", "ndi", "ppdiv", "prdf", "pengine", " pde", "prede", " pev", "lpdevice", "prevar", "pevar", "pcvar", "uprav", "spdev", "pprad", "ppserv", "cpdiv", "pDEV", "qdevice", "ndev", "pvalid", "ccam", "npdev", "perad", " pwd", "pcengine", "ipvar", "cdev", "pcdevelopment", "tdiv", " pdef", "pdd", "pcdc", "nver", "Pdef", "lpdd", "pcdev", "npvar", "ppdef", "cdevice", "prdiv", "prdev", "tdev", "pserv", "spserv", "predevice", "cde", "nrav", " pvar", "lpdiv", "jconn", "pdevelopment", "ipdev", "pdi", "prav", "copdi", "lprad", "pev", "upDEV", "lpdef", "qde", "pver", "tdf", "pdiv", "pvar", "pdc", "ppdebug", "predevelopment", "pdf", "lpDEV", "cconf", "lpwd", "lpvalid", " pconn", "predev"], "is_default_rom": ["is_default2rom", "is_no_mode", "is_default2chrom", "is_default_mode", "is_default_chrom", "is_no2mode", "is_no2rom", "is_no2chrom", "is_default2ram", "is_no_ram", "is_no2ram", "is_no_rom", "is_default2mode", "is_default_ram", "is_no_chrom"], "errp": [" errd", "yrp", "errP", "serpr", "serlp", "serwp", "Erp", "finderr", "finderb", "errc", "ererpr", "erb", "yrpr", "errpe", "yrlp", " errpe", "iterp", "errfp", "erd", "rrc", " errr", "errd", "Errorpa", "ererp", "iterfp", "ferpa", "errb", "serp", "rrpa", "err", "Erfp", " errP", "ErP", "ferpi", "ferc", "errr", "ererwp", "ererlp", "rrp", "finderd", "Errorp", "errpi", "finderp", "erp", "Errorpi", " errb", "iterpe", "iterP", "ferp", "errpr", "errlp", "Errorc", "Erpe", " errfp", "yrwp", "errpa", "rrpi", "errwp"], "size": ["capacity", "any", "large", "go", "mini", "n", "weight", "empty", "handle", "g", "code", "storage", "address", "x", "Size", "en", "sum", "fee", "unit", "time", "sized", "security", "form", "ui", "type", "sh", "ny", "p", "e", "length", "core", "sn", "scale", "iz", "count", "SIZE", "crop", "esc", "small", "speed", "loc", "page", "use", "member", "year", "i", "body", "function", "c", "len", "cache", "value", "sec", "mode", "shape", "si", "ize", "class", " sizes", "now", "sync", "number", "style", "range", "full", "ice"], "path": ["route", "call", "test", "trace", "ctx", "time", "key", "anc", "alias", "context", "method", "url", "image", "binary", "folder", "loc", "type", "prop", "id", "parent", "enc", "po", "inner", "code", "Path", "file", "box", "sync", "bug", "slice", "source", "entry", "temp", "pointer", "config", "dir", "raw", "home", "PATH", "content", "progress", "work", "p", "c", "index", "resource", "length", "ref", "loader", "text", "cache", "child", "ath", "cmd", "node", "connection", "sign", "clean", "uri", "location", "full", "link", "root", "part", "shape", "rh", "desc", "user"], "ptr": ["dr", "ig", "mount", "fd", "src", "buffer", "trace", "offset", "ext", "ctx", "tty", "loc", "bc", "scope", "grad", "buf", "lr", "adr", "pos", "rb", "args", "pointers", "err", "slice", "str", "pointer", "address", "len", "ref", "attr", "br", "exec", "alloc", "inst", "addr", "val", "pt", "que", "fi", "rc", "port"], "name": ["key", "large", "url", "n", "client", "code", "file", "address", "x", "dev", "self", "child", "ame", "comment", "start", "option", "port", "time", " names", "anc", "host", "filename", "image", "type", "id", "parent", "end", "pass", "package", "create", "resource", "mask", "val", " NAME", "title", "base", "version", "a", "data", "small", "new", "global", "member", "space", "info", "names", "str", "Name", "len", "cap", "cache", "value", "node", "connection", "prefix", "error", "list", "shape", "mem", "call", "null", "no", "alias", "memory", "num", "pos", "none", "number", "word", "block", "w", "nm", "full", "nice", "part", "NAME", "desc"], "vmsd": ["lmsdn", "mamsn", "vMsl", "vamsl", "vmsds", "lmsb", "vmesd", "viasdn", "lmesds", "varsdh", "vomsn", "vcsb", "lmesd", "mamshd", "lmsds", "vumsp", "vumssd", "vMsd", "vvsd", " vmsp", "vamshd", "lmesb", "vmsdn", "vmsp", "vMShd", " vmsds", "mmsd", "vamsd", "mmsn", "vmsdt", "lmesdn", " vrsds", "vmesdn", "vmsb", "vumsd", "vrsd", "vvssd", "vmsl", "vmesb", "viasds", " vumsp", "vrsds", "vMSl", "varsdt", " vmsdt", "vmshd", "varsds", "viasd", "vMSd", "vmesdt", " vrsd", "mamsd", "mmshd", "mamsl", "vvsn", "vomsd", "vumsn", "vomsp", " vumssd", "varsd", "vcsds", "vcsd", " vrsdh", "vrsdt", " vrsdt", "lmsd", "vMSn", "vamsn", "vcsdn", " vumsn", "vvsp", "vMsn", " vmsdh", "vMshd", "mmsl", "vmsdh", "vrsdh", "vmesdh", " vmssd", "vmesds", " vumsd", "viasb", "vmssd", " vmsn", "vmsn", "vomssd"]}}
{"project": "qemu", "commit_id": "e23a1b33b53d25510320b26d9f154e19c6c99725", "target": 1, "func": "static void slavio_misc_init(target_phys_addr_t base,\n\n                             target_phys_addr_t aux1_base,\n\n                             target_phys_addr_t aux2_base, qemu_irq irq,\n\n                             qemu_irq fdc_tc)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"slavio_misc\");\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    if (base) {\n\n        /* 8 bit registers */\n\n        /* Slavio control */\n\n        sysbus_mmio_map(s, 0, base + MISC_CFG);\n\n        /* Diagnostics */\n\n        sysbus_mmio_map(s, 1, base + MISC_DIAG);\n\n        /* Modem control */\n\n        sysbus_mmio_map(s, 2, base + MISC_MDM);\n\n        /* 16 bit registers */\n\n        /* ss600mp diag LEDs */\n\n        sysbus_mmio_map(s, 3, base + MISC_LEDS);\n\n        /* 32 bit registers */\n\n        /* System control */\n\n        sysbus_mmio_map(s, 4, base + MISC_SYS);\n\n    }\n\n    if (aux1_base) {\n\n        /* AUX 1 (Misc System Functions) */\n\n        sysbus_mmio_map(s, 5, aux1_base);\n\n    }\n\n    if (aux2_base) {\n\n        /* AUX 2 (Software Powerdown Control) */\n\n        sysbus_mmio_map(s, 6, aux2_base);\n\n    }\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_connect_irq(s, 1, fdc_tc);\n\n    qemu_system_powerdown = qdev_get_gpio_in(dev, 0);\n\n}\n", "idx": 26090, "substitutes": {"base": ["build", "chain", "server", "name", "buffer", "sync", "valid", "kit", "bi", "model", "part", "f", "year", "core", "big", "area", "gap", "b", "p", "se", "address", "real", "prefix", "store", "boot", "key", "pse", "resource", "common", "binary", "cache", "stable", "root", "normal", "file", "temp", "family", "bare", "ached", "ada", "db", "ase", "cli", "Base", "client", "bot", "absolute", "fake", "proxy", "source", "null", "full", "post", "bas", "api", "bf", "type", "plus", "id", "unit", "reverse", "home", "site", "basic", "zero", "os", "local", "scale", "as", "active", "slave", "ip", "out", "ace"], "aux1_base": ["aux2_last", "auxn_full", "aux1__stable", "aux1_based", "aux2_stable", "aux2_bas", "aux1_b", "aux1__base", "aux2_b", "aux1_full", "aux1__bas", "aux1__site", "aux1__b", "auxn_base", "aux1_bas", "auxn_bas", "aux1_last", "aux2_site", "aux2_based", "aux1__based", "aux1_stable", "auxn_site", "aux1__last", "aux1_site"], "aux2_base": ["aux2_last", "aux1_core", "aux2_bas", "aux2_core", "aux1_cache", "aux2_cycle", "aux1_cycle", "aux1_bas", "aux2_cache", "aux1_last", "aux62_build", "aux62_full", "aux62_last", "aux2_full", "aux62_base", "aux2_build"], "irq": ["iwk", "irque", "irach", " irk", "iraq", "iwqu", "idch", "iraQ", "iwq", "arqs", "iraqs", "irk", "idqs", "irch", "arQ", "irqu", "iwque", "idQ", "irqs", "idq", "arq", "irQ", "irik", " irque", "iriqu", " irqu", "irique", "iriq", "arch"], "fdc_tc": ["fdc2mc", "fdc2tg", "fdc_tg", "fdac_TC", "fdc2tm", "fdac_tc", "fdc2tc", "fdc_tm", "fdc_TC", "fdac_tm", "fdac_tg", "fdc_mc", "fdc2TC", "fdac_mc"], "dev": ["ve", "temp", "md", "gu", "user", "w", "driver", "dc", "info", "p", "engine", "der", "d", "data", "conf", "diff", "bug", "error", "def", "DEV", "state", "ev", "ch", "priv", "serial", "bus", "prom", "self", "dd", "db", "dem", "hw", "grad", " device", "err", "spec", "di", "mode", "req", "block", "device", "mod", "development", "pro", "conn", "de", "Dev", "rad", "v", "ver", "result", "cam", "dn", "g"], "s": ["sys", "w", "server", "ns", "ts", "sites", "sq", "states", "sync", "self", "u", "es", "gs", "south", "http", "sym", "sa", "f", "fs", "js", "n", "status", "service", "t", "tests", "r", "ops", "native", "S", "sk", "k", "p", "b", "m", "c", "se", "x", "ds", "us", "su", "is", "spec", "new", "services", "h", "sl", "settings", "its", "sh", "g", "ses", "d", "sg", "rows", "uses", "e", "session", "sb", "full", "ssl", "i", "site", "o", "si", "os", "device", "sup", "as", "a", "an", "v", "ui", "l"]}}
{"project": "qemu", "commit_id": "0a982b1bf3953dc8640c4d6e619fb1132ebbebc3", "target": 0, "func": "static void test_qga_file_write_read(gconstpointer fix)\n\n{\n\n    const TestFixture *fixture = fix;\n\n    const unsigned char helloworld[] = \"Hello World!\\n\";\n\n    const char *b64;\n\n    gchar *cmd, *enc;\n\n    QDict *ret, *val;\n\n    int64_t id, eof;\n\n    gsize count;\n\n\n\n    /* open */\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-file-open',\"\n\n                 \" 'arguments': { 'path': 'foo', 'mode': 'w+' } }\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    id = qdict_get_int(ret, \"return\");\n\n    QDECREF(ret);\n\n\n\n    enc = g_base64_encode(helloworld, sizeof(helloworld));\n\n    /* write */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-write',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \",\"\n\n                          \" 'buf-b64': '%s' } }\", id, enc);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert_cmpint(eof, ==, 0);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read (check implicit flush) */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, \"\");\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* seek to 0 */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-seek',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \", \"\n\n                          \" 'offset': %d, 'whence': %d } }\",\n\n                          id, 0, SEEK_SET);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    qmp_assert_no_error(ret);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"position\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(!eof);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, enc);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n    g_free(enc);\n\n\n\n    /* close */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-close',\"\n\n                          \" 'arguments': {'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n}\n", "idx": 19469, "substitutes": {"fix": ["pattern", "fixes", "init", "data", "conf", "f", "call", "ix", "FIX", "fe", "apply", "make", "Fix", "fc", "def", "setup", "host", "fx", "class", "format", "diff", "new", "pre", "bf", "prefix", "config", "q", " format", "update", "post", "patch", " prefix", "mix", " Fix", "test", "field", "bug"], "fixture": ["froster", "pactory", "dixtures", "dendor", "hactory", "dixture", "ditness", "taint", "hixture", "mixture", "frundle", "fitter", "tendor", "goster", "pixture", "tixture", "gixture", "foster", "titter", "mault", "frault", "daint", "dactory", "hitness", "moster", "fixtures", "dlict", " fixtures", "fendor", " fitter", "fundle", "fitness", "Flict", "gault", "factory", "pestival", "hestival", "Fitness", " faint", "faint", "Fixture", " fitness", "flict", " fendor", "gundle", "mundle", "ditter", "fault", "frixture", "festival", "pitness", " flict", "destival", "Fixtures"], "helloworld": ["hellowsellow", "hellowsworld", "hellowww", "hemowedworld", "clowworld", " hellowarden", "hellowork", "helleworld", "hemowedird", "hellowedird", "hellowingird", "hellowedorld", "hemowellow", "hellowarden", " hellowingarden", "helloyworld", "helloyellow", "kelewella", "kelowww", "hemoworld", "cloyworld", "cloworld", "helloyird", "hellowellow", "hemowird", "helloyorld", "clowellow", "hellowworld", "hellework", " hellowingorld", "hellowingella", " hellowellow", "hellowingellow", "hellewww", "hellowella", "kelewww", " hellowird", "cloyorld", " hellowingird", "hellewella", "kelowork", "hellowsird", " hellowingellow", "keleworld", "hellowsorld", "hellowedarden", "hellowedworld", "kelework", "clowork", "hemowedorld", "hellowedork", "hellowird", "helloyork", "hellowedellow", "hellowingww", "hellowingworld", "hellowsarden", "hellowedella", "keloworld", "hemowedellow", "hellowingarden", "hellowingorld", "kelowella", "cloyork", "cloyellow", "hellowingork", "hellowedww", "hemowworld"], "b64": ["f24", "b62", "base64", "f64", "p64", "eb64", "B64", "b63", "b128", "eb63", "eb65", "base24", "coll", " b58", "baseoll", " b256", "wb65", "wb64", " b62", "f58", "p128", "wb128", "c62", "p63", " b24", "B256", "c256", "base58", " boll", "B62", "boll", "foll", "c64", "b256", "b24", "p65", "wb63", "b58", "eb128", "Boll", "b65"], "cmd": ["grad", "cfg", "child", "gd", "md", "cf", "anc", "cod", "path", "config", "prefix", "cli", "qq", "ck", "gen", "win", "valid", "command", "pt", "cc", "conn", "input", "init", "vc", "fun", "clean", "msg", "arg", "force", "cat", "dom", "parent", "gz", "mac", "dict", "code", "contin", "cookie", "err", "call", "window", "cb", "root", "auth", "help", "ctrl", "crit", "std", "back", "rn", "buf", "cd", "ux", "cn", "bug", "session", "func", "mode", "g", "module", "method", "shell", "ctx", "def", "pkg", "Cmd", "img", "bot", "client", "cl", "req", "seq", "ll", "url", "custom"], "enc": ["Enc", "sg", "ch", "code", "rc", "vec", "inc", "ENC", "exc", "sl", "auth", "anc", "loc", "msg", "ext", "acl", "env", "en", "alg", "encrypted", "eng", "oder", "exec", "wk", "empty", "nc", "iq", "ac", "feat", "img", "emb", "c", "seq", "lib", "binary", "uc", "col", "win", "ec", "eval", "lang", "mac", "el", "conn", "len"], "ret": ["grad", "br", "obj", "al", "ref", "bit", "nt", "ann", "result", "job", "var", "run", "att", "feat", "fit", "rev", "repl", "res", "opt", "valid", "pt", "conn", "part", "fun", "vals", "fin", "resp", "arg", "arr", "art", "flat", "Ret", "bf", "cat", "gt", "RET", "pet", "ft", "dict", "status", "expr", "base", "alt", "lit", "r", "rt", "rel", "des", "final", "re", "back", "buf", "rl", "del", "detail", "reply", "success", "session", "db", "data", "let", "reg", "pass", "ext", "def", "rets", "en", "ber", "img", "response", "det", "dr", "seq", "ll", "url", "eval", "el"], "val": ["Val", "part", "stat", "data", "al", "base", "ref", "x", "alt", "all", "lit", "reg", "fun", "rt", "rel", "vals", "sl", "var", "loc", "sel", "pos", "ind", "VAL", "vert", "arg", "vol", "fl", "bo", "pre", "pal", "cel", "ol", "il", "serv", "bl", "rev", "v", "elt", "unit", "rl", "seq", "lib", "repl", "b", "pr", "col", "la", "bel", "ul", "eval", "res", "aval", "valid", "bal", "el", "value", "pt", "cond", "len"], "id": ["Id", "ify", "grad", "init", "pid", "code", "data", "info", "af", "bit", "name", "ID", "f", "x", "base", "ref", "ape", "md", "aid", "nt", "rid", "num", "i", "root", "type", "ide", "idy", "z", "ie", "in", "kid", "max", "ind", "bid", "ip", "uid", "d", "iq", "oid", "ac", "ident", "mid", "q", "ad", "start", "fd", "cat", "parent", "seq", "ick", "url", "doc", "p", "ids", "gen", "sid", "win", "ension", "cd", "h", "end", "valid", "it", "one", "bug"], "eof": ["neok", "eeOF", "Eout", " eoc", "seOf", "zeop", "eeOf", "eop", "seof", "zeout", "seOF", " eok", "Eop", "aeof", "geOF", "eok", "eOF", "geif", "aeif", "Eoff", "nof", "Eos", "nos", "neOf", "Eiff", "aeOF", "aeoff", "nOF", " eiff", " eout", " eop", "eeof", "Eoc", "Eof", "eout", "nOf", "zeof", "zeiff", "eoff", "neoc", "neos", "peof", "eos", "neof", "geoff", "peok", "Eif", "EOf", "eOf", "peOf", " eOf", "seos", "geof", "eif", " eos", "peos", "eoc", "eeos", "eiff"], "count": ["part", "stat", "ch", "code", "time", "child", "base", "f", "err", "ct", "call", "nt", "inc", "coll", "type", "max", "loc", "Count", "in", "ind", "act", "label", "cond", "l", "keep", "found", "size", "ac", "add", "length", "q", "limit", "gl", "cat", "c", "parent", "catch", "seq", "p", "cache", "b", "sum", "col", "depth", "check", "level", "number", "weight", "cast", "list", "cc", "len"]}}
{"project": "qemu", "commit_id": "167351020420c285b67cdf0603501b3d3b15e3f7", "target": 1, "func": "static int jazz_led_init(SysBusDevice *dev)\n\n{\n\n    LedState *s = FROM_SYSBUS(LedState, dev);\n\n\n\n    memory_region_init_io(&s->iomem, &led_ops, s, \"led\", 1);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    s->ds = graphic_console_init(jazz_led_update_display,\n\n                                 jazz_led_invalidate_display,\n\n                                 jazz_led_screen_dump,\n\n                                 jazz_led_text_update, s);\n\n\n\n    return 0;\n\n}\n", "idx": 26443, "substitutes": {"dev": ["ve", "md", "gu", " Dev", "w", "driver", "fo", "p", "Device", "app", "d", "data", "ad", "debug", "def", "priv", "DEV", "dd", "ev", "ch", "die", "serial", "dom", "self", "prom", "tr", "dem", "hw", "phy", "home", "grad", " device", "gd", "di", "device", "mod", "development", "conn", "dm", "de", "Dev", "rad", "od", "ver", "sd", "devices", "cam"], "s": ["S", "rs", "ses", "sys", "args", "w", "ss", "p", "m", "i", "c", "server", "b", "ns", "d", "se", "ts", "storage", "sq", "ds", "us", "ps", "sg", "sync", "self", "su", "is", "u", "e", "es", "south", "gs", "o", "session", "spec", "l", "sv", "si", "os", "uns", "sb", "services", "ls", "f", "service", "js", "n", "t", "sd", "v", "sl", "r", "settings", "ops", "ssl", "cs", "g"]}}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "static bool do_modify_softint(CPUSPARCState *env, uint32_t value)\n\n{\n\n    if (env->softint != value) {\n\n        env->softint = value;\n\n#if !defined(CONFIG_USER_ONLY)\n\n        if (cpu_interrupts_enabled(env)) {\n\n\n            cpu_check_irqs(env);\n\n\n        }\n\n#endif\n\n        return true;\n\n    }\n\n    return false;\n\n}", "idx": 5174, "substitutes": {"env": ["enable", "ah", "fg", "eng", "er", "nw", "ea", "cur", "dat", "scope", "config", "esp", "environment", "exc", "style", "enc", "eu", "buf", "db", "cal", "export", "ext", "server", "obj", "args", "py", "init", "forest", "conf", "ev", "np", "code", "e", "img", "ass", "en", "here", "esc", "estate", "err", "context", "ec", "stage", "settings", "opt", "req", "viron", "txt", "core", "cv", "site", "cache", "age", "forge", "conn", "end", "dict"], "value": ["address", "option", "name", "paid", "v", "complete", "values", "config", "update", "val", "data", "format", "image", "status", "null", "window", "num", "valid", "key", "version", "enabled", "number", "code", "property", "target", "message", "port", "timeout", "result", "Value", "scale", "start", "VALUE", "none", "attribute", "new", "type", "current", "index", "age", "set", "max", "expression", "end", "size"]}}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 1335, "substitutes": {"job": ["flow", "base", "server", "lock", "service", "build", "queue", "process", "image", "jobs", "section", "worker", "pb", "j", "sync", "project", "bug", "cb", "pool", "config", "status", "feed", "result", "block", "work", "child", "jp", "object", "exec", "node", "connection", "seq", "b", "plugin", "manager", "Job", "run", "db"], "speed": ["cost", "level", "service", "capacity", "mass", "time", "rate", "spec", "slow", "grade", "effect", "image", "gain", "high", "race", "weight", "scroll", "sk", "duration", "peed", "seed", "score", "slice", "settings", "source", "strike", "status", "mph", "step", "rank", "skill", "size", "length", "set", "power", "powered", "scale", "fee", "strength", "error", "sort", "stop", "sex", "Speed", "limit", "performance", "port"], "errp": ["errP", "erc", "rrfp", "erP", "errc", "errpe", "errfp", " errpe", "iterp", "rrP", "erf", "rrc", " errr", "err", " errP", "iterr", "errr", "erpe", "erp", " errc", "iterf", "iterpe", " errf", " errfp", "errf", "erfp", "rrp"], "s": ["sg", "submit", "js", "service", "sup", "ss", "spec", "sb", "r", "is", "sp", "sl", "sh", "ssh", "g", "m", "ses", "ls", "sf", "ds", "ps", "gs", "ns", "c", "p", "services", "e", "f", "secondary", "sq", "u", "o", "v", "b", "S", "session", "hs", "se", "si", "sym"]}}
{"project": "qemu", "commit_id": "e976c6a1e40ad74d616a186d3b48b0ad8f5eb970", "target": 1, "func": "static void qcow_aio_write_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    const uint8_t *src_buf;\n\n    int n_end;\n\n\n\n    acb->hd_aiocb = NULL;\n\n\n\n    if (ret < 0) {\n\n    fail:\n\n        acb->common.cb(acb->common.opaque, ret);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->nb_sectors -= acb->n;\n\n    acb->sector_num += acb->n;\n\n    acb->buf += acb->n * 512;\n\n\n\n    if (acb->nb_sectors == 0) {\n\n        /* request completed */\n\n        acb->common.cb(acb->common.opaque, 0);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n    n_end = index_in_cluster + acb->nb_sectors;\n\n    if (s->crypt_method &&\n\n        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)\n\n        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n\n\n    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,\n\n                                          index_in_cluster,\n\n                                          n_end, &acb->n);\n\n    if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    if (s->crypt_method) {\n\n        if (!acb->cluster_data) {\n\n            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                             s->cluster_size);\n\n            if (!acb->cluster_data) {\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n        }\n\n        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,\n\n                        acb->n, 1, &s->aes_encrypt_key);\n\n        src_buf = acb->cluster_data;\n\n    } else {\n\n        src_buf = acb->buf;\n\n    }\n\n    acb->hd_aiocb = bdrv_aio_write(s->hd,\n\n                                   (cluster_offset >> 9) + index_in_cluster,\n\n                                   src_buf, acb->n,\n\n                                   qcow_aio_write_cb, acb);\n\n    if (acb->hd_aiocb == NULL)\n\n        goto fail;\n\n}\n", "idx": 7916, "substitutes": {"opaque": ["opbuffer", "uppaques", "opacle", "compaco", "uppaque", "pya", "oppac", "compaque", "Opga", "ipaco", "opya", "obec", "splane", "iopaques", "ipsaque", "oaque", "iopec", "obaque", " opga", "Opaque", "ipsec", "iopca", "uppacle", "operaques", "oppaca", "opga", "spac", "pacity", "oppaque", "operaque", "Opya", "compbuffer", "obuffer", "oacity", "opac", "ipaque", "pga", "opplane", "ipsaques", "opec", "spaque", "Opacity", " opacle", " opacity", "opaco", "spaca", " opya", "uppacity", "oaco", "opaques", "paque", "operacle", "operacity", "ipacity", "opaca", "ipsca", "ipbuffer", " oplane", "opacity", "oplane", "obca", "opca", "obaques", " opaques", "iopaque", " opac", "compacity", " opaca"], "ret": ["gc", "red", "reg", "mem", "rt", "alt", "hard", "nt", "pat", "get", "rot", "val", "final", "rc", "bit", "cat", "let", "reply", "valid", " RET", "num", " Ret", "lit", "job", "att", "prot", "arg", "res", "match", "def", "len", "mt", "part", "det", "RET", "sat", "feat", "nil", "result", "seq", "Ret", "ft", "ut", "re", "fun", "back", "gt", "desc", "ref", "success", "no", "rets"], "acb": ["accbase", "aclemb", "macfb", "accgb", "ACba", "acemb", "acllb", "ACbot", "acfb", "icbb", "macsb", " acbb", "acway", "accbr", "ocfb", " acrb", "agbb", "ecbb", "iclb", "macmb", "acl", "icbf", "aclbase", "macf", "accrb", "acxb", "aclob", "acB", "aca", "ackbd", "ecmb", "acsb", "akf", " acfb", "agbf", "ecbd", "acgb", "acssb", " acbar", " acbase", "acbr", "akba", "icl", "ocb", "ucfb", "ocbase", "ecsb", "Acba", "ocl", "aclxb", "ucbb", "akfb", "ocob", "aclb", "aclbc", "aclbf", "agl", "ACl", "acbb", "icb", "acll", "acclb", "ucb", "ancxb", "axbb", "acbase", "aclf", "aksb", "acbf", " acsb", "agf", "maclb", "ancbot", "accB", "acbd", " acwb", "akemb", "akb", "ACbb", " aca", "AcB", "accbar", "ocbb", "acsbot", "acbc", "ecbr", "macbd", "acwb", "acba", "acbar", "akbr", "macb", "acbot", "akgb", "Acb", "ocba", "akrb", "acob", "ecb", "ecwb", "ACsb", "macway", "icf", "ecgb", "axb", "acf", "ocxb", "accbf", "akbb", "ancob", "ucf", "axf", "icbc", "aclfb", "aclrb", " acl", "accb", "ecf", "akl", "acrb", "accl", "acurl", "aclbb", "accfb", "ocf", "ocway", "ackmb", "ecl", "ocsb", "acca", "accbb", "accwb", "ackb", "ancb", "ecrb", "ecfb", "icurl", "macbb", "accba", "aclway", "ancbb", " aclb", " acgb", "accsb", "accf", "acsbb", "ACB", "maca", "agbc", "acmb", " acf", "ucbf", "ancsb", "ackfb", "aclurl", "Acsb", " acurl", "axbar", "agbase", "ucgb", "ACb", "ecbf", "accemb", "agb"], "bs": ["abc", "bas", "base", "as", "lb", "platform", "bits", "rb", "b", "ob", "bm", "sys", "ses", "bi", "BS", "obs", "fb", "db", "buf", "wb", "bes", "ns", "ls", "iss", "bb", "cs", "ss", "bal", "eb", "las", "sb", "ops", "bis", "ds", "bytes", "bc", "cb", "ab", "ubs", "ba", "Bs", "ec", "blocks", "acks", "gb", "fs", "os", "bos", "bid", "bo", "bl", "pb", "aos", "account", "cas", "bh"], "s": ["sub", "stat", "o", "sets", "sf", "v", "is", "S", "a", "http", "spec", "sg", "session", "b", "si", "sync", "i", "sys", "ses", "services", "m", "details", "states", "l", "f", "parts", "ns", "state", "stats", "sl", "ls", "args", "d", "service", "cs", "ss", "server", "e", "sc", "sb", "gs", "secondary", "bis", "ds", "t", "n", "full", "ts", "multi", "self", "p", "settings", "blocks", "sa", "c", "new", "g", "ssl", "sym", "os", "sq", "params", "rs", "r", "ps", "js"], "index_in_cluster": ["index_in_blusters", "index_in_scuster", "index_in_chuster", "index_in_CLorer", "index_in_scusters", "index_in_cedrome", "index_in_Clica", "index_in_cedusters", "index_in_blosion", "index_in_clrome", "index_in_choser", "index_in_scorer", "index_in_closion", "index_in_sclusters", "index_in_scluster", "index_in_explosion", "index_in_scloser", "index_in_CLuster", "index_in_clorer", "index_in_Cluster", "index_in_clusters", "index_in_Clusters", "index_in_closer", "index_in_explusters", "index_in_Clorer", "index_in_ceduster", "index_in_bloser", "index_in_sclica", "index_in_Closer", "index_in_CLusters", "index_in_Closion", "index_in_clica", "index_in_exploser", "index_in_Clrome", "index_in_CLrome", "index_in_expluster", "index_in_bluster", "index_in_chica", "index_in_chusters"], "cluster_offset": ["clusterfend", "clusters_len", "cluster2data", "clisk_size", "clusterfoffset", "clusterFsize", "clusters_location", "cliskFset", "clusters_num", "clacofoffset", "cluster_limit", "cliskFoffset", "cluster_location", "claco_data", "clust_limit", "clacofend", "clisk_width", "clust2limit", "claco_end", "cluster\u00b7len", "clust2data", "cluster_rot", "clusterFset", "clusterFwidth", "cluster_position", "cluster\u00b7num", "claco_rot", "clust_data", "clusterfdata", "clust_offset", "cliskFsize", "clacofrot", "cluster_end", "cluster_len", "clisk_set", "cluster_num", "clusters_offset", "cluster_set", "cluster2offset", "cluster\u00b7offset", "clisk_offset", "clust_position", "clust2offset", "cluster_width", "clusterfrot", "cluster\u00b7location", "clust2position", "clusterFoffset", "cluster2limit", "cluster2position", "cluster_data", "clacofdata", "cluster_size", "claco_offset", "cliskFwidth"], "src_buf": [" src_mem", "src2mem", " src_buffer", "src2buffer", "src_mem", "src2buf", "src_buffer", "src_buff", "src2buff", " src_buff"], "n_end": [" n_ends", "n_END", "num_start", "n67open", "nJenter", "n64start", "rn_ended", "n__ended", "n64post", "n_ended", "n00open", "nworkend", "n_dev", "nJset", "num00enter", "num_END", " n_dev", "rn__start", "n_ends", "num_set", " n_END", "nJend", "n_enter", "n00END", "n64ended", " n_open", "num00set", "n00set", "rn_start", "numworkended", "n67start", "n00enter", "nworkended", "numworkend", "n00ending", "rn__end", "n00end", "n64end", "n_open", "rn__ended", "n67end", "num_post", " n_ending", "num00end", "rn_end", "num00END", "numworkpost", "nworkpost", "n_start", "n__open", "n__start", "num_enter", "nJEND", "num_ended", "numworkstart", "rn__open", "n67ended", "nworkstart", "n__end", "n_ending", "num_end", "n_set", "rn_open", "n_post"]}}
{"project": "qemu", "commit_id": "052495178821fdc97b4125a8677c1b68eb458db9", "target": 0, "func": "static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp)\n\n{\n\n    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);\n\n    int ret;\n\n\n\n    if (nvram->blk) {\n\n        nvram->size = blk_getlength(nvram->blk);\n\n\n\n        ret = blk_set_perm(nvram->blk,\n\n                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,\n\n                           BLK_PERM_ALL, errp);\n\n        if (ret < 0) {\n\n            return;\n\n        }\n\n    } else {\n\n        nvram->size = DEFAULT_NVRAM_SIZE;\n\n    }\n\n\n\n    nvram->buf = g_malloc0(nvram->size);\n\n\n\n    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {\n\n        error_setg(errp, \"spapr-nvram must be between %d and %d bytes in size\",\n\n                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);\n\n        return;\n\n    }\n\n\n\n    if (nvram->blk) {\n\n        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);\n\n\n\n        if (alen != nvram->size) {\n\n            error_setg(errp, \"can't read spapr-nvram contents\");\n\n            return;\n\n        }\n\n    } else if (nb_prom_envs > 0) {\n\n        /* Create a system partition to pass the -prom-env variables */\n\n        chrp_nvram_create_system_partition(nvram->buf, MIN_NVRAM_SIZE / 4);\n\n        chrp_nvram_create_free_partition(&nvram->buf[MIN_NVRAM_SIZE / 4],\n\n                                         nvram->size - MIN_NVRAM_SIZE / 4);\n\n    }\n\n\n\n    spapr_rtas_register(RTAS_NVRAM_FETCH, \"nvram-fetch\", rtas_nvram_fetch);\n\n    spapr_rtas_register(RTAS_NVRAM_STORE, \"nvram-store\", rtas_nvram_store);\n\n}\n", "idx": 11642, "substitutes": {"dev": ["conf", "gu", "gd", "cam", "img", "tr", "dom", "prof", "Dev", "def", "conn", "w", "prom", "phy", "dem", "mem", "ver", "fw", "serv", "data", "obj", "app", "plug", "rad", "serial", "ev", "device", "md", "req", "mod", "dm", "grad", "self", "proc", "DEV"], "errp": ["erp", "erb", " errP", "nerp", "erg", "errg", "nerP", " errsp", "errcp", "corsp", "corr", "erc", "errorp", " errc", "errsp", "nercp", "errorb", "errorg", "errP", " errb", "nerr", "erP", " errg", "err", "ercp", " errfp", "Erp", "erfp", "errc", "corfp", " errcp", "Erc", "errb", "ErP", "corp", "ersp", " errr", "Err", "errr", "errfp", "errorr"], "nvram": ["nwlam", "lovgram", "ncgam", "cvscan", "nlgram", "navlam", "nwdim", "lovcamp", "nvam", "cvram", "vcdim", "naviam", "ovgram", "nvran", "nwam", "vvram", "novmem", "lviam", "vvapp", "nvcamp", "cvmem", "vvcam", "ncram", "sviam", "lvam", "vvrom", "cvcom", "svcam", "nvirm", "svscan", "lovram", "nmgam", "vvvm", "ncgram", "advram", "vvirm", "nwram", "svtm", "vvgram", "cvcamp", "svirm", "nvream", "advgram", "nwvm", "nvlam", "novcam", "NVrom", "svgam", "vvgam", "cvcam", "ovcam", "novlam", "nvtm", "vvlam", "vciam", "navgam", "nwran", "nwtm", "ncdim", "nwream", "svgram", "navcamp", "novram", "ovapp", "nwgram", "NVram", "nvvm", "navcam", "vvtm", "svam", "vcmem", "nvrom", "nllam", "nmgram", "novam", "navrom", "nvdim", "nwcom", "lvgam", "nvcom", "navmem", "nmiam", "navscan", "advran", "nwpass", "ncmem", "svmem", "ovram", "novgram", "nvgram", "cvgram", "vcran", "lvream", "nlmem", "lvram", "nmpass", "advmem", "nvapp", "svram", "nmlam", "nlcam", "nvcam", "nvscan", "nviam", "cvvm", "nccam", "nvgam", "nwmem", "vvcom", "navram", "vcgram", "nlram", "NVgram", "NVapp", "navgram", "nwirm", "nwgam", "lovcam", "vcram", "vcgam", "lvgram", "vvpass", "svream", "nwiam", "nwcam", "novran", "nmram", "nvmem", "nvpass", "navapp", "nlran"], "ret": ["rf", "arr", "pass", "alt", "val", "len", "af", "def", "nt", "Ret", "t", "x", "pat", "red", "ct", "ref", "arg", "lit", "obj", "reg", "pt", "rets", "f", "rt", "res", "det", "rc", "fun", "att", "art", "ur", "fin", "cat", "re", "RET", "back", "result", "mt", "ft", "sr", "feat", "success", "pet"]}}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_sws_init_swScale_mmx(SwsContext *c)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_INLINE_ASM\n\n    if (cpu_flags & AV_CPU_FLAG_MMX)\n\n        sws_init_swScale_MMX(c);\n\n#if HAVE_MMXEXT_INLINE\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT)\n\n        sws_init_swScale_MMX2(c);\n\n#endif\n\n#endif /* HAVE_INLINE_ASM */\n\n\n\n#if HAVE_YASM\n\n#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \\\n\n    if (c->srcBpc == 8) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 9) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 10) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \\\n\n    } else /* c->srcBpc == 16 */ { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \\\n\n    } \\\n\n} while (0)\n\n#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \\\n\n    }\n\n#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \\\n\nswitch(c->dstBpc){ \\\n\n    case 16:                          do_16_case;                          break; \\\n\n    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \\\n\n    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \\\n\n    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \\\n\n    }\n\n#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \\\n\n    switch(c->dstBpc){ \\\n\n    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \\\n\n    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \\\n\n    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \\\n\n    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \\\n\n    }\n\n#define case_rgb(x, X, opt) \\\n\n        case PIX_FMT_ ## X: \\\n\n            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \\\n\n            if (!c->chrSrcHSubSample) \\\n\n                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \\\n\n            break\n\n#if ARCH_X86_32\n\n    if (cpu_flags & AV_CPU_FLAG_MMX) {\n\n        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);\n\n        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_mmx;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            c->chrToYV12 = ff_yuyvToUV_mmx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_mmx;\n\n            c->chrToYV12 = ff_uyvyToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_mmx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, mmx);\n\n        case_rgb(bgr24, BGR24, mmx);\n\n        case_rgb(bgra,  BGRA,  mmx);\n\n        case_rgb(rgba,  RGBA,  mmx);\n\n        case_rgb(abgr,  ABGR,  mmx);\n\n        case_rgb(argb,  ARGB,  mmx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1);\n\n    }\n\n#endif /* ARCH_X86_32 */\n\n#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \\\n\n             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \\\n\n             break; \\\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE2) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_sse2;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            c->chrToYV12 = ff_yuyvToUV_sse2;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_sse2;\n\n            c->chrToYV12 = ff_uyvyToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_sse2;\n\n            break;\n\n        case_rgb(rgb24, RGB24, sse2);\n\n        case_rgb(bgr24, BGR24, sse2);\n\n        case_rgb(bgra,  BGRA,  sse2);\n\n        case_rgb(rgba,  RGBA,  sse2);\n\n        case_rgb(abgr,  ABGR,  sse2);\n\n        case_rgb(argb,  ARGB,  sse2);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSSE3) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);\n\n        switch (c->srcFormat) {\n\n        case_rgb(rgb24, RGB24, ssse3);\n\n        case_rgb(bgr24, BGR24, ssse3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE4) {\n\n        /* Xto15 don't need special sse4 functions */\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,\n\n                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        if (c->dstBpc == 16 && !isBE(c->dstFormat))\n\n            c->yuv2plane1 = ff_yuv2plane1_16_sse4;\n\n    }\n\n\n\n    if (cpu_flags & AV_CPU_FLAG_AVX) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_YUYV422:\n\n            c->chrToYV12 = ff_yuyvToUV_avx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->chrToYV12 = ff_uyvyToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_avx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, avx);\n\n        case_rgb(bgr24, BGR24, avx);\n\n        case_rgb(bgra,  BGRA,  avx);\n\n        case_rgb(rgba,  RGBA,  avx);\n\n        case_rgb(abgr,  ABGR,  avx);\n\n        case_rgb(argb,  ARGB,  avx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 3153, "substitutes": {"c": ["cm", "cs", "ctx", "cc", "mc", "context", "ct", "nc", "bc", "cur", "con", "k", "ac", "m", "coll", "cr", "ch", "C", "ec", "dc", "ce", "cu", "p", "l", "cv", "e", "lc", "f", "u", "center", "vc", "pc", "s", "v", "b", "t", "cf", "ci", "uc", "rc"]}}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "void wm8750_set_bclk_in(void *opaque, int hz)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n\n\n    s->ext_adc_hz = hz;\n\n    s->ext_dac_hz = hz;\n\n    wm8750_clk_update(s, 1);\n\n}\n", "idx": 20471, "substitutes": {"opaque": ["oacity", "opaques", "oaque", "ospacity", "octaque", "Opesc", " opesc", "octacity", " opaques", "octaques", "oifice", "opesc", "Opacity", "ospaques", "opacity", " opacity", "oaques", "Opaque", "Opaques", "ospaque", "octifice", "opifice", " opifice", "ospesc"], "hz": ["az", "delay", "icity", "scale", "loop", "xxx", "eth", "height", "GHz", "wave", "hello", "kHz", "fps", "MHz", "size", "fee", "kh", "phy", "bass", "rh", "abc", "depth", "dy", "sync", "Hz", "cb", "density", "cpu", "hash", "length", "len", "cz", "z", "conf", "hw", "frequency", "clock", "tz", "broad", "ss", "hh", "padding", "count"], "s": ["sb", "i", "native", "e", "ruby", "sym", "es", "sl", "fs", "g", "ses", "an", "features", "d", "sets", "plugins", "ops", "services", "f", "t", "r", "u", "m", "socket", "ssl", "new", "p", "ts", "o", "sync", "is", "ss", "c", "js", "opens", "spec", "submit", "settings", "a", "b", "n", "S", "ns", "session", "south", "v", "secondary", "l", "sq", "padding"]}}
{"project": "FFmpeg", "commit_id": "2f86e7bd12d8023da3349f10490b1e5b64531e23", "target": 1, "func": "static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,\n\n                         const char *filt_name, const char *args, AVClass *log_ctx)\n\n{\n\n    AVFilter *filt;\n\n    char inst_name[30];\n\n    char tmp_args[256];\n\n    int ret;\n\n\n\n    snprintf(inst_name, sizeof(inst_name), \"Parsed filter %d %s\", index, filt_name);\n\n\n\n    filt = avfilter_get_by_name(filt_name);\n\n\n\n    if (!filt) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"No such filter: '%s'\\n\", filt_name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ret = avfilter_open(filt_ctx, filt, inst_name);\n\n    if (!*filt_ctx) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error creating filter '%s'\\n\", filt_name);\n\n        return ret;\n\n    }\n\n\n\n    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {\n\n        avfilter_free(*filt_ctx);\n\n        return ret;\n\n    }\n\n\n\n    if (!strcmp(filt_name, \"scale\") && !strstr(args, \"flags\")) {\n\n        snprintf(tmp_args, sizeof(tmp_args), \"%s:%s\",\n\n                 args, ctx->scale_sws_opts);\n\n        args = tmp_args;\n\n    }\n\n\n\n    if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error initializing filter '%s' with args '%s'\\n\", filt_name, args);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3721, "substitutes": {"filt_ctx": ["fill_c", "filt_ca", "fil_conn", "filt_voc", "fil_voc", "filt___voc", "filt___ctx", "filt___context", "fil_scope", "flt_ctx", "fill_ctx", "flt_loc", "filt_context", "filt_conn", "fil_cmd", "filt_lc", "filt_scope", "flt_cp", "fill_context", "filt_c", "flt_conn", "flt_lc", "flt_context", "filt___ca", "fil_ca", "filt_cs", "fil_context", "fill_ca", "filt_cp", "filt_loc", "fil_ctx", "fil_cs", "filt_cmd"], "ctx": ["fc", "cm", "cli", "cam", "src", "cs", "conn", "context", "cc", "cpp", "Context", "loc", "ck", "bc", "graph", "scope", "tc", "concept", "client", "cas", "comp", "tx", "cb", "config", "crit", "pkg", "cu", "c", "cv", "xc", "lc", "cn", "sc", "ctrl", "ca", "exec", "cmd", "obj", "pc", "cca", "connection", "qa", "cp", "cmp", "cf", "conv", "support", "ci", "cfg", "rc"], "index": ["match", "Index", "base", "name", "offset", "find", "active", "context", "current", "image", "column", "loc", "type", "id", "fff", "end", "num", "search", "instance", "pos", "info", "slice", "config", "x", "ind", "example", "len", "length", "ref", "f", "col", "size", "connection", "prefix", "depth", "addr", "part", "inc", "input"], "filt_name": ["flt_Name", "fil_name", "filtPName", "factory_NAME", "filtacNAME", "filtacnames", "filt_names", "filt__NAME", "filt_value", "filt__type", "fillFvalue", "filtPname", "fillFName", "factory_name", "filt__name", "filt_block", "filtFname", "factoryactype", "factoryacname", "filtactype", "filt_id", "flt_name", "filtFName", "fil_names", "filt_NAME", "ffilter_name", "factoryacNAME", "fill_value", "factory_type", "filtPpath", "factory_names", "filtFvalue", "flt_id", "filt__names", "fill_Name", "filt_Name", "flt_node", "ffilter_Name", "filt__Name", "ffilter_path", "factoryacnames", "filt_path", "filt_node", "fill_name", "fillFname", "filtacname", "filt_type", "ffilter_block", "fil_Name", "filtPblock"], "args": ["limits", "files", "arg", "missing", "ig", "name", "ics", "alls", "groups", "works", "null", "ass", "extra", "spec", "array", "actions", "acl", "vals", "data", "ips", "flags", "strings", "results", "help", "empty", "objects", "includes", "links", "arr", "enc", "options", "ids", "comments", "params", "bits", "body", "ars", "resources", "names", "cards", "ras", "config", "ams", "gs", "str", "result", "example", "p", "items", "afi", "values", "atts", "lines", "size", "cache", "alloc", "fields", "blocks", " arguments", "qa", "ay", "Args", "bytes", "changes", "ages", "init", "parts", "allows"], "log_ctx": ["log_cn", "logwcb", "log_ca", "logalcn", "failpcf", "log_fn", "logpctx", "log_sys", "logerctx", "logpfn", "fail_fn", "tagercb", "logpcn", "failpcn", "tagersys", "logencci", "logboardctx", "log_scope", "logervc", "fail_ctx", "tag_cb", "logingvc", "log_vc", "Log_ctx", "tagerctx", "logwvc", "lock_cci", "tag_ctx", "logenscope", "logenctx", "logercb", "logalctx", "Log_context", "logboardcontext", "lock_scope", "lock_ca", "failpctx", "log_cf", "logwctx", "logingcb", "logboardjc", "logingctx", "tag_vc", "logwsys", "logersys", "log_sc", "logalcf", "tagervc", "Log_jc", "logboardsc", "lock_ctx", "logalfn", "logpcf", "fail_cn", "log_cci", "log_cb", "failpfn", "logenca", "tag_sys", "Log_sc", "fail_cf", "logingsys", "log_context", "log_jc"], "filt": ["infizzle", "Filt", "sfizzle", "flld", "bil", "dfil", " fld", "inffilter", "filler", " facet", "firt", "flt", "Flt", "dfld", "biller", "infilt", "sflt", "sfld", "sfilt", "fil", "Facet", " fil", "bilt", "dfiller", "dfilt", "sffilter", "infld", " filler", "bld", "sfacet", "infirt", "fizzle", " flt", "fld", "facet", "ffilter", "Fizzle", "flizzle", "flilt", " ffilter", " fizzle", " firt", "flirt"], "inst_name": ["instacdata", "inst__span", "inst__id", "instameName", "Inst_data", "inst_conn", "inst_id", "inst_Name", "instamename", "instameid", " inst_conn", "inst_data", "inst_prefix", "instance_info", "inst_names", " inst_span", "inst__name", "instamespan", "inst__Name", "Inst_names", "Inst_name", "instance_name", " inst_id", "instacnames", "inst_info", "inst_span", " inst_names", "instacname", "instance_names", "instance_prefix", " inst_Name"], "tmp_args": ["tmp_items", " tmp_arg", "tmp_ams", "temp_members", " tmp_parts", "tmp2args", "tmp_params", "tmp_arg", "tmp_options", "tmp_members", "temp_items", "temp_ams", " tmp_options", "temp_errors", "tmp2parts", "temp_arg", "tmp_errors", "temp_args", "tmp2arg", "tmp_parts", "tmp2caps", "tmp_caps", " tmp_params", " tmp_caps"], "ret": ["match", "base", "arg", "fun", "att", "mt", "ext", "utf", "def", "gc", "success", "data", "url", "r", "alt", "cur", "job", "pet", "rets", "grad", "arr", "num", "pass", "fail", "rb", "code", "info", "ft", "nt", "err", "str", "reply", "feat", "Ret", "back", "tr", "bad", "opt", "result", "bot", "ut", "f", "len", "flag", "ref", "red", "gt", "value", "obj", "RET", "valid", "al", "re", "run", "val", "reg", "rt", "part", "lit", "let", "det", "res", "debug", "db", "rc", "mem"]}}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *vc_init(const char *id, ChardevBackend *backend,\n\n                                ChardevReturn *ret, Error **errp)\n\n{\n\n    return vc_handler(backend->u.vc, errp);\n\n}\n", "idx": 2564, "substitutes": {"id": ["name", "q", "def", "sid", "data", "url", "class", "kind", "head", "oid", "ID", "parent", "ids", "Id", "mid", "info", "code", "rid", "pid", "ident", "ip", "kid", "ref", "uid", "uri", "path", "root", "db"], "backend": ["backen", "backender", "backended", "BACKend", "BACKender", "Backen", " backender", " backended", "BACKen", " backen", "Backended", "Backend", "BACKended", "frontended", "Backender", "frontender", "fronten", "frontend"], "ret": ["fun", "att", "def", "conn", "data", "rets", "auth", "proc", "reply", "Ret", "pub", "result", "ut", "fin", "red", "ref", "eth", "resp", "obj", "RET", "lit", "reg", "val", "det", "res", "mem"], "errp": ["errP", "erP", "acepo", " errpi", "acerP", "errfp", "erpo", " errP", "acefp", "errpi", "acerp", "erp", "acerpi", "aceP", " errfp", "erpi", "errpo", "acep", "acerfp", " errpo", "erfp"]}}
{"project": "FFmpeg", "commit_id": "bf238a6a3ca92de686e0e103135c1336f33f685b", "target": 1, "func": "static int hwupload_query_formats(AVFilterContext *avctx)\n\n{\n\n    HWUploadContext *ctx = avctx->priv;\n\n    AVHWFramesConstraints *constraints = NULL;\n\n    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;\n\n    AVFilterFormats *input_formats = NULL;\n\n    int err, i;\n\n\n\n    if (!avctx->hw_device_ctx) {\n\n        av_log(ctx, AV_LOG_ERROR, \"A hardware device reference is required \"\n\n               \"to upload frames to.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);\n\n    if (!ctx->hwdevice_ref)\n\n        return AVERROR(ENOMEM);\n\n    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;\n\n\n\n    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);\n\n    if (!constraints) {\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    input_pix_fmts  = constraints->valid_sw_formats;\n\n    output_pix_fmts = constraints->valid_hw_formats;\n\n\n\n    input_formats = ff_make_format_list(output_pix_fmts);\n\n    if (!input_formats) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if (input_pix_fmts) {\n\n        for (i = 0; input_pix_fmts[i] != AV_PIX_FMT_NONE; i++) {\n\n            err = ff_add_format(&input_formats, input_pix_fmts[i]);\n\n            if (err < 0) {\n\n                ff_formats_unref(&input_formats);\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_formats_ref(input_formats, &avctx->inputs[0]->out_formats);\n\n\n\n    ff_formats_ref(ff_make_format_list(output_pix_fmts),\n\n                   &avctx->outputs[0]->in_formats);\n\n\n\n    av_hwframe_constraints_free(&constraints);\n\n    return 0;\n\n\n\nfail:\n\n    av_buffer_unref(&ctx->hwdevice_ref);\n\n    av_hwframe_constraints_free(&constraints);\n\n    return err;\n\n}\n", "idx": 26173, "substitutes": {"avctx": ["navctl", "afctl", "AVcam", "akcv", "navcontext", "AVcmp", "AVconfig", "avecontext", "Avcmp", "avconsole", "evcontext", "avcmp", "afkb", "afcmp", "avcontext", "avkb", "avcam", "ajconn", "afcontext", "afctx", "aveconfig", "avconfig", "Avcam", "AVcb", "avectx", "avecv", "evctx", "avctl", "ajctx", "AVkb", "afcb", "avekb", "akcam", "evconn", "navcmp", "Avcontext", "Avcb", "ajconsole", "evconsole", "AVctx", "avconn", "akctx", "AVctl", "afconn", "avcv", "avecmp", "afconsole", "afcv", "akcontext", "avcb", "AVcv", "navctx", "Avcv", "AVcontext", "ajcontext", "Avctx", "afconfig"], "ctx": ["sc", "kw", "cm", "acl", "cca", "uc", "anc", "c", "pkg", "context", "cat", "cv", "qa", "xc", "sq", "config", "conf", "jp", "cus", "cb", "bc", "ce", "instance", "kb", "cmp", "aux", "hw", "cmd", "cms", "vc", "loc", "wcs", "fw", "cc", "ci", "cp", "cf", "mc", "cn", "client", "conv", "cas", "lc", "ctrl", "ca", "tc", "cu", "conn", "ck", "nc", "tx", "cs", "cam", "pc", "kt"], "constraints": ["constaints", "concomplaint", "conribants", "constrorts", "conretaints", "constr\n", "constants", "Conctruments", "Constaints", "oconformures", "conformappings", "constructributes", "Constraints", "contrants", "conntaint", "conctraints", "constrributes", "constritives", "concomplributes", "conforts", "confortappings", "converorts", "conformures", "unstrributes", "construments", "conretappings", "constriffs", "uncomplaints", "converaints", "conctraint", "conribiffs", "confortitives", "oconstrappings", "Constrants", "conformaints", "conformitives", "constaint", "oconformaints", "oconstritives", "conretures", "uncomplorts", "contraint", "constiffs", "converributes", "conntaints", "constructuments", "consts\n", "contruments", "Constructaints", "Constrributes", "contraints", "Conctraint", "Constiffs", "recsts\n", "concomplorts", "conntants", "Constructaint", "constructaints", "unstrorts", "uncomplributes", "conribaints", "conntiffs", "Constrorts", "Constructributes", "Construments", "constrappings", "oconformappings", "constructaint", "Constants", "conctrants", "confortaints", "confaint", "conribaint", "Constriffs", "oconformitives", "constrants", "Conctraints", "conStr\n", "oconstrures", "unstraints", "Conctrants", "conretitives", "conctruments", "confaints", "converuments", "confributes", "construres", "Constaint", "Constructorts", "Constraint", "concomplants", "uncompluments", "confortures", "recstr\n", "concomplaints", "unstruments", "concompluments", "oconstraints", "constructorts", "construct\n", "constraint"], "input_pix_fmts": ["input_pix_wmters", "input_pix_rmters", "input_pix_mts", "input_pix_wmaters", "input_pix_fmps", "input_pix_gmters", "input_pix_fcaters", "input_pix_dimts", "input_pix_fmTS", "input_pix_fcats", "input_pix_fmms", "input_pix_formts", "input_pix_formats", "input_pix_gmts", "input_pix_cmTS", "input_pix_fms", "input_pix_cmters", "input_pix_fts", "input_pix_rmts", "input_pix_fmt", "input_pix_mmats", "input_pix_fmaters", "input_pix_cmaters", "input_pix_dimps", "input_pix_fmters", "input_pix_mters", "input_pix_cmats", "input_pix_mats", "input_pix_gmt", "input_pix_gmats", "input_pix_fct", "input_pix_fats", "input_pix_cmt", "input_pix_dimats", "input_pix_fTS", "input_pix_mt", "input_pix_formps", "input_pix_formters", "input_pix_mmms", "input_pix_dimters", "input_pix_wmt", "input_pix_fcts", "input_pix_cmts", "input_pix_cmps", "input_pix_cmms", "input_pix_rmt", "input_pix_fmats", "input_pix_wmts", "input_pix_rmats", "input_pix_wmats", "input_pix_mmts", "input_pix_mmTS"], "output_pix_fmts": ["output_pix_umats", "output_pix_cmt", "output_pix_formTS", "output_pix_formters", "output_pix_mts", "output_pix_rmks", "output_pix2fmts", "output_pix2cmt", "output_pix_wmt", "output_pix2wmTS", "output_pix2wmats", "output_pix2cmats", "output_pix_umks", "output_pix_fmps", "output_pix_rmts", "output_pix_mps", "output_pix_cmtes", "output_pix_rmats", "output_pix_fmats", "output_pix_cmters", "output_pix2cmks", "output_pix_cmts", "output_pix2fmTS", "output_pix2fmt", "output_pix2wmts", "output_pix_wmters", "output_pix_wmTS", "output_pix_mters", "output_pix_wmats", "output_pix_umt", "output_pix_cmps", "output_pix2fmats", "output_pix_mtes", "output_pix_formts", "output_pix2fmks", "output_pix_formats", "output_pix_fps", "output_pix2wmters", "output_pix_mats", "output_pix_cmats", "output_pix_ftes", "output_pix_fmks", "output_pix_umts", "output_pix_fmters", "output_pix_fts", "output_pix_fats", "output_pix_fmt", "output_pix_rmt", "output_pix_fmtes", "output_pix_wmts", "output_pix_cmTS", "output_pix2cmts", "output_pix_cmks", "output_pix_fmTS", "output_pix_mt", "output_pix2fmters"], "input_formats": ["input_formsls", "input_transformolds", "input_feands", "input_formataps", "input_formutters", "input_facars", "input_formatatives", "input_formsutters", "input_factats", "input_factls", "input_formatars", "input_operATS", "input_factaters", "input_transformets", "input_feATS", "input_commaters", "input_formatations", "input_featter", "input_formsations", "input_formets", "input_formATS", "input_FORMations", "input_facats", "input_formolds", "input_formarts", "input_formars", "input_formaters", "input_FORMats", "input_formations", "input_factaps", "input_formsaters", "input_formaps", "input_formsatter", "input_formatands", "input_facets", "input_formatives", "input_formsaps", "input_commats", "input_formatter", "input_formsars", "input_formataters", "input_formsarts", "input_formsets", "input_operats", "input_FORMarts", "input_formatls", "input_formatats", "input_fears", "input_transformats", "input_formatATS", "input_operarts", "input_formatatter", "input_feats", "input_feutters", "input_facolds", "input_formatutters", "input_FORMATS", "input_commatives", "input_formsolds", "input_feations", "input_formands", "input_formsATS", "input_formls", "input_formsatives", "input_commaps", "input_transformars", "input_operations", "input_formsats", "input_formsands"], "err": ["yr", "code", "ner", "fe", "er", "sr", "rage", "res", "der", "usr", "msg", "dr", "doc", "rb", "var", "ise", "br", "cb", "type", "ler", "error", "gr", "mr", " Err", "bug", "fr", "num", "orig", "iter", "Error", "arr", "min", "str", "rh", "loc", "rar", "inner", "fi", " error", "ctr", "order", "cache", "kr", "req", "size", "ar", "ir", "count", "y", "nr", "pr", "n", "later", "resp", "init", "ver", "r", "attr", "rr", "result", "Er", "ind", "aster", "val", "g"], "i": ["abi", "z", "yi", "p", "m", "info", "c", "b", "ie", "ix", "x", "ti", "mi", "type", "phi", "qi", "ri", "id", "io", "ui", "u", "e", "li", "gi", "ji", "zi", "multi", "xi", "uri", "inner", "ini", "ii", "si", "bi", "di", "ni", "ai", "cli", "ci", "fi", "eni", "I", "f", "y", "oi", "chi", "j", "ip", "index", "t", "n", "iu", "ind", "r", "pi", "v", "mu"]}}
{"project": "qemu", "commit_id": "77eec1b3f1493ca4813eae2fbf8702d1ef58f147", "target": 0, "func": "static inline int open_by_handle(int mountfd, const char *fh, int flags)\n\n{\n\n    errno = ENOSYS;\n\n    return -1;\n\n}\n", "idx": 14842, "substitutes": {"mountfd": ["procfd", "procdb", "mountdb", "mountd", "devd", "devor", "procor", "_or", "_d", "_db", "mountor", "_fd", "devfd", "devdb", "procd"], "fh": [" fH", "sfH", "fdH", "fdhh", "fH", "fhh", "fdh", "fdhs", "sfhh", "sfh", " fhs", "fhs", "sfhs", " fhh"], "flags": ["types", "args", "FLAG", "fs", "name", "settings", "ants", "files", "s", "options", "data", "features", "mode", "mask", "magic", "bits", "Flags", "offset", "stats", "ags", "ents", "ops", "windows", "flag", "len", "ptr", "vals"]}}
{"project": "qemu", "commit_id": "0072d2a9fce4835ab2b9ee70aaca0169fb25fa0c", "target": 1, "func": "static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,\n\n                                    const uint8_t *key, size_t nkey,\n\n                                    Error **errp)\n\n{\n\n    uint8_t *salt;\n\n    size_t nhash;\n\n    size_t nsalt;\n\n    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);\n\n\n\n    /* Not necessarily the same as nkey */\n\n    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);\n\n\n\n    nhash = qcrypto_hash_digest_len(ivgen->hash);\n\n    /* Salt must be larger of hash size or key size */\n\n    salt = g_new0(uint8_t, MAX(nhash, nsalt));\n\n\n\n    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,\n\n                           &salt, &nhash,\n\n                           errp) < 0) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n    /* Now potentially truncate salt to match cipher key len */\n\n    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,\n\n                                       QCRYPTO_CIPHER_MODE_ECB,\n\n                                       salt, MIN(nhash, nsalt),\n\n                                       errp);\n\n    if (!essiv->cipher) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n\n    ivgen->private = essiv;\n\n\n\n    return 0;\n\n}", "idx": 17101, "substitutes": {"ivgen": ["ivneg", "ervgen", "avgen", " ivgener", "evneg", "ocrgen", " ivgeneration", "hrGen", "ervlif", "ivercon", "ivergeneration", "ocrGen", "avgener", "ihget", "ivergener", "vgen", "ervgener", "ihGen", "ivergen", "ocGen", "ivGen", "irgeneration", "ocrgeneration", "occon", "eccon", "ocgen", "evgener", "ihgin", "hrgin", "vgener", "ervGen", "hrget", "evgeneration", "ivlif", "ecGen", "ecgate", "vgeneration", "avgeneration", "ovneg", "evget", "ihgen", "ocrgener", "evgin", "evGen", "hrgen", "ivcon", "ivergate", "ovgener", "ovGen", "ervgeneration", "avGen", "vlif", "ivget", "evgen", "ivgener", "ivgin", " ivlif", "irgen", "ivgeneration", "irgener", "ecgen", "ervneg", "irGen", "iverGen", "ivgate", "ocgate", "ovgen"], "key": ["code", "data", "x", "base", "image", "name", "hash", "block", "type", "match", "password", "cert", "copy", "ip", "secret", "crypt", "pair", "change", "ce", "size", "seed", "wire", "id", "k", "v", "private", "temp", "address", "fee", "sum", "cache", "Key", "row", "sign", "connection", "message", "KEY", "value"], "nkey": ["Nmac", "nchash", "nhex", "nsmix", "nmac", "nskey", "nmix", "Nhex", " nmix", " nmac", "ncmac", "nshash", "nckey", " nhex", "Nkey", "Nmix", "Nhash", "nchex", "nsmac"], "errp": [" errfp", "acerp", "erfp", "dangerp", "acerb", "erpre", "arrpy", "dangerpre", " errc", "errc", "acerpre", "errpre", "acerfp", "erp", " errpy", " errb", " erp", "errr", "dangerpat", "errpat", " erpy", "errfp", "dangerpp", " errr", "errb", " erc", "errpy", " errpat", "eorpre", "arrc", "eorpat", "arrp", "eorpp", " err", "erb", "eorp", " errpp", "arrr", "errpp", " errpre"], "salt": ["watt", "sysalt", "wash", "ssash", "osatt", "walt", "pssecret", "sALT", "nsodium", "nsALT", "nssecret", "osash", "psass", "syssecret", "ssALT", "ssass", "nsass", "satt", " sass", "sash", " sodium", "osALT", "sodium", " ssecret", "sysodium", "sysALT", "sssecret", "sass", "osalt", "ssatt", "psalt", "ssalt", "psALT", "wALT", "ssecret", " sALT"], "nhash": ["cnhash", "rnhash", " nbuild", "rnh", "chex", "ch", "sbuild", "nih", "cnblock", " nblock", "neurl", "cnkey", "nchash", "nhex", "neh", "nhost", "nheader", "Nheader", "cnhex", "nsum", "rnsum", "noh", "ncsum", "nohost", "nch", " nurl", "nsh", "Nh", "nehash", "shost", "shash", "Nhex", "nohash", "nihash", "chash", " nh", "nblock", "sh", "nikey", "nobuild", "nshash", "nurl", "niurl", " nhost", "cheader", "nckey", " nsum", " nhex", "nh", "nsheader", "Nhash", "nekey", "nchex", "rnhex", "ncblock", "nshex", "nbuild"], "nsalt": ["gsert", " nsul", " nsort", "sort", "ainsert", "ssodium", "netshash", "sALT", "gsalt", "nsol", "nsodium", "ainsalt", "ainsodium", "namesol", "nsul", "nsALT", "nasALT", "nasalt", "netsalt", "namesALT", "nsert", "nsort", "sol", "ssALT", "nasort", "nsass", "ainshash", "safe", "NSodium", "ssafe", "nshash", " nsol", "sodium", "namesalt", "nsafe", "netsert", "nasul", "sass", " nsass", "ssalt", "gshash", "netsodium", "gsodium", "NSALT", " nsALT", "namesass", "sul", "NSafe", "NSalt"], "essiv": ["cessiver", "esseserv", "assivation", "esiv", "issiver", "essenc", "essesiver", "assiver", "esliv", "issiv", "hesserv", "ossiv", "asserv", "esivation", "esiver", "essesenc", "cessive", "cessenc", "essesort", "ossrc", "ossiver", "assiv", "esrc", "issliv", "esive", "cessiv", "essiver", "ossort", "ssort", "ssiver", "osserv", "lessiv", "cessient", "sserv", "essient", "cesserv", "eserv", "lessliv", "hessiver", "essesient", "essivation", "issivation", "essesive", "essesrc", "ssiv", "essesiv", "esenc", "lessivation", "hessivation", "ossivation", "esient", "essive", "hessiv", "essliv", "lessiver", "essrc", "essort", "esserv"]}}
{"project": "qemu", "commit_id": "049a9f7b946fe1d3ff97127f8905881dbb78cb00", "target": 1, "func": "static void i82378_init(DeviceState *dev, I82378State *s)\n\n{\n\n    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, \"isa.0\"));\n\n    ISADevice *pit;\n\n    qemu_irq *out0_irq;\n\n\n\n    /* This device has:\n\n       2 82C59 (irq)\n\n       1 82C54 (pit)\n\n       2 82C37 (dma)\n\n       NMI\n\n       Utility Bus Support Registers\n\n\n\n       All devices accept byte access only, except timer\n\n     */\n\n\n\n    qdev_init_gpio_out(dev, s->out, 2);\n\n    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);\n\n\n\n    /* Workaround the fact that i8259 is not qdev'ified... */\n\n    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);\n\n\n\n    /* 2 82C59 (irq) */\n\n    s->i8259 = i8259_init(isabus, *out0_irq);\n\n    isa_bus_irqs(isabus, s->i8259);\n\n\n\n    /* 1 82C54 (pit) */\n\n    pit = pit_init(isabus, 0x40, 0, NULL);\n\n\n\n    /* speaker */\n\n    pcspk_init(isabus, pit);\n\n\n\n    /* 2 82C37 (dma) */\n\n    DMA_init(1, &s->out[1]);\n\n    isa_create_simple(isabus, \"i82374\");\n\n\n\n    /* timer */\n\n    isa_create_simple(isabus, \"mc146818rtc\");\n\n}\n", "idx": 7732, "substitutes": {"dev": ["hw", "serv", "ch", "rad", "pro", "spec", "Dev", "device", "bug", "data", "info", "dem", "der", "bus", "de", "f", "d", "ve", "mod", "conf", "ev", "def", "dom", "des", "priv", "w", "prom", "cam", "die", "ds", "dc", "self", "p", "serial", "req", "ver", "g", "gd", "app", "grad", "conn"], "s": ["o", "sf", "v", "is", "S", "spec", "sg", "session", "b", "si", "i", "sync", "sys", "ses", "services", "in", "its", "l", "f", "parts", "ns", "state", "server", "d", "sl", "ls", "stats", "service", "init", "ss", "cs", "u", "conf", "args", "e", "sc", "w", "gs", "sb", "out", "bis", "t", "ds", "n", "sd", "su", "p", "south", "settings", "sv", "fs", "sa", "c", "os", "g", "ssl", "sq", "rs", "r", "ps", "js"], "isabus": ["itabs", "isacs", "issab", "servalis", "areacs", "Isabi", "risabi", "itsibus", "iabi", "ialog", "areabs", "isiab", "idabo", "issabus", "risabo", "isiabi", "areibus", "misabs", "isabo", "itsacs", "hopabi", "issalis", "hopabo", "lisabal", "Isabs", "risabs", "issalog", "issabi", " isabs", "itsabs", "misabus", "lisalog", "risabus", "Isab", "areabus", "servab", "iabus", "isabi", "isubs", "misabi", " isibus", "lisabi", " isabi", "Isabus", "isabal", " isab", " isalis", "idubs", "iabal", "issabal", "hopubs", "isibus", "isabs", "isiabus", "idabi", "idabus", "misab", "isiabs", "itsabus", "itabus", " isacs", "itab", "isalog", "risubs", "isalis", "isab", "servabi", "servabus", "hopabus", "lisabus", "risab", "itabi"], "pit": ["pot", "plugin", "kit", "serv", "bp", "rt", "pai", "piece", "sit", "pin", "pa", "qt", "bt", "val", "itty", "sn", "itter", "lp", "pt", "its", "lit", "at", "sil", "prot", "pet", "sl", "pc", "it", "net", "np", "sb", "nit", "bis", "t", "sat", "fit", "nat", "bot", "bc", "jp", "kat", "p", "ut", "bet", "sp", "sa", "cit", "ct", "pl", "cot"], "out0_irq": ["out0_pirqs", "out0_mirquest", "out0_irp", "out0_irQ", "out0_mirQ", "out0_IRp", "out0_ireq", "out0_ireqs", "out0_IRquest", "out0_ironQ", "out0_ironq", "out0_irquest", "out0_iraqs", "out0_mirq", "out0_irqq", "out0_pirq", "out0_iraQ", "out0_iraqq", "out0_pirQ", "out0_mirqq", "out0_ironqs", "out0_IRQ", "out0_IRqs", "out0_mirp", "out0_ironquest", "out0_pirqq", "out0_irep", "out0_IRq", "out0_ireQ", "out0_mirqs", "out0_irqs", "out0_iraq"]}}
{"project": "qemu", "commit_id": "9c5ce8db2e5c2769ed2fd3d91928dd1853b5ce7c", "target": 0, "func": "UuidInfo *qmp_query_uuid(Error **errp)\n\n{\n\n    UuidInfo *info = g_malloc0(sizeof(*info));\n\n    char uuid[64];\n\n\n\n    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],\n\n                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],\n\n                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],\n\n                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],\n\n                   qemu_uuid[14], qemu_uuid[15]);\n\n\n\n    info->UUID = g_strdup(uuid);\n\n    return info;\n\n}\n", "idx": 8866, "substitutes": {"errp": ["erf", "erp", "errps", "gramps", "excps", "erps", "erb", "gramf", "excb", "errb", "excf", "errf", "gramb", "gramp", "excp"], "info": ["alias", "conf", "up", "it", "fo", "start", "si", "Info", "comment", "source", "in", "def", "id", "http", "bar", "update", "i", "data", "config", "a", "INFO", "obj", "before", "feed", "value", "txt", "bug", "q", "op", "f", "tf", "py", "index", "parse", "hand", "opt", "name", "order", "gi", "end", "inner", "check", "error", "now", "type", "back", "report", "ignore", "api", "extra", "options", "cache", "inf", "result", "image", "url", "ret", "help", "fi", "success"], "uuid": ["UUID", "ruID", "iqider", "buip", "uccuid", "uuide", "iqid", "cuid", "buID", "uid", "uuip", "UUid", "duq", "duide", "ruid", "buq", "ouid", "buuid", "buider", "ouids", "iqids", "iqID", "uip", "duid", "buids", "UUuid", "buide", "runame", "cuuid", "ouider", "guide", "uccid", "uuider", "guq", "UUname", "uuida", "cuip", "buid", "uuids", "guida", "uccID", "ruuid", "uuID", "guid", "uuname", "duida", "uuuid", "uccname", "uuq", "ouID", "buida"]}}
{"project": "qemu", "commit_id": "40c4ed3f95f0b2ffa0848df0fc311556bb7472a1", "target": 1, "func": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set */\n\n    if (!(s->status & DRQ_STAT))\n\n        return;\n\n\n\n    p = s->data_ptr;\n\n    *(uint16_t *)p = le16_to_cpu(val);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n}\n", "idx": 6775, "substitutes": {"opaque": ["defaques", "oppaques", "opque", "defaque", "oppace", "operaques", "ipaques", "oppaque", "ipque", "operac", "operaque", "ipace", "opac", "hopace", "ipaque", "osaques", "defac", "hopaque", "hopque", "osac", "opaques", "opace", "oppque", "hopaques", "osaque"], "addr": ["address", "dr", "host", "reg", "device", "nc", "data", "ad", "ace", "tx", "offset", "add", "pc", "arg", "part", "len", "arr", "port", "pad", "seq", "pos", "pointer", "alloc", "ip", "ac", "ref", "src", "prefix"], "val": ["stat", "base", "address", "pid", "ret", "reg", "v", "al", "block", "mem", "alt", "el", "value", "pre", "x", "data", "b", "slice", "Val", "pt", "valid", "vals", "f", "VAL", "sl", "pc", "arg", "def", "buffer", "len", "all", "arr", "pal", "eval", "pos", "bl", "ref", "cache", "slot"], "bus": ["plugin", "o", "feed", "block", "hub", "local", "http", "BUS", "config", "plug", "io", "sync", "cat", "Bus", "drive", "usb", "loop", "us", "service", "mount", "driver", "lib", "pass", "bc", "lock", "bridge", "boot", "proc", "os", "c", "board", "cache", "host", "hole"], "s": ["as", "r", "o", "sf", "v", "ins", "is", "S", "less", "spec", "scope", "b", "si", "i", "sync", "sys", "ses", "services", "m", "states", "l", "xs", "f", "parts", "ns", "state", "d", "ls", "sl", "stats", "args", "service", "us", "ss", "cs", "u", "hs", "bs", "e", "space", "w", "gs", "ks", "se", "ops", "t", "ds", "n", "ts", "su", "self", "settings", "fs", "c", "os", "g", "ssl", "sym", "params", "es", "rs", "ps", "js"], "p": ["cp", "P", "pid", "o", "bp", "v", "pr", "pu", "pa", "pat", "pre", "po", "pp", "data", "i", "b", "x", "pe", "lp", "ap", "m", "l", "f", "pi", "at", "j", "d", "pc", "py", "q", "u", "np", "e", "point", "dp", "per", "t", "n", "fp", "ptr", "sp", "pointer", "c", "ip", "y", "api", "tp", "pl", "pb", "ps"]}}
{"project": "qemu", "commit_id": "80fb34eda099e7cc519a91e9701ab3c0262717b3", "target": 1, "func": "bool qio_task_propagate_error(QIOTask *task,\n\n                              Error **errp)\n\n{\n\n    if (task->err) {\n\n        error_propagate(errp, task->err);\n\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}", "idx": 8111, "substitutes": {"task": ["patch", "game", "master", "pack", "clean", "complete", "parent", "device", "scope", "config", "kick", "object", "module", "tty", "asks", "tag", "tx", "resource", "event", "project", "content", "call", "ack", "target", "item", "error", "message", "instance", "empty", "ask", "exec", "process", "result", "theme", "work", "load", "source", "this", "tile", "level", "rule", "slave", "contract", "type", "thread", "Task", "test", "app", "command", "worker"], "errp": ["errvp", "rp", " errvp", "erP", "resultp", "resultP", "rvp", " errcp", "errP", "irvp", " errP", "resultps", "erps", "rP", " errps", "irp", "irps", "ercp", "errps", "resultcp", "erp", "rps", "errcp", "irP"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(slw)\n\n{\n\n    if (T1 & 0x20) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 = T0 << T1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 5855, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "a55692a96099c40aabb25e1443890be99f9c845c", "target": 1, "func": "static int read_interval_packets(WriterContext *w, AVFormatContext *fmt_ctx,\n\n                                 const ReadInterval *interval, int64_t *cur_ts)\n\n{\n\n    AVPacket pkt, pkt1;\n\n    AVFrame *frame = NULL;\n\n    int ret = 0, i = 0, frame_count = 0;\n\n    int64_t start = -INT64_MAX, end = interval->end;\n\n    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;\n\n\n\n    av_init_packet(&pkt);\n\n\n\n    av_log(NULL, AV_LOG_VERBOSE, \"Processing read interval \");\n\n    log_read_interval(interval, NULL, AV_LOG_VERBOSE);\n\n\n\n    if (interval->has_start) {\n\n        int64_t target;\n\n        if (interval->start_is_offset) {\n\n            if (*cur_ts == AV_NOPTS_VALUE) {\n\n                av_log(NULL, AV_LOG_ERROR,\n\n                       \"Could not seek to relative position since current \"\n\n                       \"timestamp is not defined\\n\");\n\n                ret = AVERROR(EINVAL);\n\n\n\n            target = *cur_ts + interval->start;\n\n        } else {\n\n            target = interval->start;\n\n\n\n\n        av_log(NULL, AV_LOG_VERBOSE, \"Seeking to read interval start point %s\\n\",\n\n               av_ts2timestr(target, &AV_TIME_BASE_Q));\n\n        if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Could not seek to position %\"PRId64\": %s\\n\",\n\n                   interval->start, av_err2str(ret));\n\n\n\n\n\n\n    frame = av_frame_alloc();\n\n\n\n\n\n    while (!av_read_frame(fmt_ctx, &pkt)) {\n\n        if (selected_streams[pkt.stream_index]) {\n\n            AVRational tb = fmt_ctx->streams[pkt.stream_index]->time_base;\n\n\n\n            if (pkt.pts != AV_NOPTS_VALUE)\n\n                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);\n\n\n\n            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {\n\n                start = *cur_ts;\n\n                has_start = 1;\n\n\n\n\n            if (has_start && !has_end && interval->end_is_offset) {\n\n                end = start + interval->end;\n\n                has_end = 1;\n\n\n\n\n            if (interval->end_is_offset && interval->duration_frames) {\n\n                if (frame_count >= interval->end)\n\n                    break;\n\n            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {\n\n                break;\n\n\n\n\n            frame_count++;\n\n            if (do_read_packets) {\n\n                if (do_show_packets)\n\n                    show_packet(w, fmt_ctx, &pkt, i++);\n\n                nb_streams_packets[pkt.stream_index]++;\n\n\n            if (do_read_frames) {\n\n                pkt1 = pkt;\n\n                while (pkt1.size && process_frame(w, fmt_ctx, frame, &pkt1) > 0);\n\n\n\n        av_free_packet(&pkt);\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = NULL;\n\n    pkt.size = 0;\n\n    //Flush remaining frames that are cached in the decoder\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        pkt.stream_index = i;\n\n        if (do_read_frames)\n\n            while (process_frame(w, fmt_ctx, frame, &pkt) > 0);\n\n\n\n\nend:\n\n    av_frame_free(&frame);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Could not read packets in interval \");\n\n        log_read_interval(interval, NULL, AV_LOG_ERROR);\n\n\n    return ret;\n", "idx": 21012, "substitutes": {"w": ["writer", "cam", "wcs", "ow", "g", "wa", "wr", "temp", "r", "m", "we", "aw", "rw", "iw", "wb", "W", "wp", "window", "sw", "RW", "fw", "wav", "wx", "tw", "hw", "kw", "wrap"], "fmt_ctx": ["fmt_reader", "frt_cmp", "fmt_coll", "fmt_cu", "fmtfloc", "fmt_sci", "fmt_context", "fmt2sci", "fmt2context", "fmtfrx", "frt_coll", "frt_reader", "fMT_context", "fmt_loc", "fmt_rx", "fMT_rx", "fmt_cmp", "frt_sci", "frt_cu", "fmtfctx", "fMT_loc", "fmtfcontext", "fmt2ctx", "fmt2cmp", "frt_ctx", "fMT_ctx", "frt_context"], "interval": ["extcal", "nerver", "interscel", "INTERsection", "sural", "intervol", "irval", "inseval", "extval", "intersval", "warval", "interchange", "extVAL", "infvol", "interref", "INTERref", " interruction", "interpoint", "intersvals", "warpol", "intercel", "intcel", "extpoint", "perref", "overval", "curval", "Intervals", "nerval", "interrupt", "iterchange", "inseVAL", "iterpol", " intervals", "iterval", " interpre", "INTERv", "iterver", "interpol", " interal", "surval", "INTERpol", "INTERver", "intcol", "perpre", "interv", "iterpoint", "infpol", "overpol", "INTERcal", "intervert", "curchange", "interVAL", " interver", "pervert", "irvals", " interv", "Interval", "iterrupt", "intervals", "extvert", " intercol", "extsection", "insever", "interrule", " interrule", "curpoint", "intvals", "iterpre", "warruction", "insepre", "insesection", "perv", "Intercel", "INTERval", "waral", "nerpol", "surruction", "itervol", "ircel", "INTERVAL", "extpol", "insecal", "intersrule", "iterVAL", "INTERpre", "nerVAL", "perVAL", "extchange", "intercol", "intval", "intersection", "ircol", " intercel", "infver", "interver", "oververt", " interpol", "infval", "interal", "extrupt", "surpol", "perval", "Interrule", "interpre", " interref", "currupt", " intervol", "perpol", "intercal", "overVAL", "interruction"], "cur_ts": [" cur_qs", " cur_ds", "curGats", "curGqs", "cur8times", " cur_TS", "Cur_ts", "cur2times", " cur_ats", "curLvalues", "cur2ts", "cur_uts", "cur_steps", "cur8TS", "cur2steps", " cur_times", " cur_values", "cur_ats", "rc\n", "cur_TS", "Cur\n", " cur\n", "cur_ds", "curLts", "Cur_TS", " cur_uts", "curGts", "cur8ts", "cur_times", "cur_qs", "cur2TS", "Cur_steps", "cur_values", "cur8uts", "Cur_times", "curLtimes", "curLds", "curGtimes", "cur\n"], "pkt": ["Packet", "cpet", " pct", "Pct", "pmt", "Pwk", "backet", "cpacket", "cpsth", "pet", "cpkt", "Pet", "pett", "fct", "promacket", "promkt", "cwk", " pett", " pwk", "pelt", "promct", "Psth", "fqt", "Pqt", "cpct", "opmt", "Pett", "bkt", "fet", " pelt", "bct", "celt", "Pmt", " pqt", "promett", " pet", "Pkt", "packet", "opct", "fkt", "pwk", " packet", "opacket", "psth", "pqt", "opkt", "bsth", "cpmt", "facket", "pct", "Pelt", "ckt", "cacket"], "pkt1": ["packet2", "pct2", " pqt1", "packet1", "pqt2", " pkt2", "pkt2", "pct1", " pqt2", "pqt1"], "frame": ["view", "e", "object", "event", "thread", "result", "part", "val", "feature", "parse", "f", "buffer", "fat", "sequence", "data", "state", "lock", "p", "ret", "point", "ace", "dr", "live", "fr", "window", "seq", "session", "call", "slice", "flow", "trace", "Frame", "range", "boot", "fram", "parent", "image", "block", "fi", "feat"], "target": ["feat", "port", "net", "Target", "arget", "start", "limit", "next", "conn", "gt", "end", "pattern", "valid", "object", "result", " offset", " ret", "project", "arg", "blank", "transform", "token", "weight", "buffer", "path", "master", "address", "cat", "data", "rel", "ret", "ip", "current", " Target", "point", "timeout", "client", "ctx", "tag", "goal", "source", "match", "ARGET", "ault", "window", "date", "core", "qa", "session", "top", " next", "test", "iter", "base", "global", "root", "range", "alt", "parent", "nt", "reset", "dest", "expected", "pointer", "gap", "offset", " result", "output", "format", "value"], "frame_count": ["frame___weight", "frame_id", "frame2id", "frame_counter", "frame___counter", "frame2counter", "frame2count", "block_weight", "block_counter", "block_count", "block_id", "frame2weight", "frame___count", "block___counter", "block___count", "block___weight", "block___id", "frame___id", "frame_weight"], "i": ["io", "ind", "ti", "I", "f", "ci", "t", "info", "it", "j", "ip", "p", "at", "id", "mi", "timeout", "c", "index", "num", "si", "ii", "slice", "ai", "len", "multi", "fi", "ni"], "stream_index": ["wave_position", "stream_config", "stream_number", " streamingconfig", "streamityupdate", "streamingconfig", "wavealposition", "streamityconfig", "wave_index", "streamityposition", "streamalindex", "streamingindex", " stream_int", "streamishposition", "streamalposition", "wavealindex", "stream_int", "wavealupdate", "stream_condition", "streamitycondition", "streamingnumber", "streamalcondition", " stream_number", "streamitynumber", " streamingnumber", "streamishindex", "stream_position", " stream_config", "wave_update", " streamingint", "wavealcondition", " streamingindex", "wave_condition", "streamityindex", "streamalupdate", "stream_update", "streamishupdate", "streamingint", "streamityint", "streamishcondition"]}}
{"project": "FFmpeg", "commit_id": "ddd86a2924b9bc67c406cd66ebb1fc8915cd60f7", "target": 1, "func": "static int output_packet(InputStream *ist,\n\n                         OutputStream *ost_table, int nb_ostreams,\n\n                         const AVPacket *pkt)\n\n{\n\n    int ret = 0, i;\n\n    int got_output;\n\n    int64_t pkt_pts = AV_NOPTS_VALUE;\n\n\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->dts;\n\n    if (ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE) {\n\n        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)\n\n            ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    }\n\n    if(pkt->pts != AV_NOPTS_VALUE)\n\n        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int duration;\n\n    handle_eof:\n\n\n\n        ist->pts = ist->next_pts;\n\n        ist->dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = transcode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = transcode_video    (ist, &avpkt, &got_output, &pkt_pts);\n\n            if (avpkt.duration) {\n\n                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                duration = ((int64_t)AV_TIME_BASE *\n\n                                ist->st->codec->time_base.num * ticks) /\n\n                                ist->st->codec->time_base.den;\n\n            } else\n\n                duration = 0;\n\n\n\n            if(ist->dts != AV_NOPTS_VALUE && duration) {\n\n                ist->next_dts += duration;\n\n            }else\n\n                ist->next_dts = AV_NOPTS_VALUE;\n\n\n\n            if (got_output)\n\n                ist->next_pts += duration; //FIXME the duration is not correct in some cases\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avpkt.dts=\n\n        avpkt.pts= AV_NOPTS_VALUE;\n\n\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n\n                ret = avpkt.size;\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        rate_emu_sleep(ist);\n\n        ist->dts = ist->next_dts;\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                             ist->st->codec->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (pkt->duration) {\n\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->st->codec->time_base.num * ticks) /\n\n                                  ist->st->codec->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n        ist->pts = ist->dts;\n\n        ist->next_pts = ist->next_dts;\n\n    }\n\n    for (i = 0; pkt && i < nb_ostreams; i++) {\n\n        OutputStream *ost = &ost_table[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18077, "substitutes": {"ist": ["set", "edit", "nt", "adder", "empt", "att", "ont", "irst", "feat", "pop", "it", "pt", "est", "part", "tt", "txt", "work", "nd", "rest", "artist", "osi", "ld", "wd", "dit", "pect", "imet", "art", "istor", "pg", "aint", "et", "ft", "list", "at", "wp", "ists", "ict", "ess", "mot", "ind", "isd", "act", "sta", "ht", "ird", "back", "xt", "ad", "start", "post", "ust", "iste", "ism", "inst", "ace", "er", "progress", "oss", "ord", "ast", "ext", "ctx", "gest", "asp", "lect", "old", "elect", "alist", "add", "st", "ush", "dr", "isi", "ait", "kt", "support", "pick", "best", "IST", "ard", "usr", "dist"], "ost_table": ["ost_source", "oc_file", "ost_col", "ost_file", "oc_col", "oc_table", "oc_source"], "nb_ostreams": ["nb_octstreams", "nb_ostocollist", "nb_ostreamgroups", "nb_octstreamgroups", "nb_octreams", "nb_ostinputs", "nb_octstreamd", "nb_ostocols", "nb_octstreamlist", "nb_ostreamd", "nb_ostocold", "nb_ostinputlist", "nb_oststreamgroups", "nb_octreamlist", "nb_ostinputd", "nb_oststreams", "nb_octreamgroups", "nb_ostocolgroups", "nb_octreamd", "nb_oststreamd", "nb_oststreamlist", "nb_ostinputgroups", "nb_ostreamlist"], "pkt": ["preacket", "mwk", "delt", " psth", " pct", "packet", "ppkt", "fcht", "melt", "opett", "jpacket", "mkt", "apqt", "backet", "apcht", "pcht", "Pkt", "cpett", "Pct", "tpcht", "Pqt", "ppnt", "Ptch", "pnt", "tpkt", "bkt", "paramwk", "rkt", "tkt", "mcht", "fsth", " pet", "payacket", "pqt", "cpqt", "opkt", "mnt", "jpkt", "prent", "paykt", " pqt", "pet", "psth", "apelt", "tacket", "fkt", "rtch", "paycht", "Pet", "pett", "Packet", "fwk", "ppct", "cpct", "tpqt", "Pcht", "dcht", "jpett", "paramnt", " pcht", "opelt", "facket", "paramkt", "cpkt", " pelt", "rcht", "macket", "racket", "opcht", "tpelt", "paramacket", "dkt", "apkt", "tsth", "Pnt", "bwk", "dacket", "prewk", "jpcht", "pelt", " packet", " pnt", "pwk", "ppacket", "paytch", "tcht", "pct", "cpelt", "bcht", "cpcht", "cpet", "cpacket", "ptch", "opacket", "prekt"], "i": ["ti", "gi", "j", "t", "f", "io", "mi", "n", "ai", "ii", "di", "slice", "mini", "ind", "I", "ip", "d", "pi", "ui", "ci", "c", "si", "p", "xi", "it", "fi", "inner", "li"], "got_output": ["got_response", "got___response", "getting_download", "getting_output", "got_download", " got_Output", "getting_response", "got_input", "getting_input", " got_input", "got_Output", "got___output", "got___input", "got___download"], "avpkt": ["avpcht", "ovbetsk", "avaiece", "avfcht", "avfett", "avfact", "avdpacket", "avcpkt", "Avpact", "avpqt", "Avpkt", "avecct", "avgkt", "avpcp", "evpk", "caltpwk", "AVcpcp", "avccht", "avvkt", "avepcht", "avparamcht", "Avppkt", "ovpkt", "avopk", "avpwk", "evcpkt", "avparamet", "avPqt", "avipact", "avakt", "avmnt", "avcpet", "AVcpkt", "avopqt", "avepkt", "Avpwk", "ovbkt", "avckt", "avegiece", "avepct", "avgke", "calpacket", "avdpkt", "avfnt", "avfwk", "adpett", "avciece", "avvnt", "avbnt", "avpact", "avpet", "avspkt", "aveciece", "ovbnt", "avipkt", "caltpkt", "AVcpcht", "avpunct", "avpetsk", "calpunct", "adpkt", "avmqt", "evpnt", "avnpct", "avpft", "avvetsk", "avtpkt", "avfqt", "avppacket", "avegft", "ovpetsk", "Avpacket", "avcpk", "avbacket", "evcpqt", "avlpqt", "ovpnt", "calpwk", "avtpunct", "avnpft", "avspet", "avipacket", "avppact", "avppwk", "avopett", "avgiece", "avegke", "avepiece", "avaft", "avcpcp", "avmkt", "avpk", "avPk", "Avppact", "avpett", "evpqt", "avfetsk", "avpct", "adlpkt", "avtpwk", "avlpk", "avepke", "avcpcht", "avpnt", "avcct", "avfk", "evpkt", "Avppwk", "avcpqt", "Avppacket", "avgft", "aveccht", "ovpacket", "adlpett", "avopkt", "avdpwk", "avtpacket", "avegkt", "avspcp", "AVpkt", "AVpcp", "adpqt", "avpacket", "evcpnt", "avparamcp", "AVpet", "avbetsk", "avfkt", "avnpkt", "avfct", "caltpunct", "avpke", "avdpunct", "avpiece", "avmk", "avfunct", "avvacket", "avnpiece", "avake", "ovbacket", "AVcpet", "avbkt", "adpk", "avspcht", "adlpk", "evcpk", "AVpcht", "avnpcht", "caltpacket", "avnpke", "avlpkt", "avppkt", "avipwk", "adlpqt", "calpkt", "avPnt", "avparamkt", "aveckt", "avepft", "avfacket", "avlpett", "avcpnt", "avPkt", "avfiece"], "duration": ["m", "group", "sg", "err", "f", "T", "fun", "debug", "wait", "result", "num", "g", "sec", "timeout", "resp", "gap", "d", "G", "id", "start", "unit", "loss", "lag", "total", "desc", "valid", "gr"]}}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static inline int sd_wp_addr(SDState *sd, uint32_t addr)\n\n{\n\n    return sd->wp_groups[addr >>\n\n            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];\n\n}\n", "idx": 20507, "substitutes": {"sd": ["md", "td", "sv", "sb", "sed", "rd", "sk", "sam", "sl", "std", "db", "d", "vd", " td", "pd", "ds", "ld", "gd", "dev", "dd", "ad", "hd", "cs", "od", "sa", "sg", "sm", "sq", "sh", "si", "se", "dk", "dl", "fd", "inst", "sf", "bd", "SD", "di", "ss", "gb"], "addr": ["route", "ref", "adr", "ha", "kt", "ord", "wd", "rx", "align", "host", "mt", "ld", "pad", "node", "pc", "adder", "ac", "address", "size", "data", "ad", "state", "dd", "hd", "ace", "id", "od", "mac", "dr", "ext", "rc", "cb", "nr", "rm", "ar", "rt", "ptr", "hash", "alias", "src", "pointer", "offset", "x", "attr"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int vqa_decode_init(AVCodecContext *avctx)\n\n{\n\n    VqaContext *s = (VqaContext *)avctx->priv_data;\n\n    unsigned char *vqa_header;\n\n    int i, j, codebook_index;;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    avctx->has_b_frames = 0;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the extradata made it */\n\n    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: expected extradata size of %d\\n\", VQA_HEADER_SIZE);\n\n\n\n\n\n    /* load up the VQA parameters from the header */\n\n    vqa_header = (unsigned char *)s->avctx->extradata;\n\n    s->vqa_version = vqa_header[0];\n\n    s->width = LE_16(&vqa_header[6]);\n\n    s->height = LE_16(&vqa_header[8]);\n\n\n\n\n\n    s->vector_width = vqa_header[10];\n\n    s->vector_height = vqa_header[11];\n\n    s->partial_count = s->partial_countdown = vqa_header[13];\n\n\n\n    /* the vector dimensions have to meet very stringent requirements */\n\n    if ((s->vector_width != 4) ||\n\n        ((s->vector_height != 2) && (s->vector_height != 4))) {\n\n        /* return without further initialization */\n\n\n\n\n\n    /* allocate codebooks */\n\n    s->codebook_size = MAX_CODEBOOK_SIZE;\n\n    s->codebook = av_malloc(s->codebook_size);\n\n    s->next_codebook_buffer = av_malloc(s->codebook_size);\n\n\n\n    /* initialize the solid-color vectors */\n\n    if (s->vector_height == 4) {\n\n        codebook_index = 0xFF00 * 16;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 16; j++)\n\n                s->codebook[codebook_index++] = i;\n\n    } else {\n\n        codebook_index = 0xF00 * 8;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 8; j++)\n\n                s->codebook[codebook_index++] = i;\n\n\n    s->next_codebook_buffer_index = 0;\n\n\n\n    /* allocate decode buffer */\n\n    s->decode_buffer_size = (s->width / s->vector_width) *\n\n        (s->height / s->vector_height) * 2;\n\n    s->decode_buffer = av_malloc(s->decode_buffer_size);\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n", "idx": 2358, "substitutes": {"avctx": ["afcontext", "navcm", " avctl", "afcup", "afkb", " avcu", "afloc", "avecas", "ovcf", "navctl", "avcontext", "afwcs", "afcp", "aveconfig", "avcm", "AVcontext", "afcmp", "avecu", "ovcontext", "verwcs", "avkb", "avectx", "avecf", "afctx", "navctx", "AVcp", "avcf", "AVctl", "avcb", "avcp", "afcm", "abcf", "avconfig", "aucontext", "abcontext", "verctx", "avecmp", "avcas", "avewcs", " avloc", "afcas", "abcmp", " avcm", "AVconfig", "avecb", "auctx", "accountcontext", "accountctx", "ovctx", "aucb", "abctx", "avecup", "afcu", "navloc", " avkb", "afcf", "avctl", "aucu", "navconfig", "avwcs", "vercontext", "afconfig", "AVctx", "avecp", " avwcs", "ovcas", "accountcf", " avcontext", " avcf", "avekb", "vercf", " avconfig", "avcup", "accountcup", "navcontext", "avloc", "avecontext", "avcu", "avcmp", "afcb"], "s": ["sg", "js", "qs", "n", "sites", "sl", "g", "ses", "ls", "sf", "args", "storage", "vs", "f", "sys", "sc", "se", "fs", "parts", "spec", "ts", "sb", "aws", "uns", "xs", "sv", "sets", "p", "e", "lines", "conf", "less", "su", "S", "t", "session", "ks", "os", "its", "bs", "sym", "ssl", "cs", "ctx", "ss", "a", "rs", "r", "is", "ins", "m", "settings", "ds", "ps", "gs", "ns", "c", "es", "o", "si", "server", "service", "http", "ops", "d", "results", "ms", "comments", "params", "sync", "l", "services", "w", "sq", "stats", "b", "full", "states"], "vqa_header": ["vqua_header", "vca_buffer", "vasa_comment", "vasa_main", "vqa2header", "vqa64token", "vqa_token", "vqa_buffer", "vqaOpart", "vca_block", "vcca_border", "vqa00header", "vga_header", "vcca_header", "vqa_head", "vqa00part", "vqa_request", "vqadhead", "vasa_version", "vqa_main", "vista_header", "vca_version", "vqua64token", "vqa2version", "vqua64header", "vqa_version", "vqadmain", "vqaamversion", "vqaamblock", "vqua_main", "vqa67header", "vqa_center", "vqadheader", "vqa00center", "vcca_buffer", "vcca_description", "vqa00request", "vista_center", "vqaamheader", "vqa_metadata", "vqa67center", "vqa_message", "vqa67part", "vqa_comment", "vasa_header", "vga_head", "vqua64main", "vga_message", "vqa64head", "vqaOrequest", "vqa_description", "vqa_block", "vqadcomment", "vqa_border", "vca_header", "vasa_buffer", "vqaammetadata", "vista67part", "vqa64header", "vqua_token", "vqua64head", "vista67header", "vista67request", "vqaOheader", "vqaOcenter", "vqaambuffer", "vasa_head", "vasa_metadata", "vqa67request", "vqa2buffer", "vqua_head", "vista_part", "vqa_part", "vista67center", "vga_version", "vqa64main", "vista_request"], "i": ["yi", "li", "gi", "ni", "ii", "ji", "pi", "ui", "n", "I", "di", "is", "id", "mi", "im", "iu", "it", "api", "y", "g", "ri", "eni", "info", "ti", "ini", "index", "z", "ai", "ie", "ip", "ind", "l", "p", "phi", "bi", "f", "u", "ki", "v", "o", "qi", "vi", "ik", "ix", "uri", "ci", "io", "fi", "si", "in", "xi"], "j": ["xi", "js", "li", "q", "jl", "key", "em", "ii", "ji", "jit", "ui", "jen", "d", "n", "jj", "position", "J", "oj", "job", "it", "k", "aj", "th", "ij", "uj", "off", "y", "py", "pos", "g", "m", "jo", "kj", "fr", "z", "index", "ie", "h", "ind", "l", "p", "x", "jc", "size", "f", "jam", "br", "je", "jp", "jet", "dj", "obj", "o", "v", "b", "qi", "vi", "si", "ja"], "codebook_index": ["codebookacindex", "codebreak_point", "codebook_condition", "codebook__point", "codeBOOKPcondition", "codebookPi", "codeBOOK_condition", "codeBOOKPindex", "codebookaccount", "codeBOOKPcount", "codebook___min", "codebook_info", "codebookPcondition", "codesheet_slice", "codebox_size", "codebook___index", "codebookenloop", "codebook_count", "codebreak_ind", "codesheet_min", "codebook__info", "codebook_position", "codeBOOK_i", "codebreak_index", "codeBOOKPi", "codebook__index", "codesheet_size", "codesheet_loop", "codebox_length", "codebox_label", "codebookaci", "codebox_index", "codebookPcount", "codebook___position", "codebook___condition", "codeBOOK_count", "codesheet_position", "codebook_size", "codebookenslice", "codebreak_info", "codesheet_condition", "codebook_min", "codebook_ind", "codebook_label", "codebook__ind", "codebook_i", "codebook_slice", "codebook_point", "codebookPindex", "codebook_loop", "codebookenindex", "codebookensize", "codesheet_index", "codebookaccondition", "codebook_length", "codeBOOK_index"]}}
{"project": "FFmpeg", "commit_id": "9b2c28e6edbb43e00e0b2d99b95567189cd46e91", "target": 0, "func": "void rgb15to16(const uint8_t *src,uint8_t *dst,uint32_t src_size)\n\n{\n\n#ifdef HAVE_MMX\n\n  register const char* s=src+src_size;\n\n  register char* d=dst+src_size;\n\n  register int offs=-src_size;\n\n  __asm __volatile(PREFETCH\"\t%0\"::\"m\"(*(s+offs)):\"memory\");\n\n  __asm __volatile(\n\n\t\"movq\t%0, %%mm4\\n\\t\"\n\n\t\"movq\t%1, %%mm5\"\n\n\t::\"m\"(mask15b), \"m\"(mask15rg):\"memory\");\n\n  while(offs<0)\n\n  {\n\n\t__asm __volatile(\n\n\t\tPREFETCH\"\t32%1\\n\\t\"\n\n\t\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\t\"movq\t8%1, %%mm2\\n\\t\"\n\n\t\t\"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t\t\"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm0\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm1\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm2\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm3\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm1\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm3\\n\\t\"\n\n\t\t\"por\t%%mm1, %%mm0\\n\\t\"\n\n\t\t\"por\t%%mm3, %%mm2\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 8%0\"\n\n\t\t:\"=m\"(*(d+offs))\n\n\t\t:\"m\"(*(s+offs))\n\n\t\t:\"memory\");\n\n\toffs+=16;\n\n  }\n\n  __asm __volatile(SFENCE:::\"memory\");\n\n  __asm __volatile(EMMS:::\"memory\");\n\n#else\n\n   const uint16_t *s1=( uint16_t * )src;\n\n   uint16_t *d1=( uint16_t * )dst;\n\n   uint16_t *e=((uint8_t *)s1)+src_size;\n\n   while( s1<e ){\n\n     register int x=*( s1++ );\n\n     /* rrrrrggggggbbbbb\n\n        0rrrrrgggggbbbbb\n\n        0111 1111 1110 0000=0x7FE0\n\n        00000000000001 1111=0x001F */\n\n     *( d1++ )=( x&0x001F )|( ( x&0x7FE0 )<<1 );\n\n   }\n\n#endif\n\n}\n", "idx": 13855, "substitutes": {"src": ["RC", "rib", "proc", "gz", "uc", "sync", "rc", "config", "ins", "stream", "rs", "supp", "ctr", "sup", "source", "req", "image", "sr", "dest", "sq", "loc", "secure", "impl", "rb", "img", "share", "pl", "sb", "b", "reflect", "inst", "scl", "url", "c", "cb", "ur", "sc", "ssl", "rob", "attr", "sur", "sub", "cur", "support", "filename"], "dst": ["dyst", " dsts", "datsts", "dyput", "Dst", "dysp", "datput", "Dsts", "adst", "dsts", "dysts", " dsp", "adsts", " drc", "datst", "idrc", "sdsts", "dsp", "idbl", "dbl", "Dbl", "sdst", "adsp", "adrc", "idst", "dput", "datsp", "idsts", "Dsp", "sdput", " dbl", "adbl", "drc", "sdsp"], "src_size": ["rc_address", "rc_size", "src64name", " src_scale", "rc_speed", "src_scale", "src_address", "src_day", "rc_name", "src64scale", "rc_scale", "src_name", " src_day", "src_speed", "src64size", " src_address"], "s": ["ses", "t", "ins", "l", "i", "a", "g", "S", "sp", "h", "os", "si", "v", "ps", "o", "w", "u", "z", "p", "b", "sb", "j", "n", "f", "gs", "c", "ns", "offs", "r", "ds", "su", "ls", "ts", "space", "ks"], "d": ["D", "dh", "t", "fd", "l", "i", "a", "g", "h", "x", "di", "v", "o", "w", "z", "ad", "u", "p", "ind", "b", "sd", "j", "n", "f", "dat", "c", "dt", "dc", "q", "dp", "r", "ds", "dn"], "m": ["mc", "cm", "t", "l", "i", "a", "fm", "g", "h", "x", "mm", "v", "tm", "o", "w", "ms", "gm", "media", "mt", "p", "bm", "u", "mi", "b", "multi", "n", "f", "mode", "hm", "c", "nm", "M", "r", "y", "sm"], "memory": ["true", "map", "record", "cm", "math", "medium", "i", "shape", "large", "name", "g", "reference", "manager", "image", "h", "use", "module", "buffer", "java", "vm", "mm", "performance", "session", "master", "size", "media", "mem", "p", "resource", "Memory", "data", "byte", "count", "length", "mask", "address", "complex", "gpu", "function", "application", "all", "cache", "program", "texture", "material", "asm", "message"], "s1": ["p2", "f8", "S1", "p81", " s2", "d81", "ds2", "s8", "S2", "dOne", "dsOne", "p1", "s81", "pOne", "s2", "n8", "nOne", "dsone", "S81", "SOne", "sone", "ds1", "sOne", "fOne", "n81", "n1", "f1", "S8", "pone", "d2", "f81", " sone"], "d1": ["c81", " d11", "done", "f8", "e81", "c1", " d81", "d81", "i3", "e11", "c8", "c11", "i1", "d11", "d3", "f3", "d8", "i8", "cone", "eone", " done", "c3", "f1", "e1"], "e": ["en", "E", "ea", "ue", "ey", "h", "ve", "x", "es", "ie", "error", "equal", "ed", "element", "de", "u", "z", "ee", "p", "eps", "be", "se", "f", "fe", "c", "end", "pe", "ne", "ele", "ce", "ae", "ev", "ei", "ec", "el", "ef", "y", "esi"]}}
{"project": "FFmpeg", "commit_id": "b853cfe7eaf13b7d4ff3ceba7098544ccc049df8", "target": 0, "func": "static void stream_close(VideoState *is)\n\n{\n\n    VideoPicture *vp;\n\n    int i;\n\n    /* XXX: use a special url_shutdown call to abort parse cleanly */\n\n    is->abort_request = 1;\n\n    SDL_WaitThread(is->read_tid, NULL);\n\n    SDL_WaitThread(is->refresh_tid, NULL);\n\n    packet_queue_destroy(&is->videoq);\n\n    packet_queue_destroy(&is->audioq);\n\n    packet_queue_destroy(&is->subtitleq);\n\n\n\n    /* free all pictures */\n\n    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {\n\n        vp = &is->pictq[i];\n\n#if CONFIG_AVFILTER\n\n        avfilter_unref_bufferp(&vp->picref);\n\n#endif\n\n        if (vp->bmp) {\n\n            SDL_FreeYUVOverlay(vp->bmp);\n\n            vp->bmp = NULL;\n\n        }\n\n    }\n\n    SDL_DestroyMutex(is->pictq_mutex);\n\n    SDL_DestroyCond(is->pictq_cond);\n\n    SDL_DestroyMutex(is->subpq_mutex);\n\n    SDL_DestroyCond(is->subpq_cond);\n\n    SDL_DestroyCond(is->continue_read_thread);\n\n#if !CONFIG_AVFILTER\n\n    sws_freeContext(is->img_convert_ctx);\n\n#endif\n\n    av_free(is);\n\n}\n", "idx": 6997, "substitutes": {"is": ["isi", "ris", "ib", "does", "IS", "iris", "parts", "ii", "ois", "las", "bs", "ar", "cms", "self", "nis", "irc", "id", "s", "config", "info", "its", "was", "ls", "iss", "it", "uri", "ops", "bis", "ils", "ie", "ais", "ip", "ms", "iso", "isc", "ui", "as", "act", "are", "ins", "lis", "ri", "use", "or", "ses", "isl", "has", "isu", "esi", "isa", "cs", "ics", "sis", "mis", "ist", "isin", "ic", "css", "os", "can", "api", "core", "ish", "app", "Is", "http", "get", "in", "init", "us", "full", "this", "iv", "il", "es", "js"], "vp": ["nv", "plugin", "gp", "hw", "vr", "bp", "vg", "v", "pr", "qv", "vm", "va", "vt", "tmp", "esp", "pp", "pd", "xp", "wp", "lp", "avi", "uv", "px", "uf", "pm", "mp", "pg", "pps", "np", "vs", "vP", "fp", "jp", "fps", "p", "sv", "sp", "iv", "ppa", "vl", "eve", "lv", "ov", "tp", "vv", "VP", "api", "PF", "cv", "vc", "pb", "adr", "pkg"], "i": ["gi", "r", "o", "ti", "v", "I", "di", "s", "ci", "ji", "ni", "xi", "ri", "si", "rc", "b", "abi", "io", "x", "bi", "m", "qi", "ix", "l", "yi", "pi", "f", "phi", "j", "iu", "ii", "d", "ai", "cli", "u", "vi", "e", "uri", "t", "k", "multi", "ini", "p", "h", "eni", "z", "oi", "c", "ip", "g", "api", "li", "fi", "index", "zi", "mu", "ui"]}}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "void ff_dsputil_init_alpha(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n    const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n    if (!high_bit_depth) {\n\n    c->put_pixels_tab[0][0] = put_pixels16_axp_asm;\n\n    c->put_pixels_tab[0][1] = put_pixels16_x2_axp;\n\n    c->put_pixels_tab[0][2] = put_pixels16_y2_axp;\n\n    c->put_pixels_tab[0][3] = put_pixels16_xy2_axp;\n\n\n\n    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_axp_asm;\n\n    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_axp;\n\n    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_axp;\n\n    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_axp;\n\n\n\n    c->avg_pixels_tab[0][0] = avg_pixels16_axp;\n\n    c->avg_pixels_tab[0][1] = avg_pixels16_x2_axp;\n\n    c->avg_pixels_tab[0][2] = avg_pixels16_y2_axp;\n\n    c->avg_pixels_tab[0][3] = avg_pixels16_xy2_axp;\n\n\n\n    c->avg_no_rnd_pixels_tab[0][0] = avg_no_rnd_pixels16_axp;\n\n    c->avg_no_rnd_pixels_tab[0][1] = avg_no_rnd_pixels16_x2_axp;\n\n    c->avg_no_rnd_pixels_tab[0][2] = avg_no_rnd_pixels16_y2_axp;\n\n    c->avg_no_rnd_pixels_tab[0][3] = avg_no_rnd_pixels16_xy2_axp;\n\n\n\n    c->put_pixels_tab[1][0] = put_pixels_axp_asm;\n\n    c->put_pixels_tab[1][1] = put_pixels_x2_axp;\n\n    c->put_pixels_tab[1][2] = put_pixels_y2_axp;\n\n    c->put_pixels_tab[1][3] = put_pixels_xy2_axp;\n\n\n\n    c->put_no_rnd_pixels_tab[1][0] = put_pixels_axp_asm;\n\n    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels_x2_axp;\n\n    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels_y2_axp;\n\n    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels_xy2_axp;\n\n\n\n    c->avg_pixels_tab[1][0] = avg_pixels_axp;\n\n    c->avg_pixels_tab[1][1] = avg_pixels_x2_axp;\n\n    c->avg_pixels_tab[1][2] = avg_pixels_y2_axp;\n\n    c->avg_pixels_tab[1][3] = avg_pixels_xy2_axp;\n\n\n\n    c->avg_no_rnd_pixels_tab[1][0] = avg_no_rnd_pixels_axp;\n\n    c->avg_no_rnd_pixels_tab[1][1] = avg_no_rnd_pixels_x2_axp;\n\n    c->avg_no_rnd_pixels_tab[1][2] = avg_no_rnd_pixels_y2_axp;\n\n    c->avg_no_rnd_pixels_tab[1][3] = avg_no_rnd_pixels_xy2_axp;\n\n\n\n    c->clear_blocks = clear_blocks_axp;\n\n    }\n\n\n\n    /* amask clears all bits that correspond to present features.  */\n\n    if (amask(AMASK_MVI) == 0) {\n\n        c->put_pixels_clamped = put_pixels_clamped_mvi_asm;\n\n        c->add_pixels_clamped = add_pixels_clamped_mvi_asm;\n\n\n\n        if (!high_bit_depth)\n\n            c->get_pixels   = get_pixels_mvi;\n\n        c->diff_pixels      = diff_pixels_mvi;\n\n        c->sad[0]           = pix_abs16x16_mvi_asm;\n\n        c->sad[1]           = pix_abs8x8_mvi;\n\n        c->pix_abs[0][0]    = pix_abs16x16_mvi_asm;\n\n        c->pix_abs[1][0]    = pix_abs8x8_mvi;\n\n        c->pix_abs[0][1]    = pix_abs16x16_x2_mvi;\n\n        c->pix_abs[0][2]    = pix_abs16x16_y2_mvi;\n\n        c->pix_abs[0][3]    = pix_abs16x16_xy2_mvi;\n\n    }\n\n\n\n    put_pixels_clamped_axp_p = c->put_pixels_clamped;\n\n    add_pixels_clamped_axp_p = c->add_pixels_clamped;\n\n\n\n    if (avctx->bits_per_raw_sample <= 8 &&\n\n        (avctx->idct_algo == FF_IDCT_AUTO ||\n\n         avctx->idct_algo == FF_IDCT_SIMPLEALPHA)) {\n\n        c->idct_put = ff_simple_idct_put_axp;\n\n        c->idct_add = ff_simple_idct_add_axp;\n\n        c->idct =     ff_simple_idct_axp;\n\n    }\n\n}\n", "idx": 24426, "substitutes": {"c": ["sc", "cm", "k", "dc", "uc", "oc", "p", "this", "context", "C", "cit", "d", "xc", "ec", "cur", "config", "cr", "conf", "ct", "bc", "ce", "cy", "ch", "u", "e", "fc", "con", "ic", "cl", "vc", "s", "icc", "cc", "ctx", "ci", "cp", "cf", "mc", "rc", "cache", "co", "lc", "ctrl", "ca", "f", "gc", "tc", "n", "cu", "conn", "t", "q", "arc", "g", "r", "nc", "l", "cs", "ac", "pc"], "avctx": ["Avctl", "AVcmp", "abca", "avecontext", "abcontext", "avcmp", "afcmp", "avcontext", "avsci", "AVsci", "avca", "afcontext", "afctx", "avectx", "avctl", "afca", "abctx", "Avcontext", "avesci", "AVca", "abcmp", "AVctx", "AVctl", "Avsci", "avectl", "AVcontext", "Avctx"]}}
{"project": "FFmpeg", "commit_id": "80b1e1c03d26ade05b0f53d0731aa7398d4ef6f9", "target": 1, "func": "static int huf_uncompress(GetByteContext *gb,\n\n                          uint16_t *dst, int dst_size)\n\n{\n\n    int32_t src_size, im, iM;\n\n    uint32_t nBits;\n\n    uint64_t *freq;\n\n    HufDec *hdec;\n\n    int ret, i;\n\n\n\n    src_size = bytestream2_get_le32(gb);\n\n    im = bytestream2_get_le32(gb);\n\n    iM = bytestream2_get_le32(gb);\n\n    bytestream2_skip(gb, 4);\n\n    nBits = bytestream2_get_le32(gb);\n\n    if (im < 0 || im >= HUF_ENCSIZE ||\n\n        iM < 0 || iM >= HUF_ENCSIZE ||\n\n        src_size < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    bytestream2_skip(gb, 4);\n\n\n\n    freq = av_calloc(HUF_ENCSIZE, sizeof(*freq));\n\n    hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec));\n\n    if (!freq || !hdec) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)\n\n        goto fail;\n\n\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n\n        ret = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)\n\n        goto fail;\n\n    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);\n\n\n\nfail:\n\n    for (i = 0; i < HUF_DECSIZE; i++) {\n\n        if (hdec[i].p)\n\n            av_freep(&hdec[i].p);\n\n    }\n\n\n\n    av_free(freq);\n\n    av_free(hdec);\n\n\n\n    return ret;\n\n}\n", "idx": 16197, "substitutes": {"gb": ["ge", "gz", "cm", "bc", "sync", "rc", "pc", "gio", "bb", "binary", "gc", "gt", "g", "ko", "hub", "rg", "py", "gy", "game", "gin", "gnu", "cgi", "gru", "tm", "mb", "storage", "gd", "gm", "gg", "bm", "rb", "du", "cli", "sb", "usb", "jpg", "b", "bf", "gs", "cfg", "gam", "gram", "gom", "cb", "bg", "eb", "cod", "kb", "hd", "GB", "db", "ga", "src", "gal", "ctx", "go", "gp"], "dst": [" dsts", "sdST", " dST", "sdrest", "dsts", "pdost", "bST", "fdst", "sdsts", "dstore", "drest", "sdst", "dost", "dST", "fdsts", " drest", " dost", "pdst", "fdost", "fdstore", "pdsts", "bsts", "brest", " dstore", "bst", "pdstore"], "dst_size": ["dst_capacity", "dsc_size", "dsc_SIZE", "dst_len", "dsts_size", "dsts_len", "dsts_capacity", "dsc_name", "dst_name", "dst_SIZE"], "src_size": ["rss_size", " src_ize", " src_Size", " src_speed", "src_Size", "src_capacity", " src_capacity", "rss_ize", "src_ize", "rss_Size", "src_speed"], "im": ["sem", "m", "cm", "ru", "ai", "iu", "imm", "iv", "fm", "ci", "image", "hub", "IM", "umi", "mm", "ym", "ie", "model", "loc", "em", "ims", "Im", "aim", "sim", "imp", "size", "gm", "u", "img", "ib", "mi", "ext", "iam", "rm", "ip", "am", "pm", "om", "um", "ima", "imi", "imet", "dim", "dm", "nm", "lim", " unim"], "iM": ["iD", "siT", "siB", "oiD", "uI", "siL", "tiL", "oiM", " iMQ", "qiD", " iL", "qiM", "piM", "oiN", "uM", "uN", " iC", "siAM", "qiN", "iniP", "tiN", " iAM", "tiM", "siD", "siN", "iniN", "piN", "iC", "siM", "iniM", "iMQ", "iT", "iI", "tiT", "oM", "uMQ", " iG", "oI", "oim", "uC", "uAM", "oG", "iN", "iniB", "oD", "siP", "iL", " iT", "piC", " iD", " iB", " iP", "uB", "iP", "um", "iG", " iN", "uD", "uG", "iAM", "qiMQ", "piB", " iI", "iB"], "nBits": ["nNBats", "nDBis", " nMBats", "nFit", " nMBis", " nFitches", "nLits", " nMBits", "nLimitches", "nMBins", "nWits", "nMBITS", "nBITS", "nMBis", "nFats", "nBsats", "nBitches", "nCBits", "nLins", " nMBins", "nWats", "nCBitches", "nLimit", "nBsITS", "nNBITS", "nMBats", " nFITS", "nCBbits", "nLimbits", "nMBists", "nFitches", " nBit", " nBbits", " nFit", "nLITS", " nBis", "nWands", "nNBists", "nMBits", " nBins", "nLats", "nLands", "nBit", " nBitches", " nFbits", "nBsits", " nFits", "nBins", "nBis", "nFbits", "nBats", "nLis", " nBats", "nFits", " nFats", "nLimits", " nBITS", "nBsists", "nFands", " nMBists", "nDBins", "nNBits", "nBists", " nBists", "nWITS", "nDBits", "nBands", " nBands", "nFITS", " nFands", "nBbits", "nCBit", " nMBITS", "nDBITS"], "freq": ["freqs", "feeQ", "Freq", "speq", " frec", "frequencyque", "frequencyQ", "feeqs", "greqs", " freck", "frequencyquality", "frec", "frequencyqi", "offq", "luqs", "frequal", " frece", "Freqi", "Frequal", "frequencyce", "luck", " freque", "funque", "Fredq", "frequality", "offqs", "frece", "freQ", "feeq", "frep", "greq", "greque", " frequality", " freqs", "grequal", "Freck", "Frece", " frep", "offdq", "speqs", "fredq", "Frequality", "FreQ", "speqq", "feep", "offiq", " fredq", "freqq", "Frec", "Frep", "speiq", " freqq", "funq", "funqual", "Freque", "freque", "freck", "freqi", "Freqs", " freqi", "freiq", " freQ", "feec", "funqs", "luq", "frequencyq", " freiq", "Freiq", "Freqq"], "hdec": ["rhdec", "hmsec", "rhdecl", "hrec", "shrec", "hec", "phrec", "hydel", "hldec", "hldata", "hdes", "hldisc", "hdecl", "shdig", "fseq", "hseq", "hmdec", "ihdecl", " henc", "Hdecl", "hmdata", "hlseq", "hydiv", "bhenc", " hdiv", "hmrec", "hdig", "fdec", " hdes", " hDec", "hydecl", "shseq", " hsec", "Hrec", "bhdes", "hdesc", "hdeg", "ahdec", "wdec", "phdec", "pdisc", "shdel", " hdisc", "ahdata", "shdiv", "herdecl", "ihdata", "hdiv", "bhdec", "hlrec", "bhdecl", "Hsec", "pdesc", "HDec", "hmdecl", "shdecl", "hdisc", "fdecl", "Hdata", "pdec", "hdel", "hlenc", "phdig", "rhdata", "hdata", "hldig", "bhdata", "herdec", "ahdecl", " hdesc", "henc", " hec", " hdel", "wdeg", "wdecl", "ahseq", " hrec", "hldesc", "herdeg", "phseq", "Hseq", "hsec", "herec", "hDec", " hdecl", "fdata", "Hdec", "hldes", " hdeg", "hmDec", "ihdec", " hdata", "wec", "rhenc", "hydec", "ihrec", "shdec"], "ret": ["pet", "alt", "ft", "let", "rev", "part", "format", "reply", "id", "val", "code", "back", "def", "rets", "gt", "fun", "status", "str", "ref", "det", "arg", "lit", "valid", "feat", "obj", "ut", "mt", "mem", "bot", "info", "fi", "fin", "match", "data", "ext", "success", "Ret", "j", "result", "fit", "att", "cat", "nt", "re", "out", "rt", "rep", "resp", "db", "pat", "RET", "al", "res", "reg", "num", "flag", "len", "opt", "bit"], "i": ["ani", "qi", "it", "ui", "part", "I", "ni", "ai", "xi", "iu", "ini", "gi", "l", "oi", "io", "g", "ci", "ki", "mu", "di", "x", "si", "ie", "ii", "uri", "u", "ind", "p", "e", "mini", "fi", "info", "mi", "li", "ix", "multi", "j", "phi", "f", "ti", "ip", "eni", "pi", "chi", "bi", "ri", "ori", "ami", "zi", "y", "abi", "index"]}}
{"project": "FFmpeg", "commit_id": "a6d6b8a20072a5919d38258dd48cc612e2372f81", "target": 1, "func": "const AVOption *av_opt_next(void *obj, const AVOption *last)\n\n{\n\n    AVClass *class = *(AVClass**)obj;\n\n    if (!last && class->option[0].name) return class->option;\n\n    if (last && last[1].name)           return ++last;\n\n    return NULL;\n\n}\n", "idx": 14366, "substitutes": {"obj": ["ord", "alt", "self", "po", "ob", "art", "tmp", "jp", "val", "object", "ass", "act", "os", "nb", "init", "aut", "Obj", "o", "lib", "bot", "instance", "rb", "lt", "pl", "data", "ext", "b", "op", "inst", "j", "parent", "next", "nt", "clone", "src", "pos", "opt", "node", "cl"], "last": ["self", "after", "build", "sync", "bottom", "id", "code", "latest", "private", "object", "style", "child", "or", "eval", "final", "option", "later", "str", "pop", "nd", "full", "scope", "value", "closure", "size", "cost", "li", "j", "old", "est", "count", "list", "Last", "parent", "best", "global", "close", "next", "first", "end", "cle", "one", "cache", "empty", "cycle", "prev", "cl", "max", "worst", "node", "always"], "class": ["future", "Class", "self", "service", "config", "code", "private", "object", "latest", "style", "or", "current", "name", "ass", "classes", "section", "final", "option", "user", "new", "str", "scope", "opt", "ss", "lib", "super", "instance", "s", "b", "op", "parent", "line", "c", "cat", "first", "pe", "function", "CLASS", "rule", "out", "book", "cache", "css", "prev", "cl", "lass"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)\n\n{\n\n    uint8_t *old_code_ptr = s->code_ptr;\n\n    assert(ret != arg);\n\n#if TCG_TARGET_REG_BITS == 32\n\n    tcg_out_op_t(s, INDEX_op_mov_i32);\n\n#else\n\n    tcg_out_op_t(s, INDEX_op_mov_i64);\n\n#endif\n\n    tcg_out_r(s, ret);\n\n    tcg_out_r(s, arg);\n\n    old_code_ptr[1] = s->code_ptr - old_code_ptr;\n\n}\n", "idx": 19129, "substitutes": {"s": ["ns", "spec", "m", "ts", "sg", "session", "t", "info", "x", "f", "services", "r", "ions", "service", "n", "sb", "g", "i", "ss", "src", "in", "ctx", "this", "scope", "fs", "sec", "self", "xs", "is", "o", "cs", "context", "d", "su", "new", "args", "site", "w", "e", "ssl", "ses", "sync", "v", "c", "js", "si", "p", "S", "b", "ks", "gs", "sys", "u", "a", "es", "os", "us", "se", "sq", "ds", "sf"], "type": ["types", "spec", " t", "t", "name", "f", "pe", "rel", "def", "enc", "class", "re", "Type", "path", "style", "sub", "id", "parent", "TYPE", "p", "ty", "py", "prot", "ype", " typ", "typ"], "ret": ["tr", "obj", "err", "ref", "f", "alt", "al", "reg", "rc", "rt", "fun", "rel", "result", "str", "ar", "flag", "match", "usr", "sel", "ext", "sec", "mem", "ry", "def", "rets", "arr", "att", "store", "val", "re", "Ret", "args", "sr", "rev", "RET", "inter", "sys", "res", "proc", "opt", "fi", "reply", "target"], "arg": ["grad", "rest", "err", "ref", "alt", "all", "rc", "reg", "debug", "ar", "result", "str", "g", "flag", "arm", "Arg", "orig", "ext", "sec", "tag", "arr", "enc", "arc", "rec", "val", "re", "Ret", "args", "ig", "ag", "cmd", "argument", "inter", "b", "param", "addr", "mac", "target"], "old_code_ptr": ["old_code\u00b7length", "old_code_ref", "old_codeJptr", "old_line_tr", "old_code2pointers", "old_line_pointer", "old_line_ptr", "old_code_pointers", "old_code_length", "old_call_rep", "old_code_pointer", "old_line_ref", "old_code2pointer", "old_codeJpointer", "old_code_tr", "old_code_rep", "old_codeJrep", "old_code\u00b7rep", "old_code_addr", "old_code\u00b7pointer", "old_call_ptr", "old_call_pointer", "old_code2addr", "old_code\u00b7ptr", "old_codeJlength", "old_code2ptr", "old_call_length"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void mcf_uart_write(void *opaque, target_phys_addr_t addr,\n\n                    uint64_t val, unsigned size)\n\n{\n\n    mcf_uart_state *s = (mcf_uart_state *)opaque;\n\n    switch (addr & 0x3f) {\n\n    case 0x00:\n\n        s->mr[s->current_mr] = val;\n\n        s->current_mr = 1;\n\n        break;\n\n    case 0x04:\n\n        /* CSR is ignored.  */\n\n        break;\n\n    case 0x08: /* Command Register.  */\n\n        mcf_do_command(s, val);\n\n        break;\n\n    case 0x0c: /* Transmit Buffer.  */\n\n        s->sr &= ~MCF_UART_TxEMP;\n\n        s->tb = val;\n\n        mcf_uart_do_tx(s);\n\n        break;\n\n    case 0x10:\n\n        /* ACR is ignored.  */\n\n        break;\n\n    case 0x14:\n\n        s->imr = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    mcf_uart_update(s);\n\n}\n", "idx": 23495, "substitutes": {"opaque": ["OPaque", "ochole", "opaques", "OPque", "phole", "OPaques", "opatile", "ipaques", "ipaque", " opaques", "ocaques", "obaques", " opatile", "ophole", "obque", "patile", "obaque", "ipque", "opacity", "ocatile", "OPacity", "ocaque", "paques", "obacity", "opque", "paque", "ipacity", " ophole"], "addr": ["rol", "ocol", "port", "asm", "ref", "adr", "config", "prot", "part", "aud", "mode", "ord", "afi", "pad", "host", "pc", "align", "pos", "cmd", "address", "ad", "data", "p", "ace", "point", "code", "mac", "slot", "buf", "dr", "rc", "cb", "frame", " address", "ptr", "ada", "seq", "src", "len", "sid", "pointer", "tz", "offset"], "val": ["ival", "reg", "sel", "def", "serv", "fail", "ref", "sl", "valid", "ind", "vt", "part", "xxx", "tx", "bl", "buffer", "pos", "exec", "al", "pre", "data", "stat", "state", "ret", "p", "enc", "vals", "slot", "buf", "rot", "el", "index", "pid", "b", "vol", "len", "loc", "VAL", "base", "Val", "v", "eval", "block", "pt", "lit", "x", "prop", "value"], "size": ["str", " bytes", "Size", "bytes", "address", "fee", "data", "args", "unit", "mem", "value", "length", " length", "len", "SIZE", "eval", "padding", "type"], "s": ["ions", "i", "sb", "ips", "e", "sym", "qs", "es", "sl", "uns", "g", "ses", "an", "private", "d", "sets", "ops", "as", "ks", "ds", "services", "f", "sys", "t", "r", "u", "m", "its", "ssl", "os", "p", "ts", "cs", "us", "o", "ls", "sync", "is", "sg", "c", "js", "settings", "opens", "ows", "si", "a", "b", "w", "service", "se", "session", "S", "n", "ns", "ps", "rs", "gs", "south", "v", "grades", "secondary", "scope", "server", "l", "x", "ss", "states"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_error(QEMUFile *f, int ret)\n\n{\n\n    if (f->last_error == 0) {\n\n        f->last_error = ret;\n\n    }\n\n}\n", "idx": 22431, "substitutes": {"f": ["fc", "i", "e", "ref", "fs", "g", "this", "framework", "file", "fb", "rf", "fp", "df", "t", "m", "tif", "new", "p", "fx", "inf", "cf", "o", "af", "c", "self", "fr", "tf", "w", "ff", "fd", "F", "fw", "sf", "fen", "v", "bf", "lf", "l", "fo", "elf"], "ret": ["reg", "red", "en", "xt", "ref", "result", "val", "arg", "det", "rep", "Ret", "mt", "al", "res", "cat", "rets", "arr", "id", "ext", "RET", "rt", " Ret", "mem", "reply", "re", "pat", "pret", "back", "alt", "ry", "nt", "lit", "att", "resp", "fun"]}}
{"project": "FFmpeg", "commit_id": "d9051f8f3e60768f68867c3e3116e980d855215a", "target": 1, "func": "static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)\n\n{\n\n    int16_t *block = ctx->dct_block;\n\n    unsigned int pos;\n\n\n\n    ctx->bdsp.clear_block(block);\n\n\n\n    block[0] = get_bits(&ctx->gb, 8) << 3;\n\n\n\n    for (pos = 1; pos < num_coeffs; pos++) {\n\n        uint32_t vlc, num_bits;\n\n        int value;\n\n        int coeff;\n\n\n\n        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);\n\n        if (!vlc) /* end-of-block code */\n\n            return 0;\n\n        if (vlc == -1)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        /* pos_add and num_bits are coded in the vlc code */\n\n        pos     += vlc & 15; // pos_add\n\n        num_bits = vlc >> 4; // num_bits\n\n\n\n        if (pos >= 64)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        value = get_bits(&ctx->gb, num_bits);\n\n\n\n        /* FFmpeg's IDCT behaves somewhat different from the original code, so\n\n         * a factor of 4 was added to the input */\n\n\n\n        coeff = vlcdec_lookup[num_bits][value];\n\n        if (pos < 3)\n\n            coeff *= 16;\n\n        else /* TODO Use >> 10 instead of / 1001 */\n\n            coeff = (coeff * qscale) / 1001;\n\n\n\n        block[ctx->scantable.permutated[pos]] = coeff;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14639, "substitutes": {"ctx": ["support", " context", "context", "tx", "cam", "bc", "cm", "qa", "pkg", "cv", "ca", "sync", "config", "pc", "cc", "utils", "Context", "connection", "ctrl", "ci", "cs", "lc", "conv", "kernel", "cn", "cms", "wcs", "cmp", "sq", "fp", "loc", "ct", "conf", "conn", "client", "kw", "cli", "nc", "ck", "tc", "cus", "concept", "rx", "gb", "cfg", "c", "cca", "crit", "cu", "anc", "cb", "cas", "sci", "sc", "cmd", "cf", "cp", "que", "kb", "exec", "xc", "cache", "css", "prefix", "fc", "hw", "cpp"], "num_coeffs": ["num_coefficientp", "num_COeffp", "num_coefficients", "num_coeffi", "num_coefficientss", "num_coefficientsi", "num_coeffp", "num_COeffd", "num_coeffes", "num_coffd", "num_coefficientsp", "num_coefes", "num_coefficientses", "num_coefp", "num_coffs", "num_coffp", "num_coffi", "num_coeffd", "num_coffes", "num_COffes", "num_COffp", "num_COffd", "num_coefficientes", "num_COeffs", "num_coefficientsd", "num_coefi", "num_COeffes", "num_coefficientd", "num_coefs", "num_COffs"], "qscale": [" qcale", " qScale", "bitnorm", "bitcale", "qScale", "kScale", "bitdata", "qudata", " qnorm", "quscale", " qdata", "qnorm", "Qscale", "qcale", "qucale", "kcale", "qdata", "kscale", "QScale", "Qcale", "bitscale", "qunorm"], "block": ["channel", "map", "record", "board", "blocks", "bin", "tx", "bc", "slice", "batch", "bb", "object", "label", "pre", "range", "row", "Block", "image", "section", "panel", "pool", "ref", "buffer", "unit", "position", "comment", "session", "error", "table", "frame", "job", "chain", "bar", "group", "clean", "dict", "pack", "buf", "b", "byte", "base", "bit", "length", "box", "list", "point", "line", "address", "flow", "number", "type", "bo", "layout", "cache", "work", "lock", "bl", "node"], "pos": ["port", "part", "slot", "po", "slice", "pc", "val", "i", "pt", "style", "def", "ass", "cond", "nos", " position", "sp", "pose", "os", "x", "ref", "unit", "post", "position", "loc", "pres", "POS", "pid", "conf", "limit", "col", "obj", "pass", "size", "p", "comp", "pointer", "axis", "base", "min", "j", "length", "opp", "n", "f", "padding", "spec", "neg", "diff", "type", "offset", "pro", "rot", "Pos", "prop", "no", "num", "rel", "len", "index", "start"], "vlc": ["vlci", "lipc", "llcs", "wlp", "vllc", "klcs", "lvcs", "nlc", "wlf", "nlcs", "nlce", "kllc", "lvcu", "lvlc", "liplc", "velci", "wlac", "lvf", "llci", "svci", "klce", "vlrc", "velc", "vlf", "svc", "wlci", "lvci", "lllc", "vlcs", "velf", "lvp", "vlcu", "llce", "wllc", "llc", "lipcs", "velcs", "lipcu", "llrc", "lvrc", "vlct", "wlcs", "nlct", "llf", "klct", "klc", "velp", "llcu", "llct", "svcs", "vlce", "vlp", "llac", "lvac", "vlac", "svrc", "klf", "wlc", "llp", "lvc"], "num_bits": ["max_details", " num_bit", "num_flags", "num_locks", " num_points", "num_points", "numlogbit", "max_parts", "numloglocks", " num_flags", "num_parts", "num__bits", "num__locks", " num_locks", "num_bs", " num_bs", "numlogbits", "num_bytes", "numlogpoints", "numLhours", "num_details", "numLflags", "numLbits", "num_hours", "numLbit", "num_bit", "max_bits", " num_hours", " num_bytes", "num__bit", "num__points", "max_bit"], "value": ["port", "val", "object", "child", "current", "range", "name", "values", "VALUE", "image", "weight", "null", "unit", "position", "total", "comment", "key", "valid", "v", "limit", "wave", "size", "dev", "version", "cost", "Value", "sec", "data", "length", "flow", "address", "number", "start", "type", "offset", "function", "scale", "field", "num", "len", "max", "index", "message"], "coeff": ["microefficient", "COef", "noefficient", "colleffect", "coff", "collef", "COefficient", " coff", "Coff", "opeffect", "corort", "cef", "coref", "opeff", "collefficient", "Coef", "noef", "coefficient", "coef", "COff", "microeffect", "microef", "Coort", "coeffect", "ceff", "noff", "opef", "coort", "opefficient", "microeff", "noeff", "colleff", "cff", "Coeffect", "coreffect", "Coefficient", " coefficient", " coeffect", "Coeff", "COeff", "coreff", " coef", "cefficient", " coort"]}}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_dct_init_x86(DCTContext *s)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_SSE(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse;\n\n    if (EXTERNAL_SSE2(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse2;\n\n    if (EXTERNAL_AVX(cpu_flags))\n\n        s->dct32 = ff_dct32_float_avx;\n\n}\n", "idx": 12927, "substitutes": {"s": ["sys", "m", "ses", "parts", "t", "sync", "fs", "l", "rs", "g", "cs", "qs", "hs", "settings", "os", "uses", "its", "h", "sets", "es", "js", "ps", "ss", "an", "p", "e", "sf", "features", "f", "gs", "ns", "c", "ans", "ats", "stats", "ssl", "ops", "services", "r", "states", "ls", "ips", "ts", "us", "aws"]}}
{"project": "qemu", "commit_id": "8d0bcba8370a4e8606dee602393a14d0c48e8bfc", "target": 0, "func": "int net_init_socket(const NetClientOptions *opts, const char *name,\n\n                    NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    Error *err = NULL;\n\n    const NetdevSocketOptions *sock;\n\n\n\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_SOCKET);\n\n    sock = opts->socket;\n\n\n\n    if (sock->has_fd + sock->has_listen + sock->has_connect + sock->has_mcast +\n\n        sock->has_udp != 1) {\n\n        error_report(\"exactly one of fd=, listen=, connect=, mcast= or udp=\"\n\n                     \" is required\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_localaddr && !sock->has_mcast && !sock->has_udp) {\n\n        error_report(\"localaddr= is only valid with mcast= or udp=\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_fd) {\n\n        int fd;\n\n\n\n        fd = monitor_fd_param(cur_mon, sock->fd, &err);\n\n        if (fd == -1) {\n\n            error_report_err(err);\n\n            return -1;\n\n        }\n\n        qemu_set_nonblock(fd);\n\n        if (!net_socket_fd_init(peer, \"socket\", name, fd, 1)) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_listen) {\n\n        if (net_socket_listen_init(peer, \"socket\", name, sock->listen) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_connect) {\n\n        if (net_socket_connect_init(peer, \"socket\", name, sock->connect) ==\n\n            -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_mcast) {\n\n        /* if sock->localaddr is missing, it has been initialized to \"all bits\n\n         * zero\" */\n\n        if (net_socket_mcast_init(peer, \"socket\", name, sock->mcast,\n\n            sock->localaddr) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    assert(sock->has_udp);\n\n    if (!sock->has_localaddr) {\n\n        error_report(\"localaddr= is mandatory with udp=\");\n\n        return -1;\n\n    }\n\n    if (net_socket_udp_init(peer, \"socket\", name, sock->udp, sock->localaddr) ==\n\n        -1) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 19003, "substitutes": {"opts": ["optks", "otts", " opters", "ocks", "OPts", " optt", "octt", " opps", "ots", "otds", " opcs", "opters", "ops", "obcs", "otks", "opps", "opcs", "ottt", "otters", "opks", "optts", "obks", "obts", "octs", " opks", "obps", "optps", "otcs", "OPs", "optcs", "optds", "optt", "octers", "OPcs", "OPds", "opds"], "name": ["part", "time", "call", "base", "options", "ame", "conn", "comment", "n", "str", "on", "type", "am", "node", "nam", "sea", "Name", "mini", "active", "filename", "self", "username", "ip", "home", "host", "nm", "NAME", "alias", "old", "new", "path", "up", "common", "size", "like", "large", "style", "space", "no", "prefix", "named", "key", "id", "client", "parent", "temp", "ni", "url", "address", "none", "resource", "cap", "names", "connection", "addr", "port", "server", "word", "version", "hello"], "peer": ["pc", "plugin", "part", "instance", "point", "request", "mode", "vr", "pool", "buffer", "pe", "worker", "loader", "channel", "cb", "master", "attr", "type", "node", "phase", "package", "player", "root", "scope", "wheel", "owner", "fork", "host", "context", "layer", "chain", "pkg", "seed", "wire", "socket", "ssl", "remote", "client", "parent", "rb", "slave", "address", "http", "ker", "proc", "wrapper", "er", "addr", "state", "connection", "port", "server", "pro", "message", "source", "conn", "reader"], "errp": ["erp", "errps", "rrps", "nerps", "errr", "nerp", "rrr", "rrp", "nerr", "erps"], "err": ["rx", "rr", "fr", "rage", "db", "conf", "ref", "runner", "eor", "reader", "fe", "r", "md", "rc", "fi", "inc", "ar", "str", " er", "exc", "cb", "or", "rh", "loc", "msg", "ind", "cer", "der", "ise", "resp", "kr", "ee", "ln", "mr", "rar", "dy", "ev", "rn", "ler", "dr", "lr", "e", "cr", "acer", "req", "rb", "dev", "ir", "doc", "fee", "error", "sys", "Er", "er", "iter", "Error", "gr", "attr", "conn", "bug"], "sock": ["sink", " slock", "say", "inock", " socket", "sck", "opensocket", "sslock", "nsoke", "osoke", "symoke", "confoke", "sslig", "svoke", "confock", "dsoco", " socol", "dsct", "dah", "sct", " siv", " song", "opensoc", "insoke", "psock", "sah", "scho", "dsock", "absock", "slock", "octoke", "toco", "soke", "servock", "psocket", "socks", "socket", "high", " sah", "enssocket", " sct", "ansocket", "psoke", " ssocket", "svock", " scho", "osock", "nock", "symink", "ensock", "sesong", "unsolve", "hsock", "gsolve", "octink", "pck", "octock", "siv", "alsocket", "passoke", " sig", "ssleth", "conflock", "alsolve", "ensvc", "insock", "octocket", "noy", "hsocket", "slib", "sect", "absoke", " svc", "sesocks", "sesvc", "sesocket", " say", "insocket", "noco", "hock", "symeth", "servoke", " solve", "fsay", "sigh", "sloke", "symod", "seth", "bock", "unsell", "gsell", " sink", "opensock", "dong", "sinock", "gsong", "yourock", "soc", "sesock", "insoy", "tah", "ensod", "dsigh", "passocol", "tocks", "holl", "nigh", "scall", "youroc", "absink", "nib", " soc", "boy", "absocket", "boke", "alscall", "nsock", "youriv", "alsell", "hsocks", "slink", "fsoc", "solve", "song", "socol", "inscho", "sib", "dock", "symock", "sesct", "soy", "sloy", "gsoco", "svvc", "alsoke", "sslink", "alsock", "osoup", " sod", "passink", "hocks", "tong", "soll", "hoco", "sinoke", " soco", "unscall", "sinoc", "soco", "gsigh", " sect", "fsiv", "pocks", "ansock", "pink", "confoc", "sig", "sell", " seth", "nsocket", "svink", " sck", "gscall", "nocket", "insink", "nsoy", "passock", "gsink", "dsocks", "slocket", "tock", "sinocket", "hsoll", "obsock", "dect", "gsocket", " socks", "hocket", "soup", "bocket", "obsoco", "symsocket", "pock", "unsock", "svc", "sinocks", "obsoke", "gsoke", "inoke", "inoup", "insoup", "sinong", "gscho", "tect", " sigh", " sib", "ansoke", "dsvc", "ssocket", "inocket", "alsoy", "fsock", "symvc", " soke", " soy", "tigh", "tocket", "servong", "symig", "servigh", "gsock", "youray", "slocol", "psoy", "obsolve", "osocket", "opensoke", "sod", "ansoy"], "fd": ["dc", "dd", "dn", "db", "pid", "ff", "nd", "fp", "fw", "f", "bind", "dir", "func", "conn", "fe", "md", "poll", "pd", "fun", "fa", "cf", "cb", "wb", "dt", " fid", "fc", "dl", " f", "wd", "timeout", "fin", "fs", "sd", "fed", "lf", "ln", "fx", "d", "fl", "df", "wat", "nc", "bf", "socket", "dy", "bd", "pipe", "handler", "fb", "buf", "da", "flo", "driver", "wr", "fee", "fm", "fn", "cd", "write", "connection", "port", "fi", "FD"]}}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static inline int test_bit(uint32_t *field, int bit)\n\n{\n\n    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;\n\n}\n", "idx": 11911, "substitutes": {"field": ["round", "map", "filter", "holder", "flag", "window", "key", "class", "record", "pad", "fields", "card", "FIELD", "fred", "data", "block", "rule", "style", "group", "f", "entry", "slice", "index", "input", "event", "end", "Field", "object", "address", "inner", "patch", "type", "form", "layer", "message", "result", "match", "seed", "buffer"], "bit": ["hit", "byte", "BIT", "fix", "it", "flag", "key", "word", "no", "quad", "tag", "b", "num", "i", "apt", "big", "ct", "slot", "letter", "band", "arg", "Bit", "value", "fact", "bug", "number", "act", "bits", "op", "ac", "f", "unit", "index", "digit", "opt", "feature", "bot", "option", "token", "patch", "part", "offset", "col", "type", "cat", "ip", "bin", "text", "feat"]}}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qint_get_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = 123456;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qint_get_int(qi) == value);\n\n\n\n    QDECREF(qi);\n\n}\n", "idx": 218, "substitutes": {"qi": ["Q", "li", "gi", "q", "quad", "fen", "qs", "ei", "ii", "zi", "chi", "lli", "ni", "pi", "mini", "di", "cci", "ffe", "iq", "i", "eni", "iaz", "plug", "aka", "pai", "ani", "ini", "dq", "ai", "ie", "adi", "bi", "iana", "ahi", "sq", "gui", "jp", "qa", "agi", "ci", "mu", "qt", "fi", "qq", "si", "qua", "xi"]}}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,\n\n                               TCGMemOp s_bits, int which)\n\n{\n\n    const TCGReg r0 = TCG_REG_O0;\n\n    const TCGReg r1 = TCG_REG_O1;\n\n    const TCGReg r2 = TCG_REG_O2;\n\n    int tlb_ofs;\n\n\n\n    /* Shift the page number down.  */\n\n    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);\n\n\n\n    /* Mask out the page offset, except for the required alignment.  */\n\n    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,\n\n                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n\n\n    /* Mask the tlb index.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);\n\n    \n\n    /* Mask page, part 2.  */\n\n    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);\n\n\n\n    /* Shift the tlb index into place.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);\n\n\n\n    /* Relative to the current ENV.  */\n\n    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);\n\n\n\n    /* Find a base address that can load both tlb comparator and addend.  */\n\n    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);\n\n    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {\n\n        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);\n\n        tlb_ofs &= 0x3ff;\n\n    }\n\n\n\n    /* Load the tlb comparator and the addend.  */\n\n    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);\n\n    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));\n\n\n\n    /* subcc arg0, arg2, %g0 */\n\n    tcg_out_cmp(s, r0, r2, 0);\n\n\n\n    /* If the guest address must be zero-extended, do so now.  */\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);\n\n        return r0;\n\n    }\n\n    return addr;\n\n}\n", "idx": 5304, "substitutes": {"s": ["groups", "stat", "sets", "sf", "v", "is", "S", "a", "http", "spec", "sg", "session", "b", "socket", "si", "i", "sync", "rows", "sys", "ses", "services", "m", "ions", "support", "states", "info", "xs", "l", "f", "client", "details", "ns", "private", "d", "server", "stats", "us", "cs", "conf", "u", "native", "e", "w", "sb", "gs", "secondary", "t", "qs", "ds", "ctx", "n", "self", "p", "settings", "h", "fs", "c", "g", "ssl", "sq", "sym", "site", "current", "r", "js"], "addr": ["address", "dr", "name", "cmp", "layer", "host", "reg", "arm", "rt", "spec", "sg", "config", "Address", "x", "data", "rc", "slice", "xp", "alias", "ace", "mac", "offset", "add", "nr", "ack", "align", "sid", "ar", "ctx", "rx", "nil", "seq", "p", "amp", "asm", "usr", "ptr", "flags", "pointer", "proc", "class", "type", "amd", "ord", "sample", "arch", "ref", "rs", "src", "conn", "pkg", "Error", "size"], "mem_index": ["Mem_Index", "mem_position", "mem_mask", "mem_Index", "mem_slice", "memfIndex", " mem_mask", "memfindex", "memingindex", "Mem_position", "Mem_index", " mem_slice", "memingmask", "memfposition", "memingslice"], "s_bits": ["S_bits", "s2bits", "s5bytes", "num_bytes", "s2flags", "s5length", "s2BIT", "S_BIT", "s5bits", "s_length", "S_bit", "S_flags", "s_flags", "num_length", "s_BIT", "s2bit", "num_bits", "s_bytes", "s_bit", "s_lins", "num_lins", "s5lins"], "which": ["est", "extra", "spec", "config", "rc", "dest", "loc", "mac", "num", "how", " rc", "version", " how", "func", "port", "ctx", " mode", "hift", " unused", "asm", "where", "supp", "proc", "who", "desc", "test", "src", "mode", "shift"], "tlb_ofs": ["tlb_ifp", "tlb_Ofb", "tlb_ifs", "tlb_offs", "tlb_ofn", "tlb_lengths", "tlb_offts", "tlb_offhs", "tlb_OFs", "tlb_ofi", "tlb_lengthd", "tlb_lengthb", "tlb__ofc", "tlb_Ofn", "tlb_effds", "tlb_offds", "tlb_nots", "tlb_lengthts", "tlb_lengthc", "tlb_notits", "tlb__ofd", "tlb_ofp", "tlb_ofds", "tlb_lengthits", "tlb_Ofds", "tlb_OFd", "tlb_effb", "tlb_ofb", "tlb_effs", "tlb_lengthn", "tlb_Ofd", "tlb_Ofc", "tlb_lengthp", "tlb_effhs", "tlb_ifd", "tlb_Ofhs", "tlb__ofs", "tlb_OFb", "tlb_notds", "tlb_offp", "tlb_ofhs", "tlb_offd", "tlb_notts", "tlb__ofb", "tlb_ofits", "tlb_Ofi", "tlb_notd", "tlb_Ofs", "tlb_lengthds", "tlb_notp", "tlb_offb", "tlb_ofd", "tlb_OFds", "tlb_ifts", "tlb_ofts", "tlb_ofc", "tlb_lengthi"]}}
{"project": "FFmpeg", "commit_id": "d7da4d47a6841444f12bf56dfe4230d3e4af8646", "target": 1, "func": "static int mxf_read_header(AVFormatContext *s)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    KLVPacket klv;\n\n    int64_t essence_offset = 0;\n\n    int ret;\n\n\n\n    mxf->last_forward_tell = INT64_MAX;\n\n    mxf->edit_units_per_packet = 1;\n\n\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, -14, SEEK_CUR);\n\n    mxf->fc = s;\n\n    mxf->run_in = avio_tell(s->pb);\n\n\n\n    while (!url_feof(s->pb)) {\n\n        const MXFMetadataReadTableEntry *metadata;\n\n\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n\n            /* EOF - seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        PRINT_KEY(s, \"read header\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n\n\n            if (!mxf->current_partition) {\n\n                av_log(mxf->fc, AV_LOG_ERROR, \"found essence prior to first PartitionPack\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            if (!mxf->current_partition->essence_offset) {\n\n                /* for OP1a we compute essence_offset\n\n                 * for OPAtom we point essence_offset after the KL (usually op1a_essence_offset + 20 or 25)\n\n                 * TODO: for OP1a we could eliminate this entire if statement, always stopping parsing at op1a_essence_offset\n\n                 *       for OPAtom we still need the actual essence_offset though (the KL's length can vary)\n\n                 */\n\n                int64_t op1a_essence_offset =\n\n                    round_to_kag(mxf->current_partition->this_partition +\n\n                                 mxf->current_partition->pack_length,       mxf->current_partition->kag_size) +\n\n                    round_to_kag(mxf->current_partition->header_byte_count, mxf->current_partition->kag_size) +\n\n                    round_to_kag(mxf->current_partition->index_byte_count,  mxf->current_partition->kag_size);\n\n\n\n                if (mxf->op == OPAtom) {\n\n                    /* point essence_offset to the actual data\n\n                    * OPAtom has all the essence in one big KLV\n\n                    */\n\n                    mxf->current_partition->essence_offset = avio_tell(s->pb);\n\n                    mxf->current_partition->essence_length = klv.length;\n\n                } else {\n\n                    /* NOTE: op1a_essence_offset may be less than to klv.offset (C0023S01.mxf)  */\n\n                    mxf->current_partition->essence_offset = op1a_essence_offset;\n\n                }\n\n            }\n\n\n\n            if (!essence_offset)\n\n                essence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else if (mxf->parsing_backward)\n\n                continue;\n\n            /* we're still parsing forward. proceed to parsing this partition pack */\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n\n\n                    /* only seek forward, else this can loop for a long time */\n\n                    if (avio_tell(s->pb) > next) {\n\n                        av_log(s, AV_LOG_ERROR, \"read past end of KLV @ %#\"PRIx64\"\\n\",\n\n                               klv.offset);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    /* we need to do this before computing the index tables\n\n     * to be able to fill in zero IndexDurations with st->duration */\n\n    if ((ret = mxf_parse_structural_metadata(mxf)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = mxf_compute_index_tables(mxf)) < 0)\n\n        return ret;\n\n\n\n    if (mxf->nb_index_tables > 1) {\n\n        /* TODO: look up which IndexSID to use via EssenceContainerData */\n\n        av_log(mxf->fc, AV_LOG_INFO, \"got %i index tables - only the first one (IndexSID %i) will be used\\n\",\n\n               mxf->nb_index_tables, mxf->index_tables[0].index_sid);\n\n    } else if (mxf->nb_index_tables == 0 && mxf->op == OPAtom) {\n\n        av_log(mxf->fc, AV_LOG_ERROR, \"cannot demux OPAtom without an index\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    mxf_handle_small_eubc(s);\n\n\n\n    return 0;\n\n}\n", "idx": 23206, "substitutes": {"s": ["sv", "i", "es", "xs", "ds", "sys", "r", "ssl", "os", "ts", "cs", "us", "stats", "js", "aws", "n", "S", "ns", "rs", "http", "v", "conf", "l", "ss", "sb", "g", "ses", "d", "sets", "site", "services", "o", "sg", "c", "spec", "sc", "sf", "su", "native", "e", "sym", "qs", "serv", "fs", "com", "f", "t", "new", "p", "si", "b", "service", "gs", "sec", "secondary", "sq", "sci", "sl", "ops", "m", "storage", "ls", "sync", "is", "client", "settings", "single", "source", "se", "session", "south", "server"], "mxf": ["ncf", "nxc", "gxc", "Mcf", "mfc", "fmcf", "dxf", "dxd", "dxc", "fmxc", "Mxc", "mxd", "nxf", "Mxf", " mxd", "cmxf", "Mxe", "gxd", "nxd", "fmxe", "Mxa", "dxe", "gxf", "Mxd", "cmxd", "cmcf", "mcf", "mxa", "cmxc", "pxc", " mcf", "mxe", " mxe", "pcf", "pxd", " mxc", "gxe", "mxc", "cmfc", " mfc", "fmxf", "Mfc", "dcf", "pxf", " mxa", "nxa", "nfc", "cmxe", "nxe", "fmxd"], "klv": ["kvl", "cklv", "kela", "Kql", "keLV", "kln", "knvi", "kvc", "kswl", "okwl", "mlv", "sklf", " kql", "skla", "skql", " kwl", "okrl", "klc", "skln", "kLV", "skrl", " klf", " kvl", "kla", "skvi", "kslv", "ikLV", "skLV", "kevc", "Kln", "kql", "Kwl", "klf", "ikwl", "kwl", " kll", "sklp", "kelp", "mlp", "cklc", "Klc", "oklp", "mLV", "uklc", "ukvl", "uklv", "skvc", "kll", "iklv", "okvm", "ckwl", "uklf", "okln", "okvl", " klc", "kelv", "Kvm", "kvm", "sklv", "Klf", "ikvl", "kvi", "cklf", "oklf", "Kvl", "kslc", "ksll", "skvm", " kLV", "Klv", "ckll", "klp", "mrl", "okvc", "kevi", "okLV", "oklv", "knlv", "knla", "knlp", "sklc", "krl"], "ret": ["col", " val", "def", " success", "val", "rep", " flags", "Ret", " resp", " RET", "rc", "num", "RET", " Ret", "ry", "nt"], "metadata": ["ATA", "package", "summary", "message", "meta", "json", "node", "ata", "info", "entry", "m", "data", "description", "params", "annot", "o", "filename", "adata", "header", "tmp", "iterator", "details", "definition", "parser", "options", "met", "stream", "ma"]}}
{"project": "FFmpeg", "commit_id": "cd1047f3911fa0d34c86f470537f343d23c8b956", "target": 0, "func": "static int qsv_decode_init(AVCodecContext *avctx, QSVContext *q)\n\n{\n\n    const AVPixFmtDescriptor *desc;\n\n    mfxSession session = NULL;\n\n    int iopattern = 0;\n\n    mfxVideoParam param = { { 0 } };\n\n    int frame_width  = avctx->coded_width;\n\n    int frame_height = avctx->coded_height;\n\n    int ret;\n\n\n\n    desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);\n\n    if (!desc)\n\n        return AVERROR_BUG;\n\n\n\n    if (!q->async_fifo) {\n\n        q->async_fifo = av_fifo_alloc((1 + q->async_depth) *\n\n                                      (sizeof(mfxSyncPoint*) + sizeof(QSVFrame*)));\n\n        if (!q->async_fifo)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    if (avctx->pix_fmt == AV_PIX_FMT_QSV && avctx->hwaccel_context) {\n\n        AVQSVContext *user_ctx = avctx->hwaccel_context;\n\n        session           = user_ctx->session;\n\n        iopattern         = user_ctx->iopattern;\n\n        q->ext_buffers    = user_ctx->ext_buffers;\n\n        q->nb_ext_buffers = user_ctx->nb_ext_buffers;\n\n    }\n\n\n\n    if (avctx->hw_frames_ctx) {\n\n        AVHWFramesContext    *frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n        AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;\n\n\n\n        if (!iopattern) {\n\n            if (frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME)\n\n                iopattern = MFX_IOPATTERN_OUT_OPAQUE_MEMORY;\n\n            else if (frames_hwctx->frame_type & MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET)\n\n                iopattern = MFX_IOPATTERN_OUT_VIDEO_MEMORY;\n\n        }\n\n\n\n        frame_width  = frames_hwctx->surfaces[0].Info.Width;\n\n        frame_height = frames_hwctx->surfaces[0].Info.Height;\n\n    }\n\n\n\n    if (!iopattern)\n\n        iopattern = MFX_IOPATTERN_OUT_SYSTEM_MEMORY;\n\n    q->iopattern = iopattern;\n\n\n\n    ret = qsv_init_session(avctx, q, session, avctx->hw_frames_ctx);\n\n    if (ret < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing an MFX session\\n\");\n\n        return ret;\n\n    }\n\n\n\n    ret = ff_qsv_codec_id_to_mfx(avctx->codec_id);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    param.mfx.CodecId      = ret;\n\n    param.mfx.CodecProfile = avctx->profile;\n\n    param.mfx.CodecLevel   = avctx->level;\n\n\n\n    param.mfx.FrameInfo.BitDepthLuma   = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.BitDepthChroma = desc->comp[0].depth;\n\n    param.mfx.FrameInfo.Shift          = desc->comp[0].depth > 8;\n\n    param.mfx.FrameInfo.FourCC         = q->fourcc;\n\n    param.mfx.FrameInfo.Width          = frame_width;\n\n    param.mfx.FrameInfo.Height         = frame_height;\n\n    param.mfx.FrameInfo.ChromaFormat   = MFX_CHROMAFORMAT_YUV420;\n\n\n\n    param.IOPattern   = q->iopattern;\n\n    param.AsyncDepth  = q->async_depth;\n\n    param.ExtParam    = q->ext_buffers;\n\n    param.NumExtParam = q->nb_ext_buffers;\n\n\n\n    ret = MFXVideoDECODE_Init(q->session, &param);\n\n    if (ret < 0)\n\n        return ff_qsv_print_error(avctx, ret,\n\n                                  \"Error initializing the MFX video decoder\");\n\n\n\n    q->frame_info = param.mfx.FrameInfo;\n\n\n\n    return 0;\n\n}\n", "idx": 23714, "substitutes": {"avctx": ["ajcv", "devcontext", "avecu", "aveconfig", "aveloc", "AVconfig", "AVcmp", "avcv", "vercontext", "vercu", "ajcontext", "devcmp", "verconn", "avsq", "afctl", "averctl", "afcmp", "avconn", "verctx", "avconfig", "AVcontext", "afctx", "avercontext", "AVcu", "Avconfig", " avbc", "averctx", "navctx", "Avcontext", "AVclient", "avecontext", " avcmp", "aveclient", " avsq", "afcu", "avbc", "avecv", "afsq", "Avcu", "AVsq", "avcu", "avcontext", "navconn", "avctl", "AVconn", "vercmp", "averconn", "navctl", "avclient", " avloc", "AVbc", "afconfig", "devconfig", "ajctx", "avectx", "avcmp", "Avctx", "navcmp", "afcontext", "AVctx", "AVcv", "afconn", " avcontext", "ajclient", "avebc", "AVloc", "devctx", "navcontext", "avloc"], "q": ["request", "view", "query", "qs", "qi", "conn", "eq", "config", "g", "input", "Q", "post", "ack", "queue", "d", "qq", "get", "f", "t", "u", "cmd", "m", "ue", "qu", "ad", "p", "cf", "que", "context", "client", "c", "ctx", "self", "ch", "cal", "dq", "window", "question", "w", "quant", "quest", "qa", "session", "iq", "req", "batch", "v", "qt", "conf", "z", "user", "h", "sq", "k", "requ"], "desc": ["lc", "bc", "fc", "name", "def", "esc", "uc", "config", "asc", "text", "meta", "der", "de", "d", "func", "rec", "cur", "anc", "dep", "dist", "env", "info", "dir", "nc", "description", "enc", "code", "comment", "ext", "rc", "la", "cb", "sc", "sub", "des", "dc", "session", "loc", "req", "doc", "sec", "Desc", "disc", "ec", "fun"], "ret": ["reg", "def", "valid", "result", "progress", "aud", "rep", "rec", "Ret", " quiet", " resp", "res", "cat", "arr", "success", "match", "RET", "flag", "re", "error", "alt", "sec", "resp", "fun"], "user_ctx": [" user_cmp", "use_cu", "user_cmp", "useringctx", " user_loc", "use_xc", "useringcontext", " user_conn", "user_wcs", "user_kb", "user_anc", " user_chan", "useringloc", "use_ctx", "useringcu", "user_xc", "use_wcs", " user_cu", "use_context", "use_kb", "user_chan", "user_cu", "user_loc", "use_cmp", " user_anc", "user_conn", "use_loc", "user_context"], "frames_ctx": ["frames___pkg", "flows_vc", "frames_vc", "flows_ctx", "frames_loc", "frames___vc", "frames_pkg", "frames___context", "flows_loc", "frames_ci", "flows_pkg", "frames_context", "flows_ci", "flows_context", "frames___ctx"], "frames_hwctx": ["frames_nvcontext", "frames_iwcf", "frames_nvctx", "frames_vcctx", "frames_hopcmd", "frames_vccf", "frames_hwcmd", "frames_hwrx", "frames_hhcmd", "frames_hwcontext", "frames_hmconfig", "frames_fwcontext", "frames_hopcontext", "frames_memconfig", "frames_navconfig", "frames_navcb", "frames_hwcf", "frames_iwcontext", "frames_fwchan", "frames_cowctx", "frames_hoprx", "frames_fwcmd", "frames_fwctx", "frames_cowchan", "frames_fwrx", "frames_hmctx", "frames_nvcp", "frames_nvchan", "frames_hhctx", "frames_hopctx", "frames_iwcb", "frames_hwcp", "frames_hwsec", "frames_hhcontext", "frames_vcconfig", "frames_navcontext", "frames_navctx", "frames_cowcp", "frames_iwsec", "frames_iwctx", "frames_iwconfig", "frames_cowcontext", "frames_hmcontext", "frames_hhrx", "frames_hwconfig", "frames_hwcb", "frames_fwcp", "frames_hwchan", "frames_memctx", "frames_memsec", "frames_hmcb", "frames_vcsec", "frames_memcf"]}}
{"project": "FFmpeg", "commit_id": "0232f788b6b0855db1771dbf8d7174e2eda2ff45", "target": 1, "func": "int swr_init(struct SwrContext *s){\n\n    s->in_buffer_index= 0;\n\n    s->in_buffer_count= 0;\n\n    s->resample_in_constraint= 0;\n\n    free_temp(&s->postin);\n\n    free_temp(&s->midbuf);\n\n    free_temp(&s->preout);\n\n    free_temp(&s->in_buffer);\n\n    swri_audio_convert_free(&s-> in_convert);\n\n    swri_audio_convert_free(&s->out_convert);\n\n    swri_audio_convert_free(&s->full_convert);\n\n\n\n    s-> in.planar= av_sample_fmt_is_planar(s-> in_sample_fmt);\n\n    s->out.planar= av_sample_fmt_is_planar(s->out_sample_fmt);\n\n    s-> in_sample_fmt= av_get_alt_sample_fmt(s-> in_sample_fmt, 0);\n\n    s->out_sample_fmt= av_get_alt_sample_fmt(s->out_sample_fmt, 0);\n\n\n\n    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->in_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->out_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLT){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, only float & S16 is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    //FIXME should we allow/support using FLT on material that doesnt need it ?\n\n    if(s->in_sample_fmt <= AV_SAMPLE_FMT_S16 || s->int_sample_fmt==AV_SAMPLE_FMT_S16){\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_S16;\n\n    }else\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_FLT;\n\n\n\n\n\n    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){\n\n        s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, 16, 10, 0, 0.8);\n\n    }else\n\n        swri_resample_free(&s->resample);\n\n    if(s->int_sample_fmt != AV_SAMPLE_FMT_S16 && s->resample){\n\n        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16 currently\\n\"); //FIXME\n\n        return -1;\n\n    }\n\n\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n\n\n    if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){\n\n        av_log(s, AV_LOG_WARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\");\n\n        s-> in_ch_layout= 0;\n\n    }\n\n\n\n    if(!s-> in_ch_layout)\n\n        s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count);\n\n    if(!s->out_ch_layout)\n\n        s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count);\n\n\n\n    s->rematrix= s->out_ch_layout  !=s->in_ch_layout || s->rematrix_volume!=1.0;\n\n\n\n#define RSC 1 //FIXME finetune\n\n    if(!s-> in.ch_count)\n\n        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n    if(!s->out.ch_count)\n\n        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\nav_assert0(s-> in.ch_count);\n\nav_assert0(s->used_ch_count);\n\nav_assert0(s->out.ch_count);\n\n    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;\n\n\n\n    s-> in.bps= av_get_bytes_per_sample(s-> in_sample_fmt);\n\n    s->int_bps= av_get_bytes_per_sample(s->int_sample_fmt);\n\n    s->out.bps= av_get_bytes_per_sample(s->out_sample_fmt);\n\n\n\n    if(!s->resample && !s->rematrix && !s->channel_map){\n\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n\n        return 0;\n\n    }\n\n\n\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n\n\n\n\n\n    s->postin= s->in;\n\n    s->preout= s->out;\n\n    s->midbuf= s->in;\n\n    s->in_buffer= s->in;\n\n    if(s->channel_map){\n\n        s->postin.ch_count=\n\n        s->midbuf.ch_count=\n\n        s->in_buffer.ch_count= s->used_ch_count;\n\n    }\n\n    if(!s->resample_first){\n\n        s->midbuf.ch_count= s->out.ch_count;\n\n        s->in_buffer.ch_count = s->out.ch_count;\n\n    }\n\n\n\n    s->in_buffer.bps = s->postin.bps = s->midbuf.bps = s->preout.bps =  s->int_bps;\n\n    s->in_buffer.planar = s->postin.planar = s->midbuf.planar = s->preout.planar =  1;\n\n\n\n\n\n    if(s->rematrix)\n\n        return swri_rematrix_init(s);\n\n\n\n    return 0;\n\n}\n", "idx": 17737, "substitutes": {"s": ["ns", "spec", "strings", "user", "settings", "service", "ions", "details", "ss", "cs", "d", "qs", "sym", "p", "ks", "h", "us", "sets", "m", "ts", "sg", "rs", "in", "su", "si", "S", "uses", "a", "hs", "an", "ds", "native", "phys", "f", "r", "sb", "as", "this", "l", "w", "serv", "vs", "sync", "c", "ps", "b", "sys", "es", "states", "sq", "params", "sf", "session", "t", "request", "conf", "services", "n", "plugins", "g", "i", "ls", "ops", "fs", "xs", "is", "args", "site", "e", "ssl", "ses", "js", "gs", "its", "os", "parts", "se", "server", "u"]}}
{"project": "FFmpeg", "commit_id": "8728360b5664ef9db31137d8d3104cac33b9a911", "target": 1, "func": "static av_cold int mp_decode_init(AVCodecContext *avctx)\n\n{\n\n    MotionPixelsContext *mp = avctx->priv_data;\n\n    int w4 = (avctx->width  + 3) & ~3;\n\n    int h4 = (avctx->height + 3) & ~3;\n\n\n\n    if(avctx->extradata_size < 2){\n\n        av_log(avctx, AV_LOG_ERROR, \"extradata too small\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    motionpixels_tableinit();\n\n    mp->avctx = avctx;\n\n    ff_dsputil_init(&mp->dsp, avctx);\n\n    mp->changes_map = av_mallocz(avctx->width * h4);\n\n    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;\n\n    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));\n\n    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_RGB555;\n\n    avcodec_get_frame_defaults(&mp->frame);\n\n    return 0;\n\n}", "idx": 20659, "substitutes": {"avctx": ["avecf", "ivcontext", "vercontext", "ajcli", "mediacf", " avcu", "AVc", "avconfig", "AVcu", "AVca", " avcm", "ovctx", "abconfig", "ovcf", "afcm", "groundcdn", "avcb", "avcms", "avobj", "afconfig", "ajctx", "vercb", "avcmp", "Avctx", "afconn", "avcli", "avecu", "aveconfig", "afobj", "ovcontext", "avcdn", "avecb", "verctx", "AVtx", "avcp", "avecp", "afctx", " avpkg", " avc", "ajcf", "avscope", "abobj", "avcontext", "aviacms", "ajconn", "mediactx", "AVctx", " avca", "afcp", "ivcu", "avpkg", "AVcf", " avcp", "ajcontext", "groundcontext", "Avca", "afcmp", "AVcli", "avcf", "afscope", "avca", "ivctx", "afpkg", " avcmp", "afcms", "AVcms", "ajscope", "afcu", "avcu", "aviactx", "AVconn", "abctx", "vercmp", "AVcdn", "afcb", "ovcli", "avectx", "afcontext", "Avtx", "ivcm", "AVcmp", "aviacmp", "afcf", "vercu", "verc", "afcdn", "verconn", "avconn", "AVcontext", "avecmp", "ajcdn", "Avcontext", "groundpkg", "avecontext", "aviacontext", "avecms", " avtx", "ovscope", "avcm", "groundctx", " avcdn", "avtx", "mediacms", "avc", "abcontext", "aveobj", " avcontext", "mediacontext"], "mp": ["md", "bc", "pb", "cam", "ph", "omp", "ap", "app", "jp", "lp", "amp", "lv", "av", "me", "mb", "pkg", "cv", "cm", "pm", "bb", "cop", "rup", "mt", "mom", "mic", "fp", "mpeg", "pg", "cmp", "op", "cp", "msg", "mo", "agg", "pp", "p", "mc", "MP", "ep", "mod", "mm", "context", "mac", "gg", "ip", "ctx", "lim", "pl", "wp", "match", "peer", "gp", "comp", "tmp", "fm", "ms", "par", "media", "craft", "ps", "Mp", "manager", "tm", "sp", "gm", "ppa", "cap", "capt"]}}
{"project": "qemu", "commit_id": "5819e3e072f41cbf81ad80d822a5c468a91f54e0", "target": 0, "func": "static void gdb_accept(void)\n\n{\n\n    GDBState *s;\n\n    struct sockaddr_in sockaddr;\n\n    socklen_t len;\n\n    int fd;\n\n\n\n    for(;;) {\n\n        len = sizeof(sockaddr);\n\n        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);\n\n        if (fd < 0 && errno != EINTR) {\n\n            perror(\"accept\");\n\n            return;\n\n        } else if (fd >= 0) {\n\n#ifndef _WIN32\n\n            fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* set short latency */\n\n    socket_set_nodelay(fd);\n\n\n\n    s = g_malloc0(sizeof(GDBState));\n\n    s->c_cpu = first_cpu;\n\n    s->g_cpu = first_cpu;\n\n    s->fd = fd;\n\n    gdb_has_xml = false;\n\n\n\n    gdbserver_state = s;\n\n\n\n    fcntl(fd, F_SETFL, O_NONBLOCK);\n\n}\n", "idx": 23855, "substitutes": {"s": ["sv", "sb", "i", "e", "sym", "sie", "sl", "g", "ses", "su", "d", "sets", "site", "so", "services", "f", "sys", "t", "r", "u", "m", "socket", "storage", "state", "ssl", "os", "p", "ts", "o", "ls", "sync", "stats", "ss", "sg", "js", "c", "client", "sd", "spec", "sa", "si", "b", "w", "service", "session", "S", "ns", "n", "sf", "ps", "rs", "south", "z", "v", "h", "server", "l", "sq"], "sockaddr": ["sighaddress", "sinkstr", "dsipaddr", "siglen", "dsipord", "sighord", "dsiplen", "sockstr", "dsockref", "sinkoa", "sckref", "sockaddress", "socksord", "sipord", "sockoa", "ionsipaddress", "ionsockaddr", "sackadd", "dsocklen", "dsipaddress", "ionsockaddress", "dsockord", "socksaddr", "ionsockoa", "ionsipaddr", "dsockaddress", "sinkaddr", "sighaddr", "sinkadd", "socklen", "sockref", "sckaddr", "sackoff", "sipstr", "siplen", "sockadd", " sipaddress", "sackaddr", "dsipref", "sighoa", "sinkaddress", "sipadd", " sockadd", "scklen", "sockord", "socksaddress", " sockoff", "sipoa", "ionsockstr", "sackaddress", "sigref", "sipref", "sipaddress", " sipoff", " sipadd", "sighstr", "ionsipoa", "sckaddress", "sigaddress", "sipoff", "sinkoff", " sipaddr", "sipaddr", " sockaddress", "dsockaddr", "ionsipstr", "sockoff", "sigaddr"], "len": ["lc", "limit", "en", "ie", "sl", "val", "part", "db", "d", "ln", "ld", "f", "pos", "lan", "ell", "size", "data", "fin", "lock", "id", "lin", "count", "elt", "dy", "el", "num", "line", "seq", "rev", "dl", "n", "length", " length", "ll", "fl", "loc", "lon", "lib", "ler", "alt", "nt", "li", "lf", "fn", "l", "base", "lic", "Len", "fun"], "fd": ["fc", "config", "director", "temp", "ds", "df", "fat", "hd", "dy", " df", "pid", "dl", "ff", "fw", "bd", "v", "pointer", "l", "fi", "format", "fin", "driver", "db", "d", "handler", "pd", "fp", "pipe", "dir", "fee", "fx", "buf", "c", "cb", " f", "dc", "flo", "sf", "feed", "fen", "ctl", " fin", "md", " FD", "fa", "e", "fs", "fb", "fax", "ln", "ld", "f", "dn", "exec", "dd", "nd", "cf", "sd", "dt", "fed", "flow", "bf", "lf", " ff", "fun", "td", "cd", "wd", "vd", "xd", "draft", "FD", "socket", " d", "fe", " fid", "fm", "fl", "fn", "FH"]}}
{"project": "qemu", "commit_id": "459db780be10f7adac723a5d3a4ffeac8ae6e768", "target": 1, "func": "envlist_parse(envlist_t *envlist, const char *env,\n\n    int (*callback)(envlist_t *, const char *))\n\n{\n\n\tchar *tmpenv, *envvar;\n\n\tchar *envsave = NULL;\n\n\n\n\tassert(callback != NULL);\n\n\n\n\tif ((envlist == NULL) || (env == NULL))\n\n\t\treturn (EINVAL);\n\n\n\n\t/*\n\n\t * We need to make temporary copy of the env string\n\n\t * as strtok_r(3) modifies it while it tokenizes.\n\n\t */\n\n\tif ((tmpenv = strdup(env)) == NULL)\n\n\t\treturn (errno);\n\n\n\n\tenvvar = strtok_r(tmpenv, \",\", &envsave);\n\n\twhile (envvar != NULL) {\n\n\t\tif ((*callback)(envlist, envvar) != 0) {\n\n\t\t\tfree(tmpenv);\n\n\t\t\treturn (errno);\n\n\t\t}\n\n\t\tenvvar = strtok_r(NULL, \",\", &envsave);\n\n\t}\n\n\n\n\tfree(tmpenv);\n\n\treturn (0);\n\n}\n", "idx": 11524, "substitutes": {"tmpenv": [" tmpen", "nowenv", "tmpen", "tmpv", " tmpv", "fakeenc", "tempconfig", "tmpenvironment", "testenv", "testconfig", "ntenv", " tmpenc", "ntenvironment", "tmpenc", "fakeen", "testenvironment", "tempviron", "ntviron", "fakeenvironment", " tmpconfig", "tempen", "tempenc", "tempenvironment", "nowenvironment", "testv", " tmpviron", "nowviron", " tmpenvironment", "tempenv", "fakeenv", "tmpconfig", "tmpviron", "tempv"], "envvar": ["encvar", "environmentname", "senconst", "environmentVar", "environmentver", "environmentlist", "encVar", " envVar", "envlist", "environmentvar", "encvari", "envcat", "evvari", "environmentcat", " envstack", " envname", "enbar", "evVar", "enccat", "envconst", "evname", "envbar", "envver", " envbar", "environmentconst", "envname", "environmentstack", "envvari", "envstack", "envVar", " envvari", " envlist", " envcat", " envconst", "enlist", "environmentvari", "senlist", "evvar", " envver", "encver", "senvar", "envar", "environmentbar", "enstack"], "envsave": ["enstsaved", "ennsave", " ensssave", " enssaved", "elstsaving", "enversaving", "envsource", "enssave", "encsave", "elstsaved", "envssave", " envssave", " enversaving", "ensssave", "envsaves", "elvsaved", "elstsave", "envalsave", "envsaving", "encsaves", " envsaver", " envsaves", "encssave", "elvsaving", " enversaves", "ennssave", "envaving", "envource", "elstsource", "enversave", " enversave", "enstsaving", " enversaver", "ennsaves", "ennsaving", "enversaves", " envsaved", "elvsave", "elvsource", "ennsaver", "envaved", "envalsaves", " enssaves", "envsaver", "enstsave", "encsaved", " envsaving", "envalsaver", "enstsource", "envalsaving", "envsaved", " enssave", "enssaves", "ennsaved", "envave", "enversaver", "enssaved", "ennsource"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,\n\n                                      int do_init,\n\n                                      const char *cpu_model,\n\n                                      uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    qemu_irq *irqs;\n\n\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    return cpu;\n\n}\n", "idx": 22931, "substitutes": {"ram_size": ["ram2len", "ram_len", "gram_count", "ram_address", "ram2size", "gram_len", "ram2count", "gram_address", "ram__count", "gram_size", "ram__len", "ram_count", "ram2address", "ram__size", "ram__address"], "do_init": ["do_load", "do_setup", "do_set"], "cpu_model": ["cpu_Model", "cpulexModel", "cpuamcontroller", " cpu_models", "cpulexmodel", " cpu_format", "cpulexmethod", "cpuammethod", "cpu_method", "cpu__format", "CPU_method", "cpu__models", "cpuamModel", "cpuammodel", " cpu__model", " cpu__format", "cpu__Model", "CPU_model", "cpu_models", " cpu__models", " cpu__Model", "cpu_format", " cpu_Model", "cpulexcontroller", "CPU_Model", "cpu__model", "cpu_controller", "CPU_controller"], "sysclk": ["sysClok", "sysplk", "ysclk", " sysCLok", "sysplok", "sysCLks", " sysclok", "sysblk", "ysclok", " sysCLk", "sysCLok", "sysblks", "sysblck", "ysclck", " sysCLks", "sysCLck", "sysplks", "sysblok", " sysclks", "ysCLk", "sysClks", "sysclks", "ysCLck", "ysclks", "ysCLok", "sysClk", "ysCLks", "sysclok", "sysplck", "sysclck", "sysCLk"], "cpu": ["lc", "platform", "computer", "bench", "hp", "net", "lb", "gpu", "conn", "linux", "config", "GPU", "eni", "performance", "none", "result", "processor", "process", "pc", "CPU", "css", "node", "fp", "cmp", "nc", "cp", "fps", "cache", "appa", "uno", "uci", "np", "cli", "pool", "px", "ctx", "c", "cn", "cfg", "gp", "pid", "uca", "loader", "PU", "cpp", "python", "core", "auc", "chip", "pai", "console", "boot", "proc", " CPU", "vm", "hw", "instance", "clock", "nu", "pu"], "env": ["exe", "config", "eni", "extra", "exc", "que", "context", "qa", "proc", "v", "conf", "ev", "inet", "priv", "txt", "password", "end", "conn", "db", "cv", "oa", "eng", "style", "pect", "dir", "dev", "state", "enc", "code", "ext", "cfg", "equ", "qt", "erv", "scope", "net", "stack", "e", "err", "eu", "agents", "ea", "exec", "init", "cf", "cli", "Environment", "el", "gui", "loader", "worker", "core", "req", "skin", "manager", "ec", "en", "inc", "shell", "energy", "export", "engine", "nc", "args", "cache", "vs", "np", "ctx", "agent", "profile", "viron", "session", "console", "vm", "anne", "estate", "server", "environment"], "irqs": ["irques", "IRqus", " irques", " irks", "iercks", "irks", "IRcks", "IRacks", "pirq", "irches", "ircks", "mirches", "IRquest", "irsches", " irq", "errq", "errqs", "miracks", "irql", "ierqus", " ircks", "pirques", "iracks", "pirqs", "ierches", "IRq", "irqus", "ierqs", "IRks", "ierql", "irquest", "pirquest", "IRques", "pircks", "irsq", "errquest", "mirq", "irsql", "mirks", "irsqs", "IRqs", "ierq", "errques", "mirqs", "irq", "mirql", " irqus", " iracks", "pirks"]}}
{"project": "qemu", "commit_id": "25d9747b6427de8253221d544b45e50888d4cef7", "target": 1, "func": "static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL) &&\n\n        !strstart(filename, \"/dev/fdset/\", NULL)) {\n\n        prio = 50;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    /* Attempt to detect via a floppy specific ioctl */\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    qemu_close(fd);\n\nout:\n\n    return prio;\n\n}\n", "idx": 444, "substitutes": {"filename": ["files", "name", "buffer", "named", "utf", "ppa", "txt", "binary", "tty", "folder", "fn", "wl", "buf", "fax", "lua", "fil", "nil", "Filename", "fp", "file", "sf", "ilk", "database", "sudo", "feat", "kn", "bf", "word", "l", "which", "dll", "f", "kl", "length", "wb", "STDOUT", "microsoft", "username", "il", "pty", "phrase", "prefix", "tools", "path", "socket", "FH", "whatever", "println", "directory"], "fd": ["fc", "ff", "ld", "fun", "fs", "da", "dd", "ud", "pd", "FD", "conn", "sd", "fed", "fw", "fa", "out", "d", "ad", "xd", "dl", "lf", "fl", "ln", "fn", "buf", "draft", "pipe", "fp", "file", "sf", "df", "dt", "ds", "md", "cod", "cond", "bf", "feed", "dc", "fe", "temp", "ind", "c", "fin", "f", "hd", "bd", " fid", "cd", "exec", "fat", "handler", "fx", "wd", "die", "connection", "fb", "cf", "od", "ecd", "vd", "FH", "ded", "nd", "dat", "dir", "fi", "gd", "db"], "ret": ["rot", "ort", "fun", "att", "mt", "def", "conn", "success", "out", "ct", "alt", "ry", "pet", "rets", "ben", "rf", "py", "pass", "j", "fail", "lt", "ait", "ft", "nt", "err", "rev", "cond", "reply", "status", "Ret", "feat", "bf", "dt", "result", "pret", "fin", "try", "rl", "len", "ref", "fat", "resp", "std", "art", "en", "sec", "obj", "RET", "rx", "lit", "re", "ann", "rt", "val", "reg", "pt", "let", "fi", "det", "res", "db"], "fdparam": ["draftparam", "dresource", "fpar", "FDparams", "dlresource", "fparams", "FDresource", "dParam", "fdresource", "fdpar", "dparam", "dlparam", "FDparam", "fdParam", "fdparams", "dlparams", "fparam", "dparams", "FDParam", "dlParam", "draftparams", "draftpar", "FDpar"], "st": ["stage", "ist", "src", "rest", "ss", "dd", "stat", "sd", "sb", "d", "ct", " est", "store", "spect", "St", "ste", "ft", "nt", "str", "storage", "fe", "et", "ut", "state", "put", "ST", "sc", "stab", "stream", "std", "obj", "rd", "sts", "sta", "inst", "t", "stop", "station", "ost", "td", "ast", "pt", "fi", "start", "sth", "est"]}}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)\n\n{\n\n    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    uint8_t bus_n = pci_bus_num(vtd_as->bus);\n\n    VTDContextEntry ce;\n\n\n\n    /*\n\n     * The replay can be triggered by either a invalidation or a newly\n\n     * created entry. No matter what, we release existing mappings\n\n     * (it means flushing caches for UNMAP-only registers).\n\n     */\n\n    vtd_address_space_unmap(vtd_as, n);\n\n\n\n    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {\n\n        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                  PCI_FUNC(vtd_as->devfn),\n\n                                  VTD_CONTEXT_ENTRY_DID(ce.hi),\n\n                                  ce.hi, ce.lo);\n\n        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);\n\n    } else {\n\n        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),\n\n                                    PCI_FUNC(vtd_as->devfn));\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 20495, "substitutes": {"iommu_mr": ["iommuit_mi", "iommu_rr", "iommur_rs", "iommu_br", "iommu_mid", "iommur_br", "iommuit_rr", "iommur_vr", "iommu__mr", "iommuit__mr", "iommuit__rr", "iommu__mi", "iommuit__mi", "iommu__rr", "iommu_mi", "iommu_rs", "iommu__mid", "iommur_mr", "iommu_vr", "iommuit__mid", "iommuit_mr", "iommuit_mid"], "n": ["i", "net", "e", "nat", "nn", "g", "d", "node", "f", "dn", "t", "y", "N", "r", "m", "nc", "j", "u", "p", "o", "network", "c", "self", "num", "a", "b", "w", "ns", "nb", "v", "nt", "sn", "fn", "h", "l", "x", "ne", "k", "nm"], "vtd_as": ["vtd__as", "vtd_state", "vdt_at", "vtd_cache", "vtd_AS", "vdtikcache", "vdt_as", "vtd__at", "vcd_asse", "vtd_at", "vtd__ws", "vcd_an", "vtd_an", "vtd_ac", "vtd_nas", "vtdikat", "vtdOCKAs", "vpc__ras", "vtd7as", "vdat_las", "vtdika", "vpd_as", "vtd7state", "vpc__ms", "vtdobas", "vtd7ras", "vtdappasin", "vdtikas", "vdd_As", "vtdikas", "vtdocat", "vdat_a", "vtd__ac", "vdat_as", "vpc_ras", "vtd__AS", "vtdockas", "vdtikAs", "vdd_as", "vpd_nas", "vdd_ac", "vpd_with", "vtd_ws", "vtdoat", "vtd_ras", "vtdocbas", "vcd_as", "vcd_asin", "vtd_asin", "vtdiknas", "vpc_an", "vtd__cache", "vtdikwith", "vpc_as", "vtd___as", "vdat_at", "vpc_ms", "vpc__an", "vtdocknas", "vdd_state", "vtd_As", "vtd___asin", "vtdockwith", "vtdOCKAS", "vtdOCKac", "vtdockras", "vtdappasse", "vtd_las", "vtdocws", "vtdikcache", "vtdikAs", "vtdappAs", "vtdows", "vtd_via", "vtd_a", "vdd_at", "vdd_AS", "vtd__las", "vtdappcache", "vtd___asse", "vtdockms", "vtdockvia", "vtd_ms", "vtdOCKas", "vtd___an", "vtd_bas", "vdt_cache", "vpc__as", "vtd__As", "vtd__an", "vtdockan", "vdt_As", "vtdikws", "vtd_asse", "vpd_via", "vdtikat", "vtdocas", "vtdikvia", "vtdappan", "vtdiklas", "vtd__a", "vdat_ws", "vtd__ras", "vtd_with", "vdat_bas", "vtdappat", "vtd__ms", "vdd_ras", "vtdappas", "vtdoas"], "s": ["i", "sb", "e", "sl", "ses", "sis", "ops", "ds", "services", "f", "sys", "t", "u", "r", "m", "state", "ssl", "os", "p", "cs", "ts", "o", "sync", "is", "sa", "c", "js", "spec", "a", "b", "S", "ns", "session", "side", "ps", "south", "gs", "v", "scope", "ss", "states"], "ce": ["ate", "cc", "ix", "ces", "ee", "e", "cing", "oe", "ct", "ind", " pe", "ance", "pe", "ette", "ade", " CE", "none", "nce", "ze", "za", " ke", "ca", "che", "cur", "cel", "cell", "ci", "ine", "ide", "ue", " ne", " ace", "cle", "cer", "CE", "ace", "code", "cess", "SE", "le", "que", "cue", "coe", "client", "dr", "fe", "ste", "cf", "du", "cal", "se", "face", "cy", "ced", "core", "te", "ve", "cca", "co", "cast", "see", "ince", "ae", "ke", "ck", "GE", "ge", "cod", "ie", "ice", "ne", " ge"]}}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "sPAPRDRConnector *spapr_drc_by_index(uint32_t index)\n\n{\n\n    Object *obj;\n\n    char name[256];\n\n\n\n    snprintf(name, sizeof(name), \"%s/%x\", DRC_CONTAINER_PATH, index);\n\n    obj = object_resolve_path(name, NULL);\n\n\n\n    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);\n\n}\n", "idx": 20151, "substitutes": {"index": ["instance", "point", "offset", "data", "x", "ix", "inc", "num", "i", "root", "type", "match", "loc", "Index", "ind", "pos", "pointer", "object", "NAME", "alias", "path", "size", "prefix", "key", "config", "length", "id", "position", "url", "address", "cache", "level", "number", "addr", "connection", "value", "version", "column"], "obj": ["ns", "init", "j", "code", "data", "ob", "ref", "bj", "x", "conn", "err", "eff", "nt", "adj", "n", "cb", "oa", "node", "wb", "ext", "ctx", "pos", "ass", "nb", "act", "object", "o", "po", "art", "arr", "val", "path", "nc", "args", "prefix", "key", "id", "buff", "elt", "js", "tmp", "rb", "fn", "Object", "cn", "inst", "addr", "os", "attr", "pt", "Obj", "typ"], "name": ["part", "instance", "data", "x", "comment", "base", "dot", "ref", "call", "search", "n", "num", "str", "root", "block", "type", "package", "ext", "Name", "filename", "out", "object", "NAME", "alias", "old", "new", "path", "size", "space", "prefix", "key", "id", "e", "named", "parent", " path", " prefix", "table", "url", "address", " parent", "resource", "names", "connection", "addr", "word", "desc", "attr"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmadd (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) != float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) + farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_add(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 20158, "substitutes": {"arg1": ["argone", "argument3", "argument1", "ax3", "ax2", "Arg01", "ax01", "argument01", "arg01", "Arg1", "Argone", "ax1", "argument2", " argone", "axone", "Arg2", " arg01"], "arg2": ["arm2", "argument3", "argument1", "ax2", "arm4", "ax4", "args2", "args02", "args4", "ax1", "argument2", "argument4", "arg4", "ax02", "args1", "arg02", "arm1", "arm3", " arg4", " arg02"], "arg3": ["argument3", "arg53", " arg03", "argument1", "ax3", " arg53", "argument03", "Arg1", "ax1", "argument2", "ax53", "Arg3", "Arg03", "Arg53", "Arg2", "arg03", "ax03"], "farg1": ["fargumentone", "fargs81", "afargument91", "fArg3", "fang3", "far6", "faccessN", "fargument1", "fang81", " fark81", " far6", "farkOne", " farg11", "fark0", " fargfirst", "farc3", "fgen11", "frparam61", "fvar3", "fvar01", "fArgOne", "targs81", "fargs2", " farg6", " fark0", "frparam3", "fark81", "farg4", "FArg01", " far1", "fang1", "fargs3", "fargN", "fark01", "fang01", "frparamOne", "targN", "farkfirst", " far4", "fark1", "frg61", "frarg1", "fArgone", "fax4", "farg11", "faccess1", "fargone", "fArg91", "fparam1", " fark01", " farg01", "fargs1", "fArg81", " fark3", "fvar0", "targs01", "fargs6", "far4", "farc0", "fargOne", "faccess01", "far1", "frarg3", "targ01", "frparam1", "fargument3", " fark1", "farc81", "farg61", "fvarfirst", "targsN", "afargument3", "fvar1", "farg81", "farg0", "farkN", "afarg3", "fgen2", "farc1", "fvarOne", "fark61", "fax1", "farg01", "far3", "faccess81", "afarg91", "Farg1", "afargone", "FArg1", "FArg3", "frg3", "fargs91", "fparam3", "fargsN", "farg6", "fargfirst", "targs1", " fargOne", "FArg81", "fArg01", "targ1", "farg91", "Farg81", "fargsfirst", " farg81", "targ81", "fax6", "frg1", "fgen3", "fargs11", "fargs01", "afargumentone", "afargument1", "fargsone", "fargs0", " farg0", "fark3", "afarg1", "fArg1", "frgOne", "Farg01", " farg4", "frargOne", "fparam61", "fax3", " farkOne", "Farg3", "fparamOne", "fargument91", " farkfirst", "fgen1", "frarg61", " far3", "fargs4"], "farg2": ["pArg2", "fralletwo", "fplay0", "fallesecond", "fArg3", "fralle2", "fang3", "fag2", "fcresultsecond", "fitem2", "fdr3", "forargTwo", "Farg0", "fplay2", "afallesecond", "fitem3", "fresult62", "fagenTwo", "forarg2", "fagsecond", "fargs2", "fplay22", "fordr22", "fitem0", "fvar182", "afargsecond", "farg62", "pArg4", "farg4", "pArg0", "Fang2", "fcargsecond", "fargTwo", "Farg2", "fplay182", "parg4", "farntwo", "fordr2", "falleTwo", "fang2", "fagTwo", "frarg2", "parg182", "falle02", "farn72", "fagen2", "fplayTwo", "fArg2", "fralle72", "fralle3", "fvar0", "Fang3", "fArgTwo", "afalle2", "afalleTwo", "parg0", "falle62", "frarg3", "farg182", "fark22", "fdr22", "fresult02", "farkTwo", "fordrTwo", "farg0", "fordr3", "fcresult02", "frarg72", "falle72", "fargtwo", "farg72", "Fang0", "fvar4", "fvar2", "fang0", "falle2", "farg22", "fcarg2", "forarg3", "fangTwo", "parg2", "falletwo", "fArg4", "fagensecond", "farg02", "fark2", "fcarg62", "fargsecond", "fargs02", "fcarg02", "fcresult2", "frargtwo", "fdr2", "fdrTwo", "falle3", "fargssecond", "fark3", "fplay3", "forarg22", "fArg0", "fplay4", "pArg182", "FangTwo", "fark72", "fresultsecond", "fresult2", "afargtwo", "Farg3", "fagentwo", "fitemTwo", "fargs62", "fArg182", "FargTwo", "farktwo", "afalletwo", "afarg2", "fagtwo", "fcresult62", "afargTwo", "farn2", "farn3"], "farg3": ["fArg40", " ferg23", "fack12", "fcall3", "fArg3", "fang3", "ferg3", " fargThree", "ferg12", "farg23", "frarg15", "carg53", "carg03", "fvalid1", " farg40", "fok3", "farc3", "fcall23", "fargs2", "fok03", "farg9", "frarg53", "falle1", "cang53", "carg9", "farg4", "fcall03", "fargs3", "fArgthird", " fArg1", " ferg12", "fark1", " fArg03", "fax23", " fargthird", "fArg03", "frcall23", "farc53", "fang53", "carg3", "fang9", "farg53", "fargs1", "fArg2", "fcall53", "fargThree", " fArg40", "fargthird", "cang03", "frarg3", "fcall15", " farg03", " fargs3", "fvalid3", " farg12", "farg12", "frcall15", " ferg03", " fArgthird", "farc15", "fall03", " ferg3", "fall9", "frcall3", "ferg03", "farkThree", "ferg23", "fax15", "fack3", " farg23", "fax03", "farg03", "fall3", "farc23", "fax9", "falle40", "fack23", "fvalid40", "fokThree", "cang3", " fargs4", "fArg4", "farg40", "fok1", " fArgThree", "falle3", "fark3", "fArg1", " fArg3", " fargs1", " farg4", "fax53", "fang03", "fcall12", "fax3", "fark03", "farg15", "frcall53", " fargs2", "cang9", "fall53", "frarg23", "fallethird", "fargs4", "fArgThree", "fack03", "fvalidthird"], "ft0_128": ["ft1_58", "ft0j58", "ft5_128", "ft1_384", "ft0j256", "ft0j128", "ft0_1024", "ft80_1024", "ft1_257", "ft2_188", "ft0_256", "ft1_512", "ft1_048", "ft5_208", "ft2_48", "ft5_256", "ft5_512", "ft80_128", "ft0_48", "ft0_167", "ft80_256", "ft2_048", "ft0_208", "ft0j13", "ft0_512", "ft0_188", "ft0_384", "ft0_13", "ft0_58", "ft1_256", "ft0_257", "ft1_13", "ft0_048", "ft80_167", "ft2_128"], "ft1_128": ["ft0_32", "ft1_32", "ft0_48", "ft1_257", "ft0_126", "ftone_48", "ft1_188", "ft1_48", "ft1_126", "ft0_256", "ft1_256", "ftone_128", "ft0_257", "ftone_188"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,\n\n        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,\n\n        BlockCompletionFunc *cb, void *opaque)\n\n{\n\n    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);\n\n\n\n    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,\n\n                                 BDRV_REQ_ZERO_WRITE | flags,\n\n                                 cb, opaque, true);\n\n}\n", "idx": 3924, "substitutes": {"bs": ["ob", "base", "js", "src", "cs", "sb", "bps", "BS", "bid", "bc", "banks", "ins", "pb", "fps", "bis", "plugins", "ses", "ls", "ds", "bas", "ps", "gs", "ns", "css", "vs", "bos", "lbs", "obj", "as", "iss", "blocks", "fb", "b", "os", "las", "bes", "fs", "db", "obs"], "sector_num": ["sector_number", " sector_count", "sector_count", " sector_nb", " sector_number", " sector_name", " sector_note", "sector_name", "sector_note", "sector_nb"], "nb_sectors": ["nb_sesctors", "nb_peors", "nb_pseivers", "nb_psegments", "nb_spegments", "nb_vegments", "nb_spections", "nb_speriers", "nb_spesector", "nb_serctions", "nb_peonents", "nb_pegments", "nb_sesonents", "nb_pseriers", "nb_speivers", "nb_segments", "nb_sesgments", "nb_seonents", "nb_sections", "nb_sesors", "nb_veors", "nb_veonents", "nb_seriers", "nb_spectors", "nb_psectors", "nb_vectors", "nb_sergments", "nb_serctors", "nb_veriers", "nb_vesector", "nb_sersector", "nb_vections", "nb_pectors", "nb_seors", "nb_veivers", "nb_sesector", "nb_seivers"], "flags": ["files", "fun", "cs", "offset", "Flags", "utf", "ops", "bit", "lag", "bps", "vals", "data", "ips", "faces", "type", "fl", "lf", "callback", "nl", "fps", "options", "nil", "bits", " Flags", "args", "sf", "info", "fts", "settings", "utils", "status", "feat", "fe", "factor", "fi", "fg", "vs", "flag", "features", "ints", "mask", "fields", "fee", "stats", "types", "forces", "bytes", "ants", "count", "fs", "ags", "FLAG"], "cb": ["ob", "fc", "orb", "fun", "cs", "ctx", "cc", "gc", "CB", "eb", "db", "callback", "bc", "buff", "pb", "fn", "buf", "rb", "fp", "cgi", "func", "cod", "bf", "ec", "dc", "c", "cv", "unc", "ctrl", "cd", "cmd", "bb", "cca", "pc", "fb", "cp", "b", "cf", "obb"], "opaque": ["opacity", " opque", "opsec", "compacity", "Opec", " opac", "opsacity", "opac", "operaque", "compque", "opace", " opacity", "compace", "hopaque", "hopace", "operec", "Opque", "operac", "opsque", "compaque", "operacity", "Opacity", "hopacity", " opace", "opec", "Opaque", "opsaque", "Opac", "opque", "hopque", "operque"]}}
{"project": "qemu", "commit_id": "d82831dbc5471d72785c49b33710436af49bf9ca", "target": 0, "func": "CharDriverState *text_console_init(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    QemuConsole *s;\n\n    unsigned width;\n\n    unsigned height;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    width = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (width == 0)\n\n        width = qemu_opt_get_number(opts, \"cols\", 0) * FONT_WIDTH;\n\n\n\n    height = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (height == 0)\n\n        height = qemu_opt_get_number(opts, \"rows\", 0) * FONT_HEIGHT;\n\n\n\n    if (width == 0 || height == 0) {\n\n        s = new_console(NULL, TEXT_CONSOLE);\n\n    } else {\n\n        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);\n\n    }\n\n\n\n    if (!s) {\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n\n\n    s->chr = chr;\n\n    s->g_width = width;\n\n    s->g_height = height;\n\n    chr->opaque = s;\n\n    chr->chr_set_echo = text_console_set_echo;\n\n    return chr;\n\n}\n", "idx": 13154, "substitutes": {"opts": ["opments", "hopws", "optls", "opted", "optted", "opert", "lintics", "hopts", "hopsts", "operments", "OPs", "opouts", "okTS", "optops", "optics", "linments", "OPouts", "opops", "okops", "optTS", "optouts", "opertics", "operted", "optionts", "OPfs", " optics", "opers", "lints", "optsts", " opsts", "hoptics", "opws", "operls", "operTS", "OPt", "operops", "optws", "opfs", "opTS", "optiont", "optments", "OPts", "optionfs", "OPments", "optt", "optts", "opsts", "opttics", "linls", "okted", "ops", "optionouts", "okts", "opls", " opws", "opt", "optfs", "operts"], "chr": ["charrc", " chpr", "schran", "ichdr", "achrf", "clnr", " chp", "cher", "colr", "chrl", "Chcr", "achr", " chlr", "chrb", " chran", "charlr", "colru", "charpr", " chrw", "chpr", "Chpr", "corr", "charr", "charre", "cyr", "chre", "Chrl", "qrl", "chrw", "cordr", "ichrb", "ctr", "chsr", "ichro", "hlr", "chlr", "cylr", "colnr", "chran", "cyrb", "chrt", "hrf", "shro", "Chrw", "ichlr", " chrt", "ichr", "charar", " chrc", "schrt", "schr", " chcr", "shr", "chro", " chrl", "chnr", "ctrt", "chrc", "ctran", "ctrf", "qrb", "achru", "qrw", "colrf", " chru", "achre", "clrl", "Chr", "colrl", "charrf", "Chrb", "chrf", "shsr", "charru", "ichsr", "corsr", "ichrf", "clr", "schrf", "Chp", "chelr", "chru", "charp", "colre", " chrf", "hr", " chnr", "shdr", "cherc", " chrb", "charcr", "hrb", "chcr", "chdr", "qr", "chp", "corro", "cyrf", "clru", "chear"], "s": ["south", "sys", "ses", "m", "service", "t", "sync", "sg", "d", "fs", "l", "i", "rs", "sym", "g", "cs", "S", "hs", "settings", "os", "h", "its", "str", "si", "js", "es", "sq", "rows", "session", "server", "v", "scope", "ps", "ss", "storage", "client", "o", "secure", "w", "u", "params", "sid", "p", "e", "sign", "share", "socket", "http", "sf", "sb", "b", "n", "f", "lines", "gs", "spec", "c", "ns", "shell", "is", "stats", "ssl", "side", "sv", "sl", "ops", "r", "services", "ds", "better", "su", "ls", "ts"], "height": ["upper", "stroke", "head", "hip", "Height", "deep", "slice", "build", "thin", "bottom", "grow", "arrow", "id", "level", "density", "shape", "style", "shadow", "row", "gap", "ths", "weight", "h", "missing", "how", "gh", "crop", "square", "gain", "rh", "rank", "hang", "pass", "view", "size", "ady", "tight", "direction", "huge", "han", "length", "th", "padding", "gravity", "resolution", "inches", "above", "pull", "east", "hold", "angle", "layout", "volume", "work", "window", "ty", "y", "depth", "index"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)\n\n{\n\n    return telldir(fs->dir);\n\n}\n", "idx": 11781, "substitutes": {"ctx": ["cam", "context", "cmp", "Context", "conn", "tc", "sci", "fw", "cp", "c", "cf", "loc", "bc", "cc", "cs", "alloc", "cv", "exc", "rc", "cas", "tx", "pc", "xc", "ca", "cm", "vc", "lc", "pkg", "kb"], "fs": ["vs", "FS", "ts", "uses", "ks", "ds", "sf", "stats", "fd", "files", "fw", "flows", "fb", "ls", "fp", "feed", "xs", "outs", "bits", "wcs", "rs", "f", "df", "os", "cs", "flags", "fps", "states", "ns", "bytes", "ms", "less", "gets", "sys", "ps", "ss", "ows", "bs", "Fs", "fts", "fc"]}}
{"project": "qemu", "commit_id": "1dbfd7892b66c757fdf67f346be40233adbad80e", "target": 1, "func": "void bios_linker_loader_alloc(GArray *linker,\n\n                              const char *file,\n\n                              uint32_t alloc_align,\n\n                              bool alloc_fseg)\n\n{\n\n    BiosLinkerLoaderEntry entry;\n\n\n\n    assert(!(alloc_align & (alloc_align - 1)));\n\n\n\n    memset(&entry, 0, sizeof entry);\n\n    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);\n\n    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);\n\n    entry.alloc.align = cpu_to_le32(alloc_align);\n\n    entry.alloc.zone = cpu_to_le32(alloc_fseg ?\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :\n\n                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);\n\n\n\n    /* Alloc entries must come first, so prepend them */\n\n    g_array_prepend_vals(linker, &entry, sizeof entry);\n\n}\n", "idx": 855, "substitutes": {"linker": ["layener", "layer", "lockger", " linkner", "layger", "linkger", " linkers", "layor", "locker", "inkener", " linkener", "lockor", "layner", "linkor", "linkner", "inkers", "inker", "lockher", " linkor", " linkher", "layher", "linkher", " linkger", "layers", "linkener", "linkers", "inkner"], "file": ["call", "base", "files", "name", "buffer", "offset", "time", "read", "key", "array", "queue", "data", "filename", "image", "memory", "loc", "class", "align", "type", "field", "format", "parent", "model", "code", "fp", "write", "source", "pool", "feed", "address", "content", "block", "resource", "size", "f", "per", "cache", "value", "ile", "File", "link", "path", "full", "line", "dir", "fi", "port"], "alloc_align": ["alloc__range", "loc_role", "alloc___aligned", "oc_space", "alloc__ign", "alloc_balance", "oc_array", "loc_aligned", "alloc__aligned", "oc_al", "alloc_array", "alloc_space", "loc_balance", "loc_align", " alloc_aligned", "allocfign", "alloc_al", "alloc___align", "alloc___balance", "alloc___role", "alloc__align", " alloc_range", "oc_align", "alloc_aligned", " alloc_ign", "oc_aligned", "allocfaligned", "alloc_ign", "alloc_role", "allocfrange", "allocfalign", "alloc_range"], "alloc_fseg": ["alloc_FseG", "alloc_fsege", "alloc_fpersega", "alloc_fgege", "alloc_fmege", "alloc_fpersege", "alloc_fsegs", "alloc_fgeig", "alloc_fperseG", "alloc_fseG", "alloc_rfgege", "alloc_fsega", "alloc_FgeG", "alloc_Fseg", "alloc_fmega", "alloc_Fsegs", "alloc_Fgeig", "alloc_fperseg", "alloc_Fgegs", "alloc_Fgeg", "alloc_fpersegs", "alloc_fgeG", "alloc_fperseeg", "alloc_fgeeg", "alloc_fmeeg", "alloc_fgegs", "alloc_fgega", "alloc_rfseeg", "alloc_rfsege", "alloc_rfgeeg", "alloc_Fseig", "alloc_rfseg", "alloc_rfsega", "alloc_rfgeg", "alloc_fseig", "alloc_fgeg", "alloc_fmeg", "alloc_fseeg", "alloc_fperseig", "alloc_rfgega"], "entry": ["row", "key", "ge", "ger", "next", "index", "feed", "archive", "set", "comment", "way", "cell", "valid", "engine", "se", "start", "ae", "ner", "extra", "her", "image", "parent", "end", "scan", "parse", "ie", "or", "e", "lc", "per", "org", "plugin", "link", "import", "data", "new", "r", "add", "cat", "section", "record", "insert", "ent", "member", "Entry", "inner", "info", "str", "result", "writer", "loader", "cache", "sec", "connection", "card", "error", "module", "enter", "match", "server", "service", "inter", "ga", "array", "ry", "cue", "nt", "reader", "zero", "try", "element", "line", "install", "inc", "export"]}}
{"project": "qemu", "commit_id": "eefff991d059d299b917627d2a95bce34d2f97f3", "target": 1, "func": "int load_snapshot(const char *name, Error **errp)\n\n{\n\n    BlockDriverState *bs, *bs_vm_state;\n\n    QEMUSnapshotInfo sn;\n\n    QEMUFile *f;\n\n    int ret;\n\n    AioContext *aio_context;\n\n    MigrationIncomingState *mis = migration_incoming_get_current();\n\n\n\n    if (!bdrv_all_can_snapshot(&bs)) {\n\n        error_setg(errp,\n\n                   \"Device '%s' is writable but does not support snapshots\",\n\n                   bdrv_get_device_name(bs));\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_all_find_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp,\n\n                   \"Device '%s' does not have the requested snapshot '%s'\",\n\n                   bdrv_get_device_name(bs), name);\n\n        return ret;\n\n    }\n\n\n\n    bs_vm_state = bdrv_all_find_vmstate_bs();\n\n    if (!bs_vm_state) {\n\n        error_setg(errp, \"No block device supports snapshots\");\n\n        return -ENOTSUP;\n\n    }\n\n    aio_context = bdrv_get_aio_context(bs_vm_state);\n\n\n\n    /* Don't even try to load empty VM states */\n\n    aio_context_acquire(aio_context);\n\n    ret = bdrv_snapshot_find(bs_vm_state, &sn, name);\n\n    aio_context_release(aio_context);\n\n    if (ret < 0) {\n\n        return ret;\n\n    } else if (sn.vm_state_size == 0) {\n\n        error_setg(errp, \"This is a disk-only snapshot. Revert to it \"\n\n                   \" offline using qemu-img\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Flush all IO requests so they don't interfere with the new state.  */\n\n    bdrv_drain_all();\n\n\n\n    ret = bdrv_all_goto_snapshot(name, &bs);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while activating snapshot '%s' on '%s'\",\n\n                     ret, name, bdrv_get_device_name(bs));\n\n        return ret;\n\n    }\n\n\n\n    /* restore the VM state */\n\n    f = qemu_fopen_bdrv(bs_vm_state, 0);\n\n    if (!f) {\n\n        error_setg(errp, \"Could not open VM state file\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    qemu_system_reset(SHUTDOWN_CAUSE_NONE);\n\n    mis->from_src_file = f;\n\n\n\n    aio_context_acquire(aio_context);\n\n    ret = qemu_loadvm_state(f);\n\n    qemu_fclose(f);\n\n    aio_context_release(aio_context);\n\n\n\n    migration_incoming_state_destroy();\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Error %d while loading VM state\", ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11455, "substitutes": {"name": ["parent", "alias", "NAME", "pass", "base", "n", "true", "g", "wa", "prefix", "key", "word", "all", "no", "id", "m", "again", "path", "x", "filename", "b", "block", "c", "time", "el", "names", "none", "nm", "j", "code", "label", "resource", "named", "size", "version", "new", "full", "part", "ns", "desc", "false", "error", "type", "ame", "null", "on", "url", "out", "image", "a", "Name"], "errp": ["erp", " errP", "errg", "ierapi", "errorpt", "mrapi", "arrapi", "errpatch", " erwp", "erP", "erfp", " erP", "errpr", "corpress", "errpre", "errpress", "Erwp", "argp", "argg", "ierpatch", "errt", "argping", "errwp", "arrpr", "arrping", "oderpress", "opp", "errorpre", "oppt", "ierpt", "opapi", "ErP", " erp", "mrpr", "errorfp", "errpp", " erpatch", "arrpt", "ierP", "Erpatch", "errorp", "errping", " errpa", "errorapi", "errP", "oderp", "ierp", "Erp", "aerpress", "arrg", "oderpa", "errfp", "yrpa", "yrpp", "erg", "opP", "errpt", "erping", " errpp", "erpre", "errorP", "mrp", "errapi", "mrpt", "cort", "aerpa", " errpre", "errpa", "yrp", "arrp", " errfp", "aert", "aerp", "corpp", "odert", "corp", "ierpr", "ierwp", "corpa"], "bs": ["vs", "boot", "base", "bb", "ds", "ba", "bid", "bas", "src", "b", "gs", "fb", "s", "ls", "pb", "cb", "gb", "bits", "js", "BS", "bc", "os", "obs", "cs", "bf", "bl", "eb", "lib", "sync", "sl", "las", "lb", "bot", "bis", "bi", "sb", "ns", "bytes", "hub", "sys", "platform", "null", "ps", "fs", "css", "bn", "ses", "ss", "android", "bing", "site", "bes", "bos"], "bs_vm_state": ["bs_vmksize", "bs_vm__start", "bs_mx__status", "bs_virtual_info", "bs_vmmstate", "bs_dm_states", "bs_vmkstate", "bs_vm_size", "bs_vmjstate", "bs_mx2address", "bs_mem_id", "bs_vm2status", "bs_vmmtype", "bs_vm_info", "bs_vm__state", "bs_vm6info", "bs_virtual_state", "bs_vm2address", "bs_vm2name", "bs_vm_connection", "bs_memjid", "bs_mem_state", "bs_mx__type", "bs_vmjkey", "bs_mx_status", "bs_dmjstates", "bs_vm__type", "bs_vm_status", "bs_mx__state", "bs_dm_state", "bs_mx_info", "bs_vm__address", "bs_memjsize", "bs_mx_address", "bs_vm_start", "bs_vm2data", "bs_virtual_id", "bs_vm_name", "bs_dmjstate", "bs_mx_state", "bs_vmkkey", "bs_vm6connection", "bs_mem_size", "bs_vmjsize", "bs_vm_type", "bs_cm_state", "bs_vm__info", "bs_mx2type", "bs_vm2config", "bs_vm__status", "bs_vm2state", "bs_mx2start", "bs_vm2type", "bs_vm6state", "bs_vm__states", "bs_vm2info", "bs_vmmstart", "bs_mx__info", "bs_dm_id", "bs_vm_address", "bs_vm_states", "bs_cm_name", "bs_vm_key", "bs_vm2start", "bs_vmkid", "bs_vmjstates", "bs_cm_data", "bs_vm_data", "bs_virtual_connection", "bs_dmjid", "bs_vmjid", "bs_vm6id", "bs_vm_id", "bs_cm_config", "bs_mem_key", "bs_vmmaddress", "bs_mx_type", "bs_vm_config", "bs_mx_start", "bs_memjkey", "bs_mx2state", "bs_vm__id", "bs_memjstate"], "sn": ["vi", "SN", "sp", "sh", "sv", "nb", "si", "n", "sf", "ny", "conn", "sw", "SB", "sa", "ls", " Sn", "cn", "dn", "sk", "cs", "fl", "syn", "sync", "sl", "sm", "Sn", "kn", "bi", "ns", "sb", "sd", "fn", "nc", "sys", "nu", "su", "ft", "ann", "bn", "ss", "sr", "ski", "vc", "nn", "sc"], "f": ["l", "rf", "conf", "fu", "lf", "fo", "fen", "n", "sf", "m", "fr", "fd", "t", "b", "z", "fw", "d", "i", "c", "fb", "s", "p", "e", "fit", "fp", "cb", "feed", "df", "j", "fa", "fm", "bf", "fl", "tf", "ln", "v", "r", "framework", "fin", "fn", "form", "h", "F", "file", "fs", "ft", "func", "inf", "fi", "fe", "fab", "fc"], "ret": ["fail", "red", "ref", "arg", "reg", "code", "al", "opt", "end", "att", "pret", "re", " RET", "let", "url", "ann", "resp", "arr", "rem", "flag", "val", "id", "Ret", "post", "value", "j", "res", "bf", "py", "det", "ner", "r", "ben", "en", "art", "rep", "error", "back", "mt", "rl", "rf", "ext", "str", "alt", "len", "def", "nt", " Ret", "num", "data", "reply", "status", "usr", "rt", "fun", "part", "after", "fin", "fn", "cat", "result", "success", "reset", "repl", "pass", "active", "info", "sur", "job", "run", "obj", "lit", "rets", "bit", "RET", "out", "ft", "rev", "match", "feat", "pet"], "aio_context": ["aioamcontext", "aiothecontext", "aout_context", "aiotheprivate", "aout_pointer", "aout_ctx", "aio_config", "aios_ctx", "aio_support", "aios_cert", "aioamconcept", "aio_pointer", "aios_resource", "aout_support", "aio_private", "aio_concept", "aio_cert", "aios_private", "aioamconfig", "aioamsession", "aios_concept", "aio_session", "aio_resource", "aiotheresource", "aios_context", "aiothectx", "aios_session", "aio_ctx", "aios_config"], "mis": ["me", "ts", "mn", "si", "mes", "json", "m", "model", "mr", "mas", "dj", "mm", "gm", "gs", "iss", "serv", "qs", "vis", "lu", "gp", "rs", "oci", "os", "fm", "res", "cs", "mi", "tis", "cas", "miss", "nas", "ns", "sis", "spec", "ms", "sys", "ma", "fs", "mc"]}}
{"project": "FFmpeg", "commit_id": "f907615f0813e8499f06a7eebccf1c63fce87c8e", "target": 1, "func": "static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n\n\n    pc->enc = av_mallocz(sizeof(MpegEncContext));\n\n    if (!pc->enc)\n\n        return -1;\n\n    pc->first_picture = 1;\n\n\n    return 0;\n\n}", "idx": 14362, "substitutes": {"s": ["sys", "ses", "self", "m", "as", "sg", "fs", "rs", "cs", "hs", "si", "js", "sq", "v", "ps", "ss", "ms", "p", "e", "sb", "sf", "gs", "c", "parser", "xs", "sac", "sc", "sv", "services", "ds", "sa", "soc", "ls", "ks"], "pc": ["mc", "cam", "bc", "amp", "uc", "ca", "enc", "rc", "cc", "pac", "cz", "lc", "PC", "cs", "auc", "lp", "cms", "px", "cr", "pd", "oc", "p", "pb", "nc", "pa", "tc", "cus", "co", "ck", "gb", "arc", "c", "pm", "cca", "FC", "cu", "dc", "ac", "anc", "sc", "cp", "vc", "sa", "xc", "ec", "fc", "pic", "ctx"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_b_picture_secondary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status;\n\n\n\n    bitplane_decoding(&v->skip_mb_plane, v);\n\n    if (status < 0) return -1;\n\n#if TRACE\n\n    if (v->mv_mode == MV_PMODE_MIXED_MV)\n\n    {\n\n        status = bitplane_decoding(&v->mv_type_mb_plane, v);\n\n        if (status < 0)\n\n            return -1;\n\n#if TRACE\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB MV Type plane encoding: \"\n\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n    }\n\n\n\n    //bitplane\n\n    status = bitplane_decoding(&v->direct_mb_plane, v);\n\n    if (status < 0) return -1;\n\n#if TRACE\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Direct plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"Skip MB plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    /* FIXME: what is actually chosen for B frames ? */\n\n    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables\n\n    v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)];\n\n\n\n    if (v->dquant)\n\n    {\n\n        vop_dquant_decoding(v);\n\n    }\n\n\n\n    if (v->vstransform)\n\n    {\n\n        v->ttmbf = get_bits(gb, 1);\n\n        if (v->ttmbf)\n\n        {\n\n            v->ttfrm = get_bits(gb, 2);\n\n            av_log(v->s.avctx, AV_LOG_INFO, \"Transform used: %ix%i\\n\",\n\n                   (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8);\n\n        }\n\n    }\n\n    /* Epilog (AC/DC syntax) should be done in caller */\n\n    return 0;\n\n}\n", "idx": 7130, "substitutes": {"v": ["nv", "vol", "ch", "serv", "vr", "o", "a", "vd", "vm", "s", "value", "V", "va", "vt", "b", "vic", "inv", "i", "x", "m", "uv", "l", "gu", "f", "conv", "version", "j", "av", "ve", "ii", "q", "server", "d", "tv", "ev", "vi", "vs", "e", "u", "w", "dev", "k", "t", "n", "vin", "volt", "rev", "p", "temp", "this", "h", "vp", "sv", "iv", "vert", "ver", "c", "var", "g", "lv", "ov", "video", "vv", "cv", "vc", "r", "view"], "gb": ["game", "gp", "gc", "hw", "cfg", "cgi", "lb", "dm", "vg", "phy", "gm", "hub", "vd", "ci", "rb", "Gb", "bg", "b", "bps", "rc", "bm", "ko", "gom", "uv", "db", "xy", "pm", "ga", "abb", "gin", "pc", "gz", "py", "eb", "sb", "gs", "rg", "bis", "storage", "lib", "ctx", "bc", "GB", "cb", "nb", "bridge", "mb", "gy", "kb", "ge", "gh", "g", "bf", "gd", "lv", "gt", "lc", "gg", "cv", "vc", "git", "mode", "ui"], "status": ["progress", "check", "x", "ex", "style", "data", "unit", "speed", "job", "state", "weight", "used", "magic", "active", "service", "code", "error", "pass", "err", "stage", "output", "sp", "current", "git", "index", "msg", "name", "header", "id", "count", "spec", "s", "update", "val", "info", "xml", "ix", " Status", "content", "url", "enabled", "sc", "comment", "str", "score", "ity", "settings", "type", "class", "text", "summary", "ui", "size", "uses", "stat", "days", "sr", "plugins", "security", "use", "sync", "num", "source", "temp", "css", "level", "ssl", "api", "prefix", "login", "options", "gc", "complete", "skip", "si", "details", "order", "wait", "stats", "sql", "full", "result", "seq", "step", "Status", "success", "date", "min", "js"]}}
{"project": "qemu", "commit_id": "e91e972ccfbaeba1d1416202ad1b667810a33e1f", "target": 0, "func": "int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    int ret = 0;\n\n\n\n    switch (run->exit_reason) {\n\n        case KVM_EXIT_S390_SIEIC:\n\n            ret = handle_intercept(cpu);\n\n            break;\n\n        case KVM_EXIT_S390_RESET:\n\n            qemu_system_reset_request();\n\n            break;\n\n        case KVM_EXIT_S390_TSCH:\n\n            ret = handle_tsch(cpu);\n\n            break;\n\n        case KVM_EXIT_DEBUG:\n\n            ret = kvm_arch_handle_debug_exit(cpu);\n\n            break;\n\n        default:\n\n            fprintf(stderr, \"Unknown KVM exit: %d\\n\", run->exit_reason);\n\n            break;\n\n    }\n\n\n\n    if (ret == 0) {\n\n        ret = EXCP_INTERRUPT;\n\n    }\n\n    return ret;\n\n}\n", "idx": 27254, "substitutes": {"cs": ["sc", "ses", "rs", "sk", "ss", "c", "CS", "ec", "acks", "ds", "cr", "cus", "ars", "ps", "cons", "ks", "sync", "css", "ys", "vc", "ics", "spec", "wcs", "cc", "ctx", "nas", "ras", "cf", "rc", "cas", "lc", "ls", "fs", "qs", "js", "ced", "cing", "ck", "acs", "ace", "ce"], "run": ["exec", "use", "build", "ru", "call", "thread", "Run", "execute", "play", "name", "job", "pass", "sync", "boot", "unit", "con", "cmd", "work", "runs", "min", "rm", "resource", "process", "re", "clean", "output", "rc", "ur", "view", "block", "ro", "mor", "man", "go", "un", "reg", "runner", "row", "r", "result", "ran", "fun"], "cpu": ["CPU", "node", "processor", "chip", "anc", "c", "uno", "lb", "android", "gru", "lan", "clock", "config", "component", "bc", "sync", "mac", "proc", "css", "gpu", "linux", "cmp", "boot", "unit", "hw", "phy", "process", "bench", "cli", "board", "cow", "cp", "cn", "ctx", "roc", "cache", "vm", "lc", "gc", "cu", "conn", "computer", "runner", "core", "pu", "uci", "nc", "pc"]}}
{"project": "qemu", "commit_id": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef", "target": 0, "func": "void cpu_loop_exit(CPUState *env1)\n\n{\n\n    env1->current_tb = NULL;\n\n    longjmp(env1->jmp_env, 1);\n\n}\n", "idx": 18614, "substitutes": {"env1": ["environmentOne", "envOne", " envOne", "encOne", "en7", "environment1", "excone", "environment2", "env5", "env2", "en1", " env7", "encone", "enc2", " env2", " env5", "enc5", "enc1", "environmentone", "excOne", "env7", "en5", " envone", "envone", "enc7", "exc1"]}}
{"project": "qemu", "commit_id": "b93c94f7ec74a577a0f74c724e8d251f01eaf65a", "target": 1, "func": "static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    struct iscsi_context *iscsi = NULL;\n\n    struct iscsi_url *iscsi_url = NULL;\n\n    struct IscsiTask task;\n\n    char *initiator_name = NULL;\n\n    int ret;\n\n\n\n    if ((BDRV_SECTOR_SIZE % 512) != 0) {\n\n        error_report(\"iSCSI: Invalid BDRV_SECTOR_SIZE. \"\n\n                     \"BDRV_SECTOR_SIZE(%lld) is not a multiple \"\n\n                     \"of 512\", BDRV_SECTOR_SIZE);\n\n        return -EINVAL;\n\n    }\n\n\n\n    iscsi_url = iscsi_parse_full_url(iscsi, filename);\n\n    if (iscsi_url == NULL) {\n\n        error_report(\"Failed to parse URL : %s %s\", filename,\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n\n\n    initiator_name = parse_initiator_name(iscsi_url->target);\n\n\n\n    iscsi = iscsi_create_context(initiator_name);\n\n    if (iscsi == NULL) {\n\n        error_report(\"iSCSI: Failed to create iSCSI context.\");\n\n        ret = -ENOMEM;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_targetname(iscsi, iscsi_url->target)) {\n\n        error_report(\"iSCSI: Failed to set target name.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url->user != NULL) {\n\n        ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user,\n\n                                              iscsi_url->passwd);\n\n        if (ret != 0) {\n\n            error_report(\"Failed to set initiator username and password\");\n\n            ret = -EINVAL;\n\n            goto failed;\n\n        }\n\n    }\n\n\n\n    /* check if we got CHAP username/password via the options */\n\n    if (parse_chap(iscsi, iscsi_url->target) != 0) {\n\n        error_report(\"iSCSI: Failed to set CHAP user/password\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) {\n\n        error_report(\"iSCSI: Failed to set session type to normal.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C);\n\n\n\n    /* check if we got HEADER_DIGEST via the options */\n\n    parse_header_digest(iscsi, iscsi_url->target);\n\n\n\n    task.iscsilun = iscsilun;\n\n    task.status = 0;\n\n    task.complete = 0;\n\n    task.bs = bs;\n\n\n\n    iscsilun->iscsi = iscsi;\n\n    iscsilun->lun   = iscsi_url->lun;\n\n\n\n    if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun,\n\n                                 iscsi_connect_cb, &task)\n\n        != 0) {\n\n        error_report(\"iSCSI: Failed to start async connect.\");\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    while (!task.complete) {\n\n        iscsi_set_events(iscsilun);\n\n        qemu_aio_wait();\n\n    }\n\n    if (task.status != 0) {\n\n        error_report(\"iSCSI: Failed to connect to LUN : %s\",\n\n                     iscsi_get_error(iscsi));\n\n        ret = -EINVAL;\n\n        goto failed;\n\n    }\n\n\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n\n\n    /* Medium changer or tape. We dont have any emulation for this so this must\n\n     * be sg ioctl compatible. We force it to be sg, otherwise qemu will try\n\n     * to read from the device to guess the image format.\n\n     */\n\n    if (iscsilun->type == TYPE_MEDIUM_CHANGER ||\n\n        iscsilun->type == TYPE_TAPE) {\n\n        bs->sg = 1;\n\n    }\n\n\n\n    return 0;\n\n\n\nfailed:\n\n    if (initiator_name != NULL) {\n\n        g_free(initiator_name);\n\n    }\n\n    if (iscsi_url != NULL) {\n\n        iscsi_destroy_url(iscsi_url);\n\n    }\n\n    if (iscsi != NULL) {\n\n        iscsi_destroy_context(iscsi);\n\n    }\n\n    memset(iscsilun, 0, sizeof(IscsiLun));\n\n    return ret;\n\n}\n", "idx": 572, "substitutes": {"bs": ["cms", "base", "cs", "ss", "bh", "rs", "sb", "lb", "BS", "bid", "bc", "pb", "ils", "cas", "bl", "bis", "ls", "ses", "bits", "sync", "ds", "bas", "gs", "ns", "css", "vs", "bi", "bos", "gb", "bt", "bb", "bp", "iss", "fb", "its", "fs"], "filename": ["files", "fd", "name", "buffer", "src", "utf", "sequence", "txt", "memory", "url", "tty", "binary", "download", "fn", "fil", "nil", "actual", "Filename", "fp", "file", "sf", "sbm", "document", "kn", "which", "dll", "f", "length", "kl", "rl", "java", "username", "il", "phrase", "ssl", "prefix", "bytes", "path", "subject", "location", "uri", "directory"], "flags": ["files", "windows", "fun", "Flags", "utf", "ops", "bit", "lag", "format", "fn", "locks", "options", "comments", "bits", "args", "settings", "config", "ffff", "flag", "features", "mask", "fields", "stats", "types", "bytes", "reg", "fs", "FLAG"], "iscsilun": ["discslune", "iscslon", "ibsilun", "ibsilon", "iscisolin", "iscinelin", "discsilin", "iscsluns", "ibislon", "discsluns", "iscsilUn", "iscsalur", "ibsilUn", "discslin", "discsilun", "iscisolune", "iscsilin", "ibislun", "iscslin", "iscinelun", "discsilune", "iscisoluns", "iscislon", "iscislun", "iscineluns", "discsiluns", "iscsilur", "iscsilon", "iscslur", "iscsilune", "discslun", "iscslUn", "iscislUn", "iscsiluns", "iscslun", "iscsalon", "iscsalun", "iscsalUn", "ibsilur", "iscisolun", "iscislur", "iscslune", "ibislUn", "iscinelune", "ibislur"], "iscsi": ["sicsa", "islni", "iscSI", "ircdi", "uscchi", "ISCni", "miscsa", "ircchi", "ISCsa", "uscdi", "uscsi", "uscSI", "ircli", "discdi", "rcsi", "sicifi", "becsi", "wicni", "miscsi", "ircsi", "incSI", "discci", "iscsis", "islsi", "ISCsi", "sicsis", "discsi", "iscsa", "iscfi", "ircfi", "wicsi", "iscli", "iscci", "ircni", "discfi", "islsb", "discli", "rcni", "ircifi", "incani", "ircsb", "ircci", "discsie", "islsa", "iscdi", "incfi", "uscni", "discii", "wicsb", "becsie", "wicsa", "wicii", "iscsb", "iscani", "iscni", "iscchi", "iscifi", "wicsie", "sicsi", "ircsa", "miscsis", "uscci", "rcsa", "iscsie", "becii", "wicani", "incsi", "ircani", "ircSI", "discsa", "iscii", "ircsis", "rcci", "ISCci", "incsa", "becsa", "incchi", "miscifi", "incli", "incni", "uscsa", "discni"], "iscsi_url": ["iscsi_uri", "iscsi__host", "iscsi_location", "iscsi__user", "iscsi_user", "iscni__text", "iscsi___source", "iscsi__coll", "iscgi__mount", "iscsiOuri", "iscsin_user", "iscsi__text", "isceni_path", "iscii_name", "iscsi_run", "iscsi_layer", "iscsi_str", "iscni__user", "iscSI_uri", "iscSI_url", "iscbi_fl", "iscsi__name", "iscsiPrun", "iscni_file", "iscii_str", "iscni_url", "iscsi_view", "iscsi_mount", "iscgi__url", "iscsi_coll", "iscsiPUrl", "iscSI_view", "iscsi__source", "iscii_url", "iscsi2mount", "iscsi_text", "iscSI_URL", "iscsi___url", "isceni_url", "iscsiOview", "iscsi_URL", "iscni_text", "iscgi__host", "iscsin_url", "isceni_str", "iscgi_source", "iscii_service", "iscsin_server", "iscsiPurl", "iscii_run", "iscsi_path", "iscsi_host", "iscsi2host", "iscsi_file", "iscsiOURL", "iscsi_Url", "iscbi_url", "iscgi_host", "iscgi_url", "iscsin_sl", "iscsi_channel", "iscbi_location", "iscni_layer", "iscsi___file", "iscbi_coll", "iscsi_name", "iscii_channel", "iscsi2url", "iscgi__source", "iscni__url", "iscsi_service", "iscsi_server", "iscsiPservice", "iscsiOurl", "iscni_coll", "iscsi__url", "iscii_user", "iscsi___layer", "iscsi__str", "iscsi_source", "iscii_path", "iscgi_mount", "isceni_Url", "iscni__coll", "iscsi_sl", "iscsi_fl", "iscni_source", "iscsi2source", "iscii_Url", "iscsi__mount", "iscni_user"], "task": ["unit", "Task", "bit", "method", "image", "class", "parent", "instance", "\u7684", " Task", "proc", " alloc", "tx", "master", "func", "result", " tasks", "ACK", "link", "TYPE", "NAME", "transfer"], "initiator_name": ["initiation__type", "initiate_names", "initiator__names", "initiation_name", "initiating_id", "initiating_type", "initiator_names", "initiator__key", "initiator__no", "initiation__id", "initiate_name", "initiator_id", "initiate_no", "initiator_no", "initiator__id", "initiation_names", "initiator_type", "initiator__name", "initiating_names", "initiation__name", "initiation__names", "initiator_key", "initiation_type", "initiation_id", "initiator__type", "initiate_key", "initiating_name"], "ret": ["match", "arg", "fun", "att", "mt", "bit", "success", " Ret", "get", "alt", "cat", "job", "cur", "wait", "rets", "arr", "num", " RET", "rep", "proc", "code", "lt", "rb", "nt", "ft", "rev", "str", "reply", "status", "Ret", "rc", "bf", "opt", "feat", "back", "result", "fin", "ut", "nb", "len", "rl", "flag", "ref", "gt", "resp", "art", "obj", "RET", "req", "wa", "lit", "reg", "re", "val", "let", "count", "rt", "part", "pt", "det", "res", "mem"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n", "idx": 325, "substitutes": {"bpp": ["rbcp", "fpp", "bupp", "ppps", "pupp", "fcp", "bpc", " bPP", "lgp", "fpps", "ebpps", "fupp", "abbPP", " bgp", "ebPP", "pcp", "ebpp", "abbpps", "ppp", " bcp", " bupp", "bpps", "bcp", "bgp", "lcp", "rbgp", "rbmp", "lmp", "bmp", "abbpc", "ebpc", "rbpp", "bPP", " bpps", " bpc", "lpp", "abbpp", " bmp"], "buf": ["src", "buffer", "ctx", "bag", "Buff", "context", "queue", "ab", "data", "loc", "window", "bc", "buff", "cur", "ph", "bin", "tab", "grad", "ha", "map", "off", "mac", "rb", "proc", "fab", "dest", "box", "comb", "cb", "aka", "plug", "feat", "config", "func", "home", "pub", "begin", "usr", "block", "cv", "Buffer", "vec", "ptr", "band", "book", "bd", "wb", "text", "cache", "uint", "uv", "gb", "cap", "cmd", "alloc", "fb", "b", "border", "cf", "conv", "font", "uf", "path", "img", "msg", "que", "uc", "db"]}}
{"project": "qemu", "commit_id": "4e47e39ab0ded72c0af174131ecf49d588d66c12", "target": 1, "func": "int x86_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)\n\n{\n\n    X86CPU *cpu = X86_CPU(cs);\n\n    CPUX86State *env = &cpu->env;\n\n    uint32_t tmp;\n\n\n\n    if (n < CPU_NB_REGS) {\n\n        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n            env->regs[gpr_map[n]] = ldtul_p(mem_buf);\n\n            return sizeof(target_ulong);\n\n        } else if (n < CPU_NB_REGS32) {\n\n            n = gpr_map32[n];\n\n            env->regs[n] &= ~0xffffffffUL;\n\n            env->regs[n] |= (uint32_t)ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    } else if (n >= IDX_FP_REGS && n < IDX_FP_REGS + 8) {\n\n#ifdef USE_X86LDOUBLE\n\n        /* FIXME: byteswap float values - after fixing fpregs layout. */\n\n        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);\n\n#endif\n\n        return 10;\n\n    } else if (n >= IDX_XMM_REGS && n < IDX_XMM_REGS + CPU_NB_REGS) {\n\n        n -= IDX_XMM_REGS;\n\n        if (n < CPU_NB_REGS32 ||\n\n            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {\n\n            env->xmm_regs[n].XMM_Q(0) = ldq_p(mem_buf);\n\n            env->xmm_regs[n].XMM_Q(1) = ldq_p(mem_buf + 8);\n\n            return 16;\n\n        }\n\n    } else {\n\n        switch (n) {\n\n        case IDX_IP_REG:\n\n            if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {\n\n                env->eip = ldq_p(mem_buf);\n\n                return 8;\n\n            } else {\n\n                env->eip &= ~0xffffffffUL;\n\n                env->eip |= (uint32_t)ldl_p(mem_buf);\n\n                return 4;\n\n            }\n\n        case IDX_FLAGS_REG:\n\n            env->eflags = ldl_p(mem_buf);\n\n            return 4;\n\n\n\n        case IDX_SEG_REGS:\n\n            return x86_cpu_gdb_load_seg(cpu, R_CS, mem_buf);\n\n        case IDX_SEG_REGS + 1:\n\n            return x86_cpu_gdb_load_seg(cpu, R_SS, mem_buf);\n\n        case IDX_SEG_REGS + 2:\n\n            return x86_cpu_gdb_load_seg(cpu, R_DS, mem_buf);\n\n        case IDX_SEG_REGS + 3:\n\n            return x86_cpu_gdb_load_seg(cpu, R_ES, mem_buf);\n\n        case IDX_SEG_REGS + 4:\n\n            return x86_cpu_gdb_load_seg(cpu, R_FS, mem_buf);\n\n        case IDX_SEG_REGS + 5:\n\n            return x86_cpu_gdb_load_seg(cpu, R_GS, mem_buf);\n\n\n\n        case IDX_FP_REGS + 8:\n\n            env->fpuc = ldl_p(mem_buf);\n\n            return 4;\n\n        case IDX_FP_REGS + 9:\n\n            tmp = ldl_p(mem_buf);\n\n            env->fpstt = (tmp >> 11) & 7;\n\n            env->fpus = tmp & ~0x3800;\n\n            return 4;\n\n        case IDX_FP_REGS + 10: /* ftag */\n\n            return 4;\n\n        case IDX_FP_REGS + 11: /* fiseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 12: /* fioff */\n\n            return 4;\n\n        case IDX_FP_REGS + 13: /* foseg */\n\n            return 4;\n\n        case IDX_FP_REGS + 14: /* fooff */\n\n            return 4;\n\n        case IDX_FP_REGS + 15: /* fop */\n\n            return 4;\n\n\n\n        case IDX_MXCSR_REG:\n\n            env->mxcsr = ldl_p(mem_buf);\n\n            return 4;\n\n        }\n\n    }\n\n    /* Unrecognised register.  */\n\n    return 0;\n\n}\n", "idx": 20345, "substitutes": {"cs": ["lc", "cc", "ix", "qs", "sk", "conn", "fs", "cons", "ks", "css", "pc", "ds", "CS", "ci", "sys", "nc", "cp", "vs", "cf", "ls", "rc", "c", "ctx", "js", "spec", "cn", "cfg", "sc", "core", "ns", "cus", "ps", "rs", "gs", "ck", "ips", "ec", "acs"], "mem_buf": ["ram_uf", "mem_seq", "ram_bur", "access64home", "memllbuf", "access_pub", "memlexbuf", "memlexqueue", "ram_queue", "Mem_buffer", "ram_buf", "memxbuff", "mem_bur", "memllbur", "memllbatch", "memfqueue", "access_buf", "mem_home", "memxuf", "mem64home", "memllbuff", "process_buf", "ram_buff", "memfbuffer", "mem2bur", "access64buf", "mem2queue", "ram_seq", "Mem_comb", "memlexuf", "mem_buff", "mem_queue", "Mem_buf", "process_uf", "mem_buffer", "Mem_queue", "mem64buf", "process_batch", "memfbuf", "access64pub", "memlluf", "mem_batch", "mem_comb", "access_home", "memxbuf", "memfuf", "memlexseq", "mem2uf", "mem64pub", "mem2buff", "process_buffer", "Mem_buff", "memllbuffer", "Mem_uf", "mem_pub", "memxcomb", "mem2buf", "mem_uf"], "n": [" N", "i", "name", "net", "native", "un", "e", "en", "nat", "conn", "yn", "adj", "nn", "g", "non", "none", "d", "mn", "not", "node", "no", "f", "dn", "t", "y", "N", "nc", "m", "u", "j", "init", "s", "r", "p", "current", "number", "o", "np", "ng", "network", "c", "rn", "nr", "num", "cn", "a", "b", "in", "min", "ns", "len", "br", "nb", "z", "v", "nt", "sn", "fn", "nor", "all", "nu", "l", "x", "pn", "ne", "k", "nm", "ni"], "cpu": ["lc", "platform", "bench", "net", "gpu", "conn", "nn", "g", "eni", "cm", " cp", "processor", "pc", "CPU", "node", "ea", "nc", "cp", "socket", "cache", "cf", "np", "c", "rn", "ctx", "num", "cn", "cfg", "cal", "mem", "python", "core", "pn", "proc", "vm", "instance", "clock", "pu", "ec"], "env": ["config", "event", "eur", "eni", "extra", "eff", "exc", "fg", "que", "context", " environments", "cdn", "global", "conf", "ev", "inet", "output", "org", "end", "conn", "db", "cv", "oa", "eng", "site", "ef", "enc", "assets", "code", "ext", "et", "cfg", "equ", " environment", "desc", "utils", "fen", "erv", "scope", "stack", "net", "e", "err", "eu", "kernel", "esp", "ea", "exec", "her", "uv", "cf", "cli", "Environment", "el", "enable", "gui", "loader", "core", "ne", "ec", "en", "obj", "energy", "export", "engine", "esi", "nc", "args", "cache", "vs", "dict", "np", "settings", "ctx", "cal", "viron", "session", "console", "estate", "server", "environment"], "tmp": [" v", " temp", " proc", "_", "temp", "img", " len", " c", "cp", "cache", " args", "np", " buf", "buf", " dest", " p", "mp", " src", "nb", "proc", "v", " ff", " result", " np", "max", " dst"]}}
{"project": "qemu", "commit_id": "1964a397063967acc5ce71a2a24ed26e74824ee1", "target": 0, "func": "static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)\n\n{\n\n    MigrationState *s = opaque;\n\n    if (qemu_file_get_error(s->file)) {\n\n        goto out;\n\n    }\n\n\n\n    s->xfer_limit = new_rate;\n\n\n\nout:\n\n    return s->xfer_limit;\n\n}\n", "idx": 5035, "substitutes": {"opaque": ["opatile", "oaaques", "ospaque", "openaques", "ospatile", " opifice", "oaaque", "openaque", "openatile", "oaacity", "ospifice", "opifice", " opacity", " opatile", "opaques", "copaques", "ospaques", "copaque", "opacity", "openifice", " opaques", "copacity"], "new_rate": [" new_rated", "new_limit", " new_limit", " new_range", "newWrates", " new_rates", "new_rates", "new_range", "newWlimit", "new_rated", "newWrated", "newWrate"], "s": ["o", "sets", "sf", "rates", "sec", "ins", "S", "ments", "spec", "sg", "scope", "ows", "als", "si", "sync", "sys", "ses", "services", "m", "ips", "states", "f", "ns", "sl", "ls", "ss", "cs", "hs", "e", "submit", "sb", "gs", "se", "ops", "secondary", "ks", "ds", "storage", "n", "qs", "ts", "su", "p", "south", "settings", "fs", "sa", "c", "os", "ssl", "sq", "sym", "ms", "es", "rs", "ps"]}}
{"project": "qemu", "commit_id": "ab9509cceabef28071e41bdfa073083859c949a7", "target": 1, "func": "void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)\n\n{\n\n    QXLDevSurfaceCreate surface;\n\n\n\n    memset(&surface, 0, sizeof(surface));\n\n\n\n    dprint(1, \"%s/%d: %dx%d\\n\", __func__, ssd->qxl.id,\n\n           surface_width(ssd->ds), surface_height(ssd->ds));\n\n\n\n    surface.format     = SPICE_SURFACE_FMT_32_xRGB;\n\n    surface.width      = surface_width(ssd->ds);\n\n    surface.height     = surface_height(ssd->ds);\n\n    surface.stride     = -surface.width * 4;\n\n    surface.mouse_mode = true;\n\n    surface.flags      = 0;\n\n    surface.type       = 0;\n\n    surface.mem        = (uintptr_t)ssd->buf;\n\n    surface.group_id   = MEMSLOT_GROUP_HOST;\n\n\n\n    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);\n\n}\n", "idx": 3076, "substitutes": {"ssd": ["csse", "rssdk", "bsD", "cssds", "cssd", "bsds", "pss", "sss", "psdk", "vse", "isssd", "ass", "vsd", "opensds", "sse", "bsdc", "pssd", "essd", "csssd", "vssd", "opensd", "issdk", "psdc", "asd", "psb", "bsd", "nsdc", "asds", "opensdk", "nsds", "nsd", "SSsd", "psds", "ssdb", "psd", "essdc", "ssdat", "ssb", "issds", " ssdb", "ssdc", "essds", "nsdk", "vsdc", " ssds", "rsssd", "asdk", "issd", "sssd", " ssdat", "nss", "SSdc", "rssd", "cssdb", "ssds", "issb", "essdb", "cssD", "cssdc", "SSds", "psD", "isse", "ssD", "rssdc", "rssdat", "esssd", "opensb", "rssds", "SSd", "issdc", "ssdk", "psdat", " sssd"], "surface": ["metadata", "generic", "peer", "folder", "faces", "sample", "client", "ula", "sheet", "sf", "master", " Surface", "sound", "database", "archive", "alpha", "sole", "f", "aster", "skin", "message", "cell", "cover", "texture", " surf", "spec", "interface", "filename", "image", "ui", "shell", "package", "ser", "request", "ptr", "resource", "core", "forge", "ope", "sr", "FACE", "tile", "tle", "player", "edge", "rect", "sym", "layer", "scene", "data", "use", "face", "proxy", "project", "slice", "document", "func", "content", "result", "pad", "setup", "public", "stream", "node", "bridge", "sur", "Sur", "enter", "slave", "stage", "server", "src", "buffer", "material", "wrapper", " surfaces", "area", "binary", "cur", "shared", "prototype", "source", "feature", "grave", "draw", "save", "airo", "console", "ace", "transfer", "game"]}}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static void hds_free(AVFormatContext *s)\n\n{\n\n    HDSContext *c = s->priv_data;\n\n    int i, j;\n\n    if (!c->streams)\n\n        return;\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        OutputStream *os = &c->streams[i];\n\n        if (os->out)\n\n            avio_close(os->out);\n\n        os->out = NULL;\n\n        if (os->ctx && os->ctx_inited)\n\n            av_write_trailer(os->ctx);\n\n        if (os->ctx && os->ctx->pb)\n\n            av_free(os->ctx->pb);\n\n        if (os->ctx)\n\n            avformat_free_context(os->ctx);\n\n        av_free(os->metadata);\n\n        for (j = 0; j < os->nb_extra_packets; j++)\n\n            av_free(os->extra_packets[j]);\n\n        for (j = 0; j < os->nb_fragments; j++)\n\n            av_free(os->fragments[j]);\n\n        av_free(os->fragments);\n\n    }\n\n    av_freep(&c->streams);\n\n}\n", "idx": 8112, "substitutes": {"s": ["o", "sets", "v", "is", "S", "spec", "sg", "b", "si", "sys", "ses", "services", "l", "xs", "f", "ns", "ls", "bs", "ss", "cs", "sis", "e", "sc", "sb", "ops", "ks", "gs", "ds", "t", "n", "ctx", "qs", "ts", "su", "p", "css", "fs", "ssl", "sq", "sym", "es", "rs", "ps", "js"], "c": ["cp", "oc", "ch", "o", "cr", "ci", "config", "b", "co", "C", "uc", "cm", "l", "cl", "f", "d", "pc", "cc", "cs", "ce", "u", "con", "mc", "e", "dc", "k", "n", "ctx", "t", "bc", "cu", "p", "ic", "ca", "ec", "h", "acs", "g", "lc", "cf", "ac", "vc", "conn", "cd", "tc"], "i": ["gi", "o", "ti", "v", "id", "I", "di", "ik", "ci", "ki", "ji", "ni", "b", "x", "si", "xi", "ri", "io", "info", "bi", "qi", "ix", "l", "f", "pi", "yi", "d", "ii", "iu", "it", "ai", "u", "e", "ori", "k", "n", "mi", "ini", "p", "h", "eni", "z", "oi", "hi", "ind", "ip", "y", "li", "index", "r", "zi", "ui"], "j": ["jet", "dy", "fr", "o", "v", "pr", "el", "a", "oj", "jl", "ji", "b", "xi", "x", "bi", "m", "qi", "kj", "l", "key", "f", "job", "ij", "d", "aj", "it", "q", "ii", "u", "e", "jen", "w", "J", "je", "jc", "k", "t", "n", "json", "uj", "jp", "jo", "err", "p", "z", "jj", "off", "g", "y", "ja", "dj", "br", "li", "adj", "bj", "js"], "os": ["ot", "as", "oc", "nos", "options", "o", "ans", "oses", "is", "osi", "oS", "dos", "po", "op", "object", "osa", "io", "oa", "ow", "ros", "et", "sys", "or", "ok", "obs", "so", "mos", "ols", "ns", "org", "obj", "mot", "ls", "bs", "us", "cs", "u", "des", "vs", "e", "rss", "ops", "ks", "ol", "ds", "OS", "oes", "oss", "of", "p", "ou", "css", "pos", "fs", "oi", "acs", "los", "bos", "iso", "oid", "Os", "aos", "es", "oos", "js"]}}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = g_malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n\n    g_free(ctx);\n\n}", "idx": 15132, "substitutes": {"opaque": [" opaques", "OPacre", "Opaque", "ipaques", "opatile", "opacre", "obatile", "opac", "obacity", "opaques", "obaque", "OPaques", "copaques", "ipacity", "opacity", "ipaque", "OPac", "Opacre", "Opaques", "copac", "copaque", " opacity", "copacre", "OPaque", "obaques", "ipatile", " opatile", "Opac"], "ret": ["alt", "ft", "rev", "reply", "t", "inter", "rc", "id", "val", "back", "pt", "rets", "gt", "fun", "sr", "pret", "xt", "det", "ref", "lit", "mt", "mem", "fin", "desc", "ext", "Ret", "result", " RET", "try", " Ret", "nt", "re", "rt", "sur", "rot", "pat", "RET", "res", "num", "cur", "reg", "flag", "len", "red"], "ctx": [" context", "tx", "bc", "wcs", "cmp", "fp", "loc", "np", "obj", "handler", "c", "cb", "cas", "sc", "cp", "command", "fc", "context", "cam", "sync", "cc", "gc", "lc", "conv", "cn", "cgi", "fn", "client", "lib", "grad", "instance", "six", "anc", "exec", "kb", "xc", "support", "git", "cci", "alloc", "path", "sys", "cv", "ca", "config", "pc", "connection", "ci", "wx", "cpu", "scope", "conn", "kw", "rx", "nc", "tc", "qt", "cfg", "gpu", "cf", "que", "prefix", "hw", "cl", "fw", "pkg", "cm", "qa", "unc", "jp", "utils", "Context", "ctrl", "sq", "p", "cli", "component", "cus", "parent", "wp", "cca", "crit", "cu", "sci", "general", "cmd", "vc", "qq", "css"], "t2": ["p2", "dt8", "T62", "p0", "dt6", "T2", "dt2", " t0", "t4", "t1", " t6", "p1", "d2", "dt62", "T0", "dt4", "T1", "T8", "d1", "T6", " t62", "T4", "t8", "d8", " t1", "t62", " t8", "p8", " t4", "t0", "dt1", "d0", "t6"], "cmp_buf": ["cmp2buffer", "cmp_uf", "cmp_cb", "cmp_bc", "cmp2uf", "cmp2cap", "mp_buf", "comp_buff", "comp_bc", "mp_cb", "mp_rb", "mp_buff", "comp_buffer", "comp_uf", "cmp_buff", "cmp_cap", "cmp2buf", "mp_buffer", "comp_buf", "mp_uf", "comp_cap", "cmp_rb", "cmp_buffer"]}}
{"project": "FFmpeg", "commit_id": "caa845851d790f894a2ccbe12580934f75545f92", "target": 0, "func": "static int output_data_internal(MLPDecodeContext *m, unsigned int substr,\n\n                                uint8_t *data, unsigned int *data_size, int is32)\n\n{\n\n    SubStream *s = &m->substream[substr];\n\n    unsigned int i, out_ch = 0;\n\n    int32_t *data_32 = (int32_t*) data;\n\n    int16_t *data_16 = (int16_t*) data;\n\n\n\n    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))\n\n        return -1;\n\n\n\n    for (i = 0; i < s->blockpos; i++) {\n\n        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {\n\n            int mat_ch = s->ch_assign[out_ch];\n\n            int32_t sample = m->sample_buffer[i][mat_ch]\n\n                          << s->output_shift[mat_ch];\n\n            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;\n\n            if (is32) *data_32++ = sample << 8;\n\n            else      *data_16++ = sample >> 8;\n\n        }\n\n    }\n\n\n\n    *data_size = i * out_ch * (is32 ? 4 : 2);\n\n\n\n    return 0;\n\n}\n", "idx": 13081, "substitutes": {"m": ["wm", "mc", "cm", "d", "t", "mp", "l", "fm", "g", "manager", "mn", "this", "module", "mod", "mm", "ym", "machine", "em", "tm", "v", "sim", "o", "ms", "mt", "gm", "mr", "p", "u", "bm", "e", "media", "b", "n", "f", "hm", "mos", "c", "pm", "M", "md", "man", "im", "mac", "dm", "y", "sm", "mu"], "substr": ["subStr", "conchar", "thstrings", "thstr", "constring", "constrings", "ubstring", "substring", " substring", "constr", "thstring", " subStr", "SubStr", "Substr", "Substring", "thchar", "ubStr", "subchar", " substrings", "substrings", "Subr", "ubstr", "ubr", " subchar", " subr", "subr"], "data": ["draw", "slice", "input", "d", "array", "batch", "shift", "code", "memory", "da", "sample", "a", "mu", "source", "image", "missing", "di", "buffer", "value", "frame", "output", "alpha", "open", "size", "p", "base", "multi", "result", "none", "dat", "block", "Data", "body", "change", "results", "scale", "one", "DATA", "cache", "window", "index", "start"], "data_size": ["sample_speed", "data_time", "data_speed", "data_scale", " data_depth", "sample_size", "data_depth", " data_scale", " data_speed", " data_time", "sample_scale"], "is32": [" is128", "Is128", "bis32", " is72", "isi31", "lis64", "is16", "Is64", " is16", "bis33", "Is16", "IS16", "mis31", "isi34", "isa31", "is31", "mis32", "iss33", "isa33", "iss64", "is72", "lis33", " is31", "mis34", "isa32", "lis72", "iss32", "isa16", "Is32", "isi64", "IS32", "isi32", "Is34", "Is31", "is34", "is64", "bis16", "is128", " is64", "is33", "lis32", "bis31", "IS128", " is33", "mis64", "iss72"], "s": ["ses", "d", "t", "service", "sync", "fs", "ins", "l", "sg", "rs", "rates", "g", "cs", "qs", "S", "hs", "os", "si", "js", "es", "sq", "session", "v", "ps", "ss", "sim", "client", "o", "w", "ms", "u", "p", "e", "site", "b", "sf", "sb", "n", "f", "gs", "hm", "spec", "c", "ns", "xs", "is", "ssl", "sl", "services", "ds", "r", "sa", "su", "comm", "ls", "ts", "space", "ims", "y", "sm"], "i": ["qi", "it", "ui", "ch", "I", "d", "ai", "ni", "xi", "id", "iu", "l", "ini", "gi", "oi", "io", "mu", "ci", "h", "di", "x", "si", "ie", "ii", "v", "uri", "yi", "u", "p", "e", "fi", "info", "mini", "mi", "li", "k", "b", "ix", "multi", "j", "phi", "n", "f", "ti", "ip", "c", "eni", "pi", "chi", "bi", "ri", "ei", "zi", "y", "index", "start"], "data_32": ["data_62", "data___16", "data___62", " data_62", " data_8", "data___8", " data_64", "data___32", "data_64", "data_8"], "data_16": [" data_36", " data_8", "data_18", " data_64", "data_36", "data_64", "data_8", " data_18"], "out_ch": ["mat_zh", "outRCH", "out_CH", "outxchan", "outxch", "outLchy", "mat_chi", "outJcher", "out_zh", "mat_chan", "outLcha", "outRconn", "at_chan", " outRCH", " outRch", "win_char", "out_size", "outRch", "out_chan", "outCch", " out_CH", " out_conn", "at_ch", "win_ach", "outCchi", "outLCh", "win_coll", "out_chy", "data_Ch", "out_char", "outLch", "outxzh", " outRcher", "out_conn", "outJconn", "data_cha", "data_chy", "outJch", "mat_ch", "out_ach", "outRcher", "outCchan", "data_ch", "at_char", "win_ch", "out_cher", " out_char", "outJach", " out_chan", "outCzh", "out_chi", " outRconn", " out_cher", "outJchar", "at_size", "out_coll", "outxchi", "out_cha", "outJCH", "outJcoll", "out_Ch"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void mainstone_common_init(MemoryRegion *address_space_mem,\n\n                                  MachineState *machine,\n\n                                  enum mainstone_model_e model, int arm_id)\n\n{\n\n    uint32_t sector_len = 256 * 1024;\n\n    hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n\n    PXA2xxState *mpu;\n\n    DeviceState *mst_irq;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    int be;\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    const char *cpu_model = machine->cpu_model;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa270-c5\";\n\n\n\n    /* Setup CPU & memory */\n\n    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);\n\n    memory_region_init_ram(rom, NULL, \"mainstone.rom\", MAINSTONE_ROM,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    /* There are two 32MiB flash devices on the board */\n\n    for (i = 0; i < 2; i ++) {\n\n        dinfo = drive_get(IF_PFLASH, 0, i);\n\n        if (!dinfo) {\n\n            if (qtest_enabled()) {\n\n                break;\n\n            }\n\n            fprintf(stderr, \"Two flash images must be given with the \"\n\n                    \"'pflash' parameter\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n\n                                   i ? \"mainstone.flash1\" : \"mainstone.flash0\",\n\n                                   MAINSTONE_FLASH,\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                                   sector_len, MAINSTONE_FLASH / sector_len,\n\n                                   4, 0, 0, 0, 0, be)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    mst_irq = sysbus_create_simple(\"mainstone-fpga\", MST_FPGA_PHYS,\n\n                    qdev_get_gpio_in(mpu->gpio, 0));\n\n\n\n    /* setup keypad */\n\n    pxa27x_register_keypad(mpu->kp, map, 0xe0);\n\n\n\n    /* MMC/SD host */\n\n    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n\n\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],\n\n            qdev_get_gpio_in(mst_irq, S0_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],\n\n            qdev_get_gpio_in(mst_irq, S1_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));\n\n\n\n    smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n\n                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n\n\n\n    mainstone_binfo.kernel_filename = machine->kernel_filename;\n\n    mainstone_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    mainstone_binfo.initrd_filename = machine->initrd_filename;\n\n    mainstone_binfo.board_id = arm_id;\n\n    arm_load_kernel(mpu->cpu, &mainstone_binfo);\n\n}\n", "idx": 13051, "substitutes": {"address_space_mem": ["address_space_model", "address_pace_mm", "address_space_memory", "address_stack_memory", "address_space67memory", "address_space_ram", "address_space_cpu", "address_service_lim", "address_space67cpu", "address_service_mem", "address_space2lim", "address_stack_cpu", "address_pace_mem", "address_space2mm", "address_pace_ram", "address_space_mm", "address_service_model", "address_stack_ram", "address_service_ram", "address_space2model", "address_space2memory", "address_space67mem", "address_space2ram", "address_space67ram", "address_space2mem", "address_space_lim", "address_pace_memory", "address_stack_mem"], "machine": ["device", "m", "mom", "service", "ram", "config", "mount", "memory", "object", "connection", "manager", "image", "cpu", "vm", "session", "slave", "managed", "computer", "storage", "loader", "mem", "resource", "boot", "comp", "Machine", "mode", "mo", "state", "process", "link", "host", "cache", "mac", "param", "node"], "model": ["Model", "zero", "vision", "cm", "complete", "array", "config", "code", "gment", "serial", "module", "mod", "scope", "gu", "de", "view", "data", "base", "mode", "address", "global", "block", "lu", "type", "man", "class", "core"], "arm_id": ["arm_root", " app_type", " app_ids", "arm_type", "armOtype", " app_id", "armOid", "armOids", " app_root", "armOroot", "arm_ids"], "mainstone_flash_base": ["mainstone_boot_base", "mainstone_booterarea", "mainstone_system_Base", "mainstone_boot_support", "mainstone_bootersupport", "mainstone_flash_Base", "mainstone_flasherbas", "mainstone_flashalarea", "mainstone_flasherbase", "mainstone_booterbase", "mainstone_flash_server", "mainstone_flash_bas", "mainstone_flashalsupport", "mainstone_flashalbas", "mainstone_system_bas", "mainstone_flashalbase", "mainstone_flash_area", "mainstone_flash_support", "mainstone_system_server", "mainstone_boot_area", "mainstone_flashersupport", "mainstone_flasherarea", "mainstone_boot_bas", "mainstone_booterbas", "mainstone_system_base"], "mpu": ["ppu", "mpcu", "mpus", "ampo", "ppcu", "mpui", "ampcu", "ppui", "mbui", "mpo", "mbiu", "mbu", " mpg", "mmc", "ampc", "ampa", "spu", "ppi", "ampi", "ppus", " mpo", "mpiu", " mpi", " mpc", "spui", "ampg", "mmg", "spus", "mmu", "spiu", "mpi", "mbus", "ppiu", "mpg", "ppo", " mpcu", "mpc", "mpa", " mpa", "ampu", "mma"], "mst_irq": ["mst_lrq", "mst_brp", "mst_lrqq", "mst_rinch", "mst_arce", "mst_mirch", "mst_rinp", "mst_mirce", "mst_mirw", "mst_irqq", "mst_arq", "mst_arch", "mst_rinq", "mst_brqq", "mst_mirqq", "mst_irw", "mst_mirq", "mst_irp", "mst_brw", "mst_rince", "mst_mirp", "mst_irch", "mst_irce", "mst_arp", "mst_lrw", "mst_lrp", "mst_brq"], "dinfo": ["dinf", "pinfo", " dinf", "ptype", "ddfo", "linfo", "dcheck", "bfi", "pfi", "dedinf", "ldinfo", "dedfo", "btype", "ddconfig", "binfo", " dconfig", " dfo", "dconfig", "kcheck", "dedInfo", "ddfi", "dInfo", "dtype", " dfi", "dedfi", "ldinf", "ldInfo", " dInfo", "kinfo", "pinf", "lInfo", " dtype", "ldfo", "dedconfig", "ddinfo", "dedinfo", "linf", "dfo", "kinf", " dcheck", "binf", "kInfo", "lcheck", "dfi"], "i": ["hi", "qi", "uni", "ui", "it", "adi", "slice", "I", "d", "input", "ni", "ai", "xi", "id", "iu", "ini", "gi", "l", "mu", "ci", "di", "x", "init", "ie", "si", "ii", "uri", "gu", "yi", "u", "z", "p", "e", "info", "mini", "mi", "li", "cli", "b", "multi", "j", "n", "phi", "ti", "ip", "c", "eni", "ji", "type", "pi", "chi", "udi", "r", "bi", "ri", "ori", "zi", "index"], "be": ["ke", "obe", " Be", "bis", "te", "ignore", " b", "Be", "ome", "ere", "trace", "me", "ine", "range", "ste", "ve", "use", "pose", "fore", "oe", "de", "console", "bee", "ee", "se", "e", "boot", " e", "he", "enable", " ne", "b", "byte", "component", "ore", "ape", "none", "fe", "BE", "pe", "ne", "is", "ro", "abe", "bes", "eb", " probe", " je", "ce", "scale", "le", "debug", "ble", "bi", "ache", "ae", "we", "see", "are", " BE", "bl", "ze"], "rom": ["aram", "camp", "m", "mc", "cm", "ru", "REM", "arm", "ram", "ray", "rs", "roc", "ra", "cpu", "rg", "vm", "gra", "ros", "rim", "prom", "region", "rum", "cr", "roy", "ran", "mem", "mor", "resource", "drm", "rb", "iam", "mode", "rm", "roma", "dem", "prem", "gram", "rome", "ro", "norm", "ROM", "rob", "cmd", "chrom", "coll", "pro", "com", "rock", "param", "r", "cp", "irm", "rem", "dim", "core", "ream", "sm", "lim"], "cpu_model": ["cache_channel", "cpu_location", "cpu_type", "cpu_view", "cpuermode", "core_models", "cpu_size", "gpu_mode", " cpu_contract", " cpu_mode", "cpuromodels", "cpuroimage", "cache_model", "cpufimage", "cpu_contract", "cpufmodels", "cpurotype", " cpu_resource", "cpu_channel", " cpu_view", "cpuerlayout", "cpuftype", "cpu_models", "core_model", "cpu_layout", "cpuromodel", "cpu_address", "cpufmodel", "core_type", "core_image", " cpu_layout", "cpu_mode", "cpu_image", "gpu_models", "cpu_resource", "cache_location", "gpu_model", "cpuermodel", "cpuercontract", "gpu_size", "cache_address"]}}
{"project": "qemu", "commit_id": "9c12a6f24d8bfd0e0d81a4a77f515e32d15547c1", "target": 0, "func": "void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    int host_port;\n\n    char buf[256] = \"\";\n\n    const char *p = src_str;\n\n    int is_udp = 0;\n\n    int n;\n\n\n\n    if (!slirp_inited) {\n\n        monitor_printf(mon, \"user mode network stack not in use\\n\");\n\n        return;\n\n    }\n\n\n\n    if (!src_str || !src_str[0])\n\n        goto fail_syntax;\n\n\n\n    get_str_sep(buf, sizeof(buf), &p, ':');\n\n\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    host_port = atoi(p);\n\n\n\n    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);\n\n\n\n    monitor_printf(mon, \"removed %d host forwarding rules for %s\\n\", n,\n\n                   src_str);\n\n    return;\n\n\n\n fail_syntax:\n\n    monitor_printf(mon, \"invalid format\\n\");\n\n}\n", "idx": 24213, "substitutes": {"mon": ["ban", "wan", "bin", "m", "mont", "bo", "uno", "module", "mot", "config", "am", "mr", "meter", "mat", "mut", "bean", "dom", "mos", "blue", "mic", "mag", "MON", "mer", "con", "atom", "mt", "ann", "lin", "mn", "mun", "mand", "mo", "plan", "mc", "mas", "block", "mor", "man", "mini", "tun", "tom", "un", "bm", "mm", "amon", "an", "mu", "Mon", "monitor", "nan", "mons"], "src_str": ["src_string", "source_Str", "src_Str", "src_list", " src_list", " src_br", "src2str", " src_string", "src2br", "source_string", "rc_char", "src2string", "rc_Str", "source_br", "rc_str", "source_str", "src_char", "rc_br", "src_br", "src_arr", "rc_arr", "src2Str"], "host_port": ["node_addr", "port_port", "host_addr", "server_port", "hostaltype", "node_port", "host_host", "port_host", "hostaladdress", "host_address", "hostalpoint", "server_address", "host_type", "port_length", "host_PORT", "node_PORT", "hostalport", "host_length", "host_point", "server_point", "server_type"], "buf": ["seq", "uf", "bag", "received", "uc", "b", "batch", "wb", "c", "pkg", "context", "cat", "cv", "exc", "grab", "bb", "enc", "buffer", "queue", "vec", "data", "text", "ab", "rb", "bf", "bh", "bd", "br", "cb", "cur", "bc", "prop", "port", "bu", "bus", "pad", "cmp", "bed", "raw", "fab", "brace", "feed", "home", "ff", "ba", "cmd", "str", "pb", "cap", "la", "path", "padding", "loc", "bound", "box", "ctx", "fb", "cf", "rc", "conv", "bags", "cas", "buff", "h", "f", "bytes", "agg", "src", "func", "fd"], "p": ["pp", "pa", "np", "w", "i", "b", "m", "c", "pt", "d", "x", "api", "P", "pointer", "jp", "prefix", "ps", "port", "bp", "u", "point", "sp", "e", "o", "padding", "pb", "s", "ctx", "cp", "wp", "h", "part", "f", "y", "pr", "ip", "tp", "t", "fp", "j", "q", "pipe", "v", "r", "vp", "l", "pc", "ap"], "n": ["node", "k", "none", "z", "nat", "sn", "i", "m", "b", "name", "ns", "pn", "d", "c", "fn", "en", "nn", " N", "num", "ne", "nor", "e", "o", "min", "nb", "ni", "nt", "cn", "number", "ng", "N", "y", "nr", "j", "na", "t", "nl", "v", "nu", "ind", "nc", "l", "len", "dn", "g"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    if (atom.size <= 40)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n\n\n    if ((uint64_t)atom.size > (1<<30))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    av_free(st->codec->extradata);\n\n    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!st->codec->extradata)\n\n        return AVERROR(ENOMEM);\n\n    st->codec->extradata_size = atom.size - 40;\n\n    avio_skip(pb, 40);\n\n    avio_read(pb, st->codec->extradata, atom.size - 40);\n\n    return 0;\n\n}\n", "idx": 305, "substitutes": {"c": ["fc", "cm", "cs", "ctx", "anc", "cc", "mc", "cl", "ct", "co", "nc", "bc", "cur", "cy", "con", "tc", "cus", "enc", "ac", "coll", "cont", "cr", "ch", "C", "ec", "dc", "ce", "h", "cu", "p", "xc", "cv", "l", "e", "lc", "f", "conf", "ca", "ctrl", "cd", "sc", "u", "cache", "vc", "cit", "pc", "s", "icc", "cp", "t", "cf", "ic", "ci", "uc"], "pb": ["pl", "cm", "fc", "ctx", "bh", "lp", "ppa", "pd", "sb", "bps", "cpp", "lb", "ab", "hub", "eb", "prot", "bm", "rob", "pg", "bc", "tmp", "api", "PB", "tp", "rb", "fp", "cb", "bf", "pa", "p", "lc", "jp", "obj", "bp", "pc", "fb", "cp", "b", "aph", "pro", "dp", "pt", "uc", "typ", "pp", "db", "xb"], "atom": ["cm", "base", "orb", "null", "np", "material", "http", "arb", "term", "bn", "a", "acl", "fac", "chrom", "data", "ab", "xml", "image", "url", "com", "month", "type", "prop", "bc", "operator", "op", "num", "dom", "instance", "param", "m", "item", "fab", "chem", "mag", "temp", "om", "config", "source", "atomic", "x", "orbit", "arc", "article", "attr", "app", "arm", "object", "art", "obj", "mom", "amp", "canon", "tm", "asm", "um", "at", "b", "plane", "cell", "module", "element", "container", "account", "car", "tom", "an", "monitor", "wp", "emb", "typ", "perm", "sym"], "st": ["stage", "fc", "ist", "ust", "se", "ld", "src", "this", "rest", "ss", "sa", "sd", "sb", "cl", "r", "ad", "ct", " est", "sp", "sl", "end", "St", "bl", "ste", "kt", "ft", "fr", "nt", "cr", "str", "fe", "l", "sw", "start", "ut", "ptr", "lc", "sc", "ST", "stream", "art", "std", "sec", "amp", "sn", "s", "sts", "b", "sta", "t", "inst", "stop", "ost", "nd", "ast", "pt", "ace", "pp", "sth", "est"]}}
{"project": "FFmpeg", "commit_id": "951e715cebfaffced7f13c1525771ff917fe1d38", "target": 1, "func": "static int video_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFrame *frame = avcodec_alloc_frame();\n\n    int64_t pts_int;\n\n    double pts;\n\n    int ret;\n\n\n\n#if CONFIG_AVFILTER\n\n    AVFilterGraph *graph = avfilter_graph_alloc();\n\n    AVFilterContext *filt_out = NULL;\n\n    int64_t pos;\n\n    int last_w = is->video_st->codec->width;\n\n    int last_h = is->video_st->codec->height;\n\n\n\n    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n        goto the_end;\n\n    filt_out = is->out_video_filter;\n\n#endif\n\n\n\n    for (;;) {\n\n#if !CONFIG_AVFILTER\n\n        AVPacket pkt;\n\n#else\n\n        AVFilterBufferRef *picref;\n\n        AVRational tb;\n\n#endif\n\n        while (is->paused && !is->videoq.abort_request)\n\n            SDL_Delay(10);\n\n#if CONFIG_AVFILTER\n\n        if (   last_w != is->video_st->codec->width\n\n            || last_h != is->video_st->codec->height) {\n\n            av_dlog(NULL, \"Changing size %dx%d -> %dx%d\\n\", last_w, last_h,\n\n                    is->video_st->codec->width, is->video_st->codec->height);\n\n            avfilter_graph_free(&graph);\n\n            graph = avfilter_graph_alloc();\n\n            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n                goto the_end;\n\n            filt_out = is->out_video_filter;\n\n            last_w = is->video_st->codec->width;\n\n            last_h = is->video_st->codec->height;\n\n        }\n\n        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);\n\n        if (picref) {\n\n            pts_int = picref->pts;\n\n            pos     = picref->pos;\n\n            frame->opaque = picref;\n\n        }\n\n\n\n        if (av_cmp_q(tb, is->video_st->time_base)) {\n\n            av_unused int64_t pts1 = pts_int;\n\n            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);\n\n            av_dlog(NULL, \"video_thread(): \"\n\n                    \"tb:%d/%d pts:%\"PRId64\" -> tb:%d/%d pts:%\"PRId64\"\\n\",\n\n                    tb.num, tb.den, pts1,\n\n                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);\n\n        }\n\n#else\n\n        ret = get_video_frame(is, frame, &pts_int, &pkt);\n\n#endif\n\n\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (!ret)\n\n            continue;\n\n\n\n        pts = pts_int * av_q2d(is->video_st->time_base);\n\n\n\n#if CONFIG_AVFILTER\n\n        ret = output_picture2(is, frame, pts, pos);\n\n#else\n\n        ret = output_picture2(is, frame, pts,  pkt.pos);\n\n        av_free_packet(&pkt);\n\n#endif\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (step)\n\n            if (cur_stream)\n\n                stream_pause(cur_stream);\n\n    }\n\n the_end:\n\n#if CONFIG_AVFILTER\n\n    avfilter_graph_free(&graph);\n\n#endif\n\n    av_free(frame);\n\n    return 0;\n\n}\n", "idx": 6489, "substitutes": {"arg": ["abc", "as", "ig", "play", "ag", "emb", "Ar", "val", "rc", "inter", "enc", "Args", "ray", "ad", "or", "ace", "inc", "argument", "like", "args", "param", "arc", "ar", "arr", "ang", "p", "array", "parse", "amp", "asm", "AR", "Arg", "var", "g", "util", "ref", "fi", "mor", "par"], "is": ["isi", "serv", "ris", "rid", "i", "IS", "obs", "iris", "ii", "active", "bs", "ar", "any", "nis", "iz", "irc", "id", "bits", "s", "see", "info", "its", "ls", "iss", "ai", "it", "uri", "ops", "bis", "vis", "ini", "ie", "ais", "parse", "his", "ip", "ms", "iso", "isc", "ui", "as", "kit", "are", "lis", "op", "ri", "or", "ses", "image", "isl", "has", "esi", "isa", "the", "ics", "sis", "vs", "mis", "ist", "inst", "isin", "ic", "css", "os", "im", "api", "app", "Is", "http", "mes", "get", "si", "sys", "in", "ir", "init", "us", "ss", "full", "ori", "eni", "il", "es"], "frame": ["game", "base", "flow", "fr", "block", "parent", "note", "session", "config", "layout", "force", "feature", "iframe", "slice", "za", "image", "Frame", "draw", "live", "fb", " Frame", "window", "f", "fake", "picture", "rame", "state", "series", "document", "fe", "part", "point", "file", "fram", "plane", "cycle", "framework", "boot", "fab", "shot", "line", "node", "setup", "thread", "video", "model", "frames", "element", "ref", "fi", "host", "ze", "view"], "pts_int": ["pts_bit", "PT\n", "pts_str", "pts1bit", "pt\n", "ptts_inter", "ct\n", "point\n", "pts1int", "pts_full", "ptsets_full", "ptsets_int", "ptts_long", "pts_inter", "ptts_int", "pts_long", "ptts_str", "ptsets_bit", "pts1full"], "pts": ["periods", "ctsets", "ptcount", "ptsets", "ctcount", "PTs", "ctls", "ptS", "periodcount", "PTcount", "ctsi", " ptsets", "cts", "PTS", " prefsi", " prefs", "periodS", " prefsets", "ctS", "ctd", "PTd", "ptd", "periodd", " prefls", "ptsi", " ptsi", " ptls", "ptls"], "ret": ["reg", "mem", "rt", "id", "alt", "nt", "rot", "val", "cat", "let", "reply", "status", " RET", "fin", " Ret", "lit", "att", "obj", "res", "match", "def", "part", "len", "mt", "det", "arr", "RET", "feat", "rev", "result", "seq", "Ret", "ft", "ut", "opt", "re", "fun", "back", "hash", "resp", "gt", "ref", "conn", "rets"], "graph": ["flow", "gp", "complex", "feed", "hub", "parent", "shadow", "shape", "scope", "session", "edge", "layout", "config", "stack", "growth", "stream", "widget", "module", "gpu", "image", "draw", "dot", "pg", "document", "connect", "man", "facebook", "proxy", "connection", "gener", "path", "hou", "go", "ghost", "container", "bridge", "context", "pool", "h", "network", "gen", "hog", "raph", "node", "tree", "g", "closure", "Graph", "gd", "model", "query", "gh", "ha", "cache", "group", "grad", "conn", "google", "view"], "filt_out": ["flt_work", "failJout", "facet_in", "fft_out", "filt_string", "failJstring", "filterexternal", "filt_Out", "fail_out", "fail_in", "filterout", "fail_string", "failJin", "filt_work", "flt_in", "filterstring", "fft_string", "flt_out", "facet_out", "failJref", "facet_list", "fft_external", "filt_ref", "filtJin", "filtJstring", "filt_list", "filtJout", "flt_Out", "filt_external", "filt_in", "filtJref", "fail_ref"], "pos": ["points", "base", "pid", "axis", "position", "padding", "block", "count", "alt", "spec", "channel", "po", "rot", "val", "sum", "data", "style", "bit", "rel", "body", "pt", "vals", "offset", "obj", "args", "pc", "POS", "conf", "Pos", "part", "len", "code", "col", "depth", "port", "lat", "vis", "str", "seq", "prop", "start", "fs", "pose", "os", "doc", "pointer", "cap", "type", "bl", "cache", "ref", "index", "src", "neg", "slot"], "pkt": ["pbct", "Pkt", "bct", "pbacket", "pbft", "pft", "pct", "packet", "Pct", "bkt", "bft", "Pft", "pbkt", "Packet", "backet"], "picref": ["picre", "synRef", "fcref", "nicREF", "cusreference", " picrel", "icRef", "pictREF", "picrel", "chatref", "PicRef", "icror", "pcrel", "synreference", "Picalt", "licRef", "chatror", "synrel", "icreference", " picalt", "pcalt", "PicREF", "pictref", "chatreference", "fcrel", "picalt", "pictalt", "licreference", "picreference", "picREF", "cusref", "pcref", "pinrel", "licrel", "pinror", "picRef", " picREF", "nicref", "Picref", "chatrel", "fcreference", "pinreference", "pcreference", "icref", "picror", "pictreference", " picreference", "cusre", "Picreference", "fcRef", "nicreference", "cusREF", "icrel", "synref", "pcRef", "nicre", "pinalt", "licref", "pinref", "Picrel", "Picre"], "tb": ["ptbm", " ptbm", "tbm", "btz", "tzb", "ptbs", "btb", " tbl", "itp", "ctbs", " ptbs", "ptb", "itbs", "ctp", " tbs", "tbs", " ptb", "atb", "btbs", "btzb", "itbl", " tbm", "atzb", "tz", "ttbs", "ttz", "ttb", "ctb", " tp", "atz", "ctbl", "tp", "itb", "ttzb", "tbl", "atbs"]}}
{"project": "qemu", "commit_id": "b7680cb6078bd7294a3dd86473d3f2fdee991dd0", "target": 0, "func": "int qemu_cpu_self(void *env)\n\n{\n\n    return 1;\n\n}\n", "idx": 178, "substitutes": {"env": ["buffer", "ctx", "context", "device", "data", "global", "environment", "nc", "scope", "enc", "py", "proc", "code", "config", "ec", "p", "dev", "e", "core", "all", "exec", "viron", "en", "ev", "path", "console", "rc", "port"]}}
{"project": "qemu", "commit_id": "f1d3b99154138741161fc52f5a8c373bf71613c6", "target": 1, "func": "static void pci_basic(gconstpointer data)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QPCIBus *bus;\n\n    QVirtQueuePCI *tx, *rx;\n\n    QGuestAllocator *alloc;\n\n    void (*func) (const QVirtioBus *bus,\n\n                  QVirtioDevice *dev,\n\n                  QGuestAllocator *alloc,\n\n                  QVirtQueue *rvq,\n\n                  QVirtQueue *tvq,\n\n                  int socket) = data;\n\n    int sv[2], ret;\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    bus = pci_test_start(sv[1]);\n\n    dev = virtio_net_pci_init(bus, PCI_SLOT);\n\n\n\n    alloc = pc_alloc_init();\n\n    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 0);\n\n    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 1);\n\n\n\n    driver_init(&qvirtio_pci, &dev->vdev);\n\n    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);\n\n\n\n    /* End test */\n\n    close(sv[0]);\n\n    guest_free(alloc, tx->vq.desc);\n\n    pc_alloc_uninit(alloc);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n    qpci_free_pc(bus);\n\n    test_end();\n\n}\n", "idx": 6217, "substitutes": {"data": ["pack", "append", "a", "parent", "done", "di", "dat", "device", "dd", "config", "val", "sync", "info", "buf", "window", "valid", "package", "d", "init", "DATA", " DATA", "def", "buffer", "connection", "ops", "da", "Data", "timeout", "exec", "multi", "devices", "result", "array", "input", "p", "reader", "batch", "proc", "cache", "next"], "dev": ["hw", "reg", "od", "v", "prof", "id", "rad", "pu", "pro", "di", "Dev", "dd", "device", "adv", "md", "config", "plug", "bug", "tr", "rc", "ow", "enc", "ad", "info", "debug", "der", "valid", "gu", "package", "d", "ve", "mod", "fo", "dist", "conf", "ev", "def", "DEV", "wd", "priv", "prom", "w", "error", "da", "dc", "driver", "self", "pub", "serial", "req", "boot", "ver", "gh", "var", "off", "node", "api", "engine", "cache", "app", "vc", "prov", "grad", "conn", "diff"], "bus": ["plugin", "base", "cmp", "build", "feed", "block", "hub", "local", "http", "pu", "BUS", "device", "config", "plug", "bug", "b", "io", "sync", "bit", "cat", "Bus", "buf", "db", "usb", "book", "us", "def", "mount", "connection", "driver", "port", "lib", "path", "ux", "bc", "pass", "self", "bridge", "pub", "serial", "this", "boot", "proc", "os", "class", "board", "pl", "cache", "test", "index", "fi", "conn"], "tx": ["rw", "ti", "pull", "wx", "trial", "device", "x", "tr", "ax", "raf", "sync", "rc", "rel", "co", "pt", "TX", "fx", "loc", "der", "ty", "ix", "ran", "ra", "pc", "q", "def", "ck", "mc", "w", "auth", "t", "ctx", "ux", "bc", "Tx", "context", "temp", "ca", "req", "reader", "trans", "gh", "ta", "txt", "cf", "ac", "cache", "test", "cross", "cas", "worker", "tc"], "rx": ["rw", "vr", "rt", "fw", "rr", "wx", "eth", "rb", "x", "ri", "rc", "raf", "rd", "rf", "ax", "rel", "wa", "co", "sync", "loc", "fx", "rh", "ru", "ra", "rou", "nr", "pc", "ry", "wd", "ck", "rss", "rg", "ctx", "ux", "lr", "rl", "rin", "req", "lex", "reader", "mr", "src", "rs", "r", "xc"], "alloc": ["vol", "oc", "cmp", "afi", "hw", "anc", "pack", "mem", "wx", "pu", "fee", "config", "rac", "rc", "raf", "enc", "auc", "uc", "loc", "buf", "valid", "mac", "capacity", "ga", "attr", "soc", "org", "win", "pc", "ack", "init", "oca", "conf", "acl", "sc", "random", "ctx", "ux", "exec", "cu", "bc", "voc", "go", "coll", "nil", "pool", "access", "ec", "req", "gen", "toc", "c", "addr", "util", "asc", "ac", "isc", "aux", "au", "cache", "loader", "vc", "conn", "pkg", "aw"], "func": ["function", "unc", " function", "wrapper", "rb", "val", "nc", "sync", "lambda", "sys", "module", "buf", "package", "f", "call", "obj", "pc", "cc", "loop", "code", "fn", "lib", "Function", "bc", "cb", "dll", "exec", "callback", "work", "self", "fun", "proc", "class", "cf", "lc", "fc", "addr", "src", "conn", "worker"], "rvq": ["rpw", "rpq", "RvQ", "Rvw", "rvw", "Rpw", "rvvQ", "rvvflow", "rpflow", "Rpq", "rvvw", "rvvq", "rww", "rwflow", "Rvflow", "RpQ", "rvflow", "Rpflow", "rwQ", "rvQ", "Rvq", "rwq", "rpQ"], "tvq": ["voltq", "tvqueue", "voltqa", "vuq", "uvqueue", "voltqs", "uvqs", "tvqs", "vuqs", "uvqa", "vuqa", "uvq", "tvqa", "vuqueue", "voltqueue"], "socket": ["sf", "channel", "config", "ockets", "ocket", " sock", "sync", "sn", "stream", "buf", "server", "sl", "ss", "port", " sockets", "timeout", "seq", "pool", "cpu", "proc", "ssl", "sq", "src", "conn", "Socket", "slot"], "sv": ["nv", "ipt", "serv", "sf", "v", "s", "vt", "si", "sn", "sys", "services", "vector", "uv", "status", "isl", "db", "csv", "null", " SV", "sk", "support", "sl", "sm", "series", "av", "service", "ss", "vi", "vs", "sh", "via", "sb", "sql", "zip", "sd", "ds", "timeout", "su", "temp", "ft", "sp", "iv", "vl", "ssl", "sq", "lv", "api", "ov", "vv", "cv", "vc"], "ret": ["flag", "reg", "no", "mem", "rt", "cur", "alt", "nt", "pin", "val", "rc", "inter", "bit", "reply", "status", "valid", "fin", "f", "lit", "att", "arg", "res", "len", "code", "det", "en", "RET", "ben", "pass", "result", "Ret", "ft", "re", "fun", "success", "ref", "fi", "addr", "r", "rets"]}}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void show_help(void)\n\n{\n\n    const char *prog;\n\n    const OptionDef *po;\n\n    int i, expert;\n\n    \n\n    prog = do_play ? \"ffplay\" : \"ffmpeg\";\n\n\n\n    printf(\"%s version \" FFMPEG_VERSION \", Copyright (c) 2000, 2001, 2002 Gerard Lantau\\n\", \n\n           prog);\n\n    \n\n    if (!do_play) {\n\n        printf(\"usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\\n\"\n\n               \"Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\\n\");\n\n    } else {\n\n        printf(\"usage: ffplay [options] input_file...\\n\"\n\n               \"Simple audio player\\n\");\n\n    }\n\n           \n\n    printf(\"\\n\"\n\n           \"Main options are:\\n\");\n\n    for(i=0;i<2;i++) {\n\n        if (i == 1)\n\n            printf(\"\\nAdvanced options are:\\n\");\n\n        for(po = options; po->name != NULL; po++) {\n\n            char buf[64];\n\n            expert = (po->flags & OPT_EXPERT) != 0;\n\n            if (expert == i) {\n\n                strcpy(buf, po->name);\n\n                if (po->flags & HAS_ARG) {\n\n                    strcat(buf, \" \");\n\n                    strcat(buf, po->argname);\n\n                }\n\n                printf(\"-%-17s  %s\\n\", buf, po->help);\n\n            }\n\n        }\n\n    }\n\n\n\n    exit(1);\n\n}\n", "idx": 21050, "substitutes": {"prog": ["proge", "Progs", "pregs", "Progn", "rougs", "Prog", "prob", "progn", "prb", "prgg", " proge", " prob", "rouG", "proG", "pregn", "progs", "ProG", "puge", "proga", " progs", "preG", " proG", "prega", "prge", " progg", "Proga", "rouga", "progg", "prg", "pug", "pugg", "preg", "roug", " progn", "pub"], "po": ["Ko", "ee", "obj", "oo", "oe", "jp", "pe", "ao", "oa", "apo", "pd", "Po", "pc", "so", "no", "yo", "elo", "pos", "pg", "op", "pre", "wo", "mo", "obo", "da", "pp", "gro", "p", "zone", "o", "py", "lo", "pr", "la", "pro", "aco", "cho", "bo", "vo", "flo", "va", "PO", "aa", "co", "ps", "ote", "ko", "li", "odo", "jo", "pi", "ppa", "poke", "pa", "ppo"], "i": ["io", "lc", "e", "ix", "ie", "fi", "qi", "ri", "ind", "ui", "part", "gi", "d", "uri", "ti", "I", "l", "f", "hei", "ci", "split", "r", "oi", "ini", "u", "it", "j", "phi", "p", "ip", "id", "o", "bi", "ori", "cli", "mi", "c", "index", "si", "a", "ii", "in", "b", "n", "iu", "slice", "ai", "xi", "hi", "di", "yi", "multi", "v", "li", "z", "api", "pi", "x", "zi", "ni", "type"], "expert": ["comret", "expr", "invert", "pretern", "intervert", "inert", "expconfig", "xert", "interert", "exlr", "prepert", "Exvert", "comtern", "Exert", "exert", "exvert", " exret", "explr", "xlr", "inpert", "interpr", "Expr", "preper", "compert", "Exconfig", "exret", "preret", "exppert", "inpr", "exconfig", "comper", " exper", "xpert", "xconfig", "Expert", "exper", "Exlr", "interpert"], "buf": ["begin", "bc", "str", "uf", "binary", "uc", "brace", "nat", "ba", "fab", "board", "ha", "cv", "fb", "queue", "utf", "Buff", "img", "home", "fp", "cas", "buffer", "path", "xff", "alloc", "cmd", "box", "cat", "cf", " buffer", "wb", "font", "rc", "cb", "ctx", "la", "b", "seq", "auc", "desc", "fd", "src", "fw", "bd", "br", "append", "Buffer", "aka", "buff", "proc", "bh", "bag", "rb", "vec", "block", "lit", "fi", "cap"]}}
{"project": "qemu", "commit_id": "9e14037f05e99ca3b8a33d8be9a2a636bbf09326", "target": 1, "func": "static void msmouse_chr_close (struct CharDriverState *chr)\n\n{\n\n    MouseState *mouse = chr->opaque;\n\n\n\n    qemu_input_handler_unregister(mouse->hs);\n\n    g_free(mouse);\n\n    g_free(chr);\n\n}\n", "idx": 11501, "substitutes": {"chr": ["cr", " chra", "ichm", "csr", "Chre", "cra", "chra", "ichre", " chsr", "ichsr", "car", "chsr", "Chra", "Chm", "Char", "chre", "Chr", "Chsr", "Chmr", "chmr", "chm", " chre", " chmr", "ichmr", " chm", "ichr"], "mouse": ["voice", "parent", "mac", "cookie", "me", "key", "chrome", "m", "phy", "poke", "pointer", "wire", "bridge", "rule", "close", "server", "circle", "bug", "gro", "hover", "click", "mid", "sym", "ctrl", "ae", "shape", "Mouse", "scope", "master", "move", "input", "query", "event", "remote", "state", "ctx", "inner", "address", "nick", "copy", "cue", "controller", "self", "handler", "cm", "press", "mc"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int block_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n\n\n    DPRINTF(\"Enter save live complete submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* we know for sure that save bulk is completed and\n\n       all async read completed */\n\n    blk_mig_lock();\n\n    assert(block_mig_state.submitted == 0);\n\n    blk_mig_unlock();\n\n\n\n    do {\n\n        ret = blk_mig_save_dirty_block(f, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (ret == 0);\n\n\n\n    /* report completion */\n\n    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);\n\n\n\n    DPRINTF(\"Block migration completed\\n\");\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n\n\n    blk_mig_cleanup();\n\n    return 0;\n\n}\n", "idx": 17411, "substitutes": {"f": ["m", "fr", "xf", "fw", "t", "fp", "x", "ref", "info", "fe", "r", "file", "elf", "fa", "feed", "cf", "g", "i", "fc", "fs", "rf", "self", "fen", "o", "fo", "fx", "l", "d", "df", "bf", "w", "fd", "e", "k", "fb", "front", "v", "c", "F", "p", "b", "fm", "tf", "fn", "form", "h", "sf"], "opaque": ["ipoc", "ipaque", "obhole", "Ohole", "Ofac", "obfac", "ipfac", "opfac", "iphole", "opoc", "ophole", "oboc", "obaque", "Ooc", "Oaque"], "ret": ["part", "db", "code", "data", "ref", "alt", "true", "let", "lit", "nt", "reg", "rt", "fun", "result", "num", "flag", "match", "bare", "pass", "orig", "ext", "fin", "run", "rf", "active", "def", "rets", "en", "out", "art", "att", "arg", "bad", "val", "re", "Ret", "bf", "fail", "back", "reset", "value", "det", "fit", "sr", "rev", "cat", "post", "rb", "hard", "url", "gt", "RET", "pat", "error", "red", "rep", "res", "pet", "mt", "ft", "valid", "iter", "reply", "success", "len"]}}
{"project": "FFmpeg", "commit_id": "c776531aef9b546ca576d4c8e3ec14a513394618", "target": 0, "func": "static int vqa_decode_chunk(VqaContext *s)\n\n{\n\n    unsigned int chunk_type;\n\n    unsigned int chunk_size;\n\n    int byte_skip;\n\n    unsigned int index = 0;\n\n    int i;\n\n    unsigned char r, g, b;\n\n    int index_shift;\n\n    int res;\n\n\n\n    int cbf0_chunk = -1;\n\n    int cbfz_chunk = -1;\n\n    int cbp0_chunk = -1;\n\n    int cbpz_chunk = -1;\n\n    int cpl0_chunk = -1;\n\n    int cplz_chunk = -1;\n\n    int vptz_chunk = -1;\n\n\n\n    int x, y;\n\n    int lines = 0;\n\n    int pixel_ptr;\n\n    int vector_index = 0;\n\n    int lobyte = 0;\n\n    int hibyte = 0;\n\n    int lobytes = 0;\n\n    int hibytes = s->decode_buffer_size / 2;\n\n\n\n    /* first, traverse through the frame and find the subchunks */\n\n    while (bytestream2_get_bytes_left(&s->gb) >= 8) {\n\n\n\n        chunk_type = bytestream2_get_be32u(&s->gb);\n\n        index      = bytestream2_tell(&s->gb);\n\n        chunk_size = bytestream2_get_be32u(&s->gb);\n\n\n\n        switch (chunk_type) {\n\n\n\n        case CBF0_TAG:\n\n            cbf0_chunk = index;\n\n            break;\n\n\n\n        case CBFZ_TAG:\n\n            cbfz_chunk = index;\n\n            break;\n\n\n\n        case CBP0_TAG:\n\n            cbp0_chunk = index;\n\n            break;\n\n\n\n        case CBPZ_TAG:\n\n            cbpz_chunk = index;\n\n            break;\n\n\n\n        case CPL0_TAG:\n\n            cpl0_chunk = index;\n\n            break;\n\n\n\n        case CPLZ_TAG:\n\n            cplz_chunk = index;\n\n            break;\n\n\n\n        case VPTZ_TAG:\n\n            vptz_chunk = index;\n\n            break;\n\n\n\n        default:\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: Found unknown chunk type: %c%c%c%c (%08X)\\n\",\n\n            (chunk_type >> 24) & 0xFF,\n\n            (chunk_type >> 16) & 0xFF,\n\n            (chunk_type >>  8) & 0xFF,\n\n            (chunk_type >>  0) & 0xFF,\n\n            chunk_type);\n\n            break;\n\n        }\n\n\n\n        byte_skip = chunk_size & 0x01;\n\n        bytestream2_skip(&s->gb, chunk_size + byte_skip);\n\n    }\n\n\n\n    /* next, deal with the palette */\n\n    if ((cpl0_chunk != -1) && (cplz_chunk != -1)) {\n\n\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CPL0 and CPLZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* decompress the palette chunk */\n\n    if (cplz_chunk != -1) {\n\n\n\n/* yet to be handled */\n\n\n\n    }\n\n\n\n    /* convert the RGB palette into the machine's endian format */\n\n    if (cpl0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cpl0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        /* sanity check the palette size */\n\n        if (chunk_size / 3 > 256 || chunk_size > bytestream2_get_bytes_left(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found a palette chunk with %d colors\\n\",\n\n                chunk_size / 3);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        for (i = 0; i < chunk_size / 3; i++) {\n\n            /* scale by 4 to transform 6-bit palette -> 8-bit */\n\n            r = bytestream2_get_byteu(&s->gb) * 4;\n\n            g = bytestream2_get_byteu(&s->gb) * 4;\n\n            b = bytestream2_get_byteu(&s->gb) * 4;\n\n            s->palette[i] = (r << 16) | (g << 8) | (b);\n\n        }\n\n    }\n\n\n\n    /* next, look for a full codebook */\n\n    if ((cbf0_chunk != -1) && (cbfz_chunk != -1)) {\n\n\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CBF0 and CBFZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* decompress the full codebook chunk */\n\n    if (cbfz_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbfz_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        if ((res = decode_format80(&s->gb, chunk_size, s->codebook,\n\n                                   s->codebook_size, 0)) < 0)\n\n            return res;\n\n    }\n\n\n\n    /* copy a full codebook */\n\n    if (cbf0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbf0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n        /* sanity check the full codebook size */\n\n        if (chunk_size > MAX_CODEBOOK_SIZE) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: CBF0 chunk too large (0x%X bytes)\\n\",\n\n                chunk_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        bytestream2_get_buffer(&s->gb, s->codebook, chunk_size);\n\n    }\n\n\n\n    /* decode the frame */\n\n    if (vptz_chunk == -1) {\n\n\n\n        /* something is wrong if there is no VPTZ chunk */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: no VPTZ chunk found\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_seek(&s->gb, vptz_chunk, SEEK_SET);\n\n    chunk_size = bytestream2_get_be32(&s->gb);\n\n    if ((res = decode_format80(&s->gb, chunk_size,\n\n                               s->decode_buffer, s->decode_buffer_size, 1)) < 0)\n\n        return res;\n\n\n\n    /* render the final PAL8 frame */\n\n    if (s->vector_height == 4)\n\n        index_shift = 4;\n\n    else\n\n        index_shift = 3;\n\n    for (y = 0; y < s->frame.linesize[0] * s->height;\n\n        y += s->frame.linesize[0] * s->vector_height) {\n\n\n\n        for (x = y; x < y + s->width; x += 4, lobytes++, hibytes++) {\n\n            pixel_ptr = x;\n\n\n\n            /* get the vector index, the method for which varies according to\n\n             * VQA file version */\n\n            switch (s->vqa_version) {\n\n\n\n            case 1:\n\n                lobyte = s->decode_buffer[lobytes * 2];\n\n                hibyte = s->decode_buffer[(lobytes * 2) + 1];\n\n                vector_index = ((hibyte << 8) | lobyte) >> 3;\n\n                vector_index <<= index_shift;\n\n                lines = s->vector_height;\n\n                /* uniform color fill - a quick hack */\n\n                if (hibyte == 0xFF) {\n\n                    while (lines--) {\n\n                        s->frame.data[0][pixel_ptr + 0] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 1] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 2] = 255 - lobyte;\n\n                        s->frame.data[0][pixel_ptr + 3] = 255 - lobyte;\n\n                        pixel_ptr += s->frame.linesize[0];\n\n                    }\n\n                    lines=0;\n\n                }\n\n                break;\n\n\n\n            case 2:\n\n                lobyte = s->decode_buffer[lobytes];\n\n                hibyte = s->decode_buffer[hibytes];\n\n                vector_index = (hibyte << 8) | lobyte;\n\n                vector_index <<= index_shift;\n\n                lines = s->vector_height;\n\n                break;\n\n\n\n            case 3:\n\n/* not implemented yet */\n\n                lines = 0;\n\n                break;\n\n            }\n\n\n\n            while (lines--) {\n\n                s->frame.data[0][pixel_ptr + 0] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 1] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 2] = s->codebook[vector_index++];\n\n                s->frame.data[0][pixel_ptr + 3] = s->codebook[vector_index++];\n\n                pixel_ptr += s->frame.linesize[0];\n\n            }\n\n        }\n\n    }\n\n\n\n    /* handle partial codebook */\n\n    if ((cbp0_chunk != -1) && (cbpz_chunk != -1)) {\n\n        /* a chunk should not have both chunk types */\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: problem: found both CBP0 and CBPZ chunks\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (cbp0_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbp0_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n\n\n            /* time to replace codebook */\n\n            memcpy(s->codebook, s->next_codebook_buffer,\n\n                s->next_codebook_buffer_index);\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    if (cbpz_chunk != -1) {\n\n\n\n        bytestream2_seek(&s->gb, cbpz_chunk, SEEK_SET);\n\n        chunk_size = bytestream2_get_be32(&s->gb);\n\n\n\n        /* accumulate partial codebook */\n\n        bytestream2_get_buffer(&s->gb, &s->next_codebook_buffer[s->next_codebook_buffer_index],\n\n                               chunk_size);\n\n        s->next_codebook_buffer_index += chunk_size;\n\n\n\n        s->partial_countdown--;\n\n        if (s->partial_countdown == 0) {\n\n            GetByteContext gb;\n\n\n\n            bytestream2_init(&gb, s->next_codebook_buffer, s->next_codebook_buffer_index);\n\n            /* decompress codebook */\n\n            if ((res = decode_format80(&gb, s->next_codebook_buffer_index,\n\n                                       s->codebook, s->codebook_size, 0)) < 0)\n\n                return res;\n\n\n\n            /* reset accounting */\n\n            s->next_codebook_buffer_index = 0;\n\n            s->partial_countdown = s->partial_count;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21070, "substitutes": {"s": ["sv", "sb", "e", "sym", "qs", "es", "serv", "bis", "sie", "sci", "fs", "ses", "your", "sets", "site", "ks", "ds", "services", "f", "sys", "t", "u", "its", "ssl", "p", "cs", "ts", "ls", "o", "sync", "is", "ss", "sa", "sg", "c", "settings", "js", "spec", "self", "stats", "si", "a", "service", "se", "parts", "session", "S", "ns", "sup", "sf", "rs", "gs", "v", "conf", "server", "su", "sq"], "chunk_type": ["chunktypetype", "chacket_type", "chump_types", "chunkinglength", "chunkingsize", "chunker_type", "chunker_info", "chunktypesize", "chunkerinfo", "chunkingTYPE", "chunk_style", "chump_level", "chunk_offset", "chunk_TYPE", "chunkersize", "chunk_info", "chump_type", "chunker_types", "chump_size", "chunk_num", "chunkingtype", "chunker_size", "chacket_length", "chacket_TYPE", "chunk_length", "chunktypeoffset", "chacket_size", "chunk_id", "chunk_level", "chunk_types", "chunkertypes", "chunkertype"], "chunk_size": ["chunker_size", "chunk64length", "chacket_handle", "chunks_size", "chunk_address", "chunks_Size", "chacket_type", "chunk_len", "chunk_sized", "chunk_handle", "chunk_Size", "chunk_name", "chunkingsized", "chunk_length", "chunkinglength", "chunkingsize", "chunk64Size", "chunk64len", "chunker_sized", "chacket_size", "chacket_name", "chunks_address", "chunks_len", "chunk64sized", "chunker_length", "chunk64name", "chunk64address", "chunkingname", "chunker_name", "chunk64size"], "byte_skip": [" byte_size", "Byte_size", "byte_offset", "byte___seek", "Byte_start", "byte_start", "bytexstart", "bytexsize", "Byte_offset", "byte___skip", " byte_seek", "byte___size", "byte_seek", "Byte_skip", " byte_offset", "byte_size", "bytexskip", "bytexoffset", "byte___offset"], "i": ["io", "ui", "bin", "I", "f", "ci", "phi", "info", "m", "j", "p", "bi", "is", "c", "index", "si", "ii", "n", "slice", "di", "z", "li", "h", "pi"], "r": ["row", "e", "end", "err", "d", "lr", "f", "m", "p", "rw", "rc", "c", "rl", "w", "re", "n", "er", "R", "rs", "range", "v", "pair", "rb", "h", "l", "rg"], "g": ["e", "G", "gn", "gl", "d", "f", "pg", "ga", "m", "u", "bg", "p", "gg", "q", "gz", "c", "gp", "w", "n", "gs", "h", "l", "k", "rg"], "b": ["bc", "sb", "e", "lb", "fb", "bb", "bin", "bp", "f", "buffer", "eb", "p", "bi", "wb", "buf", "c", "cb", "nb", "v", "bs", "rb", "B", "l"], "index_shift": [" index_offset", "index_offset", "index_skip", "index_map", " index_map", " index_skip"], "res": ["col", "row", "runs", "es", "obj", "err", "rows", "rem", "rx", "rep", "results", "pos", "planes", "Res", "vals", " rows", "bits", "blocks", "seq", "rev", "error", "details", "req", "ps", "reset", "resolution", "files", "base"], "x": ["e", "en", "xs", "_", "d", "xx", "f", "pixel", "ex", "m", "p", "ip", "xc", "o", "c", "px", "index", "X", "w", "n", "ax", "z", "h", "l"], "y": ["ya", "e", "vy", "yy", "d", "yt", "f", "t", "ey", "m", "p", "o", "dy", "ye", "c", "Y", "w", "cy", "ym", "n", "z", "h", "l", "type"], "pixel_ptr": ["pixelalskip", "pixel_skip", "pixelaloffset", "vectoraloffset", "vector_skip", "vector_offset", "pixel_offset", "pixelalpos", "pixelalptr", "vectoralskip", "vectoralptr", "vector_pos", "vectoralpos", "vector_ptr", "pixel_pos"], "lobytes": ["lobyges", "locyte", "Locyte", "Lobyges", "Locytes", "Lobytes", "locyges", "loyte", "LocyTE", "Lobyte", "loytes", "lodyte", "LobyTE", "loyTE", "lodyges", "loyges", "locyTE", "lodyTE", "Locyges", "lobyTE", "locytes", "lodytes", "lobyte"], "hibytes": ["hibeyts", "hibYts", "obytes", "hibYmits", "hibeytes", "hibittes", "hibitmits", "hibYte", "obymits", "hibeyte", "hibitts", "obeyte", "hibymits", "hibyts", "hibYtes", "obeytes", "obeyts", "obyte", "obyts", "hibeymits", "hibyte", "obeymits", "hibitte"], "lines": ["rows", "bytes", "flags", "pos", "m", "planes", "codes", "cells", "vals", "lin", "ls", "code", "breaks", "frames", "bits", "ii", "line", "blocks", "total", "points", "len", "links", "files", "ips", "bands", "pages", "count"], "gb": ["sb", "binary", "gpu", "gt", "usb", "gram", "gal", "ui", "gold", "db", "xy", "gl", "vg", "gin", "pc", "home", "gd", "ga", "bg", "gru", "storage", "uv", "gy", "gg", "gz", "rc", "cb", "cfg", "hub", "gc", "src", "bm", "jpg", "game", "gom", "lib", "gam", "GB", "rb", "gm", "cgi", "ge", "yg", "rg", "gly"]}}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "void helper_iret_protected(int shift)\n\n{\n\n    helper_ret_protected(shift, 1, 0);\n\n}\n", "idx": 18020, "substitutes": {"shift": [" shifted", "set", "offset", "init", "small", "data", "push", "ix", "hift", "buffer", "center", "pack", "pixel", "i", " offset", "src", "slice", "index", "pointer", "ip", "size", "seed", "reset", "length", "config", "start", " shifts", "pull", "slave", "off", "pad", "address", "next", "carry", "transform", "Shift", "input"]}}
{"project": "qemu", "commit_id": "2aece63c8a9d2c3a8ff41d2febc4cdeff2633331", "target": 0, "func": "host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)\n\n{\n\n    MemoryRegion *mr;\n\n\n\n    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);\n\n    if (memory_region_is_mapped(mr)) {\n\n        return false;\n\n    } else {\n\n        return true;\n\n    }\n\n}\n", "idx": 2063, "substitutes": {"mr": ["ur", "dr", "mn", "rg", "cm", "mir", "mt", "gr", "wk", "mc", "mx", "bm", "wr", "ml", "km", "rr", "MR", "r", "yr", "mer", "mm", "lr", "kr", "adr", "m", "hr", "gro", "nr", "mor", "er", "fr", "ir", "mk", "md", "LR", "usr", "gor", "pr", "igr", "br", "wm", "rm", "pm", "sr", "pc", "RR", "shr", "rt", "vr", "rh", "Mr", "rer"]}}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_write_packet(AVFormatContext *ctx, int stream_index,\n\n                                 const uint8_t *buf, int size, int64_t pts)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    AVStream *st = ctx->streams[stream_index];\n\n    StreamInfo *stream = st->priv_data;\n\n    int64_t dts;\n\n    int len;\n\n\n\n    /* XXX: system clock should be computed precisely, especially for\n\n       CBR case. The current mode gives at least something coherent */\n\n    if (stream_index == s->scr_stream_index)\n\n        s->last_scr = pts;\n\n    \n\n#if 0\n\n    printf(\"%d: pts=%0.3f scr=%0.3f\\n\", \n\n           stream_index, pts / 90000.0, s->last_scr / 90000.0);\n\n#endif\n\n    \n\n    /* XXX: currently no way to pass dts, will change soon */\n\n    dts = AV_NOPTS_VALUE;\n\n\n\n    /* we assume here that pts != AV_NOPTS_VALUE */\n\n    if (stream->start_pts == AV_NOPTS_VALUE) {\n\n        stream->start_pts = pts;\n\n        stream->start_dts = dts;\n\n    }\n\n    while (size > 0) {\n\n        len = s->packet_data_max_size - stream->buffer_ptr;\n\n        if (len > size)\n\n            len = size;\n\n        memcpy(stream->buffer + stream->buffer_ptr, buf, len);\n\n        stream->buffer_ptr += len;\n\n        buf += len;\n\n        size -= len;\n\n        while (stream->buffer_ptr >= s->packet_data_max_size) {\n\n            /* output the packet */\n\n            flush_packet(ctx, stream_index,\n\n                         stream->start_pts, stream->start_dts, s->last_scr);\n\n            /* Make sure only the FIRST pes packet for this frame has\n\n               a timestamp */\n\n            stream->start_pts = AV_NOPTS_VALUE;\n\n            stream->start_dts = AV_NOPTS_VALUE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 19976, "substitutes": {"ctx": ["pc", "cc", "fp", "cca", "jp", "cus", "ct", "rc", "gc", "cm", "cf", "cpp", "cb", "anc", "bc", "loc", "cp", "src", "cas", "Context", "ca", "cs", "exec", "context", "hw", "cms", "conv", "kb", "pkg", "nc", "tx", "ci", "tc", "xc", "config", "sc", "cu", "cam", "client", "cli", "lc", "c", "cmd", "p", "ck", "sci", "cmp", "cn", "cv", "conn"], "stream_index": ["streamdbroute", "stream_level", "stream_name", "stream_block", "stream_slice", "streamamelist", " stream_name", "streamdbindex", "channel_Index", "stream_route", "stream_Index", " stream_Index", "channel_slice", "channel_level", " stream_range", "streamamerange", " stream_block", " stream_list", "thread_Index", "thread_index", " stream_route", "streamdbreference", "stream_ref", "thread_position", "thread_ref", "stream_reference", "stream_position", "streamameIndex", "stream_list", " stream_reference", "stream_range", "channel_index", "streamameindex"], "buf": ["ff", "data", "pool", "buffer", "rc", "vec", "feed", "cf", "cb", "block", "bc", "src", "loc", "msg", "raw", "wb", "pb", "mem", "count", "cas", "prop", "context", "val", "box", "queue", "blocks", "fd", "buff", "fb", "cur", "rb", "seq", "cmd", "uc", "b", "cap", "la", "alloc", "bytes", "port", "bag", "uf", "cv"], "size": ["izes", "term", "scale", "offset", "content", "capacity", "shape", "small", "time", "SIZE", "name", "data", "code", "mode", "rc", "n", "cm", "sized", "g", "z", "max", "loc", "function", "sec", "pos", "timeout", "min", "en", "count", "speed", "cs", "page", "empty", "fl", "new", "large", "ize", "length", "limit", "send", "sync", "lc", "c", "needed", "line", "address", " sizes", "sum", "cap", "cache", "body", "es", "bytes", "Size", "el", "grow"], "pts": ["ointments", "ointsize", "putd", "ctts", "ptd", "ctsets", "iptd", "ntd", "iptls", "PTd", "ipts", "iptts", "colts", "ctls", "ppd", "ctd", "cts", "ppls", "ptls", "ptsets", "ptsize", "putments", "ctments", "iptsets", "ointd", "PTs", "cold", "pps", "nts", "ptts", "PTsize", "cols", "ppsize", "ntsets", "iptsize", "ctsize", "PTsets", "ptments", "ntsize", "colsets", "putsize", "oints"], "s": ["ns", "ans", "spec", "session", "sg", "ts", "data", "aws", "rs", "f", "sv", "services", "service", "sb", "g", "sl", "sw", "ss", "ls", "src", "this", "fs", "xs", "sd", "self", "is", "cs", "l", "d", "su", "space", "qs", "serv", "ssl", "ses", "client", "sync", "c", "ps", "si", "sam", "sym", "p", "support", "S", "sts", "sci", "ks", "gs", "sys", "h", "es", "sign", "hs", "se", "sq", "sa", "ds", "sf"], "st": ["ts", "steam", "t", "sv", "sp", "ste", "r", "service", "str", "sb", "sw", "sl", "ss", "src", "ST", "sd", "sta", "sk", "d", "std", "stop", "sn", "start", "sc", "sth", "cl", "cr", "stage", "p", "sts", "St", "inst", "sa", "sf"], "stream": ["child", "user", "full", "thread", "file", "result", "cf", "upload", "raw", "control", "enc", "rec", "path", "stack", "config", "length", "resource", "output", "loop", "source", "reader", "input", "content", "document", "clean", "Stream", "load", "hw", "sc", "stage", "uc", "can", "row", "iv", "port", "wave", "time", "view", "window", "coll", "forward", "model", "prom", "head", "sm", "host", "ack", "sync", "post", "wrapper", "own", "progress", "draft", "steam", "record", "request", "data", "pool", "buffer", "feed", "channel", "ream", "sw", "sl", "public", "slice", "context", "header", "draw", "event", "standard", "ssl", "cl", "client", "cur", "trans", "form", "server"], "dts": ["ddcs", "sdts", "dytl", "dds", "dycs", "dttt", " dcs", "dtTS", "dtes", " dds", "dtts", " dtt", "ddtes", "dytes", "dtl", " dTS", " dtl", "dyts", "sdTS", "dtds", "sdtt", "dtt", "Dts", "ddts", "Dds", " dtes", "DTS", "ddtl", "sdds", "dTS", "dcs"], "len": ["lon", "bin", "data", "lim", "err", "f", "ix", "lit", "vec", "n", "fun", "str", "late", "coll", "sl", "z", "ls", "loc", "led", "fin", "dl", "pos", "min", "en", "zi", "count", "lt", " el", "lf", "low", "ln", "l", "val", "fl", "le", "pre", "dy", "length", " length", "il", "limit", "ler", "hl", "rev", "span", "lc", "ni", "elt", " lang", "line", "lan", "la", "body", "lin", "el", "li", "Len"]}}
{"project": "FFmpeg", "commit_id": "35dcc8a0405788de392ed116dd628aef2772003d", "target": 1, "func": "static int lag_decode_prob(GetBitContext *gb, uint32_t *value)\n\n{\n\n    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };\n\n    int i;\n\n    int bit     = 0;\n\n    int bits    = 0;\n\n    int prevbit = 0;\n\n    unsigned val;\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (prevbit && bit)\n\n            break;\n\n        prevbit = bit;\n\n        bit = get_bits1(gb);\n\n        if (bit && !prevbit)\n\n            bits += series[i];\n\n    }\n\n    bits--;\n\n    if (bits < 0 || bits > 31) {\n\n        *value = 0;\n\n        return -1;\n\n    } else if (bits == 0) {\n\n        *value = 0;\n\n        return 0;\n\n    }\n\n\n\n    val  = get_bits_long(gb, bits);\n\n    val |= 1 << bits;\n\n\n\n    *value = val - 1;\n\n\n\n    return 0;\n\n}\n", "idx": 10868, "substitutes": {"gb": ["GB", "ui", "gd", "boot", "bb", "nb", "g", "gio", "abb", "gpu", "bm", "game", "b", "gm", "gs", "gin", "cb", "gp", "gui", "rb", "bc", "gnu", "gy", "db", "bf", "eb", "slice", "py", "ig", "gi", "gg", "ctx", "abi", "ga", "vd", "usb", "storage", "sb", "pc", "hub", "gc", "cfg", "xy", "vg", "rg", "ge", "bin", "gam", "kb"], "value": ["parent", "member", "reference", "Value", "valid", "sv", "scale", "comment", "key", "view", "model", "ve", "iv", "store", "service", "data", "time", "server", "component", "memory", "number", "code", "unit", "db", "values", "child", "version", "size", "index", "v", "format", "description", "name", "response", "query", "process", "feature", "end", "object", "function", "variable", "get", "type", "volume", "message", "video", "image", "result", "write", "weight", "buffer", "VALUE", "range"], "series": ["vals", "eries", "channel", "stores", "scale", "frames", "si", "IES", "axis", "source", "ds", "store", "service", "data", "config", "parts", "sector", " Series", "frame", "serial", "pins", "sequence", "array", "slice", "ints", "Series", "groups", "details", "bytes", "seconds", "options", "params", "seed", "proc", "events", "chain"], "i": ["oi", "l", "ui", "di", "it", "is", "n", "si", "in", "id", "xi", "info", "b", "x", "ini", "k", "z", "p", "ix", "uri", "e", "f", "ie", "j", "ai", "o", "multi", "index", "v", "jit", "ind", "ti", "gi", "qi", "pi", "bi", "part", "ii", "bit", "col", "u", "I", "li", "pos", "ip", "ci", "ori", "io", "bin", "ni", "ri", "fi"], "val": ["count", "l", "vals", "Val", " v", "seq", "base", "valid", "pass", "dim", "cond", "len", " eval", "sel", "bal", "b", "x", "update", "block", "VAL", "data", "sum", "p", "el", "ref", "rel", "pt", " slot", "f", "la", "bc", "unit", "vol", "bl", "eval", "al", "v", "sl", "abi", " bit", "pre", "part", " ret", "bit", "col", "pos", "ret", "bin", "vec", "fe"], "bits": ["count", "vals", "boot", "words", "base", "its", "frames", "rows", "ids", "features", "dates", "cuts", "alls", "changes", "b", "files", "ops", "places", "works", "ports", "s", "reads", " bugs", "jobs", "pieces", "parts", "cats", "ins", "steps", "runs", "bands", "planes", "bug", "versions", "pins", "lines", "cs", "limits", "items", "ints", "flags", "bugs", "ubs", "fps", "bis", "cycles", "ats", "hours", "details", "blocks", "part", "codes", "bytes", "ns", "bit", "gets", "rots", "pos", "points", "ips", "ps", "bin", "forces", "bs", "units", "settings", "lins"]}}
{"project": "qemu", "commit_id": "da57febfed7bad11be79f047b59719c38abd0712", "target": 0, "func": "DeviceState *qdev_try_create(BusState *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n    if (object_class_by_name(name) == NULL) {\n\n        return NULL;\n\n    }\n\n    dev = DEVICE(object_new(name));\n\n    if (!dev) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!bus) {\n\n        bus = sysbus_get_default();\n\n    }\n\n\n\n    qdev_set_parent_bus(dev, bus);\n\n    qdev_prop_set_globals(dev);\n\n\n\n    return dev;\n\n}\n", "idx": 7579, "substitutes": {"bus": ["vol", "base", "plugin", "ch", "block", "hub", "local", "http", "id", "parent", "BUS", "device", "config", "plug", "bug", "io", "home", "use", "lab", "cat", "sync", "Bus", "loc", "db", "f", "book", "usb", "state", "loop", "us", "kind", "mount", "se", "driver", "lib", "bc", "pass", "self", "lock", "bridge", "controller", "serial", "root", "boot", "pos", "os", "class", "cache", "host", "ass"], "name": ["base", "address", "id", "parent", "unknown", "device", "word", "object", "data", "alias", "named", "info", "names", "key", "package", "null", "version", "Name", "part", "code", "NAME", "size", "connection", "ame", "n", "path", "self", "str", "nam", "none", "new", "type", "class", "prefix"], "dev": ["ch", "od", "local", "rad", "di", "Dev", "dd", "device", "adv", "bug", "val", "data", "enc", "ad", "dem", "der", "debug", "valid", "gu", "private", "de", "d", "ve", "mod", "obj", "dist", "conf", "ev", "def", "DEV", "wd", "priv", " Dev", "kind", "error", "inst", "die", "driver", "sd", "dc", "comment", "instance", "err", "self", "result", "p", "pub", "serial", "h", "prop", "development", "ver", "var", "gd", "cache", "fi", "app", "test", "prov", "grad", "conn", "diff", "cd"]}}
{"project": "FFmpeg", "commit_id": "13a099799e89a76eb921ca452e1b04a7a28a9855", "target": 0, "func": "static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,\n\n                             const int16_t **lumSrc, int lumFilterSize,\n\n                             const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                             const int16_t **chrVSrc,\n\n                             int chrFilterSize, const int16_t **alpSrc,\n\n                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                             uint8_t *aDest, int dstW, int chrDstW)\n\n{\n\n    if (uDest) {\n\n        x86_reg uv_off = c->uv_off;\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n", "idx": 20856, "substitutes": {"c": ["lc", "e", "cc", "ct", "config", "g", "cm", "d", "con", "pc", "cur", "cl", "f", "ci", "t", "ac", "u", "m", "s", "r", "cache", "oc", "p", "mc", "xc", "ctrl", "tc", "context", "ctx", "icc", "a", "b", "dc", "w", "cpp", "C", "v", "cit", "h", "l", "ec", "vc"], "lumFilter": ["LumbRef", "LumbFile", "lumRef", "lumbFilter", "lumFile", "LumFile", "LumRef", "lUMFilter", "LumFilter", "lumbRef", "lucRef", "lUMRef", "lucFile", "lucFilter", "LumbFilter", "lUMFile", "lumbFile"], "lumSrc": ["lumaAsrc", "lumaSsrc", "lumCsrc", "lumCuc", "lumaSuc", "lumSRC", "lumaAssrc", "lumVSuc", "lumAsuc", "lumAsrc", "lumaAsuc", "lumSuc", "lumVSRC", "lumCrc", "lumAsRC", "lumaSrc", "lumaSRC", "lumCRC", "lumVSsrc", "lumSsrc", "lumVSrc", "lumaAsRC", "lumAssrc"], "lumFilterSize": ["lumContextC", "lumFileStyle", "lulFilterSIZE", "lulFlSize", "lumFlStyle", "lumFilterC", "lumContextSIZE", "lulFlC", "lumContextSize", "lumFlC", "lumFilterStyle", "lumFlSize", "lumFileC", "lumFileSize", "lulFlStyle", "lulFlSIZE", "lumFlSIZE", "lumFileSIZE", "lulFilterC", "lumContextStyle", "lumFilterSIZE", "lulFilterStyle", "lulFilterSize"], "chrFilter": ["chrgLimit", "echreLimit", "chreHeader", "chrgHeader", "echrLimit", "chreLimit", "echreFilter", "chrgFilter", "chrLimit", "chcHeader", "chcFilter", "echreHeader", "chrHeader", "chcLimit", "echrHeader", "chreFilter", "echrFilter"], "chrUSrc": ["chrSSsrc", "chrSSrc", "chrSrc", "chrKSsrc", "chrSSRC", "chrUSRC", "chrsUSrc", "chrsUSci", "chrKSRC", "chrKSrc", "chrKSci", "chrsSci", "chrSsrc", "chrSci", "chrSRC", "chrsUSRC", "chrsSRC", "chrSSci", "chrsUSsrc", "chrUSci", "chrUSsrc", "chrsSrc", "chrsSsrc"], "chrVSrc": ["chrCSsrc", "chrgVSrc", "chrSSsrc", "chrgVSuc", "chrCSuc", "chrSSrc", "chrgVSsrc", "chrCSrc", "chrVSource", "chrgVSource", "chrSSource", "chrgSSrc", "chrSSuc", "chrNsource", "chrNsrc", "chrNsuc", "chrgSSsrc", "chrVSsrc", "chrgSSuc", "chrNssrc", "chrgSSource", "chrCSource", "chrVSuc"], "chrFilterSize": ["chrbBlockLen", "chrFilterLen", "chrBlockLen", "chrBlockSIZE", "chrFilterSIZE", "chrfilterLen", "chrFlSIZE", "chrfilterSIZE", "chrFlLen", "chrbFilterSIZE", "chrbFilterLen", "chrbBlockSize", "chrbBlockSIZE", "chrFlSize", "chrBlockSize", "chrfilterSize", "chrbFilterSize"], "alpSrc": ["alpSSdr", "alpSSrc", "alpOSRC", "alpAssrc", "alpOSrc", "alcSdr", "alpOSsrc", "alcAsdr", "alpSdr", "alcSsrc", "alpAsRC", "alpAsdr", "alpSSRC", "alcAsRC", "alcSrc", "alpSSsrc", "alpSRC", "alcAsrc", "alpAsrc", "alcSRC", "alcAssrc", "alpSsrc", "alpOSdr"], "dest": ["md", "route", "transform", "name", "target", "uc", "config", "asc", "mode", "de", "d", "home", "img", "path", "dist", "dep", "cont", "done", "dev", "data", "da", "wb", "shift", " Dest", "destroy", "cb", "Dest", "source", "match", "sc", "du", "dc", "tmp", "desc", "src", "loc", "dat", "orig", "feat", "prop"], "uDest": ["uDep", "UDep", "uDir", "vDir", "udest", "UDest", " uDir", "adest", "Udest", "UDir", "iSource", "uHome", "aSource", "vOrig", "aExt", "pDesc", "vHome", "uSource", "UHome", "iDesc", "vExt", "vdest", "uOrig", "UExt", "USource", "pSource", "pOrig", " uHome", "uExt", "vDesc", "pDest", "iDest", " uDep", "vDep", "vSource", "iOrig", "uDesc"], "vDest": [" vOrd", "uDep", "vDist", "fOrd", "hDist", "hDesc", "hDep", " vDist", "pDep", "vOrig", "pDesc", "uOrig", " vOrig", "pDist", "hDest", "vOrd", "fDist", "uDist", "vDesc", "uOrd", "pDest", "fDest", "vDep", "uDesc", "fOrig"], "aDest": ["AOrig", "apiOrig", " adest", "vaOrig", "aDist", "ASc", "sadest", "aOrig", "bdest", "adest", "apiSc", " aOrig", " aEnt", "aaOrig", " aDesc", " aSc", "bDist", "aaDest", "apiDest", "saDest", "ADest", "aaDesc", "apiEnt", "vaDesc", " aDist", "bDest", "aEnt", "vaDest", "aSc", "AEnt", "saDist", "aDesc"], "dstW": ["dstFW", "dptWS", "DndW", "DscH", "DstFW", "dostW", "dstM", "dndM", "dstB", "drcM", "DscW", "dscM", "DstW", "dstWS", "dostH", "drestWS", "DndM", "dostM", "drestM", "dptM", "dndH", "drcW", "DptW", "drestW", "DndH", "DscFW", "dscH", "dscFW", "DstM", "drestH", "DptWS", "DstH", "drcH", "dstH", "dostB", "dndW", "dptH", "DptM", "DptH", "DndB", "dscW", "DscM", "DstB", "dptW", "drcB", "dndB", "drcFW", "drestFW", "DstWS", "drcWS"], "chrDstW": ["chrLstM", "chrDscH", "chrdSTL", "chrSrcN", "chrdSTW", "chrdstGW", "chrDblW", "chrDntD", "chrdstH", "chrDrcW", "chrDblw", "chrLstw", "chrDscN", "chrDstL", "chrDrdH", "chrLstGW", "chrDrcN", "chrSstD", "chrDstw", "chrDrcM", "chrDrdW", "chrDscW", "chrSstW", "chrDstM", "chrDstGW", "chrDestw", "chrDrcD", "chrSrcD", "chrdstL", "chrDrdGW", "chrDblM", "chrDrcGW", "chrdSTGW", "chrDSTH", "chrDestM", "chrDSTL", "chrDestW", "chrDrdL", "chrDscD", "chrSstN", "chrdstW", "chrSstM", "chrDblGW", "chrDSTW", "chrdSTH", "chrDntW", "chrDestGW", "chrDSTGW", "chrDscL", "chrLestw", "chrDstH", "chrDscGW", "chrSrcM", "chrSrcW", "chrDscM", "chrDstN", "chrDntM", "chrLstW", "chrLestGW", "chrDstD", "chrDntN", "chrLestM", "chrLestW", "chrDrcw"]}}
{"project": "qemu", "commit_id": "35c2c8dc8c0899882a8e0d349d93bd657772f1e7", "target": 0, "func": "int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,\n\n                   const char *version, const char *serial, const char *model,\n\n                   uint64_t wwn,\n\n                   uint32_t cylinders, uint32_t heads, uint32_t secs,\n\n                   int chs_trans)\n\n{\n\n    uint64_t nb_sectors;\n\n\n\n    s->blk = blk;\n\n    s->drive_kind = kind;\n\n\n\n    blk_get_geometry(blk, &nb_sectors);\n\n    s->cylinders = cylinders;\n\n    s->heads = heads;\n\n    s->sectors = secs;\n\n    s->chs_trans = chs_trans;\n\n    s->nb_sectors = nb_sectors;\n\n    s->wwn = wwn;\n\n    /* The SMART values should be preserved across power cycles\n\n       but they aren't.  */\n\n    s->smart_enabled = 1;\n\n    s->smart_autosave = 1;\n\n    s->smart_errors = 0;\n\n    s->smart_selftest_count = 0;\n\n    if (kind == IDE_CD) {\n\n        blk_set_dev_ops(blk, &ide_cd_block_ops, s);\n\n        blk_set_guest_block_size(blk, 2048);\n\n    } else {\n\n        if (!blk_is_inserted(s->blk)) {\n\n            error_report(\"Device needs media, but drive is empty\");\n\n            return -1;\n\n        }\n\n        if (blk_is_read_only(blk)) {\n\n            error_report(\"Can't use a read-only drive\");\n\n            return -1;\n\n        }\n\n        blk_set_dev_ops(blk, &ide_hd_block_ops, s);\n\n    }\n\n    if (serial) {\n\n        pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial);\n\n    } else {\n\n        snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n\n                 \"QM%05d\", s->drive_serial);\n\n    }\n\n    if (model) {\n\n        pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model);\n\n    } else {\n\n        switch (kind) {\n\n        case IDE_CD:\n\n            strcpy(s->drive_model_str, \"QEMU DVD-ROM\");\n\n            break;\n\n        case IDE_CFATA:\n\n            strcpy(s->drive_model_str, \"QEMU MICRODRIVE\");\n\n            break;\n\n        default:\n\n            strcpy(s->drive_model_str, \"QEMU HARDDISK\");\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (version) {\n\n        pstrcpy(s->version, sizeof(s->version), version);\n\n    } else {\n\n        pstrcpy(s->version, sizeof(s->version), qemu_get_version());\n\n    }\n\n\n\n    ide_reset(s);\n\n    blk_iostatus_enable(blk);\n\n    return 0;\n\n}\n", "idx": 1060, "substitutes": {"s": ["sg", "js", "sa", "qs", "n", "sites", "sl", "g", "ses", "ls", "sf", "us", "self", "f", "set", "sys", "u", "fs", "parts", "spec", "ts", "sb", "uns", "xs", "sv", "request", "sets", "p", "state", "e", "conf", "as", "uses", "v", "less", "su", "site", "S", "os", "session", "t", "ks", "its", "hs", "sym", "ssl", "cs", "ss", "rs", "a", "r", "is", "ins", "i", "m", "settings", "ds", "ps", "gs", "ns", "c", "es", "south", "o", "si", "server", "service", "d", "sis", "comments", "details", "sync", "tests", "l", "services", "w", "stats", "b", "full", "states"], "blk": ["blck", "plmk", "slK", "plsk", "clks", "mlc", "blkt", "brks", "ilK", "blch", "slke", "clk", "plc", "slsk", " blok", "clkt", "mlch", "blmk", "plch", "Blks", "clb", "blks", "mlk", "clke", "slc", "clck", "ylk", "ilok", "slkt", "ilk", "ylmk", " blck", "mlks", "blke", " blmk", "clok", "ilks", "blsk", " blsk", "slch", "slks", "Blk", "ylks", "ilke", " blkt", "Blok", "plk", "blb", "plkt", "ilkt", "slok", "blK", "brke", "Blb", "brk", "slck", "brok", "plck", "plok", "blok", "slk", "plK", "plks", "ylke", "plke", " blks", " blke", "blc", " blb"], "kind": ["cost", "hack", "Kind", "name", "cycle", "kick", "shape", "spec", "ant", "device", "ke", "method", "sid", "data", "class", "d", "division", "type", "brand", "id", "head", "th", "k", "concept", "sk", "ko", "seed", "year", "instance", "need", "kt", "info", "mid", "coll", "direction", "style", "pod", "str", "impl", "ie", "step", "ind", "kid", "role", "dev", "plugin", "magic", "depth", "path", "engine", "mode", "good", "part", "dir", "start", "needed"], "version": ["stage", "vision", "server", "Version", "device", "image", "ver", "brand", "format", "id", "seed", "package", "rev", "description", "feature", "secret", "vers", "release", "scale", "iv", "plugin", "path", "product", "engine", "VERSION", "mode", "versions", "arch"], "serial": ["vision", "series", "pocket", "server", "social", "material", "micro", "primary", "local", "generic", "spec", "device", "zip", "major", "binary", "loc", "global", "flash", "initial", "package", "component", "phone", "bug", "standard", "pattern", "json", "ident", "description", "international", "dev", "random", "custom", "private", "length", "iso", "patch", "core", "machine", "power", "public", "driver", "error", "valid", "human", "specified", "mode", "io", "root", "normal", "mobile"], "model": ["vision", "media", "base", "server", "local", "generic", "models", "time", "device", "command", "method", "zip", "image", "type", "field", "Model", "format", "id", "parent", "package", "label", "language", "params", "company", "file", "sql", "python", "license", "style", "config", "json", "description", "feature", "vel", "control", "block", "automatic", "zero", "size", "length", "message", "machine", "where", "object", "library", "single", "module", "location", "path", "human", "product", "view", "mode", "install", "mobile"], "wwn": [" Warn", "awwn", "ewws", " Wwn", "wbnn", "wpgn", " Wiw", "hwn", " wgn", " wmn", "Warn", "warn", " wnn", "wpnn", "ewiw", "Wgn", "wpwn", "Wwn", "awws", " warn", "awiw", "hww", "ewwn", "wbmn", " wiw", "wbwn", "wws", "www", "wnn", "hiw", "wpmn", "awww", " Wgn", "ewww", "wmn", "wiw", "wgn", "Wiw", "wbgn", "hws"], "cylinders": ["ymiths", "cilcles", "cyinder", "galcles", "cyeds", "galinder", "quiths", "galeds", "silences", "quins", "silins", "cilinders", "ylences", "galinders", "quences", "cyliths", "siliths", "cyinders", "silinder", "cylisters", "silisters", "quinders", "cylinder", "cyleds", "silinders", "ciliths", "ymisters", "ylins", "cycles", "cilinder", "yliths", "cylences", "cilisters", "cylins", "yminders", "ylinders", "cileds", "yminder", "cylcles"], "heads": ["sections", "clips", "opens", "maps", "workers", "boards", "unks", "views", "members", "reads", "tracks", "devices", "ins", "kins", "head", "links", "hops", "cles", "locks", "ids", "checks", "frames", "bits", "holes", "shots", "mods", "sticks", "archs", "drivers", "planes", "lines", "eeks", "length", "height", "pages", "ints", "tails", "rows", "bands", "HEAD", "cycles", "blocks", "headers", "depth", "times", "tops", "olds", "versions", "nuts", "obs"], "secs": ["structds", "reqds", "seqes", "eces", "secp", "secds", "ctp", "secses", "cts", "incs", "reqs", "ctes", "secn", "ecses", "incn", "structn", "ctses", "ecs", "ecp", "reqd", "seqp", "reqn", "structd", "incds", "seces", "seqses", "secd", "incd", "structs", "seqs"], "chs_trans": ["chs_transfer", "chs_orig", "chs__rans", "chs__ctr", "chs2private", "chs2trans", "chs__transfer", "chs_tr", "chls_transfer", "chls_rans", "chns_translation", "chs_private", "chns_trans", "chs_translation", "chs2Trans", "chs2orig", "chls_trans", "chss_orig", "chs__trans", "chs_ctr", "chns_ctr", "chls_ctr", "chns_tr", "chss_private", "chss_Trans", "chss_trans", "chs_rans", "chs_Trans"], "nb_sectors": ["nb_sellers", "nb_ectors", "nb_pecs", "nb_locctors", "nb_nectors", "nb_sections", "nb_psectors", "nb_pections", "nb_ellers", "nb_secs", "nb_egments", "nb_pseors", "nb_psegments", "nb_pellers", "nb_locgment", "nb_pegments", "nb_spellers", "nb_gerets", "nb_pserets", "nb_ceors", "nb_gections", "nb_spelections", "nb_vectors", "nb_syctions", "nb_pectors", "nb_vections", "nb_selections", "nb_vedds", "nb_segment", "nb_sydds", "nb_locgments", "nb_gectors", "nb_sedds", "nb_syctors", "nb_negments", "nb_nerets", "nb_gegments", "nb_segments", "nb_vecs", "nb_serets", "nb_pedds", "nb_locors", "nb_seors", "nb_cegments", "nb_sycs", "nb_spegments", "nb_pelections", "nb_cectors", "nb_nections", "nb_elections", "nb_spectors", "nb_cegment", "nb_psections", "nb_psegment"]}}
{"project": "FFmpeg", "commit_id": "86dfcfd0e30d6645eea2c63c1c60a0550e7c97ea", "target": 1, "func": "static int read_kuki_chunk(AVFormatContext *s, int64_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st      = s->streams[0];\n\n\n\n    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)\n\n        return -1;\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_AAC) {\n\n        /* The magic cookie format for AAC is an mp4 esds atom.\n\n           The lavc AAC decoder requires the data from the codec specific\n\n           description as extradata input. */\n\n        int strt, skip;\n\n        MOVAtom atom;\n\n\n\n        strt = avio_tell(pb);\n\n        ff_mov_read_esds(s, pb, atom);\n\n        skip = size - (avio_tell(pb) - strt);\n\n        if (skip < 0 || !st->codec->extradata ||\n\n            st->codec->codec_id != AV_CODEC_ID_AAC) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid AAC magic cookie\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_skip(pb, skip);\n\n    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {\n\n#define ALAC_PREAMBLE 12\n\n#define ALAC_HEADER   36\n\n#define ALAC_NEW_KUKI 24\n\n        uint8_t preamble[12];\n\n        if (size < ALAC_NEW_KUKI) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n            avio_skip(pb, size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_read(pb, preamble, ALAC_PREAMBLE);\n\n\n\n        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.\n\n         * The new style cookie only contains the last 24 bytes of what was\n\n         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes\n\n         * in that case to maintain compatibility. */\n\n        if (!memcmp(&preamble[4], \"frmaalac\", 8)) {\n\n            if (size < ALAC_PREAMBLE + ALAC_HEADER) {\n\n                av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n                av_freep(&st->codec->extradata);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            avio_read(pb, st->codec->extradata, ALAC_HEADER);\n\n            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);\n\n        } else {\n\n            AV_WB32(st->codec->extradata, 36);\n\n            memcpy(&st->codec->extradata[4], \"alac\", 4);\n\n            AV_WB32(&st->codec->extradata[8], 0);\n\n            memcpy(&st->codec->extradata[12], preamble, 12);\n\n            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);\n\n            avio_skip(pb, size - ALAC_NEW_KUKI);\n\n        }\n\n        st->codec->extradata_size = ALAC_HEADER;\n\n    } else {\n\n        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n        avio_read(pb, st->codec->extradata, size);\n\n        st->codec->extradata_size = size;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24230, "substitutes": {"s": ["S", "space", "sc", "ses", "rs", "sys", "sr", "ss", "p", "b", "i", "c", "bis", "ns", "ts", "sed", "sq", "ds", "us", "ps", "sg", "ks", "sync", "bs", "self", "su", "is", "e", "gs", "south", "sie", "ions", "lines", "session", "sts", "spec", "sv", "l", "si", "less", "sign", "aws", "os", "sb", "services", "sa", "sing", "xs", "ls", "f", "service", "sim", "js", "fs", "t", "an", "v", "sl", "r", "sf", "ops", "ssl", "cs", "g"], "size": ["use", "name", "time", "enc", "buffer", "num", "second", "any", "max", "SIZE", "fee", "number", "six", "n", "core", "content", "complete", "code", "body", "ize", "p", "c", "empty", "sized", "storage", "sum", "en", "address", "speed", "form", "cache", "shape", "now", "timeout", "iz", "large", "len", "g", "args", "sn", "data", "send", "capacity", "Size", "small", "offset", "sec", "length", "count", "page", "i", "shift", "type", "loc", "si", "scale", "handle", "v"], "pb": ["summary", "txt", "uf", "pa", "uc", "p", "b", "parser", "pg", "wb", "pkg", "lb", "ppa", "cv", "bb", "xb", "api", "rb", "ab", "bf", "bh", "jp", "alist", "cb", "gb", "bc", "dp", "py", "prop", "bp", "platform", "bs", "proc", "typ", "plugin", "db", "hub", "PB", "fc", "rob", "fab", "pd", "tmp", "loc", "eb", "pl", "cli", "ctx", "cp", "fb", "sb", "ub", "pm", "lab", "bot", "lc", "wp", "lp", "prot", "tp", "fp", "cpp", "bm", "bps", "vp", "pc", "ib"], "st": ["rest", "std", "sc", "fe", "ST", "ft", "ss", "pt", "rd", "sn", "se", "ts", "sam", "sw", "ld", "ste", "ct", "ast", "ust", "inst", "end", "St", "fr", "typ", "sth", "sp", "td", "sta", "str", "nd", "start", "mt", "sts", "art", "sign", "nt", "lt", "sb", "client", "est", "ist", "sa", "ost", "stage", "stop", "t", "stack", "sd", "dest", "sl", "sf", "post", "put", "ut", "kt"], "strt": ["Strtt", "srs", "drt", "charts", "charT", "frt", "strT", "STRte", "strtt", "trte", "drtt", "chartt", " strT", " strtt", "trt", "srd", "Strts", "Strt", "strs", "drT", "strts", "STRt", "strte", "STRtt", "srt", " strd", "drts", "STRT", " strte", "frts", " strts", "trtt", "strd", "StrT", "chart", " strs", "frd", "trT", "srts", "frs"], "skip": ["use", "call", "gap", "slice", "parse", "jump", "keep", "name", "scroll", "read", "success", "delay", "ignore", "fail", "access", "type", "hide", "speed", "pass", "write", "sync", "op", "allow", "link", "step", "unit", "miss", "min", "zero", "start", "nic", "spec", "offset", "run", "blank", "scale", "item", "hop", "missing", "need", "scan", "sleep", "loop", "ipp", "stop", "eat", "n", "ip", "index", "limit", "Skip", "pos", "wait"], "atom": ["acc", "node", "mom", "cm", "np", "class", "info", "p", "m", "app", "fam", "data", "tm", "base", "orb", "ab", "om", "prop", "component", "oms", "am", "type", "abc", "article", "op", "atomic", "typ", "rss", "mag", " atoms", "tmp", "term", "at", "spec", "abb", "item", "com", "channel", "xml", "tab", "array", "list", "tom", "kat", " Atom", "attr", "plane", "map"], "preamble": [" pREAMble", "pREAMbled", "parsbling", " preambled", "parenble", "pairle", " parenle", "parml", "pairbling", "parmbe", "prambe", "pramble", "prawbe", " pREAMle", "preambling", " parmBLE", " preamBLE", "pairble", " parmbe", "pramBLE", "parmbled", "parmBLE", "prawBLE", "prawle", " preambe", " preamle", "parenBLE", "parsBLE", "parmble", "parsble", "parsle", " parenble", " parenBLE", "prawble", "preambe", "praml", "pREAMle", "prambled", "preaml", "parenle", "pREAMble", "pramle", "parenbling", " pREAMbled", " parmle", " parenbling", "parmle", " parmble", "pairBLE", "preamle", " preaml", " pREAMl", "preambled", "pREAMl", " preambling", "preamBLE"]}}
{"project": "FFmpeg", "commit_id": "fed92adbb3fc6cbf735e3df9a2f7d0a2917fcfbd", "target": 1, "func": "void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,\n\n                    int mb_x, int mb_y, int layout)\n\n{\n\n    VP8Macroblock *mb_edge[3] = { 0      /* top */,\n\n                                  mb - 1 /* left */,\n\n                                  0      /* top-left */ };\n\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n\n    int idx = CNT_ZERO;\n\n    int cur_sign_bias = s->sign_bias[mb->ref_frame];\n\n    int8_t *sign_bias = s->sign_bias;\n\n    VP56mv near_mv[4];\n\n    uint8_t cnt[4] = { 0 };\n\n    VP56RangeCoder *c = &s->c;\n\n\n\n    if (!layout) { // layout is inlined (s->mb_layout is not)\n\n        mb_edge[0] = mb + 2;\n\n        mb_edge[2] = mb + 1;\n\n    } else {\n\n        mb_edge[0] = mb - s->mb_width - 1;\n\n        mb_edge[2] = mb - s->mb_width - 2;\n\n    }\n\n\n\n    AV_ZERO32(&near_mv[0]);\n\n    AV_ZERO32(&near_mv[1]);\n\n    AV_ZERO32(&near_mv[2]);\n\n\n\n    /* Process MB on top, left and top-left */\n\n#define MV_EDGE_CHECK(n)                                                      \\\n\n    {                                                                         \\\n\n        VP8Macroblock *edge = mb_edge[n];                                     \\\n\n        int edge_ref = edge->ref_frame;                                       \\\n\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n\n            if (mv) {                                                         \\\n\n                if (cur_sign_bias != sign_bias[edge_ref]) {                   \\\n\n                    /* SWAR negate of the values in mv. */                    \\\n\n                    mv = ~mv;                                                 \\\n\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n\n                }                                                             \\\n\n                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \\\n\n                    AV_WN32A(&near_mv[++idx], mv);                            \\\n\n                cnt[idx] += 1 + (n != 2);                                     \\\n\n            } else                                                            \\\n\n                cnt[CNT_ZERO] += 1 + (n != 2);                                \\\n\n        }                                                                     \\\n\n    }\n\n\n\n    MV_EDGE_CHECK(0)\n\n    MV_EDGE_CHECK(1)\n\n    MV_EDGE_CHECK(2)\n\n\n\n    mb->partitioning = VP8_SPLITMVMODE_NONE;\n\n    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {\n\n        mb->mode = VP8_MVMODE_MV;\n\n\n\n        /* If we have three distinct MVs, merge first and last if they're the same */\n\n        if (cnt[CNT_SPLITMV] &&\n\n            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))\n\n            cnt[CNT_NEAREST] += 1;\n\n\n\n        /* Swap near and nearest if necessary */\n\n        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n\n            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);\n\n            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);\n\n        }\n\n\n\n        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {\n\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {\n\n                /* Choose the best mv out of 0,0 and the nearest mv */\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n\n\n\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {\n\n                    mb->mode = VP8_MVMODE_SPLIT;\n\n                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];\n\n                } else {\n\n                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);\n\n                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);\n\n                    mb->bmv[0] = mb->mv;\n\n                }\n\n            } else {\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);\n\n                mb->bmv[0] = mb->mv;\n\n            }\n\n        } else {\n\n            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);\n\n            mb->bmv[0] = mb->mv;\n\n        }\n\n    } else {\n\n        mb->mode = VP8_MVMODE_ZERO;\n\n        AV_ZERO32(&mb->mv);\n\n        mb->bmv[0] = mb->mv;\n\n    }\n\n}\n", "idx": 8208, "substitutes": {"s": ["l", "session", "sg", "ds", "n", "si", "g", "is", "shell", "sf", "w", "m", "b", "t", "x", "sci", "d", "i", "gs", "service", "sa", "iss", "p", "server", "e", "se", "sq", "js", "f", "cs", "o", "size", "S", "v", "sync", "space", "south", "sie", "sl", "services", "state", "support", "ns", "sb", "spec", "h", "sim", "single", "side", "client", "ses", "fs", "a", "ss", "y", "settings", "ssl", "sc"], "mb": ["ym", "GB", "mac", "ib", "byte", "base", "bb", "mn", "em", "pg", "nb", "ph", "media", "m", "bp", "b", "mm", "wb", "MB", "big", "vm", "fb", "ref", "meta", "pb", "gb", "MP", "machine", "rb", "loc", "pm", "large", "bc", "nm", "mode", "db", "bf", "mp", "eb", "bound", "mx", "mi", "md", "lb", "mod", "mag", "sb", "ms", "mph", "emb", "cm", "meg", "ob", "url", "image", "mt", " MB", "mop", "um", "cmd", "mc", "om", "kb"], "mb_x": ["MB_index", "MB_width", "mb_index", "MB_y", "mb_width", "MB_x"], "mb_y": ["MB_z", "MB_y", "MB_x", "mb_z"], "layout": ["scroll", "l", "orient", "center", "scale", "Layout", "def", "id", "num", "z", "block", "config", "draw", "qa", "cb", "local", "np", "style", "loc", "sq", "f", "mode", "design", "shape", "nd", "sync", "cl", "dc", "position", "offset", "form", "layer", "nl", "nc", "h", "loop", "cell", "lc", "flat", "adj", "nn", "fc"], "mb_edge": ["mp_ide", "bb_close", "mp_edge", "MB_edge", "mb_ge", "mb_slice", "bb_ide", "bb_edge", "MB_connection", "bb_scale", "bb_gate", "MB_ide", "bb_slice", "mb_close", "mb_ide", "mp_line", "MB_ge", "mb_connection", "bb_connection", "mb_scale", "mb_pad", "mb_line", "bb_pad", "mp_slice", "mb_gate"], "sign_bias": ["sign_abare", "sign_biias", "sign_burius", "sign_cias", "sign_abias", "sign_abature", "sign_bature", "sign_blases", "sign_bary", "sign_abases", "sign_Base", "sign_abinding", "sign_burinding", "sign_bases", "sign_gare", "sign_biases", "sign_binding", "sign_gias", "sign_blinding", "sign_gases", "sign_Bare", "sign_biature", "sign_cases", "sign_cature", "sign_biary", "sign_abase", "sign_Bases", "sign_blias", "sign_blius", "sign_base", "sign_Bias", "sign_bius", "sign_abius", "sign_burases", "sign_gase", "sign_burias", "sign_bare", "sign_abary", "sign_cary"], "near_mv": ["near_vmvg", "near_mf", "near_mmx", "near_mb", "near_mver", "near_mj", "near_cmh", "near_bvg", "near_cmvs", "near_cmvm", "near_rh", "near_mx", "near_mmf", "near_tx", "near_Mf", "near_mq", "near_tv", "near_Mver", "near_Mv", "near_mmvs", "near_pv", "near_mmV", "near_vmV", "near_mmb", "near_mvs", "near_cmx", "near_mV", "near_vmj", "near_vmv", "near_mmv", "near_mmver", "near_cmv", "near_mh", "near_bV", "near_pf", "near_rq", "near_bv", "near_tvm", "near_pver", "near_cmq", "near_bj", "near_Mb", "near_rv", "near_tvs", "near_pb", "near_mmj", "near_mvm", "near_rx", "near_mmvm", "near_mmvg", "near_mvg"], "cnt": ["cnc", "lcnt", "bnc", "acct", "lcct", "bnt", "acrt", "acnt", "lcnc", "cct", "brt", "lcrt", "crt", "bct", "acnc"], "c": ["l", "arc", "channel", "C", "n", "g", "cil", "w", "conn", "m", "b", "t", "d", "con", "p", "e", "cu", "cf", "cn", "bc", "cc", "f", "cs", "cv", "connection", "r", "dc", "xc", "u", "nc", "h", "ca", "cm", "ci", "a", "ch", "lc", "jc", "cell", "mc", "uc", "cy", "sc", "chain"]}}
{"project": "qemu", "commit_id": "e95ead32efc48157de12e0a257ea1c52541a6ce1", "target": 0, "func": "static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)\n\n{\n\n    return s->ops->chmod(&s->ctx, path->data, mode);\n\n}\n", "idx": 16422, "substitutes": {"s": ["ns", "status", "ts", "stats", "rs", "f", "settings", "services", "ows", "ils", "service", "sb", "uploads", "ss", "ls", "ops", "fs", " fs", "is", "o", "cs", "als", "e", "ssl", "side", "ses", "sync", "private", "c", "ps", "js", "si", "sym", "p", "secondary", "S", "gs", "sys", "its", "states", "es", "os", "state", "hs", "opens", "sets", "south", "sq", "less", "ds"], "path": ["ion", "pattern", "m", "txt", "text", "data", "user", "token", "dir", "image", "name", "loader", "root", "anc", "method", "type", "ath", "rh", "node", "th", "pass", "slice", "pointer", "object", "enc", "prop", "PATH", "alias", "step", "key", "id", "sc", "parent", "c", "Path", "p", "test", "desc"], "mode": ["move", "term", "m", "mod", "code", "data", "direction", "name", "dir", "MODE", "md", "Mode", "de", "phrase", "role", "module", "method", "type", "node", "mask", "def", "lane", "perm", "range", "ODE", "d", "alias", "grade", "key", "slave", "sym", "access", "cmd", "none", " modes", "level", "ace", "ode", "ma", "mac", "command"]}}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++)\n\n        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);\n\n    memset(output[2], 0, sizeof(output[2]));\n\n    memset(output[3], 0, sizeof(output[3]));\n\n    memset(output[4], 0, sizeof(output[4]));\n\n}\n", "idx": 9238, "substitutes": {"ctx": ["conf", "cam", "context", "cmp", "Context", "cca", "conn", "tc", "src", "c", "cp", "config", "component", "fp", "cn", "cf", "loc", "bc", "cc", "cs", "ctrl", "cv", "ck", "ce", "rc", "cas", "conv", "tx", "pc", "cpp", "cms", "cm", "ca", "ci", "anc", "lc", "text", "mc", "kb", "sc", "exec"], "i": ["count", "l", "oi", "hi", "ui", "di", "it", "n", "si", "zi", "m", "id", "xi", "info", "b", "x", "k", "t", "ini", "d", "c", "ji", "p", "uri", "e", "mu", "yi", "f", "ie", "j", "ai", "code", "o", "multi", "index", "slice", "v", "gi", "ti", "qi", "pi", "bi", "ii", "u", "type", "h", "I", "li", "ci", "a", "io", "length", "ni", "y", "iu"], "output": ["region", "word", "block", "config", "target", "memory", "code", "external", "response", "content", "object", "document", "full", "put", "sort", "grade", "image", "eff", "reference", "filter", "generated", "application", "control", "draw", "value", "hidden", "unit", "module", "input", "current", "four", "position", "layer", "complete", "operation", "source", "model", "page", "data", "written", "flow", "resource", "version", "size", "software", "after", "oper", "fn", "result", "core", "Output", "byte", "display", "update", "queue", "number", "average", "console", "event", "address", "function", "option", "summary", "null", "out", "video", "write", "forward"]}}
{"project": "FFmpeg", "commit_id": "fe7547d69e6721d064c8604d0a6375a2d24b35ca", "target": 0, "func": "int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,\n\n                              int64_t wanted_timestamp, int flags)\n\n{\n\n    int a, b, m;\n\n    int64_t timestamp;\n\n\n\n    a = -1;\n\n    b = nb_entries;\n\n\n\n    // Optimize appending index entries at the end.\n\n    if (b && entries[b - 1].timestamp < wanted_timestamp)\n\n        a = b - 1;\n\n\n\n    while (b - a > 1) {\n\n        m         = (a + b) >> 1;\n\n\n\n        // Search for the next non-discarded packet.\n\n        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {\n\n            m++;\n\n            if (m == b && entries[m].timestamp >= wanted_timestamp) {\n\n                m = b - 1;\n\n                break;\n\n            }\n\n        }\n\n\n\n        timestamp = entries[m].timestamp;\n\n        if (timestamp >= wanted_timestamp)\n\n            b = m;\n\n        if (timestamp <= wanted_timestamp)\n\n            a = m;\n\n    }\n\n    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;\n\n\n\n    if (!(flags & AVSEEK_FLAG_ANY))\n\n        while (m >= 0 && m < nb_entries &&\n\n               !(entries[m].flags & AVINDEX_KEYFRAME))\n\n            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;\n\n\n\n    if (m == nb_entries)\n\n        return -1;\n\n    return m;\n\n}\n", "idx": 13462, "substitutes": {"entries": ["entessions", "genturies", "settrows", "Entrys", "entlements", "entables", "tions", "integries", "settences", "meturies", "trants", "endessions", "turies", "contories", "settlements", "incries", "ntries", "Entries", "endions", "tessions", "tories", "contries", "incrows", "gentrants", "inclements", "estences", "entrants", "ENTies", "ties", "tries", "entories", "centrows", "ENTries", "Enturies", "enturies", "integuries", "ENTories", "Entrows", "entrows", "contrys", "tences", "settries", "contributes", "centries", "integrie", "integrows", "ientrie", "gentables", "entences", "enties", "entrys", "tables", "ntributes", "metables", "endries", "centences", "entions", "gentries", "ientries", "Entributes", "ientrows", "metrants", "Entrie", "entributes", "contrants", "estries", "conties", "endences", "ENTrants", "metries", "estions", "entrie", "ntrys", "estessions", "ienturies", "incences", "centlements"], "nb_entries": ["nb_endues", "nb_intry", "nb_exties", "nb_intrants", "nbofenties", "nb_ENTents", "nbofentries", "nb_intues", "nbofentrys", "nb_entrants", "nbofcentrys", "nb_centles", "nbofentry", "nb_centies", "nb_ntries", "nb_centries", "nb_enties", "nb_extrs", "nb_entles", "nb_endes", "nb_extrants", "nb_intes", "nb_intrs", "nb_entes", "nb_entents", "nb_endries", "nb_extents", "nb_entues", "nb_intles", "nb_centry", "nb_ENTies", "nb_extues", "nb_centrys", "nb_endrants", "nbofcentries", "nbofcentry", "nb_entrs", "nb_entry", "nb_ntles", "nb_centrs", "nb_centents", "nb_ntry", "nb_ENTrs", "nb_ntrys", "nb_intries", "nb_nties", "nb_entrys", "nbofcenties", "nb_ENTries", "nb_country", "nb_countries", "nb_extries", "nb_ntrs", "nb_countrys", "nb_counties", "nb_extes"], "wanted_timestamp": ["wanted_tmetime", "wanted_semency", "wanted_marketeter", "wanted_wateremark", "wanted_timeemark", "wanted_wateretime", "wanted_timest", "wanted_timeeter", "wanted_tmency", "wanted_tmeline", "wanted_timeestamp", "wanted_Timency", "wanted_timeline", "wanted_semest", "wanted_Timestamp", "wanted_shortetime", "wanted_Timeter", "wanted_timetime", "wanted_Timemark", "wanted_timemark", "wanted_marketestamp", "wanted_Timetime", "wanted_shortestamp", "wanted_tmestamp", "wanted_semetime", "wanted_timeeline", "wanted_shortest", "wanted_waterest", "wanted_timeter", "wanted_shorteter", "wanted_Timest", "wanted_tmest", "wanted_Timeline", "wanted_waterestamp", "wanted_timency", "wanted_timeest", "wanted_timeetime", "wanted_semestamp", "wanted_marketetime", "wanted_marketest"], "flags": ["codes", "types", "args", "planes", "cards", "pieces", "FLAG", "nl", "fd", "fl", "fs", "ins", "locks", "fields", "pins", "utils", "rets", "prot", "fun", "details", "settings", "bytes", "fo", "ants", "limits", "styles", "files", "checks", "lists", "dates", "ids", "strings", "alls", "plugins", "options", "allows", "faces", "sf", "features", "heads", "mask", "lag", "frames", "lf", "bits", "tests", "lines", "ages", "ats", "Flags", "afi", "ports", "stats", "atts", "ags", "ops", "links", "states", "ds", "fee", "requires", "mods", "rules", "fts", "flag", "vals"], "a": ["area", "as", "aj", "ak", "d", "ca", "ai", "l", "i", "da", "api", "na", "x", "ap", "aa", "o", "alpha", "w", "an", "ad", "ba", "p", "e", "A", "s", "la", "u", "aw", "pa", "af", "j", "n", "f", "aaa", "ma", "ab", "am", "c", "ac", "wa", "va", "r", "ae", "sa", "ga", "ar", "fa", "y"], "b": ["bis", "bc", "d", "reb", "ob", "bs", "ad", "ca", "l", "i", "bb", "fb", "bd", "binary", "bad", "h", "nb", "x", "aa", "machine", "v", "br", "mb", "job", "k", "o", "bp", "w", "bar", "u", "an", "ba", "p", "e", "be", "rb", "ib", "boot", "bot", "pb", "s", "sb", "wb", "j", "base", "n", "f", "bf", "bm", "ab", "bh", "c", "big", "am", "pa", "cb", "z", "body", "eb", "ok", "bas", "r", "abb", "bi", "ae", "B", "db", "emb", "lb", "y"], "m": ["mc", "cm", "wm", "d", "t", "l", "i", "me", "mid", "month", "fm", "g", "h", "mn", "x", "module", "mod", "mm", "ym", "model", "machine", "v", "tm", "em", "o", "w", "ms", "u", "an", "gm", "p", "e", "mr", "bm", "s", "z", "mi", "pa", "mini", "j", "mA", "n", "f", "mo", "hm", "ma", "am", "c", "pm", "M", "md", "man", "im", "r", "om", "um", "dim", "dm", "y", "sm", "mu"], "timestamp": ["timeetime", "timeline", "timetime", "tmetime", "scheestamp", "monthpoint", "timity", "ampedest", "metest", "simeter", "continestamp", "hometa", "simeline", "meteta", "Timity", "timeter", "monthest", "contineline", "tuneter", "continpoint", "scheeline", "timeeline", "tmeta", "timoffset", "scheplay", "contineport", "temestamp", "integest", "teneport", "metemark", "scheetime", "meteline", "ampedestamp", "ampedoffset", "hometime", "imemark", "mintpoint", "metetime", "tmeline", "Timpoint", "metency", "ampedemark", "timeta", "tmeter", "timemark", "Timest", "temeline", "tunestamp", "minteline", "tuneline", "simestamp", "imoffset", "timest", "templay", "impoint", "timpoint", "timment", "tenpoint", "timency", "integency", "imestamp", "metity", "timplay", "minteport", "Timment", "metoffset", "imest", "timette", "integity", "timeplay", "mintestamp", "imment", "monthment", "simette", "Timency", "temetime", "homeline", "teneline", "tmette", "integestamp", "tenestamp", "tunette", "Timestamp", "monthestamp", "tmestamp", "timeport", "metestamp", "homestamp", "timeestamp"]}}
{"project": "FFmpeg", "commit_id": "0de1319ee0109facefe9804ffe0f0d0df36b27ad", "target": 0, "func": "static int http_start_receive_data(HTTPContext *c)\n\n{\n\n    int fd;\n\n\n\n    if (c->stream->feed_opened)\n\n        return -1;\n\n\n\n    /* Don't permit writing to this one */\n\n    if (c->stream->readonly)\n\n        return -1;\n\n\n\n    /* open feed */\n\n    fd = open(c->stream->feed_filename, O_RDWR);\n\n    if (fd < 0) {\n\n        http_log(\"Error opening feeder file: %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    c->feed_fd = fd;\n\n\n\n    if (c->stream->truncate) {\n\n        /* truncate feed file */\n\n        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);\n\n        ftruncate(c->feed_fd, FFM_PACKET_SIZE);\n\n        http_log(\"Truncating feed file '%s'\\n\", c->stream->feed_filename);\n\n    } else {\n\n        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {\n\n            http_log(\"Error reading write index from feed file: %s\\n\", strerror(errno));\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n    c->stream->feed_size = lseek(fd, 0, SEEK_END);\n\n    lseek(fd, 0, SEEK_SET);\n\n\n\n    /* init buffer input */\n\n    c->buffer_ptr = c->buffer;\n\n    c->buffer_end = c->buffer + FFM_PACKET_SIZE;\n\n    c->stream->feed_opened = 1;\n\n    c->chunked_encoding = !!av_stristr(c->buffer, \"Transfer-Encoding: chunked\");\n\n    return 0;\n\n}\n", "idx": 26880, "substitutes": {"c": ["exec", "sc", "call", "cm", "k", "w", "dc", "uc", "oc", "p", "b", "anc", "i", "z", "C", "d", "enc", "xc", "ec", "cur", "config", "cr", "conf", "ct", "bc", "cy", "ch", "self", "rec", "u", "e", "fc", "con", "ic", "cl", "vc", "ac", "s", "cc", "ctx", "ci", "cp", "cf", "mc", "rc", "cache", "co", "sec", "lc", "ctrl", "ca", "f", "tc", "n", "cu", "t", "a", "coll", "conn", "arc", "v", "g", "r", "nc", "l", "cs", "ce", "pc"], "fd": ["md", "fen", "fed", " fid", "fe", "done", "dc", "af", "cd", "xd", "driver", "rd", "dy", "ecd", "d", "hd", "fn", "ld", "fff", "ds", "ad", "bf", "bd", "dd", "reader", "die", "db", "buf", "feed", "fc", "lf", "du", "ff", "did", "pd", "nd", "draft", "td", "dl", "fl", "wd", "handler", "FD", "wind", "fb", "fi", "fx", "cond", "ln", "cf", "fun", "f", "fs", "stream", "fa", "vd", "conn", "fp", "de", "sd", "sf", "df", "draw", "file", "dn", "pid"]}}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_cy = tcg_temp_new();\n\n\n\n    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);\n\n    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);\n\n\n\n    gen_ove_cy(dc, sr_cy);\n\n    tcg_temp_free(sr_cy);\n\n}\n", "idx": 13556, "substitutes": {"dc": ["context", "mc", "cam", "bc", "uc", "d", "ca", "cow", "director", "rc", "cc", "pc", "config", "fd", "cdn", "cm", "da", "DC", "lc", "cci", "cr", "conn", "cd", "cot", "doc", "nc", "tc", "c", "cca", "df", "design", "dt", "jc", "fc", "ac", "sc", "cf", " DC", "icc", "vc", "db", "ec", "CC", "dm"], "dest": ["path", " Dest", "d", "dist", "core", "config", "cdn", "orig", "home", "ctr", "source", "di", "txt", "loc", "dir", "nw", "gd", "de", "dev", "desc", "du", "wb", "dep", "route", "cb", "target", "sc", "Dest", "src", "rest", "decl", "destroy", "nom", "wd", "usr", "coord", "comb"], "srca": ["destb", "srcA", "desta", "sourceA", " srcA", "destA", "sourceb", "sourcea"], "srcb": ["scb", "scv", "rcv", "rca", "destB", "rcb", " srcv", "scB", "destb", "srcB", "sca", "desta", " srcB", "srcv", "rcB"]}}
{"project": "FFmpeg", "commit_id": "3a54c221d574ec944db1eddf9df895808f32bf9e", "target": 1, "func": "static const char *read_ts(const char *buf, int *ts_start, int *ts_end,\n\n                           int *x1, int *y1, int *x2, int *y2)\n\n{\n\n    int i, hs, ms, ss, he, me, se;\n\n\n\n    for (i=0; i<2; i++) {\n\n        /* try to read timestamps in either the first or second line */\n\n        int c = sscanf(buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\"\n\n                       \"%*[ ]X1:%u X2:%u Y1:%u Y2:%u\",\n\n                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,\n\n                       x1, x2, y1, y2);\n\n        buf += strcspn(buf, \"\\n\") + 1;\n\n        if (c >= 8) {\n\n            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;\n\n            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;\n\n            return buf;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 15133, "substitutes": {"buf": ["bt", "func", "runner", "vec", "port", "font", "context", "ff", "bc", "queue", "fd", "cv", "input", "tmp", "rc", "config", "fb", "orig", "binary", "bd", "msg", "uf", "conv", "buffer", "bag", "fp", "br", "buff", "output", "brace", "img", "rb", "bed", "fi", "pb", "data", "b", "sb", "Buffer", "wb", "Buff", "f", "result", "ab", "bh", "bu", "fe", "feed", "cat", "bind", "cb", "cas", "text", "bg", "offset", "cmd", "cf", "db", "cache", "src", "seq", "cur", "header", "ctx"], "ts_start": ["times_size", "tsprecur", "ts_max", "times_base", "ts_cur", "ats_end", "ats_get", "tsprenext", "ts__max", "times_end", "times_cur", "ts__end", "tsxnext", "ats_stop", "tsxstart", "ts_size", "ts__size", "ts_base", "tspreend", "tsprestart", "times_next", "tsxbase", "ats_start", "ts__start", "ts_stop", "tsxend", "ts_get", "times_max", "times_start", "ts_next"], "ts_end": ["tsacend", "tips_end", "ts_order", "tsacstop", "ts_ends", "tips_max", "ts___end", "tsacstart", " ts_ending", "ts_ending", "ts___send", "ts_send", "tips_start", "ts_max", "tips_order", "ats_stop", "ts___start", "tsacending", "ts_offset", " ts_ends", "ats_end", "times_end", "ats_ending", "ts___offset", "ts_stop", "times_send", "ats_start", "times_start", "times_offset"], "x1": ["y4", "X1", " x0", " x4", "x0", "w1", "w0", "w4", "y0", "w2", "x4", "X0", "X2"], "y1": ["y4", "Y2", " y4", "Y3", " y3", "Y1", "y3", "x0", "Y0", " y0", "y0", "Y4", "x4", "x3"], "x2": ["y4", "y5", "X1", "ix2", "y3", " x4", "ytwo", "X4", "x5", "xtwo", " x3", "ix3", "X5", " x5", "ixtwo", "ix1", " xtwo", "x4", "x3", "X2"], "y2": ["Y2", "Y3", " y3", "y5", "Y1", "vy1", "ya1", "y3", "x0", "vy2", "ya5", "ya2", "Y0", " y0", "y0", "vy5", "Y5", "x3"], "i": ["hi", "qi", "it", "ui", "m", "I", "d", "t", "ai", "ni", "xi", "id", "l", "iu", "gi", "ini", "oi", "ci", "x", "di", "si", "ie", "init", "ii", "v", "o", "u", "ind", "p", "e", "info", "mi", "li", "b", "ix", "j", "count", "n", "f", "phi", "ti", "c", "eni", "ji", "pi", "chi", "bi", "ri", "ami", "zi", "in", "index", "start"], "hs": ["hes", "ems", "hi", "hp", "wh", "ys", "hem", "HS", "rs", "cs", "qs", "h", "sq", "hel", "ps", "hh", "His", "s", "ens", "her", "gs", "hm", "ns", "xs", "hops", "ph", "ht", "ds", "sh", "his", "css", "ls", "hop", "ts", "hess", "ims", "vs", "ks"], "ms": ["MS", "ems", "sem", "m", "mc", "ses", "ys", "Ms", "rs", "les", "cs", "mn", "js", "mm", "si", "mes", "ps", "s", "mi", "ma", "ns", "ans", "md", "ds", "sh", "ls", "ips", "pos", "ts", "us", "mys", "ims", "vs", "ks"], "ss": ["ess", "sem", "ses", "rss", "bs", "rs", "SS", "ass", "cs", "sp", "si", "es", "mm", "sq", "mes", "ps", "s", "vs", "sf", "ns", "sc", "ds", "sh", "css", "ls", "pos", "ts", "hess", "us", "st", "iss", "mys", "ks", "sy"], "he": ["ke", "hi", "hes", "che", "ge", "she", "en", "self", "wh", "ha", "He", "hy", "ih", "so", "ale", "hem", "xe", "HE", "h", "ste", "gh", "hu", "ee", "e", "s", "be", "her", "han", "hee", "fe", "pe", "hen", "spe", "het", "le", "here", "you", "sh", "we", "his", "hess", "hea"], "me": ["ke", "sem", "mis", "ge", "m", "self", "te", "ale", "hem", "my", "sp", "si", "mm", "mes", "ye", "em", "ps", "oe", "sle", "mer", "ee", "e", "mor", "Me", "mi", "min", "ma", "fe", "pe", "md", "le", "meg", "sh", "ae", "we", "sea", "ME", "pos", "ph", "mu"], "se": ["ke", "sem", "ge", "she", "ses", "te", "so", "sp", "ste", "h", "sw", "SE", "ase", "si", "sq", "ps", "sle", "ee", "s", "be", "e", "ese", "th", "fe", "pe", "ne", "spe", "sc", "ce", "sl", "le", "sh", "ae", "sa", "su", "ser", "see", "sea", "sel", "ph", "ze"]}}
{"project": "qemu", "commit_id": "29a6731afb20707ab0c1f9be997bef74cef34665", "target": 0, "func": "static void vararg_number(void)\n\n{\n\n    QObject *obj;\n\n    QInt *qint;\n\n    QFloat *qfloat;\n\n    int value = 0x2342;\n\n    int64_t value64 = 0x2342342343LL;\n\n    double valuef = 2.323423423;\n\n\n\n    obj = qobject_from_jsonf(\"%d\", value);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%\" PRId64, value64);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n\n\n    qint = qobject_to_qint(obj);\n\n    g_assert(qint_get_int(qint) == value64);\n\n\n\n    QDECREF(qint);\n\n\n\n    obj = qobject_from_jsonf(\"%f\", valuef);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QFLOAT);\n\n\n\n    qfloat = qobject_to_qfloat(obj);\n\n    g_assert(qfloat_get_double(qfloat) == valuef);\n\n\n\n    QDECREF(qfloat);\n\n}\n", "idx": 24179, "substitutes": {"obj": ["ref", "ie", "pg", "pkg", "ns", "ob", "Object", "cb", "aj", "oid", "io", "bs", "bj", "oss", "el", "nb", "lib", "object", "nt", "js", "n", "j", "val", "code", "b", "p", "bo", "bb", "x", "jp", "eff", "ocr", "op", "boot", "office", "oa", "xxx", "Obj", "bm", "coll", "attr", "ut", "g", "node", "args", "otype", "pt", "data", "orb", "rb", "act", "bl", "tmp", "str", "pl", "sb", "po", "obo", "alt", "org", "pos", "oh", "objects", "adj", "dr", "fn", "api", "img", "bh", "type", "so", "id", "o", "obb", "art", "os", "ctx", "co", "ot", "off", "ext", "oi", "conn"], "qint": ["sqint", "eqint", "qnt", " qinner", "shinc", "qualin", "eqinc", "quinteger", "tINT", "dqicit", "qualint", "qunit", "qanit", "queryinteger", "shint", "quinc", "qqinteg", "quinit", "dqint", "qinit", "qind", "quicit", "tinteger", "dqid", " qinteg", "quobject", "quickint", "qid", "shid", "qainner", "qain", "qconfig", "quconfig", "sqinteger", "sqicit", "quinner", "queryint", "quinteg", "quint", "qinner", "qinc", "dqINT", "qqint", "quin", "sqinit", "qINT", "qualinner", "shind", "queryINT", "sqinteg", "qicit", "qinteg", " qconfig", "quinst", "sqobject", "qqinner", "sqnt", " qinit", "qualnit", "qnit", "quickinc", "qinteger", "dqinteger", "dqfloat", "qaint", "quid", "qin", "quickinteger", "qunt", "eqinst", "dqinc", "dqnt", "qinst", "tfloat", "queryfloat", "quind", "tint", " qobject", "dqind", "qobject", "qqconfig", "eqinteger", "quickinst"], "qfloat": ["hfloat", "qustring", " qinteger", "qfat", "sqflat", "Qdouble", "querystring", "qflat", "queryfat", "iqdouble", "querydouble", "hflat", "iqfloat", "quflat", "Qinteger", "gfloat", "gflat", " qdouble", "qflo", "Qfloat", "hflo", "qpart", "iqflat", "hdouble", "queryfloat", "iqflo", "querypart", "gpart", "sqfloat", "gdouble", "qufloat", "quflo", "qdouble", "qfinal", "Qfinal", " qflat", "qinteger", "ginteger", "gfat", " qfinal", "sqpart", "qudouble", "queryflat", " qstring", "qstring", "gfinal", "sqfat"]}}
{"project": "qemu", "commit_id": "bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6", "target": 1, "func": "void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n", "idx": 963, "substitutes": {"timer": ["Timer", "icer", "server", "outer", "imer", "buffer", "ext", "time", "inter", "term", "counter", "peer", "txt", "tim", "acker", "ee", "clock", "caster", "browser", "tick", "worker", "tc", "ger", "roller", "ter", "icker", "later", "inner", "amer", "er", "master", "ti", "err", "event", "temp", "runner", "writer", "reader", "maker", "ler", "lc", "theme", "loader", "message", "handler", "mom", "processor", "driver", "tm", "mr", "thread", "hour", "iner", "acer", "manager", "cer", "sim", "player", "timeout", "walker"], "count": ["match", "call", "base", "mount", "name", "check", "lock", "read", "time", "offset", "counter", "large", "cc", "process", "current", "clock", "weight", "empty", "num", "max", "code", "number", "cond", "force", "work", "c", "cpu", "size", "length", "len", "child", "core", "cache", "app", "amount", "sum", "seq", "thread", "path", "full", "Count", "load", "ast", "start", "cast"]}}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_4w_msa(src + stride - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 4);\n\n}\n", "idx": 17118, "substitutes": {"dst": ["dsl", "dssl", "Dst", "fedsl", "dssrc", "dsrc", "fedsrc", "Dsrc", "dsst", "Dsts", "Drc", "fedst", " dsrc", " drc", "fedrc", " dsts", "dsts", " dsl", "drc"], "src": ["grad", "sup", "sur", "rest", "dest", "ctr", "rc", "lit", "rt", "supp", "sb", "cb", "sl", "stream", "attr", "bc", "loc", "sel", "sec", "low", "gb", "rd", "size", "rib", "st", "config", "img", "sr", "sc", "ssl", "gl", "buf", "start", "sync", "cur", "rb", "rl", "lib", "bg", "url", "b", "gz", "sub", "inst", "source", "dist"], "stride": ["drider", "strride", "ptIDE", "Strided", "Strride", "Stride", "grider", "brided", "hrIDE", "ctrone", "ctride", "hrided", "arride", " strride", "drided", "serviden", "servider", "stider", "strone", "yride", "servided", "ptided", "briden", "striden", " strided", "stide", "arrone", "hriden", "arrider", "strided", "Strider", "yrride", "ptiden", "stides", "grided", "strides", "Strides", " strider", "yrider", "grides", "Strone", "ctrided", "servide", "dride", "hride", "ptide", "strider", "brIDE", "stiden", "strIDE", "ctrider", "gride", "arrided", "driden", "bride", "yrided", "stided"]}}
{"project": "FFmpeg", "commit_id": "4b9ac0b5f070f35eff671d83cee436db40631112", "target": 0, "func": "static int mpegaudio_parse(AVCodecParserContext *s1,\n\n                           AVCodecContext *avctx,\n\n                           uint8_t **poutbuf, int *poutbuf_size, \n\n                           const uint8_t *buf, int buf_size)\n\n{\n\n    MpegAudioParseContext *s = s1->priv_data;\n\n    int len, ret;\n\n    uint32_t header;\n\n    const uint8_t *buf_ptr;\n\n\n\n    *poutbuf = NULL;\n\n    *poutbuf_size = 0;\n\n    buf_ptr = buf;\n\n    while (buf_size > 0) {\n\n\tlen = s->inbuf_ptr - s->inbuf;\n\n\tif (s->frame_size == 0) {\n\n            /* special case for next header for first frame in free\n\n               format case (XXX: find a simpler method) */\n\n            if (s->free_format_next_header != 0) {\n\n                s->inbuf[0] = s->free_format_next_header >> 24;\n\n                s->inbuf[1] = s->free_format_next_header >> 16;\n\n                s->inbuf[2] = s->free_format_next_header >> 8;\n\n                s->inbuf[3] = s->free_format_next_header;\n\n                s->inbuf_ptr = s->inbuf + 4;\n\n                s->free_format_next_header = 0;\n\n                goto got_header;\n\n            }\n\n\t    /* no header seen : find one. We need at least MPA_HEADER_SIZE\n\n               bytes to parse it */\n\n\t    len = MPA_HEADER_SIZE - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n\t    if (len > 0) {\n\n\t\tmemcpy(s->inbuf_ptr, buf_ptr, len);\n\n\t\tbuf_ptr += len;\n\n\t\tbuf_size -= len;\n\n\t\ts->inbuf_ptr += len;\n\n\t    }\n\n\t    if ((s->inbuf_ptr - s->inbuf) >= MPA_HEADER_SIZE) {\n\n            got_header:\n\n\t\theader = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n\n\t\t    (s->inbuf[2] << 8) | s->inbuf[3];\n\n\n\n                ret = mpa_decode_header(avctx, header);\n\n                if (ret < 0) {\n\n\t\t    /* no sync found : move by one byte (inefficient, but simple!) */\n\n\t\t    memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n\n\t\t    s->inbuf_ptr--;\n\n                    dprintf(\"skip %x\\n\", header);\n\n                    /* reset free format frame size to give a chance\n\n                       to get a new bitrate */\n\n                    s->free_format_frame_size = 0;\n\n\t\t} else {\n\n                    s->frame_size = ret;\n\n#if 0\n\n                    /* free format: prepare to compute frame size */\n\n\t\t    if (decode_header(s, header) == 1) {\n\n\t\t\ts->frame_size = -1;\n\n                    }\n\n#endif\n\n\t\t}\n\n\t    }\n\n        } else \n\n#if 0\n\n        if (s->frame_size == -1) {\n\n            /* free format : find next sync to compute frame size */\n\n\t    len = MPA_MAX_CODED_FRAME_SIZE - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n            if (len == 0) {\n\n\t\t/* frame too long: resync */\n\n                s->frame_size = 0;\n\n\t\tmemmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n\n\t\ts->inbuf_ptr--;\n\n            } else {\n\n                uint8_t *p, *pend;\n\n                uint32_t header1;\n\n                int padding;\n\n\n\n                memcpy(s->inbuf_ptr, buf_ptr, len);\n\n                /* check for header */\n\n                p = s->inbuf_ptr - 3;\n\n                pend = s->inbuf_ptr + len - 4;\n\n                while (p <= pend) {\n\n                    header = (p[0] << 24) | (p[1] << 16) |\n\n                        (p[2] << 8) | p[3];\n\n                    header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n\n                        (s->inbuf[2] << 8) | s->inbuf[3];\n\n                    /* check with high probability that we have a\n\n                       valid header */\n\n                    if ((header & SAME_HEADER_MASK) ==\n\n                        (header1 & SAME_HEADER_MASK)) {\n\n                        /* header found: update pointers */\n\n                        len = (p + 4) - s->inbuf_ptr;\n\n                        buf_ptr += len;\n\n                        buf_size -= len;\n\n                        s->inbuf_ptr = p;\n\n                        /* compute frame size */\n\n                        s->free_format_next_header = header;\n\n                        s->free_format_frame_size = s->inbuf_ptr - s->inbuf;\n\n                        padding = (header1 >> 9) & 1;\n\n                        if (s->layer == 1)\n\n                            s->free_format_frame_size -= padding * 4;\n\n                        else\n\n                            s->free_format_frame_size -= padding;\n\n                        dprintf(\"free frame size=%d padding=%d\\n\", \n\n                                s->free_format_frame_size, padding);\n\n                        decode_header(s, header1);\n\n                        goto next_data;\n\n                    }\n\n                    p++;\n\n                }\n\n                /* not found: simply increase pointers */\n\n                buf_ptr += len;\n\n                s->inbuf_ptr += len;\n\n                buf_size -= len;\n\n            }\n\n\t} else \n\n#endif\n\n        if (len < s->frame_size) {\n\n            if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE)\n\n                s->frame_size = MPA_MAX_CODED_FRAME_SIZE;\n\n\t    len = s->frame_size - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n\t    memcpy(s->inbuf_ptr, buf_ptr, len);\n\n\t    buf_ptr += len;\n\n\t    s->inbuf_ptr += len;\n\n\t    buf_size -= len;\n\n\t}\n\n        //    next_data:\n\n        if (s->frame_size > 0 && \n\n            (s->inbuf_ptr - s->inbuf) >= s->frame_size) {\n\n            *poutbuf = s->inbuf;\n\n            *poutbuf_size = s->inbuf_ptr - s->inbuf;\n\n\t    s->inbuf_ptr = s->inbuf;\n\n\t    s->frame_size = 0;\n\n\t    break;\n\n\t}\n\n    }\n\n    return buf_ptr - buf;\n\n}\n", "idx": 4681, "substitutes": {"s1": ["s81", "cone", "sone", "c2", "ts1", "c1", "ds2", "tsone", "s2", "S2", "dsone", "s0", "sp0", "S1", "gs1", "gs2", "ds11", "ts11", "ds1", "gs0", "sp81", "gs81", "sp1", "c11", "s11", "ts2", "S81", "S0", "sp2"], "avctx": ["akcontext", "awctx", "akconfig", "maccp", "AVctx", "afcmp", "avconfig", "AVcontext", "avcmp", "awkb", "macconfig", "afkb", "macctx", "akctx", "afctx", "afcp", "avcontext", "avcp", "AVcmp", "maccontext", "awcontext", "akcp", "afcontext", "avkb", "afconfig", "awcmp", "AVkb"], "poutbuf": ["pinfb", "pOutqueue", "poutfb", "mpoutbuffer", "painsbuffer", "pargfp", "mpoutqueue", "p_buffer", "pOutfb", "painsfb", " p_buf", "pagainfp", "pinqueue", "pagainbuf", "mpinfb", "pagainbuff", "mpinbuffer", " poutbuff", " p_buff", "pagainbuffer", "mpinbuf", "mpoutbuf", "pOutbuf", "p_fp", "painsbuf", "pOutbuffer", "poutbuffer", "pargbuf", "p_buff", "poutbuff", "pargbuffer", " p_fp", " p_buffer", "pinbuf", "pinbuffer", "poutfp", " poutfp", "poutqueue", "painsqueue", "mpoutfb", "p_buf", "pargbuff", "mpinqueue", " poutbuffer"], "poutbuf_size": ["poutbuf___size", "poutbuf_sized", "poutfile_unit", "poutbuf___capacity", "poutbuf_capacity", "poutbuf___unit", "poutfile_scale", "poutbuf_unit", "poutqueue_sized", "poutbuf___scale", "poutqueue_Size", "poutfile_capacity", "poutbuf_scale", "poutqueue_size", "poutbuf_Size", "poutfile_size"], "buf": ["buff", "vec", "block", "rb", "tmp", "b", "data", "queue", "uc", "fb", "wb", "uf", "null", "window", "offset", "length", "buffer", "Buffer", "cmd", "ctx", "bc", "fp", "cb", "empty", "filename", "seq", "uint", "zero", "alloc", "cf", "cv", "pb", "src"], "buf_size": ["bufacsync", "bufFbody", "buf_sized", "queue_Size", "wav_pos", "buff_sync", "bufCsize", "frame_style", "frame67size", "queue_capacity", "buf_len", "buff_body", "wavfsized", "buf_sec", "bufqpos", "frame_size", "frame67start", "wavfpos", "buff2sec", "bufacsize", "buffSize", "bufCSize", "bufFsize", "buffstart", "buf2pos", "buffstyle", "buf_pos", "wavfsize", "buff2body", "buf67start", "buffpos", "bufClen", "wav_size", "buf2sized", "frame_start", "buf_body", "queue_size", "wav_sized", "queue_len", "buff_size", "buffsized", "buff2size", "buff2sync", "buf_style", "bufFsync", "buf_capacity", "fb_number", "bufqsize", "buf2body", "fb_pos", "fbqSize", "buf67style", "wavfcapacity", "buf2capacity", "buf67Size", "fb_Size", "frame67style", "buf_number", "buf2sync", "buffcapacity", "buf67size", "buf_start", "bufqSize", "frame67Size", "wav_capacity", "fbqpos", "fb_size", "buff_sec", "bufacbody", "fbqsize", "frame_Size", "fbqnumber", "bufacsec", "buf2sec", "bufFsec", "buf_Size", "bufCcapacity", "bufqnumber", "buf_sync", "buffsize", "buf2size"], "s": ["sf", "S", "a", "b", "data", "i", "f", "parts", "d", "service", "hs", "conf", "w", "self", "h", "sa", "g", "sym", "y", "sets", "is", "spec", "services", "its", "states", "server", "ls", "ops", "bis", "ds", "ctx", "ts", "sv", "fs", "new", "sq", "ms", "site", "rs", "as", "strings", "ans", "ins", "sg", "comments", "sync", "ses", "has", "cs", "u", "vs", "e", "ks", "secondary", "qs", "t", "c", "os", "ssl", "ims", "r", "ps", "o", "v", "session", "si", "sys", "m", "l", "xs", "ns", "stats", "us", "ss", "uns", "gs", "se", "full", "n", "su", "es", "js"], "len": ["dy", "vec", "mem", "el", "count", "la", "nt", "lt", "val", "lan", "data", "elt", "non", "lp", "ll", "loc", "l", "num", "fin", "f", "lit", "ler", "fl", "length", "ls", "sl", "limit", "split", "code", "low", "en", "L", "ul", "n", "lib", "hl", "led", "lon", "rev", "ie", "seq", "span", "z", "pos", "gen", "fun", "ln", "Len", "ind", "line", "ld", "lin", "lc", "dl", "li", "il", "bl", "pl", "lf", "lim", "conn", "le", "size"], "ret": ["del", "flag", "reg", "bin", "rt", "red", "sr", "alt", "count", "nt", "val", "rc", "reply", "fin", "num", "lit", " Ret", "att", "obj", "arg", "res", "match", "det", "en", "arr", "RET", "ben", "err", "str", "rev", "result", "Ret", "ft", "opt", "usr", "re", "fun", "back", "hash", "resp", "success", "ref", "no", "conn", "rets", "msg"], "header": ["writer", "dr", "name", "layer", "er", "rr", "pin", "config", "cover", "pillar", "data", "final", "rf", "body", "title", "null", "fb", "offset", "f", "event", "player", "meta", "version", "description", "buffer", "code", "definition", "margin", "section", "Header", "her", "message", "forward", "headers", "fp", "cb", "response", "filename", "str", "border", "result", "over", "err", "h", "protected", "column", "line", "ln", "cap", "detail", "head", "type", "cf", "dt", "pair", "cookie", "conn", "tail", "prefix"], "buf_ptr": [" buf_flush", " buf_ctr", " buf_pointer", "bufUptr", "buf_pointer", "queue_addr", "bufUflush", "queue_pointer", "buf_ctr", "bufUsize", "buf_addr", "buf_flush", "queue_size", "buf_loc", "queue_ptr", " buf_loc", "bufUpointer"], "inbuf_ptr": ["infb_size", "inqueue_fd", "inbufNcur", "inbuf_slice", "inbuf_size", "inbuf0offset", "inbuf_err", "infb_pointer", "inbufNptr", "inqueue_pointer", "inbuf_ctr", "inqueue_loc", "inbuf_fd", "infb_ptr", "inbufNpointer", "inbuf0pointer", "inqueue_ptr", "inbuf_pointer", "inbuf_Ptr", "inbuf0ptr", "inbuf0tr", "inbuf_que", "inqueue_err", "infb_loc", "inbuf0que", "inbuf_cur", "inqueue_cur", "inbuf_tr", "inbufNerr", "inbuf_offset", "inbuf_loc"]}}
{"project": "qemu", "commit_id": "9d8256ebc0ef88fb1f35d0405893962d20cc10ad", "target": 1, "func": "void sdl2_gl_scanout(DisplayChangeListener *dcl,\n\n                     uint32_t backing_id, bool backing_y_0_top,\n\n\n                     uint32_t x, uint32_t y,\n\n                     uint32_t w, uint32_t h)\n\n{\n\n    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);\n\n\n\n    assert(scon->opengl);\n\n    scon->x = x;\n\n    scon->y = y;\n\n    scon->w = w;\n\n    scon->h = h;\n\n    scon->tex_id = backing_id;\n\n    scon->y0_top = backing_y_0_top;\n\n\n\n    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);\n\n\n\n    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {\n\n        sdl2_set_scanout_mode(scon, false);\n\n        return;\n\n    }\n\n\n\n    sdl2_set_scanout_mode(scon, true);\n\n    if (!scon->fbo_id) {\n\n        glGenFramebuffers(1, &scon->fbo_id);\n\n    }\n\n\n\n    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);\n\n    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,\n\n                              GL_TEXTURE_2D, scon->tex_id, 0);\n\n}", "idx": 25182, "substitutes": {"dcl": ["bml", "pdacl", "ffl", "pbl", " dpl", "bcl", "dpl", "dml", "bacl", "pacl", "Dml", "fcl", "dfl", "Dcl", "bfl", "pdcl", "sdfl", "Dfl", "fpl", " dbc", "pcl", " dbl", "pdbl", "dbl", "sdcl", "sdbc", "psc", " dsc", "dacl", "dbc", " dfl", "Dacl", " dacl", "dsc", "fbc", "pdsc", "sdpl", " dml"], "backing_id": ["backing_side", "backings_side", "backings_type", "backing_start", "backings_id", "backing_name", "backing_ids", "backings_start", "backings_ids", "backings_name", "backing_type"], "backing_y_0_top": ["backing_y_in_bottom", "backing_y_0_high", "backing_y_from_bottom", "backing_y_from_high", "backing_y_in_top", "backing_y_in_high", "backing_y_in_tops", "backing_y_0_tops", "backing_y_0_bottom", "backing_y_from_tops", "backing_y_from_top"], "x": ["xx", "z", "i", "p", "b", "m", "c", "name", "d", "ix", "px", "data", "tx", "address", "ax", "id", "X", "u", "wx", "e", "xy", "xi", "dx", "s", "xs", "win", "f", "n", "index", "t", "a", "v", "ex", "pos", "l", "g"], "y": ["hy", "z", "yi", "i", "p", "b", "ya", "dy", "oy", "sy", "c", "ay", "wy", "yt", "py", "ye", "type", "cy", "id", "vy", "u", "yo", "ey", "o", "yx", "ii", "ky", "Y", "ry", "n", "yn", "ny", "year", "q", "v", "ty", "l", "yy"], "w": ["height", "ow", "k", "z", "i", "p", "b", "c", "ww", "m", "wb", "d", "sw", "wave", "weight", "wh", "id", "rw", "u", "wx", "e", "o", "work", "s", "l", "wl", "fw", "wd", "ew", "size", "win", "wp", "wal", "f", "aw", "n", "W", "t", "v", "r", "we", "wa", "g"], "h": ["height", "hm", "ht", "k", "z", "i", "p", "m", "b", "c", "sh", "dy", "d", "top", "ih", "bh", "H", "end", "ah", "id", "u", "e", "o", "rh", "s", "hs", "eh", "f", "n", "j", "t", "host", "ha", "q", "wa", "v", "l", "hi", "ph", "oh", "g"], "scon": ["sinacon", "Sca", "lscon", " sgin", "sympen", "esconst", "fwin", "ansgin", "sfac", "psban", "sinocon", "sun", " sfc", "psuc", "openscon", "sinCON", "lsban", "dca", "symocon", "itscn", "osrc", "lscn", "sinCon", "lsCon", "portocon", "scn", "sportssel", "sconnect", "sportscon", "suc", "dsocon", "skycon", " sCon", " sfac", " sctrl", "wspen", " sacon", "sCon", "sincon", "dsun", "sco", "psconst", "dsca", "swin", "dscn", "lsCON", "sinca", "anscon", "dsfc", "Sacon", "physron", " src", " sconnect", " socon", " sCON", " sconn", "itsconn", "tsconst", "itsfc", "physcn", "sinban", "itsban", "opensco", "sban", "portcon", "tsrc", "sportsconst", " ssel", "skyran", " sca", "wscon", "lsocon", "pscon", "dsrc", "fcon", "portpen", "symconst", "osconnect", "gsconst", "physfc", "tscon", "wsocon", " sconnection", "tsdon", " scn", "lsconst", "itsconst", "symcon", "dsconnect", "gsocon", "opensfac", "src", "osfc", "dfc", "esdon", "psocon", "gscon", "dsco", "itsron", " sron", "gsconnection", "dconn", "lsran", "docon", "openspen", "tsfc", " suc", "tspen", "ssun", " sun", "fconnect", "osgin", "ssrc", "ansconnect", "sCON", "spen", "sinco", "sconst", "gsctrl", "osocon", "sconn", "lsconnection", " sconst", "sacon", "gsco", "sportspen", "Scon", "sgin", "gspen", "itscon", "fco", "psco", "sctrl", "sfc", "skyocon", "oscon", "physcon", "lsdon", "ssel", "dscon", "SCON", " sban", "tsocon", "dsran", "sscon", "dwin", "ansrc", "wsconst", "dswin", "lsctrl", "sca", "gsfac", "socon", "skycn", "sinuc", " spen", "portconst", "sdon", "ssconn", "sconnection", "escon", "psconn", " sco", "sran", "drc", " swin", "dcon", "dsconn", "sron", "esocon"]}}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static void read_sgi_header(ByteIOContext *f, SGIInfo *info)\n{\n    info->magic = (unsigned short) get_be16(f);\n    info->rle = get_byte(f);\n    info->bytes_per_channel = get_byte(f);\n    info->dimension = (unsigned short)get_be16(f);\n    info->xsize = (unsigned short) get_be16(f);\n    info->ysize = (unsigned short) get_be16(f);\n    info->zsize = (unsigned short) get_be16(f);\n#ifdef DEBUG\n    printf(\"sgi header fields:\\n\");\n    printf(\"  magic: %d\\n\", info->magic);\n    printf(\"    rle: %d\\n\", info->rle);\n    printf(\"    bpc: %d\\n\", info->bytes_per_channel);\n    printf(\"    dim: %d\\n\", info->dimension);\n    printf(\"  xsize: %d\\n\", info->xsize);\n    printf(\"  ysize: %d\\n\", info->ysize);\n    printf(\"  zsize: %d\\n\", info->zsize);\n#endif\n    return;\n}", "idx": 12814, "substitutes": {"f": ["m", "ff", "fd", "t", "fs", "l", "i", "inf", "fb", "fm", "uf", "fore", "fx", "fo", "fp", "fr", "buff", "of", "form", "conf", "F", "u", "p", "e", "fi", "fed", "data", "sf", "af", "b", "bf", "lf", "fe", "c", "feed", "fa", "tf", "xf", "file", "cf", "r", "exec", "rf", "fen", "fc", "fac", "fw"], "info": ["i", "inf", "def", "image", "si", "of", "obj", "base", "information", "end", "is", "tf", "aux", "work", "off", "num", "Info", "index", "hi", "self", "part", "id", "home", "io", "api", "di", "txt", "full", "key", "error", "check", "parse", "fi", "data", "result", "inner", "xml", "config", "extra", "fo", "init", "ie", "update", "app", "help", "options", "note", "http", "comp", "j", "from", "add", "diff", "INFO", "type", "fw", "bug", "it", "ui", "gi", "name", "py", "ii", "conf", "buff", "same", "op", "now", "iso", "hand", "opt", "start"]}}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,\n\n                                   uint8_t devfn, hwaddr addr, bool is_write,\n\n                                   IOMMUTLBEntry *entry)\n\n{\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    VTDContextEntry ce;\n\n    uint8_t bus_num = pci_bus_num(bus);\n\n    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;\n\n    uint64_t slpte, page_mask;\n\n    uint32_t level;\n\n    uint16_t source_id = vtd_make_source_id(bus_num, devfn);\n\n    int ret_fr;\n\n    bool is_fpd_set = false;\n\n    bool reads = true;\n\n    bool writes = true;\n\n    uint8_t access_flags;\n\n    VTDIOTLBEntry *iotlb_entry;\n\n\n\n    /*\n\n     * We have standalone memory region for interrupt addresses, we\n\n     * should never receive translation requests in this region.\n\n     */\n\n    assert(!vtd_is_interrupt_addr(addr));\n\n\n\n    /* Try to fetch slpte form IOTLB */\n\n    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);\n\n    if (iotlb_entry) {\n\n        trace_vtd_iotlb_page_hit(source_id, addr, iotlb_entry->slpte,\n\n                                 iotlb_entry->domain_id);\n\n        slpte = iotlb_entry->slpte;\n\n        access_flags = iotlb_entry->access_flags;\n\n        page_mask = iotlb_entry->mask;\n\n        goto out;\n\n    }\n\n\n\n    /* Try to fetch context-entry from cache first */\n\n    if (cc_entry->context_cache_gen == s->context_cache_gen) {\n\n        trace_vtd_iotlb_cc_hit(bus_num, devfn, cc_entry->context_entry.hi,\n\n                               cc_entry->context_entry.lo,\n\n                               cc_entry->context_cache_gen);\n\n        ce = cc_entry->context_entry;\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n    } else {\n\n        ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce);\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n        if (ret_fr) {\n\n            ret_fr = -ret_fr;\n\n            if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n                trace_vtd_fault_disabled();\n\n            } else {\n\n                vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n            }\n\n            goto error;\n\n        }\n\n        /* Update context-cache */\n\n        trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo,\n\n                                  cc_entry->context_cache_gen,\n\n                                  s->context_cache_gen);\n\n        cc_entry->context_entry = ce;\n\n        cc_entry->context_cache_gen = s->context_cache_gen;\n\n    }\n\n\n\n    /*\n\n     * We don't need to translate for pass-through context entries.\n\n     * Also, let's ignore IOTLB caching as well for PT devices.\n\n     */\n\n    if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) {\n\n        entry->iova = addr & VTD_PAGE_MASK_4K;\n\n        entry->translated_addr = entry->iova;\n\n        entry->addr_mask = ~VTD_PAGE_MASK_4K;\n\n        entry->perm = IOMMU_RW;\n\n        trace_vtd_translate_pt(source_id, entry->iova);\n\n\n\n        /*\n\n         * When this happens, it means firstly caching-mode is not\n\n         * enabled, and this is the first passthrough translation for\n\n         * the device. Let's enable the fast path for passthrough.\n\n         *\n\n         * When passthrough is disabled again for the device, we can\n\n         * capture it via the context entry invalidation, then the\n\n         * IOMMU region can be swapped back.\n\n         */\n\n        vtd_pt_enable_fast_path(s, source_id);\n\n\n\n        return true;\n\n    }\n\n\n\n    ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level,\n\n                               &reads, &writes);\n\n    if (ret_fr) {\n\n        ret_fr = -ret_fr;\n\n        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n            trace_vtd_fault_disabled();\n\n        } else {\n\n            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n        }\n\n        goto error;\n\n    }\n\n\n\n    page_mask = vtd_slpt_level_page_mask(level);\n\n    access_flags = IOMMU_ACCESS_FLAG(reads, writes);\n\n    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,\n\n                     access_flags, level);\n\nout:\n\n    entry->iova = addr & page_mask;\n\n    entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask;\n\n    entry->addr_mask = ~page_mask;\n\n    entry->perm = access_flags;\n\n    return true;\n\n\n\nerror:\n\n    entry->iova = 0;\n\n    entry->translated_addr = 0;\n\n    entry->addr_mask = 0;\n\n    entry->perm = IOMMU_NONE;\n\n    return false;\n\n}\n", "idx": 8949, "substitutes": {"vtd_as": ["vdd_master", "vtd2AS", "vtd_session", "vdd2AS", "vtdokas", "vtdappasu", "vtdoksession", "vpd__as", "vdd2as", "vtd_AS", "vtdappras", "vpd_asu", "vTD__in", "vpd__ras", "vTD__is", "vtdokmaster", "vtd2as", "vTD_as", "vdd2session", "vtdappas", "vtd__master", "vtdokAS", "vtd_ras", "vtd2master", "vTD_ras", "vtdappis", "vdd_session", "vtd__as", "vpd_as", "vTD__as", "vdd_as", "vtd__AS", "vtd2session", "vTD__ras", "vdd2master", "vpd_ras", "vpd_is", "vpd__is", "vdd_AS", "vtd_master", "vtd__asu", "vtd__in", "vtd__ras", "vtd_asu", "vTD_in", "vtd_in", "vTD_is", "vpd__asu", "vtd__is", "vtd_is", "vtd__session"], "bus": ["boot", "base", "nt", "board", "http", "mount", "uss", "buf", "bridge", "service", "config", "uri", "used", "driver", "ux", "us", "BUS", "serial", "bc", "os", "host", "Bus", "sync", "name", "state", "address", "port", "usb", "plugin", "lock", "loop", "use", "cache", "proc", "drive"], "devfn": [" devln", "devname", " devfun", "diffdn", "diffkn", "diskfp", "diffn", "devicefp", "evfun", "bugn", "divfun", "devfun", "devkn", "divn", "divdn", "diskname", "evdn", "bugfun", "devln", "switchn", " devkn", "evfn", "domfp", "evname", "switchfp", "evn", "difffn", "diskfun", "switchln", "devicefn", "evkn", "diskfn", "evfp", "devdn", " devn", "devfp", " devfp", "devicename", "bugdn", " devdn", "domln", "devn", "divfn", "domn", "bugfn", "devicefun", "switchfn", "domfn"], "addr": ["mac", "adr", "area", "arr", "base", "ack", "len", "val", "id", "info", "conn", "rr", "b", "x", "bridge", "ad", "ref", "config", "uri", "ace", "server", "attr", "afi", "rss", "amd", "ag", "ptr", "act", "rs", "loc", "ac", "dr", "host", "rt", "ha", "route", "amp", "oa", "name", "sta", "rc", "md", "address", "kt", "dd", "nr", "part", "dc", "offset", "hop", "node", "asm", "eth", "vr", "layer", "pos", "rx", "ip", "url", "ann", "pkg", "wd", "adder"], "is_write": ["is__writing", "in_written", "in_write", "is_read", "in_writing", "in_read", "is2write", "is__read", "is2written", "is_writing", "is2read", "is__write", "is_written", "is2writing", "is__written"], "entry": ["ee", "session", "je", "Entry", "enter", "ry", "record", "ent", "service", "data", "server", "e", "ace", "ie", "rc", "ries", "event", "address", "ident", "spec", "row", "ge", "import", "ant", "insert", "cell"], "s": ["session", "sg", "ts", "ks", "is", "si", "g", "source", "stats", "m", "http", "b", "t", "ops", "i", "gs", "service", "c", "sa", "p", "server", "e", "parts", "ins", "request", "sq", "us", "js", "f", "os", "cs", "o", "S", "es", "sync", "space", "south", "state", "services", "sl", "r", "bis", "ns", "storage", "sb", "sis", "spec", "this", "sys", "self", "ses", "ps", "site", "a", "ss", "settings", "ssl", "sc"], "ce": ["le", "ve", "ance", "ace", "cc", "ie", " je", "code", " exce", "cur", "cal", "cle", "ca", "let", "gu", "ide", "ee", "c", "ct", "component", "se", "e", "ate", "cf", "pe", "ze", "ense", "ice", "che", " CE", " ent", "ke", "cast", "ced", "cel", "ant", "ge", "ine", "cell", "he", " ke", "CE", "cer", " ge", "cu", "ue", "dr", "cs", "ae", "catch", "edge", " ace", "ces", "cat", "use", "co", " pe", " ne", "ne", "oe", "SE", "ade", "see", " ie", "cue", "coe", "client", "ci", "force", "fe", "cy", "te"], "cc_entry": ["cc_rance", "cc_enter", "cn_enter", "ccappentry", "ccallentry", "cf_enter", "cc_element", "ccappenter", "cf_start", "rc_server", "CC_entry", "cc___inc", "ccappresult", "ccapparchive", "cf_entry", "cc_server", "cc_start", "CC_enter", "cn_event", "cc_event", "ccappelement", "ccallresult", "CC_import", "ctx_import", "CC_archive", "cnallenter", "cc_archive", "rc_path", "cc_import", " cc_inc", "cc_path", "cnallentry", "cnallevent", "cn_result", "cc_index", "ctx_reader", "cc_inc", "cf_element", "cc___path", "ctx_element", "cc___server", "ccallevent", "cnallresult", "ccallenter", " cc_index", "ccappevent", "ccappstart", " cc_rance", "cc___entry", "ccappimport", "cc_result", "cn_entry", "rc_inc", "cc_reader", "rc_entry", "ctx_entry"], "slpte": ["celptes", "celppn", "slppn", "slportd", " slntype", " slpta", "slntf", " slnta", "slptes", "slpointa", "slportey", "slupte", "celppes", "slpetes", "islpetec", "sliptec", "nlptec", "slnte", "celppe", "slpete", "nlptd", "slintes", "nlptey", "islptea", "sliptey", "slinte", "slppf", "slppes", "nlupte", "slptey", "slptf", "islpete", "slppe", "slntype", "slpetie", "celpppe", "slpointype", "slppec", " slnte", "slppea", "slporte", "slptn", "slftie", "nluptec", "nlpte", "slfte", "slptea", "celptpe", "slpetn", "slftea", "slintpe", "islpetea", "islpte", "sliptd", "slptec", "sluptd", "slpta", "islpetie", "slpetpe", "slppa", "slpetea", "celptn", "slptie", "slpppe", "sluptey", "slnta", "slptd", "slintn", "islptie", "slptype", "slppie", " slptf", "slppype", "slipte", " slntf", " slptype", "sluptec", "slpetec", "nluptd", "nluptey", "celpte", "slftec", "slportec", "slpointe", "slptpe", "islptec", "slpointf"], "page_mask": ["page_limit", "page___max", "page_flags", "page_ask", " page_length", " page_flags", " page_ask", "page___length", "page___mask", "page___limit", " page_limit", "page___flags", "page_max", "page_length", "page___ask", " page_max"], "level": ["parent", "zip", "pass", "base", "delay", "scale", "low", "lvl", "limit", "local", "loc", "mode", "priority", "code", "index", "scope", "inc", "levels", "lev", "bit", "type", "layer", "loop", "weight", "depth", "pattern", "vel"], "ret_fr": ["Ret_fr", "x", "ctr", "retregtr", "ret24br", "retregfr", "retregwrite", "ret_tr", " ret_pr", "Ret_br", "_", "retregdr", "ret24fr", "ret_pull", " ret_frac", "r", "Ret_write", "ret_dr", "this", "ret24pull", "Ret_pull", "g", " ret_dr", "d", "ret_write", "ret_frac", "ret_pr", "Ret_tr", "ret_cache", " ret_tr", "Ret_dr", " ret_cache", "write", "ret_br"], "access_flags": ["access___rights", "access_rules", "access_limits", " access_mask", "accessalflags", "accessslimits", "access___count", " access_bits", "access_parts", "access_mask", "access_flag", " access_rules", "accesssflags", "accessalmask", "access___flags", "access_rights", "access___bits", "accesssparts", " access_count", " access_flag", " access_parts", "accesssmask", "accessallimits", " access_limits", "access_bits", "accessalparts", " access_rights", "access_count"], "iotlb_entry": ["iotb_ry", "iotlb_post", "iotbl_post", "iotlb_try", "iotbl__entry", "iotzb_see", "iotla_enter", "iotzb_entry", "iotlb00ent", "iotbl_entry", "iotlbappcell", "iotlab_inc", "iotlb_enter", "iotbl_import", "iotlbapppost", "iotlb_ry", "iotb_way", "iotb_element", "iotlab_enter", "iotlab_ent", "iotml_entry", "iotlb_id", "iotla_server", "iotlb_index", "iotbl__import", "iotlb_view", "iotlb__entry", "iotlb_reader", "iotlb_element", "iotlb00view", "iotml_reader", "iotlb_server", "iotbl__post", "iotlb_way", "iotlb_exit", "iotlb_see", "iotlab_try", "iotlb__post", "iotb_entry", "iotla_index", "iotlab_exit", "iotbl_cell", "iotzb_id", "iotlab_entry", "iotla_entry", "iotlb00enter", "iotlb_inc", "iotlb__cell", "iotlb_cell", "iotml_exit", "iotlbappentry", "iotlb__import", "iotlb00entry", "iotlb_import", "iotlb_ent", "iotbl__cell", "iotlbappimport", "iotlab_view"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tunsigned i;\n\n#ifdef HAVE_MMX\n\n\tlong mmx_size= 23 - src_size;\n\n\tasm volatile (\n\n\t\t\"test %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\"jns 2f\t\t\t\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24r)\", %%mm5\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24g)\", %%mm6\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24b)\", %%mm7\t\\n\\t\"\n\n\t\tASMALIGN(4)\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\tPREFETCH\" 32(%1, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq  2(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // R BGR BGR B\n\n\t\t\"psllq $16, %%mm0\t\t\\n\\t\" // 00 BGR BGR\n\n\t\t\"pand %%mm5, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq  6(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\tMOVNTQ\" %%mm1,   (%2, %%\"REG_a\")\\n\\t\" // RGB RGB RG\n\n\t\t\"movq  8(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // R BGR BGR B\n\n\t\t\"movq 10(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // GR BGR BGR\n\n\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq 14(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // R BGR BGR B\n\n\t\tMOVNTQ\" %%mm1,  8(%2, %%\"REG_a\")\\n\\t\" // B RGB RGB R\n\n\t\t\"movq 16(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // GR BGR BGR\n\n\t\t\"movq 18(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // BGR BGR BG\n\n\t\t\"pand %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\tMOVNTQ\" %%mm1, 16(%2, %%\"REG_a\")\\n\\t\"\n\n\t\t\"add $24, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t: \"+a\" (mmx_size)\n\n\t\t: \"r\" (src-mmx_size), \"r\"(dst-mmx_size)\n\n\t);\n\n\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n\n\n\tif(mmx_size==23) return; //finihsed, was multiple of 8\n\n\n\n\tsrc+= src_size;\n\n\tdst+= src_size;\n\n\tsrc_size= 23-mmx_size;\n\n\tsrc-= src_size;\n\n\tdst-= src_size;\n\n#endif\n\n\tfor(i=0; i<src_size; i+=3)\n\n\t{\n\n\t\tregister uint8_t x;\n\n\t\tx          = src[i + 2];\n\n\t\tdst[i + 1] = src[i + 1];\n\n\t\tdst[i + 2] = src[i + 0];\n\n\t\tdst[i + 0] = x;\n\n\t}\n\n}\n", "idx": 9761, "substitutes": {"src": ["seq", "img", "reflect", "tif", "proc", "source", "sel", "b", "sur", "RC", "rest", "send", "rect", "sci", "s", "config", "stream", "dest", "cb", "gb", "usr", "dist", "rb", "loc", "rs", "sq", "st", "sec", "share", "inst", "sub", "slice", "cv", "sync", "rc", "input", "sl", "r", "cur", "sup", "ctx", "ruby", "sort", "support", "desc", "sb", "spec", "reverse", "secure", "sys", "grad", "transform", "url", "gz", "comp", "rob", "sr", "uc", "ssl", "sc"], "dst": ["nrc", "ldr", "dsp", "lsrc", "lsts", "ldest", " ddr", "Dsts", "ssp", "ddr", "sdest", "lst", "adconst", "asm", "dST", " drc", "DST", "Ddest", " dconst", "all", "_", "nbl", "addr", " dST", "ddest", " dbl", "r", "sddest", "bytes", "ssts", "sst", " ddest", " dsc", "dbl", "Ddr", "g", " dsp", "nconst", "drc", "lsc", "num", "lST", "dconst", " dsts", "adrc", "Dconst", "dsts", "adst", "adsc", "dsrc", "sdconst", "sdsts", "pack", "sdst", "dsc", " dsrc", "lsp", "nst", "Dst", "adsrc", "adbl"], "src_size": ["src96size", "src_length", "src96value", "src__size", "src_sized", "rc_name", "sb96scale", "sb_cycle", " src_start", "src_name", " src_length", "src__strength", "source_speed", "src_strength", " src_scale", "src_start", "src_fee", "sb96size", "src96start", "source_scale", "sb_size", "rc_size", "src_center", "source_size", "sb96value", "src_cycle", "src_scale", "source_fee", "rc_strength", "sb_scale", "rc_scale", " src_sized", "src96address", "src_address", "sb96cycle", "src_value", "src96scale", "src__scale", "src96cycle", "source_center", "sb_value", " src_address", "src_speed"], "i": ["oi", "l", "ui", "di", "it", "start", "n", "g", "si", "in", "zi", "key", "source", "m", "id", "xi", "info", "b", "t", "z", "ini", "my", "d", "ami", "page", "c", "ji", "s", "p", "ix", "uri", "e", "mu", "cli", "eni", "f", "j", "ai", "multi", "index", "slice", "v", "gi", "mi", "phi", "name", "r", "inner", "qi", "pi", "bi", "ii", "bit", "init", "u", "type", "h", "I", "li", "api", "ci", "a", "ni", "io", "y", "ri", "fi", "iu", "anti"], "memory": ["mac", "session", "reference", "reflect", "media", "record", "m", "application", "gpu", "Memory", "mm", "mem", "vm", "texture", "reg", "array", "binary", "resource", "master", "program", "r", "address", "function", "storage", "asm", "java", "message", "medium", "math", "cache", "ram", "image", "M", "buffer"], "x": ["xf", "xp", "val", "xx", " xx", "m", "xi", "w", "id", "b", "z", "d", "c", "s", "X", "p", "ix", "e", "ux", "xs", "f", "v", "ic", "tx", "xc", "xt", "u", "h", "xe", "rx", "px", "y", "xb", "dx", "ex"]}}
{"project": "qemu", "commit_id": "b9f7c377df4f04e9119cb0e917438dd37ef34029", "target": 1, "func": "static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,\n\n                                           const void *pkt_data,\n\n                                           size_t pkt_len)\n\n{\n\n    struct virtio_net_hdr *vhdr;\n\n    bool isip4, isip6, istcp, isudp;\n\n    uint8_t *data;\n\n    int len;\n\n\n\n    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {\n\n        return;\n\n    }\n\n\n\n    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);\n\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n\n\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n\n        VMW_PKPRN(\"packet len:%d < csum_start(%d) + csum_offset(%d) + 2, \"\n\n                  \"cannot calculate checksum\",\n\n                  len, vhdr->csum_start, vhdr->csum_offset);\n\n        return;\n\n    }\n\n\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n\n    len = pkt_len - vhdr->csum_start;\n\n    /* Put the checksum obtained into the packet */\n\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n\n}\n", "idx": 573, "substitutes": {"pkt": ["bwk", "macket", "cpnt", " packet", "bnt", "wacket", " pct", "pnt", "Pnt", "fet", "felt", " pwk", "pet", " pet", "bkt", " pnt", "melt", "facket", "mkt", "cpkt", "belt", "fnt", "fwk", "pwk", "pelt", "mnt", "wkt", "cpacket", "cpet", "wnt", "fkt", "pct", "packet", "backet", "wct", "Pkt", "Pct", "Packet"], "pkt_data": ["pkt_dat", "pkt_start", "pkt2dat", "pkt2len", "pkt2data", "pkg_length", "pkg_len", "packet_dat", "packet_data", "packet_len", "pkt_length", "pkg_start", "pkg_data"], "pkt_len": ["packet2seq", "pkt2length", "pkt64len", "packet2Len", "packet2length", "pkt64length", "pkt2len", "pkt_en", "pkt64Len", "pkt_Len", "packet_Len", "pkt2seq", "pkt_size", "packet_en", "pet_Len", "pkt2Len", "pet_len", "packet_len", "packet2len", "packet_size", "packet_length", "pkt_seq", "pkt_length", "pet_data", "pet_length", "packet_seq", "pkt64seq"], "vhdr": ["vhmt", "vghDR", "evbhrec", "evbhdi", "vmhrd", "evhdr", "ghrdr", " vhDR", "vmhlder", "svhrdr", "viewhDR", "vhrdr", "vithdi", "vvdr", "vrhder", "vihstr", "vohmt", "viewhrgr", "vphhr", "vshder", "evbhdr", "vhder", "viewhrrt", "vohrec", "vahdr", "vrhDR", " vphdr", " vhhr", "svrhrr", "vhrstr", "vmhlrd", "vghdc", "ghrstr", "svhrr", "vadhder", "vhlbr", "ghrd", "vhhr", "vhdvd", "vmhder", "vhrgr", "vhgr", "vshhr", "vbhdr", "vhlrid", "vithmt", " vphDR", "vohdr", " vhder", "vrhdr", "vbhmt", "viewhder", "vhdgr", "vethDR", " vghDR", "vhrrd", "vvbr", "vhrec", "vbhrc", "vohdi", "vhrhr", "viewhvd", "vithrec", "viewhrdr", "vchder", "vhlvd", " vphhr", "vhrt", "vghrt", "svhdr", "viewhrder", "svhrbr", "svrhdr", "vhdc", "vhlder", " vhrid", "varchdr", "vchrid", "vhlgr", "svhDR", " vshDR", "svchrc", "ghdr", "vphld", "evhdi", "vhrid", "vahder", "vphDR", "svrhder", "vadhld", "vhrd", "vhladr", "vbhdc", "vghder", "vphrd", " vhld", "viewhdc", "vhrc", "svchrid", "vadhrd", "vehdr", "evhrec", "vshdr", "varchder", "vmhdr", "varchDR", "vhldr", "vadhstr", "svhadr", "vhrDR", "vehrr", "vhdi", "vghdr", "vethdr", "svrhDR", "vbhrid", " vghdr", "svhder", "vhlrd", "vhrdc", "vihrd", "svchdr", "vphdr", " vghder", "viewhrDR", "vhradr", "vhrrid", " vshdr", "vchdr", "vbhder", " vphder", "vhstr", "vhddr", "vhld", " vghrid", "evbhmt", "vadhdr", "viewhrdc", "varchhr", "viewhrvd", "vithdr", "vahDR", "vhostdr", "vbhDR", "vvrid", "vohrid", "ghrrd", "vihdr", "vmhldr", "vshDR", "vohDR", "vvadr", "vhrrt", "vadhrec", "vhrder", "ghder", "vhadr", "vhostrd", "viewhrt", "vhrvd", "vethhr", "vhrbr", "vshrr", "svhrc", "evhDR", "vihder", "vhDR", "vadhDR", "svhbr", "vohder", "svchder", "viewhgr", "vbhdi", "vphder", "vhdder", "ghrder", " vshhr", "vchrc", "vahrid", "vhrr", "svhrrid", "evhmt", "svhradr", "vrhrr", "vbhrec", "viewhdr", "evbhDR", "vohrc", "vghrid", "svhrid", "vhbr", "vhostder", "vbhrt", "ghstr", "vehder", "vehDR", "vhvd"], "isip4": ["isIP8", "isep2", "iip8", "isipfour", "isepfour", "isidfour", "isid2", "iep44", "iipfour", "isp44", "isip2", "isIP6", "isip8", "iepfour", "isp6", "isep6", " isid4", " isipfour", "issid4", "issip6", "isep4", "iip4", " isid6", "isp8", "issid44", "isid44", "issip8", "isid4", " isip2", "isIP4", "isep8", "ispfour", "iep4", " isid2", "iep8", "isid6", "issip4", "isp4", "isid8", "isp2", "isep44", "iip44", "issip44", "issid8", " isidfour", "issid6", "isip44", "isIP44"], "isip6": ["issepsix", "isp3", "isi16", " isid3", "isip3", "issep12", "isql16", "isepsix", "isip16", " isid8", "isid16", "isql46", "isi6", "isip8", "isip46", "isp6", "isep6", "issipsix", " isid16", " isid6", "isql12", "issip12", "isqlsix", "issip6", "isp16", "isp8", "isi46", "isep12", "issip8", "isid3", "isep8", " isip3", "issep6", "isip12", "isid6", "isaf6", "isaf3", " isip16", "isaf16", "isi8", "isaf8", "isisix", "isipsix", "isql6", "isid8", " isid46", "issep8", " isip8", "isi12", "isql8", "isid46", " isip46"], "istcp": ["istpp", "irstcp", "istpc", "xtip", "pectp", "stcp", "stpe", "istmp", "irstp", "xtcp", "istep", "istp", "irstpc", "astpc", "irstpp", "irstmp", "ismip", "xtep", "pectpp", "astp", "astpp", "xtmp", "astcp", "distcp", "istip", "stmp", "ismmp", "ismcp", "distip", "stp", "pectpc", "pectcp", "distmp", "irstpe", "istpe", "astpe", "ismep", "distep", "astmp"], "isudp": ["isadhp", "isugpt", "issoodp", "isudl", "publ", "pudcp", "asubps", "isudsps", "isubcp", "isudsm", "isodcp", "isoodc", "asudm", "issoodpe", "isubc", "isugpe", "isubp", "isoodpt", "isudb", "isudps", "isadhpt", "pubc", "pudc", "asubm", "isugp", "isadhc", "pudl", "isuffb", "isubps", "pubp", "asudps", "isugc", "isuffps", "asudp", "pubcp", "isudm", "isodl", "isodp", "isubb", "isuffm", "isadhpe", "issoodpt", "issudpt", "asubb", "isubl", "isubm", "isudsb", "isudsp", "asubp", "issudpe", "isoodpe", "isudc", "isoodp", "pudp", "isudcp", "issudc", "issudp", "isudpe", "issoodc", "isadhcp", "asudb", "isadhl", "isudpt", "isuffp", "isodc"], "data": ["base", "missing", "name", "ata", "buffer", "li", "da", "dd", "lp", "a", "image", "ui", "new", "d", "di", "ad", "aa", "field", "id", "parent", "buf", "ada", "batch", "i", "next", "in", "body", "style", "dt", "index", "raw", "pad", "result", "alpha", "p", "block", "start", "zero", "input", "length", "f", "size", "DATA", "padding", "bytes", "valid", "addr", "val", "dat", "Data", "response", " DATA"], "len": ["pl", "fun", "name", "li", "split", "lp", "ni", "Len", "n", "alt", "lf", "ln", "sl", "sp", "bin", "fn", "end", "span", "pre", "bl", "lim", "pos", "dy", "nt", "err", "str", "lon", "l", "ind", "fin", "length", "size", " length", "f", "la", "el", "en", "seq", "lit", "line", "gen", "val", "count", "lo", "limit", "ann", "dat", "part", "db", "mem"]}}
{"project": "qemu", "commit_id": "3db3659bf60094657e1465cc809acb09551816ee", "target": 0, "func": "static void apic_update_irq(APICCommonState *s)\n\n{\n\n    if (!(s->spurious_vec & APIC_SV_ENABLE)) {\n\n        return;\n\n    }\n\n    if (apic_irq_pending(s) > 0) {\n\n        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);\n\n    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&\n\n               pic_get_output(isa_pic)) {\n\n        apic_deliver_pic_intr(&s->busdev.qdev, 1);\n\n    }\n\n}\n", "idx": 22201, "substitutes": {"s": ["status", "i", "sb", "e", "sym", "es", "sie", "fs", "g", "ses", "xs", "sis", "sets", "ops", "site", "ds", "services", "f", "sys", "t", "m", "args", "storage", "state", "ssl", "os", "p", "cs", "ts", "o", "sync", "is", "stats", "sa", "sg", "c", "js", "submit", "spec", "self", "settings", "sq", "si", "b", "service", "aws", "n", "S", "ns", "session", "side", "sf", "south", "rs", "gs", "ps", "http", "conf", "su", "ss", "states"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void bamboo_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 };\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *isa = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    PCIBus *pcibus;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    uint64_t elf_entry;\n\n    uint64_t elf_lowaddr;\n\n    hwaddr loadaddr = 0;\n\n    target_long initrd_size = 0;\n\n    DeviceState *dev;\n\n    int success;\n\n    int i;\n\n\n\n    /* Setup CPU. */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = \"440EP\";\n\n    }\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    if (env->mmu_model != POWERPC_MMU_BOOKE) {\n\n        fprintf(stderr, \"MMU model %i not supported by this machine.\\n\",\n\n            env->mmu_model);\n\n        exit(1);\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n    ppc_booke_timers_init(cpu, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                   ram_memories,\n\n                                   ram_bases, ram_sizes,\n\n                                   ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, 1);\n\n\n\n    /* PCI */\n\n    dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE,\n\n                                PPC440EP_PCI_CONFIG,\n\n                                pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]],\n\n                                pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]],\n\n                                NULL);\n\n    pcibus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pcibus) {\n\n        fprintf(stderr, \"couldn't create PCI controller!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_alias(isa, NULL, \"isa_mmio\",\n\n                             get_system_io(), 0, PPC440EP_PCI_IOLEN);\n\n    memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (pcibus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            /* There are no PCI NICs on the Bamboo board, but there are\n\n             * PCI slots, so we can pick whatever default model we want. */\n\n            pci_nic_init_nofail(&nd_table[i], pcibus, \"e1000\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (kernel_filename) {\n\n        success = load_uimage(kernel_filename, &entry, &loadaddr, NULL,\n\n                              NULL, NULL);\n\n        if (success < 0) {\n\n            success = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE,\n\n                               0, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        /* XXX try again as binary */\n\n        if (success < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (initrd_filename) {\n\n        initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,\n\n                                          ram_size - RAMDISK_ADDR);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load ram disk '%s' at %x\\n\",\n\n                    initrd_filename, RAMDISK_ADDR);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* If we're loading a kernel directly, we must load the device tree too. */\n\n    if (kernel_filename) {\n\n        if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,\n\n                                    initrd_size, kernel_cmdline) < 0) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n}\n", "idx": 6385, "substitutes": {"machine": ["game", "base", "mobile", "program", "plugin", "host", "vm", "note", "device", "component", "session", "config", "bug", "environment", "object", "data", "database", "template", "module", "info", "m", "image", "normal", "profile", "mac", "project", "state", "server", "linux", "space", "service", "part", "interface", "cell", "connection", "comment", "message", "storage", "instance", "Machine", "kernel", "process", "controller", "source", "computer", "mom", "processor", "boot", "node", "proc", "slave", "model", "core", "engine", "cache", "loader", "manager", "mode", "hard"], "kernel_filename": ["kernel2prefix", "system_directory", "kernel_software", "system_prefix", "kernel_description", "kernel2location", "kernellogfilename", "kernellogsoftware", "system_software", "system_filename", "kernel_directory", "system_location", "kernel_location", "system_description", "kernellogdescription", "kernel_username", "kernel2username", "kernel_prefix", "kernellogdirectory", "system_username", "kernel2filename"], "kernel_cmdline": ["kernel__cmdle", "kernel_commandle", "kernel_hostline", "kernel__cmdlines", "kernel__hostle", "kernel__cmdname", "kernel_deflines", "kernel_hostlines", "kernel_defline", "kernel__cmdline", "kernel_mdlines", "kernel_cmdl", "kernel_cmdle", "kernel_hostname", "kernel_commandname", "kernel_mdline", "kernel_defl", "kernel_hostl", "kernel_cmdname", "kernel_mdname", "kernel__hostname", "kernel_commandl", "kernel_mdle", "kernel_commandlines", "kernel_cmdlines", "kernel__hostlines", "kernel_commandline", "kernel_hostle", "kernel__hostline"], "initrd_filename": ["initrd_initial", "initrdsfile", "initrn_filename", "initrt_bytes", "initrt_filename", "initrdsprefix", "initrd_bytes", "initrd_url", "initrd_file", "initrt_Filename", "initrd_Filename", "initrdsurl", "initrn_file", "initrn_url", "initrd_prefix", "initrn_prefix", "initrt_initial", "initrdsfilename"], "pci_irq_nrs": ["pci_irq_crd", "pci_irq_codes", "pci_irq_numrs", "pci_irq_Nros", "pci_irq_nodes", "pci_irq_nrd", "pci_irq_numrd", "pci_irq_numodes", "pci_irq_Nrs", "pci_irq_Nrd", "pci_irq_nros", "pci_irq_cros", "pci_irq_numros", "pci_irq_Nodes", "pci_irq_crs"], "address_space_mem": ["address_area_memory", "address_space_memory", "address_area_mem", "address_space_ram", "address_area_lim", "address_area_ram", "address_space_lim"], "isa": ["irc", "asu", "pai", "ISA", "iam", "va", "imi", "aa", "xi", "cca", "ani", "asi", "cci", "aci", "ai", "ami", "esa", "agi", "ini", "ina", "ang", "mini", "eni", "acs", "oci", "adr", "anti", "fi", "isc"], "ram_memories": ["ram_temores", "ram_amory", "ram_temages", "ram_messages", "ram_messories", "ram_matores", "ram_memores", "ram_mources", "ram_amources", "ram_mories", "ram_matages", "ram_memages", "ram_temories", "ram_matories", "ram_mions", "ram_matources", "ram_memions", "ram_messores", "ram_mators", "ram_memors", "ram_amions", "ram_matory", "ram_mations", "ram_memory", "ram_amories", "ram_memources", "ram_mory", "ram_temors", "ram_messors"], "ram_bases": ["ram_vase", "ram_base", "ram_vias", "ram_brases", "ram_lases", "ram_vuses", "ram_buses", "ram_lias", "ram_bruses", "ram_luses", "ram_brias", "ram_bias", "ram_vases", "ram_lase", "ram_brase"], "ram_sizes": ["ram_setsizes", "ram_ciz", "ram_offsizes", "ram_sides", "ram_setsists", "ram_offsists", "ram_cizes", "ram_setsiz", "ram_offsiz", "ram_siz", "ram_setsides", "ram_sists", "ram_cists", "ram_offsides", "ram_cides"], "pic": ["oc", "pid", "anc", "ig", "bin", "mic", "pin", "quad", "xi", "sync", "module", "pins", "mac", "pc", "py", "cc", "mc", "nic", "lib", "bc", "mi", "agi", "ic", "mini", "doc", "proc", "lc", "fc", "fi"], "irqs": ["rinqs", "mirqs", "IRqs", "IRqa", "rincs", "mirq", "irks", "IRcks", " irques", "IRques", "mirques", "irq", "mirks", "mircs", "iraks", "ircks", " irqa", "IRq", "IRks", "rincks", " ircs", "iraq", "ircs", "iraqs", "IRcs", "iracs", "rinq", "irqa", "irques", " ircks", "mirqa", " irq"], "pcibus": ["puus", "pdopus", "pcubis", "puubis", "incibus", "pdubis", "pdibus", "pdus", "incubis", "puibus", "incopus", "incus", "pcopus", "pcus", "puopus"], "cpu": ["cp", "hp", "gp", "bench", "pid", "hw", "gc", "cmp", "cfg", "lb", "chip", "mem", "platform", "pu", "vm", "gru", "consumer", "nc", " CPU", "gpu", "queue", "px", "chu", "pc", "linux", "net", "np", "nic", "que", "clock", "proxy", "instance", "ctx", "kernel", "jp", "process", "pool", "ne", "computer", "processor", "boot", "runner", "eni", "none", "console", "proc", "node", "GPU", "cn", "core", "ilo", "performance", "lc", "cache", "cow", "loader", "CPU", "uno", "conn"], "env": ["energy", "el", "environment", "password", "object", "queue", "gui", "state", "conf", "ev", "zone", "err", "exec", "equ", "Environment", "enh", "theme", "ec", "engine", "conn", "extra", "vm", "config", "eu", "server", "ne", "viron", "cookie", "site", " environment", "end", "eng", "device", "vel", "exc", "image", "agent", "db", "profile", "export", "ext", "exe", "net", "np", "e", "que", "en", "network", "global", "shell", "dep", "core", "api", "cache", "loader", "ea", "v", "scope", "session", "enc", "de", "attr", "args", "priv", "devices", "context", "opt", "eni", "console", "agents", "skin", "manager", "cdn"], "elf_entry": ["elf__entry", "elf__mac", "elope_cmp", "elope_port", "elf___cmp", "elf___entry", "elf___mac", "elf_port", "elf_cmp", "elope_mac", "elf_mac", "elf__cmp", "elf__port", "elf___port", "elope_entry"], "elf_lowaddr": ["elf_oldaddress", "elf_lowattr", "elf_loadaddr", "elf_highaddress", "elf_highaddr", "elf_highattr", "elf_oldAddress", "elf_loadAddress", "elf_oldaddr", "elf_loadaddress", "elf_lowAddress", "elf_lowaddress", "elf_highAddress", "elf_oldattr", "elf_loadattr"], "dev": ["mem", "Dev", "device", "data", "debug", "bus", "de", "conf", "ev", "DEV", "priv", "error", "disk", "exec", "serial", "boot", "iv", "pos", "ver", "node", "proc", "slave", "ip", "user", "cache", "app", "loader", "conn"], "success": [" ret", "ea", " pri", " test", " succ", "device", "va", " e", " res", " cores", " code", " rc", " unit", "code", "error", " error", "err", " j", " h", " num", " d", " status", " result", " vi", " r", " b"], "i": ["id", "I", "s", "ci", "ni", "b", "xi", "io", "si", "info", "num", "pi", "d", "ii", "j", "cli", "init", "e", "n", "p", "start", "line", "c", "ip", "type", "mode", "ui"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void test_qemu_strtosz_metric(void)\n\n{\n\n    const char *str = \"12345k\";\n\n    char *endptr = NULL;\n\n    int64_t res;\n\n\n\n    res = qemu_strtosz_metric(str, &endptr);\n\n    g_assert_cmpint(res, ==, 12345000);\n\n    g_assert(endptr == str + 6);\n\n}\n", "idx": 23247, "substitutes": {"str": ["lc", "expr", "ix", "Str", "start", "obj", "err", "text", "ctr", "tr", "wr", "temp", "css", "cur", "exec", "r", "arr", "cs", "frac", "enc", "last", "code", "inner", "dr", "pr", "spec", "fr", "sc", "ocr", "sr", "hr", "ptr", "seq", "cr", "inst", "gr", "len", "br", "iter", "rs", "stri", "st", "sec", "empty", "wrap", "STR"], "endptr": ["startPtr", "endpointers", "ndpt", "endedptr", "adptr", "endPtr", "endpt", "endpointer", " endpointers", "startptr", "ndptr", "startaddr", " endaddr", "endaddr", "endedPtr", "Endpointers", "adpointer", "adaddr", "EndPtr", "ndpointer", " endpt", "endedpointer", "endedpointers", " endpointer", "startpt", "startpointer", "adPtr", "Endpointer", "Endptr", " endPtr"], "res": ["reg", "ras", "obj", "err", "rows", "result", "ress", "RES", "_", "rap", "rx", "rr", "bytes", "css", "results", "rez", "pre", "ris", "r", "s", "args", "os", "ret", "Res", "cs", "vals", "arr", "rh", "reed", "rc", "out", "js", "resh", "bits", "des", "pres", "ms", "ics", "rev", "re", "cr", "gr", "R", "rss", "req", "ps", "rs", "resolution", "resp"]}}
{"project": "qemu", "commit_id": "02acedf93da420713a0c4bbeaf32ce9d734a4332", "target": 0, "func": "static void gen_neon_unzip(int reg, int q, int tmp, int size)\n\n{\n\n    int n;\n\n    TCGv t0, t1;\n\n\n\n    for (n = 0; n < q + 1; n += 2) {\n\n        t0 = neon_load_reg(reg, n);\n\n        t1 = neon_load_reg(reg, n + 1);\n\n        switch (size) {\n\n        case 0: gen_neon_unzip_u8(t0, t1); break;\n\n        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */\n\n        case 2: /* no-op */; break;\n\n        default: abort();\n\n        }\n\n        neon_store_scratch(tmp + n, t0);\n\n        neon_store_scratch(tmp + n + 1, t1);\n\n    }\n\n}\n", "idx": 16735, "substitutes": {"reg": ["m", "pattern", "bin", "mod", "data", "Reg", "rc", "r", "debug", "num", "g", "region", "loc", "orig", "greg", "rg", "ind", "mem", "min", "tag", "arr", "xp", "rec", "re", "gr", "pre", "memory", "rar", "ru", "config", "map", "req", "c", "p", "cache", "REG", "rem", "np", "order", "dist", "round"], "q": ["quant", "ch", "t", "x", "f", "eq", "qi", "g", "query", "i", "z", "Q", "count", "o", "qu", "iq", "w", "queue", "qs", "k", "qt", "v", "c", "req", "qq", "qa", "p", "depth", "h", "sq", "order", "u"], "tmp": ["sup", "txt", "offset", "fp", "obj", "sample", "ctr", "buffer", "rc", "num", "i", "cb", "app", "cp", "loc", "ctx", "pb", "mini", "bb", "mem", "nb", "zip", "tab", "nm", "array", "nr", "pre", "xt", "img", "config", "mb", "tc", "prefix", "buff", "buf", "comb", "temp", "c", "sam", "rb", "crop", "p", "test", "mp", "pad", "cache", "cmp", "prep", "storage", "proc", "beta", "mm", "np", "now"], "size": ["gn", "scale", "j", "ch", "shape", "small", "code", "mode", "x", "core", "SIZE", "rc", "ne", "num", "i", "z", "loc", "sec", "en", "enc", "sh", "use", "sn", "ize", "k", "e", "sync", "c", "p", "shift", "form", "cn", "Size", "sq", "len"], "n": ["ns", "na", "m", "dn", "j", "un", "t", "inn", "x", "f", "name", "pn", "net", "nt", "r", "ne", "num", "mn", "N", "g", "i", "z", "ny", "nb", "min", "en", "nat", "o", "l", "d", "nr", "nc", "no", "sn", "w", "nu", "rn", "k", "e", "network", "v", "one", "c", "ni", "nw", "p", "none", "b", "fn", "cn", "len", "nn", "np", "an", "y", "conn", "u"], "t0": [" t100", "Tk", " tee", " tk", " t8", "T2", "T100", "T0", "p0", "p2", "pt00", "pt0", "t100", "t2", "ty1", "tt0", "pt2", " t2", "T00", "Tee", "t00", "ttk", "T50", "p50", "ttee", "T8", "t50", "tee", "p00", "pt1", "T1", "tt1", "ty0", "tk", " t50", "ty50", "p1", "p100", "ty8", "t8"], "t1": ["t5", "p4", "taOne", "T2", " t4", "T0", "p0", "p2", "t2", " tOne", "t7", "t4", "pone", "at1", "Tb", " t2", "pb", " t7", "tOne", "Tone", "ta0", "T5", "at5", "tb", " t5", "at2", "ta7", " tone", "atone", "TOne", " tb", "T1", "ta1", "tone", "T4", "T7", "p1"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n", "idx": 26642, "substitutes": {"s": ["S", "comments", "rs", "ses", "sys", "args", "w", "ss", "m", "b", "c", "ns", "i", "d", "se", "ts", "data", "sq", "ds", "ps", "sg", "ins", "ks", "sync", "bs", "is", "e", "cs", "gs", "es", "o", "sets", "ions", "l", "si", "sym", "gets", "aws", "os", "new", "uns", "services", "as", "h", "ls", "f", "service", "js", "qs", "fs", "tests", "t", "a", "n", "v", "r", "sf", "ops", "in", "ssl", "sv", "g"], "p": ["temp", "pp", "pa", "k", "np", "i", "b", "m", "c", "d", "data", "P", "pointer", "jp", "pe", "ps", "bp", "op", "u", "e", "point", "sp", "o", "pb", "at", "cp", "part", "lp", "f", "po", "pr", "n", "tp", "j", "t", "fp", "ip", "a", "v", "pi", "vp", "l", "post", "pc", "ap", "g"]}}
{"project": "FFmpeg", "commit_id": "62c3c8ca78ee2da7dc20c2d6371866266c82966d", "target": 1, "func": "int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port,\n\n                              int lower_transport, const char *real_challenge)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int rtx = 0, j, i, err, interleave = 0, port_off;\n\n    RTSPStream *rtsp_st;\n\n    RTSPMessageHeader reply1, *reply = &reply1;\n\n    char cmd[2048];\n\n    const char *trans_pref;\n\n\n\n    if (rt->transport == RTSP_TRANSPORT_RDT)\n\n        trans_pref = \"x-pn-tng\";\n\n    else\n\n        trans_pref = \"RTP/AVP\";\n\n\n\n    /* default timeout: 1 minute */\n\n    rt->timeout = 60;\n\n\n\n    /* for each stream, make the setup request */\n\n    /* XXX: we assume the same server is used for the control of each\n\n     * RTSP stream */\n\n\n\n    /* Choose a random starting offset within the first half of the\n\n     * port range, to allow for a number of ports to try even if the offset\n\n     * happens to be at the end of the random range. */\n\n    port_off = av_get_random_seed() % ((rt->rtp_port_max - rt->rtp_port_min)/2);\n\n    /* even random offset */\n\n    port_off -= port_off & 0x01;\n\n\n\n    for (j = rt->rtp_port_min + port_off, i = 0; i < rt->nb_rtsp_streams; ++i) {\n\n        char transport[2048];\n\n\n\n        /*\n\n         * WMS serves all UDP data over a single connection, the RTX, which\n\n         * isn't necessarily the first in the SDP but has to be the first\n\n         * to be set up, else the second/third SETUP will fail with a 461.\n\n         */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP &&\n\n             rt->server_type == RTSP_SERVER_WMS) {\n\n            if (i == 0) {\n\n                /* rtx first */\n\n                for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {\n\n                    int len = strlen(rt->rtsp_streams[rtx]->control_url);\n\n                    if (len >= 4 &&\n\n                        !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,\n\n                                \"/rtx\"))\n\n                        break;\n\n                }\n\n                if (rtx == rt->nb_rtsp_streams)\n\n                    return -1; /* no RTX found */\n\n                rtsp_st = rt->rtsp_streams[rtx];\n\n            } else\n\n                rtsp_st = rt->rtsp_streams[i > rtx ? i : i - 1];\n\n        } else\n\n            rtsp_st = rt->rtsp_streams[i];\n\n\n\n        /* RTP/UDP */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP) {\n\n            char buf[256];\n\n\n\n            if (rt->server_type == RTSP_SERVER_WMS && i > 1) {\n\n                port = reply->transports[0].client_port_min;\n\n                goto have_port;\n\n            }\n\n\n\n            /* first try in specified port range */\n\n            while (j <= rt->rtp_port_max) {\n\n                ff_url_join(buf, sizeof(buf), \"rtp\", NULL, host, -1,\n\n                            \"?localport=%d\", j);\n\n                /* we will use two ports per rtp stream (rtp and rtcp) */\n\n                j += 2;\n\n                if (!ffurl_open(&rtsp_st->rtp_handle, buf, AVIO_FLAG_READ_WRITE,\n\n                               &s->interrupt_callback, NULL))\n\n                    goto rtp_opened;\n\n            }\n\n\n\n            av_log(s, AV_LOG_ERROR, \"Unable to open an input RTP port\\n\");\n\n            err = AVERROR(EIO);\n\n            goto fail;\n\n\n\n        rtp_opened:\n\n            port = ff_rtp_get_local_rtp_port(rtsp_st->rtp_handle);\n\n        have_port:\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;\", trans_pref);\n\n            if (rt->server_type != RTSP_SERVER_REAL)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                     \"client_port=%d\", port);\n\n            if (rt->transport == RTSP_TRANSPORT_RTP &&\n\n                !(rt->server_type == RTSP_SERVER_WMS && i > 0))\n\n                av_strlcatf(transport, sizeof(transport), \"-%d\", port + 1);\n\n        }\n\n\n\n        /* RTP/TCP */\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n            /* For WMS streams, the application streams are only used for\n\n             * UDP. When trying to set it up for TCP streams, the server\n\n             * will return an error. Therefore, we skip those streams. */\n\n            if (rt->server_type == RTSP_SERVER_WMS &&\n\n                (rtsp_st->stream_index < 0 ||\n\n                 s->streams[rtsp_st->stream_index]->codec->codec_type ==\n\n                    AVMEDIA_TYPE_DATA))\n\n                continue;\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/TCP;\", trans_pref);\n\n            if (rt->transport != RTSP_TRANSPORT_RDT)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                        \"interleaved=%d-%d\",\n\n                        interleave, interleave + 1);\n\n            interleave += 2;\n\n        }\n\n\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_UDP_MULTICAST) {\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;multicast\", trans_pref);\n\n        }\n\n        if (s->oformat) {\n\n            av_strlcat(transport, \";mode=receive\", sizeof(transport));\n\n        } else if (rt->server_type == RTSP_SERVER_REAL ||\n\n                   rt->server_type == RTSP_SERVER_WMS)\n\n            av_strlcat(transport, \";mode=play\", sizeof(transport));\n\n        snprintf(cmd, sizeof(cmd),\n\n                 \"Transport: %s\\r\\n\",\n\n                 transport);\n\n        if (rt->accept_dynamic_rate)\n\n            av_strlcat(cmd, \"x-Dynamic-Rate: 0\\r\\n\", sizeof(cmd));\n\n        if (i == 0 && rt->server_type == RTSP_SERVER_REAL && CONFIG_RTPDEC) {\n\n            char real_res[41], real_csum[9];\n\n            ff_rdt_calc_response_and_checksum(real_res, real_csum,\n\n                                              real_challenge);\n\n            av_strlcatf(cmd, sizeof(cmd),\n\n                        \"If-Match: %s\\r\\n\"\n\n                        \"RealChallenge2: %s, sd=%s\\r\\n\",\n\n                        rt->session_id, real_res, real_csum);\n\n        }\n\n        ff_rtsp_send_cmd(s, \"SETUP\", rtsp_st->control_url, cmd, reply, NULL);\n\n        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {\n\n            err = 1;\n\n            goto fail;\n\n        } else if (reply->status_code != RTSP_STATUS_OK ||\n\n                   reply->nb_transports != 1) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        /* XXX: same protocol for all streams is required */\n\n        if (i > 0) {\n\n            if (reply->transports[0].lower_transport != rt->lower_transport ||\n\n                reply->transports[0].transport != rt->transport) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n        } else {\n\n            rt->lower_transport = reply->transports[0].lower_transport;\n\n            rt->transport = reply->transports[0].transport;\n\n        }\n\n\n\n        /* Fail if the server responded with another lower transport mode\n\n         * than what we requested. */\n\n        if (reply->transports[0].lower_transport != lower_transport) {\n\n            av_log(s, AV_LOG_ERROR, \"Nonmatching transport in server reply\\n\");\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        switch(reply->transports[0].lower_transport) {\n\n        case RTSP_LOWER_TRANSPORT_TCP:\n\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n\n            break;\n\n\n\n        case RTSP_LOWER_TRANSPORT_UDP: {\n\n            char url[1024], options[30] = \"\";\n\n\n\n            if (rt->rtsp_flags & RTSP_FLAG_FILTER_SRC)\n\n                av_strlcpy(options, \"?connect=1\", sizeof(options));\n\n            /* Use source address if specified */\n\n            if (reply->transports[0].source[0]) {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL,\n\n                            reply->transports[0].source,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            } else {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL, host,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            }\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) &&\n\n                ff_rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            /* Try to initialize the connection state in a\n\n             * potential NAT router by sending dummy packets.\n\n             * RTP/RTCP dummy packets are used for RDT, too.\n\n             */\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) && s->iformat &&\n\n                CONFIG_RTPDEC)\n\n                ff_rtp_send_punch_packets(rtsp_st->rtp_handle);\n\n            break;\n\n        }\n\n        case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: {\n\n            char url[1024], namebuf[50], optbuf[20] = \"\";\n\n            struct sockaddr_storage addr;\n\n            int port, ttl;\n\n\n\n            if (reply->transports[0].destination.ss_family) {\n\n                addr      = reply->transports[0].destination;\n\n                port      = reply->transports[0].port_min;\n\n                ttl       = reply->transports[0].ttl;\n\n            } else {\n\n                addr      = rtsp_st->sdp_ip;\n\n                port      = rtsp_st->sdp_port;\n\n                ttl       = rtsp_st->sdp_ttl;\n\n            }\n\n            if (ttl > 0)\n\n                snprintf(optbuf, sizeof(optbuf), \"?ttl=%d\", ttl);\n\n            getnameinfo((struct sockaddr*) &addr, sizeof(addr),\n\n                        namebuf, sizeof(namebuf), NULL, 0, NI_NUMERICHOST);\n\n            ff_url_join(url, sizeof(url), \"rtp\", NULL, namebuf,\n\n                        port, \"%s\", optbuf);\n\n            if (ffurl_open(&rtsp_st->rtp_handle, url, AVIO_FLAG_READ_WRITE,\n\n                           &s->interrupt_callback, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            break;\n\n        }\n\n        }\n\n\n\n        if ((err = rtsp_open_transport_ctx(s, rtsp_st)))\n\n            goto fail;\n\n    }\n\n\n\n    if (reply->timeout > 0)\n\n        rt->timeout = reply->timeout;\n\n\n\n    if (rt->server_type == RTSP_SERVER_REAL)\n\n        rt->need_subscription = 1;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    ff_rtsp_undo_setup(s);\n\n    return err;\n\n}\n", "idx": 17766, "substitutes": {"s": ["ns", "spec", "ts", "sg", "sit", "t", "rs", "sv", "services", "service", "sb", "sl", "ss", "ls", "sec", "fs", "cs", "su", "acs", "sed", "ssl", "ses", "private", "c", "sam", "si", "S", "sci", "ks", "gs", "sys", "storage", "os", "server", "se", "sq", "sa", "ds", "sf"], "host": ["uri", "component", "proxy", "service", "auth", "method", "node", "localhost", "nick", "username", "ip", "link", "header", "path", "socket", "prefix", "remote", "ssl", "address", "test", "http", "domain", "Host", "server", "mac", "conn"], "port": ["uri", "plugin", "point", "code", "ort", "pod", "ports", "file", "hop", "channel", "stream", "type", "method", "cp", "ip", "profile", "path", "PORT", "pipe", "phone", "p", "address", "Port", "route", "message", "server"], "lower_transport": ["lower_transports", "lower_transpt", "lower_streampt", "lower_ranspt", "lower_transsource", "lower_ransource", "lower_ransp", "lower_transort", "lower_transrule", "lower_ranrule", "lower_transpace", "lower_ransort", "lower_userrule", "lower_hostports", "lower_mailort", "lower_usersource", "lower_streampace", "lower_middlePort", "lower_transPort", "lower_streamort", "lower_mailport", "lower_middleports", "lower_streamport", "lower_ranport", "lower_ranspace", "lower_userp", "lower_ransPort", "lower_mailpace", "lower_ranssource", "lower_transp", "lower_hostport", "lower_middlefile", "lower_ransfile", "lower_ransrule", "lower_hostfile", "lower_middleport", "lower_mailpt", "lower_hostPort", "lower_ransport", "lower_ransports", "lower_transfile", "lower_userport", "lower_ranp"], "real_challenge": ["real_dupe", "real_duplay", "real_challplay", "realparentchallpe", "real_openplay", "real_challonge", "real_protonge", "realparentopenplay", "real_protenge", "real_challpe", "realparentopenpe", "realparentopenenge", "real_protpe", "real_duenge", "real_duonge", "real_openonge", "real_openpe", "real_openenge", "realparentchallplay", "real_protplay", "realparentchallenge", "realparentopenonge", "realparentchallonge"], "rt": ["rx", "grad", "RT", "rr", "tt", "ret", "txt", "fr", "nd", "tr", "rs", "vr", "t", "NT", "ot", "ort", "ct", "gd", "rc", "r", "nt", "sett", "hd", "mot", "rh", "ut", "dt", "bt", "rf", "irt", "rat", "art", "att", "rd", "ott", "ht", "feat", "tx", "urt", "ru", "rn", "rot", "sr", "dr", "qt", "ant", "yt", "apt", "rl", "rb", "kt", "vt", "gt", "od", "dat", "adr", "error", "boot", "rect", "mt", "ft", "tp", "tm", "pt"], "j": ["jc", "m", "jl", "ji", "t", "x", "jp", "jit", "f", "uj", "qi", "r", "adj", "n", "jj", "job", "g", "z", "ii", "ij", "jet", "index", "ind", "aj", "dj", "o", "l", "d", "w", "J", "k", "q", "v", "si", "p", "xi", "b", "h", "ja", "y", "li"], "i": ["ti", "gi", "uri", "m", "bi", "ei", "ji", "x", "f", "jit", "ini", "qi", "r", "ai", "mi", "n", "io", "phi", "hi", "z", "ii", "ie", "ori", "iu", "index", "di", "ij", "I", "zi", "o", "ip", "l", "d", "yi", "pi", "uni", "ui", "ci", "id", "e", "v", "cli", "ni", "c", "si", "ki", "ri", "p", "xi", "b", "api", "it", "eni", "fi", "y", "li", "u"], "err": ["status", "fr", "rr", "init", "ini", "ai", "result", "str", "ie", "ind", "ry", "resp", "out", "nil", "go", "aa", "aaa", "dr", "e", "req", "next", "error", "er", "server", "y"], "port_off": ["portenoa", "port___off", "port_data", "port67left", "key67left", "key_length", "port_pos", "port___max", "port_id", "port67name", "port_oa", "port2diff", "key_left", "key_and", "portfleft", "port67and", "port_Off", "key67off", "port64off", "port_length", "post_offset", "portenoff", "port_offset", "portenlength", "port6pos", "port67id", "portendata", "port67length", "port64name", "ort_max", "portflength", " port_id", "port___on", "portaldata", "portenand", "port_name", "ort_on", " port_data", "port6off", "portaloa", "ort_off", "post_pos", "portfoff", "key_off", "port_max", "port2off", "port_diff", "key67length", "port6offset", "portaloff", "portfand", "port___Off", "port2pos", "port64id", "portenleft", "port_and", " port_oa", "key67and", "ort_Off", "port6diff", "port67off", " port_name", "port_on", "post_off", "post_diff", "port_left", "port2offset"], "rtsp_st": ["rtsnp_ST", "rtspec_stream", "rtsp_sl", "rtsnp_sl", "rtsnp_stream", "rtsper_st", "rtsp_se", "rtsnp_se", "rtspec_est", "rtsnp_st", "rtsp_sts", "rtsper_sts", "rtsnp_str", "rtsp__se", "rtsp__str", "rtspec_stim", "rtsp_const", "rtsp_ST", "rtsp_stream", "rtsp_est", "rtsp__stream", "rtsper_const", "rtsp_stack", "rtspec_st", "rtsp__st", "rtsp_stim", "rtsper_stack", "rtsp_str"], "reply1": ["response2", "response1", "Reply2", "next0", "Reply1", " reply0", "response3", " reply2", "next1", "answer3", " reply3", "answer1", "Reply0", "reply2", "answer2", "next2", "reply3", "reply0"], "reply": ["entry", "code", "comment", "respond", "proxy", "result", "pack", "match", "msg", "resp", "ack", "flash", "link", "answer", "prefix", "response", "send", "respons", "address", " replies", "next", "route", "write", "connection", "frame", "reason", "Reply", "transfer"], "cmd": ["bin", "mode", " mac", " req", "rc", "comm", "root", "auth", "loc", "msg", "ctx", "bid", " auth", "Cmd", "box", "config", "buff", "batch", "req", "unit", "seq", "cap", "alloc", "opt", " command", "proc", "mac", "command"], "trans_pref": ["trans_perfor", "trans_rec", "trans_preef", "trans_Pref", "trans_Prec", "trans_ref", "trans_reef", "trans_perf", "trans_profor", "trans_foreef", "trans_prof", "trans_perfer", "trans_prefs", "trans_Prefs", "trans_forefer", "trans_brefs", "trans_profer", "trans_Prefer", "trans_proc", "trans_prefor", "trans_perc", "trans_prec", "trans_bref", "trans_brefer", "trans_prefer", "trans_brec", "trans_forec", "trans_forefor", "trans_peref", "trans_foref", "trans_perfs", "trans_refer"], "transport": ["ranstext", "Transtext", "Transp", "ransporter", "transporter", "interporter", " transform", "interports", "Transform", "transort", " transp", "ransports", "ransp", "Transport", "teleports", "teleport", "transtext", "interort", "teleporter", "teleort", "transp", "ransport", "transports", " transtext", "transform", "ransort", "interport", "ransform"], "rtx": ["retxp", "RTfx", "ttX", "retex", "rdX", "rotX", "rtz", "rotx", "rtex", "ntxs", "rtxp", "rtX", "retX", "rcxp", "rtxa", "ttz", "rotwy", "qtxes", "rotxb", "dtX", "ntxc", "aptX", "ortxs", "ttxb", "rtc", "rtwx", "ntX", "rtwy", "gtx", "ntz", "retx", "rrxc", "RTwy", "rdc", "drfx", "rtix", "vrX", "rtxs", "ttwy", "ttxs", "RTwx", "retxc", "rrwork", "RTxes", "retc", "rtxc", "dtx", "RTfe", "vrfx", "ttx", "drxc", "RTwork", "retxa", "ytex", "aptfe", "gtxy", "drx", "qtx", "rrx", "rdxc", "rcxa", "rcix", "retix", "rdx", "ytxc", "RTxc", "rtxes", "dtxy", "rcfx", "rotix", "rtxb", "dtv", "retfx", "ytx", "rtfx", "aptx", "ntx", "RTc", "aptxes", "ntwork", "RTv", "rtfe", "rcx", "RTX", "RTxy", "rtv", "rrX", "rotxa", "rtwork", "rcX", "rtxy", "vrx", "rotxp", "rcwx", "gtX", "ttxc", "ytfx", "ortxc", "qtfe", "gtv", "RTx", "RTxb", "vrwx", "ortz", "drex", "qtX", "ortx"], "buf": ["Buffer", "bin", "br", "func", "base", "pool", "buffer", "num", "block", "cb", "bc", "Buff", "wb", "mem", "ba", "conv", "box", "queue", "buff", "batch", "map", "pad", "b", "cap", "alloc", "proc", "bag", "uf"]}}
{"project": "qemu", "commit_id": "a80bf99fa3dd829ecea88b9bfb4f7cf146208f07", "target": 1, "func": "static int mux_chr_can_read(void *opaque)\n\n{\n\n    CharDriverState *chr = opaque;\n\n    MuxDriver *d = chr->opaque;\n\n\n\n    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)\n\n        return 1;\n\n    if (d->chr_can_read[chr->focus])\n\n        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);\n\n    return 0;\n\n}\n", "idx": 3392, "substitutes": {"opaque": ["opacity", " opque", "pque", "compacity", "operca", "opca", "opac", "opsacity", "operaque", "obacity", "obque", "compque", " opacity", "hopaque", "compac", "ipaque", "ipque", "ipca", " opa", "obac", "opsque", "compaque", "hopacity", "pa", "pacity", " opca", "ipc", "obaque", "opsaque", "hopac", "opsa", "opa", "opc", "paque", "operc", "opque", "hopque", "operque", " opc"], "chr": ["archr", "chorer", " chrc", "khrer", "motsr", "choR", "shrr", " chra", "cherR", "chR", "cherrator", "echr", "ochrr", "cherr", " chrg", "ocherr", "cltr", "chrt", "ochr", "archerr", "echsr", "chsr", "archrr", "motr", "chartr", "chcr", "charr", "cherrer", "charra", "Chrg", "Chsr", "ochtr", " chcr", " chsr", "chorator", "archtr", "clrt", "chrer", "shtr", "echrb", "chrr", " chrt", "khR", "clra", "Chrb", "motrg", "sherr", "echrc", "Chr", "Chrc", "clr", "Chcr", "chra", "khr", "chrator", "shr", " chrb", "khrator", "chrb", "charrt", "chtr", " chtr", "chrg", "motcr", "chrc", "chor"], "d": ["fd", "ld", "dn", "da", "dd", "pd", "sd", "dh", "dad", "r", "ad", "di", "n", "dl", "ct", "xd", "id", "dict", "de", "dom", "did", "g", "dy", "m", " D", "dt", "ds", "md", "z", "dc", "x", "l", "c", "p", "ind", "w", "e", "dm", "f", "bd", "du", "u", "cd", "driver", "s", "rd", "o", "b", "t", "od", "ded", "nd", "dat", "D", "gd", "db"]}}
{"project": "qemu", "commit_id": "c0f4af171999eda4e49de5169906ce98246457f0", "target": 1, "func": "void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)\n{\n    const ARMCPRegInfo *ri = rip;\n    switch (ri->accessfn(env, ri)) {\n    case CP_ACCESS_OK:\n    case CP_ACCESS_TRAP:\n        break;\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n        env->exception.syndrome = syn_uncategorized();\n        break;\n    default:\n        g_assert_not_reached();", "idx": 15209, "substitutes": {"env": ["erv", "en", "context", "bc", "enc", "prov", "ea", "config", "iss", "ini", "gr", "priv", "iv", "eu", "me", "oa", "virt", "txt", "vm", "scope", "server", "app", "v", "conf", "conn", "np", "console", "equ", "e", "viron", "exc", "net", "fi", "nc", "enable", "eng", "entry", "qt", "eni", "ridge", "serv", "ep", "cf", "here", "que", "exec", "gui", "db", "cache", "ec", "him", "environment", "vs", "ctx", "visor", "err"], "rip": ["rib", "tx", "rup", "ru", "rc", "jp", "ipe", "rs", "rn", "rg", "sr", "ick", "app", "rh", "rub", "region", "tri", "trip", "ris", "rx", "rin", "ix", "op", "RI", "arp", "rw", "ipp", "ip", "serv", "route", "pin", "cap", "rt", "ips", "strip", "rap", "raped"], "syndrome": ["Syndrome", "syindchrome", "syndchrome", "syundrom", "Syntchrome", "syundrome", "cyndchrome", "cyntchrome", "sydrom", "syundroma", "cyndrom", "sydchrome", "Syntrom", "cyntrome", "syndrom", "Syntrome", "sydroma", "syindroma", "syntrom", "Syndroma", "Syntroma", "cyntroma", "sydrome", "syundchrome", "syntrome", "syindrom", "syndroma", "cyntrom", "cyndroma", "syntroma", "Syndrom", "syntchrome", "Syndchrome", "cyndrome", "syindrome"], "ri": ["ani", "stri", "rid", "rd", "ni", "ai", "xi", "rc", "ini", "i", "gi", " RI", "iv", "io", "ra", "ci", "ki", "di", "sr", "iri", "rio", "si", "uri", "vi", "tri", "ris", "ir", "mi", "rx", "rin", "RI", "ti", "ski", "rm", "ip", "eni", "ry", "ro", "pi", "rt", "mir", "ori"]}}
{"project": "qemu", "commit_id": "d4754a953196516b16beef707dcdfdb35c2eec6e", "target": 1, "func": "static void net_l2tpv3_cleanup(NetClientState *nc)\n\n{\n\n    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);\n\n    qemu_purge_queued_packets(nc);\n\n    l2tpv3_read_poll(s, false);\n\n    l2tpv3_write_poll(s, false);\n\n    if (s->fd > 0) {\n\n        close(s->fd);\n\n    }\n\n    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);\n\n    g_free(s->vec);\n\n    g_free(s->header_buf);\n\n    g_free(s->dgram_dst);\n\n}\n", "idx": 20327, "substitutes": {"nc": ["lc", "bc", "fc", "sb", "cc", "e", "conn", "ct", "config", "g", "kt", "cv", "unc", "cm", "pc", "anc", "node", "ci", "nec", "nd", "enc", "cs", "mc", "cf", "sync", "ng", "rc", "c", "rn", "ctx", "cn", "nr", "sc", "nw", "dc", "n", "NC", "ns", "cdn", "cus", "cms", "ne", "nt", "sn", "ec", "nm"], "s": ["request", "sb", "e", "sym", "qs", "es", "bis", "send", "sie", "sl", "hs", "fs", "ses", "an", "g", "xs", "your", "d", "ops", "ks", "ds", "services", "f", "sys", "t", "u", "m", "args", "its", "ssl", "ys", "p", "ts", "cs", "enc", "os", "o", "sync", "is", "ss", "ls", "sg", "c", "js", "settings", "spec", "si", "sc", "sr", "w", "service", "se", "core", "n", "S", "session", "ns", "src", "sf", "new", "south", "rs", "gs", "conf", "sec", "sn", "su", "sq", "states"]}}
{"project": "qemu", "commit_id": "bc210eb163b162ff2e94e5c8f4307715731257f8", "target": 0, "func": "static int send_png_rect(VncState *vs, int x, int y, int w, int h,\n\n                         VncPalette *palette)\n\n{\n\n    png_byte color_type;\n\n    png_structp png_ptr;\n\n    png_infop info_ptr;\n\n    png_colorp png_palette = NULL;\n\n    pixman_image_t *linebuf;\n\n    int level = tight_png_conf[vs->tight.compression].png_zlib_level;\n\n    int filters = tight_png_conf[vs->tight.compression].png_filters;\n\n    uint8_t *buf;\n\n    int dy;\n\n\n\n    png_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL,\n\n                                        NULL, vnc_png_malloc, vnc_png_free);\n\n\n\n    if (png_ptr == NULL)\n\n        return -1;\n\n\n\n    info_ptr = png_create_info_struct(png_ptr);\n\n\n\n    if (info_ptr == NULL) {\n\n        png_destroy_write_struct(&png_ptr, NULL);\n\n        return -1;\n\n    }\n\n\n\n    png_set_write_fn(png_ptr, (void *) vs, png_write_data, png_flush_data);\n\n    png_set_compression_level(png_ptr, level);\n\n    png_set_filter(png_ptr, PNG_FILTER_TYPE_DEFAULT, filters);\n\n\n\n    if (palette) {\n\n        color_type = PNG_COLOR_TYPE_PALETTE;\n\n    } else {\n\n        color_type = PNG_COLOR_TYPE_RGB;\n\n    }\n\n\n\n    png_set_IHDR(png_ptr, info_ptr, w, h,\n\n                 8, color_type, PNG_INTERLACE_NONE,\n\n                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        struct palette_cb_priv priv;\n\n\n\n        png_palette = png_malloc(png_ptr, sizeof(*png_palette) *\n\n                                 palette_size(palette));\n\n\n\n        priv.vs = vs;\n\n        priv.png_palette = png_palette;\n\n        palette_iter(palette, write_png_palette, &priv);\n\n\n\n        png_set_PLTE(png_ptr, info_ptr, png_palette, palette_size(palette));\n\n\n\n        if (vs->client_pf.bytes_per_pixel == 4) {\n\n            tight_encode_indexed_rect32(vs->tight.tight.buffer, w * h, palette);\n\n        } else {\n\n            tight_encode_indexed_rect16(vs->tight.tight.buffer, w * h, palette);\n\n        }\n\n    }\n\n\n\n    png_write_info(png_ptr, info_ptr);\n\n\n\n    buffer_reserve(&vs->tight.png, 2048);\n\n    linebuf = qemu_pixman_linebuf_create(PIXMAN_BE_r8g8b8, w);\n\n    buf = (uint8_t *)pixman_image_get_data(linebuf);\n\n    for (dy = 0; dy < h; dy++)\n\n    {\n\n        if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n            memcpy(buf, vs->tight.tight.buffer + (dy * w), w);\n\n        } else {\n\n            qemu_pixman_linebuf_fill(linebuf, vs->vd->server, w, dy);\n\n        }\n\n        png_write_row(png_ptr, buf);\n\n    }\n\n    qemu_pixman_image_unref(linebuf);\n\n\n\n    png_write_end(png_ptr, NULL);\n\n\n\n    if (color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        png_free(png_ptr, png_palette);\n\n    }\n\n\n\n    png_destroy_write_struct(&png_ptr, &info_ptr);\n\n\n\n    vnc_write_u8(vs, VNC_TIGHT_PNG << 4);\n\n\n\n    tight_send_compact_size(vs, vs->tight.png.offset);\n\n    vnc_write(vs, vs->tight.png.buffer, vs->tight.png.offset);\n\n    buffer_reset(&vs->tight.png);\n\n    return 1;\n\n}\n", "idx": 24090, "substitutes": {"vs": ["obs", "sv", "VS", "vers", "qs", "serv", "vt", "lv", "fs", "iv", "config", "uns", "ses", "xs", "cv", "lines", "vg", "qv", "ops", "ks", "ds", "flags", "pos", "env", "fps", "s", "ils", "state", "ys", "cs", "ls", "Vs", "vi", "vis", "stats", "rc", "settings", "ctx", "spec", "wp", "sts", "ii", "vr", "ov", "ms", "rev", "verts", "vol", "ns", "va", "ps", "rs", "gs", "vert", "eps", "v", "alls", "vm", "bs", "vp", "ss", "pps", "vc"], "x": ["col", "row", "i", "xs", "xy", "d", "f", "pos", "ex", "m", "p", "o", "px", "c", "index", "dx", "X", "on", "b", "n", "z", "v", "image", "l"], "y": ["col", "i", "hot", "vy", "yy", "xy", "d", "f", "t", "r", "m", "j", "p", "o", "q", "c", "ch", "a", "b", "Y", "n", "z", "l"], "w": ["row", "i", "ow", "level", "g", "wa", "d", "height", "f", "win", "r", "m", "size", "wh", "p", "q", "W", "c", "wt", "b", "n", "sw", "fw", "ew", "wx", "v", "z", "hw", "l", "max", "k"], "h": ["ih", "i", "end", "g", "d", "height", "f", "t", "u", "ht", "m", "r", "hd", "p", "rh", "o", "q", "H", "c", "ch", "b", "n", "gh", "th", "hi", "z", "v", "hw", "l", "ph", "k", "hh"], "palette": ["plipe", " palignment", "Palge", "palote", "reallette", "palettes", "alge", "pallette", "alettes", "alette", "plettes", "Palenge", "realette", "palge", "Palettes", "Palipe", "plignment", "mallette", "Palette", " palettes", "Palignment", "realenge", " palote", "palenge", " palenge", "plette", "malignment", " pallette", "realettes", "palipe", "realignment", "palignment", "allette", " palge", "malette", "realge", "Pallette", "malote", "realipe", "Palote"], "color_type": ["colorPtypes", " color_version", "colorPstr", "channel_types", "colorvalvalue", "color_str", "color32ty", "colorftypes", "channel_source", "colorvalversion", "channelftype", "type_role", "color_count", "colorvaltype", "color__count", "channelfsource", "colorPsource", " color_count", "color32types", "colorenrole", " color_types", "color_unit", "color__unit", "colorenType", "color_var", "color32var", "typeentype", "color_source", "colorfsource", "color32type", "channelfstr", "channel_type", "color_ty", "colorentype", " color_var", "color_types", " color_value", " color_style", "colorvalunit", "color_version", "color_style", "colorftype", "colorfstr", " color_ty", "type_Type", "channelftypes", "colorvalstyle", " color_unit", "color_role", "channel_str", "colorvalcount", "typeenrole", "type_type", "colorvaltypes", "color_value", "color__types", "colorPtype", "color_Type", "typeenType", "color__type"], "png_ptr": ["px_dr", "wp67rot", "img_ptr", "txt_Ptr", "png_rt", "np_fd", "img_ref", "png_addr", "png_Ptr", "np_pointers", "png67rt", "png67pt", "pngAMaddress", "png_ref", "img_tty", "png00dr", "wp67ptr", "ng_desc", "img_addr", "png_pointer", "wp_addr", "package67addr", "wp67addr", "png_push", "package67ptr", "ng_ptr", "txt_ptr", "png67pointer", "img_pointer", "png67tty", "png_proc", "img_desc", "png00transfer", "png_rot", "png_pointers", "px00transfer", "pnglptr", "ng_pointer", "png00tty", "png67desc", "png00push", "png__ptr", "png00ptr", "png00addr", "png_address", "np_inst", "px00dr", "package67pt", "np_ptr", "png00desc", "pngAMptr", "package_pt", "png67rot", "png_transfer", "px_transfer", "pnglref", "wp67pointer", "pnglpointers", "png_pt", "wp_rot", "px00push", "txt_pointer", "pngAMref", "img_address", "png_desc", "np_tr", "pnglinst", "ng_ref", "png67addr", "np_pointer", "np_ref", "px_ptr", "png_inst", "png__desc", "pngAMproc", "img_tr", "png67Ptr", "px_push", "png__pointer", "img_Ptr", "png_fd", "package_ptr", "img_proc", "png_dr", "wp_pointer", "png67ptr", "png_tty", "png__ref", "px00ptr", "png_tr", "wp_ptr", "txt_rt", "package_addr"], "info_ptr": ["fo_ptr", " info_type", " info_pointer", "info_type", "info___struct", "infoPaddr", "info_pert", "info_pointer", "info___pointer", "fo_addr", "fo_buf", "fo_struct", " info_addr", "info___ptr", "fo_pointer", "info_buf", "fo_pointers", " info_pert", "info_dr", "infoPtype", " info_dr", "info___buf", "info_pointers", "info_struct", "infoPptr", "infoPpointer", "info_addr"], "linebuf": ["Linebag", "slicearray", "linebag", "inlinebuf", "Linebuf", "inlinearray", "linecache", "inlinebag", "inlinecache", "slicebag", "Linecache", "Linearray", "linearray", "slicebuf", "slicecache"], "buf": ["conv", "stack", "uf", "val", "pkg", "cv", "queue", "func", "buffer", "alloc", "cmd", "box", "rc", "pool", "ctx", "cb", "ptr", "window", "tmp", "seq", "ff", "src", "fd", "len", "Buffer", "buff", "rb", "cap"], "dy": ["ding", "def", " height", "ded", "db", " row", "d", " dd", " dir", "ds", "dir", "dev", "dd", " def", "sync", " d", "dx", "dim", " rows", " disp", "D", " dim", " delta", "di", " dev", " dup"], "priv": ["pb", "public", "ra", "str", "uc", "fac", "err", " Priv", "vt", "prof", "mini", "private", " privilege", "Priv", "impl", "color", "rec", "tx", "access", "ci", "trust", "neg", "info", "cp", "dev", "white", "wh", "cer", "auth", "rw", "rc", "pri", "riv", "pro", "ch", "ocr", "gr", "req", "cert", "buff", "proc", "sec", "rib", "li", "lit", "pi", "fi", "resp", "pub"]}}
{"project": "FFmpeg", "commit_id": "4f00519d9508e07aac58a00a9b514dae8ad95723", "target": 1, "func": "int vc1_decode_sequence_header(AVCodecContext *avctx, VC1Context *v, GetBitContext *gb)\n\n{\n\n    av_log(avctx, AV_LOG_DEBUG, \"Header: %0X\\n\", show_bits(gb, 32));\n\n    v->profile = get_bits(gb, 2);\n\n    if (v->profile == PROFILE_COMPLEX)\n\n    {\n\n        av_log(avctx, AV_LOG_WARNING, \"WMV3 Complex Profile is not fully supported\\n\");\n\n    }\n\n\n\n    if (v->profile == PROFILE_ADVANCED)\n\n    {\n\n        v->zz_8x4 = ff_vc1_adv_progressive_8x4_zz;\n\n        v->zz_4x8 = ff_vc1_adv_progressive_4x8_zz;\n\n        return decode_sequence_header_adv(v, gb);\n\n    }\n\n    else\n\n    {\n\n        v->zz_8x4 = wmv2_scantableA;\n\n        v->zz_4x8 = wmv2_scantableB;\n\n        v->res_y411   = get_bits1(gb);\n\n        v->res_sprite = get_bits1(gb);\n\n        if (v->res_y411)\n\n        {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Old interlaced mode is not supported\\n\");\n\n            return -1;\n\n        }\n\n        if (v->res_sprite) {\n\n            av_log(avctx, AV_LOG_ERROR, \"WMVP is not fully supported\\n\");\n\n        }\n\n    }\n\n\n\n    // (fps-2)/4 (->30)\n\n    v->frmrtq_postproc = get_bits(gb, 3); //common\n\n    // (bitrate-32kbps)/64kbps\n\n    v->bitrtq_postproc = get_bits(gb, 5); //common\n\n    v->s.loop_filter = get_bits1(gb); //common\n\n    if(v->s.loop_filter == 1 && v->profile == PROFILE_SIMPLE)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"LOOPFILTER shall not be enabled in Simple Profile\\n\");\n\n    }\n\n    if(v->s.avctx->skip_loop_filter >= AVDISCARD_ALL)\n\n        v->s.loop_filter = 0;\n\n\n\n    v->res_x8 = get_bits1(gb); //reserved\n\n    v->multires = get_bits1(gb);\n\n    v->res_fasttx = get_bits1(gb);\n\n    if (!v->res_fasttx)\n\n    {\n\n        v->vc1dsp.vc1_inv_trans_8x8 = ff_simple_idct_8;\n\n        v->vc1dsp.vc1_inv_trans_8x4 = ff_simple_idct84_add;\n\n        v->vc1dsp.vc1_inv_trans_4x8 = ff_simple_idct48_add;\n\n        v->vc1dsp.vc1_inv_trans_4x4 = ff_simple_idct44_add;\n\n        v->vc1dsp.vc1_inv_trans_8x8_dc = ff_simple_idct_add_8;\n\n        v->vc1dsp.vc1_inv_trans_8x4_dc = ff_simple_idct84_add;\n\n        v->vc1dsp.vc1_inv_trans_4x8_dc = ff_simple_idct48_add;\n\n        v->vc1dsp.vc1_inv_trans_4x4_dc = ff_simple_idct44_add;\n\n    }\n\n\n\n    v->fastuvmc =  get_bits1(gb); //common\n\n    if (!v->profile && !v->fastuvmc)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"FASTUVMC unavailable in Simple Profile\\n\");\n\n        return -1;\n\n    }\n\n    v->extended_mv =  get_bits1(gb); //common\n\n    if (!v->profile && v->extended_mv)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Extended MVs unavailable in Simple Profile\\n\");\n\n        return -1;\n\n    }\n\n    v->dquant =  get_bits(gb, 2); //common\n\n    v->vstransform =  get_bits1(gb); //common\n\n\n\n    v->res_transtab = get_bits1(gb);\n\n    if (v->res_transtab)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"1 for reserved RES_TRANSTAB is forbidden\\n\");\n\n        return -1;\n\n    }\n\n\n\n    v->overlap = get_bits1(gb); //common\n\n\n\n    v->s.resync_marker = get_bits1(gb);\n\n    v->rangered = get_bits1(gb);\n\n    if (v->rangered && v->profile == PROFILE_SIMPLE)\n\n    {\n\n        av_log(avctx, AV_LOG_INFO,\n\n               \"RANGERED should be set to 0 in Simple Profile\\n\");\n\n    }\n\n\n\n    v->s.max_b_frames = avctx->max_b_frames = get_bits(gb, 3); //common\n\n    v->quantizer_mode = get_bits(gb, 2); //common\n\n\n\n    v->finterpflag = get_bits1(gb); //common\n\n\n\n    if (v->res_sprite) {\n\n        v->s.avctx->width  = v->s.avctx->coded_width  = get_bits(gb, 11);\n\n        v->s.avctx->height = v->s.avctx->coded_height = get_bits(gb, 11);\n\n        skip_bits(gb, 5); //frame rate\n\n        v->res_x8 = get_bits1(gb);\n\n        if (get_bits1(gb)) { // something to do with DC VLC selection\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported sprite feature\\n\");\n\n            return -1;\n\n        }\n\n        skip_bits(gb, 3); //slice code\n\n        v->res_rtm_flag = 0;\n\n    } else {\n\n        v->res_rtm_flag = get_bits1(gb); //reserved\n\n    }\n\n    if (!v->res_rtm_flag)\n\n    {\n\n//            av_log(avctx, AV_LOG_ERROR,\n\n//                   \"0 for reserved RES_RTM_FLAG is forbidden\\n\");\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Old WMV3 version detected, some frames may be decoded incorrectly\\n\");\n\n        //return -1;\n\n    }\n\n    //TODO: figure out what they mean (always 0x402F)\n\n    if(!v->res_fasttx) skip_bits(gb, 16);\n\n    av_log(avctx, AV_LOG_DEBUG,\n\n               \"Profile %i:\\nfrmrtq_postproc=%i, bitrtq_postproc=%i\\n\"\n\n               \"LoopFilter=%i, MultiRes=%i, FastUVMC=%i, Extended MV=%i\\n\"\n\n               \"Rangered=%i, VSTransform=%i, Overlap=%i, SyncMarker=%i\\n\"\n\n               \"DQuant=%i, Quantizer mode=%i, Max B frames=%i\\n\",\n\n               v->profile, v->frmrtq_postproc, v->bitrtq_postproc,\n\n               v->s.loop_filter, v->multires, v->fastuvmc, v->extended_mv,\n\n               v->rangered, v->vstransform, v->overlap, v->s.resync_marker,\n\n               v->dquant, v->quantizer_mode, avctx->max_b_frames\n\n               );\n\n    return 0;\n\n}\n", "idx": 8901, "substitutes": {"avctx": ["navcb", "avcmp", "afctx", "avsync", "navsync", "AVconfig", "navctx", "abconn", "AVcn", "afpkg", "afcmp", "avectx", "abcmp", "vcontext", "AVsc", "abcontext", "vcmp", "afctl", "AVcmp", "AVpkg", " avcmp", "navconn", "AVcontext", "avcu", "verctx", "abctx", "vercontext", "verlc", "avconn", " avsc", "AVsync", "navcn", "AVlc", "avlc", "afconfig", "vctx", "cvctx", "AVctx", "avsc", "AVconn", " avcontext", "afsc", "verconn", "avconfig", "avcontext", "abcu", "vpkg", "cvctl", "avpkg", "navcontext", "navlc", "cvcontext", "AVctl", "AVcb", "avecn", "AVcu", "avecontext", "vercb", "afcontext", "avctl", " avcu", "cvconfig", "avcb", "avcn", "avesync", "ablc"], "v": ["vs", "l", "vi", "va", "gu", "vert", "sv", "n", "g", "val", "d", "lv", "view", "m", "nav", "b", "k", "t", "vim", "iv", "ve", "ver", "x", "vt", "var", "c", "vm", "s", "ov", "p", "i", "e", "tv", "value", "q", "f", "j", "ev", "qv", "vol", "inv", "version", "nv", "cv", "uv", "conv", "V", "vd", "z", "vin", "ii", "u", "vr", "h", "dev", "av", "vv", "vg", "video", "api", "vc", "rev", "volt", "vp"], "gb": ["GB", "ui", "gd", "bb", "nb", "g", "gom", "abb", "gpu", "phy", "bm", "b", "game", "gm", "gs", "gin", "bd", "hm", "cb", "ub", "bo", "ged", "cli", "gp", "rb", "gh", "gal", "bc", "gnu", "Gb", "gy", "db", "bf", "cgi", "eb", "bg", "gate", "agg", "lib", "gg", "lb", "ga", "sb", "storage", "usb", "pc", "git", "kw", "hub", "hd", "gru", "cfg", "xy", "mb", "rg", "ge", "bn", "ch", "gow", "gam", "kb", "ko", "gram"]}}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,\n\n                            uint64_t *data)\n\n{\n\n    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);\n\n    uint32_t val;\n\n\n\n    switch(addr) {\n\n    case 0x00:\n\n        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n        break;\n\n    case 0x02:\n\n        val = s->ar.pm1.evt.en;\n\n        break;\n\n    case 0x04:\n\n        val = s->ar.pm1.cnt.cnt;\n\n        break;\n\n    case 0x08:\n\n        val = acpi_pm_tmr_get(&s->ar);\n\n        break;\n\n    default:\n\n        val = 0;\n\n        break;\n\n    }\n\n    PIIX4_DPRINTF(\"PM readw port=0x%04x val=0x%04x\\n\", (unsigned int)addr, val);\n\n    *data = val;\n\n}\n", "idx": 13988, "substitutes": {"ioport": ["imetorter", "iport", "coporter", "iporter", "oporn", "oport", "ioorter", "ioported", "iprt", "ioporter", "coported", "imetorn", "coport", "ioorn", "ioporn", "ioort", "ipore", "ioorted", "imetort", "oporter", "iported", "coprt", "oported", "imetorted", "iopore", "opore", "ioprt", "ioore", "imetrt"], "addr": ["ord", "device", "proc", "context", "amp", "enc", "arm", "rc", "config", "amd", "id", "align", "x", "ref", "ace", "xp", "frame", "conn", "grad", "ad", "adr", "layer", "rx", "socket", "pointer", "ext", "kt", "mode", "address", "state", "ip", "url", "proxy", "route", "arr", "offset", "cb", "eth", "attr", "cmd", "rt", "ack", "host", "mac", "aud", "src", "seq", "inet", "dr", "pos", "prefix", "delay", "pad", "header", "len", "ptr", "index", "start"], "data": ["action", "d", "array", "response", "input", "config", "i", "da", "def", "align", "new", "di", "status", "buffer", "update", "aa", "valid", "v", "value", "alpha", "size", "la", "p", "buf", "result", "parent", "dat", "address", "state", "block", "arr", "Data", "feed", "body", "attr", "wa", "DATA", "write", "ata", "cache", "fee", "al", "len", "index"], "s": ["south", "sys", "m", "ses", "self", "as", "service", "t", "d", "sync", "fs", "your", "i", "rs", "sym", "a", "g", "cs", "qs", "S", "os", "es", "si", "js", "sq", "uns", "session", "ps", "ss", "conf", "o", "an", "p", "e", "sb", "b", "n", "f", "gs", "c", "ns", "is", "ssl", "sl", "states", "r", "services", "ds", "su", "ls", "ts", "us", "aws"], "val": ["bc", "pre", "def", "local", "eval", "x", "status", "vol", "ind", "dev", "mem", "base", "stat", "serv", "sl", "fail", "fee", "index", "call", "part", "key", "error", "pass", "grad", "doc", "b", "min", "result", "ann", "il", "arr", "cal", "exec", "al", "rel", "el", "vals", "alt", "slot", "VAL", "ref", "unit", "update", "live", "pid", "valid", "value", "fe", "rl", "Val", "sel", "pos", "bl", "err", "ret", "split", "pt", "cond", "v", "p", "ee", "ol", "all", "aval", "db", "len"]}}
{"project": "FFmpeg", "commit_id": "5674d4b0a35a34b75e3533a8580e0b5a0a8895a7", "target": 0, "func": "static int mpc8_decode_frame(AVCodecContext * avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MPCContext *c = avctx->priv_data;\n\n    GetBitContext gb2, *gb = &gb2;\n\n    int i, j, k, ch, cnt, res, t;\n\n    Band *bands = c->bands;\n\n    int off;\n\n    int maxband, keyframe;\n\n    int last[2];\n\n\n\n    keyframe = c->cur_frame == 0;\n\n\n\n    if(keyframe){\n\n        memset(c->Q, 0, sizeof(c->Q));\n\n        c->last_bits_used = 0;\n\n    }\n\n    init_get_bits(gb, buf, buf_size * 8);\n\n    skip_bits(gb, c->last_bits_used & 7);\n\n\n\n    if(keyframe)\n\n        maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1);\n\n    else{\n\n        maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);\n\n        if(maxband > 32) maxband -= 33;\n\n    }\n\n    c->last_max_band = maxband;\n\n\n\n    /* read subband indexes */\n\n    if(maxband){\n\n        last[0] = last[1] = 0;\n\n        for(i = maxband - 1; i >= 0; i--){\n\n            for(ch = 0; ch < 2; ch++){\n\n                last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch];\n\n                if(last[ch] > 15) last[ch] -= 17;\n\n                bands[i].res[ch] = last[ch];\n\n            }\n\n        }\n\n        if(c->MSS){\n\n            int mask;\n\n\n\n            cnt = 0;\n\n            for(i = 0; i < maxband; i++)\n\n                if(bands[i].res[0] || bands[i].res[1])\n\n                    cnt++;\n\n            t = mpc8_get_mod_golomb(gb, cnt);\n\n            mask = mpc8_get_mask(gb, cnt, t);\n\n            for(i = maxband - 1; i >= 0; i--)\n\n                if(bands[i].res[0] || bands[i].res[1]){\n\n                    bands[i].msf = mask & 1;\n\n                    mask >>= 1;\n\n                }\n\n        }\n\n    }\n\n    for(i = maxband; i < c->maxbands; i++)\n\n        bands[i].res[0] = bands[i].res[1] = 0;\n\n\n\n    if(keyframe){\n\n        for(i = 0; i < 32; i++)\n\n            c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1;\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        if(bands[i].res[0] || bands[i].res[1]){\n\n            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;\n\n            if(cnt >= 0){\n\n                t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);\n\n                if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt);\n\n                if(bands[i].res[1]) bands[i].scfi[1] = t & 3;\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            if(!bands[i].res[ch]) continue;\n\n\n\n            if(c->oldDSCF[ch][i]){\n\n                bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6;\n\n                c->oldDSCF[ch][i] = 0;\n\n            }else{\n\n                t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);\n\n                if(t == 64)\n\n                    t += get_bits(gb, 6);\n\n                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6;\n\n            }\n\n            for(j = 0; j < 2; j++){\n\n                if((bands[i].scfi[ch] << j) & 2)\n\n                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];\n\n                else{\n\n                    t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);\n\n                    if(t == 31)\n\n                        t = 64 + get_bits(gb, 6);\n\n                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0, off = 0; i < maxband; i++, off += SAMPLES_PER_BAND){\n\n        for(ch = 0; ch < 2; ch++){\n\n            res = bands[i].res[ch];\n\n            switch(res){\n\n            case -1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++)\n\n                    c->Q[ch][off + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510;\n\n                break;\n\n            case 0:\n\n                break;\n\n            case 1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){\n\n                    cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2);\n\n                    t = mpc8_get_mask(gb, 18, cnt);\n\n                    for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1)\n\n                        c->Q[ch][off + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0;\n\n                }\n\n                break;\n\n            case 2:\n\n                cnt = 6;//2*mpc8_thres[res]\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 3){\n\n                    t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2);\n\n                    c->Q[ch][off + j + 0] = mpc8_idx50[t];\n\n                    c->Q[ch][off + j + 1] = mpc8_idx51[t];\n\n                    c->Q[ch][off + j + 2] = mpc8_idx52[t];\n\n                    cnt = (cnt >> 1) + mpc8_huffq2[t];\n\n                }\n\n                break;\n\n            case 3:\n\n            case 4:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 2){\n\n                    t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];\n\n                    c->Q[ch][off + j + 1] = t >> 4;\n\n                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);\n\n                }\n\n                break;\n\n            case 5:\n\n            case 6:\n\n            case 7:\n\n            case 8:\n\n                cnt = 2 * mpc8_thres[res];\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];\n\n                    c->Q[ch][off + j] = t;\n\n                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);\n\n                }\n\n                break;\n\n            default:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    c->Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);\n\n                    if(res != 9){\n\n                        c->Q[ch][off + j] <<= res - 9;\n\n                        c->Q[ch][off + j] |= get_bits(gb, res - 9);\n\n                    }\n\n                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);\n\n\n\n    c->cur_frame++;\n\n\n\n    c->last_bits_used = get_bits_count(gb);\n\n    if(c->cur_frame >= c->frames)\n\n        c->cur_frame = 0;\n\n    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;\n\n\n\n    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;\n\n}\n", "idx": 7558, "substitutes": {"avctx": [" avcontext", "afcli", " avcv", "Avcli", "abcp", "Avpkg", "afcv", "ajpkg", "afctx", "abcontext", "afcp", "afpkg", "avcontext", "avcv", "ajcli", "avcp", "Avcontext", " avcp", "Avctx", "avpkg", "afcontext", "ajctx", "ajcontext", "abcv", "abctx", "avcli"], "data": ["base", "pack", "buff", "bin", "block", "dat", "channel", "config", "val", "queue", "body", "image", "m", "in", "window", "uf", "content", "client", "media", "d", "DATA", "buffer", "code", "connection", "da", "message", "Data", "bytes", "response", "load", "result", "p", "input", "batch", "reader", "frame", "memory", "read", "board", "cache", "next", "size"], "data_size": ["data\u00b7grow", "data\u00b7timeout", "dataflowsize", "dataflowgrow", "dataflowlen", "buffer_len", "buffer_timeout", "dataflowtimeout", "buffer_grow", "data\u00b7size", "data\u00b7len", "data_len", "data_grow", "data_timeout", "buffer_size"], "avpkt": ["avfacket", "abpct", "avfpkt", " avvpki", "avfkt", " avpki", "avfpkg", "abpck", "avfck", "avpacket", "avwpck", "avwpkt", "avbpcht", "abpkg", "avpct", "abcpacket", "avfpct", " avvpck", "avcpacket", "avvpkt", "avckt", "avcpkt", "avcpct", "abcpkg", "abcpct", "avcpck", "avvpki", "avwpcht", "abcpck", "avpck", " avvpcht", " avpcht", "avvpcht", "avpkg", "avfpacket", "avvpck", "avbpki", "avbpkt", "avpki", " avvpkt", "avwpki", "avpcht", "abpacket", "abpkt", "avcct", "avcpkg", "avcck", " avpck", "avfct", "avbpck", "avfkg", "avcacket", "abcpkt"], "buf": ["cas", "buff", "vec", "mem", "block", "box", "cur", "v", "rb", "config", " buffer", "rc", "queue", "map", "uc", "fb", "uf", "buffer", "code", "bag", "raw", "port", "cmd", "pad", "bc", "cb", "seq", "array", "p", "batch", "alloc", "cf", "br", "board", "cv", "cache", "pb", "src", "img"], "c": ["cp", "icc", "cmp", "cr", "v", "cur", "s", "ci", "component", "config", "b", "nc", "com", "sync", "rc", "enc", "cat", "co", "C", "uc", "cy", "m", "l", "f", "client", "d", "pc", "cc", "cs", "ce", "u", "conf", "arc", "con", "mc", "sc", "e", "dc", "conn", "ctx", "n", "bc", "cu", "coll", "p", "ctrl", "ec", "ca", "h", "cit", "g", "ct", "cn", "cf", "lc", "fc", "ac", "vc", "cache", "r", "cm", "cd", "xc"], "gb2": ["cvv", "gb4", "gb3", "GB2", "c2", "GB1", "GB4", "gbTwo", "pc2", "GBv", " rc3", "cTwo", "cv1", "gg2", " rcTwo", "pcTwo", "ggv", "cv4", "gbv", "pc3", "c3", "gb1", "cv2", "gg4", "gg1", " rc2"], "gb": ["gp", "agg", "cgi", "cfg", "band", "buff", "bp", "bin", "gm", "hub", "ci", "gru", "rb", "config", "bg", "b", "rc", "bm", "db", "gu", "uf", "ga", "pg", "usb", "gin", "pc", "gz", "bb", "py", "eb", "sb", "gs", "gam", "rg", "banks", "binary", "storage", "lib", "ctx", "bc", "GB", "cb", "go", "nb", "gold", "mb", "boot", "gy", "kb", "g", "bf", "gd", "lc", "gt", "gg", "bo", "yg"], "i": ["gi", "o", "ti", "v", "id", "I", "chi", "ih", "di", "ik", "ci", "ki", "ji", "ni", "b", "x", "si", "xi", "io", "ri", "info", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "yi", "phi", "d", "ii", "iu", "it", "ai", "u", "e", "sh", "uri", "ami", "ori", "n", "multi", "mi", "ini", "ie", "p", "h", "z", "eni", "oi", "hi", "ind", "ip", "y", "api", "li", "fi", "r", "zi", "ui"], "j": ["o", "v", "ji", "b", "si", "m", "l", "f", "ij", "ii", "d", "q", "u", "J", "n", "jp", "ie", "p", "h", "z", "pos", "ind", "g", "y", "r"], "k": ["o", "v", "ik", "ki", "x", "kk", "m", "key", "K", "sk", "f", "d", "q", "u", "ck", "e", "w", "ks", "n", "p", "kw", "h", "z", "ke", "g", "y"], "ch": ["chi", "ci", "x", "b", "ich", "sk", "f", "conf", "code", "col", "cho", "cor", "cham", "h", "chn", "ver", "y", "CH", "bh", "conn", "cm", "cp", "cur", "try", "channel", "cry", "cher", "Ch", "sh", "sc", "zh", "sch", "work", "batch", "z", "cht", "arch", "form", "fr", "change", "cha", "th", "cl", "ph", "u", "dev", "p", "hr", "ach", "app", "cel", "chy", "chip", "v", "pr", "pull", "che", "cy", "qi", "child", "q", "chart", "qu", "ky", "gh", "chan", "och"], "cnt": ["lcno", " cn", " cnc", " cnd", "count", "cnd", "CNT", "ecnc", "ecNT", "cno", "lcnc", "Cno", "Cnc", "acno", "lcn", " cNT", "ecnt", "lcct", "cct", "cnc", " cct", "ecct", "Cnt", "cNT", "lcNT", "Count", "ecnd", " count", "acn", "acnt", "ecount", " cno", "cn", "lcnt", "Cnd", "acNT", "Cct"], "res": ["gr", "reset", "ret", "reg", "press", "block", "prev", "spec", "total", "ress", "values", "Res", "ex", "real", "rh", "vals", "results", "rest", "ras", "des", "resolution", "def", "rss", "sc", "arr", "rx", "ts", "err", "response", "rev", "pres", "result", "rem", "req", "blocks", "remote", "re", "mr", "sp", "RES", "pos", "os", "range", "ms", "resp", "rep", "rs", "r", "ps", "max"], "t": ["ot", "o", "tf", "v", "rt", "total", "nt", "unt", "qt", "token", "template", "wt", "m", "pt", "l", "f", "at", "it", "e", "mt", "det", "tn", "port", "n", "tm", "ts", "p", "tz", "ut", "ta", "g", "y", "type", "dt", "tp", "tt", "T", "r", "tc"], "bands": ["groups", "points", "types", "models", "bass", "band", "files", "books", "objects", "rules", "balls", "bits", "plugins", "words", "b", "modules", "cells", "services", "ogs", "cats", "pins", "planes", "states", "girls", "codes", "parts", "images", "cycles", "heads", "stores", "rooms", "archs", "orders", "classes", "sb", "banks", "ks", "steps", "pages", "ds", "bys", "jobs", "devices", "chains", "players", "blocks", "rings", "pieces", "products", "tops", "bags", "cards", "g", "tracks", "ands", "amps", "bones", "frames", "ids", "lines", "versions", "bows", "charges", "lists"], "off": ["o", "reset", "ef", "total", "offs", "op", "offset", "obj", "loop", "def", "low", "error", "out", "one", "opt", "Off", " offset", "ip", "orig", "on", "mode", "shift", "ff", "ok"], "maxband": ["maxhard", "xBand", "mincell", "scaleband", "modbridge", "maxchannel", " maxbit", "maxblock", "scalebit", "modbit", "maxbroad", "Maxband", "axboot", "axbridge", "righthard", "maxgroup", " maxbroad", "workline", " maxgroup", "workbit", "lastbit", "taxpage", "lastline", "maxBand", "totalband", "rightbit", "axblock", "rightblock", "xbit", "rightband", "axpage", "minchannel", "taxhard", "axbroad", "lastband", "totalline", "minbit", "taxband", " maxline", "axBand", "axbit", "workband", "MaxBand", "minline", "totalbit", "mingroup", "modpage", "xband", "axline", " maxblock", "minband", "maxcell", " maxBand", " maxchannel", "maxbit", "Maxboot", "taxbit", "rightbridge", "maxline", "maxbridge", " maxpage", "scalecell", "lastBand", "rightpage", "axframe", "workframe", "scalegroup", "totalBand", "maxboot", " maxcell", "axband", "modband", "maxframe", "rightbroad", " maxboot", " maxframe", "maxpage", "axchannel", " maxhard"], "keyframe": ["maxFrame", "Keyline", "khole", " keyframes", "rowframe", "rowcode", " keyhole", "skycode", "keyfram", "Keyframe", "Keyiframe", "keycode", "skyfram", "keyframes", "kframe", "skyframe", " keyiframe", "keyline", "skyiframe", "rowfram", "maxframe", "KeyFrame", "maxline", "Keyfram", "Keyframes", "rowframes", "kframes", "Keycode", "keyhole", " keyfram", "skyframes", "Keyhole", "maxframes", "keyiframe", " keyFrame", " keyline", "keyFrame"], "last": ["master", "base", "est", "recent", "build", "extra", "id", "not", "prev", "parent", "total", "count", "since", "scope", "best", "list", "final", "style", "tr", "or", "now", "bottom", "use", "valid", "cle", "private", "child", "used", "active", "Last", "pop", "push", "code", "all", "any", "full", "latest", "always", "history", "empty", "first", "cycle", "str", "self", "one", "old", "eval", "this", "shared", "cost", "range", "pull", "new", "worst", "only", "desc", "next", "cache", "current", "max", "end", "size"], "mask": ["id", "count", "bits", "total", " tr", "tr", " masks", "bit", "info", "m", "th", "sk", "offset", "Mask", "tl", "all", "depth", "black", "ts", "ask", "p", "qa", "batch", "tile", "ta", "type", "max"], "cur_frame": ["curopchannel", "latestopelement", "curfelement", "curfchannel", "cur_channel", "cur_bit", "cur__bit", "latestopbit", "latest_bit", "curopframe", "curopbit", "curfframe", "latest_frame", "latest_element", "latestopchannel", "latestopframe", "cur__channel", "cur__frame", "cur_element", "curopelement", "latest_channel", "curfbit", "cur__element"]}}
{"project": "FFmpeg", "commit_id": "1dba8371d93cf1c83bcd5c432d921905206a60f3", "target": 0, "func": "int ffurl_connect(URLContext *uc, AVDictionary **options)\n\n{\n\n    int err =\n\n        uc->prot->url_open2 ? uc->prot->url_open2(uc,\n\n                                                  uc->filename,\n\n                                                  uc->flags,\n\n                                                  options) :\n\n        uc->prot->url_open(uc, uc->filename, uc->flags);\n\n    if (err)\n\n        return err;\n\n    uc->is_connected = 1;\n\n    /* We must be careful here as ffurl_seek() could be slow,\n\n     * for example for http */\n\n    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, \"file\"))\n\n        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)\n\n            uc->is_streamed = 1;\n\n    return 0;\n\n}\n", "idx": 24205, "substitutes": {"uc": ["acc", "exec", "ru", "uf", "sc", "cca", "class", "oc", "auc", "anc", "c", "UC", "context", "cv", "cci", "ec", "cur", "config", "uca", "up", "soc", "cus", "us", "pub", "bc", "mac", "ocr", "util", "url", "su", "u", "instance", "fc", "aux", "con", "input", "ul", "unc", "sub", "cli", "cc", "ctx", "ucc", "client", "ub", "asc", "rc", "mc", "roc", "co", "BC", "cas", "lc", "uu", "um", "aut", "ack", "ca", "usc", "tc", "cu", "userc", "RC", "plug", "uci", "ui", "connection", "ac", "pc"], "options": ["exec", "args", "public", "oci", "this", "option", "context", "flags", "other", "or", "data", "ec", "text", "config", "opens", "opt", "optional", "mac", "Options", "url", "self", "e", "aux", "con", "o", "path", "fee", "lib", "object", "os", "cache", "co", "six", "array", "null", "pos", "settings", "ops", "times", "params"]}}
{"project": "qemu", "commit_id": "2231f69b4e4523c43aa459cab18ab77c0e29b4d1", "target": 0, "func": "build_madt(GArray *table_data, BIOSLinker *linker, VirtGuestInfo *guest_info)\n\n{\n\n    int madt_start = table_data->len;\n\n    const MemMapEntry *memmap = guest_info->memmap;\n\n    const int *irqmap = guest_info->irqmap;\n\n    AcpiMultipleApicTable *madt;\n\n    AcpiMadtGenericDistributor *gicd;\n\n    AcpiMadtGenericMsiFrame *gic_msi;\n\n    int i;\n\n\n\n    madt = acpi_data_push(table_data, sizeof *madt);\n\n\n\n    gicd = acpi_data_push(table_data, sizeof *gicd);\n\n    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;\n\n    gicd->length = sizeof(*gicd);\n\n    gicd->base_address = memmap[VIRT_GIC_DIST].base;\n\n    gicd->version = guest_info->gic_version;\n\n\n\n    for (i = 0; i < guest_info->smp_cpus; i++) {\n\n        AcpiMadtGenericInterrupt *gicc = acpi_data_push(table_data,\n\n                                                     sizeof *gicc);\n\n        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(i));\n\n\n\n        gicc->type = ACPI_APIC_GENERIC_INTERRUPT;\n\n        gicc->length = sizeof(*gicc);\n\n        if (guest_info->gic_version == 2) {\n\n            gicc->base_address = memmap[VIRT_GIC_CPU].base;\n\n        }\n\n        gicc->cpu_interface_number = i;\n\n        gicc->arm_mpidr = armcpu->mp_affinity;\n\n        gicc->uid = i;\n\n        gicc->flags = cpu_to_le32(ACPI_GICC_ENABLED);\n\n\n\n        if (armcpu->has_pmu) {\n\n            gicc->performance_interrupt = cpu_to_le32(PPI(VIRTUAL_PMU_IRQ));\n\n        }\n\n    }\n\n\n\n    if (guest_info->gic_version == 3) {\n\n        AcpiMadtGenericTranslator *gic_its;\n\n        AcpiMadtGenericRedistributor *gicr = acpi_data_push(table_data,\n\n                                                         sizeof *gicr);\n\n\n\n        gicr->type = ACPI_APIC_GENERIC_REDISTRIBUTOR;\n\n        gicr->length = sizeof(*gicr);\n\n        gicr->base_address = cpu_to_le64(memmap[VIRT_GIC_REDIST].base);\n\n        gicr->range_length = cpu_to_le32(memmap[VIRT_GIC_REDIST].size);\n\n\n\n        if (its_class_name()) {\n\n            gic_its = acpi_data_push(table_data, sizeof *gic_its);\n\n            gic_its->type = ACPI_APIC_GENERIC_TRANSLATOR;\n\n            gic_its->length = sizeof(*gic_its);\n\n            gic_its->translation_id = 0;\n\n            gic_its->base_address = cpu_to_le64(memmap[VIRT_GIC_ITS].base);\n\n        }\n\n    } else {\n\n        gic_msi = acpi_data_push(table_data, sizeof *gic_msi);\n\n        gic_msi->type = ACPI_APIC_GENERIC_MSI_FRAME;\n\n        gic_msi->length = sizeof(*gic_msi);\n\n        gic_msi->gic_msi_frame_id = 0;\n\n        gic_msi->base_address = cpu_to_le64(memmap[VIRT_GIC_V2M].base);\n\n        gic_msi->flags = cpu_to_le32(1);\n\n        gic_msi->spi_count = cpu_to_le16(NUM_GICV2M_SPIS);\n\n        gic_msi->spi_base = cpu_to_le16(irqmap[VIRT_GIC_V2M] + ARM_SPI_BASE);\n\n    }\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)(table_data->data + madt_start), \"APIC\",\n\n                 table_data->len - madt_start, 3, NULL, NULL);\n\n}\n", "idx": 25810, "substitutes": {"memmap": ["memorycache", "memstore", "poolmap", "poolstore", "memorydata", " memblock", "gramstore", "rammap", "poolshare", "dimmap", " memMap", "limbar", "memcap", "ramcap", "memcache", "Memlist", "memblock", "memorydown", "memlist", "imagecache", "memorybar", "memoryMap", "memorylist", "membar", "limcache", "dimhash", "gramhash", "memdata", "ramdata", "memorycap", "ramblock", "memMap", "limdown", "Memmap", "memshare", "memdown", " memdata", "gramshare", " memlist", "imagedown", "grammap", "imagemap", "memoryblock", "memorymap", "MemMap", "imagebar", "dimshare", "limmap", " memcap", "dimstore", "poolhash", "memhash"], "irqmap": ["irparray", "srqspace", "srquspace", "irwmap", "pirqmap", "irklist", "irkmap", "srqumap", "irqarray", "pirparray", "irquspace", "pirqblock", "srqlist", "srquconf", "irwspace", "irqlist", "pirqlist", "pirqarray", "srqmap", "irkarray", "srqconf", "irquconf", "irQblock", "irpmap", "irQlist", "irwconf", "irplist", "irQmap", "irqumap", "pirpblock", "irqulist", "irqconf", "irqblock", "irpblock", "pirplist", "irqspace", "pirpmap", "irkblock", "irQarray", "irkconf", "srqulist", "irkspace", "irwlist"], "madt": ["jadty", "mandtt", "midtor", "mingtt", "aidT", "madty", "madts", "madtu", "medten", "mandt", "midt", "madtor", "midtu", "mrtt", "madT", "adt", " madts", " madta", "medty", "mrt", "mrten", "aidt", "medtt", "midtt", "mandtu", "aidta", "jadtt", "mingtor", "mandtor", "madtt", "adta", "jadt", "madta", "adT", "mingt", "jadten", "medt", "adts", "mrty", " madT", "aidts", "mingtu", "madten"], "gicd": ["gaicdi", "picdi", "gacn", "gessdi", " gicf", "gicandn", "gaccd", "gicn", "gicst", "gixdh", "giccdl", "gicitd", "gircdd", "gicdn", "giacdl", "giscd", "gicsl", "gaicd", " gict", "egicitdt", "gicdi", " grict", " gisct", " gicl", "gixsd", "giccdn", "gricc", "giccdd", " gikdn", "ogicdh", "giccds", "giacds", "gicdb", "gisct", "gicitdh", " gikd", "Gacds", "gircd", "gicdl", "gicitdd", "giscdd", "gessdd", " gikcd", "gicandt", "gizc", "gicu", "giccd", "Gicd", "egicitsd", "ogicitdh", "gicansd", "giscf", "gizl", "giccu", " giscds", "gizd", "gicancd", "gicandb", "gicand", "gicdh", "Gicn", "gicandd", "gacf", "giaccd", "gikd", "gicdd", "Gacn", "gicitdt", "gixdt", "gikdn", "gircdb", " giscd", " gicdn", "giacd", " gicds", "picu", " gricd", "gicccd", "gicds", "Gacd", "gicsc", "egicd", "gicitdb", " gaicd", "ogicdb", " gicdl", "ogicitdb", "giscu", "piscd", "grict", "gact", "egicdh", "egicdt", "gessd", "gircdh", "egicitd", "ogicdd", "giacdi", "giccdi", "piscdd", "gessu", "gicct", " giscf", " giccd", "Gaccd", "picdd", "gizt", "giccf", "ogicitdd", "gicdt", "gisccd", " gicdi", "Giccd", " gaicdl", "egicsd", "gicsd", "piscdi", "picd", "giscdi", "gricd", "gacd", "gicandh", " gricc", " gicdt", " gaicdi", "gricl", "Gicds", " gricl", "gicf", "gicl", "gaicdl", " gikdt", "gict", "ogicitd", "gikdt", "gixd", "giscds", "gicitsd", "gacds", "giscn", "giacn", "egicitdh", "gikcd", "giccdt", "ogicd", "piscu"], "gic_msi": ["gic__ansii", "gic__ansi", "gic_csd", "gic_ansb", "gic__msii", "gic__msb", "gic_msd", "gic_ksd", "gic_ansi", "gic_msii", "gic_csi", "gic_ansii", "gic_ksi", "gic__msi", "gic__ansb", "gic_ksii", "gic_msb", "gic__ansd", "gic__msd", "gic_ansd", "gic_csii", "gic_csb", "gic_ksb"], "i": ["idi", "gui", "abi", "slice", "k", "ski", "z", "yi", "p", "m", "b", "c", "name", "d", "uli", "x", "ti", "mi", "type", "phi", "qi", "it", "ri", "io", "id", "u", "udi", "e", "li", "gi", "ji", "zi", "multi", "xi", "s", "uri", "ii", "cli", "si", "bi", "di", "ni", "ini", "ci", "fi", "eni", "h", "I", "f", "chi", "mini", "n", "j", "ip", "index", "ki", "oi", "lo", "t", "iu", "v", "mu", "pi", "anti", "ui", "l", "hi"], "gicc": ["wci", "musc", "gusc", "rgirc", "geicc", "geirc", "genusc", "geci", "rgicc", "gib", "geniac", "kigg", " gisi", "genirc", "agica", "gausc", "agocl", "agirc", "kusc", "Girc", "gocl", "Gigg", "gaocl", " gosc", "genaic", "picc", "genisc", "rgitech", "agosc", "gairc", " gisc", "gaigg", "gosc", "igocl", "piac", "pci", "Giac", "Gocl", "gaicc", "igiac", "pusc", "gci", "agigg", " gigg", "agib", "maic", " gci", "agci", "genocl", "micc", "kirc", "igisi", "gica", "agicc", "Gib", "kicc", " giac", "rgigg", "igicc", "gaiac", "agusc", "gigg", "miac", "gifi", " gifi", "igifi", "agiac", "genigg", "genib", "wusc", "kiac", "wiac", "igib", "igusc", "gisc", "genisi", "genicc", "agisc", " gica", "gitech", " gib", "gisi", "Gitech", " gocl", "girc", "kitech", "Gicc", "genifi", "gaic", "giac", "gaosc", "wicc", " gusc", "igaic", "genica", "genci", "geib"], "armcpu": ["amcpu", "arggpu", "mpu", "mprocessor", "amchu", "ampc", "mgpu", "amprocessor", "ramgpu", "adjcpu", "ampu", "ramcpu", "armgpu", "mcgpu", "adjchu", "rampc", "mccpu", "ramCPU", "adjpc", "mcprocessor", "mCPU", "argpu", "mcpu", "armpu", "argcpu", "armpc", "argCPU", "armchu", "adjgpu", "armCPU", "amgpu", "rampu", "ramchu", "armprocessor"], "gic_its": ["glic_ins", "gic__ins", "glic_times", "gic_times", "gic__times", "gic__its", "glic_its", "gic_ins", "gic_ms", "gic__ms", "glic_ms"]}}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "static int vmdk_reopen_prepare(BDRVReopenState *state,\n\n                               BlockReopenQueue *queue, Error **errp)\n\n{\n\n    BDRVVmdkState *s;\n\n    int ret = -1;\n\n    int i;\n\n    VmdkExtent *e;\n\n\n\n    assert(state != NULL);\n\n    assert(state->bs != NULL);\n\n\n\n    if (queue == NULL) {\n\n        error_setg(errp, \"No reopen queue for VMDK extents\");\n\n        goto exit;\n\n    }\n\n\n\n    s = state->bs->opaque;\n\n\n\n    assert(s != NULL);\n\n\n\n    for (i = 0; i < s->num_extents; i++) {\n\n        e = &s->extents[i];\n\n        if (e->file != state->bs->file) {\n\n            bdrv_reopen_queue(queue, e->file, state->flags);\n\n        }\n\n    }\n\n    ret = 0;\n\n\n\nexit:\n\n    return ret;\n\n}\n", "idx": 17246, "substitutes": {"state": ["set", "stat", "session", "j", "code", "t", "data", "core", "element", "err", "f", "settings", "r", "pe", "str", "or", "ss", "scope", "slice", "manager", "self", "out", "is", "o", "State", "store", "parse", "sh", "new", "the", "seed", "style", "rule", "pse", "st", "config", "key", "start", "q", "k", "sync", "v", "private", "parent", "c", "STATE", "p", "address", "cache", "resource", "ace", "body", "local", "os", "er", "port", "se", "states", "a", "conn"], "queue": ["status", "group", "fp", "f", "pool", "buffer", "proxy", "r", "file", "job", "block", "Q", "manager", "Que", "ack", "array", "menu", "event", "ue", "pipe", "prefix", "q", "config", "buf", "sync", "v", "c", "seq", "lib", "line", "p", "que", "cache", "next", "route", "message", "sequence", "port", "server", "list", "command", "Queue", "callback", "progress", "collection"], "errp": [" errP", "ertp", " errcp", "err", "errP", "errpc", "rarps", "erpc", "rarp", "erp", " erp", "errr", " errr", "rrp", " erpc", "errps", "rrps", "rrcp", " errtp", " ertp", "rarP", " errps", "errtp", "rrP", "rarcp", " errpc", " err", "errcp"], "s": ["ns", "status", "spec", "m", "session", "sg", "ts", "bs", "stats", "rs", "f", "settings", "services", "ares", "service", "sb", "g", "ges", "sl", "ss", "ls", "as", "fs", "xs", "is", "o", "cs", "als", "l", "d", "su", "ins", "site", "qs", "ssl", "ses", "c", "ps", "si", "js", "p", "S", "b", "gs", "sys", "its", "es", "os", "us", "server", "states", "sq", "se", "ds", "u"], "i": ["ti", "uri", "gi", "wei", "m", "bi", "j", "ji", "t", "info", "x", "f", "err", "ini", "qi", "r", "io", "ai", "n", "phi", "g", "hi", "ii", "ie", "iu", "di", "ind", "index", "I", "multi", "zi", "o", "l", "adi", "d", "oi", "yi", "pi", "ui", "ci", "abi", "id", "v", "c", "ni", "si", "ri", "p", "xi", "b", "mu", "a", "eni", "fi", "esi", "y", "li", "u"], "e": ["E", "m", "ei", "eb", "element", "f", "ine", "fe", "eu", "pe", "ne", "n", "g", "em", "je", "ge", "ie", "entity", "en", "ae", "ee", "o", "ze", "l", "d", "ce", "ed", "pse", "ue", "ev", "ep", "be", "oe", "c", "ea", "ade", "p", "line", "ele", "ec", "er", "es", "edge", "end", "se", "me", "el", "esi"]}}
{"project": "qemu", "commit_id": "016d2e1dfa21b64a524d3629fdd317d4c25bc3b8", "target": 1, "func": "long do_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t target_set;\n\n    target_ulong r0;\n\n    int i;\n\n    int err = 0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask);\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        __get_user(target_set.sig[i], &frame->extramask[i - 1]);\n\n    }\n\n\n\n    if (err)\n\n        goto badframe;\n\n\n\n    target_to_host_sigset_internal(&blocked, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->sc, &r0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 26234, "substitutes": {"regs": ["regm", "signps", "pools", "REGses", "rols", "RegS", "regses", "regS", "signs", "regals", "roundfs", "lics", "rounds", "Regs", "gregals", " regps", "gregs", "Regds", "licm", "rolS", "Regses", "poolfs", "rolses", "regds", "rolds", "REGs", "poolals", "regps", " regm", "REGds", "roundals", "gregfs", "licps", "regfs", "REGS", "signm"], "frame": ["fram", "processor", "framework", "code", "element", "node", "thread", "slice", "fe", "zone", "parse", "position", "image", "function", "frames", "module", "buffer", "scene", "base", "raise", "component", "config", "feature", "hide", "version", "instance", "motion", "fr", "profile", "boot", "e", " Frame", "line", "point", "cfg", "message", "tick", "cpu", "object", "role", "sequence", "target", "setup", "cf", "fb", "fi", "channel", "fake", "game", "iframe", "update", "window", "f", "Frame", "host", "header", "event", "ace", "que", "connection", "file", "ze"], "frame_addr": ["frame_offset", "frame_ptr", "fram_ptr", " frame_adr", "fram_addr", " frame_address", "frame_oa", "fram_address", "frame_ord", "fram_ord", "frame_adr", " frame_ord", " frame_oa", "frame_address", " frame_offset"], "blocked": ["BLock", " bllocked", "Bllocked", "BLOCK", "bllocked", "clock", "clocking", "plocking", "pllocked", "plOCK", "BLlocked", "clocked", "cllocked", "Blocked", "plock", "Block", "BLocking", "blOCK", "BLocked", "Blocking", " block", " blocking", "BlOCK", "block", "plocked", "blocking"], "target_set": [" target_sync", "targetvalrun", "host_set", "target_clear", "message64clear", "target_sche", "message_sche", "targetvalsets", "targetssc", "component_sets", "message_clear", "target_switch", "message64sche", "target_site", "host_switch", "componentssets", "target_Set", "component_run", "targetvalset", "message_site", " target_Set", "target_run", "target64site", " target_sc", "message64set", "host_SET", "targetsset", "targetvalexport", "target_sc", "targetsSet", "component_export", "target_SET", "target64set", "componentsset", "component_set", "message_set", "target64clear", "host_setup", "target_sync", "message64site", "componentsexport", "target_setup", "targetssets", "targetsexport", "target_export", "target64sche", "target_sets", "targetsrun", "componentsrun", "targetssync"], "r0": ["Rloop", " r180", "result180", "r1", " r1", "rr0", "x0", "x1", "R2", "result0", " r2", "r180", "result1", "r2", "rr1", "rr180", "R0", "sr1", "xloop", "srloop", "sr0", "return2", "rloop", "return0", "return1", "R1"], "i": ["code", "z", "yi", "p", "b", "m", "c", "ie", "page", "d", "x", "ti", "qi", "it", "ri", "io", "id", "ui", "u", "e", "key", "li", "gi", "o", "zi", "err", "multi", "xi", "uri", "start", "ii", "cli", "si", "ai", "bi", "ni", "ini", "di", "ci", "fi", "length", "part", "I", "f", "y", "oi", "n", "j", "ip", "index", "a", "v", "iu", "r", "pi", "ind", "mu", "l", "hi", "in"]}}
{"project": "FFmpeg", "commit_id": "ecb14b8af73b92e5a1be47c119d2f528ff402ebd", "target": 0, "func": "static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){\n\n    MpegEncContext * const s = &h->s;\n\n    AVCodecContext * const avctx= s->avctx;\n\n    H264Context *hx; ///< thread context\n\n    int buf_index;\n\n    int context_count;\n\n    int next_avc;\n\n    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);\n\n    int nals_needed=0; ///< number of NALs that need decoding before the next frame thread starts\n\n    int nal_index;\n\n\n\n    h->nal_unit_type= 0;\n\n\n\n    h->max_contexts = (HAVE_THREADS && (s->avctx->active_thread_type&FF_THREAD_SLICE)) ? avctx->thread_count : 1;\n\n    if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){\n\n        h->current_slice = 0;\n\n        if (!s->first_field)\n\n            s->current_picture_ptr= NULL;\n\n        ff_h264_reset_sei(h);\n\n    }\n\n\n\n    for(;pass <= 1;pass++){\n\n        buf_index = 0;\n\n        context_count = 0;\n\n        next_avc = h->is_avc ? 0 : buf_size;\n\n        nal_index = 0;\n\n    for(;;){\n\n        int consumed;\n\n        int dst_length;\n\n        int bit_length;\n\n        uint8_t *ptr;\n\n        int i, nalsize = 0;\n\n        int err;\n\n\n\n        if(buf_index >= next_avc) {\n\n            if (buf_index >= buf_size - h->nal_length_size) break;\n\n            nalsize = 0;\n\n            for(i = 0; i < h->nal_length_size; i++)\n\n                nalsize = (nalsize << 8) | buf[buf_index++];\n\n            if(nalsize <= 0 || nalsize > buf_size - buf_index){\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"AVC: nal size %d\\n\", nalsize);\n\n                break;\n\n            }\n\n            next_avc= buf_index + nalsize;\n\n        } else {\n\n            // start code prefix search\n\n            for(; buf_index + 3 < next_avc; buf_index++){\n\n                // This should always succeed in the first iteration.\n\n                if(buf[buf_index] == 0 && buf[buf_index+1] == 0 && buf[buf_index+2] == 1)\n\n                    break;\n\n            }\n\n\n\n            if(buf_index+3 >= buf_size) break;\n\n\n\n            buf_index+=3;\n\n            if(buf_index >= next_avc) continue;\n\n        }\n\n\n\n        hx = h->thread_context[context_count];\n\n\n\n        ptr= ff_h264_decode_nal(hx, buf + buf_index, &dst_length, &consumed, next_avc - buf_index);\n\n        if (ptr==NULL || dst_length < 0){\n\n            return -1;\n\n        }\n\n        i= buf_index + consumed;\n\n        if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc &&\n\n           buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0)\n\n            s->workaround_bugs |= FF_BUG_TRUNCATED;\n\n\n\n        if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){\n\n        while(dst_length > 0 && ptr[dst_length - 1] == 0)\n\n            dst_length--;\n\n        }\n\n        bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1));\n\n\n\n        if(s->avctx->debug&FF_DEBUG_STARTCODE){\n\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"NAL %d/%d at %d/%d length %d pass %d\\n\", hx->nal_unit_type, hx->nal_ref_idc, buf_index, buf_size, dst_length, pass);\n\n        }\n\n\n\n        if (h->is_avc && (nalsize != consumed) && nalsize){\n\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"AVC: Consumed only %d bytes instead of %d\\n\", consumed, nalsize);\n\n        }\n\n\n\n        buf_index += consumed;\n\n        nal_index++;\n\n\n\n        if(pass == 0) {\n\n            // packets can sometimes contain multiple PPS/SPS\n\n            // e.g. two PAFF field pictures in one packet, or a demuxer which splits NALs strangely\n\n            // if so, when frame threading we can't start the next thread until we've read all of them\n\n            switch (hx->nal_unit_type) {\n\n                case NAL_SPS:\n\n                case NAL_PPS:\n\n                    nals_needed = nal_index;\n\n                    break;\n\n                case NAL_IDR_SLICE:\n\n                case NAL_SLICE:\n\n                    init_get_bits(&hx->s.gb, ptr, bit_length);\n\n                    if (!get_ue_golomb(&hx->s.gb))\n\n                        nals_needed = nal_index;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        //FIXME do not discard SEI id\n\n        if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc  == 0)\n\n            continue;\n\n\n\n      again:\n\n        err = 0;\n\n        switch(hx->nal_unit_type){\n\n        case NAL_IDR_SLICE:\n\n            if (h->nal_unit_type != NAL_IDR_SLICE) {\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"Invalid mix of idr and non-idr slices\");\n\n                return -1;\n\n            }\n\n            idr(h); // FIXME ensure we don't lose some frames if there is reordering\n\n        case NAL_SLICE:\n\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n\n            hx->intra_gb_ptr=\n\n            hx->inter_gb_ptr= &hx->s.gb;\n\n            hx->s.data_partitioning = 0;\n\n\n\n            if((err = decode_slice_header(hx, h)))\n\n               break;\n\n\n\n            if (   h->sei_recovery_frame_cnt >= 0\n\n                && ((h->recovery_frame - h->frame_num) & ((1 << h->sps.log2_max_frame_num)-1)) > h->sei_recovery_frame_cnt) {\n\n                h->recovery_frame = (h->frame_num + h->sei_recovery_frame_cnt) %\n\n                                    (1 << h->sps.log2_max_frame_num);\n\n            }\n\n\n\n            s->current_picture_ptr->f.key_frame |=\n\n                    (hx->nal_unit_type == NAL_IDR_SLICE);\n\n\n\n            if (h->recovery_frame == h->frame_num) {\n\n                h->sync |= 1;\n\n                h->recovery_frame = -1;\n\n            }\n\n\n\n            h->sync |= !!s->current_picture_ptr->f.key_frame;\n\n            h->sync |= 3*!!(s->flags2 & CODEC_FLAG2_SHOW_ALL);\n\n            s->current_picture_ptr->sync = h->sync;\n\n\n\n            if (h->current_slice == 1) {\n\n                if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) {\n\n                    decode_postinit(h, nal_index >= nals_needed);\n\n                }\n\n\n\n                if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0)\n\n                    return -1;\n\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                    ff_vdpau_h264_picture_start(s);\n\n            }\n\n\n\n            if(hx->redundant_pic_count==0\n\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n\n               && avctx->skip_frame < AVDISCARD_ALL){\n\n                if(avctx->hwaccel) {\n\n                    if (avctx->hwaccel->decode_slice(avctx, &buf[buf_index - consumed], consumed) < 0)\n\n                        return -1;\n\n                }else\n\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){\n\n                    static const uint8_t start_code[] = {0x00, 0x00, 0x01};\n\n                    ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code));\n\n                    ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed], consumed );\n\n                }else\n\n                    context_count++;\n\n            }\n\n            break;\n\n        case NAL_DPA:\n\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n\n            hx->intra_gb_ptr=\n\n            hx->inter_gb_ptr= NULL;\n\n\n\n            if ((err = decode_slice_header(hx, h)) < 0)\n\n                break;\n\n\n\n            hx->s.data_partitioning = 1;\n\n\n\n            break;\n\n        case NAL_DPB:\n\n            init_get_bits(&hx->intra_gb, ptr, bit_length);\n\n            hx->intra_gb_ptr= &hx->intra_gb;\n\n            break;\n\n        case NAL_DPC:\n\n            init_get_bits(&hx->inter_gb, ptr, bit_length);\n\n            hx->inter_gb_ptr= &hx->inter_gb;\n\n\n\n            if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning\n\n               && s->context_initialized\n\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n\n               && avctx->skip_frame < AVDISCARD_ALL)\n\n                context_count++;\n\n            break;\n\n        case NAL_SEI:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            ff_h264_decode_sei(h);\n\n            break;\n\n        case NAL_SPS:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            if(ff_h264_decode_seq_parameter_set(h) < 0 && (h->is_avc ? (nalsize != consumed) && nalsize : 1)){\n\n                av_log(h->s.avctx, AV_LOG_DEBUG, \"SPS decoding failure, trying alternative mode\\n\");\n\n                if(h->is_avc) av_assert0(next_avc - buf_index + consumed == nalsize);\n\n                init_get_bits(&s->gb, &buf[buf_index + 1 - consumed], 8*(next_avc - buf_index + consumed));\n\n                ff_h264_decode_seq_parameter_set(h);\n\n            }\n\n\n\n            if (s->flags& CODEC_FLAG_LOW_DELAY ||\n\n                (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))\n\n                s->low_delay=1;\n\n\n\n            if(avctx->has_b_frames < 2)\n\n                avctx->has_b_frames= !s->low_delay;\n\n            break;\n\n        case NAL_PPS:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n\n\n            ff_h264_decode_picture_parameter_set(h, bit_length);\n\n\n\n            break;\n\n        case NAL_AUD:\n\n        case NAL_END_SEQUENCE:\n\n        case NAL_END_STREAM:\n\n        case NAL_FILLER_DATA:\n\n        case NAL_SPS_EXT:\n\n        case NAL_AUXILIARY_SLICE:\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\", hx->nal_unit_type, bit_length);\n\n        }\n\n\n\n        if(context_count == h->max_contexts) {\n\n            execute_decode_slices(h, context_count);\n\n            context_count = 0;\n\n        }\n\n\n\n        if (err < 0)\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n\n        else if(err == 1) {\n\n            /* Slice could not be decoded in parallel mode, copy down\n\n             * NAL unit stuff to context 0 and restart. Note that\n\n             * rbsp_buffer is not transferred, but since we no longer\n\n             * run in parallel mode this should not be an issue. */\n\n            h->nal_unit_type = hx->nal_unit_type;\n\n            h->nal_ref_idc   = hx->nal_ref_idc;\n\n            hx = h;\n\n            goto again;\n\n        }\n\n    }\n\n    }\n\n    if(context_count)\n\n        execute_decode_slices(h, context_count);\n\n    return buf_index;\n\n}\n", "idx": 19724, "substitutes": {"h": ["m", "ch", "j", "t", "eh", "f", "oh", "hist", "hr", "g", "gh", "hi", "hd", "rh", "th", "ctx", "uh", "o", "han", "home", "host", "l", "d", "hw", "header", "ht", "sh", "w", "hl", "e", "q", "handler", "bh", "v", "ih", "c", "history", "hp", "p", "hm", "b", "http", "hh", "ph", "ha", "hs", "he", "ah", "H", "u"], "buf": ["Buffer", "grad", "br", "grab", "ff", "code", "data", "text", "pool", "buffer", "rc", "vec", "cf", "cb", "bc", "src", "Buff", "wb", "ctx", "pb", "context", "header", "begin", "conv", "box", "img", "queue", "config", "buff", "batch", "v", "map", "fb", "cur", "rb", "seq", "cmd", "uc", "que", "b", "cmp", "cap", "output", "alloc", "port", "bag", "uf", "bus", "cv", "input"], "buf_size": ["buf_sync", " buf_number", "buf_scale", "queue_size", "buf0number", "bufjsize", "buf_length", "queue_length", "buf_source", " buf_offset", " buf_scale", "buf0size", "queue_index", " buf_sync", "bufjnumber", "buf_loc", " buf_SIZE", "queue_count", "buf_offset", " buf_source", "buf0index", "buf_SIZE", "buf_number", "bufjoffset", "buf0offset", " buf_loc", "bufjindex", "buf_count"], "s": ["ns", "spec", "settings", "op", "service", "ss", "cs", "d", "sh", "qs", "cli", "p", "resource", "us", "sa", "input", "m", "sup", "ts", "sg", "rs", "in", "o", "share", "setup", "su", "sc", "v", "si", "S", "hs", "ds", "f", "sv", "r", "sb", "ys", "l", "network", "w", "sync", "c", "ps", "sci", "b", "sys", "es", "sq", "sf", "session", "t", "conf", "services", "n", "g", "sl", "ls", "ctx", "fs", "xs", "is", "site", "sch", "e", "ssl", "ses", "client", "js", "support", "http", "gs", "storage", "server", "u"], "avctx": ["evcmp", "avectx", "afcmp", "AVscl", "avconfig", "AVconfig", "afcu", "evscl", "broadcmp", "avcb", " avcb", "avecu", "broadcci", "AVcmp", "afcontext", "afctx", "abctx", "abcu", "evctx", "broadctx", "abcontext", "abcmp", "afcb", "afconfig", "avconf", "AVconf", "avscl", "broadcontext", " avscl", "abconfig", "AVcci", " avcmp", "avecontext", " avconfig", "afcci", "avcci", "AVctx", " avcontext", "afconf", "avecmp", "AVcontext", "avcmp", " avconf", "avcu", "avcontext", "evconf", "abcb"], "hx": ["phxc", "phct", "rhct", "rhtx", "phtx", "rhx", "rhxc", " hct", "hxc", "hct", "phx", " htx", "htx", " hxc"], "buf_index": ["fp00number", "bufPind", "buf_ini", "bufCdefault", "uf_update", "fp00ind", "fp00index", "bufamIndex", "fb_ini", "buf_body", "bufCdate", "buf_handle", "buflexcount", "uf_Index", "bufamcondition", "buf00site", "uf_index", "queue_size", "fp_prefix", "bufamnumber", "bufPdiff", "buf00size", "bufallnumber", "bufPsite", "buf_condition", "seq_site", "buflexbody", "seqPprefix", "bufPcount", "buf_length", "buf00index", "buf0type", "queue_label", "buf_label", "buf1index", "buf_inc", "fp_ind", "fp_index", "buflexheight", "uf_prefix", "queue_length", "buf1site", "vecPdiff", "buf64index", "bufallprefix", "buffer_size", "seqPind", "seq_index", "buf_site", "buf00number", "vecPcount", "bufamindex", "fp_number", "buf0size", "bufMsite", "buf00prefix", "cv_site", "buf64count", "cv_index", "vecPinc", "queue_index", "buffer_height", "bufallind", "buf_date", "bufMsize", "bufsindex", "seqPsite", "uf_body", "bufMindex", "fb_index", "buffer_index", "bufallindex", "seq_prefix", "buf1ind", "bufPprefix", "buf00label", "buf00length", "buf_ind", "buf1prefix", "bufamprefix", "bufamind", "bufamsite", "fp00prefix", "bufCindex", "buf_height", "buflexindex", "buf_prefix", "bufamsize", "cv_size", "bufPindex", "buf64diff", "bufCini", "buf64inc", "buf_default", "fb_date", "buf0inc", "seq_ind", "buf0index", "bufMhandle", "buf_diff", "uf_size", "buflexsize", "vec_inc", "bufamhandle", "bufsupdate", "buf00ind", "buflexupdate", "buf_number", "vecPindex", "bufPinc", "vec_diff", "buf_type", "buf_Index", "uf_condition", "vec_index", "queue_inc", "bufsbody", "cv_handle", "seqPindex", "buffer_count", "vec_count", "queue_type", "buf_update", "bufssize", "buf_count", "fb_default"], "context_count": [" contextsnum", "contextslimit", "context0group", "context__group", "contextalllimit", " context_num", "context_number", "contextfcount", "contextfnumber", "contextslen", "contextfsize", "context__number", " context0count", " contextscount", "context_len", " context0size", "contextscount", "contextsnum", "context_group", "context_size", "context0size", "contextallcount", " context_group", "context0number", "contextalllen", " context_size", "contextfgroup", " context0number", " context_number", " contextslimit", " context0group", "context0count", " context_limit", " contextslen", " context_len", "context__size", "context_num", "context_limit", "context__count", "contextallnum"], "next_avc": ["next_awcu", "next_afarc", "next_alp", "next_avepc", "next_awc", "next_afcu", "next_awci", "next_AVrc", "next_avci", "next_AVac", "next_ajc", "next_aff", "next_alc", "next_alci", "next_ajrc", "next_averc", "next_avep", "next_afcs", "next_umci", "next_afc", "next_avlc", "next_umcu", "next_awcs", "next_afci", "next_avf", "next_afrc", "next_awarc", "next_afp", "next_ajlc", "next_awp", "next_umc", "next_allc", "next_ajac", "next_avef", "next_calp", "next_aflc", "next_afpc", "next_umarc", "next_avarc", "next_avpc", "next_avp", "next_avec", "next_calci", "next_avac", "next_calc", "next_aveci", "next_avcu", "next_AVlc", "next_avecs", "next_ajf", "next_ajpc", "next_AVc", "next_avrc", "next_afac", "next_avcs", "next_callc"], "nal_index": ["nals_index", "nal_size", "nals_type", "naler_size", "nals_count", "nal_i", "naler_Index", "nal_count", "nal_type", "naler_i", "nals_Index", "naler_index", "nal_Index"], "pass": ["process", "skip", "j", "code", "rupt", "push", "call", "thread", "feed", "PASS", "acc", "result", "sw", "match", "ass", "run", "pos", "password", "act", "fast", "parse", "step", "fail", "flow", "ride", "pull", "sc", "cr", "parent", "catch", "strip", "post", "stage", "access", "test", "gen", "level", "proc", "loop", "row", "Pass", "port", "asses", "miss", "scan", "section", "success"], "consumed": [" unconserved", "cosensus", "coserved", "resumption", "cosumed", "conserved", "resensus", " unconsumption", "consumption", " unconsumed", "reserved", "cosumption", "consensus", " unconsensus", "resumed"], "dst_length": ["dst___address", "dst_long", "dbl_length", "dst_len", "dst___length", "dbl_long", "dst___len", "dbl_len", "dst___long", "dst_address", "dbl_address"], "bit_length": ["bit___width", "bit_limit", "bit___limit", "byte_width", "bit___len", "byte_length", "bit___length", "bit_width", "byte_limit", "bit_len", "byte_len"], "ptr": ["grad", "code", "tr", "data", "buffer", "rc", "vec", "str", "src", "loc", "slice", "pos", "dim", "pointer", "val", "fd", "buff", "seq", "pad", "cmp", "alloc", "proc", "addr", "port", "desc", "attr", "pt"], "i": ["gi", "ti", "uri", "bi", "j", "ji", "info", "x", "f", "jit", "ini", "qi", "io", "ai", "n", "phi", "mi", "z", "ii", "di", "index", "slice", "mini", "iu", "I", "multi", "zi", "ip", "chi", "l", "d", "pi", "ui", "ci", "id", "e", "ni", "si", "ki", "ri", "p", "xi", "uli", "eni", "fi", "attr", "li", "len"], "err": ["rx", "init", "frac", "code", "f", "result", "pack", " res", "in", "pos", "resp", "def", " errors", " arr", "found", " error", "comp", "aa", "e", "ea", "error", " rc", "res", " r", " success", "inner", "success"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int check_prot(int prot, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n    if (access_type == ACCESS_CODE) {\n\n        if (prot & PAGE_EXEC) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else if (rw) {\n\n        if (prot & PAGE_WRITE) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    } else {\n\n        if (prot & PAGE_READ) {\n\n            ret = 0;\n\n        } else {\n\n            ret = -2;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24508, "substitutes": {"prot": ["het", "txt", "primary", "ht", "np", "termin", "p", "pt", "server", "cot", "test", "api", "prop", "config", "pointer", "rin", "att", "type", "prefix", "port", "inet", "platform", "typ", "python", "pb", "eth", "repl", "flat", "rot", "bot", "ptr", "pred", "pat", "Prot", "addr", "transfer", "rect", "pro", "ext", "ocol", "tf", "tp", "php", "t", "fp", "sil", "pre", "reset", "rog"], "rw": ["ru", "w", "rou", "ww", "wb", "usr", "rn", "wo", "sw", "rf", "rb", "wh", "rus", "wrap", "wx", "rss", "hw", "iw", "work", "rh", "rew", "wer", "wl", "fw", "worker", "wit", "rc", "tw", "ro", "rack", "wp", "wal", "nw", "rx", "wr", "RW", "r", "wa", "rog"], "access_type": [" access_style", "accesstypetype", " access_resource", "accessingtype", "accessingpolicy", "access_types", "accesstyperesource", " access_types", "accessingname", "accesstypestyle", "access_resource", "access_name", "access_policy", " access_name", "access__key", " access_key", "access_style", "accessingkey", "access__type", "access__policy", " access_policy", "access__name", "access_key", "accesstypetypes"], "ret": ["std", "ref", "code", "ft", "res", "final", "cat", "flag", "data", "back", "base", "hard", "success", "opt", "def", "error", "pass", "id", "num", "rets", "al", "mem", "grad", "str", "mt", "lit", "det", "rev", "RET", "fit", "re", "art", "nt", "reply", "let", "feat", "req", "pat", "arg", "Ret", "rt", "part", "ext", "alt", "reg", "resp", "t", "match", "result", "len", "val", "gt", "fun"]}}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25459, "substitutes": {"env": ["exec", " en", "txt", "NV", "her", "obj", "code", "console", "np", "er", "this", "scope", "exc", "app", "server", "engine", "ass", "context", "manager", "enable", "enc", "me", "data", "ec", "en", "config", "conf", "Environment", "export", "style", "global", "priv", "dict", "ev", "loader", "ea", "end", "environment", "proc", "self", "ne", "db", "buf", "e", "site", "el", "extra", "err", "cdn", "viron", "dev", "ctx", "eu", "eni", "cache", "erv", "external", "esp", "ext", "nw", "conn", "net", "core", "event", " environment", "nc", "que", "et", " environments", "eng"], "mem_buf": ["memalprim", "mem0buffer", "sm_raf", "mem_coord", "Mem_coord", "Mem_done", "sm_buf", "mem_bu", "memingbuf", "memalhor", "mem0hor", " mem_fd", "mem_prim", "mem_begin", "Mem_buf", "memingbuffer", "mem_fd", "sm_begin", "Mem_buffer", " mem_prim", "memmemvec", "mem_bag", "memmembuff", "mem_brace", "memalbuf", "mem_done", "mem_buffer", "mem_vec", "memmemdone", "Mem_brace", " mem_buff", "memmembuf", " mem_hor", "Mem_bu", "mem0prim", "sm_bu", "memalbuffer", "Mem_vec", "mem_raf", "Mem_buff", "mem_buff", "Mem_bag", "mem_hor", " mem_buffer", "memingfd", "mem0buf", "memingbuff"], "n": ["node", "np", "k", "w", "z", "i", "sn", "m", "b", "c", "name", "ns", "p", "d", "pn", "x", "or", "fn", "en", "no", "on", "nn", "config", " N", "num", "self", "ne", "u", "all", "nor", "e", "o", "s", "nb", "ni", "nt", "cn", "number", "N", "f", "y", "nr", "network", "j", "nw", "t", "un", "conn", "an", "net", "v", "nu", "r", "in", "nc", "l", "len", "nat"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void phys_page_set(AddressSpaceDispatch *d,\n\n                          target_phys_addr_t index, target_phys_addr_t nb,\n\n                          uint16_t leaf)\n\n{\n\n    /* Wildly overreserve - it doesn't matter much. */\n\n    phys_map_node_reserve(3 * P_L2_LEVELS);\n\n\n\n    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n\n}\n", "idx": 6033, "substitutes": {"d": ["D", "dy", "dm", "od", "md", "bd", "ded", "dn", "dd", "dat", "dos", "pd", "dh", "ad", "dx", "dad", "db", "e", "dp", "da", "driver", "ds", "dc", "df", "xd", "t", "p", "did", "ld", "c", "ind", "fd", "gd", "dl", "dt", "cd", "dict"], "index": ["base", "address", "axis", "position", "iter", "block", "bin", "id", "count", "fee", "note", "config", "i", "info", "loc", "route", "inc", "num", "offset", "f", "url", "loop", "byte", "len", "part", "uri", "depth", "batch", "pos", "start", "level", "node", "ind", "ln", "ld", "Index", "ref", "addr", "end", "prefix"], "nb": ["uni", "base", "bp", "lb", "buff", "ib", "bin", "bd", "nn", "fee", "nob", "note", "quad", "rb", "b", "bm", "bi", "wb", "db", "abb", "bb", "split", "eb", "sb", "lib", "timeout", "bc", "cb", "batch", "gb", "kb", "aff", "node", "bf", "NB", "bn", "seed", "nd", "slot"], "leaf": ["abc", "layer", "lb", "flag", "inf", "parent", "nn", "quad", "ignore", "pattern", "children", "fff", "offset", "f", "child", "abb", " Leaf", "cc", "loop", "split", "lib", "kid", "bc", "nil", "urse", "root", "batch", "level", "node", "ld", "tree", "bf", "lv", "lc", "slot", "ref", "lf", "af"]}}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void vnc_client_cache_addr(VncState *client)\n\n{\n\n    Error *err = NULL;\n\n\n\n    client->info = g_malloc0(sizeof(*client->info));\n\n    client->info->base = g_malloc0(sizeof(*client->info->base));\n\n    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,\n\n                                         &err);\n\n    if (err) {\n\n        qapi_free_VncClientInfo(client->info);\n\n        client->info = NULL;\n\n        error_free(err);\n\n    }\n\n}\n", "idx": 10370, "substitutes": {"client": ["parent", "session", "connect", "http", "container", "config", "ace", "code", "call", "contract", "ce", "connection", "content", "remote", "end", "port", "get", "help", "gu", "prefix", "open", "i", "con", "c", "close", "app", "request", "gui", "current", "callback", "friend", "plugin", "sim", "build", "common", "cell", "secure", "conn", "public", "game", "my", "project", "Client", "data", "util", "cli", "local", "cod", "host", "resource", "new", "custom", "cat", "command", "use", "cache", "core", "co", "start", "comment", "win", "update", "service", "server", "private", "manager", "child", "name", "user", "address", "pc", "cm", "api", "clean", "ci"], "err": ["cr", "acer", "conf", "ler", "arr", "str", "n", "rage", "conn", "fr", "mr", "rr", "erer", "kr", "cer", "gr", "ver", "i", "var", "fy", "Error", "e", "cb", "ace", "ir", "aster", "bug", "rs", "er", "lr", "dr", "found", "res", "finder", "msg", "ind", "order", "ar", "r", "req", "ise", "cor", "error", "here", "rar", "sys", "cfg", "orer", "der", "rx", "dev", "result", "fee", "Er", "sr", "resp", "rh", "fi", "runner"]}}
{"project": "FFmpeg", "commit_id": "d1a58afb95f68c5375b4a7556317d835108509ed", "target": 1, "func": "static int latm_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    PutBitContext bs;\n\n    int i, len;\n\n    uint8_t loas_header[] = \"\\x56\\xe0\\x00\";\n\n    uint8_t *buf = NULL;\n\n\n\n    if (s->streams[0]->codec->codec_id == CODEC_ID_AAC_LATM)\n\n        return ff_raw_write_packet(s, pkt);\n\n\n\n    if (pkt->size > 2 && pkt->data[0] == 0xff && (pkt->data[1] >> 4) == 0xf) {\n\n        av_log(s, AV_LOG_ERROR, \"ADTS header detected - ADTS will not be incorrectly muxed into LATM\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (pkt->size > 0x1fff)\n\n        goto too_large;\n\n\n\n    buf = av_malloc(pkt->size+1024);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    init_put_bits(&bs, buf, pkt->size+1024);\n\n\n\n    latm_write_frame_header(s, &bs);\n\n\n\n    /* PayloadLengthInfo() */\n\n    for (i = 0; i <= pkt->size-255; i+=255)\n\n        put_bits(&bs, 8, 255);\n\n\n\n    put_bits(&bs, 8, pkt->size-i);\n\n\n\n    /* The LATM payload is written unaligned */\n\n\n\n    /* PayloadMux() */\n\n    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {\n\n        // Convert byte-aligned DSE to non-aligned.\n\n        // Due to the input format encoding we know that\n\n        // it is naturally byte-aligned in the input stream,\n\n        // so there are no padding bits to account for.\n\n        // To avoid having to add padding bits and rearrange\n\n        // the whole stream we just remove the byte-align flag.\n\n        // This allows us to remux our FATE AAC samples into latm\n\n        // files that are still playable with minimal effort.\n\n        put_bits(&bs, 8, pkt->data[0] & 0xfe);\n\n        avpriv_copy_bits(&bs, pkt->data + 1, 8*pkt->size - 8);\n\n    } else\n\n        avpriv_copy_bits(&bs, pkt->data, 8*pkt->size);\n\n\n\n    avpriv_align_put_bits(&bs);\n\n    flush_put_bits(&bs);\n\n\n\n    len = put_bits_count(&bs) >> 3;\n\n\n\n    if (len > 0x1fff)\n\n        goto too_large;\n\n\n\n    loas_header[1] |= (len >> 8) & 0x1f;\n\n    loas_header[2] |= len & 0xff;\n\n\n\n    avio_write(pb, loas_header, 3);\n\n    avio_write(pb, buf, len);\n\n\n\n    av_free(buf);\n\n\n\n    return 0;\n\n\n\ntoo_large:\n\n    av_log(s, AV_LOG_ERROR, \"LATM packet size larger than maximum size 0x1fff\\n\");\n\n    av_free(buf);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 15125, "substitutes": {"s": ["south", "sys", "ses", "self", "bis", "service", "t", "d", "sg", "sync", "fs", "sym", "ches", "g", "cs", "qs", "S", "os", "sets", "js", "si", "sq", "session", "server", "v", "conf", "ss", "ps", "client", "o", "w", "u", "p", "e", "plugins", "socket", "http", "data", "b", "sf", "sb", "n", "f", "gs", "spec", "c", "ns", "xs", "is", "stats", "sc", "ssl", "sci", "sv", "sl", "ops", "services", "ds", "r", "sa", "su", "ls", "ubs", "space", "fts", "us", "support", "ts", "ks", "aws"], "pkt": ["spkt", "pet", "Pant", "pct", "pett", "facket", "ipet", "perkt", "spct", "cpkg", " pct", "fet", "ipcht", "Pct", "jacket", "spacket", "spelt", "pwk", "bqt", "pqt", "ppacket", " pant", "periece", "qcht", "psth", "pskt", "qacket", "Pet", "npkt", "bkt", " pqt", "ppelt", "fnt", " piece", "pcht", "npet", "npelt", "perwk", "jkt", "Piece", "cpet", "fkt", "Pkt", "Pcht", " pkg", "cpant", "Psth", "het", "macket", "Pwk", "mkt", "spnt", " pdt", "chcht", "hkt", " pet", " pnt", " pwk", " psth", "psct", "Pnt", "Pqt", "packet", "pant", "npacket", "ppkt", "hett", "backet", "jcht", "ppcht", " pett", "peracket", "fsth", "psdt", "Pett", "chet", "pnt", "bet", "tpacket", "fant", "chacket", "ipkt", "pelt", "piece", "pkg", "melt", "Packet", "chkt", "cpkt", "qkt", "tpelt", "qant", "pdt", "tpkt", "Pelt", "jelt", "met", "Pkg", "psacket", "spwk", "hacket", " pelt", "tpet", " pcht", "ipacket", "Pdt", "cpacket", " packet"], "pb": ["proc", "typ", "ses", "bc", "cv", "pc", "jp", "vp", "mp", "fb", "uf", "prot", "lc", "ub", "pg", "py", "lp", "fp", "ps", "platform", "bp", "pd", "np", "obj", "summary", "p", "rb", "bm", "plugins", "pl", "pa", "sb", "tc", "wb", "wp", "gb", "bh", "ab", "pm", "bps", "cb", "PB", "dp", "pro", "cpp", "db", "lb", "ppa", "fc", "tp", "ctx"], "bs": [" bc", "blocks", "tx", "bc", "qs", "bytes", "js", "boxes", "br", "ps", " cx", "base", "bf", "lines", "bps", "cb", "bas", "las", "bis", "fs", "ins", "g", "cs", " bos", "nos", "bus", "bp", "b", "bits", "ns", " fs", "outs", "bugs", "bi", "lb", "iss", "vals", "ks", "bid", "lbs", "BS", "pc", "fb", "os", "obs", "sb", "gb", "lins", "bu", "ls", "pos", "bl", "ctx", "BT", "ses", "bn", "BC", "its", "ros", "ss", "cks", "Bs", " ss", "gs", "bes", "ds", "css", "bos", "ts", "ubs", "us", "vs"], "i": ["hi", "qi", "ui", "adi", "I", "ai", "ni", "xi", "id", "ini", "iu", "gi", "inf", "io", "ci", "ki", "di", "x", "si", "ie", "ii", "uri", "col", "u", "ind", "z", "p", "e", "mini", "info", "fi", "mi", "li", "ix", "base", "multi", "j", "count", "b", "f", "phi", "ti", "line", "abi", "ip", "c", "is", "type", "ji", "pi", "field", "ri", "ami", "zi", "y", "in", "index", "start"], "len": ["vec", "en", "bin", "rev", "part", "lin", "non", "fl", "Len", "ni", "val", "lon", "l", "lan", "split", "lc", "fun", "low", "dl", "lang", "lit", "fat", "fn", "ld", "limit", "dy", "z", "size", "ll", "la", "lif", "fin", "lt", "li", "min", "length", "n", "lf", "ler", "count", "list", "ann", "line", "il", "lu", "nt", "body", "elt", "sl", "le", "all", "pos", "num", "el", "span", "ln", "lim"], "loas_header": ["loas2headers", "loas___gender", "loam_layer", "loas___header", "loas__table", "loac_table", "loas2layer", "loam_data", "loas___layer", "end", "loas_headers", "loas2gender", "loas__master", "loas_master", "loas__header", "loam_dr", "loas_dr", "at", "loam_header", "loac_headers", "r", "loas___headers", "loas_table", "loac_gender", "loas__layer", "loac_master", "loac_layer", "loas_gender", "_", "loas2header", "loac_header", "loas_layer", "loas_data", "all"], "buf": ["port", "vec", "ff", "pkg", "uc", "bc", "queue", "fd", "cv", "bid", "fl", "batch", "rc", "config", "bb", "fb", "bn", "home", "uf", "pool", "buffer", "lit", "fp", "bag", "loc", "v", "br", "buff", "feat", "rb", "data", "wb", "b", "box", "Buffer", "Buff", "block", "cb", "bo", "text", "cmd", "cf", "aux", "cache", "src", "seq", "cur", "bl", "ctx", "alloc", "fw"]}}
{"project": "qemu", "commit_id": "ef29a70d18c2d551cf4bb74b8aa9638caac3391b", "target": 0, "func": "void helper_tlb_update(uint32_t T0)\n\n{\n\n#if !defined(CONFIG_USER_ONLY)\n\n\tuint32_t vaddr;\n\n\tuint32_t srs = env->pregs[PR_SRS];\n\n\n\n\tif (srs != 1 && srs != 2)\n\n\t\treturn;\n\n\n\n\tvaddr = cris_mmu_tlb_latest_update(env, T0);\n\n\tD(printf(\"flush old_vaddr=%x vaddr=%x T0=%x\\n\", vaddr, \n\n\t\t env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));\n\n\ttlb_flush_page(env, vaddr);\n\n#endif\n\n}\n", "idx": 3256, "substitutes": {"T0": ["tFalse", "P0", " TFalse", "P1", "VT0", "T50", "Targ", "T2", "PT1", " T00", "t00", "t2", " T50", "t0", " T1", "t50", "PT2", "VTFalse", "VT1", "Parg", "t1", " Targ", "targ", "T00", "TFalse", "PT0", " T2", "PT50", "P00", "T1"], "vaddr": ["Vadd", "vwork", "verhost", "vhost", "svaddress", "faddress", " vadd", "verptr", "vaddress", "Vaddr", "paddress", "vadd", " vhost", "svaddr", "fwork", " vint", " vaddress", "svint", "vint", "paddr", "Vptr", "fhost", "fptr", "padd", " vwork", "Vaddress", "fint", "veraddress", "vptr", "svwork", "veraddr", "svhost", "faddr", "Vhost"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int roq_dpcm_encode_init(AVCodecContext *avctx)\n\n{\n\n    ROQDPCMContext *context = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be mono or stereo\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_rate != 22050) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be 22050 Hz\\n\");\n\n        return -1;\n\n    }\n\n    if (avctx->sample_fmt != AV_SAMPLE_FMT_S16) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Audio must be signed 16-bit\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->frame_size = ROQ_FIRST_FRAME_SIZE;\n\n\n\n    context->lastSample[0] = context->lastSample[1] = 0;\n\n\n\n    avctx->coded_frame= avcodec_alloc_frame();\n\n\n\n\n\n    return 0;\n\n}", "idx": 24631, "substitutes": {"avctx": ["AVlc", " avcv", "vercmp", "navcontext", "avcontext", "navctrl", "ajconn", "afcontext", "avectx", "avctl", "ajctx", "AVsync", "AVctrl", "camconn", "avdc", "avcv", "verlc", "AVcontext", "verctrl", "afsync", "avcoll", "avalloc", "afctrl", "avcca", "avcit", "versync", "evctl", "AVloc", "avalcontext", "avalctrl", " avloc", "camcontext", "avercontext", " avcmp", "averctrl", "afctx", "avalctx", "afca", "afgc", "avecoll", "avloc", "avctrl", " avctrl", "ajcit", "AVcas", "AVctx", "verctx", "AVctl", "aveca", "AVdc", "afcv", "AVgc", "avecontext", "evcontext", "AVconn", "avcmp", "verconn", "avsync", "avca", "evctx", "avecv", "aflc", "camctl", "avconn", "AVcit", "avalgc", "avaldc", "ajcontext", "AVcca", "averctx", "avalcca", "AVcoll", "avecca", "vercontext", " avca", " avcoll", "evconn", "avallc", "aveconn", "avedc", " avconn", "avgc", " avcontext", "camctx", "navcas", "avlc", "avcas", "vercit", "avercas", "navctx", "afcmp"], "context": ["sc", "subject", "package", "kernel", "acl", "scope", "driver", "definition", "parser", "document", "anc", "manager", "qa", "buffer", "data", "metadata", "text", "config", "component", "support", "address", "reader", "concept", "instance", "general", "aux", "resource", "input", "path", "object", "Context", "parent", "ctx", "cache", "channel", "current", "ca", "network", "index", "stack", "event", "memory", "container", "database", "result", "connection", "ce"]}}
{"project": "FFmpeg", "commit_id": "e3e6a2cff4af9542455d416faec4584d5e823d5d", "target": 1, "func": "static void create_default_qtables(uint8_t *qtables, uint8_t q)\n\n{\n\n    int factor = q;\n\n    int i;\n\n\n\n    factor = av_clip(q, 1, 99);\n\n\n\n    if (q < 50)\n\n        q = 5000 / factor;\n\n    else\n\n        q = 200 - factor * 2;\n\n\n\n    for (i = 0; i < 128; i++) {\n\n        int val = (default_quantizers[i] * q + 50) / 100;\n\n\n\n        /* Limit the quantizers to 1 <= q <= 255. */\n\n        val = av_clip(val, 1, 255);\n\n        qtables[i] = val;\n\n    }\n\n}\n", "idx": 22944, "substitutes": {"qtables": ["tables", "ktries", "table", "qries", "qtools", "ktables", "quantable", "iotabilities", "iotables", "qtries", "iotable", "quantions", "qtions", "qtabilities", "iotions", "questries", "tions", "tabilities", "questools", "ktools", "questables", "quantabilities", "qables", "ktable", "quantables", "qable", "qtable", "qools", "questable"], "q": ["col", "ix", "limit", "query", "qs", "qi", "ct", "scale", "g", "requ", "Q", "val", "force", "qq", "cl", "f", "r", "u", "qu", "bug", "quality", "p", "id", "max", "depth", "c", "ch", "dq", "w", "value", "question", "quant", "qa", "quest", "length", "iq", "req", "base", "range", "z", "qt", "v", "conf", "frequency", "quad", "l", "x", "factor", "sq", "k", "count"], "i": ["io", "ix", "e", "ie", "fi", "qi", "ri", "ind", "ui", "val", "part", "gi", "uri", "ti", "I", "f", "ci", "t", "phi", "u", "ini", "info", "it", "j", "lock", "ip", "p", "id", "o", "bi", "mi", "c", "index", "si", "b", "ii", "line", "n", "iu", "len", "ai", "xi", "base", "di", "v", "li", "pi", "x", "zi", "k", "ni", "count"]}}
{"project": "qemu", "commit_id": "fae38221e78fc9f847965f6d18b359b8044df348", "target": 1, "func": "static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)\n\n{\n\n    if (r < 0 || r > 15) {\n\n        fprintf(stderr, \"wrong register write $p%d\\n\", r);\n\n    }\n\n    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {\n\n        return;\n\n    } else if (r == PR_SRS) {\n\n        tcg_gen_andi_tl(cpu_PR[r], tn, 3);\n\n    } else {\n\n        if (r == PR_PID) {\n\n            gen_helper_tlb_flush_pid(cpu_env, tn);\n\n        }\n\n        if (dc->tb_flags & S_FLAG && r == PR_SPC) {\n\n            gen_helper_spc_write(cpu_env, tn);\n\n        } else if (r == PR_CCS) {\n\n            dc->cpustate_changed = 1;\n\n        }\n\n        tcg_gen_mov_tl(cpu_PR[r], tn);\n\n    }\n\n}\n", "idx": 2415, "substitutes": {"dc": ["dr", "fc", "DC", "ctx", "da", "dn", "roc", "ga", "anc", "context", "mc", "conn", "gc", "spec", "cc", "d", "ct", "tk", "nc", "dl", "bc", "director", "ea", "tc", "de", "cdn", "df", "dt", "cr", "ds", "ec", "abc", "c", "jc", "doc", "design", "dm", "draw", "oc", "ca", "ctrl", "cd", "vc", "cca", "cit", "cf", "cfg", "dat", "dp", "desc", "db", "rc"], "r": ["ur", "rg", "row", "w", " sr", " yr", "rs", "h", "rn", "wr", "rr", "d", "n", "ru", "type", "ry", " hr", "lr", " pr", "rf", "kr", "i", "j", "g", "rb", "m", "hr", "nr", "er", "ir", "err", "cr", "tr", "rev", "fr", "x", "l", "p", "pr", "c", "or", "e", "rl", "f", "ro", "attr", "ar", "br", "u", "R", "rd", "sr", "mr", "v", "rel", "o", "b", "rss", "t", "rx", "error", "rar", "re", "rt", "nor", "rh", "rc"], "tn": [" tr", "tun", " sr", "bn", "vt", "txt", "tu", "rn", "tty", " tw", "n", "tk", " priv", "tur", "ln", " ret", "pn", "hn", "tc", "zn", "fn", " cit", "span", " tid", "tp", "tw", "kt", "nr", "fp", "tx", " td", "ti", "dt", "TN", " reply", "kn", "tl", "btn", "isu", "cn", "token", "tt", "sn", "tm", "su", "nw", "t", " tu", " fn", "td", "nor", "rt", "qt", " TN", " rc", " args"]}}
{"project": "FFmpeg", "commit_id": "d1f3e475f9807b445ba37ff2fd23f71c4645de79", "target": 1, "func": "static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)\n\n{\n\n    int ret;\n\n    FailingMuxerPacketData *data = av_malloc(sizeof(*data));\n\n\n\n\n    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));\n\n    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));\n\n\n\n    pkt->pts = pkt->dts = pts;\n\n    pkt->duration = 1;\n\n\n\n    return ret;\n", "idx": 10520, "substitutes": {"pkt": ["hkt", "cpacket", "cpkg", " pet", " packet", "het", "bkt", "backet", "ppkt", " pkg", "mkg", "Pnt", "cpct", " pnt", "cpeth", "cpet", "Pkt", "cpnt", "Pet", "bnt", "hacket", "Pcht", "cpkt", "mkt", "packet", "bet", "ppacket", "ppcht", "pnt", "Pct", "Packet", "macket", "pcht", "hnt", " pct", "meth", " peth", "pct", "ppct", " pcht", "pkg", "peth", "pet"], "pkt_data": ["packet_data", "pkt_buffer", "packet_buffer", "packet_memory", "packet_parts", "packet_cache", "pkt_memory", "pkt_parts", "pkt_cache"], "pts": [" ptstats", "ntds", "ptments", "ntts", " ptss", "portds", "ptsets", " ptsstats", "cts", "ports", "portts", "ptd", "oints", "periodd", "ctts", "ctments", "periodts", "ntments", "ptds", "pullts", "ointstats", "ointss", "nts", "ntd", "ptss", " ptsets", " ptssets", "ptstats", "periods", "ctds", "pulld", "ptts", " ptsss", "pulls", "ointsets", "portments"], "ret": ["base", "valid", "flag", "ext", "len", "val", "alt", "def", "nt", "Ret", "t", "num", "reply", "lit", "obj", "status", "rets", "f", "code", "rt", "res", "bf", "det", "al", "fun", "att", "en", "part", "art", "eth", "fin", "cat", "re", "et", "RET", "back", "out", "result", "mt", "ft", "match", "rev", "flat", "fi", "success", "pet"], "data": ["parent", "map", "arr", "di", "base", "valid", "start", "media", "window", "pad", "da", "record", "missing", "d", "buf", "ad", "config", "p", "reader", "batch", "parts", "package", "ata", "ada", "addr", "memory", "array", "body", "DATA", "code", "dat", "resource", "zero", "size", "alpha", "slice", "input", "connection", "content", "current", "raw", "done", "address", "results", "dd", "new", "load", "Data", "part", "bus", "bytes", "message", "api", "a", "image", "cache", "result", "bin", "partial", "buffer"]}}
{"project": "FFmpeg", "commit_id": "03931ecf71710452fc9e89d4f18354f0b5e05395", "target": 0, "func": "static float ssim_plane(uint8_t *main, int main_stride,\n\n                        uint8_t *ref, int ref_stride,\n\n                        int width, int height, void *temp)\n\n{\n\n    int z = 0;\n\n    int x, y;\n\n    float ssim = 0.0;\n\n    int (*sum0)[4] = temp;\n\n    int (*sum1)[4] = sum0 + (width >> 2) + 3;\n\n\n\n    width >>= 2;\n\n    height >>= 2;\n\n\n\n    for (y = 1; y < height; y++) {\n\n        for (; z <= y; z++) {\n\n            FFSWAP(void*, sum0, sum1);\n\n            for (x = 0; x < width; x+=2)\n\n                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,\n\n                                &ref[4 * (x + z * ref_stride)], ref_stride,\n\n                                &sum0[x]);\n\n        }\n\n\n\n        ssim += ssim_endn(sum0, sum1, width - 1);\n\n    }\n\n\n\n    return ssim / ((height - 1) * (width - 1));\n\n}\n", "idx": 3274, "substitutes": {"main_stride": ["main_striides", "main_shrice", "main_striided", "main_trade", "main_shride", "main_strides", "main_strride", "main_drided", "main_stine", "main_bride", "main_shrides", "main_brride", "main_trride", "main_dride", "main_drides", "main_strided", "main_stides", "main_strice", "main_strade", "main_brice", "main_tride", "main_brine", "main_striide", "main_strine", "main_stade", "main_shrided", "main_stided", "main_striine", "main_brided", "main_drice", "main_trided", "main_brides", "main_brade", "main_stide"], "ref": ["ob", "base", "rib", "def", "ab", "url", "alt", "lf", "parent", "remote", "rf", "pre", "ef", "pos", "info", "source", "REF", "config", "bf", "fe", "Ref", "aff", "arc", "f", "red", "conf", "cache", "reference", "min", "range", "rel", "b", "review", "re", "lab", "part", "diff"], "ref_stride": ["ref_strided", "ref_striide", "ref_arride", "ref_strider", "ref_collided", "ref_divided", "ref_Strided", "ref_brider", "ref_strade", "ref_striided", "ref_strine", "ref_bride", "ref_divider", "ref_brided", "ref_collade", "ref_collite", "ref_Strides", "ref_brite", "ref_arrided", "ref_divide", "ref_arrider", "ref_Strider", "ref_arrade", "ref_arrine", "ref_brade", "ref_strides", "ref_Stride", "ref_brides", "ref_divides", "ref_arrite", "ref_striine", "ref_striider", "ref_brine", "ref_strite", "ref_collide"], "height": ["flow", "radius", "resolution", "level", "crop", "row", "build", "time", "above", "dim", "image", "window", "d", "zh", "weight", "distance", "id", "ty", "gap", "bottom", "lat", "dy", "direction", "hold", "style", "h", "alpha", "thin", "top", "hi", "w", "rank", "size", "length", "deep", "rows", "inches", "density", "center", "padding", "pull", "depth", "arrow", "img", "shape", "Height"], "temp": ["flow", "buffer", "local", "term", "flat", "vt", "txt", "form", "current", "cut", "wrap", "tc", "emp", "parent", "tmp", "i", "max", "tw", "m", "source", "fake", "Temp", "c", "p", "w", "size", "tem", "cache", "v", "prefix", "cel", "t", "clean", "wa", "pt", "white"], "x": ["xa", "cross", "yx", "any", "time", "a", "r", "d", "n", "ct", "px", "id", "im", "k", "xy", "i", "j", "max", "pos", "ady", "dx", "m", "tx", "lex", "X", "index", "xp", "xx", "h", "l", "p", "c", "xc", "w", "e", "f", "ax", "u", "ww", "el", "fx", "v", "b", "ix", "t", "rx", "wa", "sex", "xxx", "wy", "one", "ex", "my", "xi", "wx"], "y": ["yi", "a", "ye", "yl", "yo", "zy", "d", "n", "yr", "type", "id", "cy", "xy", "ny", "ya", "ty", "j", "i", "g", "py", "m", "dy", "yn", "yy", "ey", "ch", "h", "l", "p", "c", "w", "e", "vy", "f", "size", "u", "yt", "o", "v", "s", "b", "ay", "t", "Y", "oy", "wy", "ym", "sy"], "sum0": ["um1", "mem0", "um4", "um0", "Sum4", "Sum2", "dim2", "Sum1", " sum3", "dim0", "Sum3", "um3", "sum2", "dim1", "Sum0", " sum2", " sum4", "mem4", "sum3", "sum4", "mem1", "mem2"], "sum1": ["um1", "um0", " sum9", "Sum2", "sum8", "ram1", "Sum9", "umOne", "Sum1", "gramOne", "ram8", "ram2", "gram2", "um2", "gram1", " sumOne", "Sum8", "SumOne", "sum2", "Sum0", "gram9", "ram0", " sum2", "sum9", "sumOne", " sum8"], "z": ["Z", "yi", "q", "ez", "zip", "ii", "zi", "zy", "r", "zh", "d", "n", "fl", "id", "xy", "zz", "ya", "i", "j", "g", " w", "m", "dy", "code", "xx", "oz", "l", "c", "p", "h", "w", "e", "vy", "f", "zo", "u", "v", "s", "yz", "ix", "ze", "t", "tz", "Y", "iz", "wa", "zone"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void pcnet_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    PCNetState *s = opaque;\n\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n\n    uint8_t buf1[60];\n\n    int remaining;\n\n    int crc_err = 0;\n\n\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)\n\n        return;\n\n\n\n#ifdef PCNET_DEBUG\n\n    printf(\"pcnet_receive size=%d\\n\", size);\n\n#endif\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    if (CSR_PROM(s)\n\n        || (is_padr=padr_match(s, buf, size))\n\n        || (is_bcast=padr_bcast(s, buf, size))\n\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n\n\n        pcnet_rdte_poll(s);\n\n\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n\n            struct pcnet_RMD rmd;\n\n            int rcvrc = CSR_RCVRC(s)-1,i;\n\n            target_phys_addr_t nrda;\n\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n\n                if (rcvrc <= 1)\n\n                    rcvrc = CSR_RCVRL(s);\n\n                nrda = s->rdra +\n\n                    (CSR_RCVRL(s) - rcvrc) *\n\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n\n                RMDLOAD(&rmd, nrda);\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n\n                                rcvrc, CSR_RCVRC(s));\n\n#endif\n\n                    CSR_RCVRC(s) = rcvrc;\n\n                    pcnet_rdte_poll(s);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n\n#endif\n\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n\n            CSR_MISSC(s)++;\n\n        } else {\n\n            uint8_t *src = s->buffer;\n\n            target_phys_addr_t crda = CSR_CRDA(s);\n\n            struct pcnet_RMD rmd;\n\n            int pktcount = 0;\n\n\n\n            if (!s->looptest) {\n\n                memcpy(src, buf, size);\n\n                /* no need to compute the CRC */\n\n                src[size] = 0;\n\n                src[size + 1] = 0;\n\n                src[size + 2] = 0;\n\n                src[size + 3] = 0;\n\n                size += 4;\n\n            } else if (s->looptest == PCNET_LOOPTEST_CRC ||\n\n                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size])\n\n                    CRC(fcs, *p++);\n\n                *(uint32_t *)p = htonl(fcs);\n\n                size += 4;\n\n            } else {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size-4])\n\n                    CRC(fcs, *p++);\n\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n\n            }\n\n\n\n#ifdef PCNET_DEBUG_MATCH\n\n            PRINT_PKTHDR(buf);\n\n#endif\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            /*if (!CSR_LAPPEN(s))*/\n\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n\n\n#define PCNET_RECV_STORE() do {                                 \\\n\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n\n    target_phys_addr_t rbadr = PHYSADDR(s, rmd.rbadr);          \\\n\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n\n    src += count; remaining -= count;                           \\\n\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n\n    pktcount++;                                                 \\\n\n} while (0)\n\n\n\n            remaining = size;\n\n            PCNET_RECV_STORE();\n\n            if ((remaining > 0) && CSR_NRDA(s)) {\n\n                target_phys_addr_t nrda = CSR_NRDA(s);\n\n#ifdef PCNET_DEBUG_RMD\n\n                PRINT_RMD(&rmd);\n\n#endif\n\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                    crda = nrda;\n\n                    PCNET_RECV_STORE();\n\n#ifdef PCNET_DEBUG_RMD\n\n                    PRINT_RMD(&rmd);\n\n#endif\n\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                            crda = nrda;\n\n                            PCNET_RECV_STORE();\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n\n\n#undef PCNET_RECV_STORE\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            if (remaining == 0) {\n\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n\n                if (crc_err) {\n\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n                }\n\n            } else {\n\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n            }\n\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n\n            s->csr[0] |= 0x0400;\n\n\n\n#ifdef PCNET_DEBUG\n\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n\n#endif\n\n#ifdef PCNET_DEBUG_RMD\n\n            PRINT_RMD(&rmd);\n\n#endif\n\n\n\n            while (pktcount--) {\n\n                if (CSR_RCVRC(s) <= 1)\n\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n\n                else\n\n                    CSR_RCVRC(s)--;\n\n            }\n\n\n\n            pcnet_rdte_poll(s);\n\n\n\n        }\n\n    }\n\n\n\n    pcnet_poll(s);\n\n    pcnet_update_irq(s);\n\n}\n", "idx": 18254, "substitutes": {"opaque": ["iopesc", "operacity", "Opaque", "OPhole", "Opacity", "ophole", " opacity", "operhole", "operatile", " opace", "opatile", "oppacity", "OPatile", "opacity", "oppaque", "iopaque", "operaque", "opphole", " opesc", "Opesc", "iopace", "oppatile", "OPaque", "opace", "iopacity", "OPacity", "Opace", "opesc"], "buf": ["Buffer", "br", "data", "fp", "text", "f", "pool", "buffer", "rc", "vec", "fi", "cf", "window", "cb", "block", "bc", "loc", "wb", "ctx", "pb", "mem", "byte", "cas", "enc", "home", "prop", "gb", "header", "box", "queue", "config", "fd", "bl", "buff", "fb", "tmp", "seq", "cmd", "uc", "rb", "que", "b", "cache", "cap", "alloc", "proc", "port", "bag", "uf", "cv", "len"], "size": ["offset", "extra", "x", "full", "huge", "num", "six", "max", "sec", "empty", "large", "length", "send", "needed", "bytes", "Size", "source", "len", "scale", "content", "name", "timeout", "count", "eng", "sc", "si", "weight", "grow", "code", "time", "SIZE", "fe", "negative", "sized", "loc", "speed", "page", "go", "security", "ize", "sn", "sync", "c", "address", "sent", "sum", "fee", "small", "capacity", "data", "shape", "esc", "mode", "ng", "buffer", "g", "complete", "args", "ui", "use", "unit", "cache", "form", "storage"], "s": ["ns", "spec", "settings", "service", "ions", "details", "comm", "ss", "submit", "d", "qs", "sym", "us", "sets", "m", "sg", "rs", "times", "self", "lines", "o", "su", "tests", "side", "k", "v", "si", "S", "a", "an", "ds", "native", "f", "r", "sb", "multi", "l", "w", "bis", "sync", "private", "c", "ps", "secondary", "b", "sys", "er", "es", "state", "states", "sq", "sf", "types", "session", "small", "stats", "t", "request", "conf", "services", "n", "plugins", "g", "sl", "fs", "xs", "is", "sites", "site", "e", "ssl", "ses", "client", "js", "hm", "http", "gs", "its", "local", "os", "parts", "server", "south"], "buf1": ["buff1", "bufn", "buf2", "buff0", " bufone", "buffer1", "buf0", "uf2", " bufn", "uf0", "buffone", "ufn", "uf1", "buffer2", "buffern", "buff2", "bufferone", "bufone", " buf2", " buf0", "buffer0"], "remaining": [" remend", "remend", "resaining", "romoding", "remoding", " remoding", "resoding", "resend", "romaining", "romend"], "rmd": [" rmb", "rccmd", "rarm", "rrarm", " rarm", "prcmd", "prarm", "rsha", " prMD", "RMD", "rmb", "rcmd", " rMD", "rld", "rrld", " prcmd", "Rmd", "rrcmd", "prld", " rsha", " prsha", "rrmd", " prmd", "rcMD", "rrmb", " rcmd", " rld", "rMD", "Rsha", "Rcmd", "rcmb", "rrMD", "prmd"], "i": ["ti", "gi", "uri", "bi", "j", "info", "x", "ix", "ini", "qi", "ai", "mi", "io", "phi", "n", "z", "ii", "iu", "index", "di", "ind", "I", "mini", "multi", "zi", "o", "ip", "pi", "ui", "ci", "e", "ni", "c", "si", "ri", "xi", "mu", "anti", "im", "it", "fi", "li", "u"], "nrda": ["nrandia", "nldae", " nldo", "Nrdas", "Nrda", "nrssae", "Nlda", "nrlas", "nrsas", "nrusae", "nddas", "nrdb", "nldar", "nrsa", "nrusas", "nrssa", "nrsb", "ndda", "nddia", "nrdae", "Nldia", "Nrdia", " nrdae", "nrusa", " nrdb", " nlda", "nrdas", "nrlb", "nrsar", "nldo", "nrandas", "Nldb", "Nrdb", " nrdar", " nrdas", "nranda", "nddb", "nrdia", "nruso", " nrsar", "nrdo", "nrssas", " nrdo", "nldb", "nrdar", " nldae", "nrla", "Nldas", " nrsas", " nrsb", "nrandb", "nrlar", "nlda", "nldas", "nrsso", " nrsa", "nldia", " nldas"], "rcvrc": ["rcfrc", "RCfrt", " rcverRC", " rcvRC", "rcvru", "rcvrec", "RCfrc", "rcvmgd", "rcfRC", "rckrt", "rchrt", "rcfra", "rcfunRC", "rcfsrc", "rchrc", "rcvsrc", " rcversrc", "rcverRC", "rcVsrc", "rcfgd", "rckra", "rcsvrc", "rcnrr", "rchrec", "rcversc", "rcfru", "rcVrs", "rcfunrf", "rckrc", "rcVgd", "rcvmrc", "RCfgd", "rcvpRC", "RCfrs", "rcvvrf", "rcnsrc", "rcvprc", "rcnRC", "RCfrf", "RCvRC", "rcfsc", "rcvpra", "RCvrr", "rcvvru", "rcpsc", "rcvgd", " rcverrc", "rckRC", "rcfunrc", "rcVras", "rcpRC", "rcfrf", "rcvvRC", "rcfrr", " rcvsrc", "rcvrf", "rcprc", "rcfras", " rcversc", "RCvgd", "rcvmRC", "RCfRC", "rcVRC", "RCvrf", "RCvrt", "rcnrc", "rcvrr", "rcvRC", "rchRC", "RCfras", "rcVrc", " rcvsc", "rcfunru", "rcfrec", "rcvprt", "rcfrs", "rcvvras", "RCvsrc", "rcsvRC", "rcvsc", "rcvmsrc", "rcvvrs", "rcpsrc", "RCvra", "RCfrec", "RCfrr", "rcverrc", "RCvrec", "rcvvrc", "RCfra", "rcvra", "rcsvrt", "rcversrc", "rcsvrec", "rcprr", "RCfru", "rcvrt", "RCvras", "RCvru", "RCfsrc", "rcvras", "rcfrt", "RCvrc", "RCvrs", "rcvrs"], "CSR_RCVRC": ["CSR_RRvRS", "CSR_RCFRS", "CSR_RCVDRS", "CSR_RCVDRL", "CSR_RCPRL", "CSR_RRvRL", "CSR_RCVRS", "CSR_RRvRC", "CSR_RCFRR", "CSR_RRVRL", "CSR_RCVRT", "CSR_RCFRC", "CSR_RCPRR", "CSR_RCFRT", "CSR_RCVDVR", "CSR_RCVRL", "CSR_RCvRT", "CSR_RCvVR", "CSR_RCvRS", "CSR_RRvRR", "CSR_RCPRS", "CSR_RRVRR", "CSR_RCvRL", "CSR_RRVRC", "CSR_RCFVR", "CSR_RCvRC", "CSR_RCvRR", "CSR_RCPRC", "CSR_RRvVR", "CSR_RCFRL", "CSR_RRVRS", "CSR_RCVDRC", "CSR_RCVVR", "CSR_RRVRT", "CSR_RRVVR", "CSR_RCVRR", "CSR_RRvRT"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    PCIBonitoState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr - BONITO_REGBASE) >> 2;\n\n\n\n    DPRINTF(\"bonito_readl \"TARGET_FMT_plx\"  \\n\", addr);\n\n    switch (saddr) {\n\n    case BONITO_INTISR:\n\n        return s->regs[saddr];\n\n    default:\n\n        return s->regs[saddr];\n\n    }\n\n}\n", "idx": 21513, "substitutes": {"opaque": ["OPaque", "Opsa", "opaques", "opec", "Opque", "OPque", "OPaques", " opaques", "opsa", "optque", " opsa", "Opec", "OPec", " opque", "optaque", "OPsa", "Opaque", "opque", "optaques", " opec"], "addr": ["route", "port", "grad", "start", "conn", "ref", "adr", "asm", "amp", "arg", "mode", "oa", "ord", "rx", "afi", "amd", "pad", "host", "mt", "align", "node", "ea", "pos", "cmp", "alloc", "r", "address", "args", "data", "ad", "size", "ip", "ace", "point", "slot", "code", "dr", "rc", "ctx", "nr", "ar", "rt", " address", "ptr", "xp", "x", "arm", "seq", "alias", "src", "slice", "len", "alt", "sid", "pointer", "offset", "base"], "s": ["status", "ions", "port", "sb", "ums", "e", "outs", "sym", "aces", "es", "hs", "fs", "g", "ses", "rows", "als", "sets", "ds", "sys", "r", "m", "ssl", "os", "p", "ts", "cs", "ls", "o", "ss", "sg", "c", "opens", "ows", " streams", "a", "session", "S", "ps", "ins", "gs", "acks", "conf", "ies", "ips", "resses", "sq", "states", "ays"], "saddr": ["paddr", "faddr", "southhost", "ssrc", "pptr", "scall", " scall", "baddr", "sha", "pha", "faddress", "pcall", "asptr", "raddr", " snode", "rint", " sint", " saddress", "asaddress", "taddr", "phost", "raddress", " sptr", "snode", "baddress", "paddress", " sha", "isnode", "taddress", "sint", "saddress", "psrc", "fhost", "southsrc", "slayer", "tlayer", "asaddr", "fsrc", "pint", "isaddress", "southaddr", "islayer", "ascall", "rha", "shost", "bptr", "southaddress", "tnode", "sptr", "isaddr", " slayer"]}}
{"project": "qemu", "commit_id": "7e97cd88148876bad36ee7c66d526dcaed328d0d", "target": 0, "func": "static void kvm_start_vcpu(CPUState *env)\n\n{\n\n    env->thread = qemu_mallocz(sizeof(QemuThread));\n\n    env->halt_cond = qemu_mallocz(sizeof(QemuCond));\n\n    qemu_cond_init(env->halt_cond);\n\n    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);\n\n    while (env->created == 0)\n\n        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);\n\n}\n", "idx": 26945, "substitutes": {"env": ["exec", "gui", "code", "ep", "args", "np", "console", "er", "scope", "exc", "app", "server", "engine", "empty", "context", "cv", "enable", "enc", "qa", "queue", "ec", "api", "en", "config", "conf", "export", "loader", "ev", "end", "ea", "environment", "ne", "db", "e", "iter", "site", "el", "err", "enter", "viron", "ctx", "here", "eu", "size", "client", "eni", "cache", "req", "vm", "window", "f", "stage", "ext", "conn", "core", "init", "event", " environment", "v", "nc", "que", "eng"]}}
{"project": "FFmpeg", "commit_id": "14a90c9ef09a4b046500dceab5ca1875e330a376", "target": 1, "func": "static av_cold int ffmmal_init_decoder(AVCodecContext *avctx)\n{\n    MMALDecodeContext *ctx = avctx->priv_data;\n    MMAL_STATUS_T status;\n    MMAL_ES_FORMAT_T *format_in;\n    MMAL_COMPONENT_T *decoder;\n    char tmp[32];\n    int ret = 0;\n    bcm_host_init();\n    if (mmal_vc_init()) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot initialize MMAL VC driver!\\n\");\n        return AVERROR(ENOSYS);\n    if ((ret = ff_get_format(avctx, avctx->codec->pix_fmts)) < 0)\n        return ret;\n    avctx->pix_fmt = ret;\n    if ((status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &ctx->decoder)))\n        goto fail;\n    decoder = ctx->decoder;\n    format_in = decoder->input[0]->format;\n    format_in->type = MMAL_ES_TYPE_VIDEO;\n    switch (avctx->codec_id) {\n        case AV_CODEC_ID_MPEG2VIDEO:\n            format_in->encoding = MMAL_ENCODING_MP2V;\n            break;\n        case AV_CODEC_ID_MPEG4:\n            format_in->encoding = MMAL_ENCODING_MP4V;\n            break;\n        case AV_CODEC_ID_VC1:\n            format_in->encoding = MMAL_ENCODING_WVC1;\n            break;\n        case AV_CODEC_ID_H264:\n        default:\n            format_in->encoding = MMAL_ENCODING_H264;\n            break;\n    format_in->es->video.width = FFALIGN(avctx->width, 32);\n    format_in->es->video.height = FFALIGN(avctx->height, 16);\n    format_in->es->video.crop.width = avctx->width;\n    format_in->es->video.crop.height = avctx->height;\n    format_in->es->video.frame_rate.num = 24000;\n    format_in->es->video.frame_rate.den = 1001;\n    format_in->es->video.par.num = avctx->sample_aspect_ratio.num;\n    format_in->es->video.par.den = avctx->sample_aspect_ratio.den;\n    format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;\n    av_get_codec_tag_string(tmp, sizeof(tmp), format_in->encoding);\n    av_log(avctx, AV_LOG_DEBUG, \"Using MMAL %s encoding.\\n\", tmp);\n    if ((status = mmal_port_format_commit(decoder->input[0])))\n        goto fail;\n    decoder->input[0]->buffer_num =\n        FFMAX(decoder->input[0]->buffer_num_min, 20);\n    decoder->input[0]->buffer_size =\n        FFMAX(decoder->input[0]->buffer_size_min, 512 * 1024);\n    ctx->pool_in = mmal_pool_create(decoder->input[0]->buffer_num, 0);\n    if (!ctx->pool_in) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    if ((ret = ffmal_update_format(avctx)) < 0)\n        goto fail;\n    ctx->queue_decoded_frames = mmal_queue_create();\n    if (!ctx->queue_decoded_frames)\n        goto fail;\n    decoder->input[0]->userdata = (void*)avctx;\n    decoder->output[0]->userdata = (void*)avctx;\n    decoder->control->userdata = (void*)avctx;\n    if ((status = mmal_port_enable(decoder->control, control_port_cb)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->input[0], input_callback)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->output[0], output_callback)))\n        goto fail;\n    if ((status = mmal_component_enable(decoder)))\n        goto fail;\n    return 0;\nfail:\n    ffmmal_close_decoder(avctx);\n    return ret < 0 ? ret : AVERROR_UNKNOWN;", "idx": 25401, "substitutes": {"avctx": ["avcms", "varctx", " avcms", "navcontext", "varcontext", " avc", " avcas", "AVc", "avcontext", "ajconn", "avec", "afcontext", "avectx", "avctl", "varcmd", "ajctx", "airctx", "awcfg", "aircontext", "akctx", "avsc", "avecmp", "akcontext", "AVcontext", "afctrl", "avconsole", "awcontext", "avalcontext", " avcc", " avcmp", "afctx", "avpkg", "avalctx", "afca", "avchan", "varcc", "avctrl", "avalcms", "AVca", "AVcas", "AVctx", "AVchan", "avcfg", "aveca", "awpkg", "avcf", "AVcfg", "avcc", "airctl", "AVcmd", "AVcmp", "avalcmp", "avecontext", "AVconn", "avcmp", "awctx", "afcms", "afcf", "avca", "navcmp", "varcms", "avc", "AVpkg", "avconn", "AVsc", "ajcf", "afconn", "AVcli", "ajcontext", "afcc", "aveconsole", " avcli", "avesc", "afctl", "airctrl", "avecf", "ajcas", "avalchan", "avalcmd", "avechan", "AVcf", "avcli", "akctrl", "akcfg", " avsc", "aveconn", " avconn", "ajconsole", "akctl", "AVconsole", " avcontext", "avcas", "avcmd", "AVcms", "navctx", "akpkg", "navcli"], "ctx": ["cm", "console", "cca", " context", "anc", "c", "pkg", "context", "cv", "connection", "qa", "cci", "xc", "text", "config", "component", "cb", "bc", "general", "cmp", "hw", "cmd", "cms", "vc", "wcs", "voc", "cli", "parent", "cc", "ci", "cp", "cf", "client", "rc", "cn", "conv", "cas", "git", "lc", "ctrl", "ca", "service", "cu", "conn", "coll", "event", "tx", "cs", "cam"], "status": ["exec", "temp", "std", "code", "sc", "Status", "STAT", "class", "res", "usr", "cat", "flag", "msg", "job", "success", "cb", "bc", "error", "state", "sync", "proc", " resp", " ret", "str", "err", "val", "s", "progress", "session", "output", "stat", "ret", "sb", "sec", "rc", "response", "gc", "null", "resp", "crit", "bg", "result", "wait"], "format_in": [" format\n", "format_ac", "Format_out", "formatocat", "Formatformat", "template_in", "formatableIn", "filter\n", "feedableout", "feedableIn", "type_In", "live_inc", "form_IN", "filter_out", " format_at", "formatableout", "filter_ini", "format_0", "format_again", "format_at", "Format_in", "filter_inn", "format_In", "format\n", "filter_in", "feed_In", "Format_inc", "formatoc0", "format_ini", "feedablenew", "formatocin", "formatingdiff", " format_init", "formatformat", " format_new", "format___IN", "format_init", "formatMixat", "formatablein", "filterformat", "Format_In", "Format_again", "formatocinit", "formatingnew", " format_out", "feedablein", "formatocini", "feed_new", "type_in", "form_in", " formatformat", "live_ins", "format_inn", " format_diff", " format_id", " format_inc", "format_ins", "formatMixin", "format_out", "format___in", "formatMixinit", "formatacnew", "formatablenew", "Format\n", "template_ini", "formatacdiff", "feed_in", "format___out", "format_for", "form_ac", "form_out", "formatingin", "format_diff", "type_inc", "format_id", "type_for", "format_inc", "formatacin", "live_in", "Format_ins", "format___ac", " format_IN", "feed_out", "format_IN", " format_In", "format_new", "template_0"], "decoder": ["Decode", "decode", "decoded", "encrator", " decrator", "recoder", "decloding", "recader", "decrator", "encoder", "decade", "encode", "Decater", "deoder", "Decoding", "ecode", "recade", "decader", "Decoder", "recode", "decloder", "declader", "deode", "decater", "declade", "deoded", "encater", "declater", "declode", " decader", " decoded", " decoding", " decade", "ecoding", "encoding", "encoded", "decoding", " decode", "deoding", "ecater", "declrator", "ecoder"], "tmp": ["temp", "obj", " obj", " co", " img", " proc", "bb", "img", "cb", " params", "MP", "proc", "pad", "cmp", "mp", " ecc", " rc", " resp", " reply", " msg", " dup", " app", "sb", " param", " dst", " pad", "src", " pts"]}}
{"project": "qemu", "commit_id": "c9fc50839863f05545caca92bb9fbead8b1c91bd", "target": 0, "func": "static void dump_human_image_check(ImageCheck *check)\n\n{\n\n    if (!(check->corruptions || check->leaks || check->check_errors)) {\n\n        printf(\"No errors were found on the image.\\n\");\n\n    } else {\n\n        if (check->corruptions) {\n\n            printf(\"\\n%\" PRId64 \" errors were found on the image.\\n\"\n\n                \"Data may be corrupted, or further writes to the image \"\n\n                \"may corrupt it.\\n\",\n\n                check->corruptions);\n\n        }\n\n\n\n        if (check->leaks) {\n\n            printf(\"\\n%\" PRId64 \" leaked clusters were found on the image.\\n\"\n\n                \"This means waste of disk space, but no harm to data.\\n\",\n\n                check->leaks);\n\n        }\n\n\n\n        if (check->check_errors) {\n\n            printf(\"\\n%\" PRId64 \" internal errors have occurred during the check.\\n\",\n\n                check->check_errors);\n\n        }\n\n    }\n\n\n\n    if (check->total_clusters != 0 && check->allocated_clusters != 0) {\n\n        printf(\"%\" PRId64 \"/%\" PRId64 \"= %0.2f%% allocated, %0.2f%% fragmented\\n\",\n\n        check->allocated_clusters, check->total_clusters,\n\n        check->allocated_clusters * 100.0 / check->total_clusters,\n\n        check->fragmented_clusters * 100.0 / check->allocated_clusters);\n\n    }\n\n\n\n    if (check->image_end_offset) {\n\n        printf(\"Image end offset: %\" PRId64 \"\\n\", check->image_end_offset);\n\n    }\n\n}\n", "idx": 26595, "substitutes": {"check": ["exec", "build", "call", "name", "flight", "add", "cross", "sync", "num", "project", "valid", "set", "start", "http", "lib", "cal", "match", "query", "Check", "draw", "pack", "walk", "wait", "complete", "code", "checked", "test", "key", "feed", "work", "process", "cache", "com", "task", "update", "comp", "rule", "checks", "report", "block", "file", "load", "parse", "fix", "send", "fail", "error", "get", "search", "view", "scan", "ack", "pull", "ck", "full", "post", "control", "lock", "ok", "info", "read", "config", "type", "pass", "end", "flow", "id", "create", "clean", "worker", "clear", "off", "checking", "comment", "y", "index"]}}
{"project": "qemu", "commit_id": "7d489dcdf5fd71b5052ffd401b869a627e1c751f", "target": 0, "func": "static void vfio_pci_load_rom(VFIOPCIDevice *vdev)\n\n{\n\n    struct vfio_region_info reg_info = {\n\n        .argsz = sizeof(reg_info),\n\n        .index = VFIO_PCI_ROM_REGION_INDEX\n\n    };\n\n    uint64_t size;\n\n    off_t off = 0;\n\n    size_t bytes;\n\n\n\n    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {\n\n        error_report(\"vfio: Error getting ROM info: %m\");\n\n        return;\n\n    }\n\n\n\n    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,\n\n                            (unsigned long)reg_info.offset,\n\n                            (unsigned long)reg_info.flags);\n\n\n\n    vdev->rom_size = size = reg_info.size;\n\n    vdev->rom_offset = reg_info.offset;\n\n\n\n    if (!vdev->rom_size) {\n\n        vdev->rom_read_failed = true;\n\n        error_report(\"vfio-pci: Cannot read device rom at \"\n\n                    \"%s\", vdev->vbasedev.name);\n\n        error_printf(\"Device option ROM contents are probably invalid \"\n\n                    \"(check dmesg).\\nSkip option ROM probe with rombar=0, \"\n\n                    \"or load from file with romfile=\\n\");\n\n        return;\n\n    }\n\n\n\n    vdev->rom = g_malloc(size);\n\n    memset(vdev->rom, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->vbasedev.fd, vdev->rom + off,\n\n                      size, vdev->rom_offset + off);\n\n        if (bytes == 0) {\n\n            break;\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 6196, "substitutes": {"vdev": ["lev", "vdd", " vdata", "vecase", "svconn", "nvdevice", "vdc", "pdev", "lver", "wdev", " verror", "navprivate", "avdevice", "pver", "ndie", " vver", "lconn", " vdi", "lconf", "avdev", "vself", "Vdef", "vtr", "gdev", "vconn", "vdie", "lde", "veerror", "Vev", " vtr", "vdi", " vdevelopment", "vdiff", "tvdebug", "vver", "vapp", "ldevelopment", "avdd", " vdebug", "ltr", "svver", "evver", "svdd", "ldef", "ldevice", "lself", "svdiff", "verror", "ldie", " vself", "nvdev", "nev", "tvdevice", "vconf", "lapp", "lerror", "svdev", "Vconf", "svde", "tvdevelopment", "svdi", "gdevice", "navdev", "vdevice", "ndevice", "svdc", "tvdev", "gapp", "ldc", "pev", "ldiff", "svdata", "ldebug", " vev", "svev", "vdevelopment", "gde", "evvar", "nvvar", "vdef", "svdevice", "vev", "ldev", "mdevice", "vde", "Vdev", "wdevice", "mdev", "vedev", "avde", "pprivate", "navev", "Vdd", "Verror", "lcase", "ldi", "evdc", "ldata", "vdata", "vedef", " vde", "wev", "mvar", " vdie", "Vdevice", "Vde", " vdevice", "ndev", "wtr", "evdev", " vapp", "evev", " vdiff", "evdevice", "navver", " vconn", "Vcase", "Vver", " vconf", "vdebug", "svself", "Vprivate", "mver", "vprivate", "nvver", "vcase", "vvar"], "size": ["position", "large", "ci", "shape", "data", "i", "oa", "unit", "speed", "sector", "code", "len", "empty", "zero", "g", "max", "cm", "mode", "function", "name", "SIZE", "count", "fee", "value", "sum", "slice", "capacity", "member", "six", "sized", "scale", "range", "type", "false", "address", "area", "time", "sec", "use", "sync", "now", "loc", "num", "small", "Size", "cs", "e", "timeout", "network", "pos", "global", "c", "core", "complete", "si", "offset", "length", "args", "handle", "storage", "n", "memory", "ize", "needed"], "bytes": ["nos", "tes", "files", "gets", "sec", "les", "rules", "count", "bits", "fee", "total", "s", "users", "runs", "nets", "abytes", "values", "allows", "io", "data", "bps", "rows", "cells", "Bytes", "ones", "ips", "offset", "codes", "parts", "ns", "cycles", "used", "flows", "forces", "args", "ls", "bs", "byte", "cs", "vs", "len", "units", "classes", "ops", "out", "seconds", "full", "raw", "pages", "zip", "ks", "steps", "outs", "ipes", "eps", "blocks", "boot", "css", "pieces", "charges", "settings", "os", "errors", "loads", "items", "es", "lines", "reads"]}}
{"project": "FFmpeg", "commit_id": "577393321c389ad2973bec6168a8045c94a9e099", "target": 0, "func": "int ff_wmv2_decode_secondary_picture_header(MpegEncContext *s)\n\n{\n\n    Wmv2Context *const w = (Wmv2Context *) s;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        if (w->j_type_bit)\n\n            w->j_type = get_bits1(&s->gb);\n\n        else\n\n            w->j_type = 0; // FIXME check\n\n\n\n        if (!w->j_type) {\n\n            if (w->per_mb_rl_bit)\n\n                s->per_mb_rl_table = get_bits1(&s->gb);\n\n            else\n\n                s->per_mb_rl_table = 0;\n\n\n\n            if (!s->per_mb_rl_table) {\n\n                s->rl_chroma_table_index = decode012(&s->gb);\n\n                s->rl_table_index        = decode012(&s->gb);\n\n            }\n\n\n\n            s->dc_table_index = get_bits1(&s->gb);\n\n        }\n\n        s->inter_intra_pred = 0;\n\n        s->no_rounding      = 1;\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"qscale:%d rlc:%d rl:%d dc:%d mbrl:%d j_type:%d \\n\",\n\n                   s->qscale, s->rl_chroma_table_index, s->rl_table_index,\n\n                   s->dc_table_index, s->per_mb_rl_table, w->j_type);\n\n        }\n\n    } else {\n\n        int cbp_index;\n\n        w->j_type = 0;\n\n\n\n        parse_mb_skip(w);\n\n        cbp_index = decode012(&s->gb);\n\n        if (s->qscale <= 10) {\n\n            int map[3]         = { 0, 2, 1 };\n\n            w->cbp_table_index = map[cbp_index];\n\n        } else if (s->qscale <= 20) {\n\n            int map[3]         = { 1, 0, 2 };\n\n            w->cbp_table_index = map[cbp_index];\n\n        } else {\n\n            int map[3]         = {2,1,0};\n\n            w->cbp_table_index = map[cbp_index];\n\n        }\n\n\n\n        if (w->mspel_bit)\n\n            s->mspel = get_bits1(&s->gb);\n\n        else\n\n            s->mspel = 0; // FIXME check\n\n\n\n        if (w->abt_flag) {\n\n            w->per_mb_abt = get_bits1(&s->gb) ^ 1;\n\n            if (!w->per_mb_abt)\n\n                w->abt_type = decode012(&s->gb);\n\n        }\n\n\n\n        if (w->per_mb_rl_bit)\n\n            s->per_mb_rl_table = get_bits1(&s->gb);\n\n        else\n\n            s->per_mb_rl_table = 0;\n\n\n\n        if (!s->per_mb_rl_table) {\n\n            s->rl_table_index        = decode012(&s->gb);\n\n            s->rl_chroma_table_index = s->rl_table_index;\n\n        }\n\n\n\n        s->dc_table_index   = get_bits1(&s->gb);\n\n        s->mv_table_index   = get_bits1(&s->gb);\n\n\n\n        s->inter_intra_pred = 0; // (s->width * s->height < 320 * 240 && s->bit_rate <= II_BITRATE);\n\n        s->no_rounding     ^= 1;\n\n\n\n        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d mspel:%d \"\n\n                   \"per_mb_abt:%d abt_type:%d cbp:%d ii:%d\\n\",\n\n                   s->rl_table_index, s->rl_chroma_table_index,\n\n                   s->dc_table_index, s->mv_table_index,\n\n                   s->per_mb_rl_table, s->qscale, s->mspel,\n\n                   w->per_mb_abt, w->abt_type, w->cbp_table_index,\n\n                   s->inter_intra_pred);\n\n        }\n\n    }\n\n    s->esc3_level_length = 0;\n\n    s->esc3_run_length   = 0;\n\n    s->picture_number++; // FIXME ?\n\n\n\n    if (w->j_type) {\n\n        ff_intrax8_decode_picture(&w->x8, 2 * s->qscale, (s->qscale - 1) | 1);\n\n\n\n        ff_er_add_slice(&w->s.er, 0, 0,\n\n                        (w->s.mb_x >> 1) - 1, (w->s.mb_y >> 1) - 1,\n\n                        ER_MB_END);\n\n        return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21576, "substitutes": {"s": ["i", "es", "xs", "ds", "sys", "y", "r", "ssl", "os", "ts", "cs", "us", "params", "stats", "js", "aws", "ms", "n", "S", "ns", "rs", "ins", "v", "conf", "http", "l", "this", "ss", "request", "sb", "g", "ses", "d", "sets", "site", "as", "services", "u", "o", "sg", "c", "self", "spec", "sc", "sf", "k", "native", "e", "sym", "qs", "fs", "f", "t", "new", "p", "si", "b", "service", "ims", "parts", "sw", "words", "ps", "gs", "h", "sq", "sl", "features", "ops", "ks", "m", "its", "args", "storage", "ls", "sync", "is", "settings", "se", "session", "comments", "south"], "w": ["es", "wa", "wave", "win", "y", "data", "wh", "os", "work", "rw", "wb", "iw", "window", "aws", "ms", "n", "ns", "fw", "wx", "v", "conf", "l", "wcs", "ow", "g", "d", "as", "wo", "u", "war", "web", "aw", "o", "q", "c", "self", "wp", "a", "k", "e", "ess", "wal", "fs", "way", "f", "t", "new", "p", "we", "W", "nw", "wt", "b", "wan", "sw", "words", "gs", "z", "hw", "h", "wl", "x", "writer", "wr", "ww", "cl", "m", "word", "sh", "WS", "tw", "kw", " W"], "cbp_index": ["cbp64slice", "cbc_id", "cbp67weight", "cbp_point", "cbc_index", "cbP_index", "cbp_address", "cbp_Index", "cbp_type", "cbp_key", "cbP_Index", "cbp_input", "cbP_ind", "cbn_type", "cbp67Index", "cbp_weight", "cbc_input", "cbn_key", "cbp64index", "cbpdbaddress", "cbpdbweight", "cbp_id", "cbn_index", "cbpdbid", "cbn_id", "cbP_id", "cbp_length", "cbp_ind", "cbpdbindex", "cbp67input", "cbp67index", "cbc_weight", "cbp_slice", "cbc_address", "cbp64point", "cbp64length", "cbc_Index"], "map": ["view", "shape", "table", "ap", "app", "config", "store", "maps", "file", "share", "copy", "pad", "wave", "model", "one", "pre", "master", "use", "m", "Map", "address", "cache", "msg", "size", "shared", "lock", "arr", "list", "wise", "dict", "open", "gen", "module", "complete", "match", "mem", "set", "hash", "mask", "pair", "comb", "batch", "array", "MAP", "group", "grid", "stream", "block", "cover", "pack", "scope", "image", "cap"]}}
{"project": "qemu", "commit_id": "0a73336d96397c80881219d080518fac6f1ecacb", "target": 1, "func": "int net_init_vhost_user(const Netdev *netdev, const char *name,\n\n                        NetClientState *peer, Error **errp)\n\n{\n\n    int queues;\n\n    const NetdevVhostUserOptions *vhost_user_opts;\n\n    CharDriverState *chr;\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);\n\n    vhost_user_opts = &netdev->u.vhost_user;\n\n\n\n    chr = net_vhost_parse_chardev(vhost_user_opts, errp);\n\n    if (!chr) {\n\n        return -1;\n\n    }\n\n\n\n    /* verify net frontend */\n\n    if (qemu_opts_foreach(qemu_find_opts(\"device\"), net_vhost_check_net,\n\n                          (char *)name, errp)) {\n\n        return -1;\n\n    }\n\n\n\n    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;\n\n    if (queues < 1 || queues > MAX_QUEUE_NUM) {\n\n        error_setg(errp,\n\n                   \"vhost-user number of queues must be in range [1, %d]\",\n\n                   MAX_QUEUE_NUM);\n\n        return -1;\n\n    }\n\n\n\n    return net_vhost_user_init(peer, \"vhost_user\", name, chr, queues);\n\n}\n", "idx": 10857, "substitutes": {"netdev": ["networkpad", "netdevice", "matdev", "netdef", " netconf", "netdriver", " netpad", "natpad", " netdef", "netdiv", "etdev", "networkdef", "networkdiv", "etdevice", "etdef", "natdevice", "netpad", " netdevice", "netconn", "etdriver", "networkconf", "matdriver", " netdriver", "netconf", "etconn", "natconf", "matdevice", "etdiv", " netdiv", "networkdevice", " netconn", "natdev", "matconn", "networkdev"], "name": ["parent", "alias", "sea", "NAME", "base", "up", "n", "prefix", "key", "word", "info", "id", "path", "x", "filename", "nam", "data", "addr", "username", "names", "network", "host", "label", "size", "version", "cap", "connection", "space", "am", "user", "address", "old", "part", "type", "ame", "ip", "client", "image", "ni", "anc", "Name", "hello", "family"], "peer": ["parent", "cot", "channel", "worker", "owner", "conn", "instance", "pool", "block", "addr", "server", "pro", "attr", "request", "pe", "ptr", "socket", "er", "next", "slave", "host", "device", "scope", "connection", "remote", "cert", "cur", "actor", "req", "address", "inner", "node", "enc", "client", "ip", "seed", "proc", "buffer", "ssl", "chain"], "errp": ["iterfp", "erp", "dersp", "rrr", "rrpc", "derp", "derr", " errsp", "rrc", "iterr", "errps", "errper", "erc", " errpc", "erper", " errc", " errper", "rrper", "errsp", "rrp", "errpc", "err", "erpc", " errfp", "erfp", "erps", "errc", "iterps", "derpc", "iterp", " errps", "ersp", " errr", "errr", "errfp"], "queues": ["Queue", "queries", "Queends", "quesges", "quums", "queends", "queueries", "quges", "qations", "queueues", " queances", "clends", "Queances", "Queures", "quesences", "que", "quients", "queences", "qasks", "fluences", "quue", "clasks", "quesations", "clues", "requues", "Queients", "queueums", "queue", "quures", "quues", "Queries", "qends", "fluues", "qacks", "queueacks", "queacks", "queums", "requures", "quries", "queances", "clries", " queures", "queueue", "queasks", "quences", "quesues", "quesures", "fluges", "quesacks", " queue", "fluures", "Queasks", "ques", "qries", "queations", "queges", "queueances", "Queums", "requients", "queueations", "queueures", "queients", "queures", "Queues", "quesue", "requums"], "vhost_user_opts": ["vhost_user_OPcs", "vhost_user_operts", "vhost_user_preps", "vhost_user_opente", "vhost_user_openps", "vhost_user_opens", "vhost_user_opents", "vhost_user_proters", "vhost_user_kt", "vhost_user_opps", "vhost_user_operps", "vhost_user_prote", "vhost_user_props", "vhost_user_kts", "vhost_user_proter", "vhost_user_optts", "vhost_user_opcs", "vhost_user_verts", "vhost_user_OPters", "vhost_user_prets", "vhost_user_ops", "vhost_user_OPt", "vhost_user_kter", "vhost_user_prots", "vhost_user_procs", "vhost_user_optt", "vhost_user_adps", "vhost_user_opters", "vhost_user_opms", "vhost_user_operms", "vhost_user_optps", "vhost_user_opt", "vhost_user_verps", "vhost_user_optcs", "vhost_user_OPms", "vhost_user_kters", "vhost_user_prot", "vhost_user_OPter", "vhost_user_vert", "vhost_user_OPts", "vhost_user_OPps", "vhost_user_adms", "vhost_user_opter", "vhost_user_pros", "vhost_user_pret", "vhost_user_opert", "vhost_user_prety", "vhost_user_OPty", "vhost_user_optte", "vhost_user_adts", "vhost_user_adt", "vhost_user_opty", "vhost_user_opte", "vhost_user_verty"], "chr": [" chro", "chri", "ichrg", " chrg", "CHr", "cherrg", "cherrc", "shrg", "qr", "schri", "schsr", "ichrs", "schro", " chsr", "chro", "ichsr", "echrg", "Chrc", "chrs", "qsr", "chsr", "Chrs", "qri", "chcr", "Chr", " chcr", " chrc", "Chsr", "echr", "qro", "chrg", "echrs", "CHrc", "shrb", "shrc", "Chrb", " chri", "Chcr", "schr", "shr", "CHcr", "CHrg", "chrc", "echsr", "Chrg", "ichr", "cherrb", "cherr", "chrb"]}}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,\n\n                                           stride, dst, stride, 16, 0);\n\n}\n", "idx": 16255, "substitutes": {"dst": ["fdsp", "Dsc", "fdrc", "Dst", "sdsrc", " dsc", " dsrc", " dsp", " drc", "fdst", "dsrc", "dsp", "sdst", "fdsrc", "sdsc", "dsc", "Drc", "sdrc", "Dsp", "drc", "Dsrc"], "src": ["ffff", "slice", "d", "dist", "sync", "rc", "config", "i", "supp", "sup", "source", "low", "use", "sr", "dest", "loc", "rec", "img", "rb", "sec", "rate", "sb", "b", "inst", "gb", "url", "cb", "sc", "bg", "sl", "sur", "r", "sub", "sel", "cur", "st", "fc"], "stride": ["strider", "str8", "dride", " strade", "Stride", "trided", "Strider", "arrode", "drade", "divide", "strided", "brided", "arrided", "Strside", " strside", "trside", " str8", "hrided", "brade", "divade", "brode", "dr8", " strider", "strade", "div8", "Strides", "hride", "hrider", "bride", "Strided", " strides", "arride", "drided", "hrd", "strides", "Strd", "strode", " strode", "arrade", " strd", "divided", "strside", "trides", "tride", "strd", " strided"]}}
{"project": "qemu", "commit_id": "b0706b716769494f321a0d2bfd9fa9893992f995", "target": 1, "func": "void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)\n\n{\n\n    CPUArchState *env;\n\n\n\n    int mmu_idx;\n\n\n\n    assert_cpu_is_self(cpu);\n\n\n\n    env = cpu->env_ptr;\n\n    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {\n\n        unsigned int i;\n\n\n\n        for (i = 0; i < CPU_TLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n\n\n        for (i = 0; i < CPU_VTLB_SIZE; i++) {\n\n            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],\n\n                                  start1, length);\n\n        }\n\n    }\n\n}\n", "idx": 2620, "substitutes": {"cpu": ["eu", "chu", "vm", "cli", "gpu", "ctx", "intel", "roc", "hw", "conn", "gc", "process", "cpp", "clock", "uci", "nc", "nic", "platform", "boot", "comp", "instance", "eni", "CPU", "proc", "fp", "python", "pid", "utils", "config", "bench", "pkg", "c", "lc", "pu", "loader", "core", "sys", "cache", "hp", "chip", "processor", "node", "linux", "pc", "pec", "cp", "uca", "net", "rc"], "start1": ["graden", "start3", "grade1", "grade01", "end3", "offsetn", "set0", " start01", "set01", "stopLength", " start2", "start0", "offset01", "gradeOne", "start2", "startn", "startLength", "stop1", "index0", "stop2", "end2", "end1", "set1", "start01", "offset1", "stop3", "index01", " start0", " startLength", "endLength", " start3", " startn", " startOne", "offsetOne", "startOne", "index1"], "length": ["total", "buffer", "build", "offset", "time", "sequence", "tail", "filename", "url", "position", "type", "distance", "section", "end", "duration", "maximum", "number", "style", "slice", "address", "pad", "l", "block", "len", "size", "angle", "text", "library", "amount", "range", "Length", "padding", "collection", "seq", "depth", "path", "full", "available", "view", "count", "limit", "shape", "load"], "env": ["eu", "oa", "np", "external", "vm", "ctx", "ext", "ass", "enable", "conn", "context", "her", "equ", "environment", "que", "ea", "dict", "scope", "elf", "eng", "enc", "py", "eni", "erv", "file", "args", "enh", "config", "ec", "exc", "Environment", "vs", "e", "loader", "cache", "conf", "core", "el", "viron", "obj", "chal", "en", "eur", "v", "enda", "ev", "cf", "session", "engine", "dir", "console", "si", "energy", "db"], "mmu_idx": ["mmu_ini", "mmu_indt", "mmu_ridxs", "mmu_ity", "mmu_idw", "mmu_dxs", "mmu_minf", "mmu_adX", "mmu_indx", "mmu_idex", "mmu__endx", "mmu__adx", "mmu__adxs", "mmu_endxs", "mmu__adi", "mmu_Idc", "mmu_ipf", "mmu_idi", "mmu__idX", "mmu_idxe", "mmu__idct", "mmu_ridst", "mmu_indexxs", "mmu_idt", "mmu_idey", "mmu_itw", "mmu_idez", "mmu_minc", "mmu_Idz", "mmu_indy", "mmu_dxe", "mmu__endct", "mmu_idy", "mmu_inxs", "mmu__adX", "mmu__idi", "mmu_mainst", "mmu_Idw", "mmu_endct", "mmu_indexx", "mmu_idct", "mmu_idec", "mmu_ipxe", "mmu_ipc", "mmu_midxi", "mmu_indexX", "mmu_dct", "mmu_Idt", "mmu_minx", "mmu__idx", "mmu_inX", "mmu_Idx", "mmu_itx", "mmu__endxe", "mmu_ipxs", "mmu_itt", "mmu_midxs", "mmu_idf", "mmu_mainxs", "mmu_adx", "mmu_midst", "mmu_idX", "mmu_ridxi", "mmu_ridx", "mmu_endx", "mmu_indexi", "mmu_idg", "mmu_mainx", "mmu_ipct", "mmu_idc", "mmu_dx", "mmu__endxs", "mmu_mainxi", "mmu_ipg", "mmu_adi", "mmu_inx", "mmu_idxs", "mmu_Idy", "mmu_idxi", "mmu_idz", "mmu_ming", "mmu__idxe", "mmu_midx", "mmu_ipx", "mmu_idst", "mmu_endxe", "mmu__idxs", "mmu_adxs", "mmu_indw"], "i": ["cli", "yi", "name", "li", "gi", "abi", "a", "ii", "zi", "ui", "pi", "oi", "mini", "d", "I", "n", "di", "id", "it", "k", "iu", "api", "j", "g", "y", "ri", "m", "info", "ti", "multi", "index", "ini", "ai", "ie", "x", "l", "c", "p", "phi", "bi", "e", "lc", "f", "u", "jp", "o", "v", "ki", "qi", "b", "t", "uri", "ci", "io", "mu", "init", "fi", "start", "si", "in", "xi"]}}
{"project": "FFmpeg", "commit_id": "273e6af47b38391f2bcc157cca0423fe7fcbf55c", "target": 0, "func": "static int ea_read_packet(AVFormatContext *s,\n\n                          AVPacket *pkt)\n\n{\n\n    EaDemuxContext *ea = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int ret = 0;\n\n    int packet_read = 0;\n\n    unsigned int chunk_type, chunk_size;\n\n    int key = 0;\n\n    int av_uninit(num_samples);\n\n\n\n    while (!packet_read) {\n\n        chunk_type = avio_rl32(pb);\n\n        chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8;\n\n\n\n        switch (chunk_type) {\n\n        /* audio data */\n\n        case ISNh_TAG:\n\n            /* header chunk also contains data; skip over the header portion*/\n\n            avio_skip(pb, 32);\n\n            chunk_size -= 32;\n\n        case ISNd_TAG:\n\n        case SCDl_TAG:\n\n        case SNDC_TAG:\n\n        case SDEN_TAG:\n\n            if (!ea->audio_codec) {\n\n                avio_skip(pb, chunk_size);\n\n                break;\n\n            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||\n\n                       ea->audio_codec == CODEC_ID_MP3) {\n\n                num_samples = avio_rl32(pb);\n\n                avio_skip(pb, 8);\n\n                chunk_size -= 12;\n\n            }\n\n            ret = av_get_packet(pb, pkt, chunk_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            pkt->stream_index = ea->audio_stream_index;\n\n\n\n            switch (ea->audio_codec) {\n\n            case CODEC_ID_ADPCM_EA:\n\n            case CODEC_ID_ADPCM_EA_R1:\n\n            case CODEC_ID_ADPCM_EA_R2:\n\n            case CODEC_ID_ADPCM_IMA_EA_EACS:\n\n                pkt->duration = AV_RL32(pkt->data);\n\n                break;\n\n            case CODEC_ID_ADPCM_EA_R3:\n\n                pkt->duration = AV_RB32(pkt->data);\n\n                break;\n\n            case CODEC_ID_ADPCM_IMA_EA_SEAD:\n\n                pkt->duration = ret * 2 / ea->num_channels;\n\n                break;\n\n            case CODEC_ID_PCM_S16LE_PLANAR:\n\n            case CODEC_ID_MP3:\n\n                pkt->duration = num_samples;\n\n                break;\n\n            default:\n\n                pkt->duration = chunk_size / (ea->bytes * ea->num_channels);\n\n            }\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        /* ending tag */\n\n        case 0:\n\n        case ISNe_TAG:\n\n        case SCEl_TAG:\n\n        case SEND_TAG:\n\n        case SEEN_TAG:\n\n            ret = AVERROR(EIO);\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case MVIh_TAG:\n\n        case kVGT_TAG:\n\n        case pQGT_TAG:\n\n        case TGQs_TAG:\n\n        case MADk_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MVIf_TAG:\n\n        case fVGT_TAG:\n\n        case MADm_TAG:\n\n        case MADe_TAG:\n\n            avio_seek(pb, -8, SEEK_CUR);     // include chunk preamble\n\n            chunk_size += 8;\n\n            goto get_video_packet;\n\n\n\n        case mTCD_TAG:\n\n            avio_skip(pb, 8);  // skip ea dct header\n\n            chunk_size -= 8;\n\n            goto get_video_packet;\n\n\n\n        case MV0K_TAG:\n\n        case MPCh_TAG:\n\n        case pIQT_TAG:\n\n            key = AV_PKT_FLAG_KEY;\n\n        case MV0F_TAG:\n\nget_video_packet:\n\n            ret = av_get_packet(pb, pkt, chunk_size);\n\n            if (ret < 0)\n\n                return ret;\n\n            pkt->stream_index = ea->video_stream_index;\n\n            pkt->flags |= key;\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            avio_skip(pb, chunk_size);\n\n            break;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8340, "substitutes": {"s": ["sed", "sg", "ks", "sv", "ds", "si", "n", "g", "sf", "b", "t", "i", "sa", "c", "p", "e", "se", "sq", "os", "sk", "an", "f", "cs", "v", "es", "sync", "space", "sie", "sl", "services", "sb", "sis", "spec", "sd", "self", "scl", "ses", "a", "su", "ss", "ssl", "sc"], "pkt": ["cpkg", "cpacket", "copcht", "facket", "pKT", " pet", " packet", "spelt", "copct", "spkg", "fkt", "Pka", "payeth", "copkt", "copacket", " pkg", "Pk", "Pnt", "cpct", " pnt", "Pelt", "pka", "payct", " pka", "apacket", "cpet", "Pkt", "cpk", "Pet", "Peth", "PKT", "lpkt", "pk", "Pcht", "fet", "lpacket", "cpkt", "apkt", "Pkg", "lpka", "packet", "lpct", " pk", "spacket", "pnt", "Pct", "paykt", "Packet", "pcht", "pelt", "spkt", "apKT", " pct", " peth", "payacket", "fct", "apnt", "pct", " pcht", "pkg", "peth", " pKT", "pet", " pelt"], "ea": ["sea", "uca", "nea", "sem", "ee", "va", "area", "anza", "di", "ATA", "SEA", "ta", "lda", "wa", "na", "cca", "ba", "da", "usa", "iana", "ena", "pa", "ra", "oga", "sa", "oe", "gae", "data", "apa", "e", "qa", "ata", "ace", "au", "aea", "ica", "ec", "eni", "ette", "ia", "ECA", "eca", "fa", "ae", "ha", "eb", "oda", "oa", "esa", "ga", "ega", "eva", "aria", "aa", "ca", "coe", "ma", "enda", "aaaa", "EA", "a", "ape", "ni", "ema", "aka", "eu", "fee", "za", "eas"], "pb": ["lp", "dp", "uf", "ib", "wp", "ppa", "pg", "tab", "bb", "proc", "pit", "bp", "prot", "pl", "lab", "bm", "b", "ab", "wb", "pa", "pp", "job", "bs", "cp", "fb", "p", "ref", "pd", "cb", "fp", "gb", "np", "ub", "plug", "rb", "pm", "prop", "tmp", "bc", "pkg", "db", "bf", "mp", "eb", "amp", "bps", "bh", "phrase", "lb", "bot", "kt", "jp", "sb", "pc", "PB", "asm", "summary", "cpp", "hub", "plugin", "platform", "mb", "api", "fc", "ob", "xb", "rob", "typ", "vp"], "chunk_type": ["chword_length", "chword_level", "chunkertypes", "chunklentype", "chunkerlevel", "chet_type", "chunk_types", "chet_size", "chart_code", "chet_tag", "chunk_number", "chunkertag", "chunkworksize", "chword_type", "chunklentag", "chart_length", "chunkworktype", "chunk_code", "chunkerlength", "chunkworkcode", "chunkersize", "chunklennumber", "chunkworklength", "chword_types", "chunk_tag", "chart_size", "chunkertype", "chunklensize", "chet_number", "chunk_level", "chunk_length", "chart_type", "chunkernumber"], "chunk_size": ["chunk\u00b7load", "chgroup_load", "chunksfee", "chgroup_size", "chunknshape", "chunk2weight", "chunks_time", "chgroup_number", "chunkedsize", "chunk_name", "chunk2data", "chunksname", "chunk_sum", "chet_fee", "chunkncount", "chunkeddata", "chunk\u00b7type", "chait_name", "chump_eng", "chunk6count", "chump6shape", "chunkedchannel", "chgroup_data", "chunks_size", "chunk64number", "chet_size", "chait_sum", "chgroup_type", "chunk_eng", "chump_size", "chunk_channel", "chunk_count", "chunks_len", "chump_count", "chunkstype", "chunkneng", "chgroup64number", "chunklexnumber", "chunk6eng", "chunk6shape", "chait_no", "chunk_no", "chet_name", "chunk_SIZE", "chunk6size", "chunkedweight", "chunkssize", "chunk_data", "chunk64type", "chunk64size", "chetstype", "chetssize", "chunklextype", "chgroup_weight", "chgroup64type", "chgroup_channel", "chunklexload", "chunks_SIZE", "chunk_load", "chgroup64size", "chunk2channel", "chump6eng", "chunk_shape", "chetsname", "chunk_len", "chait_size", "chet_type", "chetsfee", "chunk_number", "chunk_weight", "chump6size", "chunk2size", "chunk_fee", "chunk\u00b7size", "chunk64load", "chunknsize", "chunk_time", "chunk\u00b7number", "chump_shape", "chunklexsize", "chgroup64load", "chump6count"]}}
{"project": "FFmpeg", "commit_id": "a755b725ec1d657609c8bd726ce37e7cf193d03f", "target": 0, "func": "static int do_decode(AVCodecContext *avctx, AVPacket *pkt)\n\n{\n\n    int got_frame;\n\n    int ret;\n\n\n\n    av_assert0(!avctx->internal->buffer_frame->buf[0]);\n\n\n\n    if (!pkt)\n\n        pkt = avctx->internal->buffer_pkt;\n\n\n\n    // This is the lesser evil. The field is for compatibility with legacy users\n\n    // of the legacy API, and users using the new API should not be forced to\n\n    // even know about this field.\n\n    avctx->refcounted_frames = 1;\n\n\n\n    // Some codecs (at least wma lossless) will crash when feeding drain packets\n\n    // after EOF was signaled.\n\n    if (avctx->internal->draining_done)\n\n        return AVERROR_EOF;\n\n\n\n    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))\n\n            ret = pkt->size;\n\n    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n    } else {\n\n        ret = AVERROR(EINVAL);\n\n    }\n\n\n\n    if (ret == AVERROR(EAGAIN))\n\n        ret = pkt->size;\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (avctx->internal->draining && !got_frame)\n\n        avctx->internal->draining_done = 1;\n\n\n\n    if (ret >= pkt->size) {\n\n        av_packet_unref(avctx->internal->buffer_pkt);\n\n    } else {\n\n        int consumed = ret;\n\n\n\n        if (pkt != avctx->internal->buffer_pkt) {\n\n            av_packet_unref(avctx->internal->buffer_pkt);\n\n            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)\n\n                return ret;\n\n        }\n\n\n\n        avctx->internal->buffer_pkt->data += consumed;\n\n        avctx->internal->buffer_pkt->size -= consumed;\n\n        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;\n\n        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    if (got_frame)\n\n        av_assert0(avctx->internal->buffer_frame->buf[0]);\n\n\n\n    return 0;\n\n}\n", "idx": 4198, "substitutes": {"avctx": ["akcontext", " avcf", "afctrl", "navcn", "rafcontext", "afcas", "avecas", "avalcmd", "ivcn", "aveqa", "vercu", "ivcontext", "navcontext", "aveloc", "alctx", "ivctx", "afxc", "aveconfig", "afctx", "aircmd", "apctx", "allconfig", "avqa", "avalcu", "ajctx", "navctx", "navcca", "avalcot", "verctrl", " avcontext", "afsq", "altx", "verxc", "allcontext", "avcdn", "afrc", "airctx", "rafcot", "avcmd", "avalctl", "avalcdn", "akcmp", "afcot", "afloc", "afcmp", "avcmp", "avecca", "akctx", "afcn", "aircf", "rafctl", "abcontext", "avecms", "navcu", "avalctx", "avxc", "aveconn", "avecontext", "akcf", "akconn", "afcf", "avlc", "avctrl", "avexc", "avecu", "rafctx", "avelc", "avalcontext", "avalcf", "verconfig", "navsq", "abconn", " avcms", "navconfig", "aflc", "avcas", "alcu", "afctl", "vercontext", "avecn", "avcu", "avconfig", "afcmd", "avcca", "avcms", "allcf", "akctrl", "navconn", "navcf", "allctx", "avcontext", "afpkg", "afcdn", "vercdn", "avcot", "afqa", "avloc", "avconn", "ajconn", "abctx", "alconn", "apcu", "avcn", "alcontext", "avctl", "ivrc", "afcms", "apcontext", "verconn", "avectx", "avepkg", "avsq", "navxc", "avrc", "avcf", "verqa", "aptx", "aftx", "averc", "avecf", "avtx", " avloc", "verctx", "ajsq", "aircontext", "afconn", "avpkg", "afcontext", "afconfig", "ajcontext", "akpkg", " avlc", "afcca", "avecmp", "alcas", "afcu", "abcu", "vercf"], "pkt": ["cpkt", "felt", "apkid", "tpdt", " pnt", "Pcht", "pqt", " pka", " pdt", "apacket", "pucht", "pkid", "cpacket", "cpka", " pk", "Pett", "pk", "lpkt", "prct", "epka", "cpelt", "promacket", "Pet", "lpkid", "promet", "prcht", "lpcht", "apkt", "Packet", "prkt", " pett", "tpkt", "promkt", " pcht", "Pkg", "tpant", "packet", "pracket", "promett", "pelt", "cpct", " pet", " pqt", "cpqt", "epacket", "epk", "lpacket", "ipkt", "lpdt", "pet", "pant", "cpk", "epkh", "epkt", "epnt", "ipacket", " pkh", " pant", "pdt", "pnt", "fkt", " pkid", "Pkt", "pett", "pka", "pct", "pkh", "lpant", " pelt", "ipkh", "cpkg", "pcht", "tpcht", " pct", "apkg", "ipnt", "cpet", "fqt", "puacket", "pukt", "Pct", "lpkg", "puet", " pkg", "fct", "pkg", " packet"], "got_frame": ["got_fram", " got_slot", "got_pixel", "gotableframe", "gotayline", "gotayframe", "gotablesample", "gotaypointer", "given_pointer", "gotaysample", "gotfframe", "gotfpixel", "given_frame", "got_hole", " got_word", " Got_frame", "Got_fram", "got_slot", "got_sample", "got_word", " got_hole", "gotablepointer", "Got_frame", "gotableline", "got_range", "got_pointer", "gotfposition", "gotffram", "got_class", " got_class", "Got_pixel", "given_line", "got_size", " Got_fram", " Got_range", "got_position", "Got_position", "got_line", " Got_size", "given_sample"], "ret": ["flag", "rb", "data", "status", "f", "used", "arg", "active", "match", "code", "len", "det", "error", "RET", "sat", "rl", "rev", "ft", "fun", "resp", "slot", "function", "msg", "id", "nt", "value", "lt", "val", "rf", "art", "valid", "url", "bad", "mt", "str", "usr", "ut", "fail", "back", "reg", "rt", "sec", "alt", "rc", "bit", "cat", "debug", "db", " RET", "num", "fin", "ext", "att", "pet", "obj", "sb", "en", "fit", "feat", "Ret", "re", "gt", "desc", "ref", "r", "rets", "final", "format", "reply", "sur", "lit", "res", "def", "part", "result", "opt", "bf", "success", "rep"]}}
{"project": "FFmpeg", "commit_id": "42f9132218ca11a8e9a3c82a175b46bca092113e", "target": 0, "func": "static int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n\n{\n\n    AVStream *st = s->streams[stream_index];\n\n    int64_t seconds;\n\n    MXFContext* mxf = s->priv_data;\n\n    int64_t seekpos;\n\n    int ret;\n\n    MXFIndexTable *t;\n\n\n\n    if (mxf->nb_index_tables <= 0) {\n\n    if (!s->bit_rate)\n\n        return AVERROR_INVALIDDATA;\n\n    if (sample_time < 0)\n\n        sample_time = 0;\n\n    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);\n\n\n\n    if ((ret = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET)) < 0)\n\n        return ret;\n\n    ff_update_cur_dts(s, st, sample_time);\n\n    mxf->current_edit_unit = sample_time;\n\n    } else {\n\n        t = &mxf->index_tables[0];\n\n\n\n        /* clamp above zero, else ff_index_search_timestamp() returns negative\n\n         * this also means we allow seeking before the start */\n\n        sample_time = FFMAX(sample_time, 0);\n\n\n\n        if (t->fake_index) {\n\n            /* behave as if we have a proper index */\n\n            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)\n\n                return sample_time;\n\n        } else {\n\n            /* no IndexEntryArray (one or more CBR segments)\n\n             * make sure we don't seek past the end */\n\n            sample_time = FFMIN(sample_time, st->duration - 1);\n\n        }\n\n\n\n        if ((ret = mxf_edit_unit_absolute_offset(mxf, t, sample_time, &sample_time, &seekpos, 1)) << 0)\n\n            return ret;\n\n\n\n        ff_update_cur_dts(s, st, sample_time);\n\n        mxf->current_edit_unit = sample_time;\n\n        avio_seek(s->pb, seekpos, SEEK_SET);\n\n    }\n\n    return 0;\n\n}\n", "idx": 26568, "substitutes": {"s": ["sys", "w", "server", "ns", "ts", "sq", "support", "states", "sync", "self", "u", "es", "gs", "http", "set", "sym", "xs", "sa", "f", "service", "qs", "n", "js", "fs", "r", "ops", "S", "space", "p", "m", "b", "c", "se", "storage", "ds", "us", "ins", "su", "is", "sets", "spec", "aws", "services", "com", "sl", "g", "rs", "ses", "ss", "sn", "d", "conf", "sg", "ks", "e", "session", "stat", "sb", "sf", "ssl", "cs", "sv", "sc", "i", "site", "ic", "si", "os", "ls", "y", "v", "l"], "stream_index": ["transform_prefix", "streamlexint", "streamingthread", " stream_base", "stream_ticket", "streamingticket", "transform_index", "stream_thread", "transform_ticket", "streamingprefix", "streamingindex", "stream_base", "streamlexbase", "stream_int", "stream_prefix", "transform_thread", "streamlexindex", " stream_int"], "sample_time": ["sample_host", "sample\u00b7delay", "sample_memory", "samplephost", "ample_year", "sample2times", "samplextimes", "sample\u00b7times", "site_name", "ample_money", "Sample_money", "sampleLdistance", "sample___price", "site_time", "sample\u00b7time", " sample_host", "sample_tz", "samplexlength", "samplealmode", "sampleptime", "service_rate", "server_ime", "ample_time", "ample_cost", "server_time", "sample_money", " sample_volume", "sea_times", "ample_times", " sample_val", "sample_TIME", "sample___time", "sample67rule", "sample_Time", " sample_times", "sample_ime", "sample_value", "samplexTime", "sample_val", "sample_length", "sample_volume", "samplepTime", "sampleacTIME", "servicealtime", "samplealrate", "sample_tim", "sample___times", "site_rate", "sample_rate", " sample_value", "sampleLtime", "samplealtime", "sample_delay", " sample_speed", "sampleLtimes", "sample2ime", "samplexval", "samplextime", "ample_name", "servicealmode", "sample_term", "ample_info", "sample2time", " sample_Time", " sample_ime", "servicealrate", "sample_name", "sampleLtz", "sampleacyear", "server_name", "samplepspeed", "sample_rule", "server_times", "samplexvolume", " sample_timer", "service_tim", "ample_timer", "sample_times", "ample_tim", "sample_info", "sea_tz", " sample_term", "sample_distance", "site_rule", "samplexspeed", "samplexhost", "site_volume", "server_date", "sample_timer", "ample_TIME", "sample67time", "servicealtim", "sampleactime", "samplextimer", "sea_distance", "sample_speed", "Sample_time", "site_times", "sample_mode", " sample_cost", "sample_cost", "server_money", " sample_money", "samplealvalue", "Sample_price", "sample___money", "sample_price", "service_mode", "ample_delay", "sea_time", "sample67volume", "service_time", "sample_date", "sample67times", "samplealtim", "samplealterm", "site_memory", "sample2name", " sample_length", "sampleacinfo", "Sample_times", "sample_year"], "flags": ["mask", "ants", "args", "fo", "features", "flag", "frames", "ips", "items", "Flags", " Flags", "types", "vals", "format", "lf", "stats", "options", "ff", "fps", "fields", "reads", "fts", "faces", "properties", "lag", "utils", "files", "mods", "xml", "ags", "orts", "fun", "fs", "bytes", "bits", "reports", "details", "FLAG", "settings", "ops", "sf", "ints", "windows"], "st": ["rest", "std", "sc", "sk", "w", "ST", "ss", "sn", "p", "pt", "c", "m", "d", "se", "ts", "sw", "data", "en", "ste", "ds", "ct", "inst", "end", "sync", "St", "sth", "db", "e", "step", "sp", "td", "sta", "str", "tmp", "start", "mt", "sts", "set", "tt", "dt", "nt", "stat", "sb", "sa", "stable", "lc", "ost", "stage", "n", "src", "sd", "v", "sl", "r", "sf", "l", "sv", "ut", "stop"], "seconds": ["seq", "times", "sid", "steps", "cuts", "charges", "objects", "frames", " positions", "ips", "months", "sites", "ms", "forms", "outs", "ones", "states", "eps", "second", "codes", "flows", "sets", "fps", "abytes", "hours", "letters", "fee", "strings", "lines", "sections", " second", "sb", "utils", "files", "sec", "resses", "obs", "services", "sleep", "timeout", "elt", "bytes", "years", " bytes", "sent", "values", "settings", "sf", "scripts", "ops"], "mxf": ["pmxf", "Mxf", "mfe", "tmxf", "pmcf", " mcf", "tmcf", "mxd", "Mxc", "nxc", " mfc", "mcf", "pmfc", "mmcf", "mmxc", "mxc", "pxf", "mxb", "pmxb", "tmfe", "Mxb", "Mxd", "pxd", " mxd", "Mfc", " mxe", "ncf", "gxc", "nxf", " mfx", "tmxd", "pxe", "pfc", "gcf", "mmxd", "nfx", " mxb", "mmxf", "mfc", "Mxe", "Mcf", "mxe", "Mfx", " mfe", "gxd", " mxc", "pcf", "gxf", "mfx", "pfe"], "seekpos": ["boardPos", "feedpre", "ekpos", "ekpo", "boardPOS", "boardlen", "ekPOS", "seekposition", "givepos", "givepo", "offsetlen", "feedPos", "offsetposition", " seekPos", "givepre", "seekpre", "ekposition", "seeklen", "ekPos", "feedpo", " seeklen", "seekpo", "offsetpos", "seekPos", " seekposition", "ekpre", "feedpos", "offsetPos", "seekPOS", "givePos", "boardpos", "eklen", " seekPOS"], "ret": ["ref", "code", "obj", "fe", "af", "res", "info", "flag", "red", "back", "base", "en", "success", "bf", "fail", "att", "opt", "error", "def", "pass", "it", "rep", "id", "url", "db", "rets", "al", "mem", "arr", "runs", "err", "det", "lit", "rev", "RET", "fit", "re", "run", "art", "nt", "sec", "reply", "let", "rc", "bad", "pet", "arg", "Ret", "reset", " result", "f", "rt", "value", "alt", "reg", "resp", "replace", "match", "out", "result", "len", "val", "ut", "fun"], "t": ["tree", "z", "i", "p", "m", "b", "c", "unt", "pt", "ta", "d", "template", "ts", "x", "tm", "qt", "ant", "tz", "T", "te", "att", "type", "ct", "it", "port", "the", "e", "o", "at", "mt", "tt", "dt", "nt", "tool", "tw", "ot", "h", "tn", "f", "rt", "wt", "tc", "tf", "tp", "n", "y", "j", "v", "r", "bt", "l", "et", "table", "ut", "g"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int getopt(int argc, char *argv[], char *opts)\n\n{\n\n    static int sp = 1;\n\n    int c;\n\n    char *cp;\n\n\n\n    if (sp == 1)\n\n        if (optind >= argc ||\n\n            argv[optind][0] != '-' || argv[optind][1] == '\\0')\n\n            return EOF;\n\n        else if (!strcmp(argv[optind], \"--\")) {\n\n            optind++;\n\n            return EOF;\n\n        }\n\n    optopt = c = argv[optind][sp];\n\n    if (c == ':' || (cp = strchr(opts, c)) == NULL) {\n\n        fprintf(stderr, \": illegal option -- %c\\n\", c);\n\n        if (argv[optind][++sp] == '\\0') {\n\n            optind++;\n\n            sp = 1;\n\n        }\n\n        return '?';\n\n    }\n\n    if (*++cp == ':') {\n\n        if (argv[optind][sp+1] != '\\0')\n\n            optarg = &argv[optind++][sp+1];\n\n        else if(++optind >= argc) {\n\n            fprintf(stderr, \": option requires an argument -- %c\\n\", c);\n\n            sp = 1;\n\n            return '?';\n\n        } else\n\n            optarg = argv[optind++];\n\n        sp = 1;\n\n    } else {\n\n        if (argv[optind][++sp] == '\\0') {\n\n            sp = 1;\n\n            optind++;\n\n        }\n\n        optarg = NULL;\n\n    }\n\n\n\n    return c;\n\n}\n", "idx": 1145, "substitutes": {"argc": ["axdc", "argn", " argct", "arkci", "agv", "axci", "arglc", " argdc", "argct", "axlc", "axct", "axn", " argci", "argpc", "cmdc", "argci", " argn", "arklc", "arkc", "axc", "aglc", "agc", "cmddc", " arglc", "argdc", "agf", "axpc", "axv", "axf", " argf", "cmdn", "arkpc", " argpc", "cmdct", "argf"], "argv": ["Argv", "agve", "argumentv", "argumentf", "agv", "Argve", "argsl", "Argvs", "optc", " argl", "argssv", "optp", "ArgV", "paramf", "Argsv", "axvs", "axsv", "axver", "catf", "optl", "argumentver", "catvs", "Argc", "arkf", "argV", "agvs", "argumentc", " argvs", "argsp", "argve", "arkc", "paramvs", "axp", "axc", "Argf", "catv", "argumentp", " argsv", "optv", "argl", "arkl", "agf", "axv", "Argl", "axf", "argver", "arkv", "paramv", " argf", "argsv", " argV", " argver", "Argp", "argumentV", "argsf", " argp", "argvs", "argsc", "argf", "paramsv", "catve", "argp", "paramc"], "opts": ["coptes", "OPTS", "opoptions", "OPts", "optionTS", "optes", "otts", "opercs", "copoptions", "ipTS", "ipters", "optionts", "OPters", "optioncs", "ottes", "copcs", "opTS", "opcs", "opertes", "ipts", "ipcs", "otcs", "operts", "OPcs", "copts", "otoptions", "operoptions", "opters", "optionters"], "c": ["cm", "cs", "ctx", "csv", "cc", "cl", "cpp", "r", "d", "ct", "n", "cat", "nc", "bc", "co", "cy", "chain", "k", "con", "tc", "end", "i", "ac", "m", "code", "coll", "err", "cr", "ch", "config", "C", "dc", "ce", "h", "l", "p", "xc", "cu", "e", "lc", "f", "col", "cn", "sc", " pc", "cd", "cmd", "vc", "o", "pc", "v", "s", "cit", "b", "cmp", "cf", "t", "line", "ci", "count", " rc"], "cp": ["cm", "np", "cs", "ctx", "csv", "conn", "pe", "ype", "cpp", "yp", "cat", "ap", "pg", "pn", "ph", "cop", "pb", "op", "tp", "proc", "fp", "cb", "cr", "ep", "ch", "pointer", "CP", "ip", "p", "esp", "col", "hp", "cd", "jp", "mp", "cmd", "bp", "pc", "cmp", "cf", "ci", "wp", "gp", "pp"], "optind": ["argIND", "altend", "optiminst", "optimind", "optioninst", "optionIND", "optioninder", "octInd", "mpind", "propInd", "optioninit", "optioninn", " optint", "optiondir", "optinc", "optimiss", "expinc", "altiss", "optann", "optnd", "octinn", "expind", "optinit", "optionnd", "optinst", "optionini", "octend", "combind", "optIND", "varint", "optinn", "optimann", "optinder", "optionnt", "altind", "optionid", "mpInd", "optstart", "optid", "optionstart", "optii", "optiminn", "varind", "optimnd", "combint", "optionind", "optini", "mpina", " optend", " optann", "optionint", "optiminc", "optionann", " optii", "rootInd", "vertann", "octinc", "optdir", "rootIND", "optnt", "argInd", "optimInd", "rootind", "vertind", "argind", "propind", "varinder", "optionii", "optionina", "optimint", "optimii", "optiss", " optInd", "optioniss", "optimdir", "optimend", "optionend", " optinder", "optionInd", "optina", "optiminit", "vertnd", " optnt", "expInd", "propid", "optimini", "altint", "propinn", "octii", "optend", "mpIND", "optimIND", " optinit", "octind", "optimnt", " optinn", "optimid", "optioninc", "optimstart", "optInd", "vertint", "rootini", "argina", "combdir", "combstart", "optint", " optinst", "expid"], "sp": ["SP", "sg", " sc", "ct", "nc", "sl", "j", "sf", "opt", "isp", "ind", "sw", "f", "sc", "jp", "wp", "se", "start", "pp", "pl", "osp", "sup", "spl", "yp", "type", "ap", "sh", "click", "html", "span", "ny", "asp", "gap", "fp", "sv", "p", "ptr", "esp", "Sp", "amp", "sn", "serv", "sci", " SP", "gp", "pt", "sy", "np", " esp", "skip", "ss", "pe", "bsp", "loc", "page", "py", "i", "pre", "space", "slice", "ep", "st", "cap", "bp", "inst", "si", "service", "pg", "ph", "scope", "sk", "spe", "tp", "pos", "spot", "style", "ip", "pc", "line"]}}
{"project": "qemu", "commit_id": "a2d4e44b485222a8972ea9e555b148148c655bb9", "target": 1, "func": "void pci_default_write_config(PCIDevice *d, \n\n                              uint32_t address, uint32_t val, int len)\n\n{\n\n    int can_write, i;\n\n    uint32_t end, addr;\n\n\n\n    if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) || \n\n                     (address >= 0x30 && address < 0x34))) {\n\n        PCIIORegion *r;\n\n        int reg;\n\n\n\n        if ( address >= 0x30 ) {\n\n            reg = PCI_ROM_SLOT;\n\n        }else{\n\n            reg = (address - 0x10) >> 2;\n\n        }\n\n        r = &d->io_regions[reg];\n\n        if (r->size == 0)\n\n            goto default_config;\n\n        /* compute the stored value */\n\n        if (reg == PCI_ROM_SLOT) {\n\n            /* keep ROM enable bit */\n\n            val &= (~(r->size - 1)) | 1;\n\n        } else {\n\n            val &= ~(r->size - 1);\n\n            val |= r->type;\n\n        }\n\n        *(uint32_t *)(d->config + address) = cpu_to_le32(val);\n\n        pci_update_mappings(d);\n\n        return;\n\n    }\n\n default_config:\n\n    /* not efficient, but simple */\n\n    addr = address;\n\n    for(i = 0; i < len; i++) {\n\n        /* default read/write accesses */\n\n        switch(d->config[0x0e]) {\n\n        case 0x00:\n\n        case 0x80:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x10 ... 0x27: /* base */\n\n            case 0x30 ... 0x33: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n        case 0x01:\n\n            switch(addr) {\n\n            case 0x00:\n\n            case 0x01:\n\n            case 0x02:\n\n            case 0x03:\n\n            case 0x08:\n\n            case 0x09:\n\n            case 0x0a:\n\n            case 0x0b:\n\n            case 0x0e:\n\n            case 0x38 ... 0x3b: /* rom */\n\n            case 0x3d:\n\n                can_write = 0;\n\n                break;\n\n            default:\n\n                can_write = 1;\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        if (can_write) {\n\n            d->config[addr] = val;\n\n        }\n\n        addr++;\n\n        val >>= 8;\n\n    }\n\n\n\n    end = address + len;\n\n    if (end > PCI_COMMAND && address < (PCI_COMMAND + 2)) {\n\n        /* if the command register is modified, we must modify the mappings */\n\n        pci_update_mappings(d);\n\n    }\n\n}\n", "idx": 23307, "substitutes": {"d": ["md", "dos", "e", "cd", "config", "g", "db", "dad", "dh", "plugin", "ds", "ld", "gd", "dn", "df", "f", "t", "u", "m", "s", "da", "dd", "ad", "data", "cmd", "p", "dict", "o", "c", "sd", "dom", "dt", "du", "b", "dc", "dm", "dl", "n", "fd", "bd", "D", "z", "dat", "l", "dp"], "address": ["target", "attribute", "config", "event", "eni", "message", "connection", "ord", "duration", "device", "order", "data", "ip", "prefix", "work", "which", "direction", "date", "alias", "email", "alpha", "pointer", "clock", "image", "output", "attr", "route", "name", "align", "code", "network", "capacity", "office", "channel", "any", "element", "pair", "position", "offset", "hello", "allow", "interface", "e", "adr", "ress", "mode", "host", "layer", "size", "p", "ace", "number", "point", "answer", "ptr", "service", "enter", "length", "reference", "resource", "x", "port", "shape", "en", "hop", "uri", "m", "entry", "index", "Address", "array", "block", "server", "each", "value"], "val": ["def", "sel", "fi", "ref", "config", "valid", "sl", "ind", "arg", "bal", "ol", "bin", "tx", "bl", "type", "f", "pos", "al", "alloc", "pre", "exec", "data", "cache", "stat", "rel", "ret", "arr", "p", "vals", "unit", "code", "var", "buf", "pr", "el", "index", "values", "aval", "byte", "cal", "mem", "x", "rule", "seq", "vol", "call", "test", "loc", "VAL", "Val", "v", "alt", "eval", "all", "block", "base", "value"], "len": ["lc", "limit", "en", "sl", "valid", "ol", "ln", "bl", "ld", "layer", "pos", "lan", "split", "size", "data", "lock", "lin", "code", "L", "el", "lim", "num", "pl", "ann", "mem", "line", "seq", "dl", "n", "length", "loc", "ll", "lon", "v", "alt", "lib", "li", "fn", "lf", "z", "l", "Len", "fin"], "can_write": ["canFwrite", " can_writing", "ban_written", "canaywrite", " can_writer", "can_written", "ban_write", "canaycontrol", "ban_edit", "canaywritten", " can_read", "canOveredit", "can_config", "can_control", " can_written", "can_edit", " can_config", "allow_write", "can2writer", "can2config", "canOverwrite", "can2write", "can_load", "canOverwritten", "can_writer", "allow_written", "allow_control", " can_load", "canFconfig", "canFwriter", "can_read", "can_writing"], "i": ["ami", "ix", "start", "ie", "fi", "qi", "zi", "ri", "ui", "eni", "mini", "gi", "uri", "chi", "ti", "I", "l", "ci", "pos", "esi", "info", "adi", "ini", "u", "it", "j", "phi", "m", "p", "ip", "id", "bi", "ani", "mi", "c", "index", "si", "dim", "ii", "n", "iu", "slice", "ai", "xi", "hi", "di", "multi", "uni", "li", "pi", "x", "attr", "ni", "ori"], "end": ["port", "start", "ind", "valid", "iv", "pos", "dev", "data", "nd", "enc", "id", "code", "is", "fe", "num", "index", "byte", "loc", "Val", "sec", "rib", "all", "eval", "ended", "value"], "addr": ["route", "port", "name", "e", "asm", "ref", "adr", "config", "amp", "hop", "acl", "eni", "eth", "ack", "oa", "ord", "mode", "amd", "align", "host", "node", "device", "layer", "ea", "pos", "order", "adder", "coord", "ad", "data", "arr", "ip", "ace", "prefix", "p", "enc", "mac", "code", "dr", "index", "advert", "add", "ady", "ptr", "direction", "Address", "arm", "dc", "enter", "slice", "loc", "alt", "offset", "attr"], "r": ["ru", "e", "rd", "err", "adr", "g", "result", "region", "rr", "rf", "f", "ro", "t", "u", "m", "s", "rel", "p", "or", "rh", "o", "dr", "pr", "rn", "nr", "rc", "c", "fr", "ar", "rar", "sr", "rt", "vr", "b", "hr", "w", "rl", "re", "cr", "er", "R", "br", "mr", "rs", "range", "v", "ner", "rb", "kr", "l", "rg"], "reg": ["rol", "row", "port", "org", "ig", "conn", "err", "ref", "config", "ind", "adj", "g", "pred", "lex", "region", " Reg", "eng", "rx", "rin", "rec", "sign", "rem", "bl", "ro", "pg", "ac", "acc", "rest", "res", "rel", "stat", "leg", "ret", "mod", "fun", "rc", "tag", "num", "ann", "rule", "REG", "par", "Reg", "re", "loc", "br", "debug", "sec", "eg", "feat", "rg"]}}
{"project": "qemu", "commit_id": "e95e9b88ba5f4a6c17f4d0c3a3a6bf3f648bb328", "target": 1, "func": "static void do_interrupt64(CPUX86State *env, int intno, int is_int,\n\n                           int error_code, target_ulong next_eip, int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr;\n\n    int type, dpl, selector, cpl, ist;\n\n    int has_error_code, new_stack;\n\n    uint32_t e1, e2, e3, ss;\n\n    target_ulong old_eip, esp, offset;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 16 + 15 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    ptr = dt->base + intno * 16;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    e3 = cpu_ldl_kernel(env, ptr + 8);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    ist = e2 & 7;\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) {\n\n        /* to inner privilege */\n\n        new_stack = 1;\n\n        esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl);\n\n        ss = 0;\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (env->eflags & VM_MASK) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n    esp &= ~0xfLL; /* align stack */\n\n\n\n    PUSHQ(esp, env->segs[R_SS].selector);\n\n    PUSHQ(esp, env->regs[R_ESP]);\n\n    PUSHQ(esp, cpu_compute_eflags(env));\n\n    PUSHQ(esp, env->segs[R_CS].selector);\n\n    PUSHQ(esp, old_eip);\n\n    if (has_error_code) {\n\n        PUSHQ(esp, error_code);\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        ss = 0 | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0);\n\n    }\n\n    env->regs[R_ESP] = esp;\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 669, "substitutes": {"env": ["eu", "vt", "txt", "nc", "here", "enc", "inet", "args", "event", "ec", "eve", "cv", "vs", "dev", "jp", "viron", "en", "qa", "engine", "rt", "energy", "ext", "target", "stat", "context", "sb", "esi", "her", "equ", "ea", "assets", "end", "cdn", "eng", "cot", "e", "core", "conf", "org", "forge", "chal", "eur", "v", "ev", "site", "init", "np", "ctx", "atten", "enable", "osc", "esm", "environment", "global", "ne", "gear", "enh", "info", "exc", "usr", "anne", "et", "loader", "obj", "nw", "req", "img", "qt", "net", "oa", "stage", "vm", "server", "fen", "conn", "pg", "dict", "priv", "pos", "eni", "erv", "entry", "ah", "config", "dc", "Environment", "uv", "dat", "que", "console", "export", "db", "ench"], "intno": ["intname", " intcomp", "uinteno", "pointname", "idno", "pointnum", " intNO", "INTno", "indnumber", "extnum", "incnumber", "INTinfo", "seqcho", "idnumber", "uintcho", "extcomp", " intname", "pointinfo", "intnumber", "pointNO", "uintnumber", " intnum", "idname", "inteno", "pointeno", "uintno", "seqeno", "extNO", " intinfo", "INTNO", "intcho", "indnos", " intnos", "pointcho", "incNO", "idnum", "incnos", "inccomp", "extnos", " intnumber", "pointnumber", "extno", "pointnos", "Intno", "incno", "INTnum", "Intnum", "intcomp", "extnumber", "intNO", "Intnumber", "pointno", "indNO", "indnum", "seqnumber", "intnos", "seqno", "incnum", "intinfo", "intnum", "indno"], "is_int": ["isFnt", " is_intel", "is7int", "as_inter", "as_oct", "as_integer", "as_int", "is_integer", "is_intel", "is_oct", "isFind", "isFhw", "is_nt", "is_ind", "is7ind", " is_ind", " is_nt", "isFint", "is7nt", "as_nt", "is7intel", "is_inter"], "error_code": [" error_cod", " error_message", "erroracmessage", "erroraccode", "erroraccodes", "erroraccod", " error_codes", "error_codes", "error_cod", "error_message"], "next_eip": ["next_eeof", "next_ceof", "next_eeip", "next_peips", "next_eips", "next_seep", "next_eep", "next_eeep", "next_ceip", "next_ceips", "next_seip", "next_peep", "next_peof", "next_peip", "next_eIP", "next_seIP", "next_peIP", "next_seips", "next_ceIP", "next_eof", "next_eeips", "next_eeIP"], "is_hw": ["is_ht", "as_hw", "is_wire", "as_ht", "as_fw", " is_ht", " is_wire", "as_rt", "is_fw", "is_rt", " is_fw"], "dt": ["dr", "cm", "np", "tn", "nat", "tf", "ctx", "mt", "dn", "target", "elt", "tg", "vt", "dh", "txt", "wt", "ct", "tk", "di", "ea", "ta", "tc", "tmp", "deb", "tp", "kt", "fp", "ds", "dq", "dc", "ut", "e", "dm", "cn", "ctr", "jp", "bt", "tt", "driver", "tm", "qa", "tz", "t", "DT", "td", "rt", "dat", "qt", "cfg", "db"], "ptr": ["dr", "rot", "base", "pend", "src", "ctx", "ext", "inter", "tip", " pointer", "prot", "loc", "eger", "pair", "next", "adr", "pos", "dy", "proc", "code", "pointers", "info", "fp", "plug", "fr", "slice", "index", "pointer", "tr", "fe", "address", "pad", "Ptr", "p", "shift", "len", "length", "ref", "br", "attr", "ctr", "patch", "jp", "obj", "inst", "req", "addr", "rt", "td", "pt", "part", "start", "rc", "port"], "type": ["unit", "test", "null", "name", "version", "time", "key", "ype", "loc", "class", "ping", "kind", "id", "like", "op", "ty", "comp", "pre", "py", "y", "pos", "none", "code", "Type", "style", " typ", "ip", "block", "p", "state", "size", "ref", "attr", "set", "value", "comment", "rel", "o", "action", "t", "types", "rule", "var", "link", "error", "TYPE", "val", "part", "shape", "typ", "port"], "dpl": ["csl", "dpe", "dplug", " dPL", "ccl", "dcbl", "pPL", "pcl", "cbl", "ldopl", " dbl", "ldbl", "pbl", " dopl", "ldpe", "dPL", "dcplug", "dspl", "dbl", "pplug", "dspe", " dpe", "ldpl", "dsl", "dcPL", "dsbl", " dcl", "dcpl", "dcl", " dsl", "dopl", "ppl", " dplug", "psl", "dsopl"], "selector": ["lectori", "SELECTory", "SELECTion", "accessor", "Selectori", " selectory", "lector", " selecto", "Selection", " selection", "Selector", "lecto", "SELECTori", "accesso", "Selectory", "selectori", "selection", "SELECTor", "selecto", "selectory", " selectori", "lection", "accessori", "accession"], "cpl": ["csl", " cPL", "dpe", "tpl", "tpp", " cfl", "cPL", "ccompl", "ccl", "cpp", "cbl", "tcompl", "cpe", " cbl", "pbl", " ccl", "dcompl", " ccompl", "ppe", "cfl", "CPL", "dPL", "dpp", "Cpl", "dbl", " csl", "dsl", "tPL", "Cfl", " cpp", "dcl", "ppl", " cpe", "psl", "Ccl", "dfl"], "ist": ["ism", "ists", "rest", "ext", "esi", "sp", "op", "aps", "sync", "push", "slice", "st", "ack", "ind", "shift", "et", "reset", "attr", "ress", "asm", "rss", "inst", "slave", "ast", "ace", "dist", "ush", "est"], "has_error_code": ["has_ror_code", "has_error_codes", "has_error_once", "has_error_call", "has_error_coded", "has_erroripcode", "has_erroraycount", "has_erroriponce", "has_error_error", "has_errorayerror", "has_ror_count", "has_error_count", "has_erroripcount", "has_ror_call", "has_erroraycode", "has_erroraycodes", "has_ror_error", "has_ror_codes", "has_erroripcoded"], "new_stack": ["new_addr", " new_scope", "newamstack", "new_depth", "newamaddr", "newamdepth", " new_addr", " new_depth", "newamscope", "new_scope"], "e1": ["eone", "ee2", "E2", "Eone", "ee4", " eall", "pall", "en3", "p4", "en4", "p1", "ea64", "econe", "ea1", "E3", "ec4", "ea2", " e4", "e4", "ee64", "e64", "ec1", " eone", "ea3", "eaone", "Eall", "E1", "E4", "p2", "enone", "eeone", "eall", "ee3", " e64", "en1", "ec3", "ee1"], "e2": ["e20", "ee2", "E2", "i1", " e16", "i16", "ee4", "ee200", "p3", "eTwo", " e200", "p200", "ec02", " eTwo", "p4", " e62", "p1", "e02", "cTwo", "iTwo", "d4", " e02", "e200", "E3", "c20", "ec4", "c1", "ec2", " e4", "e4", "E62", "e62", "d1", "c4", "ec1", "p62", "c16", "i2", "c2", "ee02", "E1", "p2", "E4", "d2", "d20", "E02", " e20", "e16", "ec3", "ee1"], "e3": ["ec5", "E5", " e15", " eiii", "ec15", "e15", " e53", "e6", "E15", "E53", " e5", "E6", "ea1", "E3", "iiii", "e5", " e4", "e03", "e4", "ea03", "i3", "E03", "ec1", "ea3", "ea53", " e03", "i4", "E4", "eiii", "e53", "Eiii", " e6", "ec3", "E1", "i6"], "ss": ["ff", "skip", "rs", "rw", "speed", "eps", "sp", "pos", "ls", "eff", "sync", "ps", "au", "css", "sw", "oss", "sq", "sc", "ress", "s", "tz", "pp", "socket", "slave", "ace", "si", "ssl"], "old_eip": ["old_ceep", "old_peip", "old_eeIP", "old_Eips", "old_zeIP", "old_eeep", "old_Epp", "old_eid", "old_eeip", "old_Eip", "old_seIP", "old_peid", "old_zeip", "old_peipped", "old_eips", "old_sepp", "old_seep", "old_cepp", "old_epp", "old_eeips", "old_pepp", "old_oeipped", "old_eeipped", "old_eIP", "old_eeid", "old_oeIP", "old_oeid", "old_peep", "old_peips", "old_zepp", "old_ceip", "old_oeip", "old_seip", "old_eepp", "old_ceIP", "old_zeep", "old_eep", "old_eipped", "old_peIP", "old_Eep"], "esp": ["sg", "sup", "spec", "sb", "speed", "clock", "sp", "pos", "nil", "sync", "push", "slice", "cr", "sel", "css", "sq", "ress", "resp", "rss", "cp", "selection", "iter", "slave", "ace", "pp", "ice"], "offset": ["no", "skip", "adjust", "oe", "alias", "esi", "data", "loc", "align", "position", "slot", "oid", "parent", "end", "seed", "pos", "entry", "slice", "index", "address", "p", "shift", "et", "start", "size", "reset", "len", "length", "padding", "o", "point", "Offset", "error", "addr", "count", "part", "timeout", "port"]}}
{"project": "qemu", "commit_id": "09b9418c6d085a0728372aa760ebd10128a020b1", "target": 1, "func": "static int get_monitor_def(target_long *pval, const char *name)\n\n{\n\n    const MonitorDef *md;\n\n    void *ptr;\n\n\n\n    for(md = monitor_defs; md->name != NULL; md++) {\n\n        if (compare_cmd(name, md->name)) {\n\n            if (md->get_value) {\n\n                *pval = md->get_value(md, md->offset);\n\n            } else {\n\n                CPUState *env = mon_get_cpu();\n\n                if (!env)\n\n                    return -2;\n\n                ptr = (uint8_t *)env + md->offset;\n\n                switch(md->type) {\n\n                case MD_I32:\n\n                    *pval = *(int32_t *)ptr;\n\n                    break;\n\n                case MD_TLONG:\n\n                    *pval = *(target_long *)ptr;\n\n                    break;\n\n                default:\n\n                    *pval = 0;\n\n                    break;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 24559, "substitutes": {"pval": ["Pdata", "pVAL", "Pval", "Peval", "lpvalid", " pVAL", "fval", "Pvals", "pdata", "peval", "pvalid", "lpval", "cval", "lppol", "pVal", "Pvalue", "spval", "cdata", "tvalue", " pdata", "preval", "tVal", "speval", "prepol", "cvalue", "fpVal", "PVal", "cVal", "lpVAL", " pvalid", "prevalid", " peval", "pvalue", " pvalue", "spvalue", "fpvals", " pVal", "fvalue", " ppol", "pvals", "feval", "tval", "fpvalue", "spVal", "preVAL", "tvals", "ppol", "fpval"], "name": ["space", "ref", "code", "call", "param", "none", "image", "time", "data", "action", "base", "label", "no", "style", "config", "am", "on", "address", "type", "prefix", "version", "ame", "id", "alias", "self", "Name", "key", "cmd", "path", "group", "word", "new", "size", "part", "NAME", "named", "value", "n", "names", "nam", "init", "normal", "description", "block", "val"], "md": ["exec", "head", "nm", "cd", "ld", "add", "own", "dom", "self", "mem", "cmd", "nd", "mt", "dt", "dev", "nt", "mod", "MD", "sm", "da", "dm", "mm", "sd", "df", "code", "cm", "m", "ds", "ad", "bd", "diff", "mi", "def", "mp", "ma", "old", "di", "mb", "Cmd", "mand", "mc", "vd", "od", "managed", "meta", "fd", "node", "pt", "d", "data", "ms", "am", "mid", "db", "mode", "req", "ng", "hm", "dc", "hd", "dr", "doc", "kg", "dd", "mag", "o", "td", "amp", "pd", "grad", "dat", "rm", "mo", "pm", "amd", "conn", "ind", " MD"], "ptr": ["ref", "code", "slice", " pointer", "shift", "pt", "mount", "dr", "fd", "buffer", "rb", "br", "pointer", "address", "inst", "push", "port", "tr", "proc", "pad", "sth", "buf", "iter", "td", "adr", "val", "pb", "eth", "loc", "offset", "enter", "coord", "rc", "alloc", "req", "Ptr", "ctr", "addr", "length", "buff", "amd", "rt", "ext", "src", "pair", "inter", "ind", "attr", "ace", "tty", "pos", "pc", "desc"], "env": ["code", "obj", "sys", "np", "console", "scope", "exc", "context", "cv", "vs", "enc", "ec", "en", "config", "ct", "priv", "state", "ev", "end", "ea", "inet", "environment", "db", "e", "buf", "dir", "loc", "viron", "dev", "edge", "ctx", "eu", "size", "sec", "eni", "rc", "iv", "vm", "oa", "len", "addr", "rt", "nw", "conn", "vel", "net", "v", "pos", "nc", "que", "equ"]}}
{"project": "qemu", "commit_id": "f1c52354e5bdab6983d13a4c174759c585e834b3", "target": 0, "func": "static uint32_t drc_set_unusable(sPAPRDRConnector *drc)\n\n{\n\n    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;\n\n    if (drc->awaiting_release) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_allocation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 70, "substitutes": {"drc": ["Dsrc", "bsrc", " dpc", "tsc", " dvc", "sdrc", "adirc", "idsrc", "dspc", "ddc", "bpc", "brc", "dsrec", "tvc", "dsc", " duc", "brec", "puc", "dsirc", "ldrec", "psrc", " dsrc", " droc", "drec", "sdsc", "dRC", "Drc", "dirc", "proc", "sdvc", " dirc", "iduc", "adsrc", "adrc", " dsc", "sddc", "dsrc", "duc", " ddc", "idroc", "ldrc", "prc", "adRC", "DRC", " dRC", " drec", "ldpc", "idrc", "trc", "ldsrc", "droc", "dvc", "dpc", "Dirc", "dssrc", "tdc", "ldirc"]}}
{"project": "qemu", "commit_id": "6750e795b167e3defab36502e61b8c57ede119eb", "target": 0, "func": "static int add_old_style_options(const char *fmt, QemuOpts *opts,\n\n                                 const char *base_filename,\n\n                                 const char *base_fmt)\n\n{\n\n    if (base_filename) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {\n\n            error_report(\"Backing file not supported for file format '%s'\",\n\n                         fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    if (base_fmt) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {\n\n            error_report(\"Backing file format not supported for file \"\n\n                         \"format '%s'\", fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 14220, "substitutes": {"fmt": ["sfmt", "bwt", "fwt", "tflt", "Fformat", "tfm", "sftt", " fm", "FMT", "sfformat", "tfformat", "fnt", "fm", "Ftt", " fformat", "fformat", " fnt", "Fmt", "tfwt", "tfmt", "flt", " fwt", "tftt", "ftt", "tfMT", "bmt", "bformat", " flt", "sfMT", "tfnt", "Fnt", "fMT", "Fm", "blt"], "opts": ["otps", "alt", "opcs", "optches", "iopt", "prets", "opert", "precs", "alps", "OPTS", "OPches", "optTS", "alpt", "OPpt", "preps", "iopches", "opters", "OPps", "preters", "otts", "OPt", "opTS", "oppt", "otters", "iopts", "OPts", "opches", "optt", "optts", "operpt", "opps", "optters", "iopTS", "otcs", "optps", "alts", "opt", "optcs", "operps", "operts"], "base_filename": ["baseingfilename", "build_filename", "build_layer", " base_file", " base_string", "base_language", "baseingfile", "basefullfiles", "build_language", "basefullfile", "baseingtxt", "basefullstring", "base_file", " base_txt", "base_layer", "baseinglanguage", " base_family", "build_file", "base_string", "baseingfamily", "baseinglayer", "base_family", "basefullfilename", "base_files", " base_files", "base_txt"], "base_fmt": ["base_tflass", "base_blt", "base2fatter", "base_tflt", "base_formmt", "base__btml", "base__fmt", "base2formmt", "base_flt", "base_flass", "base_filemt", "base_tfwd", "base__fwd", "base_frameworkmt", "base_tfmt", "base_frmt", "base_batter", "base2fformat", "base2formformat", "base2flt", "base_fmmt", "base_formatter", "base_fmlt", "base_btml", "base_frformat", "base_filelass", "base2fmt", "base_formformat", "base_bformat", "base_frlass", "base_frlt", "base2formatter", "base_formlt", "base_fformat", "base_fwd", "base_tfformat", "base_fmatter", "base_frameworkwd", "base__bmt", "base2formlt", "base_frameworkformat", "base_frameworktml", "base__bformat", "base_fatter", "base_filelt", "base_ftml", "base_tftml", "base__ftml", "base_bwd", "base_bmt", "base_fileformat", "base__fformat", "base_fmformat", "base__bwd"]}}
{"project": "qemu", "commit_id": "cdeaf1f15909e2e8af38f45aea7cfa467a729c52", "target": 1, "func": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,\n\n                                      const uint8_t *buf, int nb_sectors)\n\n{\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = vmdk_write(bs, sector_num, buf, nb_sectors);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    return ret;\n\n}\n", "idx": 11334, "substitutes": {"bs": ["vs", "base", "ds", "lbs", "ba", "bid", "bas", "b", "iss", "sa", "fb", "ls", "pb", "gb", "js", "us", "BS", "bc", "os", "obs", "cs", "bl", "es", "ubs", "bh", "las", "lb", "bis", "bi", "ns", "sb", "blocks", "as", "fs", "ses", "css", "ps", "ss", "bes", "bos"], "sector_num": ["sectorIdnum", "sectoridnumber", " sector_number", "sectorIdnumber", "sector_count", "sector_number", "sector_nom", "sectoridcount", "sectorIdfn", "sectorIdcount", " sector_nom", " sector_count", " sector_name", "sector_fn", "sectoridfn", "sector_name", "sectoridnum", " sector_fn"], "buf": ["bag", "uf", "seq", "Buffer", "ff", "src", "fd", "b", "num", "pool", "fi", "data", "block", "fb", "batch", "ref", "pb", "cb", "fp", "queue", "rb", "loc", "array", "bc", "bf", "alloc", "cv", "v", "ctx", "port", "bytes", "result", "vec", "buff", "buffer"], "nb_sectors": ["nb_spegments", "nb_secctors", "nb_vectors", "nb_sucs", "nb_surars", "nb_specs", "nb_secs", "nb_sears", "nb_surctors", "nb_secvers", "nb_suars", "nb_seitors", "nb_pectors", "nb_severs", "nb_suvers", "nb_survers", "nb_segments", "nb_pegments", "nb_surcs", "nb_vecs", "nb_spectors", "nb_pecs", "nb_speitors", "nb_vegments", "nb_secars", "nb_seccs", "nb_peitors", "nb_suctors", "nb_veitors"], "ret": ["pass", "base", "flag", "len", "val", "alt", "nt", "id", "Ret", "info", "x", "num", " Ret", "pat", "data", "reply", "ref", "arg", "obj", "reg", "final", "rets", "tmp", "f", "j", "code", "rt", "res", "bf", "py", "det", "fun", "att", "ben", "en", "art", "bit", "fin", "cat", "re", "RET", "back", "result", "rev", "match", "ft", "fi"], "s": ["l", "conf", "session", "ts", "is", "ds", "g", "si", "n", "w", "b", "t", "d", "gs", "sa", "c", "service", "iss", "p", "server", "e", "args", "js", "rs", "sq", "f", "j", "cs", "sym", "o", "opt", "S", "sync", "sl", "r", "ns", "sys", "h", "side", "ses", "ps", "fs", "site", "ss", "settings", "ssl"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv iwmmxt_load_creg(int reg)\n\n{\n\n    TCGv var = new_tmp();\n\n    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));\n\n    return var;\n\n}\n", "idx": 14814, "substitutes": {"reg": ["port", "proc", " REG", "un", "bad", "name", "req", "eg", "arg", "mod", "registered", "loc", "pred", "region", "conn", "feat", "win", "aug", "rec", "mem", "sec", "ang", "eng", "min", "rol", "Reg", "stat", " Reg", "re", "REG", "param", "tag", "res", "addr", "num", "rel", "index"]}}
{"project": "qemu", "commit_id": "f21126df5f81797486eb3bd628da8e2ad5fae12e", "target": 1, "func": "static void pl181_fifo_run(pl181_state *s)\n\n{\n\n    uint32_t bits;\n\n    uint32_t value;\n\n    int n;\n\n    int is_read;\n\n\n\n    is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0;\n\n    if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card))\n\n            && !s->linux_hack) {\n\n        if (is_read) {\n\n            n = 0;\n\n            value = 0;\n\n            while (s->datacnt && s->fifo_len < PL181_FIFO_LEN) {\n\n                value |= (uint32_t)sd_read_data(s->card) << (n * 8);\n\n                s->datacnt--;\n\n                n++;\n\n                if (n == 4) {\n\n                    pl181_fifo_push(s, value);\n\n                    n = 0;\n\n                    value = 0;\n\n                }\n\n            }\n\n            if (n != 0) {\n\n                pl181_fifo_push(s, value);\n\n            }\n\n        } else { /* write */\n\n            n = 0;\n\n            while (s->datacnt > 0 && (s->fifo_len > 0 || n > 0)) {\n\n                if (n == 0) {\n\n                    value = pl181_fifo_pop(s);\n\n                    n = 4;\n\n                }\n\n                n--;\n\n                s->datacnt--;\n\n                sd_write_data(s->card, value & 0xff);\n\n                value >>= 8;\n\n            }\n\n        }\n\n    }\n\n    s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO);\n\n    if (s->datacnt == 0) {\n\n        s->status |= PL181_STATUS_DATAEND;\n\n        /* HACK: */\n\n        s->status |= PL181_STATUS_DATABLOCKEND;\n\n        DPRINTF(\"Transfer Complete\\n\");\n\n    }\n\n    if (s->datacnt == 0 && s->fifo_len == 0) {\n\n        s->datactrl &= ~PL181_DATA_ENABLE;\n\n        DPRINTF(\"Data engine idle\\n\");\n\n    } else {\n\n        /* Update FIFO bits.  */\n\n        bits = PL181_STATUS_TXACTIVE | PL181_STATUS_RXACTIVE;\n\n        if (s->fifo_len == 0) {\n\n            bits |= PL181_STATUS_TXFIFOEMPTY;\n\n            bits |= PL181_STATUS_RXFIFOEMPTY;\n\n        } else {\n\n            bits |= PL181_STATUS_TXDATAAVLBL;\n\n            bits |= PL181_STATUS_RXDATAAVLBL;\n\n        }\n\n        if (s->fifo_len == 16) {\n\n            bits |= PL181_STATUS_TXFIFOFULL;\n\n            bits |= PL181_STATUS_RXFIFOFULL;\n\n        }\n\n        if (s->fifo_len <= 8) {\n\n            bits |= PL181_STATUS_TXFIFOHALFEMPTY;\n\n        }\n\n        if (s->fifo_len >= 8) {\n\n            bits |= PL181_STATUS_RXFIFOHALFFULL;\n\n        }\n\n        if (s->datactrl & PL181_DATA_DIRECTION) {\n\n            bits &= PL181_STATUS_RX_FIFO;\n\n        } else {\n\n            bits &= PL181_STATUS_TX_FIFO;\n\n        }\n\n        s->status |= bits;\n\n    }\n\n}\n", "idx": 9025, "substitutes": {"s": ["l", "session", "is", "its", "m", "http", "t", "gs", "parts", "set", "state", "full", "ns", "hs", "spec", "self", "params", "settings", "sg", "ds", "si", "your", "sf", "b", "i", "serv", "c", "se", "e", "request", "args", "us", "f", "sym", "sets", "scope", "es", "r", "as", "u", "comments", "fs", "ps", "site", "su", "ss", "ks", "sv", "g", "stats", "ops", "d", "ls", "status", "os", "cs", "o", "sync", "south", "native", "new", "sb", "sys", "side", "ions", "a", "ssl", "conf", "ts", "the", "service", "p", "server", "qs", "tests", "ins", "xs", "js", "rs", "an", "aws", "S", "sie", "states", "services", "less", "h", "ses", "uns", "y", "bs"], "bits": ["vals", "boot", "BIT", "acts", "its", "nos", "features", "dates", "stats", "alls", "fields", "ops", "ports", " bugs", "mask", "pieces", "parts", "status", "ins", "ids", "steps", "runs", "bands", "outs", "planes", "pins", "plugins", "values", "limits", "ints", "flags", "bugs", "fps", "checks", "states", "notes", "locks", "codes", "hours", "cycles", "details", "blocks", "bytes", "bit", "lock", "gets", "ips", "options", "nets", "bs", "settings", "lins"], "value": ["json", "x", "store", "max", "xml", "none", "device", "values", "v", "content", "end", "object", "offset", "type", "image", "vi", "element", "val", "key", "w", "no", "id", "b", "total", "expression", "e", "unit", "index", "format", "position", "error", "fee", "temp", "num", "d", "data", "flow", "xxx", "entry", "resource", "o", "version", "size", "gi", "ava", "sn", "node", "message", "result", "VALUE", "ion", "byte", "Value", "valid", "scale", "wa", "server", "p", "number", "child", "name", "function", "address", "option", "null", "nu", "length", "write", "fe"], "n": ["l", "un", "nb", "len", "g", "span", "na", "ny", "m", "conn", "nt", "no", "t", "x", "k", "b", "num", "z", "d", "i", "ne", "net", "c", "inn", "p", "e", "don", "cn", "nw", "number", "dn", "f", "network", "nat", "j", "pn", "o", "N", "size", "non", "nit", "v", "name", "inner", "en", "sn", "ns", "node", "nan", "fn", "nc", "nl", "not", "nu", "ng", "ni", "length", "y", "adj", "nn"], "is_read": ["is_ok", " is_ok", " is_add", "is__ready", "is_Read", "is_write", "is_ready", "is__add", " is_Read", " is_write", "is__Read", "is__read", "is_current", "is__write", " is_current", " is_ready", "is_add"], "datacnt": [" datacant", " datacNT", " datcct", "datacourse", " Datacct", "DatACound", " datcnt", "Dataccent", " datACount", " Dataccnt", "datACnet", "dataccant", "daticount", "dataccound", "DatACnt", "Datacound", "dataccct", "daticnt", "datacnet", "datACnt", "Datacount", " datacnc", " datACnt", "datAcount", " datACourse", " datacount", "daticnc", "Datacct", "DatACount", "dataclnt", "DatACnc", "datAcNT", "dataccourse", " Dataccct", "datacount", " datacct", "dataclound", "datacant", " datACnet", "datancnet", " datacourse", "datACnc", " datACct", "datacct", "datacccent", "datACount", "DatACcent", " Datacount", "datcnt", "datAcnt", "datascourse", " datACNT", " Dataccnc", " datACant", "datcnc", "datacNT", "daticct", "DatACct", "datancnt", "datancNT", "datecnt", "dataccnc", "dataccent", "datcount", "datacnc", "datacound", "datACcent", "datACant", "datecnc", "datACct", "Datacnc", " datcnc", " Dataccount", " datcount", "datACourse", " Datacnt", "datascnt", "dataccnt", "datACound", "dataccount", "datascant", "datAcnet", "datACNT", "datcct", "dataccNT", "dataclct", "datecct", "datancount", "datascct", " datACnc", "datecount", "Datacnt", "datAcct", "dataclcent", " Datacnc", " datacnet", "datAcnc"]}}
{"project": "qemu", "commit_id": "e61031cdd81826c433a8bbfa3aca2bae4ffaf845", "target": 1, "func": "static gboolean gd_motion_event(GtkWidget *widget, GdkEventMotion *motion,\n\n                                void *opaque)\n\n{\n\n    GtkDisplayState *s = opaque;\n\n    int x, y;\n\n    int mx, my;\n\n    int fbh, fbw;\n\n    int ww, wh;\n\n\n\n    fbw = surface_width(s->ds) * s->scale_x;\n\n    fbh = surface_height(s->ds) * s->scale_y;\n\n\n\n    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);\n\n\n\n    mx = my = 0;\n\n    if (ww > fbw) {\n\n        mx = (ww - fbw) / 2;\n\n    }\n\n    if (wh > fbh) {\n\n        my = (wh - fbh) / 2;\n\n    }\n\n\n\n    x = (motion->x - mx) / s->scale_x;\n\n    y = (motion->y - my) / s->scale_y;\n\n\n\n    if (x < 0 || y < 0 ||\n\n        x >= surface_width(s->ds) ||\n\n        y >= surface_height(s->ds)) {\n\n        return TRUE;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_X, x,\n\n                             surface_width(s->ds));\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_Y, y,\n\n                             surface_height(s->ds));\n\n        qemu_input_event_sync();\n\n    } else if (s->last_x != -1 && s->last_y != -1 && gd_is_grab_active(s)) {\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_X, x - s->last_x);\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_Y, y - s->last_y);\n\n        qemu_input_event_sync();\n\n    }\n\n    s->last_x = x;\n\n    s->last_y = y;\n\n\n\n    if (!qemu_input_is_absolute() && gd_is_grab_active(s)) {\n\n        GdkScreen *screen = gtk_widget_get_screen(s->drawing_area);\n\n        int x = (int)motion->x_root;\n\n        int y = (int)motion->y_root;\n\n\n\n        /* In relative mode check to see if client pointer hit\n\n         * one of the screen edges, and if so move it back by\n\n         * 200 pixels. This is important because the pointer\n\n         * in the server doesn't correspond 1-for-1, and so\n\n         * may still be only half way across the screen. Without\n\n         * this warp, the server pointer would thus appear to hit\n\n         * an invisible wall */\n\n        if (x == 0) {\n\n            x += 200;\n\n        }\n\n        if (y == 0) {\n\n            y += 200;\n\n        }\n\n        if (x == (gdk_screen_get_width(screen) - 1)) {\n\n            x -= 200;\n\n        }\n\n        if (y == (gdk_screen_get_height(screen) - 1)) {\n\n            y -= 200;\n\n        }\n\n\n\n        if (x != (int)motion->x_root || y != (int)motion->y_root) {\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n            GdkDevice *dev = gdk_event_get_device((GdkEvent *)motion);\n\n            gdk_device_warp(dev, screen, x, y);\n\n#else\n\n            GdkDisplay *display = gtk_widget_get_display(widget);\n\n            gdk_display_warp_pointer(display, screen, x, y);\n\n#endif\n\n            s->last_x = -1;\n\n            s->last_y = -1;\n\n            return FALSE;\n\n        }\n\n    }\n\n    return TRUE;\n\n}\n", "idx": 4521, "substitutes": {"widget": ["game", "gets", "scroll", "fw", "wx", "scope", "sw", "session", "wid", "layout", "iframe", "wp", "pipe", "image", "draw", "window", "gui", "sl", "wordpress", "select", "w", "Widget", "win", "theme", "skin", "loader"], "motion": ["game", "flow", "position", "scroll", "mpeg", "comm", "effect", "sem", "up", "iframe", "wp", "mo", "image", "draw", "mos", "mp", "media", "select", "ss", "km", "sc", "down", "error", "cam", "mission", "otion", "speech", "me", "theme", "Motion", "mega", "frame", "sp", "mph", "mm", "video", "webkit", "model", "params", "move", "anim", "activity", "upload", "element", "mode", "mouse", "ui"], "opaque": ["opsac", "OPac", "opusaque", "opque", "OPque", "OPonymous", "oponymous", "OPacity", "opsaque", " opque", "opsaques", "OPaque", "opusacity", "opac", "opsonymous", " oponymous", "OPaques", " opacity", "opaques", "opusque", "opusonymous", "opacity", " opaques", " opac"], "s": ["sf", "S", "a", "features", "b", "data", "i", "status", "f", "parts", "d", "service", "conf", "sports", "self", "aws", "g", "sym", "sets", "sites", "is", "spec", "services", "its", "states", "server", "sl", "ls", "native", "sie", "ops", "ds", "ts", "south", "settings", "fs", "sq", "ms", "your", "site", "rs", "as", "ins", "ows", "sg", "plugins", "comments", "sync", "ses", "ions", "cs", "u", "e", "an", "submit", "sb", "ks", "en", "t", "qs", "tests", "p", "input", "css", "c", "os", "ssl", "r", "ps", "o", "views", "less", "http", "scope", "session", "words", "si", "styles", "sys", "m", "details", "l", "side", "ns", "stats", "us", "ss", "gs", "se", "full", "storage", "n", "su", "spot", "request", "params", "es", "js"], "x": ["ya", "name", "area", "position", "cross", "yx", "v", "id", "wx", "value", "Y", "ex", "ax", "i", "xi", "xp", "b", "pe", "wa", "data", "m", "dx", "px", "fx", "ix", "xy", "tx", "xs", "l", "f", "image", "key", "event", "d", "e", "an", "point", "w", "en", "t", "n", "rx", "height", "win", "p", "input", "h", "z", "xxx", "c", "xx", "X", "index", "on", "size"], "y": ["yy", "dy", "name", "o", "python", "zy", "sy", "wx", "ady", "Y", "yt", "yo", "ny", "b", "iy", "i", "cy", "sky", "m", "ya", "yn", "xy", "ty", "yi", "d", "py", "ry", "ay", "w", "yl", "oy", "ery", "t", "height", "lon", "vy", "ey", "year", "p", "yan", "ye", "ky", "h", "z", "gy", "ys", "ym", "ish"], "mx": ["yy", "dy", "ml", "yx", "fy", "md", "wx", "wave", "zx", "hz", "xp", "wm", "ax", "wp", "cy", "mo", "wa", "m", "fx", "px", "xy", "tx", "pm", "wy", "mn", "py", "mc", "MX", "hh", "rx", "mag", "mi", "me", "mb", "fm", "mr", "gy", "memory", "mm", "ym", "xx", "webkit", "ms", "cm"], "my": ["yy", "dy", "fy", "mmm", "md", "nn", "mic", "ady", "zx", "ny", "wm", "i", "cy", "m", "ya", "ix", "xy", "mys", "pm", "ma", "mos", "mn", "gray", "nm", "Mi", "py", "ry", "ay", "mc", "mis", "any", "ami", "rx", "mag", "mi", "me", "ky", "mr", "gy", "am", "mph", "mm", "sym", "ms", "why", "ym", "your", "MY", "My"], "fbh": ["fbx", "fdh", "fey", "fxhi", "fsy", "few", "bbsh", "fxw", "fsh", "fcg", "pbh", "bbh", "fbsh", "bx", "ebk", "fcy", "pbhi", "fby", "ebw", "bw", "fdsh", "fek", "bby", "feh", "fex", "bk", "fch", "ebx", "bbw", "fdy", "fbg", "bbk", "fsg", "fsx", "fbhi", "fdw", "pbk", "fxk", "fcx", "fxh", "pbw", "feg", "bbhi", "bh", "ebh", "fbk", "fxsh", "fxy"], "fbw": ["fbx", "cbm", "rby", "fy", "fw", "fbm", "cbw", "fh", "fbv", "fcw", "fv", "cbx", "rbx", "bbh", "cfx", "fx", "rbm", "cby", "fby", "bbx", "rbh", "bby", "rbw", "fch", "bbw", "cfh", "cfv", "bbm", "fcv", "fcx", "cbh", "cfw"], "ww": ["rw", "hw", "nw", "yah", "fw", "wx", "nn", "wed", "dd", "sw", "wn", "sem", "wp", "oh", "wa", "wk", "dx", "fx", "wb", "wy", "wo", "wd", "w", "www", "tw", "hh", "rx", "wow", "whe", "kw", "qa", "wal", "iw", "gh", "mm", "wl", "sq", "xx", "ew"], "wh": ["rw", "hw", "ko", "nw", "fw", "wx", "eth", "sw", "WH", "wm", "wp", "oh", "wa", "wk", "rh", "sk", "wy", "how", "wo", "ffff", "ph", "han", "wd", "sh", "w", "we", "www", "tw", "self", "hop", "whe", "kw", "wr", "wal", "h", "hy", "gh", "hi", "mm", "who", "xx", "rah", "Wh", "ff"]}}
{"project": "qemu", "commit_id": "90e26f5aacd265257f7de58ee59f72dc36dff40e", "target": 0, "func": "target_ulong do_arm_semihosting(CPUARMState *env)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong args;\n\n    target_ulong arg0, arg1, arg2, arg3;\n\n    char * s;\n\n    int nr;\n\n    uint32_t ret;\n\n    uint32_t len;\n\n#ifdef CONFIG_USER_ONLY\n\n    TaskState *ts = cs->opaque;\n\n#else\n\n    CPUARMState *ts = env;\n\n#endif\n\n\n\n    if (is_a64(env)) {\n\n        /* Note that the syscall number is in W0, not X0 */\n\n        nr = env->xregs[0] & 0xffffffffU;\n\n        args = env->xregs[1];\n\n    } else {\n\n        nr = env->regs[0];\n\n        args = env->regs[1];\n\n    }\n\n\n\n    switch (nr) {\n\n    case TARGET_SYS_OPEN:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        s = lock_user_string(arg0);\n\n        if (!s) {\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        }\n\n        if (arg1 >= 12) {\n\n            unlock_user(s, arg0, 0);\n\n            return (uint32_t)-1;\n\n        }\n\n        if (strcmp(s, \":tt\") == 0) {\n\n            int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;\n\n            unlock_user(s, arg0, 0);\n\n            return result_fileno;\n\n        }\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"open,%s,%x,1a4\", arg0,\n\n                                  (int)arg2+1, gdb_open_modeflags[arg1]);\n\n        } else {\n\n            ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));\n\n        }\n\n        unlock_user(s, arg0, 0);\n\n        return ret;\n\n    case TARGET_SYS_CLOSE:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"close,%x\", arg0);\n\n        } else {\n\n            return set_swi_errno(ts, close(arg0));\n\n        }\n\n    case TARGET_SYS_WRITEC:\n\n        {\n\n          char c;\n\n\n\n          if (get_user_u8(c, args))\n\n              /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n              return (uint32_t)-1;\n\n          /* Write to debug console.  stderr is near enough.  */\n\n          if (use_gdb_syscalls()) {\n\n                return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,1\", args);\n\n          } else {\n\n                return write(STDERR_FILENO, &c, 1);\n\n          }\n\n        }\n\n    case TARGET_SYS_WRITE0:\n\n        if (!(s = lock_user_string(args)))\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        len = strlen(s);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,%x\",\n\n                                   args, len);\n\n        } else {\n\n            ret = write(STDERR_FILENO, s, len);\n\n        }\n\n        unlock_user(s, args, 0);\n\n        return ret;\n\n    case TARGET_SYS_WRITE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_READ, arg1, len, 1);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, write(arg0, s, len));\n\n            unlock_user(s, arg1, 0);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READ:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"read,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_WRITE, arg1, len, 0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            do {\n\n                ret = set_swi_errno(ts, read(arg0, s, len));\n\n            } while (ret == -1 && errno == EINTR);\n\n            unlock_user(s, arg1, len);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READC:\n\n       /* XXX: Read from debug console. Not implemented.  */\n\n        return 0;\n\n    case TARGET_SYS_ISTTY:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"isatty,%x\", arg0);\n\n        } else {\n\n            return isatty(arg0);\n\n        }\n\n    case TARGET_SYS_SEEK:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"lseek,%x,%x,0\",\n\n                                   arg0, arg1);\n\n        } else {\n\n            ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET));\n\n            if (ret == (uint32_t)-1)\n\n              return -1;\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_FLEN:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_flen_cb, \"fstat,%x,%x\",\n\n                                   arg0, arm_flen_buf(cpu));\n\n        } else {\n\n            struct stat buf;\n\n            ret = set_swi_errno(ts, fstat(arg0, &buf));\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return buf.st_size;\n\n        }\n\n    case TARGET_SYS_TMPNAM:\n\n        /* XXX: Not implemented.  */\n\n        return -1;\n\n    case TARGET_SYS_REMOVE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"unlink,%s\",\n\n                                  arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret =  set_swi_errno(ts, remove(s));\n\n            unlock_user(s, arg0, 0);\n\n        }\n\n        return ret;\n\n    case TARGET_SYS_RENAME:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        GET_ARG(3);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"rename,%s,%s\",\n\n                                   arg0, (int)arg1+1, arg2, (int)arg3+1);\n\n        } else {\n\n            char *s2;\n\n            s = lock_user_string(arg0);\n\n            s2 = lock_user_string(arg2);\n\n            if (!s || !s2)\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                ret = (uint32_t)-1;\n\n            else\n\n                ret = set_swi_errno(ts, rename(s, s2));\n\n            if (s2)\n\n                unlock_user(s2, arg2, 0);\n\n            if (s)\n\n                unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_CLOCK:\n\n        return clock() / (CLOCKS_PER_SEC / 100);\n\n    case TARGET_SYS_TIME:\n\n        return set_swi_errno(ts, time(NULL));\n\n    case TARGET_SYS_SYSTEM:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"system,%s\",\n\n                                   arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, system(s));\n\n            unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_ERRNO:\n\n#ifdef CONFIG_USER_ONLY\n\n        return ts->swi_errno;\n\n#else\n\n        return syscall_err;\n\n#endif\n\n    case TARGET_SYS_GET_CMDLINE:\n\n        {\n\n            /* Build a command-line from the original argv.\n\n             *\n\n             * The inputs are:\n\n             *     * arg0, pointer to a buffer of at least the size\n\n             *               specified in arg1.\n\n             *     * arg1, size of the buffer pointed to by arg0 in\n\n             *               bytes.\n\n             *\n\n             * The outputs are:\n\n             *     * arg0, pointer to null-terminated string of the\n\n             *               command line.\n\n             *     * arg1, length of the string pointed to by arg0.\n\n             */\n\n\n\n            char *output_buffer;\n\n            size_t input_size;\n\n            size_t output_size;\n\n            int status = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n            const char *cmdline;\n\n#endif\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n            input_size = arg1;\n\n            /* Compute the size of the output string.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            cmdline = semihosting_get_cmdline();\n\n            if (cmdline == NULL) {\n\n                cmdline = \"\"; /* Default to an empty line. */\n\n            }\n\n            output_size = strlen(cmdline) + 1; /* Count terminating 0. */\n\n#else\n\n            unsigned int i;\n\n\n\n            output_size = ts->info->arg_end - ts->info->arg_start;\n\n            if (!output_size) {\n\n                /* We special-case the \"empty command line\" case (argc==0).\n\n                   Just provide the terminating 0. */\n\n                output_size = 1;\n\n            }\n\n#endif\n\n\n\n            if (output_size > input_size) {\n\n                 /* Not enough space to store command-line arguments.  */\n\n                return -1;\n\n            }\n\n\n\n            /* Adjust the command-line length.  */\n\n            if (SET_ARG(1, output_size - 1)) {\n\n                /* Couldn't write back to argument block */\n\n                return -1;\n\n            }\n\n\n\n            /* Lock the buffer on the ARM side.  */\n\n            output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0);\n\n            if (!output_buffer) {\n\n                return -1;\n\n            }\n\n\n\n            /* Copy the command-line arguments.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            pstrcpy(output_buffer, output_size, cmdline);\n\n#else\n\n            if (output_size == 1) {\n\n                /* Empty command-line.  */\n\n                output_buffer[0] = '\\0';\n\n                goto out;\n\n            }\n\n\n\n            if (copy_from_user(output_buffer, ts->info->arg_start,\n\n                               output_size)) {\n\n                status = -1;\n\n                goto out;\n\n            }\n\n\n\n            /* Separate arguments by white spaces.  */\n\n            for (i = 0; i < output_size - 1; i++) {\n\n                if (output_buffer[i] == 0) {\n\n                    output_buffer[i] = ' ';\n\n                }\n\n            }\n\n        out:\n\n#endif\n\n            /* Unlock the buffer on the ARM side.  */\n\n            unlock_user(output_buffer, arg0, output_size);\n\n\n\n            return status;\n\n        }\n\n    case TARGET_SYS_HEAPINFO:\n\n        {\n\n            target_ulong retvals[4];\n\n            uint32_t limit;\n\n            int i;\n\n\n\n            GET_ARG(0);\n\n\n\n#ifdef CONFIG_USER_ONLY\n\n            /* Some C libraries assume the heap immediately follows .bss, so\n\n               allocate it using sbrk.  */\n\n            if (!ts->heap_limit) {\n\n                abi_ulong ret;\n\n\n\n                ts->heap_base = do_brk(0);\n\n                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;\n\n                /* Try a big heap, and reduce the size if that fails.  */\n\n                for (;;) {\n\n                    ret = do_brk(limit);\n\n                    if (ret >= limit) {\n\n                        break;\n\n                    }\n\n                    limit = (ts->heap_base >> 1) + (limit >> 1);\n\n                }\n\n                ts->heap_limit = limit;\n\n            }\n\n\n\n            retvals[0] = ts->heap_base;\n\n            retvals[1] = ts->heap_limit;\n\n            retvals[2] = ts->stack_base;\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#else\n\n            limit = ram_size;\n\n            /* TODO: Make this use the limit of the loaded application.  */\n\n            retvals[0] = limit / 2;\n\n            retvals[1] = limit;\n\n            retvals[2] = limit; /* Stack base */\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#endif\n\n\n\n            for (i = 0; i < ARRAY_SIZE(retvals); i++) {\n\n                bool fail;\n\n\n\n                if (is_a64(env)) {\n\n                    fail = put_user_u64(retvals[i], arg0 + i * 8);\n\n                } else {\n\n                    fail = put_user_u32(retvals[i], arg0 + i * 4);\n\n                }\n\n\n\n                if (fail) {\n\n                    /* Couldn't write back to argument block */\n\n                    return -1;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_EXIT:\n\n        if (is_a64(env)) {\n\n            /* The A64 version of this call takes a parameter block,\n\n             * so the application-exit type can return a subcode which\n\n             * is the exit status code from the application.\n\n             */\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n\n\n            if (arg0 == ADP_Stopped_ApplicationExit) {\n\n                ret = arg1;\n\n            } else {\n\n                ret = 1;\n\n            }\n\n        } else {\n\n            /* ARM specifies only Stopped_ApplicationExit as normal\n\n             * exit, everything else is considered an error */\n\n            ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1;\n\n        }\n\n        gdb_exit(env, ret);\n\n        exit(ret);\n\n    case TARGET_SYS_SYNCCACHE:\n\n        /* Clean the D-cache and invalidate the I-cache for the specified\n\n         * virtual address range. This is a nop for us since we don't\n\n         * implement caches. This is only present on A64.\n\n         */\n\n        if (is_a64(env)) {\n\n            return 0;\n\n        }\n\n        /* fall through -- invalid for A32/T32 */\n\n    default:\n\n        fprintf(stderr, \"qemu: Unsupported SemiHosting SWI 0x%02x\\n\", nr);\n\n        cpu_dump_state(cs, stderr, fprintf, 0);\n\n        abort();\n\n    }\n\n}\n", "idx": 7462, "substitutes": {"env": ["osc", "eng", "ch", "nw", "ea", "python", "serv", "er", "v", "vm", "scope", "config", "qt", "environment", "exc", "oa", "et", "enc", "ace", "eu", "inet", "db", "event", "ext", "state", "server", "exe", "iss", "init", "conf", "ev", "net", "vs", "e", "np", "que", "code", "en", "inst", "dev", "her", "ctx", "bc", "err", "loader", "exec", "context", "ne", "ec", "settings", "stage", "opt", "eni", "console", "proc", "eve", "txt", "shell", "cf", "engine", "site", "cache", "host", "manager", "conn", "end", "dict"], "cpu": ["cp", "hp", "gp", "bench", "pid", "hw", "gc", "anc", "python", "cr", "chip", "phy", "intel", "platform", "pu", "vm", "roc", "device", "config", "nc", "cat", "sys", "gpu", "px", "ips", "mac", "uci", "pc", "linux", "net", "np", "ck", "nic", "rpm", "conn", "ctx", "bc", "cu", "jp", "processor", "computer", "sta", "css", "boot", "proc", "os", "node", "cn", "lc", "core", "fc", "cow", "CPU", "cm"], "cs": ["cp", "Cs", "spec", "ci", "cus", "nc", "sync", "sys", "ants", "ns", "ls", "pc", "TS", "cc", "tc", "ss", "CS", "vs", "sc", "ars", "gs", "ks", "ds", "ctx", "bc", "ec", "css", "acs", "utils", "vc", "rs", "cas", "conn"], "args": ["stat", "name", "strings", "afi", "aug", "extra", "ig", "sec", "ins", "count", "alls", "arms", "data", "Args", "enc", "vals", "results", "ants", "parts", "ns", "ext", "call", "stats", "obj", "arg", "py", "uments", "pc", "active", "actions", "ints", "code", "all", "ars", "gs", "arr", "binary", "cmd", "bytes", "outs", "seq", "array", "asm", "blocks", "alloc", "ids", "params", "aux", "ras", "max", "flags"], "arg0": ["param2", " arg6", " arg11", "argsname", "argument1", "argname", "ag1", "Arg8", "Arg11", "val1", "ax6", "argument2", "arg4", "param0", "ag2", "param8", "Arg0", "ax1", "ag90", "args1", "Arg90", "ag0", " arg4", "args2", "argument0", "val11", "paramname", "args0", " arg90", "Arg6", "ax2", "arg11", " arg8", "arg8", " argname", "arg90", "args4", "argument4", "val0", "arg6", "Arg1", "Arg2", "val2", "ax0", "param1"], "arg1": ["param2", "ax01", "args3", "ar3", "ar1", "argument1", "param5", "ag1", "argument2", " arg5", "ag2", "param0", "argument5", "ar0", "arg01", " arg01", "arg5", "Arg0", "ax1", "args1", "Arg01", "ag0", "args2", " argX", "argument0", "ar2", "argsX", "args0", "ax2", "agX", "Arg3", "Arg1", "Arg2", "argX", "ax0", "param1"], "arg2": ["argument8", "argument1", "argument2", "args8", "arg4", "argument3", "Arg0", "args1", " arg4", "args2", "argument0", " arg8", "arg8", "args4", "argument4", "Arg3", "Arg1", "Arg2"], "arg3": ["param3", "param2", " arg63", "param63", "argument3", "argument2", "argument63", "argument1", "arg63", "param1"], "s": ["sf", "S", "b", "socket", "status", "f", "service", "sid", "hs", "h", "aws", "sp", "sa", "g", "sym", "y", "sets", "is", "spec", "services", "states", "server", "sl", "ls", "sie", "ds", "str", "settings", "sv", "fs", "sq", "your", "site", "rs", "strings", "sr", "ins", "sg", "sync", "sn", "ses", "opens", "u", "e", "submit", "sb", "ks", "secondary", "t", "ruby", "p", "input", "shell", "os", "ssl", "r", "ps", "o", "session", "si", "sys", "m", "l", "ns", "stats", "ss", "uns", "gs", "n", "su", "js"], "nr": ["rn", "nl", "gr", "nos", "nor", "nw", "vr", "sr", "NR", "rr", "radius", "rb", "chain", "ni", "nc", "rf", "inv", "sn", "rel", "nir", "loc", "num", "ru", "ng", "attr", "np", "arin", "number", "nic", "rg", "n", " sr", "rx", "lr", "cb", "nz", "nb", "rl", "result", "rev", "rin", "wr", "nar", "usr", "ner", "mr", "yr", "addr", "cn", "adr", " ni", "next", "kr", "rob", "r", "nu"], "ret": ["std", "flag", " arg", "sr", "rt", "id", "mem", "alt", "reg", "nt", "value", "rb", "val", "sum", " res", "cat", "info", "reply", " ar", "status", "num", "lit", "job", " reply", "obj", "arg", "active", "res", "det", "out", "arr", "RET", "fit", " sr", "feat", "str", "rev", "result", "sun", " result", "Ret", "run", "re", "fun", "back", "resp", "addr", "br", "success", "ref", " flags", " returns", "rets", " arr"], "len": ["lang", "base", "flag", "bin", "mem", "sec", "alt", "rot", "val", "enc", "loc", "length", "arg", "obj", "all", "arr", "bytes", "str", "rev", "lock", "seq", "pos", "gen", "ln", "Len", "resp"], "ts": ["as", "options", "te", "ins", "fts", "alls", "ets", "scope", "tr", "sys", "ses", "tty", "states", "tx", "xs", "Ts", "ns", "ats", "ls", "TS", "pc", "stats", "us", "ss", "hs", "ics", "vs", "mt", "ars", "gs", "ops", "ks", "t", "ds", "qs", "tz", "acs", "fs", "ta", "ms", "uts", "tp", "tt", "rs", "times", "ps", "rets", "tc"]}}
{"project": "FFmpeg", "commit_id": "3dfbdb328ed9e88cebc6462c56cfe61e55850b2e", "target": 0, "func": "static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)\n\n{\n\n    int v;\n\n    int i = 0;\n\n    uint8_t state[CONTEXT_SIZE];\n\n\n\n    memset(state, 128, sizeof(state));\n\n\n\n    for (v = 0; i < 128; v++) {\n\n        unsigned len = get_symbol(c, state, 0) + 1;\n\n\n\n        if (len > 128 - i)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        while (len--) {\n\n            quant_table[i] = scale * v;\n\n            i++;\n\n        }\n\n    }\n\n\n\n    for (i = 1; i < 128; i++)\n\n        quant_table[256 - i] = -quant_table[i];\n\n    quant_table[128] = -quant_table[127];\n\n\n\n    return 2 * v - 1;\n\n}\n", "idx": 17723, "substitutes": {"c": ["dc", "pc", "oc", "ic", "m", "ch", "code", "f", "cus", "ct", "rc", "r", "cm", "cf", "cb", "bc", "cp", "fc", "mc", "cy", "cs", "l", "d", "ce", "nc", "ac", "xc", "e", "sc", "cr", "lc", "p", "b", "ec", "unc", "icc", "C", "cc", "u"], "quant_table": ["quant_tree", "quant_module", "quantsbuffer", "quantisttest", "user_bottom", "quant_TABLE", "volumeisttable", "volume_test", "user_part", "quant_source", "quantitytree", "queryitymodule", "quant_cache", "quant_scale", "querystable", "queryityheader", "quant0cache", "quantscount", "querystree", "useritytable", "component_table", "quantitypart", "componentingtable", "useritycache", "volumeistTABLE", "componentingcache", "quant_count", "component_source", "quantityheader", "quant_header", "useritypart", "query_cache", "qual_list", "quantstree", "quantitytable", "quantsscale", "query_tree", "quantscache", "querysbuffer", "quantentree", "queryscache", "quantistcache", "componentingiterator", "quantingcache", "quant_list", "quant0iterator", "queryitytable", "quantitycache", "query_header", "query_buffer", "query_module", "quantstable", "queryitytree", "useritybottom", "quantingsource", "query_table", "quantentable", "quantisttable", "component_iterator", "quant_buffer", "user_table", "quantslist", "quantingiterator", "qual_table", "volume_table", "quant_bottom", "quant_iterator", "quantitybottom", "quant0table", "qual_count", "quantenmodule", "component_cache", "user_cache", "componentingsource", "quant_test", "quant_part", "quantistTABLE", "volumeistcache", "quantingtable", "quantenheader", "quant0source", "quantitymodule", "volumeisttest", "volume_cache", "volume_TABLE", "qual_scale"], "scale": ["Scale", "sup", "offset", "shape", "data", "mode", "base", "cale", "slice", "range", "gain", "alias", " Scale", "grade", "size", "pi", "seed", "rule", "adjust", "value", "ize", "start", "delay", "e", "unit", "ale", "si", "shift", "norm", "rate", "fee", "error", "beta", "transform", "repeat", "co", "se", "alpha", "order", "factor", "u"], "v": ["m", "vid", "V", "j", "s", "t", "x", "f", "sv", "vc", "vp", "ver", "n", "g", "z", "ii", "vi", "lv", "count", "o", "uv", "l", "val", "conv", "size", "pi", "ui", "ci", "w", "length", "id", "k", "e", "q", "limit", "vs", "si", "p", "b", "va", "h", "iv", "a", "nv", "value", "li", "u"], "state": ["instance", "session", "stat", "j", "ch", "code", "data", "core", "err", "buffer", "r", "trace", "result", "channel", "g", "block", "ctx", "scope", "slice", "pointer", "is", "State", "range", "context", "store", "size", "memory", "seed", "style", "use", "config", "length", "start", "e", "sync", "private", "cur", "parent", "STATE", "p", "address", "cache", "resource", "output", "param", "connection", "states", "value", "source", "conn"], "len": ["j", "code", "base", "lit", "vec", "n", "pl", "lu", "sl", "ie", "ii", "dl", "pos", "ind", " l", "en", "count", "min", "L", "lf", "ln", "l", "val", "fl", "le", "size", "length", "hl", "il", "limit", "ler", "e", "id", "rev", "lc", "line", "split", "lin", "iter", "el", "li", "Len"], "i": ["gi", "uri", "m", "bi", "j", "ji", "t", "info", "x", "f", "ix", "ini", "qi", "r", "ai", "io", "n", "phi", "mi", "z", "ii", "ie", "iu", "di", "index", "I", "vi", "o", "ip", "l", "d", "yi", "pi", "ui", "ci", "length", "id", "k", "q", "e", "limit", "lc", "ni", "si", "xi", "p", "line", "b", "h", "a", "api", "iter", "it", "fi", "y", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "7104c23bd1a1dcb8a7d9e2c8838c7ce55c30a331", "target": 0, "func": "static void rv34_pred_mv_rv3(RV34DecContext *r, int block_type, int dir)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int A[2] = {0}, B[2], C[2];\n\n    int i, j, k;\n\n    int mx, my;\n\n    int avail_index = avail_indexes[0];\n\n\n\n    if(r->avail_cache[avail_index - 1]){\n\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];\n\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];\n\n    }\n\n    if(r->avail_cache[avail_index - 4]){\n\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + 2]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride + 2][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[0][0];\n\n    my += r->dmv[0][1];\n\n    for(j = 0; j < 2; j++){\n\n        for(i = 0; i < 2; i++){\n\n            for(k = 0; k < 2; k++){\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][0] = mx;\n\n                s->current_picture_ptr->f.motion_val[k][mv_pos + i + j*s->b8_stride][1] = my;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 12106, "substitutes": {"r": ["l", "tr", "n", "hr", "w", "m", "fr", "mr", "rr", "b", "t", "kr", "gr", "d", "c", "nor", "p", "e", "rss", "ir", "rb", "rs", "er", "f", "dr", "rt", "res", "v", "R", "rc", "ner", "ar", "pr", "err", "nr", "ur", "re", "h", "rg", "result", "sr", "br", "rh"], "block_type": [" blocktypetype", " blocktypetypes", " blocktypefile", "block_file", " blockblockheader", " block_types", " block_file", "block_header", " block_header", " blockblocktype", " blocktypeheader", "block_types", " blockblockfile", " blockblocktypes"], "dir": ["round", "orient", "dim", "def", "w", "src", "path", "rec", "d", "ref", "mode", "Dir", "unit", "lib", "ind", "order", " direction", "sort", "circ", "desc", "ii", "file", "DIR", "cache", "depth", "D", "direction"], "s": ["l", "session", "is", "m", "http", "t", "x", "sci", "z", "gs", "er", "sy", "v", "bis", "ns", "spec", "self", "settings", "sg", "ds", "n", "si", "sf", "w", "b", "ship", "c", "e", "se", "sq", "us", "f", "sym", "sets", "sky", "es", "current", "sup", "en", "u", "fs", "su", "site", "ps", "ss", "sc", "ks", "g", "stats", "d", "ls", "share", "os", "o", "sl", "sb", "sys", "side", "single", "secondary", "a", "sr", "core", "ssl", "setup", "conf", "sports", "ts", "in", "service", "p", "server", "qs", "xs", "rs", "js", "sec", "multi", "S", "services", "less", "h", "ses", "y", "inf"], "A": ["As", "Ca", "AR", "LA", "MA", "At", "BA", "Q", "E", "AU", "This", "Alpha", "Average", "AV", "X", "An", "Action", "AB", "Ar", "AST", "P", "GA", "The", "SA", "G", "N", "T", "S", "AA", "And", "R", "IA", "AT", "Java", "L", "V", "AM", "Y", "Array", " a", "API", "NA", "Data", "HA", "AD", "All", "AW", "Area", "AS", "H", "I", "F", "AP", "U", "a", "AC", "Auth", "Adam", "W", "CA", "Am", "M", "AN", "D", "mA"], "B": ["BR", "GB", "Z", "Block", "BD", "Bo", "BA", "BC", "E", "O", "b", "LB", "BG", "RB", "Base", "X", "But", "BB", "FB", "BE", "AB", "P", "BS", "BI", "G", "T", "N", "QB", "S", "EB", "R", "NB", "WB", "L", "V", "MN", "Y", "BF", "UB", "Both", "H", "Br", "I", "F", "U", "Q", "Bar", "Bl", "W", "Bs", "M", "OB", "D", "DB"], "C": ["Ca", "CC", "SC", "Code", "DC", "BC", "CT", "E", "O", "CV", "GC", "CE", "MC", "Cons", "c", "Cache", "KC", "X", "CU", "VC", "Sc", "P", "YC", "G", "N", "T", "NC", "S", "R", "CS", "V", "L", "CI", "Y", "K", "Cl", "CL", "Col", "H", "Ch", "CW", "F", "Q", "U", "CNN", "CP", "Count", "W", "CA", "EC", "M", "Cu", "D", "Con"], "i": ["it", "n", "m", "b", "x", "z", "d", "c", "p", "e", "ia", "f", "ai", "mi", "phi", "ti", "bi", "pi", "ii", "h", "I", "li", "ip", "ci", "iu"], "j": ["l", "je", "n", "g", "w", "m", "b", "x", "z", "ji", "p", "kj", "q", "uj", "o", "v", "ij", "jp", "ii", "ja", "h", "pos", "J", "y", "jl"], "k": ["dk", "n", "g", "w", "m", "kr", "z", "x", "p", "e", "q", "ak", "f", "sk", "o", "v", "ik", "K", "kw", "u", "h", "y", "mk", "ki", "kk"], "mx": ["me", "mn", " mm", "mos", "hh", "m", " m", "mm", "mu", "wm", "np", "nm", "ml", "yx", "mi", "mmm", "nr", " mc", "ms", "nz", "cm", "rx", "ma", "px", "ng", "ap", "M", "mc"], "my": ["me", "mis", "mn", "mos", "in", "hh", "mr", "mm", "mon", "mu", "np", "mic", "pm", "nm", "mid", "mi", "MY", "md", "am", "Mi", "mmm", "ms", "mo", "mys", "mc", "My", "yo"]}}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "func": "static bool use_multiport(VirtIOSerial *vser)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n\n    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);\n\n}\n", "idx": 4389, "substitutes": {"vser": ["wsoc", "wSER", "svserver", "evcer", "vserver", "evser", "svser", "wser", " vserv", "lvsoc", "vsoc", "svserv", "vcer", "vserv", " vSER", "svsoc", "svcer", "wserver", "svSER", "lvserver", "evserv", " vcer", "lvser", "lvSER", "vSER", "evSER"], "vdev": ["voltdes", "vbus", "evser", "vdevice", "voltser", " vserv", "varser", " vdes", "vardevice", "varbus", "vserv", "voltdev", "lser", " vdevice", " vbus", "lbus", "evdev", "ldev", "evserv", "ldevice", "vdes", "voltserv", "vardev", "evdes"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void get_xbzrle_cache_stats(MigrationInfo *info)\n\n{\n\n    if (migrate_use_xbzrle()) {\n\n        info->has_xbzrle_cache = true;\n\n        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));\n\n        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();\n\n        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();\n\n        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();\n\n        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();\n\n        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();\n\n        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();\n\n    }\n\n}\n", "idx": 22906, "substitutes": {"info": ["io", "ami", "i", "txt", "start", "def", "Info", "end", "off", "app", "hand", "config", "ui", "result", "this", "part", "INFO", "extra", "gi", "afi", "json", "build", "f", "op", "information", "it", "data", "bug", "init", "state", "full", "link", "inf", "diff", "setup", "id", "help", "inner", "is", "py", "thin", "index", "aux", "check", "si", "die", "tf", "ii", "now", "error", "utils", "hi", "feed", "options", "update", "di", "http", "conf", "base", "li", "manager", "image", "api", "fo", "type"]}}
{"project": "FFmpeg", "commit_id": "2f996b8397ee0e646a824f3dfcbd291a114af348", "target": 0, "func": "int MP3lame_encode_frame(AVCodecContext *avctx,\n\n                     unsigned char *frame, int buf_size, void *data)\n\n{\n\n\tMp3AudioContext *s = avctx->priv_data;\n\n\tint num, i;\n\n//av_log(avctx, AV_LOG_DEBUG, \"%X %d %X\\n\", (int)frame, buf_size, (int)data);\n\n//        if(data==NULL)\n\n//            return lame_encode_flush(s->gfp, frame, buf_size);\n\n\n\n\t/* lame 3.91 dies on '1-channel interleaved' data */\n\n\tif (s->stereo) {\n\n\t\tnum = lame_encode_buffer_interleaved(s->gfp, data,\n\n\t\t\tMPA_FRAME_SIZE, frame, buf_size);\n\n\t} else {\n\n\t\tnum = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,\n\n\t\t\tframe, buf_size);\n\n\n\n/*av_log(avctx, AV_LOG_DEBUG, \"in:%d out:%d\\n\", MPA_FRAME_SIZE, num);\n\nfor(i=0; i<num; i++){\n\n    av_log(avctx, AV_LOG_DEBUG, \"%2X \", frame[i]);\n\n}*/\n\n\t}\n\n\n\n\treturn num;\n\n}\n", "idx": 7122, "substitutes": {"avctx": [" avcontext", "ajconfig", "avca", "afca", " avconfig", "apcontext", "afcb", "acca", " avcca", "avconfig", "avcca", "avcb", "afctx", "apctx", "apcb", "avcontext", "ajcca", "acctx", "accontext", "afcontext", "afconfig", "ajctx", "ajcontext", "afcca", "apca", "accb"], "frame": ["scene", "base", "game", "flow", "dy", "time", "position", "header", "channel", "iframe", "family", "format", "face", "slice", "image", "Frame", "draw", "window", "fake", "f", "event", "series", "document", "property", "code", "buffer", "point", "part", "message", "fram", "file", "cycle", "source", "scale", "line", "setup", "type", "video", "frames", "board", "sample", "element", "fi", "stroke", "feature"], "buf_size": ["buf0size", "window_type", "bufingstring", "buf_sized", "queue_sized", "buf0scale", " buf_string", " buf_SIZE", "window_size", "buf_len", "buf_level", "bufftype", "bufingcode", "queue_source", "window_len", "buf_type", "buf_code", "buf0source", "windowflen", "windowftype", "windowflevel", "windowfsize", "queue_size", "bufingsize", "queue_scale", "buf_scale", " buf_code", "buf_SIZE", "buf0sized", "bufflen", "buf_string", "bufflevel", "window_level", "buffsize", "bufingSIZE", "buf_source"], "data": ["base", "o", "block", "id", "a", "parent", "done", "dat", "device", "final", "family", "format", "database", "info", "m", "image", "body", "missing", "draw", "window", "package", "f", "content", "media", "d", "DATA", "buffer", "e", "message", "Data", "empty", "source", "p", "input", "result", "scale", "xxx", "zero", "start", "none", "api", "video", "board", "sample", "cache", "next", "partial", "size"], "s": ["as", "o", "sec", "is", "S", "a", "comm", "spec", "scope", "session", "com", "si", "sync", "enc", "sys", "ses", "services", "m", "xs", "private", "f", "client", "parts", "ns", "d", "ls", "space", "service", "cs", "ss", "u", "e", "sc", "an", "w", "sb", "bis", "ds", "t", "n", "ctx", "p", "aws", "fs", "sup", "sa", "c", "ssl", "sq", "sym", "ps", "js"], "num": ["uni", "o", "na", "iter", "bin", "id", "count", "ni", "val", "sum", "b", "x", "umi", "update", "info", "unit", "loc", "uu", "inc", "f", "offset", "nr", "init", "u", "number", "len", "con", "en", "Num", "fn", "n", "NUM", "multi", "su", "result", "pos", "gen", "off", "orig", "ul", "um", "mu", "index", "no", "dim", "end", "ui", "nu"], "i": ["ti", "id", "I", "ci", "b", "si", "io", "umi", "m", "in", "f", "pi", "j", "ii", "it", "ai", "init", "u", "n", "mi", "p", "c", "ip", "ind", "li", "inner", "index", "ui"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_register_reset(QEMUResetHandler *func, void *opaque)\n\n{\n\n    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));\n\n\n\n    re->func = func;\n\n    re->opaque = opaque;\n\n    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);\n\n}\n", "idx": 13513, "substitutes": {"func": ["args", "proc", "pkg", "unc", "amd", "pc", "val", "code", "name", "fun", "fp", "fn", "job", "package", "conn", "obj", "super", "handler", "rb", "rx", "buf", "data", "entry", "f", "rl", "parser", "cb", "function", "attr", "rule", "cmd", "cf", "aux", "wrapper", "exec", "ack", "r", "src", "work", "wrap", "lambda", "addr", "apply", "ctx", "go", "callback"], "opaque": ["opace", " opaques", "oppaco", "ipesc", "opesc", "oppesc", "operaco", "ipaco", "oppacity", "oacity", "oaques", "oaque", "hopaques", "oppaque", "operacity", "opericit", "hopaque", "opaco", "opaques", "oicit", "operaque", " opicit", "ipacity", "hopace", "opacity", "ipaque", "operque", "operesc", " opque", "opque", " opacity", "oace", "hopacity", "oque", " opace", "opicit"], "re": ["record", "ret", "bre", "rev", "ru", "reply", "reb", "array", "response", "ere", "ren", "rs", "pre", "g", "rg", "ref", "cre", "fr", "parse", " rec", "rec", "e", "rew", "resource", "entry", "Rec", "rm", "reset", "arr", "ry", "per", "ro", "change", "rule", "rt", "r", "resp", "cache", "ae", "Re", "ar", "real", "dr", "res", "rel", "reg", "rem", "gre", "RE", "replace"]}}
{"project": "qemu", "commit_id": "595ab64169be9063d64c3b1aa1c249fbe2662221", "target": 1, "func": "static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    ssize_t len;\n\n\n\n    do {\n\n        len = qemu_recv(s->fd, buf, size, 0);\n\n    } while (len == -1 && socket_error() == EINTR);\n\n\n\n    if (len == -1)\n\n        len = -socket_error();\n\n\n\n    return len;\n\n}\n", "idx": 13736, "substitutes": {"opaque": [" opaques", "opace", "oppaques", "oppity", "oppca", "opity", "oopca", "oppaque", "opaques", "iopace", "opca", " opicit", "oopaque", "iopaque", "phpace", " opque", "oopity", "opque", "iopque", "phpicit", "phpque", " opace", "phpaque", " opity", "oopaques", "opicit", " opca", "iopicit"], "buf": ["vec", "port", "context", "blocks", "bc", "queue", "fd", "cv", "fl", "batch", "config", "fb", "uf", "bound", "bytes", "pool", "buffer", "bag", "loc", "fp", "buff", "rb", "pb", "data", "b", "base", "Buffer", "box", "length", "wb", "f", "ab", "c", "cb", "cap", "que", "db", "cache", "src", "seq", "ctx", "lim", "alloc"], "pos": [" offset", "port", "val", " position", "os", "str", "position", "loc", "limit", "set", " index", "p", "pointer", "base", "from", "address", "block", "end", "offset", " positions", " start", "seq", "Pos", "off", "no", "addr", "start"], "size": ["args", "en", "small", "enc", "id", "code", "name", "Size", "bytes", "position", "loc", "limit", "z", "ize", "p", "e", "data", "length", "count", "n", "address", "c", "timeout", "end", "SIZE", "offset", "sn", "cache", "empty", "start"], "s": ["sys", "ses", "m", "service", "sync", "fs", "sym", "syn", "S", "os", "si", "es", "js", "sq", "session", "server", "o", "p", "e", "sec", "socket", "http", "sb", "f", "gs", "spec", "c", "ns", "is", "ssl", "sl", "ops", "ds", "sie", "sa", "ls", "ips", "ts"], "len": ["ln", "vec", "en", "rev", "hl", "_", "fl", "Len", "rc", " lang", "l", "val", "i", "code", "pre", " length", "lc", "fun", " el", "h", " lib", "bytes", "str", "ie", "js", "fn", "limit", "lib", " l", "dy", "ll", "z", "e", "fin", "lt", "li", "data", "length", "ler", "n", "count", "f", "line", "lf", "url", " err", "body", "nt", "all", "le", "sl", "elt", "db", "El", "ls", "num", "no", "el", "err"]}}
{"project": "qemu", "commit_id": "21a0b6ed1dd9f1d8e3d953954847776c8697bd99", "target": 0, "func": "target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)\n\n{\n\n    uint32_t tlbncfg;\n\n    int tlbn = booke206_tlbm_to_tlbn(env, tlb);\n\n    int tlbm_size;\n\n\n\n    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];\n\n\n\n    if (tlbncfg & TLBnCFG_AVAIL) {\n\n        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;\n\n    } else {\n\n        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;\n\n        tlbm_size <<= 1;\n\n    }\n\n\n\n    return 1024ULL << tlbm_size;\n\n}\n", "idx": 22276, "substitutes": {"env": ["inv", "enh", "e", "en", "conn", "err", "obj", "eu", "config", "eur", "eni", "chal", "him", "db", "ench", "eng", "impl", "energy", "engine", "ea", "eve", "ef", "exec", "esi", "exc", "her", "enc", "vs", "code", "context", "Environment", "ext", "el", "loader", "profile", "esm", "viron", "enter", "er", "console", "iss", "v", "qt", "erv", "estate", "ev", "environment", "ec", "emb"], "tlb": ["ttlam", "atbm", "atlb", "llb", "tbm", "ttl", "atbl", " tbm", "ttlb", "tlr", "tbl", "llam", "trb", "ptlam", " tbl", " tlr", "llc", "ptrb", "tlc", " tlc", "ptbl", "ttbl", "ll", "atlr", "ttlc", "ttrb", "ptlb", "tlam", "tl", "Tlb", "Tbm", " trb", "Tlr", "Tbl", " tl", " tlam"], "tlbncfg": ["tlBNcf", "lbmconf", "tlbmconn", "tlbonconf", "slbanfg", "lbmconn", "tlbncf", "tlbenconfig", "slbnfg", "tlbencf", "lbmcf", "lbmconfig", "tlbnconf", "tlbinconfig", "tlbanfg", "tlboncfg", "slbnconn", "tlbonconn", "tlbnconfig", "lbncf", "lbnconn", "tlbencfg", "tlbinfg", "tlbincf", "tlbnfg", "lbmcfg", "tlfnconfig", "lbmfg", "lbncfg", "tlfncf", "tlbinconf", "tlbmconfig", "tlbmcf", "tlfnfg", "tlbenconn", "lbnconfig", "slbncfg", "slbanconn", "tlbnconn", "tlbincfg", "tlbancfg", "tlBNconfig", "tlfnconf", "tlbanconn", "tlfncfg", "tlbonfg", "slbanconf", "tlbanconf", "lbnfg", "tlBNconn", "slbancfg", "tlbmconf", "tlbmfg", "slbnconf", "tlbmcfg", "lbnconf", "tlBNcfg"], "tlbm_size": ["tlbon_scale", "tlbh_name", "tlBM_sum", "tlbh_size", "tlbh2rate", "tlBM_source", "tlbm_source", "tlbm__ize", "tlbh2type", "tlbh2name", "tlbm__size", "tlbon_ize", "tlbm_rate", "tlbm__mode", "tlbmxspeed", "tlbon_size", "tlbm_scale", "tlbh_rate", "tlbh_ize", "tlbm2size", "tlbn_size", "tlbh_speed", "tlbn_mode", "tlbm_speed", "tlbm2rate", "tlbon__scale", "tlbm2type", "tlbm_name", "tlbm__speed", "tlbon__size", "tlbm_mode", "tlbm_ize", "tlbm_sum", "tlbm2name", "tlbon__ize", "tlbh_type", "tlbm__scale", "tlbmxmode", "tlbn_speed", "tlbmxscale", "tlbh2size", "tlbm_type", "tlBM_size", "tlbmxsize", "tlbn_scale", "tlbon_speed", "tlbon__speed"]}}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,\n\n                                             GIOCondition condition,\n\n                                             gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(\n\n        qio_task_get_source(task));\n\n\n\n    qio_channel_tls_handshake_task(\n\n       tioc, task);\n\n\n\n    object_unref(OBJECT(tioc));\n\n\n\n    return FALSE;\n\n}\n", "idx": 26330, "substitutes": {"ioc": [" ioco", " iucc", "iucc", "atioco", "tiucc", "tioco", "tiroc", "atioc", "ioco", "iroc", "atiucc", " iroc", "atiroc"], "condition": ["chain", " cond", "processor", " thread", " proc", " interrupt", "ec", "bc", "proc", "reason", "self", " event", " prec", "parent", "cond", " error", "comp", "ruction", " block", " exc", "tc", "null", "func", "container", "block", "tx", " exception"], "user_data": ["userfulldata", "user_reader", " user_package", "userfulldevice", "custom_device", " user_done", "useruserreader", "userpooldone", "user_done", "userpooldata", "custom_reader", "userpoolclass", "user_class", "user_device", " user_class", "useringdone", "useruserinfo", "userfullreader", "useringdata", "useringpackage", "user_package", "userfullinfo", "custom_data", "user_info", "userpoolpackage", "custom_info", "useruserdata", "useruserdevice", "useringclass"], "task": ["exec", "socket", "thread", "app", "master", "server", "image", "job", "data", "test", "config", "address", "type", "instance", "trip", "ask", "sync", "key", "piece", "message", "resource", "work", "process", "session", "contract", "Task", "object", "worker", "role", "result", "target", "client", "channel", "device", "transfer", "course", "slave", "source", "child", "t", "conn", "content", "event", "route", "tty", "tx", "connection", "table", "tag"], "tioc": [" tiuc", "shiroc", "TIuc", "shiuc", "nioc", "tiec", "idioci", "kiocation", "tiOC", "sioc", "kioci", "idiocl", "shioc", "siOC", "TIoc", "tiocation", "siuc", "siec", "tiocon", "tiuc", "TIec", "niroc", "siroc", " tiOC", "shiocon", "tioci", "niocon", "siocon", "idioc", "kioc", "siocl", "tiocl", "sioci", " tiec", "kiocl", "niuc", "TIOC", "idiocation", "siocation", "tiroc"]}}
{"project": "qemu", "commit_id": "82be8e7394b31fd2d740651365b8ebdd0c847529", "target": 1, "func": "static int get_htab_fd(sPAPRMachineState *spapr)\n\n{\n\n    if (spapr->htab_fd >= 0) {\n\n        return spapr->htab_fd;\n\n    }\n\n\n\n    spapr->htab_fd = kvmppc_get_htab_fd(false);\n\n    if (spapr->htab_fd < 0) {\n\n        error_report(\"Unable to open fd for reading hash table from KVM: %s\",\n\n                     strerror(errno));\n\n    }\n\n\n\n    return spapr->htab_fd;\n\n}\n", "idx": 19434, "substitutes": {"spapr": ["spapar", "spaxpr", "scappar", "spacr", "Spacrs", "pseaprs", "spraper", " spapsr", "sprapper", "spapear", "splapnr", "spapprc", "pseapri", "splupper", "spagrc", "pseagri", "spraprs", "splaprs", "spupr", "spagpr", "spapnr", "Spaprs", "spapper", "spupnr", "spacsr", "sprapri", "Spaplr", "spaper", "spagri", "spagrar", "spaprar", "spapsr", "ppapsnr", "spaprs", "Spacsr", "scaprar", "spupper", "spaperc", "spapsrc", "ppapser", "spampar", "spapsri", "spAPr", "scapr", "spajr", "scapar", "spagar", "scapprc", " spaprc", " spaprar", "Spacr", "Spaclr", "spapprs", "ppapsr", "spagrs", "spappar", "pseapr", "ppaper", "splupnr", "spajlr", "spapppr", "spapsnr", "ppapr", "spuprs", "pseagpr", "spapsar", "splapr", "spajsr", "splupr", "spagr", "ppapnr", "scaprc", " spapsrar", " spapsar", "Spapsr", "spacrs", "spampnr", "spaperar", "spaxr", "splapper", " spapar", "spamprc", "spappr", "spappnr", "spAPrs", "spampri", "Spapr", "spaplr", "spaxri", "ppapri", "pseagr", "spappper", "spapprar", "spluprs", "spAPsr", "spapri", "pseagrs", "sprapnr", "spaprc", "ppapsri", "spappri", "sprapr", "spampr", "scapprar", "spapser", "spamper", "spapsrar", "pseappr", "spaclr", "spAPlr", "spaxrs", "scappr", " spapsrc", "spamprar", "spajrs"]}}
{"project": "qemu", "commit_id": "4981bdec0d9b3ddd3e1474de5aa9918f120b54f7", "target": 0, "func": "AioContext *blk_get_aio_context(BlockBackend *blk)\n\n{\n\n    return bdrv_get_aio_context(blk->bs);\n\n}\n", "idx": 8855, "substitutes": {"blk": ["plks", "plkt", "clks", "Blk", "plck", "clck", "Blks", "blck", "blks", "Blkt", " blck", "clk", " blks", " blkt", "blkt", "clkt", "Blck", "plk"]}}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_pread(BlockDriverState *bs, int64_t offset,\n               void *buf1, int count1)\n{\n    BlockDriver *drv = bs->drv;\n    if (!drv)\n        return -ENOMEDIUM;\n    if (!drv->bdrv_pread)\n        return bdrv_pread_em(bs, offset, buf1, count1);\n    return drv->bdrv_pread(bs, offset, buf1, count1);\n}", "idx": 9176, "substitutes": {"bs": ["vs", "base", "ks", "ds", "lbs", "bid", "bas", "src", "boxes", "b", "gs", "iss", "fb", "s", "ls", "pb", "obj", "cb", "ins", "bits", "rb", "rs", "banks", "BS", "bc", "os", "obs", "cs", "bl", "bps", "ras", "ubs", "fps", "las", "lb", "bis", "ns", "sb", "blocks", "bytes", "as", "ses", "ps", "fs", "css", "ss", "bes", "bos"], "offset": ["count", "area", "location", "boot", "timeout", "reference", "seq", "base", "inet", "initial", "start", "prefix", "origin", "pointer", "data", "slot", "addr", "config", "ref", "attr", "fp", "set", "off", "loc", "ptr", "padding", "o", "bound", "index", "size", "order", "align", "loader", "address", "port", "part", "position", "type", "layer", "online", "et", "pos", "url", "length", "image", "absolute", "buffer", "Offset", "reset"], "buf1": ["buff2", " bufp", "uf3", "bag2", " bufone", "bufone", " buf4", "buf2", "buf4", " buf2", "bagone", "uf1", "uf2", "buffer3", " buf0", "buff0", "bufferone", " buf3", "buffer2", "buffer1", "buff1", "buf3", "bufferp", "buffer4", "bag1", "bag4", "uf0", "bufp", "buffp", "buffer0", "buf0"], "count1": ["call2", "lenone", "len1", " countOne", "lenOne", "partOne", "cond1", " count8", "len2", "partone", "count2", "count8", "part8", "sum1", " countone", "condOne", "cond2", "callone", "sumone", "part1", "call1", "countOne", "sumOne", "call8", "condone", "countone", " count2", "part2", "sum2"], "drv": ["drvs", " drver", "irf", "drV", "Drf", " drf", " drvs", "irv", "Drb", "drb", "drf", "DRf", " drb", "irver", "hrf", "rdf", "drvr", "DRvs", "DRV", "rdvr", "driver", "adrvc", "DRp", "driv", "adrf", "hrb", "drp", "adrver", "drvc", "hrv", "hrV", "irvc", "adrv", "rdvs", " drV", " drvc", "rdv", "drib", "DRv", "Drv", "DrV", "drif", "drver", "Drp", " drp", "Drver", "DRvr", " drvr"]}}
{"project": "FFmpeg", "commit_id": "c56e71309ec1a585ed4d4dc11ae0ba3ca7d19618", "target": 1, "func": "static int gif_image_write_image(AVCodecContext *avctx,\n\n                                 uint8_t **bytestream, uint8_t *end,\n\n                                 const uint8_t *buf, int linesize)\n\n{\n\n    GIFContext *s = avctx->priv_data;\n\n    int len, height;\n\n    const uint8_t *ptr;\n\n    /* image block */\n\n\n\n    bytestream_put_byte(bytestream, 0x2c);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, 0);\n\n    bytestream_put_le16(bytestream, avctx->width);\n\n    bytestream_put_le16(bytestream, avctx->height);\n\n    bytestream_put_byte(bytestream, 0x00); /* flags */\n\n    /* no local clut */\n\n\n\n    bytestream_put_byte(bytestream, 0x08);\n\n\n\n    ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height,\n\n                       12, FF_LZW_GIF, put_bits);\n\n\n\n    ptr = buf;\n\n    for (height = avctx->height; height--;) {\n\n        len += ff_lzw_encode(s->lzw, ptr, avctx->width);\n\n        ptr += linesize;\n\n    }\n\n    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);\n\n\n\n    ptr = s->buf;\n\n    while (len > 0) {\n\n        int size = FFMIN(255, len);\n\n        bytestream_put_byte(bytestream, size);\n\n        if (end - *bytestream < size)\n\n            return -1;\n\n        bytestream_put_buffer(bytestream, ptr, size);\n\n        ptr += size;\n\n        len -= size;\n\n    }\n\n    bytestream_put_byte(bytestream, 0x00); /* end of image block */\n\n    bytestream_put_byte(bytestream, 0x3b);\n\n    return 0;\n\n}\n", "idx": 9095, "substitutes": {"avctx": ["afconn", "avcv", "avcmp", "afctx", "afsync", "avsync", "avcc", "ajcmp", "AVcc", "AVqa", "afcmp", "avecmp", "avectx", "afctl", "auctx", "auctl", "AVcmp", "AVcv", " avcmp", "AVcontext", "avconn", "AVsync", "avproc", "ajctx", "ajcontext", "AVctx", "AVconn", "aucmp", " avcontext", "avcontext", " avcv", " avconn", "AVproc", "afcc", "ajproc", " avsync", " avcc", "AVctl", "afqa", "aveconn", "avecontext", "aucontext", "avctl", "afcontext", "aveqa", "avqa", "afcv", "afproc"], "bytestream": [" bygestagram", "byinstbroad", "bytestingorage", "byteenREAM", "bylastream", "byconstreen", "bythisamera", "bycestream", "Byteststream", "BYpastream", "byestREAM", "byserverream", "byvestamera", "byeststream", "viaestream", "Bytestream", " bytestruction", "fortestream", "bygestream", "viainstagram", "BYtestamera", "liketestram", "andcodeair", "BYtestrum", "bytestrum", "byestchannel", "bylastagram", "byveyamera", "liketestruction", " bytestREAM", "viaestrum", "bycodeair", " bygestreen", " bytestamera", "byinstREAM", "bytestair", "bygestamera", "byserveramera", "byestream", " bygestalk", "byinstrum", "byaststream", "andcoderam", "byscriptagram", "fromestrum", "viatestamera", "bytestingruction", "bygestchannel", "byrestream", " bytestalk", "bythisream", "bytestingREAM", "byrestreen", "byvestream", "byinstagram", "BytestREAM", "bygestram", "byserverram", "byestrum", "byconstREAM", "byestorage", "bytrum", "byconstram", "bytestingered", "bytestalk", "bytestingram", "bytram", "viaestagram", "byconstear", "fortestorage", " bytestagram", "viatestallow", "byteenream", "bycoderum", "byestamera", "viatestream", "byestagram", "byteststream", "byestram", "byscriptram", "forestered", "byinstamera", "byestallow", "bytestered", "bytream", "fromtestrum", "Byestream", "bytestallow", " bygestear", "Byestamera", "bycestorage", "fortestrum", "bytruction", "bygestalk", "fromtestREAM", " bygestrom", "bycodeream", "bytestingair", "liketestair", "liketestingream", "bylastbroad", "byterrum", "byestruction", "byteenrom", "bypastream", "bygestair", "viainstream", "BYpastrum", "bygestrum", "bycoderam", "BYpastand", "bycestrum", "BYpastamera", "andtestrum", "bypertram", "Byestram", "viatestrum", "andtestram", "bytestagram", "byterair", "bytestreen", "bygestruction", "bypertair", "bythisallow", " bygestream", "bygestREAM", "bytestchannel", "byscriptalk", "fortestered", "viainstbroad", "bygeststream", "bythisrum", "byterream", "bytestingamera", "bypertream", "bypastrum", "viatestbroad", "byastREAM", "Bytestram", " bygestram", "bytestram", "andcoderum", "bytestand", "andtestream", "forestorage", "liketestingair", "bytestbroad", "viatestagram", "fromestREAM", "viaestallow", "bytestamera", "fromtestchannel", "byconstalk", "bytestREAM", "forestrum", "bygestrom", "bygestreen", " bygestruction", "bytallow", "byconstrom", "bylastamera", "viainstamera", "byvestREAM", "BYtestream", "fromestchannel", "andcodeream", " bygestamera", "ByestREAM", "Byestruction", "bycestered", "fromestream", "bytestrom", "byastream", "byestered", "bytagram", " bytestreen", " bytestear", "bypastamera", "byinstchannel", "byrestREAM", "BYtestand", "Bytestruction", "bytestruction", "byastram", "byteenamera", " bytestrom", "byvestruction", " bygestREAM", "bypastand", "fromtestream", "byterram", "byrestear", "bytamera", "bythisand", "byveyream", "byscriptream", "andtestair", "bygestagram", "Byeststream", "liketestingruction", "forestream", "bythisagram", "byveyagram", " bytestram", "bytestorage", "bytestingand", "liketestingram", "bygestear", "bypertruction", "bytestingream", "byveybroad", "byconstream", "byinstream", "byconstagram", "byserverruction", "bytestingrum", "Bytestamera", "liketestream", "bytestear", "byconstamera"], "end": ["start", "est", "ended", "id", "open", "End", "path", "z", "send", "last", "c", "line", "max", "limit", "e", "set", "env", "stop", "mid", "append", "index", "edge", "address", "en", "begin", "ending", "after", "offset", "enc", "h", "pos", "dev", "length", "use", "END", "range"], "buf": ["bag", "uf", "map", "background", "uu", "seq", "context", "src", "fd", "b", "wb", "mem", "pool", "fi", "data", "block", "fb", "config", "ref", "bu", "pb", "p", "cb", "fp", "queue", "cf", "rb", "loc", "tmp", "prop", "bc", "code", "alloc", "cv", "aux", "cap", "v", "rc", "home", "cas", "ctx", "conv", "raw", "address", "port", "offset", "border", "header", "length", "func", "vec", "buff", "br", "proc", "buffer", "box", "uc"], "linesize": ["linsiz", "codesizing", "linsIZE", "linesiz", "codesizer", "odesize", " linesIZE", "linsizer", "odesizing", "odesIZE", "linesizing", "linsize", "linesIZE", " linesizer", "codesize", " linesizing", "linesizer", "codesIZE", "codesiz", "odesiz", " linesiz"], "s": ["conf", "session", "sg", "ts", "ks", "sv", "ds", "n", "g", "is", "its", "w", "m", "stats", "b", "t", "ops", "d", "i", "gs", "c", "data", "service", "p", "ls", "e", "qs", "ins", "xs", "sq", "js", "rs", "f", "us", "args", "cs", "sym", "aws", "sets", "S", "v", "sync", "es", "services", "ctx", "r", "bis", "ns", "hs", "sb", "spec", "as", "sys", "ions", "ses", "a", "ps", "fs", "uns", "ss", "bs", "ssl"], "len": ["lp", "l", "count", "ld", "ler", "seq", "le", "lf", "span", "n", "val", "fen", "win", "lim", "z", "num", "data", "line", "limit", "el", "lit", "loc", "dl", "code", "fl", "size", "lib", "ll", "cap", "min", "name", "sl", "fun", "zen", "en", "pre", "lt", "elt", "fin", "lang", "den", "hl", "pos", "li", "lon", "url", "length", "bin", "Len", "lc", "lan", "rev", "ln", "dy", "lin"], "height": ["channel", "html", "img", "x", "container", "fw", "thin", "memory", "lat", "step", "duration", "port", "crop", "type", "volume", "row", "image", "definition", "buffer", "depth", "wid", "rank", "dim", "han", "view", "w", "id", "resolution", "density", "i", "layout", "padding", "gy", "ha", "slice", "input", "wall", "huge", "header", "gap", "ady", "hi", "context", "fen", "source", "room", "num", "d", "lvl", "wrap", "bottom", "head", "style", "flow", "hei", "host", "png", "Height", "alpha", "zh", "size", "shape", "kw", "hl", "sid", "weight", "dy", "diff", "level", "wide", "rows", "win", "window", "capacity", "qa", "quality", "dir", "name", "h", "length", "arrow", "y", "direction"], "ptr": ["Ptr", "uf", "sp", "dim", "sh", "lf", "context", "tr", "ext", "start", "str", "pad", "coord", "src", "inter", "fd", "mount", "pointer", "shift", "fi", "addr", "p", "ref", "pb", "dest", "pointers", "fp", "attr", "cb", "pt", "plug", "loc", "rb", "tmp", "push", "slave", "rot", "dr", "inst", "code", "slice", "alloc", "ctr", "trace", "index", "rc", "obj", "cur", "req", "address", "err", "port", "pe", " pointer", "offset", "pend", "pair", "pos", "length", "buff", "proc", "buffer", "fe"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)\n\n{\n\n    int sa, sb;\n\n    sa = ((int64_t)*phigh < 0);\n\n    if (sa)\n\n        neg128(plow, phigh);\n\n    sb = (b < 0);\n\n    if (sb)\n\n        b = -b;\n\n    div64(plow, phigh, b);\n\n    if (sa ^ sb)\n\n        *plow = - *plow;\n\n    if (sa)\n\n        *phigh = - *phigh;\n\n}\n", "idx": 848, "substitutes": {"plow": ["flow", " pligh", "lowed", "phay", "plowed", "lOW", "oploy", "iplowe", "opligh", "iploom", " plowed", "pullowe", "fligh", "flowed", "phOW", "plows", "lowe", "oploom", "iplrow", "phow", " play", " plOW", "phoy", " plows", "iplOW", "iplow", "flows", "oplow", " plrow", " plowe", "pullow", "plowe", "oplay", "oplOW", "ploom", "plOW", "ploy", " ploy", "oplowed", "Plow", " ploom", "Plowe", "PlOW", "pligh", "pullOW", "play", "oplows", "Plrow", "low", "pullowed", "iplowed", "plrow", "iplows"], "phigh": ["philig", "phight", "shig", "Phigi", "ophalth", "PHiz", "phai", "phaich", "Phai", "PHalth", "Phalth", " phiz", "PHigg", "PHig", "phaogg", "phiz", " phight", "phaig", "shigh", "phug", "philigh", "phaug", " phalth", "Phigh", "ophug", " phigi", "phaigh", "ophight", "philogg", " phyg", "phigi", " phiy", " phai", "PHiy", "phogg", "PHigh", "phiy", "PHai", "philich", "PHigi", "phig", "phyg", " phug", "shiz", "phayg", "shigg", "phich", " phigg", "shiy", "ophig", "phaalth", "phigg", " phig", "phalth", " phich", "ophyg", "phaight", "ophigh", " phogg"], "b": ["ob", "base", " db", " bi", "bh", "a", "lb", "ab", "binary", "mb", "r", "B", "d", "ib", "n", "eb", "bc", "k", "pb", " eb", "i", "y", "bl", "g", "rb", "body", "bf", "pa", "l", "c", "p", "beta", "h", "w", "e", "nb", "f", "wb", "bi", "length", "gb", "zb", "bt", "s", "bb", "bp", "v", "fb", "bar", "bs", "db"], "sa": ["sg", "sac", "so", "asu", "da", "ss", "ba", "a", "ga", "sd", "asi", "sam", "n", "aa", "ma", "sp", "sl", "sh", "ta", "sk", "na", "za", "Sa", "au", "ai", "pa", "sea", "p", "sie", "asa", "ca", "sc", "sq", "la", "gb", "as", "pc", "s", "SA", "sta", "ama", "su", "wa", "isa", "va", "bs", "se", " si", "si", "sy"], "sb": ["sg", "SB", "src", "bh", "ss", "ba", "obb", "a", "sd", "lb", "bm", "ab", "eb", "ib", "mb", "db", "sp", "sl", "bc", "sh", "pb", "sk", "bl", "rb", "sf", "cb", "amb", "st", "bf", "pa", "bi", "nb", "wb", "sq", "sc", "gb", "zb", "bt", "sec", "sn", "bb", "bp", "s", "fb", "sta", "sm", "bs", "si", "sth"]}}
{"project": "qemu", "commit_id": "4f9242fc931ab5e5b1b753c8e5a76c50c0b0612e", "target": 0, "func": "static void reset(DeviceState *d)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    trace_spapr_drc_reset(spapr_drc_index(drc));\n\n\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    /* immediately upon reset we can safely assume DRCs whose devices\n\n     * are pending removal can be safely removed, and that they will\n\n     * subsequently be left in an ISOLATED state. move the DRC to this\n\n     * state in these cases (which will in turn complete any pending\n\n     * device removals)\n\n     */\n\n    if (drc->awaiting_release) {\n\n        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);\n\n        /* generally this should also finalize the removal, but if the device\n\n         * hasn't yet been configured we normally defer removal under the\n\n         * assumption that this transition is taking place as part of device\n\n         * configuration. so check if we're still waiting after this, and\n\n         * force removal if we are\n\n         */\n\n        if (drc->awaiting_release) {\n\n            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);\n\n        }\n\n\n\n        /* non-PCI devices may be awaiting a transition to UNUSABLE */\n\n        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n            drc->awaiting_release) {\n\n            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);\n\n        }\n\n    }\n\n}\n", "idx": 23076, "substitutes": {"d": ["md", "i", "e", "cd", "driver", "dh", "ds", "ld", "f", "dn", "gd", "t", "r", "u", "m", "s", "da", "data", "ad", "state", "p", "dict", "o", "c", "dr", "dx", "sd", "dt", "a", "b", "dc", "dm", "fd", "bd", "D", "st", "z", "l", "dp"], "drc": ["drt", "sdrt", "sdrc", "trc", "brc", "datrc", " drec", "dsrc", "dsrec", "ldsrc", "lRC", "adru", "datru", "Drec", "datlc", "lirc", "pdrac", "ldRC", " drac", "adrec", "tdrt", " dsrc", "tdrc", "dnroc", "datrec", "dnrt", "dsc", "dirc", " dsc", "dsrt", "drrc", "drsrc", "ldrac", "droc", "adrc", "brec", "fRC", "lrc", "DRC", "Dru", "adrt", "lsrc", "tsc", "frec", " drt", " dRC", "prec", "adlc", "lrec", "flc", "tdsrc", "drec", "drsc", "Drc", "sdroc", "frc", "dru", " droc", "dssc", "adRC", "troc", "prc", "tdrec", "trt", "drRC", "ldrec", "ldirc", "dnrc", "datRC", "dsRC", "pdrec", "psc", "drac", "bsc", "sdRC", "dRC", "drrec", "pdrc", "drirc", "dlc", "pdroc", "dnRC", "psrc", "birc", "pdsc", "bRC", "adsrc", "ldrc", "dssrc", "bsrc", "ldsc", "pirc", "pdrt"], "drck": ["strcc", "hrck", "hrok", "derck", "hrock", "hrac", "drac", " drco", "hrco", "drrc", "DRck", " drcks", " drack", "drco", "derok", " drok", "drcks", "derco", "derac", "drok", "DRrc", "drcc", "drack", "DRack", "hrack", "hrrc", " drcc", " drac", "strack", "DRcks", "strcks", "drock", " drock", "DRock", "DRcc", " drrc", "strck"]}}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "bool vring_should_notify(VirtIODevice *vdev, Vring *vring)\n\n{\n\n    uint16_t old, new;\n\n    bool v;\n\n    /* Flush out used index updates. This is paired\n\n     * with the barrier that the Guest executes when enabling\n\n     * interrupts. */\n\n    smp_mb();\n\n\n\n    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&\n\n        unlikely(!vring_more_avail(vdev, vring))) {\n\n        return true;\n\n    }\n\n\n\n    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {\n\n        return !(vring_get_avail_flags(vdev, vring) &\n\n                 VRING_AVAIL_F_NO_INTERRUPT);\n\n    }\n\n    old = vring->signalled_used;\n\n    v = vring->signalled_used_valid;\n\n    new = vring->signalled_used = vring->last_used_idx;\n\n    vring->signalled_used_valid = true;\n\n\n\n    if (unlikely(!v)) {\n\n        return true;\n\n    }\n\n\n\n    return vring_need_event(vring_used_event(&vring->vr), new, old);\n\n}\n", "idx": 13156, "substitutes": {"vdev": ["verdev", " vdiv", "vmid", "lmid", "vconn", "svconn", "svgen", "vcding", "svring", "ivdevice", "verring", "vcprof", "vding", "fgen", "fdev", "verdi", "vcdev", "vdiv", "nvgen", "vcapi", "vcring", " vgen", "vdi", "vapi", "evdev", "evring", "svmid", "fdiv", "lconn", "svdb", "evgen", "svding", "svdevice", "fdevice", " vding", "svprof", "nvdiv", " vdb", "nvdev", "ldev", "ivdev", "vgen", "vdevice", "vdb", "vprof", " vprof", " vapi", "svapi", " vdevice", "nvdevice", "vcdb", " vdi", "vergen", "ldevice", "ivconn", "ivmid", "vcgen", "svdev", "evdi"], "vring": ["pending", "vsding", "nvlic", "rstring", "svdi", "svring", "evding", " vending", "voltcalling", " vgen", " vstring", "svridge", " vdata", "vsing", " vding", "rdata", "bray", "vrig", "vlic", "voltding", "vvray", "lvray", "svdev", "ivring", "rgen", "svbinding", "ivcalling", "svsing", "varray", "svgen", "pding", "vsetting", "svdata", "svending", "bring", "vsridge", " vng", "svding", "voltring", "ivding", "varsing", "lvbinding", " vray", "lvsing", " vsetting", "vstring", " vdi", "vvtesting", "varbinding", "vsring", "varding", "varring", "avding", "rring", "rtesting", "vding", "ivray", " vrig", "vdi", "brig", "evping", "vtesting", "vcalling", "vsdev", "nvring", " vlic", "pring", "avng", " vridge", "svray", "evsetting", "blic", "vng", "vping", "svng", " vtesting", "avdi", "rray", "lvring", "avring", "vending", "evring", "svping", "nvrig", "vvring", " vping", "vbinding", "vgen", "varcalling", "vray", "svsetting", "voltray", "vdata", "vridge", "vvstring", "pray", "nvray"], "old": ["normal", "before", "after", "d", "id", "val", "l", "orig", "i", "or", "current", "pre", "range", "low", "event", "null", "OLD", "original", "other", "x", "update", "live", "ld", "valid", " Old", "o", "und", "ind", "p", "j", "from", "f", "diff", "end", "now", "lv", "md", "last", "Old", "num", "older", "prev"], "new": ["normal", "small", "self", "d", "with", "l", "again", "ew", "or", "current", "name", "g", "low", "final", "missing", "other", "raw", "update", "valid", "New", "value", "var", "o", "w", "view", "NEW", "version", "good", "where", "j", "n", "f", "result", "from", "add", "inc", "diff", "next", "c", "end", "now", "gen", "r", "el", "false"], "v": ["m", "rev", "d", "t", "vv", "l", "i", "val", "vp", "iv", "g", "conv", "ve", "h", "event", "x", "valid", "var", "o", "w", "u", "p", "e", "s", "k", "vs", "b", "j", "n", "f", "c", "function", "change", "sv", "nv", "uv", "r", "V", "ev", "lv"]}}
{"project": "qemu", "commit_id": "7c4228b4771acddcb8815079bc116007cec8a1ff", "target": 1, "func": "static void vfio_unmap_bar(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    if (!bar->size) {\n\n        return;\n\n    }\n\n\n\n    vfio_bar_quirk_teardown(vdev, nr);\n\n\n\n    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);\n\n    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));\n\n\n\n\n    if (vdev->msix && vdev->msix->table_bar == nr) {\n\n        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);\n\n        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));\n\n\n    }\n\n\n\n    memory_region_destroy(&bar->mem);\n\n}", "idx": 16293, "substitutes": {"vdev": ["lvdevelopment", "wdd", "nvserver", "vapp", "vardev", "evdev", "wrad", "vneg", "svev", "ivdev", "evev", "Vserv", " vprof", "nvdraft", "svvar", "vpub", "svdraft", "svapp", "evver", "svdev", "lev", "bdev", "bvar", "svpack", "nverror", "wdevice", "svdb", "vserv", "vdd", "svneg", " vgd", "wdiv", "svver", "vprof", "hver", "vpack", "vde", "vev", " vrad", " vapp", "sverror", "bver", "wdev", "verror", "ivgd", "Vdev", "ivdevice", " vde", "nvdb", "svdevelopment", "wpub", "lserver", "evneg", " vdevelopment", "svprof", "ldd", "nvdev", "varerror", "lvpack", "vrad", "vdraft", "varserver", " vpack", "ldevice", "svserv", "lvapp", " vvar", "Vdiv", "Vpub", "nvev", "vgd", "wgd", " vver", "wde", "hev", "vver", "svserver", "vdevelopment", "vardraft", "hdev", "ivde", "vdiv", "lvdev", "bprof", "lrad", " vdd", "ldev", "ldb", "vdevice", "vdb", "wserv", "hneg", "svdiv", " vdevice", "svpub", "vserver", "vvar"], "nr": ["runner", "rr", "nl", "ru", "rid", "ni", "rc", "nov", "our", "nn", "ctr", "kr", "name", "range", "rn", "rg", "nb", "ner", "sr", "br", "nw", "inv", "np", "adr", "mr", "lr", "rb", "yr", "nc", "rin", "n", "nu", "nor", "number", "eni", "ng", "sn", "nt", "r", "NR", "no", "num", "rf", "nom", "nm", "wr", "err"], "bar": ["bug", "bridge", "way", "card", "show", "cart", "area", "ha", "ca", "allow", "array", "batch", "arrow", "worker", "home", "bad", "row", "er", "gap", "border", "cor", "progress", "Bar", "this", "browser", "user", "buffer", "project", "star", "comment", "bag", "error", "table", "br", "job", "server", "var", "google", "war", "request", "app", "group", "grid", "aer", "page", "b", "can", "car", "usa", "feature", "ab", "item", "block", "gar", "cat", "tab", "par", "ebin", "bg", "broad", "far", "org", "r", "db", "ga", "ar", "work", "ban", "cur", "order", "bars"]}}
{"project": "qemu", "commit_id": "9359a58b122187964d7465d48165680eadbf69d3", "target": 0, "func": "static void ehci_update_frindex(EHCIState *ehci, int frames)\n\n{\n\n    int i;\n\n\n\n    if (!ehci_enabled(ehci)) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < frames; i++) {\n\n        ehci->frindex += 8;\n\n\n\n        if (ehci->frindex == 0x00002000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n        }\n\n\n\n        if (ehci->frindex == 0x00004000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n            ehci->frindex = 0;\n\n            if (ehci->usbsts_frindex >= 0x00004000) {\n\n                ehci->usbsts_frindex -= 0x00004000;\n\n            } else {\n\n                ehci->usbsts_frindex = 0;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 20095, "substitutes": {"ehci": ["khcu", "khlc", "ohcit", "ohdi", "ohco", "ohca", "khki", "evcu", "ohlc", "ahci", "ehsci", "khcci", "ahdi", "evdi", "khci", "echco", "eksci", "hessci", "khcit", "ethsci", "hesscci", "ethlc", "ehdi", "herci", "ehco", "herco", "hessc", "evci", "ahco", "echcu", "ahlc", "hesski", "eccu", "hcu", "ehki", "khc", "ethci", "ehcit", "ehc", "hlc", "eccin", "eclc", "ehlc", "ahcin", "ehca", "ethcu", "ohcci", "eklc", "hcci", "ahc", "evcci", "echci", "ehcu", "ecsci", "ahsci", "khca", "ahcci", "echsci", "ohc", "echcin", "ahcit", "ekcci", "herdi", "ohcu", "ahcu", "ecco", "ecci", "ahki", "ehcin", "hca", "hercu", "ohci", "ehcci", "hci", "hc", "khsci", "eccci", "echcci", "ekci"], "frames": ["classes", "values", "cycles", "planes", "fps", "tones", "pages", "stars", "series", "faces", "flows", "plugins", "seconds", "objects", "videos", "files", "points", "lines", "inches", "links", "quarters", "cells", "features", "blocks", "codes", "Frames", "bits", "steps", "rows", "events", "interface", "tracks", "frame", "states", "images"], "i": ["uri", "gi", "ti", "m", "bi", "j", "ji", "f", "ini", "qi", "io", "ai", "n", "phi", "fi", "hi", "z", "ie", "ii", "ori", "di", "index", "mini", "iu", "I", "multi", "zi", "o", "ip", "l", "adi", "oi", "yi", "pi", "ui", "ci", "abi", "e", "k", "cli", "v", "ni", "c", "si", "ri", "xi", "p", "mu", "interface", "anti", "eni", "diff", "inner", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "d0dce15da34c0e4eee6c683be299de0221db00d3", "target": 1, "func": "static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,\n\n                         uint32_t *pal, int colors)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i <= colors; i++) {\n\n        uint8_t r, g, b;\n\n        unsigned int idx = bytestream2_get_be16(gbc); /* color index */\n\n        if (idx > 255) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Palette index out of range: %u\\n\", idx);\n\n            bytestream2_skip(gbc, 6);\n\n            continue;\n\n        }\n\n        r = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        g = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        b = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        pal[idx] = (r << 16) | (g << 8) | b;\n\n    }\n\n    return 0;\n\n}\n", "idx": 16755, "substitutes": {"avctx": ["gcp", "ajctx", "akloc", "avctl", "awctx", "ajcontext", "awcp", "airloc", "AVctl", "awcontext", "airctl", "avcp", "aircli", "akcli", "AVloc", "avcli", "gcontext", "AVcli", "gmc", "avloc", "awmc", "AVctx", "akctl", "akctx", "ajmc", "ajcp", "avcontext", "airctx", "avmc", "gctx"], "gbc": ["ggc", "glic", "ggbc", "gencb", " guc", "gpc", " gcms", "aguc", " grc", "reglic", "hcms", "agcms", "aggcms", " gpc", "genfc", "gsuc", "blc", "ggpc", "gmcb", "lpc", " gc", "gscf", "gguc", "rgpc", " gcb", "gglic", "gslc", "genpc", "gcms", "blic", "gsfc", "lfc", "garc", "gencms", "Gbc", "gglc", "hlic", "igbc", "Grc", "Gcb", "regcms", "iguc", "Gfc", "lcb", "ggcb", " gec", "ggcf", "gmbc", "gfc", "aggcb", "agec", "ggec", "ggcms", " gfc", "rguc", "gmfc", "rgbc", " gcf", "garuc", " glic", "gslic", "hec", "igec", "garbc", "glc", "gsbc", "guc", "gec", "regec", "regbc", "bbc", "igcms", "lbc", "gcb", "grc", "rgfc", "gc", "ggfc", "garfc", "gmrc", "genbc", "hbc", "gcf", "buc", "agbc", "aggbc", "aggpc"], "pal": ["ab", "opal", "bin", "Pal", "pill", "cal", "al", "base", "color", "pl", "align", "pan", "plan", "pixel", "app", "chal", "ap", "pol", "arr", "chi", "nav", "val", "array", "pel", "wal", "style", "ol", "white", "par", "span", "p", "pad", "area", "cell", "ph", "ace", "isal", "pro", "list", "py", "panel", "el", "attr", "li"], "colors": ["colores", "colORS", "ColORS", "collors", " recolons", "Colories", " recolores", "collORS", "Colores", "Colors", "colories", "collores", "colorors", "colorores", "filores", "colons", "colorORS", "colorlections", "filors", "filories", "filons", " recolors", " recolories", "Collections", "colllections", "collections", "Colons"], "i": ["ti", "m", "bi", "j", "x", "f", "ini", "qi", "io", "ai", "mi", "phi", "n", "hi", "ii", "ori", "iu", "di", "index", "slice", "I", "multi", "zi", "o", "ip", "chi", "l", "d", "oi", "yi", "pi", "ui", "ci", "e", "v", "cli", "c", "ni", "si", "xi", "p", "mu", "a", "eni", "fi", "y", "li", "u"], "r": ["rx", "m", "rr", "fr", "br", "rs", "vr", "x", "err", "rc", "hr", "rt", "R", "n", "ar", "ro", "rh", "rg", "l", "d", "gb", "re", "nr", "mr", "ru", "w", "sr", "e", "dr", "lr", "k", "v", "c", "rb", "rl", "p", "ur", "pr", "er", "a", "gr", "u"], "g": ["gi", "gn", "m", "eg", "sg", "group", "s", "gar", "f", "gre", "x", "gu", "gc", "n", "gg", "gh", "ge", "gam", "rg", "mg", "pg", "l", "d", "gb", "gp", "G", "ig", "w", "e", "ga", "v", "c", "erg", "bg", "p", "gen", "gs", "gas", "gy", "gm", "a", "gr", "u"], "b": ["ab", "eb", "db", "bs", "t", "x", "ob", "f", "n", "sb", "cb", "wb", "B", "xb", "lb", "bb", "abb", "nb", "ba", "o", "l", "d", "bar", "gb", "bf", "w", "bd", "mb", "e", "bl", "fb", "v", "c", "rb", "bg", "p", "beta", "a", "y", "ib", "u"]}}
{"project": "FFmpeg", "commit_id": "892fc83e88a20f9543c6c5be3626712be7a2e6f2", "target": 0, "func": "static void init_block_mapping(Vp3DecodeContext *s) \n\n{\n\n    int i, j;\n\n    signed int hilbert_walk_y[16];\n\n    signed int hilbert_walk_c[16];\n\n    signed int hilbert_walk_mb[4];\n\n\n\n    int current_fragment = 0;\n\n    int current_width = 0;\n\n    int current_height = 0;\n\n    int right_edge = 0;\n\n    int bottom_edge = 0;\n\n    int superblock_row_inc = 0;\n\n    int *hilbert = NULL;\n\n    int mapping_index = 0;\n\n\n\n    int current_macroblock;\n\n    int c_fragment;\n\n\n\n    signed char travel_width[16] = {\n\n         1,  1,  0, -1, \n\n         0,  0,  1,  0,\n\n         1,  0,  1,  0,\n\n         0, -1,  0,  1\n\n    };\n\n\n\n    signed char travel_height[16] = {\n\n         0,  0,  1,  0,\n\n         1,  1,  0, -1,\n\n         0,  1,  0, -1,\n\n        -1,  0, -1,  0\n\n    };\n\n\n\n    signed char travel_width_mb[4] = {\n\n         1,  0,  1,  0\n\n    };\n\n\n\n    signed char travel_height_mb[4] = {\n\n         0,  1,  0, -1\n\n    };\n\n\n\n    debug_vp3(\"  vp3: initialize block mapping tables\\n\");\n\n\n\n    /* figure out hilbert pattern per these frame dimensions */\n\n    hilbert_walk_y[0]  = 1;\n\n    hilbert_walk_y[1]  = 1;\n\n    hilbert_walk_y[2]  = s->fragment_width;\n\n    hilbert_walk_y[3]  = -1;\n\n    hilbert_walk_y[4]  = s->fragment_width;\n\n    hilbert_walk_y[5]  = s->fragment_width;\n\n    hilbert_walk_y[6]  = 1;\n\n    hilbert_walk_y[7]  = -s->fragment_width;\n\n    hilbert_walk_y[8]  = 1;\n\n    hilbert_walk_y[9]  = s->fragment_width;\n\n    hilbert_walk_y[10]  = 1;\n\n    hilbert_walk_y[11] = -s->fragment_width;\n\n    hilbert_walk_y[12] = -s->fragment_width;\n\n    hilbert_walk_y[13] = -1;\n\n    hilbert_walk_y[14] = -s->fragment_width;\n\n    hilbert_walk_y[15] = 1;\n\n\n\n    hilbert_walk_c[0]  = 1;\n\n    hilbert_walk_c[1]  = 1;\n\n    hilbert_walk_c[2]  = s->fragment_width / 2;\n\n    hilbert_walk_c[3]  = -1;\n\n    hilbert_walk_c[4]  = s->fragment_width / 2;\n\n    hilbert_walk_c[5]  = s->fragment_width / 2;\n\n    hilbert_walk_c[6]  = 1;\n\n    hilbert_walk_c[7]  = -s->fragment_width / 2;\n\n    hilbert_walk_c[8]  = 1;\n\n    hilbert_walk_c[9]  = s->fragment_width / 2;\n\n    hilbert_walk_c[10]  = 1;\n\n    hilbert_walk_c[11] = -s->fragment_width / 2;\n\n    hilbert_walk_c[12] = -s->fragment_width / 2;\n\n    hilbert_walk_c[13] = -1;\n\n    hilbert_walk_c[14] = -s->fragment_width / 2;\n\n    hilbert_walk_c[15] = 1;\n\n\n\n    hilbert_walk_mb[0] = 1;\n\n    hilbert_walk_mb[1] = s->macroblock_width;\n\n    hilbert_walk_mb[2] = 1;\n\n    hilbert_walk_mb[3] = -s->macroblock_width;\n\n\n\n    /* iterate through each superblock (all planes) and map the fragments */\n\n    for (i = 0; i < s->superblock_count; i++) {\n\n        debug_init(\"    superblock %d (u starts @ %d, v starts @ %d)\\n\",\n\n            i, s->u_superblock_start, s->v_superblock_start);\n\n\n\n        /* time to re-assign the limits? */\n\n        if (i == 0) {\n\n\n\n            /* start of Y superblocks */\n\n            right_edge = s->fragment_width;\n\n            bottom_edge = s->fragment_height;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * s->fragment_width;\n\n            hilbert = hilbert_walk_y;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = -1;\n\n\n\n        } else if (i == s->u_superblock_start) {\n\n\n\n            /* start of U superblocks */\n\n            right_edge = s->fragment_width / 2;\n\n            bottom_edge = s->fragment_height / 2;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * (s->fragment_width / 2);\n\n            hilbert = hilbert_walk_c;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = s->u_fragment_start - 1;\n\n\n\n        } else if (i == s->v_superblock_start) {\n\n\n\n            /* start of V superblocks */\n\n            right_edge = s->fragment_width / 2;\n\n            bottom_edge = s->fragment_height / 2;\n\n            current_width = 0;\n\n            current_height = 0;\n\n            superblock_row_inc = 3 * (s->fragment_width / 2);\n\n            hilbert = hilbert_walk_c;\n\n\n\n            /* the first operation for this variable is to advance by 1 */\n\n            current_fragment = s->v_fragment_start - 1;\n\n\n\n        }\n\n\n\n        if (current_width >= right_edge) {\n\n            /* reset width and move to next superblock row */\n\n            current_width = 0;\n\n            current_height += 4;\n\n\n\n            /* fragment is now at the start of a new superblock row */\n\n            current_fragment += superblock_row_inc;\n\n        }\n\n\n\n        /* iterate through all 16 fragments in a superblock */\n\n        for (j = 0; j < 16; j++) {\n\n            current_fragment += hilbert[j];\n\n            current_height += travel_height[j];\n\n\n\n            /* check if the fragment is in bounds */\n\n            if ((current_width <= right_edge) &&\n\n                (current_height < bottom_edge)) {\n\n                s->superblock_fragments[mapping_index] = current_fragment;\n\n                debug_init(\"    mapping fragment %d to superblock %d, position %d\\n\", \n\n                    s->superblock_fragments[mapping_index], i, j);\n\n            } else {\n\n                s->superblock_fragments[mapping_index] = -1;\n\n                debug_init(\"    superblock %d, position %d has no fragment\\n\", \n\n                    i, j);\n\n            }\n\n\n\n            current_width += travel_width[j];\n\n            mapping_index++;\n\n        }\n\n    }\n\n\n\n    /* initialize the superblock <-> macroblock mapping; iterate through\n\n     * all of the Y plane superblocks to build this mapping */\n\n    right_edge = s->macroblock_width;\n\n    bottom_edge = s->macroblock_height;\n\n    current_width = 0;\n\n    current_height = 0;\n\n    superblock_row_inc = s->macroblock_width;\n\n    hilbert = hilbert_walk_mb;\n\n    mapping_index = 0;\n\n    current_macroblock = -1;\n\n    for (i = 0; i < s->u_superblock_start; i++) {\n\n\n\n        if (current_width >= right_edge) {\n\n            /* reset width and move to next superblock row */\n\n            current_width = 0;\n\n            current_height += 2;\n\n\n\n            /* macroblock is now at the start of a new superblock row */\n\n            current_macroblock += superblock_row_inc;\n\n        }\n\n\n\n        /* iterate through each potential macroblock in the superblock */\n\n        for (j = 0; j < 4; j++) {\n\n            current_macroblock += hilbert_walk_mb[j];\n\n            current_height += travel_height_mb[j];\n\n\n\n            /* check if the macroblock is in bounds */\n\n            if ((current_width <= right_edge) &&\n\n                (current_height < bottom_edge)) {\n\n                s->superblock_macroblocks[mapping_index] = current_macroblock;\n\n                debug_init(\"    mapping macroblock %d to superblock %d, position %d\\n\",\n\n                    s->superblock_macroblocks[mapping_index], i, j);\n\n            } else {\n\n                s->superblock_macroblocks[mapping_index] = -1;\n\n                debug_init(\"    superblock %d, position %d has no macroblock\\n\",\n\n                    i, j);\n\n            }\n\n\n\n            current_width += travel_width_mb[j];\n\n            mapping_index++;\n\n        }\n\n    }\n\n\n\n    /* initialize the macroblock <-> fragment mapping */\n\n    current_fragment = 0;\n\n    current_macroblock = 0;\n\n    mapping_index = 0;\n\n    for (i = 0; i < s->fragment_height; i += 2) {\n\n\n\n        for (j = 0; j < s->fragment_width; j += 2) {\n\n\n\n            debug_init(\"    macroblock %d contains fragments: \", current_macroblock);\n\n            s->all_fragments[current_fragment].macroblock = current_macroblock;\n\n            s->macroblock_fragments[mapping_index++] = current_fragment;\n\n            debug_init(\"%d \", current_fragment);\n\n\n\n            if (j + 1 < s->fragment_width) {\n\n                s->all_fragments[current_fragment + 1].macroblock = current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = current_fragment + 1;\n\n                debug_init(\"%d \", current_fragment + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if (i + 1 < s->fragment_height) {\n\n                s->all_fragments[current_fragment + s->fragment_width].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            if ((j + 1 < s->fragment_width) && (i + 1 < s->fragment_height)) {\n\n                s->all_fragments[current_fragment + s->fragment_width + 1].macroblock = \n\n                    current_macroblock;\n\n                s->macroblock_fragments[mapping_index++] = \n\n                    current_fragment + s->fragment_width + 1;\n\n                debug_init(\"%d \", current_fragment + s->fragment_width + 1);\n\n            } else\n\n                s->macroblock_fragments[mapping_index++] = -1;\n\n\n\n            /* C planes */\n\n            c_fragment = s->u_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            c_fragment = s->v_fragment_start + \n\n                (i * s->fragment_width / 4) + (j / 2);\n\n        s->all_fragments[c_fragment].macroblock = s->macroblock_count;\n\n            s->macroblock_fragments[mapping_index++] = c_fragment;\n\n            debug_init(\"%d \", c_fragment);\n\n\n\n            debug_init(\"\\n\");\n\n\n\n            if (j + 2 <= s->fragment_width)\n\n                current_fragment += 2;\n\n            else \n\n                current_fragment++;\n\n            current_macroblock++;\n\n        }\n\n\n\n        current_fragment += s->fragment_width;\n\n    }\n\n}\n", "idx": 10992, "substitutes": {"s": ["l", "conf", "session", "sg", "ts", "sv", "is", "si", "g", "n", "ds", "m", "t", "b", "small", "ops", "gs", "service", "c", "p", "ls", "e", "qs", "se", "js", "rs", "sec", "f", "sq", "us", "os", "sy", "cs", "sym", "an", "sets", "S", "v", "es", "space", "south", "services", "r", "sup", "bis", "en", "full", "ns", "sb", "spec", "u", "sys", "self", "h", "ses", "fs", "ps", "su", "site", "ss", "y", "a", "secondary", "inf", "ssl", "sc"], "i": ["l", "ui", "it", "n", "in", "m", "b", "x", "k", "d", "c", "p", "e", "f", "index", "v", "ind", "mi", "r", "ii", "u", "I", "li", "ci", "a", "y"], "j": ["l", "je", "n", "key", "m", "k", "b", "z", "job", "ji", "jo", "p", "obj", "js", "ak", "o", "r", "ij", "jp", "ii", "offset", "java", "aj", "pos", "J", "jc", "jj"], "hilbert_walk_y": ["hilbert_walk_x", "hilbert_walkureoy", "hilbert_walkPiy", "hilbert_indexureoy", "hilbert_move_Y", "hilbert_step_ye", "hilbert_index_oy", "hilbert_move_ya", "hilbert_hop_vy", "hilbert_path_y", "hilbert_walk_cy", "hilbert_walkFy", "hilbert_hop_ey", "hilbert_view_x", "hilbert_walk_Y", "hilbert_index_y", "hilbert_walk_ym", "hilbert_walkPy", "hilbert_move_xy", "hilbert_indexureya", "hilbert_indexurex", "hilbert_step_y", "hilbert_indexurey", "hilbert_walk_vy", "hilbert_view_ya", "hilbert_walk_ry", "hilbert_hop_y", "hilbert_walk_yn", "hilbert_move_x", "hilbert_path_ey", "hilbert_walkureya", "hilbert_step_ya", "hilbert_walk_oy", "hilbert_walk_ny", "hilbert_walk___ya", "hilbert_walkFya", "hilbert_step_yt", "hilbert_index_ya", "hilbert_walkurey", "hilbert_path_cy", "hilbert_move_cy", "hilbert_walkFyn", "hilbert_move_y", "hilbert_walkurex", "hilbert_walkPY", "hilbert_wait_ya", "hilbert_walk_xy", "hilbert_move_ry", "hilbert_wait_ye", "hilbert_view_yn", "hilbert_walkPyt", "hilbert_walk___x", "hilbert_walkFx", "hilbert_walk___y", "hilbert_walk_ya", "hilbert_path_x", "hilbert_walk_ye", "hilbert_walk_iy", "hilbert_hop_ya", "hilbert_walk___type", "hilbert_walk_type", "hilbert_index_x", "hilbert_wait_ym", "hilbert_move_iy", "hilbert_wait_y", "hilbert_view_y", "hilbert_move_yt", "hilbert_walk_ey", "hilbert_move_type", "hilbert_hop_x", "hilbert_walk_yt"], "hilbert_walk_c": ["hilbert_walk_ci", "hilbert_walker_ci", "hilbert_walker_c", "hilbert_walk_cy", "hilbert_walker_cy", "hilbert_walker_y"], "hilbert_walk_mb": ["hilbert_walk_b", "hilbert_walk_mm", "hilbert_walker_mm", "hilbert_walker_xb", "hilbert_walker_mb", "hilbert_walk_xb", "hilbert_walker_b"], "hilbert": ["halbolt", "Hailbl", "halcox", "hillcox", "Hilbolt", "Hailbert", "hillbert", "hilbl", "Hilcox", "hailbert", "hilbolt", "halbl", "hillbolt", "hillbl", "hailbolt", "Hilbl", "Hilbert", "halbert", "hailbl", "Hailbolt", "hilcox", "hailcox", "Hailcox"], "current_macroblock": ["current_macroncondition", "current_maclassblock", "current_mac_row", "current_mic_row", "current_maclassrow", "current_mic_condition", "current_mic_block", "current_microcondition", "current_maclassblocks", "current_macroblocks", "current_mac_condition", "current_mic_blocks", "current_maclasscondition", "current_microblock", "current_macronblock", "current_microrow", "current_mac_block", "current_mac_blocks", "current_macrocondition", "current_macrorow", "current_microblocks", "current_macronblocks", "current_macronrow"], "c_fragment": ["current_frangment", "current_fragments", "current_frangement", "current_fagme", "current_fagement", "current_frasureme", "current_fragme", "current_frragme", "current_frangme", "current_frragments", "current_fagment", "current_fagments", "current_frragment", "current_frragement", "current_frasurements", "current_frangments", "current_frasurement", "current_fragement", "current_frasureement"], "travel_width": ["travel___shape", "travel___layout", " travel_layout", "travel___weight", " travel_shape", "travel_weight", "travelableweight", "travelablewidth", "travelablelayout", "travel_layout", "travel___width", "travelableshape", " travel_weight", "travel_shape"], "travel_height": ["travelacheight", " travel_padding", "travelacdistance", "travel_padding", "travel_distance", "travelacpadding", "travelacwidth", " travel_distance"], "travel_width_mb": ["travel_width_bb", "travel_weight_mm", "travel_weight_mb", "travel_weight_bb", "travel_width_mp", "travel_weight_mp", "travel_width_mm"], "travel_height_mb": ["travel_data_mm", "travel_data_mp", "travel_height_bb", "travel_data_bb", "travel_height_mm", "travel_data_mb", "travel_height_mp"], "mapping_index": ["mapped_id", "mapped_index", "mapping_depth", "mapped_ind", "mapping_ind", "mapped_depth", "mapping_id"], "current_fragment": ["current_frigement", "current_drigments", "current_fraggment", "current_fraggement", "current_drigment", "current_frangmented", "current_frangment", "current_fraggments", "current_fragments", "current_frangement", "current_drigement", "current_dragmented", "current_dragments", "current_dragment", "current_frigments", "current_fragmented", "current_frangments", "current_frigmented", "current_frigment", "current_dragement", "current_fragement", "current_fraggmented", "current_drigmented"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static void vnc_connect(VncDisplay *vd, int csock,\n\n                        bool skipauth, bool websocket)\n\n{\n\n    VncState *vs = g_malloc0(sizeof(VncState));\n\n    int i;\n\n\n\n    vs->csock = csock;\n\n    vs->vd = vd;\n\n\n\n    if (skipauth) {\n\n\tvs->auth = VNC_AUTH_NONE;\n\n\tvs->subauth = VNC_AUTH_INVALID;\n\n    } else {\n\n        if (websocket) {\n\n            vs->auth = vd->ws_auth;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        } else {\n\n            vs->auth = vd->auth;\n\n            vs->subauth = vd->subauth;\n\n        }\n\n    }\n\n    VNC_DEBUG(\"Client sock=%d ws=%d auth=%d subauth=%d\\n\",\n\n              csock, websocket, vs->auth, vs->subauth);\n\n\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n\n    }\n\n\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n\n    qemu_set_nonblock(vs->csock);\n\n    if (websocket) {\n\n        vs->websocket = 1;\n\n        if (vd->ws_tls) {\n\n            qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs);\n\n        } else {\n\n            qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n        }\n\n    } else\n\n    {\n\n        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);\n\n    }\n\n\n\n    vnc_client_cache_addr(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n\n\n    if (!vs->websocket) {\n\n        vnc_init_state(vs);\n\n    }\n\n\n\n    if (vd->num_connecting > vd->connections_limit) {\n\n        QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {\n\n                vnc_disconnect_start(vs);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 15389, "substitutes": {"vd": ["vision", "vr", "d", "fd", "vv", "VD", "vp", "vid", "bd", "td", "dl", "ud", "ve", "di", "vm", "nd", "ld", "v", "gd", "help", "pd", "cd", "ant", "ad", "sd", "xd", "gb", "cover", "library", "df", "dt", "vg", "uds", "md", "ov", "sv", "va", "nv", "rt", "vo", "ds", "dd", "hd", "vc", "od", "dn", "dr", "vt", "wd", "lv"], "csock": ["cksock", "csody", " csink", "rsock", "dsocks", "jsick", "psorp", "bsink", "dsocker", "Csock", "vsocket", "psocket", "ciock", "cksocket", "jsocked", "psink", "cocks", "ssocker", "Csink", "ksocked", "cusocket", "cocked", "cssock", "rsocked", " csocket", "dsocked", "cssOCK", "csorp", "ksocket", "jsock", "ciink", "ksink", "cksocked", "vsock", "rsocket", "vsorp", "gsink", "bsOCK", "ssocket", "ssocked", "codesOCK", "ksocker", "cssink", " csick", "cocket", "csocked", "ciorp", "codesocket", "cock", "codesock", "cusock", "vsody", "vsick", "dsocket", "bsocket", "psock", "csink", "vsocker", "dsock", "bsock", "cssocket", "ksocks", "vsink", "csocks", "csocker", "dsink", "cusocked", "ksock", "wsocket", "csocket", "jsocket", "gsody", "csOCK", "resOCK", "codesink", "rsocker", "wsock", "wsink", "ssock", "gsick", " csody", "resock", "wsOCK", "Csocker", "cksick", " csocker", "dsOCK", "resink", "gsock", "Csocket", "cusick", "resocket", "ciocket", "csick"], "skipauth": [" skiputh", "skipauthent", "allowauth", "allowuth", "copyauthent", "copyacl", "allowauthent", "copyuth", "Skipauth", "allowAuth", "copyauth", "skipacl", "missingacl", "Skiputh", "Skipauthent", "missingauth", " skipacl", "skipAuth", "skiputh", "missingauthent", "missinguth", " skipauthent", " skipAuth", "SkipAuth"], "websocket": ["website", " weckset", "wealsession", "wealswitch", "rebspace", "websock", "webersession", "wealsocket", "weversocket", "wealsockets", "wecksite", "weversockets", "wecksockets", "shebswitch", "weasockets", "rebsocket", " websockets", "wecksock", "weasocket", "weblogocket", "wessession", "rebsockets", "reaswitch", "webset", "websockets", "weaswitch", "wecksource", "webswitch", "rebswitch", "webspace", "wessock", "wessocket", "wecksocket", "weversock", "pebsockets", " webset", "wesset", "shebsockets", "weckset", "weblogock", "webersockets", "wessite", "hebsock", "weaspace", "reasocket", "wesswitch", "websource", "pessockets", "hessystem", "wessource", "pebsocket", " website", "wecsocket", "webersocket", "pessocket", "pebscript", "wessystem", "weckswitch", "shebsock", "webscript", "shecksocket", "wesspace", "pebsession", "pesscript", "wecsockets", "wealscript", "weberscript", "wecsite", "weblogystem", "hebsystem", "weblogource", "reaspace", "websession", "websystem", "weverswitch", "wealsock", "hebsocket", "sheckswitch", "hebsource", "hessocket", " wecksocket", "shecksock", " wecksockets", "wecksystem", "wesscript", "reasockets", "wessockets", "hessource", " wecksite", "hessock", "pessession", "weckspace", "shecksockets", "shebsocket", "wecset"], "vs": ["vers", "env", "versions", "vp", "rs", "verts", "qs", "js", "ps", "eps", "ums", "lines", "asts", "sv", "events", "las", "fs", "ins", "Vs", "iv", "ups", "pages", "cs", "vm", "es", "nav", "views", "s", "ns", "nv", "ops", "vt", "res", "vals", "ks", "vr", "cv", "values", "pg", "hs", "os", "fg", "vi", "ves", "ms", "VS", "obs", "alls", "otes", "http", "state", "vg", "va", "services", "ls", "pos", "net", "as", "vv", "bs", "vid", "changes", "sk", "its", "nets", "v", "ss", "var", "flags", "vas", "gs", "wp", "blogs", "xs", "ports", "stats", "ov", "ds", "vc", "css", "ts", "ils", "sts"], "i": ["hi", "qi", "it", "ui", "I", "d", "t", "ai", "ni", "xi", "id", "iu", "l", "gi", "a", "io", "oi", "mu", "ci", "di", "x", "si", "ii", "v", "vi", "o", "yi", "u", "z", "p", "e", "fi", "li", "b", "base", "multi", "j", "ix", "n", "f", "phi", "ti", "ip", "c", "eni", "pi", "uli", "q", "r", "bi", "gui", "ri", "zi", "abi", "index"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_mct_read(void *opaque, target_phys_addr_t offset,\n\n        unsigned size)\n\n{\n\n    Exynos4210MCTState *s = (Exynos4210MCTState *)opaque;\n\n    int index;\n\n    int shift;\n\n    uint64_t count;\n\n    uint32_t value;\n\n    int lt_i;\n\n\n\n    switch (offset) {\n\n\n\n    case MCT_CFG:\n\n        value = s->reg_mct_cfg;\n\n        break;\n\n\n\n    case G_CNT_L: case G_CNT_U:\n\n        shift = 8 * (offset & 0x4);\n\n        count = exynos4210_gfrc_get_count(&s->g_timer);\n\n        value = UINT32_MAX & (count >> shift);\n\n        DPRINTF(\"read FRC=0x%llx\\n\", count);\n\n        break;\n\n\n\n    case G_CNT_WSTAT:\n\n        value = s->g_timer.reg.cnt_wstat;\n\n        break;\n\n\n\n    case G_COMP_L(0): case G_COMP_L(1): case G_COMP_L(2): case G_COMP_L(3):\n\n    case G_COMP_U(0): case G_COMP_U(1): case G_COMP_U(2): case G_COMP_U(3):\n\n    index = GET_G_COMP_IDX(offset);\n\n    shift = 8 * (offset & 0x4);\n\n    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);\n\n    break;\n\n\n\n    case G_TCON:\n\n        value = s->g_timer.reg.tcon;\n\n        break;\n\n\n\n    case G_INT_CSTAT:\n\n        value = s->g_timer.reg.int_cstat;\n\n        break;\n\n\n\n    case G_INT_ENB:\n\n        value = s->g_timer.reg.int_enb;\n\n        break;\n\n        break;\n\n    case G_WSTAT:\n\n        value = s->g_timer.reg.wstat;\n\n        break;\n\n\n\n    case G_COMP0_ADD_INCR: case G_COMP1_ADD_INCR:\n\n    case G_COMP2_ADD_INCR: case G_COMP3_ADD_INCR:\n\n        value = s->g_timer.reg.comp_add_incr[GET_G_COMP_ADD_INCR_IDX(offset)];\n\n        break;\n\n\n\n        /* Local timers */\n\n    case L0_TCNTB: case L0_ICNTB: case L0_FRCNTB:\n\n    case L1_TCNTB: case L1_ICNTB: case L1_FRCNTB:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n        index = GET_L_TIMER_CNT_REG_IDX(offset, lt_i);\n\n        value = s->l_timer[lt_i].reg.cnt[index];\n\n        break;\n\n\n\n    case L0_TCNTO: case L1_TCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_cnt_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read TCNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_ICNTO: case L1_ICNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_ltick_int_get_cnto(&s->l_timer[lt_i].tick_timer);\n\n        DPRINTF(\"local timer[%d] read ICNTO %x\\n\", lt_i, value);\n\n        break;\n\n\n\n    case L0_FRCNTO: case L1_FRCNTO:\n\n        lt_i = GET_L_TIMER_IDX(offset);\n\n\n\n        value = exynos4210_lfrc_get_count(&s->l_timer[lt_i]);\n\n\n\n        break;\n\n\n\n    case L0_TCON: case L1_TCON:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.tcon;\n\n        break;\n\n\n\n    case L0_INT_CSTAT: case L1_INT_CSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_cstat;\n\n        break;\n\n\n\n    case L0_INT_ENB: case L1_INT_ENB:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.int_enb;\n\n        break;\n\n\n\n    case L0_WSTAT: case L1_WSTAT:\n\n        lt_i = ((offset & 0xF00) - L0_TCNTB) / 0x100;\n\n        value = s->l_timer[lt_i].reg.wstat;\n\n        break;\n\n\n\n    default:\n\n        hw_error(\"exynos4210.mct: bad read offset \"\n\n                TARGET_FMT_plx \"\\n\", offset);\n\n        break;\n\n    }\n\n    return value;\n\n}\n", "idx": 23155, "substitutes": {"opaque": ["oplonymous", "opec", "iopcus", "oophole", "oopivalent", "oplcus", "opthole", "ioponymous", " ophole", "oplaque", "ophole", "hopaque", "oopec", "hoponymous", "opcus", "optaque", "optec", "optivalent", "iopaque", "oopaque", " opec", "hopcus", "oponymous", "opivalent", " opivalent"], "offset": ["delay", "bound", "port", "i", "phase", "start", "attribute", "off", "ref", "sample", "config", "option", "part", "origin", "energy", "style", "align", "buffer", "pos", "alloc", "address", "entry", "data", "seed", "fee", "number", "prefix", "slot", "addr", "operation", "o", "timeout", "initial", "exclusive", "action", "ptr", "set", "location", "online", "seq", "alias", "error", "Offset", "length", "slice", "loc", "parent", "reset", "range", "alpha", "pointer", "position", "server", "base", "command", "padding", "type", "zero"], "size": [" error", " bytes", "Size", "bytes", "align", "ize", "type", "address", "data", "length", " length", " sizes", "len", "SIZE"], "s": ["sv", "sim", "sb", "native", "e", "sym", "sie", "sl", "g", "ses", "fs", "hs", "d", "sets", "ops", "site", "ks", "ds", "services", "os", "f", "sys", "t", "u", "its", "storage", "ssl", "shared", "p", "ts", "us", "cs", "o", "ls", "sync", "is", "stats", "sa", "sg", "c", "ss", "js", "spec", "self", "si", "b", "service", "aws", "n", "session", "S", "ns", "slice", "sf", "ps", "rs", "gs", "conf", "secondary", "server", "su", "sq", "states", "sum"], "index": ["i", "name", "row", "start", "connect", "end", "conn", "level", "ind", "input", "inc", "val", "key", "connection", "align", "access", "column", "weight", "type", "pos", "ion", "address", "version", "id", "number", "prefix", "field", "find", "fix", "Index", "num", "match", "si", "x", "length", "slice", "loc", "len", "element", "pointer", "block", "position", "base", "action"], "shift": ["transform", "hift", "shape", "start", "limit", "ix", "off", "send", "ind", "scale", "throw", "push", "power", "ctr", "force", "pad", "align", "weight", "reverse", "pos", "dist", "address", "use", "seed", "patch", "diff", "label", "balance", "depth", "field", "load", "timeout", "strip", "sh", "pop", "pull", "ptr", "set", "carry", "length", "sup", "slice", "mask", "flow", "Shift", "show", "range", "mix", "pack", "sleep", "sort", "max"], "count": ["col", "found", "i", "name", "limit", "handle", "start", "cc", "ref", "ind", "text", "coll", "part", "weight", "type", "info", "Count", "cat", "cache", "list", "sum", "current", "id", "number", "code", "depth", "content", "c", "num", "match", "flag", "counter", "seq", "carry", "length", "call", "mask", "len", "total", "allow", "child", "batch", "array", "all", "base", "max"], "value": ["Value", "val", "message", "device", "slave", "info", "data", "balance", "v", "instance", "image", "output", "this", "format", "type", "member", "name", "response", "end", "object", "scale", "valid", "null", "gi", "style", "dev", "description", "current", "unit", "child", "media", "element", "multi", "VALUE", "action", "reg", "native", "example", "summary", "amount", "result", "weight", "function", "model", "number", "vi", "depth", "comment", "memory", "values", "num", "service", "python", "error", "length", "expression", "volume", "start", "feature", "home", "get", "version", "label", "content", "document", "seq", "parent", "range", "server"], "lt_i": [" seq_ii", " seq_i", " ref_int", " seq_slice", " seq_int", " ref_ii", " ref_i", " ref_slice"]}}
{"project": "qemu", "commit_id": "591b320ad046b2780c1b2841b836b50ba8192f02", "target": 1, "func": "static inline int popcountl(unsigned long l)\n\n{\n\n    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);\n\n}\n", "idx": 3977, "substitutes": {"l": ["pl", "ol", "li", "ul", "lp", "cl", "lb", "r", "d", "n", "dl", "ln", "sl", "lr", "i", "m", "ls", "ll", "x", "c", "p", "L", "e", "lc", "f", "length", "len", "kl", "u", "la", "el", "o", "v", "b", "t", "al", "val", "lo", "list", "le"]}}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr,\n\n                        uint8_t ar)\n\n{\n\n    CPUS390XState *env = &cpu->env;\n\n    S390PCIBusDevice *pbdev;\n\n    MemoryRegion *mr;\n\n    int i;\n\n    uint32_t fh;\n\n    uint8_t pcias;\n\n    uint8_t len;\n\n    uint8_t buffer[128];\n\n\n\n    if (env->psw.mask & PSW_MASK_PSTATE) {\n\n        program_interrupt(env, PGM_PRIVILEGED, 6);\n\n        return 0;\n\n    }\n\n\n\n    fh = env->regs[r1] >> 32;\n\n    pcias = (env->regs[r1] >> 16) & 0xf;\n\n    len = env->regs[r1] & 0xff;\n\n\n\n    if (pcias > 5) {\n\n        DPRINTF(\"pcistb invalid space\\n\");\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);\n\n        return 0;\n\n    }\n\n\n\n    switch (len) {\n\n    case 16:\n\n    case 32:\n\n    case 64:\n\n    case 128:\n\n        break;\n\n    default:\n\n        program_interrupt(env, PGM_SPECIFICATION, 6);\n\n        return 0;\n\n    }\n\n\n\n    pbdev = s390_pci_find_dev_by_fh(fh);\n\n    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {\n\n        DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh);\n\n        setcc(cpu, ZPCI_PCI_LS_INVAL_HANDLE);\n\n        return 0;\n\n    }\n\n\n\n    if (pbdev->lgstg_blocked) {\n\n        setcc(cpu, ZPCI_PCI_LS_ERR);\n\n        s390_set_status_code(env, r1, ZPCI_PCI_ST_BLOCKED);\n\n        return 0;\n\n    }\n\n\n\n    mr = pbdev->pdev->io_regions[pcias].memory;\n\n    if (!memory_region_access_valid(mr, env->regs[r3], len, true)) {\n\n        program_interrupt(env, PGM_ADDRESSING, 6);\n\n        return 0;\n\n    }\n\n\n\n    if (s390_cpu_virt_mem_read(cpu, gaddr, ar, buffer, len)) {\n\n        return 0;\n\n    }\n\n\n\n    for (i = 0; i < len / 8; i++) {\n\n        memory_region_dispatch_write(mr, env->regs[r3] + i * 8,\n\n                                     ldq_p(buffer + i * 8), 8,\n\n                                     MEMTXATTRS_UNSPECIFIED);\n\n    }\n\n\n\n    setcc(cpu, ZPCI_PCI_LS_OK);\n\n    return 0;\n\n}\n", "idx": 20797, "substitutes": {"cpu": ["lc", "platform", "computer", "hp", "net", "lb", "gpu", "conn", "linux", "jp", "config", "GPU", "eni", "kernel", "loop", "progress", "nic", "pkg", "performance", "CP", "consumer", "processor", "pc", "CPU", "node", "fp", "cmp", "sys", "nc", "cp", "cache", "p", "component", "cycle", "machine", "uci", "np", "que", "cli", "mac", "pool", "c", "ctx", "cn", "roc", "ocr", "loader", "uu", "python", "core", "gc", "chip", "console", "boot", "proc", "vm", "hw", "ck", "PF", "clock", "pu", "ilo"], "r1": ["er1", "r8", "sr8", "ar31", "er2", "R4", "rone", "sr2", "rcone", "R31", "rc3", "r4", "fr5", "sr3", "ar1", "ar2", "R1", "sr1", "rc2", "R3", "r2", "fr2", "rc1", " r4", "r31", "sr4", "R8", " r8", "fr1", "ar5", "er3", " rone", " r2", "Rone", "fr31", "R5", "r5", "R2"], "r3": [" r5", " r11", "er11", "r11", "R4", "er2", "rr11", "rr2", "r4", "r6", "p4", "p6", "ar1", "p1", "R1", "R3", "ar6", "rr5", "r2", "er5", "ar4", "rr3", "er3", "R6", "p3", " r2", "r5", "ar3"], "gaddr": ["ghost", "mgdb", "gaddress", "mgaddress", "_db", "mghost", "_host", "_addr", "_address", "wdb", "gdb", "waddr", "mgaddr", "waddress", "whost"], "ar": ["arc", "ap", "err", "acl", "arg", "amd", "ara", "art", "al", "ac", "args", "ad", "arr", "arp", "au", "sa", "xa", "rar", "ann", "ard", "aa", "ai", "ag", "array", "AR", "att", "ars", "cap", "rg"], "env": ["config", "event", "eni", "chal", "prov", "exc", "ini", "que", "context", "qa", "cdn", "global", "osc", "v", "conf", "ev", "inet", "end", "conn", "iv", "db", "cv", "oa", "eng", "site", "state", "enc", "code", "ext", "cfg", "ass", "fen", "qt", "ce", "uni", "scope", "net", "stack", "e", "forge", "err", "eu", "kernel", "esp", "ou", "ea", "exec", "init", "cf", "zone", "cli", "Environment", "el", "dt", "gui", "loader", "python", "core", "req", "skin", "stage", "dat", "ne", "ec", "enh", "en", "lv", "shell", "energy", "engine", "po", "esi", "nc", "args", "cache", "vs", "np", "kn", "ctx", "agent", "cn", "cal", "profile", "session", "console", "vm", "estate", "server", "environment"], "pbdev": ["lpdev", "ppdiv", "lpdiv", "sbdevice", "lpdriver", "ppdevice", "PBDev", "lpdevice", "sbdriver", "rbdev", "fbdevice", "pbDev", "fbdiv", "jpdev", "xbserial", "pprent", "cbdiv", "cbdriver", "pdevice", "fbrent", "pcDEV", "lpconf", "cberror", "PBdev", "pbdiv", "PBDEV", "pbDEV", "pcDev", "cbserial", "jpdevice", "cbdevice", "sbdev", "xbdriver", "pcdiv", "rbdevice", "jpdef", "xbdevice", "pdev", "fbdev", "pbdevice", "lpDev", "pbdef", "pcdevice", "sbserial", "PBdiv", "pbserial", "pbdriver", "pberror", "cbdev", "ppdev", "lprent", "jpdriver", "pbrent", "rbdriver", "xbdev", "lpdef", "pcconf", "fbconf", "pdiv", "lpDEV", "lperror", "pcdev", "pbconf", "rbdef"], "mr": ["wm", "hm", "bro", "err", "adr", "ml", "Mr", "rpm", "rr", "wr", "rx", "mt", "bridge", "lr", "yr", "km", "wk", "r", "m", "arr", "mc", "dr", "mer", "igr", "module", "pr", "rm", "fr", "shr", "hr", "sr", "vr", "dm", "LR", "bm", "er", "br", "gr", "rs", "vm", "kr", "gm", "MR", "attr", "mn", "mmm", "gb"], "i": ["io", "e", "pi", "d", "ti", "I", "type", "f", "ci", "r", "s", "j", "p", "ip", "or", "id", "is", "c", "a", "ii", "b", "n", "v", "z", "l", "count"], "fh": [" fhs", "tfh", "fhs", "cfw", "dfhs", " fah", " fw", "dfh", "fq", "ghs", "rfhr", "cfh", "tfht", "dfgh", " fbh", "rfh", "tfhs", "rfhs", " fH", "fhr", "lfhr", "cfsh", "tfah", " fph", "fht", "fah", "fhp", " fhp", " fsh", "fH", "fph", "fbh", "fsh", "ggh", "gq", "Fhs", "dfhp", "dfht", "fbhs", "Fgh", " fhr", "dfw", "dfq", "lfH", "Fh", "dfsh", "fw", "gh", "fgh", "lfhs", "dfah", "lfph", "fbph", "Fq", "lfbh", "lfh", "cfhp", "rfbh", "fbH", " fht"], "pcias": ["pbias", "pociasi", "pidiasing", "pciAS", "Pciasi", "piiase", "cbiAs", "cbiasi", "pdiase", "pidias", "pcmasi", "pqias", "Pciase", "cciac", "piias", "Pdiase", "piiAS", "pbiAs", "pciasi", "pqiAs", "pidiAS", "cociAS", "pciac", "Pdiasi", "Pciac", "pociAS", "PdiAS", "piliase", "cociasing", "cciAs", "Pcias", "pbiasi", "pciase", "pdias", "pkiasing", "pocias", "pkiac", "PciAS", "cociac", "pciAs", "pcmas", "piiac", "pociasing", "pqiAS", "cciAS", "pdiasi", "pqiasi", "pdiAS", "cbias", "Pdiac", "piliac", "pciasing", "cciasi", "pidiac", "ccias", "pbiAS", "cbiAS", "pkiAS", "cciasing", "pociac", "cocias", "pkias", "pilias", "pcmAs", "pdiac", "pcmAS", "Pdias", "pbiac", "piliAS"], "len": ["lc", "span", "str", "limit", "en", "conn", "sl", "acl", "val", "part", "ln", "bin", "bl", "layer", "offset", "pos", "lan", "cmp", "split", "size", "vel", "data", "rel", "lin", "fun", "depth", "dy", "le", "count", "live", "gen", "el", "lim", "body", "code", "ann", "mem", "seq", "rev", "fl", "dl", "length", "min", "loc", "lt", "den", "lon", "lib", "ler", "li", "lf", "fn", "l", "Len", "cap", "fin"], "buffer": ["row", "binary", "shape", "ba", "uffer", "extra", "null", "bb", "bin", "bytes", "transfer", "alloc", "info", "data", "arr", "buf", "raw", "blocks", "read", "Buffer", "batch", "buff", "array", "block", "empty", "cap"]}}
{"project": "qemu", "commit_id": "8dfe8e7f4facef400ef1c220f29196ae5cfc526c", "target": 0, "func": "static void ppc_spapr_init(MachineState *machine)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\n\n    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    PowerPCCPU *cpu;\n\n    PCIHostState *phb;\n\n    int i;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *rma_region;\n\n    void *rma = NULL;\n\n    hwaddr rma_alloc_size;\n\n    hwaddr node0_size = spapr_node0_size();\n\n    uint32_t initrd_base = 0;\n\n    long kernel_size = 0, initrd_size = 0;\n\n    long load_limit, fw_size;\n\n    bool kernel_le = false;\n\n    char *filename;\n\n\n\n    msi_supported = true;\n\n\n\n    QLIST_INIT(&spapr->phbs);\n\n\n\n    cpu_ppc_hypercall = emulate_spapr_hypercall;\n\n\n\n    /* Allocate RMA if necessary */\n\n    rma_alloc_size = kvmppc_alloc_rma(&rma);\n\n\n\n    if (rma_alloc_size == -1) {\n\n        error_report(\"Unable to create RMA\");\n\n        exit(1);\n\n    }\n\n\n\n    if (rma_alloc_size && (rma_alloc_size < node0_size)) {\n\n        spapr->rma_size = rma_alloc_size;\n\n    } else {\n\n        spapr->rma_size = node0_size;\n\n\n\n        /* With KVM, we don't actually know whether KVM supports an\n\n         * unbounded RMA (PR KVM) or is limited by the hash table size\n\n         * (HV KVM using VRMA), so we always assume the latter\n\n         *\n\n         * In that case, we also limit the initial allocations for RTAS\n\n         * etc... to 256M since we have no way to know what the VRMA size\n\n         * is going to be as it depends on the size of the hash table\n\n         * isn't determined yet.\n\n         */\n\n        if (kvm_enabled()) {\n\n            spapr->vrma_adjust = 1;\n\n            spapr->rma_size = MIN(spapr->rma_size, 0x10000000);\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size > node0_size) {\n\n        error_report(\"Numa node 0 has to span the RMA (%#08\"HWADDR_PRIx\")\",\n\n                     spapr->rma_size);\n\n        exit(1);\n\n    }\n\n\n\n    /* Setup a load limit for the ramdisk leaving room for SLOF and FDT */\n\n    load_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;\n\n\n\n    /* We aim for a hash table of size 1/128 the size of RAM.  The\n\n     * normal rule of thumb is 1/64 the size of RAM, but that's much\n\n     * more than needed for the Linux guests we support. */\n\n    spapr->htab_shift = 18; /* Minimum architected size */\n\n    while (spapr->htab_shift <= 46) {\n\n        if ((1ULL << (spapr->htab_shift + 7)) >= machine->maxram_size) {\n\n            break;\n\n        }\n\n        spapr->htab_shift++;\n\n    }\n\n    spapr_alloc_htab(spapr);\n\n\n\n    /* Set up Interrupt Controller before we create the VCPUs */\n\n    spapr->icp = xics_system_init(machine,\n\n                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),\n\n                                               smp_threads),\n\n                                  XICS_IRQS, &error_fatal);\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_validate_node_memory(machine, &error_fatal);\n\n    }\n\n\n\n    /* init CPUs */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n\n    }\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        cpu = cpu_ppc_init(machine->cpu_model);\n\n        if (cpu == NULL) {\n\n            error_report(\"Unable to find PowerPC CPU definition\");\n\n            exit(1);\n\n        }\n\n        spapr_cpu_init(spapr, cpu, &error_fatal);\n\n    }\n\n\n\n    if (kvm_enabled()) {\n\n        /* Enable H_LOGICAL_CI_* so SLOF can talk to in-kernel devices */\n\n        kvmppc_enable_logical_ci_hcalls();\n\n        kvmppc_enable_set_mode_hcall();\n\n    }\n\n\n\n    /* allocate RAM */\n\n    memory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(sysmem, 0, ram);\n\n\n\n    if (rma_alloc_size && rma) {\n\n        rma_region = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram_ptr(rma_region, NULL, \"ppc_spapr.rma\",\n\n                                   rma_alloc_size, rma);\n\n        vmstate_register_ram_global(rma_region);\n\n        memory_region_add_subregion(sysmem, 0, rma_region);\n\n    }\n\n\n\n    /* initialize hotplug memory address space */\n\n    if (machine->ram_size < machine->maxram_size) {\n\n        ram_addr_t hotplug_mem_size = machine->maxram_size - machine->ram_size;\n\n\n\n        if (machine->ram_slots > SPAPR_MAX_RAM_SLOTS) {\n\n            error_report(\"Specified number of memory slots %\"\n\n                         PRIu64\" exceeds max supported %d\",\n\n                         machine->ram_slots, SPAPR_MAX_RAM_SLOTS);\n\n            exit(1);\n\n        }\n\n\n\n        spapr->hotplug_memory.base = ROUND_UP(machine->ram_size,\n\n                                              SPAPR_HOTPLUG_MEM_ALIGN);\n\n        memory_region_init(&spapr->hotplug_memory.mr, OBJECT(spapr),\n\n                           \"hotplug-memory\", hotplug_mem_size);\n\n        memory_region_add_subregion(sysmem, spapr->hotplug_memory.base,\n\n                                    &spapr->hotplug_memory.mr);\n\n    }\n\n\n\n    if (smc->dr_lmb_enabled) {\n\n        spapr_create_lmb_dr_connectors(spapr);\n\n    }\n\n\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR rtas '%s'\", \"spapr-rtas.bin\");\n\n        exit(1);\n\n    }\n\n    spapr->rtas_size = get_image_size(filename);\n\n    spapr->rtas_blob = g_malloc(spapr->rtas_size);\n\n    if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {\n\n        error_report(\"Could not load LPAR rtas '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    if (spapr->rtas_size > RTAS_MAX_SIZE) {\n\n        error_report(\"RTAS too big ! 0x%zx bytes (max is 0x%x)\",\n\n                     (size_t)spapr->rtas_size, RTAS_MAX_SIZE);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* Set up EPOW events infrastructure */\n\n    spapr_events_init(spapr);\n\n\n\n    /* Set up the RTC RTAS interfaces */\n\n    spapr_rtc_create(spapr);\n\n\n\n    /* Set up VIO bus */\n\n    spapr->vio_bus = spapr_vio_bus_init();\n\n\n\n    for (i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    /* We always have at least the nvram device on VIO */\n\n    spapr_create_nvram(spapr);\n\n\n\n    /* Set up PCI */\n\n    spapr_pci_rtas_init();\n\n\n\n    phb = spapr_create_phb(spapr, 0);\n\n\n\n    for (i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!nd->model) {\n\n            nd->model = g_strdup(\"ibmveth\");\n\n        }\n\n\n\n        if (strcmp(nd->model, \"ibmveth\") == 0) {\n\n            spapr_vlan_create(spapr->vio_bus, nd);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n\n        spapr_vscsi_create(spapr->vio_bus);\n\n    }\n\n\n\n    /* Graphics */\n\n    if (spapr_vga_init(phb->bus, &error_fatal)) {\n\n        spapr->has_graphics = true;\n\n        machine->usb |= defaults_enabled() && !machine->usb_disabled;\n\n    }\n\n\n\n    if (machine->usb) {\n\n        if (smc->use_ohci_by_default) {\n\n            pci_create_simple(phb->bus, -1, \"pci-ohci\");\n\n        } else {\n\n            pci_create_simple(phb->bus, -1, \"nec-usb-xhci\");\n\n        }\n\n\n\n        if (spapr->has_graphics) {\n\n            USBBus *usb_bus = usb_bus_find(-1);\n\n\n\n            usb_create_simple(usb_bus, \"usb-kbd\");\n\n            usb_create_simple(usb_bus, \"usb-mouse\");\n\n        }\n\n    }\n\n\n\n    if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n\n        error_report(\n\n            \"pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)\",\n\n            MIN_RMA_SLOF);\n\n        exit(1);\n\n    }\n\n\n\n    if (kernel_filename) {\n\n        uint64_t lowaddr = 0;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, PPC_ELF_MACHINE, 0);\n\n        if (kernel_size == ELF_LOAD_WRONG_ENDIAN) {\n\n            kernel_size = load_elf(kernel_filename,\n\n                                   translate_kernel_address, NULL,\n\n                                   NULL, &lowaddr, NULL, 0, PPC_ELF_MACHINE, 0);\n\n            kernel_le = kernel_size > 0;\n\n        }\n\n        if (kernel_size < 0) {\n\n            error_report(\"error loading %s: %s\",\n\n                         kernel_filename, load_elf_strerror(kernel_size));\n\n            exit(1);\n\n        }\n\n\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            /* Try to locate the initrd in the gap between the kernel\n\n             * and the firmware. Add a bit of space just in case\n\n             */\n\n            initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              load_limit - initrd_base);\n\n            if (initrd_size < 0) {\n\n                error_report(\"could not load initial ram disk '%s'\",\n\n                             initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    }\n\n\n\n    if (bios_name == NULL) {\n\n        bios_name = FW_FILE_NAME;\n\n    }\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (!filename) {\n\n        error_report(\"Could not find LPAR firmware '%s'\", bios_name);\n\n        exit(1);\n\n    }\n\n    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);\n\n    if (fw_size <= 0) {\n\n        error_report(\"Could not load LPAR firmware '%s'\", filename);\n\n        exit(1);\n\n    }\n\n    g_free(filename);\n\n\n\n    /* FIXME: Should register things through the MachineState's qdev\n\n     * interface, this is a legacy from the sPAPREnvironment structure\n\n     * which predated MachineState but had a similar function */\n\n    vmstate_register(NULL, 0, &vmstate_spapr, spapr);\n\n    register_savevm_live(NULL, \"spapr/htab\", -1, 1,\n\n                         &savevm_htab_handlers, spapr);\n\n\n\n    /* Prepare the device tree */\n\n    spapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\n\n                                            kernel_size, kernel_le,\n\n                                            kernel_cmdline,\n\n                                            spapr->check_exception_irq);\n\n    assert(spapr->fdt_skel != NULL);\n\n\n\n    /* used by RTAS */\n\n    QTAILQ_INIT(&spapr->ccs_list);\n\n    qemu_register_reset(spapr_ccs_reset_hook, spapr);\n\n\n\n    qemu_register_boot_set(spapr_boot_set, spapr);\n\n}\n", "idx": 25103, "substitutes": {"machine": ["space", "node", "kernel", "class", "scope", "info", "b", "m", "server", "image", "manager", "template", "module", "data", "base", "hard", "config", "interface", "address", "state", "loader", "mac", "instance", "mobile", "linux", "jam", "boot", "e", "cell", "home", "message", "process", "session", "M", "object", "model", "mode", "cache", "vm", "device", "note", "part", "slave", "comment", "computer", "host", "Machine", "database", "managed", "connection", "table"], "spapr": ["spapers", "skarpb", "scapeyr", "spapre", "spuprb", "spapprb", " spappb", " spapsrs", " spapsar", "SPaprator", "sparprc", "SPapper", "spashr", " spappru", " spaptrb", "sparpsr", "spaprator", "spapl", "SPapprs", "scapeb", "spampsr", "spapert", "spamper", "scaprt", "spAPR", "spupra", " spapR", "scapert", "spaptra", " spapl", "spappsr", "spapsar", " spapsr", "spaitrs", "spupl", "skarpar", " spaprb", "spapb", "scapers", "scapyr", "sprapr", " spappre", "spapprt", "spapepr", "spaptrb", "skapsr", "spappru", "spapsru", "spaprt", " spaprt", "spraprs", "scapb", "scapr", "sparprator", "spAPr", "spapeb", "scapeer", " spapb", "sparpr", "spaityr", "spaprb", "spapprs", "spapprc", "spapsrator", "spraprb", "spapsr", "spappre", "SPapprator", "spapper", "spamprt", "spapsrs", " spaptl", "SPaprc", "spapyr", "spadr", "spappar", "spampb", "scappr", "spapsrc", "spampre", "SPapr", "sprapl", "SPapprc", " spapru", "sparpb", " spapprt", "spupr", "spapsR", "spapeer", "spaperar", " spapper", " spaprs", "spapra", "spadpr", "spapsrb", " spapra", "SPapprb", " spapsru", "skapar", "spappb", "spashrt", " spappsr", "spadyr", "SPaper", "spaprc", "spapR", " spappr", "spapar", "spAPru", "spapprator", "skapb", " spaptra", "scapepr", " spapre", "spaperr", "SPappr", "spampru", " spapar", "scaprs", "spaitr", "spaptr", "SPaprs", "spapeyr", "sparprs", "spapru", "spasher", "spaptar", "spapser", "sprapra", "spaitpr", "spampR", " spaptr", "skapr", "SPaprb", "spaptl", "spashre", "spAPrs", "scaper", "spamprs", "spaperb", "spapsl", "sparpar", " spaper", "sparpru", "spapersr", "skarpr", "spaper", "skarpsr", "spampr", "spadrs", " spapsR", "sprapar", "spaptrs", "spaprs", "spappr", " spapsl"], "smc": ["smp", "mmc", "SMc", "smf", "svf", "svp", "svc", "svcc", "smcc", "SMf", "SMcc", "SMp", "mmf", "mmp", "mmcc"], "kernel_filename": ["linux_source", "kernelingfilename", "kernelpubfile", "linux_filename", "kernelingdescription", " kernel_file", "kernel_description", "kernel___description", "kernelpubfilename", "kernel___username", "kernelpubusername", "linux_description", "kernel_file", "kernel_password", " kernel_username", "kernel___filename", "kernel___source", "linux_username", "kernelpubpassword", "kernelingsource", "kernel_source", "kernelingusername", "kernel_username", " kernel_password"], "kernel_cmdline": ["kernel_macLine", "kernel_hostline", "kernel_cleanname", "kernel_hostLine", "kernel_commandli", "kernel_commandLine", "kernel_cmdli", "kernel_hostli", "kernel_cmdname", "kernel_cmdLine", "kernel_macline", "kernel_commandname", "kernel_cleanline", "kernel_cleanLine", "kernel_commandline", "kernel_hostname", "kernel_macli"], "initrd_filename": ["initrt_mode", "initrs_name", "initrs_location", "initrt_name", "initrs_filename", "initrt_filename", "initrd_name", "initrs_file", "initrd_location", "initrd_file", "initrd_mode", "initrt_file"], "cpu": ["CPU", "processor", "node", "gnu", "proc", "linux", "gpu", "mx", "boot", "disk", "mem", "hw", "lu", "nic", "process", "pool", "cow", "cp", "gp", "cache", "vm", " CPU", "conn", "computer", "net", "pu", "pc"], "phb": ["ppbs", "ppp", "PHbs", "ppB", "PHp", "phB", "php", "PHb", " phB", "PHB", "phbs", " phbs", "ppb", " php"], "i": ["z", "p", "m", "b", "c", "d", " I", "it", "ri", "io", "is", "e", "o", "s", "si", "ai", "ni", "ress", "h", "I", "f", "n", "j", "ip", "a", "r", "pi", "l"], "sysmem": ["systemram", "procmem", "sysmemory", "procmemory", " syslang", " sysram", "sysram", "procram", "systemlang", " sysmemory", "systemmem", "systemmemory", "proclang", "syslang"], "ram": ["gram", "RAM", "sc", "rom", "image", "sam", "tm", "img", "access", "iam", "mac", "instance", "range", "rams", "disk", "mem", "cms", "resource", "process", "mode", "cow", "cache", "AM", "ream", "sim", "mm", "Ram", "cam"], "rma_region": ["rna_location", "rma_location", "rna_region", "rna_resource", "rma_resource", "rma_area", "rna_area"], "rma": ["Rmas", "nrmas", "Rta", "srta", "rga", "Rfa", "rfa", "Rga", "srfa", "rta", "nrga", " rga", "nrma", "srma", "Rma", "srmas", " rta", " rfa", "nrfa", " rmas", "rmas"], "rma_alloc_size": ["rma_alloc__count", "rma_alloc_small", "rma_alloc32small", "rma_alloc32number", "rma_alloc_scale", "rma_alloc__num", "rma_alloc_address", "rma_alloc32size", "rma_allocetnum", "rma_alloc32scale", "rma_allocallscale", "rma_alloc_length", "rma_alloc_id", "rma_allocetize", "rma_allocetcount", "rma_alloc_ize", "rma_allocallunit", "rma_alloc_num", "rma_loc_size", "rma_loc_count", "rma_allocallid", "rma_alloc__ize", "rma_allocallsize", "rma_alloc_name", "rma_alloc_unit", "rma_alloc_number", "rma_allocetsize", "rma_alloc__size", "rma_loc_num", "rma_alloc_count", "rma_alloc_capacity", "rma_loc_ize"], "load_limit": ["loader_limit", "loader_limits", "load___policy", "load___lim", "loadingpolicy", "loader_length", "loadinglength", "load_limits", "loader_limited", "load_policy", "loadinglim", "load___limit", "load___length", "load_limited", "loader_lim", "load_lim", "load_length", "loadinglimit", "loader_policy"], "fw_size": ["hw_capacity", "hw_size", "hw_length", "fw_address", "fw_capacity", "hw_address", "fw_length"], "filename": ["processor", "dll", "name", "phrase", "fn", "prefix", "loader", "alias", "Filename", "url", "password", "cmd", "jpg", "path", "uri", "original", "wav", "files", "username", "src", "fil", "description", "title", "fd", "file"]}}
{"project": "qemu", "commit_id": "03ae4133ab8675d4c67e6fdc8032de7c53a89514", "target": 0, "func": "static void ppc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    pcc->parent_realize = dc->realize;\n\n    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;\n\n    dc->realize = ppc_cpu_realizefn;\n\n    dc->unrealize = ppc_cpu_unrealizefn;\n\n\n\n    pcc->parent_reset = cc->reset;\n\n    cc->reset = ppc_cpu_reset;\n\n\n\n    cc->class_by_name = ppc_cpu_class_by_name;\n\n    cc->has_work = ppc_cpu_has_work;\n\n    cc->do_interrupt = ppc_cpu_do_interrupt;\n\n    cc->dump_state = ppc_cpu_dump_state;\n\n    cc->dump_statistics = ppc_cpu_dump_statistics;\n\n    cc->set_pc = ppc_cpu_set_pc;\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;\n\n    cc->vmsd = &vmstate_ppc_cpu;\n\n#if defined(TARGET_PPC64)\n\n    cc->write_elf64_note = ppc64_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;\n\n#endif\n\n#endif\n\n\n\n    cc->gdb_num_core_regs = 71;\n\n\n\n#ifdef USE_APPLE_GDB\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;\n\n    cc->gdb_num_core_regs = 71 + 32;\n\n#endif\n\n\n\n#if defined(TARGET_PPC64)\n\n    cc->gdb_core_xml_file = \"power64-core.xml\";\n\n#else\n\n    cc->gdb_core_xml_file = \"power-core.xml\";\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;\n\n#endif\n\n\n\n    dc->fw_name = \"PowerPC,UNKNOWN\";\n\n}\n", "idx": 26886, "substitutes": {"oc": ["acc", "oca", "oci", "cca", "uc", "ogg", "anc", "c", "toc", "ob", "isc", "ec", "oper", "oco", "soc", "om", "bc", "mac", "ocr", "oid", "OC", "fc", "o", "unc", "loc", "voc", "ucc", "mc", "rc", "roc", "alloc", "co", "comp", "aco", "ocol", "usc", "coll", "org", "nc", "ac", "pc", "ok"], "data": ["load", "acc", "Data", "cm", "d", "config", "ds", "dd", "rec", "raw", "input", "dat", "dev", "board", "ci", "rc", "cache", "co", "device", "tc", "da", "src", "DATA", "func", "ac"], "pcc": ["facc", " pca", "ppcf", "Pcci", "ppcc", "cpuc", "fcca", "cpca", "ccf", "cpcci", "lpCC", "Pcc", "ppacc", "pca", " puc", "lpec", "prc", " prc", " pcca", "Pca", "PCC", "lprc", "puc", "pxc", "pacc", "lpcci", "cpcca", " pec", "pec", " pacc", "pcca", "lpcc", "cacc", "lpxc", "fcc", "Pcca", "ccc", "cpCC", " pxc", "pprc", "Pcf", "Pxc", "crc", " pCC", "Prc", " pcf", "fCC", "Pacc", "pcci", "lpcf", "Puc", "pcf", "Pec", "pCC", "cpcc", "lpcca"], "cc": ["acc", "sc", "code", "cm", "bec", "ctl", "cca", "uc", "cd", "kk", "anc", "c", "pg", "bb", "cci", "xc", "ec", "client", "cur", "config", "ect", "cus", "ct", "bc", "PC", "ce", "mac", "self", "cmp", "ee", "fc", "cell", "con", "cast", "cmd", "cl", "vc", " gcc", "cel", "CC", "ctx", "ci", "ucc", "cf", "mc", "rc", "cache", "co", "cn", "inc", "ga", "BC", "lc", "control", "ctrl", "comp", "gg", "ca", "tc", "go", "cu", "RC", "conn", "ck", "nc", "cs", "ac", "pc"], "dc": ["acc", "sc", "DC", "cca", "uc", "cd", "director", "auc", "c", "d", "cci", "doc", "ec", "ds", "cr", "bc", "mac", "db", "fc", "vc", "cdn", "disc", "di", "dt", "cf", "mc", "ga", "rc", "co", "inc", "cache", "design", "lc", "ca", "tc", "da", "conn", "cu", "duc", "ck", "df", "nc", "ac", "pc"]}}
{"project": "FFmpeg", "commit_id": "f7cf12b209c3a1ac2d6b797c585b593a5e9a461d", "target": 1, "func": "static int vc1_init_common(VC1Context *v)\n\n{\n\n    static int done = 0;\n\n    int i = 0;\n\n\n\n    v->hrd_rate = v->hrd_buffer = NULL;\n\n\n\n    /* VLC tables */\n\n    if(!done)\n\n    {\n\n        done = 1;\n\n        init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23,\n\n                 ff_vc1_bfraction_bits, 1, 1,\n\n                 ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4,\n\n                 ff_vc1_norm2_bits, 1, 1,\n\n                 ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64,\n\n                 ff_vc1_norm6_bits, 1, 1,\n\n                 ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7,\n\n                 ff_vc1_imode_bits, 1, 1,\n\n                 ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        for (i=0; i<3; i++)\n\n        {\n\n            init_vlc(&ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16,\n\n                     ff_vc1_ttmb_bits[i], 1, 1,\n\n                     ff_vc1_ttmb_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_ttblk_vlc[i], VC1_TTBLK_VLC_BITS, 8,\n\n                     ff_vc1_ttblk_bits[i], 1, 1,\n\n                     ff_vc1_ttblk_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_subblkpat_vlc[i], VC1_SUBBLKPAT_VLC_BITS, 15,\n\n                     ff_vc1_subblkpat_bits[i], 1, 1,\n\n                     ff_vc1_subblkpat_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<4; i++)\n\n        {\n\n            init_vlc(&ff_vc1_4mv_block_pattern_vlc[i], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16,\n\n                     ff_vc1_4mv_block_pattern_bits[i], 1, 1,\n\n                     ff_vc1_4mv_block_pattern_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64,\n\n                     ff_vc1_cbpcy_p_bits[i], 1, 1,\n\n                     ff_vc1_cbpcy_p_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73,\n\n                     ff_vc1_mv_diff_bits[i], 1, 1,\n\n                     ff_vc1_mv_diff_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<8; i++)\n\n            init_vlc(&ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i],\n\n                     &vc1_ac_tables[i][0][1], 8, 4,\n\n                     &vc1_ac_tables[i][0][0], 8, 4, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64,\n\n                 &ff_msmp4_mb_i_table[0][1], 4, 2,\n\n                 &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC);\n\n    }\n\n\n\n    /* Other defaults */\n\n    v->pq = -1;\n\n    v->mvrange = 0; /* 7.1.1.18, p80 */\n\n\n\n    return 0;\n\n}\n", "idx": 5138, "substitutes": {"v": ["nv", "vd", "vid", "s", "value", "V", "vt", "x", "b", "m", "uv", "l", "f", "conv", "ve", "d", "q", "tv", "u", "vs", "e", "w", "k", "t", "n", "p", "h", "vp", "sv", "iv", "c", "vl", "g", "lv", "vv", "vc"], "i": ["gi", "r", "name", "isi", "o", "ei", "ti", "id", "I", "chi", "di", "s", "ci", "ki", "ji", "ni", "b", "xi", "si", "ani", "x", "slice", "ri", "io", "bi", "info", "m", "qi", "ix", "key", "gu", "num", "l", "yi", "pi", "f", "phi", "d", "j", "ii", "iu", "it", "ai", "cli", "uli", "init", "u", "part", "e", "uri", "field", "multi", "mi", "ski", "ini", "ie", "p", "eni", "sup", "oi", "c", "ip", "g", "y", "api", "hei", "li", "fi", "index", "zi", "idi", "ui"]}}
{"project": "FFmpeg", "commit_id": "1a3ed056c523b4670e192301be15dbc521ec8353", "target": 0, "func": "static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)\n\n{\n\n    HEVCContext *s  = avctxt->priv_data;\n\n    int ctb_size    = 1 << s->sps->log2_ctb_size;\n\n    int more_data   = 1;\n\n    int x_ctb       = 0;\n\n    int y_ctb       = 0;\n\n    int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];\n\n\n\n    if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Impossible initial tile.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->sh.dependent_slice_segment_flag) {\n\n        int prev_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts - 1];\n\n        if (s->tab_slice_address[prev_rs] == -1) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Previous slice segment missing\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    while (more_data && ctb_addr_ts < s->sps->ctb_size) {\n\n        int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts];\n\n\n\n        x_ctb = (ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        y_ctb = (ctb_addr_rs / ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);\n\n\n\n        ff_hevc_cabac_init(s, ctb_addr_ts);\n\n\n\n        hls_sao_param(s, x_ctb >> s->sps->log2_ctb_size, y_ctb >> s->sps->log2_ctb_size);\n\n\n\n        s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset;\n\n        s->deblock[ctb_addr_rs].tc_offset   = s->sh.tc_offset;\n\n        s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;\n\n\n\n        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);\n\n        if (more_data < 0) {\n\n            s->tab_slice_address[ctb_addr_rs] = -1;\n\n            return more_data;\n\n        }\n\n\n\n\n\n        ctb_addr_ts++;\n\n        ff_hevc_save_states(s, ctb_addr_ts);\n\n        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);\n\n    }\n\n\n\n    if (x_ctb + ctb_size >= s->sps->width &&\n\n        y_ctb + ctb_size >= s->sps->height)\n\n        ff_hevc_hls_filter(s, x_ctb, y_ctb);\n\n\n\n    return ctb_addr_ts;\n\n}\n", "idx": 14442, "substitutes": {"avctxt": ["AVnttxt", " avctkt", "avsecext", "avctXT", "avftxt", "avCTkt", "avntert", "avptxt", "avctert", "AVntxt", "avcxt", " avftXT", "AVctext", "avptkt", " avcttxt", "AVcttxt", "avcttxt", "avsecert", " avftxt", "avCTXT", "avcext", "AVctert", "avpttxt", "AVctxt", "AVntert", "avCTxt", "avCTtxt", "AVntext", " avfttxt", " avftkt", "avcert", "avfttxt", "avnttxt", "avftkt", " avctXT", "avsectxt", "avsecxt", "avctext", "avntext", "avftXT", "avctkt", "avntxt", "avptXT"], "isFilterThread": ["isCallThread", "isFilterLock", "isCallLock", "asMainthread", "asMainLock", "isFilterPool", "asFilterLock", "asMainThread", "asFilterPool", "isFilterthread", "isMainPool", "asMainPool", "isCatThread", "isMainLock", "isCatPool", "asFilterthread", "isCatthread", "isCallthread", "isMainthread", "isMainThread", "isCallPool", "isCatLock", "asFilterThread"], "s": ["i", "qs", "words", "js", "si", "server", "ps", "groups", "lines", "tests", "spec", "c", "is", "sc", "sv", "sl", "states", "ing", "aws", "south", "m", "self", "bis", "d", "t", "sync", "sg", "fs", "sym", "ches", "sup", "g", "cs", "es", "full", "session", "storage", "w", "an", "data", "sf", "b", "ns", "ops", "r", "ks", "secondary", "sys", "parts", "service", "details", "os", "sets", "opens", "o", "e", "sec", "site", "http", "sb", "f", "less", "services", "ls", "comments", "ctx", "ses", "as", "l", "a", "sites", "S", "settings", "uns", "sq", "conf", "ss", "request", "p", "se", "plugins", "k", "n", "gs", "xs", "stats", "ssl", "ds", "su", "ts", "us"], "ctb_addr_ts": ["ctb_dr_ns", "ctb_addr_ns", "ctb_vr_rs", "ctb_addr_ents", "ctb_addr2ts", "ctb_addrPcs", "ctb_ord_ps", "ctb_addr6tt", "ctb_dr_ats", "ctb_addrMrs", "ctb_addr6rs", "ctb_addr__ts", "ctb_addr2rs", "ctb_vr6ts", "ctb_addrJcs", "ctb_dr_Ts", "ctb_addr__TS", "ctb_dr_rs", "ctb_addr6ss", "ctb_addr__tt", "ctb_ord_ms", "ctb_addr_ms", "ctb_ord_ents", "ctb_addrPrs", "ctb_dr_tt", "ctb_addr_ps", "ctb_addr_ss", "ctb_addr35TS", "ctb_addrJms", "ctb_ord_fs", "ctb_addr2tt", "ctb_addrPms", "ctb_addr_tt", "ctb_dr_TS", "ctb_addrMts", "ctb_addr2TS", "ctb_vr6ss", "ctb_addr_fs", "ctb_addr35ents", "ctb_ord_cs", "ctb_addrJrs", "ctb_ord_rs", "ctb_addr_Ts", "ctb_addrJts", "ctb_dr_ts", "ctb_addr_cs", "ctb_vr_ss", "ctb_addr6ts", "ctb_addr35ts", "ctb_vr_ts", "ctb_addr_TS", "ctb_vr_tt", "ctb_addr_rs", "ctb_addrPts", "ctb_ord_ts", "ctb_addr_ats", "ctb_addrMns", "ctb_addr__rs", "ctb_vr6rs", "ctb_addr35ps", "ctb_addrMTS", "ctb_ord_TS", "ctb_vr6tt"]}}
{"project": "FFmpeg", "commit_id": "77d2ef13a8fa630e5081f14bde3fd20f84c90aec", "target": 1, "func": "static int matroska_decode_buffer(uint8_t** buf, int* buf_size,\n\n                                  MatroskaTrack *track)\n\n{\n\n    MatroskaTrackEncoding *encodings = track->encodings.elem;\n\n    uint8_t* data = *buf;\n\n    int isize = *buf_size;\n\n    uint8_t* pkt_data = NULL;\n\n    int pkt_size = isize;\n\n    int result = 0;\n\n    int olen;\n\n\n\n    if (pkt_size >= 10000000)\n\n        return -1;\n\n\n\n    switch (encodings[0].compression.algo) {\n\n    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n\n        return encodings[0].compression.settings.size;\n\n    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n\n        do {\n\n            olen = pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);\n\n            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);\n\n        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);\n\n        if (result)\n\n            goto failed;\n\n        pkt_size -= olen;\n\n        break;\n\n#if CONFIG_ZLIB\n\n    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n\n        z_stream zstream = {0};\n\n        if (inflateInit(&zstream) != Z_OK)\n\n            return -1;\n\n        zstream.next_in = data;\n\n        zstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            zstream.avail_out = pkt_size - zstream.total_out;\n\n            zstream.next_out = pkt_data + zstream.total_out;\n\n            result = inflate(&zstream, Z_NO_FLUSH);\n\n        } while (result==Z_OK && pkt_size<10000000);\n\n        pkt_size = zstream.total_out;\n\n        inflateEnd(&zstream);\n\n        if (result != Z_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n#if CONFIG_BZLIB\n\n    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n\n        bz_stream bzstream = {0};\n\n        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n\n            return -1;\n\n        bzstream.next_in = data;\n\n        bzstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n\n            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n\n            result = BZ2_bzDecompress(&bzstream);\n\n        } while (result==BZ_OK && pkt_size<10000000);\n\n        pkt_size = bzstream.total_out_lo32;\n\n        BZ2_bzDecompressEnd(&bzstream);\n\n        if (result != BZ_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    *buf = pkt_data;\n\n    *buf_size = pkt_size;\n\n    return 0;\n\n failed:\n\n    av_free(pkt_data);\n\n    return -1;\n\n}\n", "idx": 5277, "substitutes": {"buf": ["padding", "buff", "vec", "feed", "Buff", "rb", "tmp", "config", "b", "raf", "rc", "queue", "map", "fb", "uf", "byte", "buffer", "len", "mount", "bag", "Buffer", "port", "cmd", "pad", "bc", "cb", "seq", "array", "input", "batch", "alloc", "br", "board", "addr", "src"], "buf_size": ["file_size", "block_size", "file_range", "block_address", "block_width", "bufksize", "buf_value", "file_Size", "buf_range", "bufkwidth", "buf_Size", "buf_address", "block_value", "file_ize", "bufkaddress", "buf_width", "buf_ize", "bufkvalue"], "track": ["dr", "row", " tracks", "seek", "tracking", "train", "tr", "stream", "record", "tag", "package", "ru", "project", "order", "ack", "tab", "roll", "match", "round", "ACK", "Track", "port", "path", "car", "step", "tracks", "type", "transform", "board", "rack", "trip", "test", "form", "r", "trace", "add"], "encodings": ["ecoding", "encodions", "encodingands", "encodedings", "eccodands", "ecodings", "encodeides", "eccodings", "eccodations", "encodedands", "encording", "ecodides", "encoders", "encodeing", "encodors", "encodeers", "enccodors", "eccoders", "eccodors", "encodedrings", "ecodations", "encodedations", "encordors", "enccodands", "eccoding", "enccodides", "encodinging", "enccodrings", "enccodings", "ecodrings", "enccodions", "encordrings", "encodides", "encodeions", "encodrings", "eccodions", "ecodions", "encodedides", "enccoding", "encodingings", "encodeings", "enccoders", "eccodides", "encodeations", "encoding", "encodeding", "encodingions", "ecoders", "ecodors", "encodedions", "encodands", "ecodands", "enccodations", "encodations", "encodedors", "eccodrings", "encordings", "encodeders"], "data": ["base", "feed", "extra", "la", "parent", "dat", "dd", "config", "database", "body", "window", "valid", "package", "results", "media", "DATA", " DATA", "buffer", "len", "all", "ata", "zip", "raw", "three", "Data", "bytes", "pad", "multi", "response", "str", "empty", "devices", "result", "after", "input", "temp", "batch", "xxx", "zero", "pos", "none", "start", "memory", "new", "api", "board", "sample", "cache", "next"], "pkt_data": ["pkt2size", "pwk_data", "pkt_off", "pwk_body", "pkt2break", "packet_value", "packet_break", "pkt_align", "pwk_size", "pkt_cache", "pkt_dat", "packet_off", "pkt_batch", "pkt_done", "packet_dat", "pwk_cache", "pkg_batch", "packet_done", "pkt_break", "pkt_size", "pkt_body", "packet_bin", "pkg_size", "pkt2off", "packet_body", "pkt2data", "packet_start", "packet_data", "packet_size", "pkt_start", "pkg_data", "pkt_value", "packet_align", "pkt_bin"], "olen": ["serv", "ien", "kn", "less", "nn", "osen", "loss", "oln", "skip", "ellen", "non", "normal", "unit", "legal", "ole", "ele", "valid", "regon", "fin", "lov", "linger", "lim", "foo", "mn", "lins", " len", "sle", "sol", "oven", "numbered", "sid", "liv", "lif", "eno", "len", "olo", "oren", "lo", "what", "little", "won", "broken", "nil", "oin", "temp", " unused", "eni", "lvl", "where", "ln", "oo", "ken", "lost", " leftover", "eden", "uno", "le", "slot"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 23250, "substitutes": {"ysrc": ["sysrt", "ssrc", "iessrc", "xsync", "ysync", "ysRC", "iesync", "xsrt", "sRC", "sysync", "ysroc", "sysroc", "iesrt", "sroc", "inssrc", "insroc", "src", "iesrc", "yssrc", "insrc", "syssrc", "xssrc", "sysrc", "xsrc", "sysRC", "insRC", "ysrt"], "usrc": ["usource", "ausdc", " ussrc", "uri", "ausource", "uource", "usri", "usdc", " usri", " usource", "aussrc", "ausrc", " usdc", "udc", "urc", "ussrc", "ausri"], "vsrc": ["usst", "wsource", "svloc", "usource", "svsl", "wsl", "fsl", "vsource", "wsrc", "vloc", "vsl", "vst", "vssrc", "vsst", "ussource", "vssource", "wloc", "fsrc", "svsrc", "fsource", "urc", "ussrc", "vrc", "svsource", "ust", "floc"], "dst": ["DST", "Dst", "sst", "ssrc", "idste", "bdste", "bdsts", "dST", "dsrc", "Ddest", "idst", "sdsrc", "Dsrc", "sdST", "dbe", "idbe", "ddest", "dsts", " dbe", "bdst", "sdst", "sST", " dste", "dste", " dsts", "bdbe", "sddest", "idsts", "sdest"], "height": ["shape", "high", "square", "input", "style", "ty", "pad", "img", "Height", "dist", "rank", " heights", "y", "size", "hd", "depth", "crop", "thin", "density", "distance", "images", "dim", "deep", "window", "direction", "pull", "stroke", "length", "above", "alpha", "resolution", "gap", "h", "image", "bottom", "wrap", "max", "padding"], "lumStride": ["lumStrro", "lumStrip", "lumbStrro", "lumStro", "lumbstride", "lumbstrite", "lumScro", "lumSTride", "lumStrrip", "lumScride", "lumScrite", "lumbstro", "lumSTro", "lumstro", "lumbstrip", "lumbStri", "lumbStrride", "lumSTrip", "lumbStrrip", "lumSTri", "lumbStrri", "lumbStrite", "lumStrri", "lumStrite", "lumstrip", "lumstri", "lumScrip", "lumStri", "lumbStro", "lumbStrip", "lumbStride", "lumstride", "lumStrride", "lumstrite", "lumSTrite"], "chromStride": ["chromStrite", "romstride", "homStri", "chromsterve", "chromstrite", "chromSTerve", "chromSTride", "chromEstride", "romStrite", "homStrric", "chromStrri", "chromStrride", "chromSTrip", "chromEstri", "chromUride", "chromSTri", "homStrip", "chromSTric", "romsterve", "chromSTro", "romstrite", "chromUerve", "chromStro", "romStro", "chromStrrip", "chromSterve", "chromStrric", "homStric", "chromEstric", "chromUro", "chromstride", "homStrri", "chromStri", "homStride", "homStrrip", "chromEstrip", "homStrride", "chromstro", "romstro", "romStride", "chromSTrite", "chromStrip", "chromUrite", "romSterve", "chromStric"], "dstStride": ["dspStend", "dspStride", "dstSTrip", "dstSTride", "dstStro", "dstRestro", "dscStro", "dscStide", "dspTue", "dstSTend", "dstStrrip", "dspTend", "dscStrrip", "dstStrride", "dstRestide", "dspTride", "dscStrride", "dstClride", "dstClend", "dstTrip", "dstStide", "dstClue", "dstRestride", "dstSTue", "dstRestrip", "dspStrip", "dstTride", "dstClrip", "dspTrip", "dstTend", "dspStue", "dstStend", "dstStrip", "dstStue", "dstTue", "dstStrro", "dscStrip", "dscStride", "dscStrro"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)\n\n{\n\n    VLANClientState *vc;\n\n\n\n    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {\n\n        if (vc != sender && !vc->link_down) {\n\n            vc->receive(vc->opaque, buf, size);\n\n        }\n\n    }\n\n}\n", "idx": 26904, "substitutes": {"vc": ["dc", "ll", "c", "cv", "vs", "cci", "xc", "ec", "api", "vec", "vr", "ant", "nv", "vt", "ct", "bc", "cy", "util", "vv", "nec", "wx", "fc", "cs", "iw", "ic", "vid", "rl", "loc", "wl", "voc", "cli", "wd", "cc", "ku", "ci", "client", "cf", "cn", "rc", "ou", "ctx", "ga", "vm", "cp", "lc", "serv", "ls", "rt", "lv", "service", "vd", "cu", "conn", "fp", "VC", "nc", "sv", "ce", "pc", "dn"]}}
{"project": "qemu", "commit_id": "6240d6467077a12c24878bab645d8e2983e4975a", "target": 0, "func": "static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,\n\n                                    uint32_t val)\n\n{\n\n    SLAVIO_TIMERState *s = opaque;\n\n    uint32_t saddr;\n\n    int reload = 0;\n\n\n\n    DPRINTF(\"write \" TARGET_FMT_plx \" %08x\\n\", addr, val);\n\n    saddr = (addr & TIMER_MAXADDR) >> 2;\n\n    switch (saddr) {\n\n    case TIMER_LIMIT:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter MSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else {\n\n            // set limit, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = val & TIMER_MAX_COUNT32;\n\n            if (!s->limit)\n\n                s->limit = TIMER_MAX_COUNT32;\n\n            ptimer_set_limit(s->timer, s->limit >> 9, 1);\n\n        }\n\n        break;\n\n    case TIMER_COUNTER:\n\n        if (slavio_timer_is_user(s)) {\n\n            // set user counter LSW, reset counter\n\n            qemu_irq_lower(s->irq);\n\n            s->limit = TIMER_MAX_COUNT64;\n\n            DPRINTF(\"processor %d user timer reset\\n\", s->slave_index);\n\n            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);\n\n        } else\n\n            DPRINTF(\"not user timer\\n\");\n\n        break;\n\n    case TIMER_COUNTER_NORST:\n\n        // set limit without resetting counter\n\n        s->limit = val & TIMER_MAX_COUNT32;\n\n        if (!s->limit)\n\n            s->limit = TIMER_MAX_COUNT32;\n\n        ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload);\n\n        break;\n\n    case TIMER_STATUS:\n\n        if (slavio_timer_is_user(s)) {\n\n            // start/stop user counter\n\n            if ((val & 1) && !s->running) {\n\n                DPRINTF(\"processor %d user timer started\\n\", s->slave_index);\n\n                ptimer_run(s->timer, 0);\n\n                s->running = 1;\n\n            } else if (!(val & 1) && s->running) {\n\n                DPRINTF(\"processor %d user timer stopped\\n\", s->slave_index);\n\n                ptimer_stop(s->timer);\n\n                s->running = 0;\n\n            }\n\n        }\n\n        break;\n\n    case TIMER_MODE:\n\n        if (s->master == NULL) {\n\n            unsigned int i;\n\n\n\n            for (i = 0; i < s->num_slaves; i++) {\n\n                if (val & (1 << i)) {\n\n                    qemu_irq_lower(s->slave[i]->irq);\n\n                    s->slave[i]->limit = -1ULL;\n\n                }\n\n                if ((val & (1 << i)) != (s->slave_mode & (1 << i))) {\n\n                    ptimer_stop(s->slave[i]->timer);\n\n                    ptimer_set_limit(s->slave[i]->timer,\n\n                                     LIMIT_TO_PERIODS(s->slave[i]->limit), 1);\n\n                    DPRINTF(\"processor %d timer changed\\n\",\n\n                            s->slave[i]->slave_index);\n\n                    ptimer_run(s->slave[i]->timer, 0);\n\n                }\n\n            }\n\n            s->slave_mode = val & ((1 << s->num_slaves) - 1);\n\n        } else\n\n            DPRINTF(\"not system timer\\n\");\n\n        break;\n\n    default:\n\n        DPRINTF(\"invalid write address \" TARGET_FMT_plx \"\\n\", addr);\n\n        break;\n\n    }\n\n}\n", "idx": 1167, "substitutes": {"opaque": ["opacity", " opque", "opaques", "iopque", "copacs", "opctx", "OPctx", "OPacs", "iopaque", "iopacs", "iopctx", " opacity", "iopaques", "opacs", "copctx", "OPa", "iopacity", "OPaque", "copa", "oacity", "iopa", " opaques", "oque", "copaque", "opa", "oaques", "opque", "oaque"], "addr": ["oa", "dr", "ld", "src", "fd", "offset", "ss", "mt", "dd", "conn", "host", "sid", "data", "url", "r", "loc", "ad", "align", "alt", "sl", "ord", "adr", "pos", "mac", "code", "str", "pointer", "xp", "address", "ip", "x", "afi", "ptr", "hop", "len", "cap", "attr", "ar", "eth", "amp", "pc", "asm", "seq", "tz", "rx", "sta", "vr", "rt", "ast", "ace"], "val": ["ret", "base", "test", "arg", "vol", "delay", "ol", "ctx", "local", "cal", "def", "split", "elt", "vt", "byte", "dim", "cl", "vals", "data", "pol", "Val", "slot", "alt", "fl", "sl", "grad", "arr", "num", "bl", "nil", "util", "live", "aval", "sol", "index", "sel", "x", "ind", "len", "eval", "ref", "pal", "exec", "value", "el", "min", "v", "seq", "valid", "al", "lit", "reg", "VAL", "count", "pt", "all", "mem"], "s": ["sg", "js", "sa", "qs", "n", "sites", "sl", "g", "ses", "ls", "er", "sie", "self", "f", "sys", "u", "en", "your", "an", "fs", "parts", "spec", "ts", "sb", "ips", "aws", "y", "uns", "xs", "request", "sets", "p", "e", "conf", "v", "less", "su", "site", "S", "t", "session", "os", "its", "hs", "sym", "ssl", "cs", "ss", "a", "rs", "new", "r", "is", "m", "settings", "ds", "ps", "gs", "hm", "ns", "h", "c", "es", "south", "o", "si", "server", "service", "http", "ops", "d", "ms", "sync", "status", "l", "services", "w", "b", "full", "states"], "saddr": ["sconn", "sbcoord", "nsaddr", "sbadd", " sproxy", "Sconn", "sval", " scoord", "sincoord", "sbaddr", "paddress", "Shop", "sadd", "daddress", "sbproxy", "Saddress", " svar", " saddress", "sinadd", "svar", "shop", "dconn", "scoord", "paddr", "sinaddr", "saddress", "nsval", "pval", " sval", " sconn", "Saddr", "sinproxy", "pvar", "sproxy", "nsvar", "daddr", " shop", "nsaddress", "dhop", " sadd"]}}
{"project": "qemu", "commit_id": "df8002103c3e262dc40d7b5e0eb2171ba28b1d63", "target": 0, "func": "void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    VGACommonState *s = opaque;\n\n    int index;\n\n\n\n    /* check port range access depending on color/monochrome mode */\n\n    if (vga_ioport_invalid(s, addr)) {\n\n        return;\n\n    }\n\n#ifdef DEBUG_VGA\n\n    printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val);\n\n#endif\n\n\n\n    switch(addr) {\n\n    case VGA_ATT_W:\n\n        if (s->ar_flip_flop == 0) {\n\n            val &= 0x3f;\n\n            s->ar_index = val;\n\n        } else {\n\n            index = s->ar_index & 0x1f;\n\n            switch(index) {\n\n            case VGA_ATC_PALETTE0 ... VGA_ATC_PALETTEF:\n\n                s->ar[index] = val & 0x3f;\n\n                break;\n\n            case VGA_ATC_MODE:\n\n                s->ar[index] = val & ~0x10;\n\n                break;\n\n            case VGA_ATC_OVERSCAN:\n\n                s->ar[index] = val;\n\n                break;\n\n            case VGA_ATC_PLANE_ENABLE:\n\n                s->ar[index] = val & ~0xc0;\n\n                break;\n\n            case VGA_ATC_PEL:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            case VGA_ATC_COLOR_PAGE:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        s->ar_flip_flop ^= 1;\n\n        break;\n\n    case VGA_MIS_W:\n\n        s->msr = val & ~0x10;\n\n        s->update_retrace_info(s);\n\n        break;\n\n    case VGA_SEQ_I:\n\n        s->sr_index = val & 7;\n\n        break;\n\n    case VGA_SEQ_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write SR%x = 0x%02x\\n\", s->sr_index, val);\n\n#endif\n\n        s->sr[s->sr_index] = val & sr_mask[s->sr_index];\n\n        if (s->sr_index == VGA_SEQ_CLOCK_MODE) {\n\n            s->update_retrace_info(s);\n\n        }\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_PEL_IR:\n\n        s->dac_read_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 3;\n\n        break;\n\n    case VGA_PEL_IW:\n\n        s->dac_write_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 0;\n\n        break;\n\n    case VGA_PEL_D:\n\n        s->dac_cache[s->dac_sub_index] = val;\n\n        if (++s->dac_sub_index == 3) {\n\n            memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);\n\n            s->dac_sub_index = 0;\n\n            s->dac_write_index++;\n\n        }\n\n        break;\n\n    case VGA_GFX_I:\n\n        s->gr_index = val & 0x0f;\n\n        break;\n\n    case VGA_GFX_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write GR%x = 0x%02x\\n\", s->gr_index, val);\n\n#endif\n\n        s->gr[s->gr_index] = val & gr_mask[s->gr_index];\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_CRT_IM:\n\n    case VGA_CRT_IC:\n\n        s->cr_index = val;\n\n        break;\n\n    case VGA_CRT_DM:\n\n    case VGA_CRT_DC:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write CR%x = 0x%02x\\n\", s->cr_index, val);\n\n#endif\n\n        /* handle CR0-7 protection */\n\n        if (s->cr[VGA_CRTC_V_SYNC_END] & VGA_CR11_LOCK_CR0_CR7) {\n\n            if (s->cr_index <= VGA_CRTC_OVERFLOW) {\n\n                /* can always write bit 4 of CR7 */\n\n                if (s->cr_index == VGA_CRTC_OVERFLOW) {\n\n                    s->cr[VGA_CRTC_OVERFLOW] =\n\n                        (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) | (val & 0x10);\n\n                }\n\n                return;\n\n            } else if ((vga_cga_hacks & VGA_CGA_HACK_FONT_HEIGHT) &&\n\n                       !(s->sr[VGA_SEQ_CLOCK_MODE] & VGA_SR01_CHAR_CLK_8DOTS)) {\n\n                /* extra CGA compatibility hacks (not in standard VGA) */\n\n                if (s->cr_index == VGA_CRTC_MAX_SCAN &&\n\n                    val == 7 &&\n\n                    (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    return;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_START &&\n\n                           val == 6 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xd;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_END &&\n\n                           val == 7 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xe;\n\n                }\n\n            }\n\n        }\n\n        s->cr[s->cr_index] = val;\n\n\n\n        switch(s->cr_index) {\n\n        case VGA_CRTC_H_TOTAL:\n\n        case VGA_CRTC_H_SYNC_START:\n\n        case VGA_CRTC_H_SYNC_END:\n\n        case VGA_CRTC_V_TOTAL:\n\n        case VGA_CRTC_OVERFLOW:\n\n        case VGA_CRTC_V_SYNC_END:\n\n        case VGA_CRTC_MODE:\n\n            s->update_retrace_info(s);\n\n            break;\n\n        }\n\n        break;\n\n    case VGA_IS1_RM:\n\n    case VGA_IS1_RC:\n\n        s->fcr = val & 0x10;\n\n        break;\n\n    }\n\n}\n", "idx": 19290, "substitutes": {"opaque": ["operacity", "oponymous", "Opaque", "opedoc", "cataque", " opacs", " opoc", " opacity", "operatile", "opedacs", "opatile", "opacity", "cataques", "catacity", "operaque", "opedonymous", "Opoc", "opedaque", " opatile", "opacs", " oponymous", "Opacs", "opoc", "catatile", "Oponymous", "opaques", "operaques", " opaques"], "addr": ["part", "rr", "offset", "db", "code", "mode", "x", "ref", "eth", "rc", "r", "ord", "align", "hop", "ast", "src", "node", "loc", "ext", "ptr", "pos", "slice", "pointer", "ip", "host", "ack", "slot", "layer", "alias", "oid", "socket", "prefix", "ad", "xxx", "dr", "fd", "asm", "buf", "device", "seq", "cmd", "kt", "url", "address", "pad", "arch", "adr", "route", "sid", "interface", "alloc", "ace", "amd", "port", "server", "mac", "attr", "amp"], "val": ["Val", "stat", "al", "x", "ref", "bit", "pl", "var", "pos", "exec", "sol", "nil", "tx", "elt", "lib", "p", "vt", "aval", "valid", "pt", "len", "values", "Value", "cal", "vals", "ld", "pol", "vert", "arg", "arr", "vol", "slot", "fl", "ol", "rot", "key", "xxx", "bl", "v", "update", "item", "ret", "base", "alt", "lit", "loc", "sel", "ind", "mem", "byte", "vl", "VAL", "serv", "buf", "b", "live", "py", "value", "data", "func", "all", "buffer", "sl", "slice", "dim", "def", "bo", "fail", "unit", "col", "eval", "local", "el"], "s": ["ns", "set", "spec", "full", "settings", "service", "ss", "cs", "d", "new", "qs", "sym", "p", "ks", "h", "us", "sets", "comments", "m", "ts", "sg", "rs", "aws", "self", "o", "sk", "su", "tests", "si", "S", "a", "hs", "an", "ds", "status", "uns", "f", "r", "sb", "as", "l", "ins", "w", "sync", "c", "ps", "secondary", "b", "sys", "your", "es", "state", "states", "sq", "sf", "session", "t", "request", "conf", "stats", "services", "n", "g", "i", "sl", "ls", "fs", "xs", "is", "sites", "args", "site", "e", "ssl", "ses", "client", "js", "http", "gs", "its", "os", "server", "se", "south", "y", "u"], "index": ["point", "offset", "x", "element", "full", "inc", "align", "num", "pos", "Index", "run", "label", "new", "path", "length", "config", "prefix", "id", "output", "loop", "end", "valid", "column", "ion", "len", "input", "search", "sort", "count", "pointer", "object", "slot", "size", "xxx", "key", "update", "fff", "condition", "weight", "find", "list", "instance", "f", "image", "match", "loc", "node", "ind", "byte", "date", "host", "sync", "position", "address", "edge", "value", "connect", "success", "version", "data", "i", "module", "ctx", "slice", "dim", "active", "member", "site", "insert", "unit", "error", "level", "number", "body", "section"]}}
{"project": "FFmpeg", "commit_id": "964f07f68e1cc4e2d585615e2b1a1fade269afb0", "target": 1, "func": "static av_cold int hevc_init_context(AVCodecContext *avctx)\n{\n    HEVCContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!s->HEVClc)\n        goto fail;\n    s->HEVClcList[0] = s->HEVClc;\n    s->sList[0] = s;\n    s->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!s->cabac_state)\n        goto fail;\n    s->output_frame = av_frame_alloc();\n    if (!s->output_frame)\n        goto fail;\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        s->DPB[i].frame = av_frame_alloc();\n        if (!s->DPB[i].frame)\n            goto fail;\n        s->DPB[i].tf.f = s->DPB[i].frame;\n    }\n    s->max_ra = INT_MAX;\n    s->md5_ctx = av_md5_alloc();\n    if (!s->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&s->bdsp);\n    s->context_initialized = 1;\n    s->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(avctx);\n    return AVERROR(ENOMEM);\n}", "idx": 262, "substitutes": {"avctx": ["afcb", "AVctx", "avalbc", "awpkg", " avcb", " avci", "akcas", "afcmp", "afctx", "afcontext", "afcas", "avtx", "afpkg", "navctx", "afbc", "akcontext", " avcmp", "aftx", "akbc", " avcontext", " avtx", "avpkg", "avalcas", "awcontext", "AVpkg", "AVcu", " avcu", "navci", "afcu", "navcontext", "avcb", "avalcontext", "afci", "avcontext", "navcb", "avci", "awcmp", "avbc", "avcmp", "avcu", "akctx", "awctx", "AVcmp", "AVcontext", "AVtx", "avcas", "avalctx"], "s": ["sg", "js", "this", "qs", "n", "sites", "g", "ls", "ses", "args", "vs", "self", "us", "f", "sys", "u", "your", "se", "fs", "spec", "ts", "sb", "aws", "ims", "uns", "xs", "sets", "p", "e", "conf", "as", "v", "su", "S", "t", "session", "os", "ks", "its", "in", "sym", "ssl", "cs", "ctx", "ss", "a", "rs", "new", "data", "r", "is", "ins", "m", "settings", "ds", "ps", "gs", "native", "ns", "c", "es", "south", "o", "si", "service", "ops", "strings", "d", "ms", "sync", "l", "services", "w", "features", "sq", "stats", "b", "states"], "i": ["yi", "li", "gi", "abi", "key", "a", "interface", "ni", "ii", "zi", "chi", "ui", "pi", "oi", "d", "I", "di", "id", "mi", "it", "iu", "j", "y", "eni", "ri", "anti", "m", "info", "ti", "multi", "ini", "ai", "ie", "ip", "l", "c", "p", "hi", "bi", "adi", "e", "x", "f", "u", "idi", "ori", "range", "o", "v", "iv", "b", "qi", "ix", "req", "module", "uri", "line", "ci", "io", "mu", "part", "init", "fi", "si", "xi"]}}
{"project": "qemu", "commit_id": "2e2aa31674444b61e79536a90d63a90572e695c8", "target": 0, "func": "static void mptsas_scsi_init(PCIDevice *dev, Error **errp)\n\n{\n\n    DeviceState *d = DEVICE(dev);\n\n    MPTSASState *s = MPT_SAS(dev);\n\n    Error *err = NULL;\n\n    int ret;\n\n\n\n    dev->config[PCI_LATENCY_TIMER] = 0;\n\n    dev->config[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    if (s->msi != ON_OFF_AUTO_OFF) {\n\n        ret = msi_init(dev, 0, 1, true, false, &err);\n\n        /* Any error other than -ENOTSUP(board's MSI support is broken)\n\n         * is a programming error */\n\n        assert(!ret || ret == -ENOTSUP);\n\n        if (ret && s->msi == ON_OFF_AUTO_ON) {\n\n            /* Can't satisfy user's explicit msi=on request, fail */\n\n            error_append_hint(&err, \"You have to use msi=auto (default) or \"\n\n                    \"msi=off with this machine type.\\n\");\n\n            error_propagate(errp, err);\n\n            s->msi_in_use = false;\n\n            return;\n\n        } else if (ret) {\n\n            /* With msi=auto, we fall back to MSI off silently */\n\n            error_free(err);\n\n            s->msi_in_use = false;\n\n        } else {\n\n            s->msi_in_use = true;\n\n        }\n\n    }\n\n\n\n    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,\n\n                          \"mptsas-mmio\", 0x4000);\n\n    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,\n\n                          \"mptsas-io\", 256);\n\n    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,\n\n                          \"mptsas-diag\", 0x10000);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);\n\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);\n\n    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io);\n\n\n\n    if (!s->sas_addr) {\n\n        s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) |\n\n                       IEEE_COMPANY_LOCALLY_ASSIGNED) << 36;\n\n        s->sas_addr |= (pci_bus_num(dev->bus) << 16);\n\n        s->sas_addr |= (PCI_SLOT(dev->devfn) << 8);\n\n        s->sas_addr |= PCI_FUNC(dev->devfn);\n\n    }\n\n    s->max_devices = MPTSAS_NUM_PORTS;\n\n\n\n    s->request_bh = qemu_bh_new(mptsas_fetch_requests, s);\n\n\n\n    QTAILQ_INIT(&s->pending);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, errp);\n\n    }\n\n}\n", "idx": 9038, "substitutes": {"dev": ["diff", "conf", "gu", "devices", "dim", "gd", "di", "cam", "valid", "DC", "debug", "ds", "img", "dom", "g", "comment", "prof", "Dev", "w", "info", "conn", "def", "die", "prom", "dem", "development", "ver", "de", "var", "data", "ad", "config", "p", "serv", "block", "pro", "driver", "reg", "bug", "rad", "serial", "hw", "f", "ev", "device", "vol", "v", "google", "home", "md", "req", "loader", "mod", "user", "ga", "dd", "dc", "error", "spec", "dm", "grad", "self", "od", "engine", "ch", "DEV"], "errp": ["erf", "erp", "rfp", "erb", " errP", "errorf", "rr", "rp", "errorp", "errorb", "errP", " errb", "errf", "erP", " errf", " errfp", "erfp", "errb", " errr", "rP", "errr", "errfp", "errorr"], "d": ["gd", "dh", "ds", "g", " dd", "w", "m", "dt", "t", "b", "i", "c", "ad", "data", "p", "cd", "e", "driver", "pd", "f", "db", "v", "dd", "dc", "sd", "dm", "Ds", "D"], "s": ["l", "sp", "session", "is", "m", "http", "t", "x", "gs", "parts", "sk", "device", "v", "ns", "details", "com", "spec", "self", "params", "settings", "sg", "ds", "si", "your", "sf", "b", "i", "serv", "c", "addr", "e", "app", "se", "args", "sq", "us", "f", "sym", "sets", "es", "r", "this", "comments", "ps", "su", "fs", "site", "ss", "secure", "sv", "g", "stats", "ls", "status", "os", "cs", "o", "sync", "south", "sl", "native", "sb", "sys", "side", "ssl", "conf", "ts", "service", "p", "server", "tests", "rs", "js", "an", "aws", "S", "services", "sd", "less", "options", "ses", "y"], "err": ["cr", "acer", "conf", "ler", "arr", " er", "str", "arm", "ry", "g", "die", "fr", "mr", "rr", "kr", "gr", "ver", "irm", "p", "ref", "Error", "e", "iter", "ir", "bug", "rs", "lr", "er", "dr", "res", "msg", "ind", "ner", "ar", "r", "req", "error", " error", "re", "sys", "der", "eor", "result", "rev", "Er", "sr", "resp", "br", "rh", "fi"], "ret": ["valid", "flag", "len", "val", "ry", "alt", "fail", "_", "nt", "Ret", "prot", "t", "x", " Ret", "num", "ver", "pat", "red", "reply", "ref", "lit", "reg", "rets", "f", "ut", "j", "code", "rt", "res", "al", "det", "rc", " arg", "sil", "att", "r", "ben", "en", "part", "art", "error", "re", "cat", "et", "RET", " RET", "result", "rev", "match", "ft", "mt", "success"]}}
{"project": "FFmpeg", "commit_id": "b46a77f19ddc4b2b5fa3187835ceb602a5244e24", "target": 0, "func": "int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,\n\n                         int level)\n\n{\n\n    VDPAUHWContext *hwctx = avctx->hwaccel_context;\n\n    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;\n\n    VdpVideoSurfaceQueryCapabilities *surface_query_caps;\n\n    VdpDecoderQueryCapabilities *decoder_query_caps;\n\n    VdpDecoderCreate *create;\n\n    void *func;\n\n    VdpStatus status;\n\n    VdpBool supported;\n\n    uint32_t max_level, max_mb, max_width, max_height;\n\n    VdpChromaType type;\n\n    uint32_t width;\n\n    uint32_t height;\n\n\n\n    vdctx->width            = UINT32_MAX;\n\n    vdctx->height           = UINT32_MAX;\n\n\n\n    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))\n\n        return AVERROR(ENOSYS);\n\n\n\n    if (hwctx) {\n\n        hwctx->reset            = 0;\n\n\n\n        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {\n\n            vdctx->decoder = hwctx->context.decoder;\n\n            vdctx->render  = hwctx->context.render;\n\n            vdctx->device  = VDP_INVALID_HANDLE;\n\n            return 0; /* Decoder created by user */\n\n        }\n\n\n\n        vdctx->device           = hwctx->device;\n\n        vdctx->get_proc_address = hwctx->get_proc_address;\n\n\n\n        if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n\n\n        if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&\n\n            type != VDP_CHROMA_TYPE_420)\n\n            return AVERROR(ENOSYS);\n\n    } else {\n\n        AVHWFramesContext *frames_ctx = NULL;\n\n        AVVDPAUDeviceContext *dev_ctx;\n\n\n\n        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit\n\n        // is called. This holds true as the user is not allowed to touch\n\n        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format\n\n        // itself also uninits before unreffing hw_frames_ctx).\n\n        if (avctx->hw_frames_ctx) {\n\n            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n        } else if (avctx->hw_device_ctx) {\n\n            int ret;\n\n\n\n            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);\n\n            if (!avctx->hw_frames_ctx)\n\n                return AVERROR(ENOMEM);\n\n\n\n            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n            frames_ctx->format    = AV_PIX_FMT_VDPAU;\n\n            frames_ctx->sw_format = avctx->sw_pix_fmt;\n\n            frames_ctx->width     = avctx->coded_width;\n\n            frames_ctx->height    = avctx->coded_height;\n\n\n\n            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);\n\n            if (ret < 0) {\n\n                av_buffer_unref(&avctx->hw_frames_ctx);\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        if (!frames_ctx) {\n\n            av_log(avctx, AV_LOG_ERROR, \"A hardware frames context is \"\n\n                   \"required for VDPAU decoding.\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        dev_ctx = frames_ctx->device_ctx->hwctx;\n\n\n\n        vdctx->device           = dev_ctx->device;\n\n        vdctx->get_proc_address = dev_ctx->get_proc_address;\n\n\n\n        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n    }\n\n\n\n    if (level < 0)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        surface_query_caps = func;\n\n\n\n    status = surface_query_caps(vdctx->device, type, &supported,\n\n                                &max_width, &max_height);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    if (supported != VDP_TRUE ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        decoder_query_caps = func;\n\n\n\n    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,\n\n                                &max_mb, &max_width, &max_height);\n\n#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE\n\n    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {\n\n        profile = VDP_DECODER_PROFILE_H264_MAIN;\n\n        status = decoder_query_caps(vdctx->device, profile, &supported,\n\n                                    &max_level, &max_mb,\n\n                                    &max_width, &max_height);\n\n    }\n\n#endif\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n\n\n    if (supported != VDP_TRUE || max_level < level ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        create = func;\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        vdctx->render = func;\n\n\n\n    status = create(vdctx->device, profile, width, height, avctx->refs,\n\n                    &vdctx->decoder);\n\n    if (status == VDP_STATUS_OK) {\n\n        vdctx->width  = avctx->coded_width;\n\n        vdctx->height = avctx->coded_height;\n\n    }\n\n\n\n    return vdpau_error(status);\n\n}\n", "idx": 4524, "substitutes": {"avctx": ["vcu", "navbc", "AVtx", "AVlc", "afcas", "hwcf", "verpkg", " avcas", "evcontext", "navcv", "abcmp", "navcontext", "afxc", "afctx", "avkb", "navctx", "ovbc", "hwcontext", "abcf", " avcontext", "evcmp", "afcv", "evcf", "afcmp", "avcmp", "navpkg", "vxc", "abcontext", "avcv", "navcu", "avxc", "AVcmp", "ovcontext", "avecontext", "afcf", "avlc", "AVcu", "svcv", "avecu", "avbc", "avekb", "aflc", "avcas", "AVcas", "evlc", "vercontext", "avcu", "navcmp", "AVcontext", "ovconn", "afkb", "navconn", "navcf", "hwcu", "vctx", "hwxc", "avcontext", "navlc", "afpkg", "svcf", "navtx", "avconn", "evctx", "abctx", "AVpkg", "avectx", "avepkg", "svcontext", "ovctx", "AVctx", "avcf", "aftx", "avtx", "afbc", "hwcmp", "verctx", "afconn", "avpkg", "afcontext", "verkb", " avlc", "avecmp", "afcu", "vcontext", "svctx"], "profile": ["plugin", "program", " plugin", " profiles", "prof", " Profile", "method", " proto", "TYPE", "val", "image", " preview", "details", "picture", "py", "def", "buffer", " profiling", "file", "port", " prog", "path", " mode", " prof", "pb", "summary", "Profile", "view"], "level": ["levels", "name", "layer", "clean", "local", "id", "count", "method", "parent", "scope", "vel", "stack", "key", "l", "Level", "child", "limit", "length", "loop", "code", "len", "col", "error", "depth", "path", "temp", "scale", "stage", "lvl", "where", "line", "global", "thread", "model", "wl", "VEL", "test", "index", "mode"], "hwctx": ["fwcmp", "hawconn", "hlcmp", "hwcf", "fwxc", "hwctrl", "hwtx", "iwctx", "hwlc", "rwctrl", "rwctx", "vcctx", "wxcmp", "fwconn", "fwkb", "hwcontext", "fwloc", "hwkb", "fwsci", "rhcf", "rwcf", "wxctx", "rhctx", "hawcontext", "fwcontext", "vdcn", "hwcn", "fwlc", "hlctx", "avcmp", "fwtx", "nvtx", "lvloc", "nvcmp", "rhcontext", "rwkb", "hlcontext", "hwloc", "iwconn", "rwloc", "rwsci", "wxcontext", "iwctrl", "rhloc", "iwcf", "iwloc", "fwcn", "rwlc", "hwconn", "rwcn", "hwxc", "avcontext", "fwcf", "lvcontext", "iwxc", "nvctx", "vdloc", "hawctx", "hwsci", "rwcontext", "vccontext", "hawcf", "iwcmp", "hawxc", "hlxc", "iwtx", "iwlc", "vdcontext", "lvcf", "avcf", "wxxc", "vcconn", "hawsci", "iwkb", "hwcmp", "vccf", "lvctx", "fwctx", "nvcontext", "fwctrl", "iwcontext", "rwcmp"], "vdctx": ["svkb", "xdctx", "hdcmp", "hdcf", "hdctx", "nvcf", "vdcrit", "vdkb", "vidcontext", "vvcrit", "vcctx", "vidcli", "nvxc", "hwcp", "hwcontext", "nvpkg", "dlsync", "vdxc", "hdxc", "hdpkg", "vddc", "hwcv", "vvctx", "nvtx", "nvcrit", "vdcli", "vidctx", "viddc", "dlctx", "nvcmp", "hdcontext", "vdcf", "nvctrl", "vdsync", "vvcli", "hdcrit", "dlctrl", "hdtx", "hdkb", "vdtx", "sdcp", "hdctrl", "nvdc", "vdconn", "hdsync", "vdctrl", "vdpkg", "vdcp", "xdpkg", "vctx", "hwxc", "vvcf", "sdctx", "hdconn", "vdcmp", "vvdc", "xdkb", "vvcontext", "nvconn", "nvkb", "nvctx", "dlcontext", "sdcv", "nvcli", "nvcv", "vccontext", "nvcp", "svcontext", "vdcontext", "sdcontext", "xdcontext", "vcconn", "svpkg", "hwcmp", "nvsync", "nvcontext", "vdcv", "svctx"], "surface_query_caps": ["surface_view_pieces", "surface_query_abilities", "surface_view_caps", "surface_query_pieces", "surface_view_abilities", "surface_view_cap", "surface_query_cap"], "decoder_query_caps": ["decoder_request_cap", "decoder_query_abilities", "decoder_query_cap", "decoder_query_cards", "decoder_request_abilities", "decoder_request_cards", "decoder_request_caps"], "create": ["enable", "creat", "copy", "open", "send", "save", "execute", "update", "sync", "invoke", "draw", "make", "media", "call", "Create", "code", "activate", "process", "source", "parse", "stage", "define", "creator", "write", "apply", "construct", "setup", "add"], "func": ["function", "pack", "unc", "execute", "nc", "sync", "sys", "module", "conv", "call", "pc", "ack", "cc", "code", "fn", "cmd", "Function", "cb", "exec", "callback", "process", "stage", "alloc", "fun", "apply", "src", "grad", "setup"], "status": ["function", "stat", "name", "complete", "method", "STAT", "sync", "unit", " Status", "state", "stats", "obj", "active", "reason", "str", "process", "source", "result", "output", "stage", "Status", "success", "current", "summary", "mode"], "supported": ["function", " compatibility", "flag", "platform", " platform", "compatible", "b", " library", "Supported", "support", "valid", "null", " required", "used", "enabled", "state", "mod", " allowed", " support", "lib", " enabled", " compatible", " connected", "prop", " capable", " supports", " native", " valid"], "max_level": ["maxalllayer", "max67block", "max_length", "max_layer", "max_block", " max_layer", " max_block", "maxalllevel", "maxalllength", "max67layer", "max67length", "maxallblock", " max_length", "max67level"], "max_mb": ["min_level", "min_mode", "min_lvl", "min_mb", "max_mode", "max_lvl"], "max_width": [" max_weight", "max_weight", " max_window", "max___width", "max_length", "max___window", "max_window", "max___length", "max___weight", " max_length"], "max_height": ["maxaldata", "maxalheight", " max_data", "maxalwidth", " max_h", "maxalh", "max_h", "max_data"], "type": ["function", "types", " Type", "name", "time", "position", "block", "id", "method", "parent", "shape", "value", "TYPE", "op", "object", "style", "slice", "format", "typ", "rel", "pe", " TYPE", "unit", "key", "resource", " typ", "version", "state", "call", "by", "number", "code", "kind", "error", "port", "t", "ype", "source", "p", "rule", "attribute", "class", "y", "link", "set", "Type", "view", "role"], "height": ["density", "Height", "build", "host", "padding", "id", "alpha", "shape", "device", "layout", "crop", "gap", "inches", "style", "x", "image", "draw", "window", "ty", "capacity", "weight", "length", "thin", "resolution", "definition", "deep", "depth", "w", "k", "volume", "history", "pad", "container", "quality", "input", "h", "direction", "hold", "strength", "memory", "ip", "rank", "stroke", "index", "max", "dim", "size"], "frames_ctx": ["videos_ctx", "frames_context", "frames_anc", "frames_chan", "videos_xc", "frames_xc", "flows_anc", "videos_chan", "flows_ctx", "flows_lc", "frames_lc", "flows_xc", "videos_context"], "dev_ctx": ["device_alloc", "dev_context", "devPcb", "device_cb", "devPalloc", "device_ctx", "device_context", "devPcontext", "dev_cb", "devjalloc", "devPctx", "devjcontext", "devjcb", "devjctx", "dev_alloc"], "ret": ["row", "layer", "flag", "ag", "al", "value", "vel", "val", "rc", "conv", "res", "ry", "def", "all", "col", "det", "deep", "RET", "result", " result", "Ret", "re", "back", "resp", "group"]}}
{"project": "FFmpeg", "commit_id": "3016e919d4e1d90da98af19ce2a9d4979506eaf3", "target": 1, "func": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,\n\n                                       int S)\n\n{\n\n    unsigned bit;\n\n\n\n    if (s->extra_bits) {\n\n        S <<= s->extra_bits;\n\n\n\n        if (s->got_extra_bits &&\n\n            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {\n\n            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);\n\n        }\n\n    }\n\n\n\n    bit = (S & s->and) | s->or;\n\n    bit = ((S + bit) << s->shift) - bit;\n\n\n\n    if (s->hybrid)\n\n        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);\n\n\n\n    return bit << s->post_shift;\n\n}\n", "idx": 23323, "substitutes": {"s": ["i", "es", "uns", "xs", "ds", "sys", "y", "ssl", "os", "ts", "cs", "us", "stats", "js", "aws", "n", "ns", "ins", "http", "ans", "v", "ing", "l", "ss", "sb", "support", "g", "ses", "private", "d", "sets", "site", "as", "services", "u", "php", "o", "sg", "c", "self", "spec", "a", "scope", "su", "e", "sym", "qs", "fs", "ings", "f", "t", "less", "full", "p", "si", "b", "service", "ims", "sup", "side", "ps", "gs", "sq", "als", "ops", "m", "args", "its", "ls", "sync", "is", "settings", "w", "session", "comments"], "crc": ["Crs", "crs", "circ", "csrc", "acrc", "CRC", "Croc", "Crc", "cbc", "croc", "rcRC", "cRC", " circ", "rcrc", " cRC", "csroc", "acRC", "rcrs", " cbc", "Cbc", "Cdc", "cdc", "csdc", "rcirc", "acrs", " cdc", "Circ", " crs", " croc", "acirc", "csbc"], "S": ["SC", "SA", "O", "G", "V", "SI", "TS", "RS", "US", "Q", "SH", "Si", "A", "Sa", "P", "SP", "I", "CS", "DS", "IS", "SR", "N", "PS", "SS", "SE", "K", "SB", "W", "L", "H", "SN", "X", "INT", "U", "SU", "T", "WS", "F", "R", "C", "BS", "AS", "D", "M", "ST", "Socket", "OS", "Source", "B", "NS", "ss"], "bit": ["bc", "str", "step", "binary", "i", "big", "and", "ct", "hit", "hop", "character", "option", "BIT", "text", "input", "part", "g", "arg", "val", "key", "null", "bin", "token", "feature", "sign", "digit", "no", "f", "op", "ac", "it", "bug", "cat", "Bit", "lock", "ip", "version", "unit", "id", "slot", "word", "count", "component", "comment", "fix", "tag", "pin", "pass", "byte", "second", "bits", "b", "value", "set", "flag", "mask", "block", "all", "image", "offset", "x", "feat", "type"]}}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    opts = qemu_opts_create(list, qdict_get_try_str(qdict, \"id\"), 1);\n\n    if (opts == NULL)\n\n        return NULL;\n\n\n\n    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);\n\n    return opts;\n\n}\n", "idx": 23809, "substitutes": {"list": ["like", "name", "ul", "object", "config", "acl", "result", "chain", "coll", "tree", "pkg", "ack", "lists", "cl", "listed", "entry", "full", "p", "List", "code", "load", "comment", "out", "self", "xml", "complete", "add", "set", "seq", "call", "batch", "base", "parent", "array", "li", "LIST", "l", "x", "this"], "qdict": ["qstr", "qudir", "qdf", "sqdict", "qudict", " qmap", "qdocument", "qsdf", "qdir", "eqdict", "eqdocument", " qdocument", " qdir", "qudf", "qtdict", "qsmap", "eqstyle", " qstr", "qmap", " qdf", "sqdt", "sqstr", "qsdict", "qtdocument", "sqdf", "sqmap", "qdt", "qsdt", "qumap", "sqdir", "qtstyle", " qstyle", "eqdf", "qustr", "qstyle", "qudt", "qtdf"], "opts": [" optt", "opals", " optins", "hopents", "optbs", " ops", "opcs", "OPts", " optrs", "ops", " opents", "obps", " opbs", "obts", "OPps", "opgs", "opents", " opss", "opins", "obins", "optrs", "OPals", "oprs", "OPgs", "hopts", "optents", " oprs", " opcs", "OPrs", "optgs", " opgs", "hopcs", " optps", "opss", " optts", "opps", "optss", " opals", "OPs", "obrs", "optt", "apptt", " opps", "appps", "appals", "optcs", "hopss", "opbs", "OPtt", "optins", "OPbs", "appts", "optts", "optps"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)\n\n{\n\n    switch (size) {\n\n    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;\n\n    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;\n\n    default: abort();\n\n    }\n\n}\n", "idx": 7119, "substitutes": {"op0": ["ip2", "opt0", "op_", " op_", "hop1", "pop0", "op00", "oper1", "opt2", " op90", "oc8", " op6", " op8", "opt1", "oper00", "op2", "hop0", "option0", "mp8", "mp6", "op90", "op6", "oc0", "oc00", " op5", "hop90", "option1", "option2", " op2", "mp00", "mp0", "op8", "op5", "pop90", "oper0", "option00", "ip_", "ip0", "pop5", "pop1", "ip1", "oper2", "hop_", "hop00", "hop5", "oc6", " op00", "hop2"], "op1": ["ip2", "opt0", "hop1", "ip8", "hop8", "OP0", "opt2", "opt1", "OP2", "apOne", " op01", "op2", "hop0", "ip01", "opOne", " opOne", "opt8", "OP1", "OP8", " op2", "op8", "ip0", "ip1", "ap0", "op01", "ap1", "ap01", "ipOne", " op8", "hop2"], "size": ["address", "name", "SIZE", "large", "sec", "fee", "shape", "style", "sync", "use", "enc", "loc", "capacity", "call", "weight", "small", "Size", "align", "number", "code", "six", "out", "n", "sized", "timeout", "empty", "scale", "c", "g", "type", "core", "cache", "ize", "form"]}}
{"project": "FFmpeg", "commit_id": "cf7d2f2d2134c0854edf2db91e7436ac2bc9874f", "target": 0, "func": "static av_cold int dnxhd_encode_init(AVCodecContext *avctx)\n\n{\n\n    DNXHDEncContext *ctx = avctx->priv_data;\n\n    int i, index, bit_depth, ret;\n\n\n\n    switch (avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV422P:\n\n        bit_depth = 8;\n\n        break;\n\n    case AV_PIX_FMT_YUV422P10:\n\n        bit_depth = 10;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"pixel format is incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->cid = ff_dnxhd_find_cid(avctx, bit_depth);\n\n    if (!ctx->cid) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"video parameters incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    av_log(avctx, AV_LOG_DEBUG, \"cid %d\\n\", ctx->cid);\n\n\n\n    index = ff_dnxhd_get_cid_table(ctx->cid);\n\n    if (index < 0)\n\n        return index;\n\n    ctx->cid_table = &ff_dnxhd_cid_table[index];\n\n\n\n    ctx->m.avctx    = avctx;\n\n    ctx->m.mb_intra = 1;\n\n    ctx->m.h263_aic = 1;\n\n\n\n    avctx->bits_per_raw_sample = ctx->cid_table->bit_depth;\n\n\n\n    ff_blockdsp_init(&ctx->bdsp, avctx);\n\n    ff_fdctdsp_init(&ctx->m.fdsp, avctx);\n\n    ff_mpv_idct_init(&ctx->m);\n\n    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);\n\n    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);\n\n    if (!ctx->m.dct_quantize)\n\n        ctx->m.dct_quantize = ff_dct_quantize_c;\n\n\n\n    if (ctx->cid_table->bit_depth == 10) {\n\n        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;\n\n        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 4;\n\n    } else {\n\n        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 3;\n\n    }\n\n\n\n    if (ARCH_X86)\n\n        ff_dnxhdenc_init_x86(ctx);\n\n\n\n    ctx->m.mb_height = (avctx->height + 15) / 16;\n\n    ctx->m.mb_width  = (avctx->width  + 15) / 16;\n\n\n\n    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {\n\n        ctx->interlaced   = 1;\n\n        ctx->m.mb_height /= 2;\n\n    }\n\n\n\n    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;\n\n\n\n#if FF_API_QUANT_BIAS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&\n\n        avctx->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)\n\n        ctx->intra_quant_bias = avctx->intra_quant_bias;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    // XXX tune lbias/cbias\n\n    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)\n\n        return ret;\n\n\n\n    /* Avid Nitris hardware decoder requires a minimum amount of padding\n\n     * in the coding unit payload */\n\n    if (ctx->nitris_compat)\n\n        ctx->min_padding = 1600;\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx)) < 0)\n\n        return ret;\n\n    if ((ret = dnxhd_init_rc(ctx)) < 0)\n\n        return ret;\n\n\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,\n\n                      ctx->m.mb_num * sizeof(uint16_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,\n\n                      ctx->m.mb_num * sizeof(uint8_t), fail);\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (avctx->thread_count > MAX_THREADS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"too many threads\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->thread[0] = ctx;\n\n    for (i = 1; i < avctx->thread_count; i++) {\n\n        ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));\n\n        memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));\n\n    }\n\n\n\n    return 0;\n\nfail:  // for FF_ALLOCZ_OR_GOTO\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 5539, "substitutes": {"avctx": ["avecv", " avcf", "avercontext", "abcmp", "navcontext", "aveloc", "afxc", "avcb", "afctx", "AVctl", "Avbc", "Avcmp", "AVcb", "aveca", "avkb", "navctx", "AVca", " avcontext", "avca", "AVcv", " avca", "airctx", "avcmd", "avercp", "afloc", "afcmp", "AVloc", "avcmp", "avectl", "abcontext", "avcv", "AVcmd", "avxc", "aircb", "AVcmp", "aveconn", "Avctx", "avecontext", "AVcp", "averpkg", "AVxc", "navcmd", "AVconfig", "AVcu", "AVconn", "averkb", "avbc", "avekb", "Avcu", " avxc", "vercontext", "avcu", "avconfig", "AVcontext", "averctx", "afcmd", "avecp", "afkb", "vercb", "avcontext", "afpkg", "airconn", "avloc", "AVbc", "vercv", "AVkb", "avconn", "abctx", " avcmp", "vercmd", "avctl", "AVcf", "verconn", "averctl", "avectx", "avepkg", "Avcf", "AVctx", "avcf", " avcmd", "avcp", "Avcontext", "verctx", " avctl", "aircontext", "afconn", "avpkg", " avbc", "afcontext", "afconfig", " avconn", "vercmp", "avecmp", "afcu", "navconn", "abconfig"], "ctx": ["cp", "cmp", "hw", "anc", "act", "cfg", "fw", "la", "ci", "component", "config", "nc", "data", "cus", "cca", "rc", "comp", "cat", "co", "concept", "loc", "cm", "support", "tx", "cal", "client", "conv", "media", "pc", "cc", "sci", "cs", "conf", "cli", "ck", "sc", "connection", "cam", "conn", "fn", "cmd", "wcs", "bc", "cu", "cms", "cb", "fp", "instance", "jp", "context", "prefix", "exec", "kw", "ca", "qa", "input", "msg", "kb", "utils", "c", "txt", "sq", "cf", "lc", "cn", "fc", "chan", "cv", "vc", "cas", "ctrl", "pkg", "xc", "tc"], "i": ["base", "ti", "ib", "I", "count", "di", "ci", "x", "ri", "si", "io", "info", "num", "pi", "j", "ii", "iu", "it", "ai", "e", "uri", "k", "c", "ip", "ind", "li", "ui"], "index": ["position", "check", "x", "weight", "active", "connect", "match", "len", "all", "error", "connection", "empty", "zero", "head", "page", "query", "conn", "option", "append", "id", "value", "update", "val", "list", "slice", "info", "office", "null", "ini", "search", "type", "element", "partial", "no", "end", "condition", "address", "sync", "loc", "inc", "key", "num", "action", "e", "point", "section", "out", "instance", "input", "pos", "ind", "include", "find", "cmp", "offset", "insert", "length", "fe", "part", "example", "full", "coll", "result", "inner", "Index", "date", "diff"], "bit_depth": ["bitSdepth", "bit_rate", "bit_len", " bit_deep", " bit_Depth", "bit_size", "bitalllen", "bitStable", "bit2height", " bit2Depth", "bitSdeep", " bit_roots", "bitallsource", "bin_depth", "bit32Depth", "byte_depth", "bin_deep", "bit_height", "byte_length", "bit_Depth", "bit32depth", " bit_count", " bit_size", "bit_table", "bit_roots", "bit64deep", "bit64count", "bitalldepth", "bit_dist", " bit2rate", " bit_height", "bit2depth", "bitalllength", " bit_rate", "bit_source", " bit_dist", "bit64Depth", " bit2depth", " bit2height", "byte_deep", "bin_table", "bit32height", "byte_source", "byte_dist", "bit_count", "bit64depth", "bit32rate", "bit_length", "bit2Depth", "bit2rate", "bit_deep", "byte_len"], "ret": ["abc", "gc", "row", "reg", "mem", "alt", "entry", "val", "rc", "reply", "obj", "arg", "res", "col", "arr", "feat", "rev", "result", "seq", "batch", "orig", "resp", "success", "ref", "aux", "rem"]}}
{"project": "FFmpeg", "commit_id": "461cd5bfb5c38e48a81b4a9a5912dfd65da1ba3d", "target": 0, "func": "void mpeg1_encode_mb(MpegEncContext *s,\n\n                     DCTELEM block[6][64],\n\n                     int motion_x, int motion_y)\n\n{\n\n    int i, cbp;\n\n    const int mb_x = s->mb_x;\n\n    const int mb_y = s->mb_y;\n\n    const int first_mb= mb_x == s->resync_mb_x && mb_y == s->resync_mb_y;\n\n\n\n    /* compute cbp */\n\n    cbp = 0;\n\n    for(i=0;i<6;i++) {\n\n        if (s->block_last_index[i] >= 0)\n\n            cbp |= 1 << (5 - i);\n\n    }\n\n    \n\n    if (cbp == 0 && !first_mb && (mb_x != s->mb_width - 1 || (mb_y != s->mb_height - 1 && s->codec_id == CODEC_ID_MPEG1VIDEO)) && \n\n        ((s->pict_type == P_TYPE && s->mv_type == MV_TYPE_16X16 && (motion_x | motion_y) == 0) ||\n\n        (s->pict_type == B_TYPE && s->mv_dir == s->last_mv_dir && (((s->mv_dir & MV_DIR_FORWARD) ? ((s->mv[0][0][0] - s->last_mv[0][0][0])|(s->mv[0][0][1] - s->last_mv[0][0][1])) : 0) |\n\n        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {\n\n        s->mb_skip_run++;\n\n        s->qscale -= s->dquant;\n\n        s->skip_count++;\n\n        s->misc_bits++;\n\n        s->last_bits++;\n\n        if(s->pict_type == P_TYPE){\n\n            s->last_mv[0][1][0]= s->last_mv[0][0][0]= \n\n            s->last_mv[0][1][1]= s->last_mv[0][0][1]= 0;\n\n        }\n\n    } else {\n\n        if(first_mb){\n\n            assert(s->mb_skip_run == 0);\n\n            encode_mb_skip_run(s, s->mb_x);\n\n        }else{\n\n            encode_mb_skip_run(s, s->mb_skip_run);\n\n        }\n\n        \n\n        if (s->pict_type == I_TYPE) {\n\n            if(s->dquant && cbp){\n\n                put_mb_modes(s, 2, 1, 0, 0); /* macroblock_type : macroblock_quant = 1 */\n\n                put_bits(&s->pb, 5, s->qscale);\n\n            }else{\n\n                put_mb_modes(s, 1, 1, 0, 0); /* macroblock_type : macroblock_quant = 0 */\n\n                s->qscale -= s->dquant;\n\n            }\n\n            s->misc_bits+= get_bits_diff(s);\n\n            s->i_count++;\n\n        } else if (s->mb_intra) {\n\n            if(s->dquant && cbp){\n\n                put_mb_modes(s, 6, 0x01, 0, 0);\n\n                put_bits(&s->pb, 5, s->qscale);\n\n            }else{\n\n                put_mb_modes(s, 5, 0x03, 0, 0);\n\n                s->qscale -= s->dquant;\n\n            }\n\n            s->misc_bits+= get_bits_diff(s);\n\n            s->i_count++;\n\n            memset(s->last_mv, 0, sizeof(s->last_mv));\n\n        } else if (s->pict_type == P_TYPE) { \n\n            if(s->mv_type == MV_TYPE_16X16){\n\n                if (cbp != 0) {\n\n                    if ((motion_x|motion_y) == 0) {\n\n                        if(s->dquant){\n\n                            put_mb_modes(s, 5, 1, 0, 0); /* macroblock_pattern & quant */\n\n                            put_bits(&s->pb, 5, s->qscale);\n\n                        }else{\n\n                            put_mb_modes(s, 2, 1, 0, 0); /* macroblock_pattern only */\n\n                        }\n\n                        s->misc_bits+= get_bits_diff(s);\n\n                    } else {\n\n                        if(s->dquant){\n\n                            put_mb_modes(s, 5, 2, 1, 0); /* motion + cbp */\n\n                            put_bits(&s->pb, 5, s->qscale);\n\n                        }else{\n\n                            put_mb_modes(s, 1, 1, 1, 0); /* motion + cbp */\n\n                        }\n\n                        s->misc_bits+= get_bits_diff(s);\n\n                        mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added\n\n                        mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added\n\n                        s->mv_bits+= get_bits_diff(s);\n\n                    }\n\n                } else {\n\n                    put_bits(&s->pb, 3, 1); /* motion only */\n\n                    if (!s->frame_pred_frame_dct)\n\n                        put_bits(&s->pb, 2, 2); /* motion_type: frame */\n\n                    s->misc_bits+= get_bits_diff(s);\n\n                    mpeg1_encode_motion(s, motion_x - s->last_mv[0][0][0], s->f_code);    // RAL: f_code parameter added\n\n                    mpeg1_encode_motion(s, motion_y - s->last_mv[0][0][1], s->f_code);    // RAL: f_code parameter added\n\n                    s->qscale -= s->dquant;\n\n                    s->mv_bits+= get_bits_diff(s);\n\n                }\n\n                s->last_mv[0][1][0]= s->last_mv[0][0][0]= motion_x;\n\n                s->last_mv[0][1][1]= s->last_mv[0][0][1]= motion_y;\n\n            }else{\n\n                assert(!s->frame_pred_frame_dct && s->mv_type == MV_TYPE_FIELD);\n\n\n\n                if (cbp) {\n\n                    if(s->dquant){\n\n                        put_mb_modes(s, 5, 2, 1, 1); /* motion + cbp */\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    }else{\n\n                        put_mb_modes(s, 1, 1, 1, 1); /* motion + cbp */\n\n                    }\n\n                } else {\n\n                    put_bits(&s->pb, 3, 1); /* motion only */\n\n                    put_bits(&s->pb, 2, 1); /* motion_type: field */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits+= get_bits_diff(s);\n\n                for(i=0; i<2; i++){\n\n                    put_bits(&s->pb, 1, s->field_select[0][i]);\n\n                    mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);\n\n                    mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);\n\n                    s->last_mv[0][i][0]=   s->mv[0][i][0];\n\n                    s->last_mv[0][i][1]= 2*s->mv[0][i][1];\n\n                }\n\n                s->mv_bits+= get_bits_diff(s);\n\n            }\n\n            if(cbp)\n\n                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);\n\n            s->f_count++;\n\n        } else{  \n\n            static const int mb_type_len[4]={0,3,4,2}; //bak,for,bi\n\n\n\n            if(s->mv_type == MV_TYPE_16X16){\n\n                if (cbp){    // With coded bloc pattern\n\n                    if (s->dquant) {\n\n                        if(s->mv_dir == MV_DIR_FORWARD)\n\n                            put_mb_modes(s, 6, 3, 1, 0);\n\n                        else\n\n                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 0);\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    } else {\n\n                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 0);\n\n                    }\n\n                }else{    // No coded bloc pattern\n\n                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);\n\n                    if (!s->frame_pred_frame_dct)\n\n                        put_bits(&s->pb, 2, 2); /* motion_type: frame */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits += get_bits_diff(s);\n\n                if (s->mv_dir&MV_DIR_FORWARD){\n\n                    mpeg1_encode_motion(s, s->mv[0][0][0] - s->last_mv[0][0][0], s->f_code); \n\n                    mpeg1_encode_motion(s, s->mv[0][0][1] - s->last_mv[0][0][1], s->f_code); \n\n                    s->last_mv[0][0][0]=s->last_mv[0][1][0]= s->mv[0][0][0];\n\n                    s->last_mv[0][0][1]=s->last_mv[0][1][1]= s->mv[0][0][1];\n\n                    s->f_count++;\n\n                }\n\n                if (s->mv_dir&MV_DIR_BACKWARD){\n\n                    mpeg1_encode_motion(s, s->mv[1][0][0] - s->last_mv[1][0][0], s->b_code); \n\n                    mpeg1_encode_motion(s, s->mv[1][0][1] - s->last_mv[1][0][1], s->b_code); \n\n                    s->last_mv[1][0][0]=s->last_mv[1][1][0]= s->mv[1][0][0];\n\n                    s->last_mv[1][0][1]=s->last_mv[1][1][1]= s->mv[1][0][1];\n\n                    s->b_count++;\n\n                }\n\n            }else{\n\n                assert(s->mv_type == MV_TYPE_FIELD);\n\n                assert(!s->frame_pred_frame_dct);\n\n                if (cbp){    // With coded bloc pattern\n\n                    if (s->dquant) {\n\n                        if(s->mv_dir == MV_DIR_FORWARD)\n\n                            put_mb_modes(s, 6, 3, 1, 1);\n\n                        else\n\n                            put_mb_modes(s, mb_type_len[s->mv_dir]+3, 2, 1, 1);\n\n                        put_bits(&s->pb, 5, s->qscale);\n\n                    } else {\n\n                        put_mb_modes(s, mb_type_len[s->mv_dir], 3, 1, 1);\n\n                    }\n\n                }else{    // No coded bloc pattern\n\n                    put_bits(&s->pb, mb_type_len[s->mv_dir], 2);\n\n                    put_bits(&s->pb, 2, 1); /* motion_type: field */\n\n                    s->qscale -= s->dquant;\n\n                }\n\n                s->misc_bits += get_bits_diff(s);\n\n                if (s->mv_dir&MV_DIR_FORWARD){\n\n                    for(i=0; i<2; i++){\n\n                        put_bits(&s->pb, 1, s->field_select[0][i]);\n\n                        mpeg1_encode_motion(s, s->mv[0][i][0] -  s->last_mv[0][i][0]    , s->f_code);\n\n                        mpeg1_encode_motion(s, s->mv[0][i][1] - (s->last_mv[0][i][1]>>1), s->f_code);\n\n                        s->last_mv[0][i][0]=   s->mv[0][i][0];\n\n                        s->last_mv[0][i][1]= 2*s->mv[0][i][1];\n\n                    }\n\n                    s->f_count++;\n\n                }\n\n                if (s->mv_dir&MV_DIR_BACKWARD){\n\n                    for(i=0; i<2; i++){\n\n                        put_bits(&s->pb, 1, s->field_select[1][i]);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][0] -  s->last_mv[1][i][0]    , s->b_code);\n\n                        mpeg1_encode_motion(s, s->mv[1][i][1] - (s->last_mv[1][i][1]>>1), s->b_code);\n\n                        s->last_mv[1][i][0]=   s->mv[1][i][0];\n\n                        s->last_mv[1][i][1]= 2*s->mv[1][i][1];\n\n                    }\n\n                    s->b_count++;\n\n                }\n\n            }\n\n            s->mv_bits += get_bits_diff(s);\n\n            if(cbp)\n\n                put_bits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);\n\n        }\n\n        for(i=0;i<6;i++) {\n\n            if (cbp & (1 << (5 - i))) {\n\n                mpeg1_encode_block(s, block[i], i);\n\n            }\n\n        }\n\n        s->mb_skip_run = 0;\n\n        if(s->mb_intra)\n\n            s->i_tex_bits+= get_bits_diff(s);\n\n        else\n\n            s->p_tex_bits+= get_bits_diff(s);\n\n    }\n\n}\n", "idx": 9727, "substitutes": {"s": ["l", "session", "is", "its", "m", "http", "t", "gs", "sum", "v", "series", "bis", "full", "ans", "ns", "details", "spec", "self", "settings", "sg", "ds", "si", "n", "w", "b", "c", "e", "se", "sq", "us", "f", "sym", "sets", "es", "sup", "r", "en", "this", "comments", "fs", "su", "site", "ps", "ss", "ks", "sv", "g", "features", "stats", "ops", "d", "ys", "ls", "os", "cs", "sync", "sl", "new", "sb", "sys", "a", "ssl", "conf", "sports", "ts", "in", "service", "p", "qs", "ins", "xs", "js", "rs", "an", "aws", "S", "states", "services", "less", "client", "ses", "css", "y", "bs"], "block": ["Block", "byte", "window", "record", "w", "info", "stat", "data", "config", "output", "e", "script", "bc", "mode", "device", "size", " blocks", "input", "ctx", "object", "audio", "blocks", "enc", "type", "video", "image", "cache", "buffer"], "motion_x": ["motionIdname", "motion_index", "move_name", "motion_name", "motion___y", "rup_y", "motion___index", "motion___dx", "motion_cross", "motionIdy", "motion___x", "rup_index", "rup_x", "move_cross", "motionIdcross", "motionIdx", "rup_dx", "motion_dx", "move_x", "move_y"], "motion_y": ["eye_ya", "motion_height", "motion_ya", "move_py", "eye_y", "motion11y", "eye_x", "move_height", "motion11height", "eye_height", "motion11x", "motion_py", "motion11py", "move_x", "move_y"], "i": ["oi", "l", "hi", "ui", "di", "n", "si", "in", "zi", "key", "m", "xi", "info", "b", "x", "k", "ini", "ami", "d", "c", "ji", "p", "ix", "uri", "e", "yi", "mu", "eni", "f", "j", "ai", "index", "v", "ind", "gi", "mi", "ti", "phi", "r", "chi", "abi", "qi", "pi", "bi", "ii", "u", "h", "I", "li", "ip", "ci", "api", "ori", "io", "ni", "lc", "y", "ri", "fi", "iu", "ki"], "cbp": ["CBpc", "bbP", "cbc", "rbpc", "abbp", "CBp", "cbpi", "rbps", "cfpc", "bbps", "bbpi", "rbpi", "CBP", "bcpc", "bbp", "cbpc", "cfP", "cbps", "ggps", "ggpi", "ggp", "cfps", "rbc", "abbc", "CBps", "abbP", "bcp", "CBc", "rbp", "bcps", "abbps", "bcP", "bbpc", "abbpc", "cfp", "ggP", "rbP", "cbP"], "mb_skip_run": ["mb_skip_bit", "mb_skip_count", "mb_num_unit", "mb_num_bit", "mb_num_run", "mb_num_count", "mb_skip_unit"], "skip_count": ["miss_file", "skipalcount", "skipalcounter", "skipalfile", "miss_code", "skip_file", "skip_code", "miss_counter", "skipalcode", "miss_count", "skip_counter"], "misc_bits": ["every_bands", "skipumbits", "everyveldates", "skipumdates", "everyvelbands", "every_runs", "skipumbands", "skipvelbands", "skipvelbits", "skip_bits", "everyvelruns", "everyvelbits", "skip_runs", "skipumruns", "skip_dates", "skipvelruns", "skip_bands", "every_bits", "skipveldates", "every_dates"], "last_bits": ["last128cycles", "lastallcycles", "last128locks", "last_bit", "max_bits", "max_bit", "lastallbit", "lastalllocks", "last128bit", "lastallbits", "last_locks", "max_locks", "last_cycles", "max_cycles", "last128bits"]}}
{"project": "FFmpeg", "commit_id": "8370e426e42f2e4b9d14a1fb8107ecfe5163ce7f", "target": 1, "func": "static av_cold int vp3_decode_end(AVCodecContext *avctx)\n\n{\n\n    Vp3DecodeContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    if (avctx->is_copy && !s->current_frame.data[0])\n\n        return 0;\n\n\n\n    av_free(s->superblock_coding);\n\n    av_free(s->all_fragments);\n\n    av_free(s->coded_fragment_list[0]);\n\n    av_free(s->dct_tokens_base);\n\n    av_free(s->superblock_fragments);\n\n    av_free(s->macroblock_coding);\n\n    av_free(s->motion_val[0]);\n\n    av_free(s->motion_val[1]);\n\n    av_free(s->edge_emu_buffer);\n\n\n\n    if (avctx->is_copy) return 0;\n\n\n\n    for (i = 0; i < 16; i++) {\n\n        free_vlc(&s->dc_vlc[i]);\n\n        free_vlc(&s->ac_vlc_1[i]);\n\n        free_vlc(&s->ac_vlc_2[i]);\n\n        free_vlc(&s->ac_vlc_3[i]);\n\n        free_vlc(&s->ac_vlc_4[i]);\n\n    }\n\n\n\n    free_vlc(&s->superblock_run_length_vlc);\n\n    free_vlc(&s->fragment_run_length_vlc);\n\n    free_vlc(&s->mode_code_vlc);\n\n    free_vlc(&s->motion_vector_vlc);\n\n\n\n    /* release all frames */\n\n    if (s->golden_frame.data[0])\n\n        ff_thread_release_buffer(avctx, &s->golden_frame);\n\n    if (s->last_frame.data[0] && s->last_frame.type != FF_BUFFER_TYPE_COPY)\n\n        ff_thread_release_buffer(avctx, &s->last_frame);\n\n    /* no need to release the current_frame since it will always be pointing\n\n     * to the same frame as either the golden or last frame */\n\n\n\n    return 0;\n\n}\n", "idx": 22976, "substitutes": {"avctx": ["avecu", "avecf", "AVconfig", "afcrit", "afca", "afcf", "ajcontext", "avnas", "akcu", "navcup", "accountcrit", "operpc", " avconfig", "afcup", "avconfig", "avcup", "avcrit", "ajconfig", "operctx", "AVcontext", "afctx", "accountpc", "evcontext", "avcf", "AVca", "avca", "akcontext", "evcu", "navctx", "akctx", "accountcontext", "avecontext", "avalkb", "ajca", "afcu", "avbc", "opercontext", "abnas", "navcu", "navbc", "avcontext", "avcu", "accountctx", "abctx", "afnas", "avpc", "afbc", "afpc", "avalctx", "ajnas", "akcf", "opercrit", "evctx", "ajctx", "avectx", "abcontext", "afcontext", "AVctx", "navkb", "avalcontext", "evcup", " avca", " avcontext", "navcontext", "afkb", "avalbc", "abca", "avkb"], "s": ["ions", "sv", "bis", "es", "uns", "xs", "ds", "sys", "r", "ssl", "os", "ts", "cs", "us", "js", "aws", "ms", "n", "S", "ns", "rs", "ins", "v", "conf", "http", "l", "ss", "sb", "g", "ses", "d", "sets", "as", "services", "u", "stat", "o", "sg", "c", "spec", "sc", "a", "has", "changes", "sf", "su", "e", "sym", "qs", "hs", "fs", "f", "t", "p", "si", "b", "service", "sup", "side", "ps", "gs", "h", "sq", "als", "your", "ops", "ks", "m", "its", "args", "ls", "sync", "is", "ctx", "se", "session", "comments", "bs", "states"], "i": ["io", "ix", "e", "ie", "fi", "qi", "ri", "ui", "eni", "mini", "gi", "d", "uri", "ti", "I", "l", "ci", "y", "phi", "info", "ini", "m", "oi", "j", "u", "it", "ip", "abi", "p", "id", "o", "bi", "vi", "cli", "mi", "dr", "mu", "c", "index", "idi", "si", "ii", "b", "ji", "n", "iu", "ai", "xi", "hi", "di", "z", "yi", "multi", "li", "api", "pi", "x", "zi", "ni"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,\n\n                               unsigned size)\n\n{\n\n    PXA2xxState *s = (PXA2xxState *) opaque;\n\n\n\n    switch (addr) {\n\n    case MDCNFG ... SA1110:\n\n        if ((addr & 3) == 0)\n\n            return s->mm_regs[addr >> 2];\n\n\n\n    default:\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12134, "substitutes": {"opaque": ["opacity", "OPaque", "oppaque", "opicit", "ospaque", "ospicit", "OPicit", "opericit", "operacity", "ospaques", " opace", "OPaques", " opaques", " ophole", "oppace", "operhole", "oppaques", "opace", "opphole", "ospacity", "ophole", "operaque", "opaques", "OPacity", "operaques", "operace"], "addr": ["mac", "adr", "seq", "cmp", "start", "str", "len", "val", "ord", "ext", "pad", "id", "conn", "src", "x", "pointer", "lvl", "data", "ad", "ref", "config", "p", "slot", "cb", "ace", "ptr", "loc", "mode", "dr", "padding", "host", "rt", "code", "index", "oa", "slice", "flags", "amp", "name", "rc", "align", "r", "address", "nr", "part", "sb", "hop", "offset", "asm", "enc", "eth", "type", "layer", "pos", "rx", "ip", "sid", "mt", "cmd", "sr", "nn"], "size": [" c", " bytes", "len", " mode", "val", "w", "SIZE", "i", "data", "c", "e", "Size", "mode", " length", "shape", "rc", "state", "ctx", "address", "offset", "bytes", "length", " sizes", "ize", "ss"], "s": ["conf", "session", "ts", "is", "n", "g", "si", "sf", "w", "m", "stats", "b", "ops", "gs", "c", "p", "ls", "e", "rs", "sq", "socket", "f", "os", "cs", "o", "S", "scope", "es", "v", "states", "r", "ns", "sb", "sys", "h", "ips", "fs", "ses", "ps", "ss"]}}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)\n\n{\n\n    int ret;\n\n\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"reinit context\\n\");\n\n\n\n    /* 1. streamoff */\n\n    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);\n\n    if (ret)\n\n        av_log(s->avctx, AV_LOG_ERROR, \"capture VIDIOC_STREAMOFF\\n\");\n\n\n\n    /* 2. unmap the capture buffers (v4l2 and ffmpeg):\n\n     *    we must wait for all references to be released before being allowed\n\n     *    to queue new buffers.\n\n     */\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"waiting for user to release AVBufferRefs\\n\");\n\n    if (atomic_load(&s->refcount))\n\n        while(sem_wait(&s->refsync) == -1 && errno == EINTR);\n\n\n\n    ff_v4l2_context_release(&s->capture);\n\n\n\n    /* 3. get the new capture format */\n\n    ret = ff_v4l2_context_get_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"query the new capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 4. set the capture format */\n\n    ret = ff_v4l2_context_set_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"setting capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 5. complete reinit */\n\n    sem_destroy(&s->refsync);\n\n    sem_init(&s->refsync, 0, 0);\n\n    s->draining = 0;\n\n    s->reinit = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 19889, "substitutes": {"s": ["ns", "ms", "spec", "ts", "sg", "session", "t", "rs", "conf", "f", "settings", "services", "options", "service", "n", "sb", "i", "g", "ss", "ls", "ops", "fs", "self", "is", "o", "cs", "l", "d", "su", "new", "args", "site", "iss", "qs", "e", "ssl", "side", "ses", "c", "ps", "si", "js", "sym", "p", "secondary", "S", "ks", "gs", "sys", "u", "h", "its", "a", "es", "states", "parts", "os", "hs", "us", "sets", "se", "sq", "ds", "sf"], "ret": ["bit", "ref", "full", "nt", "debug", "result", "job", "str", "run", "att", "feat", "reset", "id", "fit", "rev", "pat", "res", "opt", "mt", "valid", "len", "part", "bin", "pub", "fun", "rf", "arg", "art", "Ret", "bf", "key", "cat", " Ret", "gt", "RET", "pet", "ft", "code", "base", "alt", "lit", "rt", "sb", "match", "bad", "val", "re", " RET", "back", "py", "reply", "success", "data", "af", "let", "reg", "flag", "pass", "ext", "def", "rets", "lt", "en", "format", "fail", "bd", "det", "bot", "url", "error", "red", "usr"]}}
{"project": "FFmpeg", "commit_id": "b04665ac028d26747396eaf4dbf9188225a6f2a1", "target": 0, "func": "static int opt_preset(const char *opt, const char *arg)\n\n{\n\n    FILE *f=NULL;\n\n    char filename[1000], tmp[1000], tmp2[1000], line[1000];\n\n    int i;\n\n    const char *base[3]= { getenv(\"HOME\"),\n\n                           \"/usr/local/share\",\n\n                           \"/usr/share\",\n\n                         };\n\n\n\n    for(i=!base[0]; i<3 && !f; i++){\n\n        snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", base[i], i ? \"\" : \".\", arg);\n\n        f= fopen(filename, \"r\");\n\n        if(!f){\n\n            char *codec_name= *opt == 'v' ? video_codec_name :\n\n                              *opt == 'a' ? audio_codec_name :\n\n                                            subtitle_codec_name;\n\n            snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", base[i],  i ? \"\" : \".\", codec_name, arg);\n\n            f= fopen(filename, \"r\");\n\n        }\n\n    }\n\n    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||\n\n              is_dos_path(arg))){\n\n        snprintf(filename, sizeof(filename), arg);\n\n        f= fopen(filename, \"r\");\n\n    }\n\n\n\n    if(!f){\n\n        fprintf(stderr, \"File for preset '%s' not found\\n\", arg);\n\n        av_exit(1);\n\n    }\n\n\n\n    while(!feof(f)){\n\n        int e= fscanf(f, \"%999[^\\n]\\n\", line) - 1;\n\n        if(line[0] == '#' && !e)\n\n            continue;\n\n        e|= sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) - 2;\n\n        if(e){\n\n            fprintf(stderr, \"%s: Preset file invalid\\n\", filename);\n\n            av_exit(1);\n\n        }\n\n        if(!strcmp(tmp, \"acodec\")){\n\n            opt_audio_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"vcodec\")){\n\n            opt_video_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"scodec\")){\n\n            opt_subtitle_codec(tmp2);\n\n        }else if(opt_default(tmp, tmp2) < 0){\n\n            fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", filename, tmp, tmp2);\n\n            av_exit(1);\n\n        }\n\n    }\n\n\n\n    fclose(f);\n\n\n\n    return 0;\n\n}\n", "idx": 6535, "substitutes": {"opt": ["pot", "option", "options", "oc", "o", "iter", "alt", "parent", "config", "op", "expr", "token", "format", "enc", "cat", "loc", "altern", "tag", "optim", "ott", "key", "attr", "ext", "url", "prot", "sl", "obj", "init", "param", "Opt", "cho", "path", "oss", "feat", "temp", "usr", "prop", "iv", "pos", "proc", "orig", "type", "comb", "term", "fi", "optional", "prefix"], "arg": ["option", "name", "extra", "flag", "ig", "ag", "sec", "al", "entry", " argument", "word", "config", "val", "op", "use", "ax", "inter", "enc", "cat", "ad", "slice", "image", "loc", "ace", "key", "mac", "valid", "argument", "inc", "ext", "call", "url", "args", "param", "arc", "match", "ar", "item", "target", "arr", "file", "en", "rg", "path", "other", "pass", "exec", "p", "input", "parse", "amp", "star", "Arg", "gen", "doc", "var", "ge", "g", "lc", "ac", "par", "neg", "end"], "f": ["fen", "full", "fr", "o", "tf", "feed", "sf", "inf", "v", "ef", "b", "rf", "info", "m", "fb", "l", "uf", "found", "d", "j", "fl", "q", "fe", "u", "e", "w", "file", "func", "t", "fn", "df", "n", "ff", "xf", "fp", "field", "fa", "p", "fm", "h", "z", "fs", "fun", "c", "g", "fd", "cf", "y", "bf", "fc", "handler", "fi", "form", "lf", "r", "F"], "filename": ["sf", "rb", "password", "database", "buf", "job", "nm", "phrase", "sheet", "document", "len", "addin", "connection", "file", "json", "fp", "nil", "theme", "upload", "audio", "folder", "msg", "verb", "name", "kn", "word", "config", "Filename", "fb", "url", "which", "fil", "uri", "binary", "path", "font", "txt", "type", "size", "archive", "nl", "mpeg", "username", "loc", "image", "title", "profile", "wb", "lace", "package", "metadata", "cli", "download", "message", "whatever", "dll", "feat", "source", "frame", "shell", "location", "fd", "loader", "prefix", "session", "length", "fn", "jpg", "lvl", "ln", "kl", "bf", "il", "figure", "skin", "dyl", "sample", "generic", "directory"], "tmp": ["appy", "rb", "mobi", "data", "perm", "buf", "mp", "tab", "buffer", "file", "fp", "output", "sp", "proc", "ppa", "page", "tp", "upload", "img", "folder", "cp", "name", "config", "kk", "slice", "tty", "fake", "fb", "param", "duration", "zip", "path", "txt", "mm", "video", "text", "test", "cpp", "area", "time", "md", "username", "now", "home", "image", "loc", "csv", "package", "metadata", "obj", "stuff", "py", "cli", "source", "temp", "pos", "start", "c", "api", "cache", "src", "seed", "prefix", "cmp", "v", "pre", "tem", "space", "dir", "pty", "sample", "cdn", "diff", "mk"], "tmp2": ["mpall", "tmp5", "temp2", "temp8", "tmp8", " tmp5", "tmp4", " tmpout", "tmpall", "fake2", "mpout", " tmp4", "tmp1", "tempTwo", "address2", "tmpout", "cppTwo", "mp2", " tmp8", "cpp1", "temp4", "fake1", "address1", "mp8", "fakeTwo", "cpp2", " tmpall", "mp5", " tmp1", "txt1", "tmpTwo", "mpTwo", "mp1", "addressTwo", "txt2", "temp1", "tempout", "txt5", "mp4", "fake8", "txtall", "txt4"], "line": ["LINE", "name", "nl", "row", "time", "block", "v", "el", "entry", "word", "co", "m", "loc", "l", "call", "url", "d", "j", "match", "Line", "ine", "code", "len", "cell", "e", "error", "buffer", "out", "file", "n", "err", "source", "p", "ne", "temp", "run", "frame", "pos", "ln", "c", "range", "page", "lin", "lc", "fd", "link", "user", "lines", "lf", "r", "end"], "i": ["gi", "name", "o", "ti", "v", "id", "I", "count", "a", "di", "s", "ci", "ni", "x", "xi", "b", "io", "si", "slice", "abi", "ri", "bi", "m", "qi", "ix", "l", "key", "pi", "yi", "phi", "j", "ii", "iu", "d", "it", "ai", "u", "part", "e", "uri", "t", "k", "n", "multi", "ini", "ie", "p", "start", "oi", "hi", "c", "ip", "page", "y", "type", "li", "fi", "index", "zi", "mu", "ui"], "base": ["bas", "name", "absolute", "area", "extra", "bin", "block", "store", "v", "http", "id", "chain", "config", "pre", "list", "b", "home", "cat", "bi", "body", "ace", "null", "l", "key", "ma", "url", "space", "param", "buffer", "part", "se", "file", "pad", "ase", "nb", "fa", "source", "p", "temp", "array", "root", "Base", "run", "frame", "based", "start", "tree", "handler", "core", "api", "ac", "cache", "index", "prefix"], "codec_name": ["codecskey", "codenc_anc", "codecstype", "codenc_key", "codecsname", "codec2key", "codef_name", "codef_key", "codec2type", "codec2name", "codec_id", "codef_type", "codec_type", "codecsanc", "codec2id", "codenc_type", "codenc_name", "codec_anc", "codec_key", "codef_id"]}}
{"project": "FFmpeg", "commit_id": "ec07efa70012845e8642df67a4a773f510a17088", "target": 1, "func": "static int parse_adaptation_sets(AVFormatContext *s)\n\n{\n\n    WebMDashMuxContext *w = s->priv_data;\n\n    char *p = w->adaptation_sets;\n\n    char *q;\n\n    enum { new_set, parsed_id, parsing_streams } state;\n\n    if (!w->adaptation_sets) {\n\n        av_log(s, AV_LOG_ERROR, \"The 'adaptation_sets' option must be set.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on\n\n    state = new_set;\n\n    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {\n\n        if (*p == ' ')\n\n            continue;\n\n        else if (state == new_set && !strncmp(p, \"id=\", 3)) {\n\n            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));\n\n            if (mem == NULL)\n\n                return AVERROR(ENOMEM);\n\n            w->as = mem;\n\n            ++w->nb_as;\n\n            w->as[w->nb_as - 1].nb_streams = 0;\n\n            w->as[w->nb_as - 1].streams = NULL;\n\n            p += 3; // consume \"id=\"\n\n            q = w->as[w->nb_as - 1].id;\n\n            while (*p != ',') *q++ = *p++;\n\n            *q = 0;\n\n            p++;\n\n            state = parsed_id;\n\n        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {\n\n            p += 8; // consume \"streams=\"\n\n            state = parsing_streams;\n\n        } else if (state == parsing_streams) {\n\n            struct AdaptationSet *as = &w->as[w->nb_as - 1];\n\n            q = p;\n\n            while (*q != '\\0' && *q != ',' && *q != ' ') q++;\n\n            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);\n\n            if (as->streams == NULL)\n\n                return AVERROR(ENOMEM);\n\n            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);\n\n            if (as->streams[as->nb_streams - 1] < 0) return -1;\n\n            if (*q == '\\0') break;\n\n            if (*q == ' ') state = new_set;\n\n            p = ++q;\n\n        } else {\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 4255, "substitutes": {"s": ["o", "serv", "v", "S", "less", "http", "spec", "sg", "b", "si", "sync", "ses", "services", "m", "f", "ns", "stats", "sl", "service", "sci", "cs", "ss", "u", "e", "sc", "an", "sb", "se", "gs", "t", "ds", "n", "ts", "su", "self", "south", "sv", "fs", "sa", "c", "os", "g", "ssl", "sq", "new", "rs", "r", "ps", "js"], "w": ["writer", "way", "rw", "hw", "nw", "v", "fw", "W", "wx", "wei", "a", "wave", "word", "sw", "wan", "wn", "wall", "x", "b", "ow", "wm", "wp", "widget", "wa", "wt", "m", " W", "window", "wb", "wh", "l", "f", "wo", "d", "u", "wd", "e", "we", "tw", "t", "k", "n", "wcs", "win", "self", "work", "ww", "kw", "wr", "wal", "war", "web", "h", "iw", "this", "wu", "c", "new", "g", "wl", "y", "ew", "current", "r", "aw"], "p": ["patch", "cp", "P", "pid", "bp", "python", "ep", "press", "v", "pr", "a", "pa", "pat", "pre", "po", "pp", "b", "x", "i", "op", "ping", "pe", "lp", "ap", "m", "l", "f", "pi", "post", "pg", "d", "j", "pc", "u", "np", "part", "e", "dp", "point", "per", "port", "t", "k", "n", "pad", "fp", "jp", "h", "vp", "z", "sp", "pos", "c", "ip", "g", "y", "api", "tp", "pair", "r", "ps"], "q": ["P", "name", "ch", "quick", "iq", "v", "id", "qq", "count", "qt", "x", "i", "pe", "queue", "m", "qi", "quant", "ix", "l", "cl", "f", "post", "ue", "dq", "d", "eq", "ph", "u", "e", "sh", "depth", "que", "port", "qs", "Q", "k", "n", "t", "question", "qu", "quality", "qa", "req", "h", "z", "sp", "c", "ip", "g", "sq", "y", "query", "r", "max", "end", "quest"], "state": ["stat", "name", "ch", "o", "st", "position", "are", "al", "is", "a", "count", "cur", "parent", "id", "config", "STATE", "po", "session", "val", "style", "slice", "pe", "ate", "art", "m", "wa", "ace", "states", "tag", "resource", "key", "f", "post", "at", "private", "j", "handle", "param", "u", "part", "an", "e", "port", "t", "k", "instance", "after", "State", "err", "self", "work", "old", "un", "start", "am", "step", "rule", "new", "g", "ke", "type", "y", "pair", "current", "conn"], "mem": ["program", "hw", "Mem", "buff", "reg", "bin", "rom", "vm", "mat", "val", "sum", "bm", "mo", "m", "rm", "buf", "ram", "num", "mod", " Mem", "ph", "em", "sh", "mc", "prom", "tm", "ctx", "mi", "access", "qu", "pool", "temp", "mb", "rem", "sp", "am", "memory", "node", "ip", "mm", "im", "du", "gram", "cache", "ref", "ha", "mor", "lim", "max", "dim"], "as": ["master", "_", "a", "atts", "pas", "x", "parts", "d", "las", "bs", "all", "ar", "access", "array", "aws", "am", "acs", "sa", "var", "ams", "inas", "ac", "cas", "ast", "ass", "pack", "asu", "al", "is", "ap", "with", "was", "at", "ai", "ts", "ask", "ais", "ms", "rs", "ras", "ans", "er", "are", "ins", "nas", "mas", "ays", "als", "asts", "num", "ra", "has", "from", "cs", "action", "an", "auth", "ks", "instance", "asm", "os", "cache", "app", "r", "bas", "ance", "to", "http", "asa", "com", "modules", "alias", "AS", "ma", "ns", "args", "res", "us", "ss", "ars", "gs", "As", "ase", "seq", "this", "asc", "es"], "nb_as": ["sb_was", "num_mas", "nbllasu", "nb_asu", "nbJas", "nblockas", "nb25ase", "nb_sa", "nbNase", "nb_nas", "nb__ras", "nb_ase", "sb_asu", "nbJras", "nbllwas", "nbBmas", "sblockas", "nblockwas", "nb_an", "num_an", "sblockwas", "nbllas", "num_as", "nb__asc", "nbNan", "nb_asc", "num_ase", "sblockras", "nb25ras", "nbBas", "num_AS", "nbBras", "nb_AS", "nbllras", "sb_ras", "nb__sa", "sblockasu", "nb_was", "nb__was", "num_asc", "nb25an", "nb__as", "nblockras", "nbJwas", "sb_as", "num_ras", "num_sa", "nb_ras", "nbJmas", "nbBasu", "nbJnas", "nbNras", "nblockasu", "num_asu", "nb__AS", "nb25as", "nbNas", "nbJAS", "nb_mas", "num_nas", "num_was"]}}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    gen_read_xer(cpu_gpr[gprn]);\n\n}\n", "idx": 13118, "substitutes": {"ctx": ["context", "tx", "cam", "pkg", "cm", "bc", "cv", "ca", "rc", "cc", "pc", "Context", "lc", "ctrl", "conv", "txt", "cmp", "abc", " cx", "conn", "grad", "cca", "c", "anc", "cb", "cas", "cp", "xc", "cpp"], "gprn": ["gPRr", "gPRn", "rgPRN", "gprr", "gPRns", "gPrN", "rgprN", " gprns", " gprN", "gprN", "gprne", "gPrn", "gPrne", "gprns", " gPrne", " gPrn", "rgprns", "rgPRns", "gPRne", "gPrr", "rgPRn", " gprne", "gPRN", "rgPRr", "rgprn", "gPrns", "rgprr", " gPrN", " gPrns"], "sprn": ["prb", "prr", "sprr", "sprN", "Sprr", "prn", " sprN", " sprr", " sprb", "SprN", "prN", "sprb", "Sprb", "Sprn"]}}
{"project": "FFmpeg", "commit_id": "4641ae352ec587355764ffd5c43dd0d0ebd47654", "target": 1, "func": "static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        int size;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        size = pb->buf_end - pb->buf_ptr;\n\n        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n\n                             .buf_size = size };\n\n        if (!pd.buf)\n\n            goto error;\n\n        memcpy(pd.buf, pb->buf_ptr, size);\n\n        sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n\n        av_freep(&pd.buf);\n\n        if (!sub_demuxer)\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n\n\n        av_assert0(!ast->sub_ctx->codec_whitelist && !ast->sub_ctx->format_whitelist);\n\n        ast->sub_ctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n        ast->sub_ctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 17908, "substitutes": {"s": ["ns", "spec", "m", "t", "f", "g", "i", "ops", "fs", "sec", "parser", "o", "cs", "d", "w", "e", "ssl", "c", "si", "p", "S", "b", "gs", "sys", "storage", "sets", "sq"], "st": ["ist", "est", "stat", "ts", "nd", "t", "rest", "ct", "sp", "ste", "td", "fe", "nt", "str", "sb", "ost", "stream", "sl", "ss", "src", "ctx", "ld", "sa", "ST", "sd", "sta", "art", "d", "std", "sn", "sc", "sth", "kt", "stage", "sts", "St", "inst", "a", "mt", "ft", "pt", "sf"], "pkt": ["hkt", "psacket", "tacket", "tke", "nacket", "tcp", "mct", "Pett", "hct", "wpct", " ppt", "wpcht", "tct", "Pcp", "pett", "Packet", "Pk", "tkt", " pett", "psct", "mpt", " pct", "packet", "Pcht", " packet", " pke", "hett", " pcht", "nct", "pspt", "pskt", "mkt", "nk", " pcp", "pct", "macket", "ppt", "nkt", "Pkt", "pcht", "wpkt", "Pct", "Ppt", "pk", "pke", "wpacket", " pk", "Pke", "pcp", "hacket"], "desc": ["dc", "txt", "code", "data", "info", "esc", "text", "dest", "dir", "ref", "name", "rc", "str", "pert", "cb", "bc", "src", "loc", "sel", "ext", "ptr", "des", "sec", "done", "def", "en", "description", "empty", "rec", "df", "std", "feat", "aux", "sub", "config", "id", "sc", "buf", "rev", "lc", "req", "seq", "meta", "uc", "Desc", "doc", "cmp", "dist", "proc", "cv", "success", "asc"], "ret": ["status", "offset", "data", "info", "ref", "alt", "rc", "gc", "reg", "lit", "fun", "nt", "result", "num", "match", "ext", "sec", "des", "mem", "resp", "rets", "en", "def", "att", "score", "val", "rec", "re", "Ret", "std", "feat", "back", "xt", "det", "rev", "cur", "cat", "seq", "gt", "RET", "error", "nz", "res", "opt", "reply", "success", "len"], "ast": ["at", "ist", "est", "ab", "esp", "nd", "af", "rest", "aste", "op", "ess", "alt", "eth", "nt", "ar", "ost", "AST", "am", "anc", "as", "node", "ap", "act", "atom", "parser", "sta", "art", "att", "host", "exec", "ta", "std", "aster", "ac", "Ast", "add", "ad", "asm", "sam", "post", "test", "mast", "od", "aw", "asting", "ace", "a", "inst", "ard", "cast", "amd", "ma", "end", "addr", "it", "asts", "sa", "amp"], "sub_demuxer": ["sub_demluxeder", "sub_demuxers", "sub_promxe", "sub_promxers", "sub_demxeder", "sub_demployler", "sub_demuxler", "sub_promuxeder", "sub_deuxler", "sub_demversler", "sub_promxeder", "sub_promployer", "sub_demxeri", "sub_dexer", "sub_demluxe", "sub_deuxer", "sub_promployers", "sub_promuxe", "sub_promuxers", "sub_demverser", "sub_demployeder", "sub_demployed", "sub_demxed", "sub_promuxeri", "sub_promxer", "sub_demployeri", "sub_demversers", "sub_deuxers", "sub_demxer", "sub_demuxe", "sub_demployer", "sub_demxers", "sub_promployeri", "sub_promuxed", "sub_demluxers", "sub_demxe", "sub_dexeri", "sub_demuxeri", "sub_promuxer", "sub_promployed", "sub_demxler", "sub_demuxeder", "sub_demversed", "sub_demverseri", "sub_demploye", "sub_demluxer", "sub_dexers", "sub_dexler", "sub_deuxeri", "sub_demuxed", "sub_demployers"], "time_base": ["TIME_cache", "time__buffer", "time_builder", "time__builder", "time__cache", "TIME_base", "time_cache", "time_buffer", "TIME_buffer", "TIME_builder", "time__base"], "size": ["offset", "extra", "x", "file", "num", "max", "pos", "sec", "enc", "score", "empty", "sh", "large", "length", "send", "bytes", "Size", "end", "len", "scale", "content", "name", "rc", "clean", "count", "last", "sc", "si", "loss", "iz", "gz", "weight", "term", "time", "code", "core", "SIZE", "f", "sized", "who", "loc", "sd", "speed", "grade", "go", "ci", "sn", "ize", "start", "sync", "c", "position", "address", "sent", "fee", "sum", "value", "capacity", "small", "data", "shape", "esc", "mode", "ng", "n", "channel", "g", "i", "day", "en", "args", "ui", "use", "e", "unit", "form", "storage", "body", "message"], "pb": ["pc", "wp", "ab", "plugin", "eb", "txt", "db", "fp", "jp", "platform", "vp", "pl", "bm", "stab", "sb", "pm", "bp", "cb", "bc", "cp", "hub", "lp", "wb", "ctx", "fc", "xb", "lb", "nb", "PB", "parser", "dp", "pg", "gb", "rob", "summary", "kb", "pkg", "bf", "bps", "sub", "abi", "pa", "bot", "buf", "fb", "bh", "lc", "primary", "rb", "tmp", "p", "b", "prot", "uf", "np", "ub", "pt", "lab", "ib", "typ"], "pd": ["pc", "wp", "plugin", "DP", " disp", "dd", "db", "pid", "cdn", "data", "gd", " def", "pod", "td", "px", "md", "pe", "edd", " dc", "pm", "hd", "cp", "lp", "vd", "dt", "dl", "ld", " data", " ta", "wd", " prod", "sd", "bb", "PB", "po", "dp", "pg", "wk", "d", " d", "pp", " sd", "pkg", "pi", " da", "bd", "ad", "fd", "pa", "raf", "xd", " dd", "PD", "p", "cmd", "da", "ud", "ppa", "od", " rc", "cd", " cd", " td", " cp", " df", "py", "tp", " DP", "np", "ds"]}}
{"project": "qemu", "commit_id": "3736cc5be31f0399999e37d8b28ca9a3ed0b4ccb", "target": 0, "func": "static int nbd_negotiate_options(NBDClient *client, Error **errp)\n\n{\n\n    uint32_t flags;\n\n    bool fixedNewstyle = false;\n\n\n\n    /* Client sends:\n\n        [ 0 ..   3]   client flags\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n\n\n        [ 0 ..   7]   NBD_OPTS_MAGIC\n\n        [ 8 ..  11]   Second NBD option\n\n        [12 ..  15]   Data length\n\n        ...           Rest of request\n\n    */\n\n\n\n    if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) {\n\n        error_prepend(errp, \"read failed: \");\n\n        return -EIO;\n\n    }\n\n    trace_nbd_negotiate_options_flags();\n\n    be32_to_cpus(&flags);\n\n    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {\n\n        trace_nbd_negotiate_options_newstyle();\n\n        fixedNewstyle = true;\n\n        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;\n\n    }\n\n    if (flags & NBD_FLAG_C_NO_ZEROES) {\n\n        trace_nbd_negotiate_options_no_zeroes();\n\n        client->no_zeroes = true;\n\n        flags &= ~NBD_FLAG_C_NO_ZEROES;\n\n    }\n\n    if (flags != 0) {\n\n        error_setg(errp, \"Unknown client flags 0x%\" PRIx32 \" received\", flags);\n\n        return -EIO;\n\n    }\n\n\n\n    while (1) {\n\n        int ret;\n\n        uint32_t option, length;\n\n        uint64_t magic;\n\n\n\n        if (nbd_read(client->ioc, &magic, sizeof(magic), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        magic = be64_to_cpu(magic);\n\n        trace_nbd_negotiate_options_check_magic(magic);\n\n        if (magic != NBD_OPTS_MAGIC) {\n\n            error_setg(errp, \"Bad magic received\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (nbd_read(client->ioc, &option,\n\n                     sizeof(option), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        option = be32_to_cpu(option);\n\n\n\n        if (nbd_read(client->ioc, &length, sizeof(length), errp) < 0) {\n\n            error_prepend(errp, \"read failed: \");\n\n            return -EINVAL;\n\n        }\n\n        length = be32_to_cpu(length);\n\n\n\n        trace_nbd_negotiate_options_check_option(option);\n\n        if (client->tlscreds &&\n\n            client->ioc == (QIOChannel *)client->sioc) {\n\n            QIOChannel *tioc;\n\n            if (!fixedNewstyle) {\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n            switch (option) {\n\n            case NBD_OPT_STARTTLS:\n\n                tioc = nbd_negotiate_handle_starttls(client, length, errp);\n\n                if (!tioc) {\n\n                    return -EIO;\n\n                }\n\n                object_unref(OBJECT(client->ioc));\n\n                client->ioc = QIO_CHANNEL(tioc);\n\n                break;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                /* No way to return an error to client, so drop connection */\n\n                error_setg(errp, \"Option 0x%x not permitted before TLS\",\n\n                           option);\n\n                return -EINVAL;\n\n\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_TLS_REQD,\n\n                                                 option, errp,\n\n                                                 \"Option 0x%\" PRIx32\n\n                                                 \"not permitted before TLS\",\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                /* Let the client keep trying, unless they asked to\n\n                 * quit. In this mode, we've already sent an error, so\n\n                 * we can't ack the abort.  */\n\n                if (option == NBD_OPT_ABORT) {\n\n                    return 1;\n\n                }\n\n                break;\n\n            }\n\n        } else if (fixedNewstyle) {\n\n            switch (option) {\n\n            case NBD_OPT_LIST:\n\n                ret = nbd_negotiate_handle_list(client, length, errp);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n\n\n            case NBD_OPT_ABORT:\n\n                /* NBD spec says we must try to reply before\n\n                 * disconnecting, but that we must also tolerate\n\n                 * guests that don't wait for our reply. */\n\n                nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, option, NULL);\n\n                return 1;\n\n\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            case NBD_OPT_STARTTLS:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                if (client->tlscreds) {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_INVALID,\n\n                                                     option, errp,\n\n                                                     \"TLS already enabled\");\n\n                } else {\n\n                    ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                     NBD_REP_ERR_POLICY,\n\n                                                     option, errp,\n\n                                                     \"TLS not configured\");\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            default:\n\n                if (nbd_drop(client->ioc, length, errp) < 0) {\n\n                    return -EIO;\n\n                }\n\n                ret = nbd_negotiate_send_rep_err(client->ioc,\n\n                                                 NBD_REP_ERR_UNSUP,\n\n                                                 option, errp,\n\n                                                 \"Unsupported option 0x%\"\n\n                                                 PRIx32,\n\n                                                 option);\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n                break;\n\n            }\n\n        } else {\n\n            /*\n\n             * If broken new-style we should drop the connection\n\n             * for anything except NBD_OPT_EXPORT_NAME\n\n             */\n\n            switch (option) {\n\n            case NBD_OPT_EXPORT_NAME:\n\n                return nbd_negotiate_handle_export_name(client, length, errp);\n\n\n\n            default:\n\n                error_setg(errp, \"Unsupported option 0x%\" PRIx32, option);\n\n                return -EINVAL;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 8988, "substitutes": {"client": ["parent", "cdn", "man", "co", "connect", "product", "worker", "chrome", "conn", "open", "http", "public", "net", "project", "container", "con", "Client", "c", "service", "config", "server", "output", "app", "cli", "local", "queue", "request", "cod", "socket", "manager", "host", "resource", "call", "ce", "current", "connection", "remote", "response", "google", "input", "bird", "user", "port", "patch", "custom", "pc", "get", "plugin", "self", "command", "api", "ip", "clean", "image", "cache", "cell", "cmd", "cart", "pattern"], "errp": ["erp", "irP", "bugpa", " errP", "reqpe", "aerping", "eerpa", "ererproc", "eerpo", "interfp", "herepa", "herps", "arrf", "reqf", "reqp", "arrpe", "asterpa", "innerping", "ferp", "yrpost", " errapi", "herepe", "errf", "erpa", "erP", "bugpost", "errback", "eerfp", "herping", "erfp", "erpo", "herp", "ferpre", "derP", "ererfp", "ferf", "errpre", "drpre", "irfp", "errps", "serverp", "asterP", " errping", "interpre", "herpath", " errf", "errorpre", "herepost", "derf", "errpi", "derpc", "asterf", "ererp", "aerps", "irp", "eorback", "orderfp", "innerpath", "errpp", "drproc", "herep", "ErrorP", "interp", "erpi", "Errorf", "errorp", "errping", "rrpre", "errorapi", "errsp", "asterpo", "reqpp", "errP", "eorp", "errpc", "errproc", " errb", "orderp", "intersp", "bugp", "asterpc", "errpo", "aerpath", "yrpe", "irpi", "serverf", "errb", "ersp", "rrfp", "eerp", "errfp", "arrpp", "yrpa", "derp", "asterfp", "errorping", "drfp", "errorf", "errpe", " errpp", "ererpre", "erpre", "serverb", " errpc", "innerps", " errpe", "errapi", "errpost", "innerp", "rrp", "drp", "errorb", "orderpi", "erproc", " errpre", "errpa", "yrp", "serverapi", "ferping", "errpath", "arrp", "Errorp", "eorP", "bugpe", "aerp", "eorf", "Errorback", "rrsp", "orderP", "asterp", " errback"], "flags": ["vals", "styles", "utils", "flag", "ds", "includes", "strings", "members", "features", "heads", "stats", "links", "alls", "fields", "fd", "files", "requires", "ils", "filename", "ops", "ports", "lists", "mask", "config", "ants", "status", "reports", "xml", "versions", "lins", "bits", "args", "lag", "planes", "types", "errors", "f", "plugins", "tools", "FLAG", "Flags", "items", "values", "rules", "ints", "bugs", "caps", "properties", "fps", "states", "services", " Flags", "ags", "locks", "codes", "groups", "details", "bytes", "allows", "ips", "options", "fs", "comments", "feat", "settings", "atts", "ssl", "events", "fee"], "ret": ["count", " num", "flag", "ry", "val", " resp", " success", "nt", "Ret", " Ret", "num", " result", " count", " flag", "res", "al", "rc", " r", "rep", " rc", "RET", " RET", "result", " res", "success"], "option": ["element", "ion", "session", "Option", "term", "timeout", "optional", "operation", "section", "prefix", "key", "color", "open", "ban", "update", "block", "ption", "other", "config", "optim", "package", "global", "value", "number", "loc", "search", "cho", "array", "op", "large", "entry", "version", "index", "opt", "route", "name", "connection", "event", "feature", "example", "item", "object", "function", "put", "position", "error", "offset", "type", "lock", "pair", "single", "options", "image", "weight", "pin"], "length": ["count", "zip", "element", "level", "library", "character", "delay", "len", "section", "view", "id", "model", "tag", "mount", "total", "filename", "block", "data", "limit", "max", "config", "value", "number", "style", "loc", "Length", "serial", "sequence", "select", "padding", "label", "child", "slice", "size", "version", "duration", "function", "full", "patch", "pull", "available", "position", "error", "list", "type", "tail", "lock", "build", "options", "url", "text", "weight", "partial", "family", "range"], "magic": ["cookie", "base", "number", "dom", "iso", "prefix", "complex", "temp", "model", "http", "missing", "stat", "memory", "money", "big", "data", "config", "time", "meta", "ix", "generic", "status", "script", "secret", "action", "mic", "bug", "serial", "mini", "xxx", "agic", "padding", "style", "binary", "progress", "version", "size", "module", "inc", "format", "example", "bot", "token", "patch", "custom", "special", "unknown", "icon", "spec", "git", "init", "plugin", "lock", "type", "tech", "year", "Magic", "extra", "math", "cache", "agent", "currency", "image", "mag", "security", "power"]}}
{"project": "qemu", "commit_id": "2b48e10f888059a98043b4816769fa2a326a1d2c", "target": 0, "func": "static TranslationBlock *tb_alloc(target_ulong pc)\n\n{\n\n    TranslationBlock *tb;\n\n    TBContext *ctx;\n\n\n\n    assert_tb_locked();\n\n\n\n    tb = tcg_tb_alloc(&tcg_ctx);\n\n    if (unlikely(tb == NULL)) {\n\n        return NULL;\n\n    }\n\n    ctx = &tcg_ctx.tb_ctx;\n\n    if (unlikely(ctx->nb_tbs == ctx->tbs_size)) {\n\n        ctx->tbs_size *= 2;\n\n        ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size);\n\n    }\n\n    ctx->tbs[ctx->nb_tbs++] = tb;\n\n    tb->pc = pc;\n\n    tb->cflags = 0;\n\n    tb->invalid = false;\n\n    return tb;\n\n}\n", "idx": 1621, "substitutes": {"pc": ["PC", "fc", "cs", "lp", "anc", "cc", "mc", "prot", "ping", "type", "nc", "pg", "bc", "mi", "pb", "tc", "platform", "ocol", "toc", "mac", "ac", "project", "pid", "pointer", "func", "ec", "asc", "dc", "pa", "c", "p", "xc", "arc", "lc", "cpu", "oc", "sc", "ca", "pm", "sec", "amp", "vc", "point", "bp", "tz", "val", "pt", "uc", "rc", "port"], "tb": [" tbh", "tbl", "tbb", " tcb", "Tbh", "ttbh", " tbb", " tbase", "rtbs", "itbs", "Tbs", "Tb", "tsb", "Tbase", "ftbb", "tbe", "ttb", "tpb", "ttcb", "itfb", " tbl", "ttbs", "ttab", " tab", "ftab", "tbs", "ttbl", "tab", "rtpb", "fbs", "etbs", "itb", "ttbb", "rb", "rbl", "ftb", "ctbs", "ttbe", "rtab", "rbb", "etpb", "tbase", "Tbb", "tsbl", "Tcb", " tpb", "fbb", " tbs", "tbh", "fcb", "tsbb", "tfb", " tbe", "ctbase", " tfb", "etb", "ftcb", "fb", "ctbb", "rtb", "rbs", "tcb", "ctb", "etab", "itab", "etfb", "tsbe"], "ctx": ["fc", "cm", "cms", "cli", "cam", "cs", "kb", "hw", "conn", "context", "mc", "cc", "gc", "anc", "Context", "fw", "acl", "loc", "ct", "co", "nc", "bc", "voc", "tc", "cus", "cas", "fp", "tx", "cb", "kw", "config", "pkg", "cu", "c", "cv", "xc", "css", "lc", "cn", "ca", "ctrl", "sq", "sc", "jp", "git", "cmd", "sys", "exec", "vc", "cca", "qa", "cp", "cmp", "rx", "cf", "conv", "ci", "cfg", "sci", "wp", "gp", "rc"]}}
{"project": "qemu", "commit_id": "3435f39513a104294b5e3bbf3612047028d25cfc", "target": 0, "func": "void qemu_ram_remap(ram_addr_t addr, ram_addr_t length)\n\n{\n\n    RAMBlock *block;\n\n    ram_addr_t offset;\n\n    int flags;\n\n    void *area, *vaddr;\n\n\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        offset = addr - block->offset;\n\n        if (offset < block->length) {\n\n            vaddr = block->host + offset;\n\n            if (block->flags & RAM_PREALLOC_MASK) {\n\n                ;\n\n            } else if (xen_enabled()) {\n\n                abort();\n\n            } else {\n\n                flags = MAP_FIXED;\n\n                munmap(vaddr, length);\n\n                if (mem_path) {\n\n#if defined(__linux__) && !defined(TARGET_S390X)\n\n                    if (block->fd) {\n\n#ifdef MAP_POPULATE\n\n                        flags |= mem_prealloc ? MAP_POPULATE | MAP_SHARED :\n\n                            MAP_PRIVATE;\n\n#else\n\n                        flags |= MAP_PRIVATE;\n\n#endif\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, block->fd, offset);\n\n                    } else {\n\n                        flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                    flags, -1, 0);\n\n                    }\n\n#else\n\n                    abort();\n\n#endif\n\n                } else {\n\n#if defined(TARGET_S390X) && defined(CONFIG_KVM)\n\n                    flags |= MAP_SHARED | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_EXEC|PROT_READ|PROT_WRITE,\n\n                                flags, -1, 0);\n\n#else\n\n                    flags |= MAP_PRIVATE | MAP_ANONYMOUS;\n\n                    area = mmap(vaddr, length, PROT_READ | PROT_WRITE,\n\n                                flags, -1, 0);\n\n#endif\n\n                }\n\n                if (area != vaddr) {\n\n                    fprintf(stderr, \"Could not remap addr: \"\n\n                            RAM_ADDR_FMT \"@\" RAM_ADDR_FMT \"\\n\",\n\n                            length, addr);\n\n                    exit(1);\n\n                }\n\n                memory_try_enable_merging(vaddr, length);\n\n                qemu_ram_setup_dump(vaddr, length);\n\n            }\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 12145, "substitutes": {"addr": ["setup", "alias", "adr", "Address", "seq", "arr", "base", "location", "ack", "active", "len", "section", "ord", "prefix", "region", "alt", "src", "open", "pointer", "ref", "add", " address", "coord", "ace", "attr", "amd", "ptr", "loc", "frame", "args", "array", "padding", "dr", "mode", "host", "code", "db", "ha", "slice", "shape", "amp", "route", "oa", "order", "rc", "name", "align", "remote", "state", "address", "node", "layer", "pos", "ip", "url", "arrow", "buffer"], "length": ["count", "l", "base", "section", "pad", "path", "angle", "loc", "body", "code", "duration", "end", "port", "type", "form", "row", "url", "text", "total", "limit", "Length", "large", "sequence", "padding", "slice", "format", "distance", "limited", "load", "position", "layer", "build", "partial", "join", "range", "seq", "ext", "len", "collection", "ptr", "style", "host", "size", "shape", "L", "part", "available", "tail", "level", "valid", "capacity", "ength", "filename", "line", "number", "child", "name", "address", "null", "loop", "match", "family"], "block": ["map", "un", "Block", "session", "byte", "base", "ack", "section", "comment", "record", "def", "view", "board", "point", "blocking", "container", "panel", "job", "line", "config", "ref", "work", "run", "exec", "number", "frame", "group", "flow", "network", "none", "bc", "label", "unit", "device", "bl", "slice", "name", "space", "clock", "event", "wall", "object", "pre", "address", "blocks", "error", "list", "node", "plugin", "link", "type", "lock", "ip", "row", "image", "cache", "down", "buffer", "box", "range", "chain"], "offset": ["count", "alias", "seq", "location", "timeout", "base", "delay", "initial", "start", "len", "prefix", "info", "origin", "shift", "pointer", "phase", "slot", "adding", "limit", "ref", "adjust", "layout", "target", "skip", "number", "ptr", "loc", "array", "off", "next", "padding", "entry", "host", "alpha", "o", "index", "alloc", "size", "slice", "order", "connection", "align", "address", "port", "part", "position", "error", "type", "layer", "pos", "gap", "Offset", "range", "fee"], "flags": ["count", "tags", "styles", "utils", "strings", "links", "parts", "xml", "lag", "errors", "plugins", "fl", "Flags", "shared", "state", " Flags", "codes", "groups", "details", "type", "ips", "forces", "settings", "atts", "vals", "lf", "flag", "aps", "sf", "ils", "s", "bits", "args", "lines", "pages", "types", "f", "padding", "FLAG", "rules", "tracks", "format", "properties", "ags", "locks", "blocks", "bytes", "allows", "this", "comments", "fs", "fee", "frames", "len", "features", "stats", "mods", "alls", "ages", "ops", "rights", "lists", "data", "ants", "offs", "size", "items", "ats", "als", "ases", "level", "rows", "fields", "files", "ports", "mask", "relations", "planes", "states", "els", "faces", "options", "feat", "events"], "area": ["alias", "sea", "atter", "va", "location", "ui", "base", "ATA", "up", "scale", "section", "access", "media", "region", "ba", "usa", "instance", "shadow", "ra", "data", "apa", "qa", "ata", "aaa", "memory", "aster", "array", " areas", "loc", "mode", "la", "alpha", "ha", "size", "oa", "AA", "issa", "name", "space", "state", "item", "object", "address", "az", "part", "storage", "radius", "Area", "aria", "layer", "aa", "handler", "ca", "volume", "a", "gap", "image", "range"], "vaddr": ["faddr", "waddr", "wenter", "venter", " vrf", "Verror", " vserver", "svaddr", "svaddress", "vhost", "vserver", "vattr", "woffset", "varea", "svattr", "lvarea", "lvoffset", "Vhost", "vnode", "svoffset", "voffset", " vhost", " vnode", "lserver", "hrf", "lerror", "fadd", " vaddress", "wattr", " varea", "vadd", "fadr", "Vserver", "evhost", "wmac", "fhost", " voffset", "frf", "evaddress", "evnode", "svhost", "svadr", "foffset", "vadr", "whost", "videoaddress", "wadr", "faddress", "vrf", "vmac", "videonode", "hhost", "videoenter", "vaddress", " venter", "verror", "lvaddress", " vmac", "eventer", "laddr", "lvaddr", "sventer", "haddress", "Vaddr", "Vaddress", "Varea", "fmac", "evadd", "waddress", "evaddr", " vattr", "videoaddr", "Vadd", "Voffset", "laddress", " verror", "haddr"]}}
{"project": "qemu", "commit_id": "871d2f079661323a7645b388eb5ae8d7eeb3117c", "target": 0, "func": "static void bdrv_put_buffer(void *opaque, const uint8_t *buf,\n\n                            int64_t pos, int size)\n\n{\n\n    QEMUFileBdrv *s = opaque;\n\n    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);\n\n}\n", "idx": 26113, "substitutes": {"opaque": ["opedaco", "opedonymous", "opedcus", "operacity", "operonymous", "operaque", "opaco", "ioponymous", " opcus", "iopaco", "oponymous", "oplaque", "operya", "oppya", "oplonymous", "opya", "opedaque", "oppaque", "iopaque", " oponymous", "oplya", "oplacity", " opaco", "opacity", "oppacity", "iopcus", "opponymous", "opcus"], "buf": ["seq", "uf", "b", "cv", "bb", "data", "buffer", "queue", "vec", "base", "rb", "config", "bf", "cb", "bc", "port", "bp", "raw", "cmd", "pb", "cap", "loc", "pool", "fb", "sb", "alloc", "Buffer", "len", "length", "buff", "f", "src", "fp", "func", "v", "fd"], "pos": ["ref", "seq", "neg", "slice", "Position", "i", "pt", "position", "data", "base", "pointer", "conf", "address", "type", "push", "end", "port", "pad", "POS", "padding", "val", "start", "axis", "lit", "loc", "pose", "offset", " position", "slot", "os", "cache", "addr", "off", "count", "limit", "index", "len", "pc", "Pos", "pid"], "size": ["code", "args", "z", "ize", "c", "empty", "sized", "name", "enc", "data", "send", "en", "sum", "address", "Size", "end", "e", "unit", "SIZE", "loc", "fee", "small", "offset", "mode", "sec", "scale", "length", "count", "bytes", "n", "iz", "len", "g"], "s": ["S", "rs", "ses", "socket", "sys", "w", "scope", "ss", "p", "b", "m", "c", "server", "ns", "sq", "ds", "opens", "ps", "sync", "self", "is", "e", "es", "gs", "o", "http", "peer", "session", "spec", "sym", "hs", "os", "services", "syn", "sa", "ls", "f", "service", "js", "your", "a", "core", "v", "sl", "settings", "ops", "ssl", "g"]}}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    float aspect;\n\n\n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    s->aspect_ratio_info= get_bits(&s->gb, 4);\n\n    if(!s->mpeg2){\n\n        aspect= mpeg1_aspect[s->aspect_ratio_info];\n\n        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);\n\n    }\n\n\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        avctx->has_b_frames= 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        if (s->frame_rate_index >= 9) {\n\n            /* at least give a valid frame rate (some old mpeg1 have this) */\n\n            avctx->frame_rate = 25 * FRAME_RATE_BASE;\n\n        } else {\n\n            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        }\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_intra_matrix[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_non_intra_matrix[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    avctx->sub_id = 1; /* indicates mpeg1 */\n\n    return 0;\n\n}\n", "idx": 60, "substitutes": {"avctx": ["akcas", "AVsrc", "afcontext", "avcus", "mpctx", "mpcontext", "aphcontext", "aphctx", "avglobal", "afcn", "avelc", "navsrc", "afloc", "avecas", "avkw", "abconfig", "avcontext", "aveloc", "navconn", "afcmd", "aphctrl", "akctx", "avecci", "allcontext", "afcmp", "AVcontext", "avcms", " avconn", "mpconfig", "avecu", "ovcontext", "alltx", "avectx", "avecf", "afctx", "navctx", "aveconn", "akcontext", " avcmp", "apbuf", "alllc", "avcf", "ovcmd", "aphcms", "avalconn", "afconn", "AVcms", "AVglobal", "avcn", "avconfig", "avalcontext", "aucontext", "ovkw", "auloc", "abcontext", "AVcmp", "allctx", "avecmp", "avcas", "avalctx", "airloc", " avcus", " avloc", "afcas", " avkw", "avtx", "abcmp", "aftx", "aircontext", "apcontext", "afglobal", "navctrl", "afkw", "afbuf", "auctx", "ovctx", "abctx", "aucn", "avctrl", "afcu", "afcf", "aflc", "avsrc", "mpcmp", "avecus", "apconn", "afconfig", "AVctx", " avglobal", "avcmd", "avbuf", " avbuf", "avconn", "AVctrl", "avalcci", "navcms", "AVconn", " avcontext", "afcci", "avcci", "afcus", "avalcu", "apctx", "navcontext", "avetx", "avloc", "akcf", "airconn", " avcmd", "avecontext", "avcu", " avcn", "avlc", "avcmp", "airctx", "avalsrc"], "buf": ["fd", "src", "buffer", "ctx", "bn", "byte", "sb", "queue", "data", "ab", "bc", "buff", "bin", "pb", "num", "batch", "rb", "fp", "cb", "config", "raw", "block", "cv", "vec", "nb", "bd", "ref", "cache", "gb", "cmd", "alloc", "fb", "b", "seq", "conv", "uf", "img", "rc", "mem"], "buf_size": ["buf_align", "buflexsize", "imglexsize", "wav_SIZE", "wavetSIZE", "bufetlen", "wav_size", "wavetlen", "imglexdepth", "bufetsize", "buf_SIZE", "buflexdepth", "img_align", "buflexalign", "wavetsize", "wav_shape", "buf_shape", "buf_len", "img_depth", "wav_len", "bufetshape", "img_size", "wavetshape", "bufetSIZE", "buf_depth", "imglexalign"], "s1": ["wsone", "ws1", " s0", "s0", "qsOne", " sOne", "scone", "cs2", "s01", "sc11", "s11", "svone", "sone", "S01", "SOne", "qsone", "sv01", "c11", "cOne", "ws11", "s2", " s2", "Sone", "qs01", "sOne", "c1", "cs1", "sc1", "csOne", "cs0", "S1", "qs1", "c2", "c0", "ws2", "cone", "sv1", "sc2", "svOne"], "s": ["sg", "js", "qs", "n", "sl", "client", "g", "ses", "ls", "sf", "args", "storage", "us", "f", "secondary", "sys", "u", "your", "an", "se", "fs", "parts", "sup", "spec", "ts", "sb", "aws", "y", "xs", "sets", "p", "e", "conf", "su", "site", "S", "t", "ks", "os", "session", "serv", "its", "hs", "sym", "plugins", "ssl", "cs", "ctx", "ss", "a", "rs", "new", "r", "is", "ins", "bis", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "south", "o", "si", "server", "service", "ops", "d", "sk", "comments", "sync", "l", "services", "w", "sq", "b", "full", "states"], "height": ["resolution", "capacity", "device", "dim", "head", "stroke", "ty", "png", "lat", "direction", "home", "alpha", "pages", "manager", "arrow", "rh", "ows", "Height", "host", "image", "ht", "ui", "id", "html", "xy", "gap", "y", "max", "gallery", "mac", "layout", "length", "inches", "driver", "huge", "bottom", "input", "gh", "media", "crop", "version", "build", "above", "fw", "data", "tight", "slice", "h", "pad", "deep", "rank", "size", "rows", "history", "definition", "times", "img", "volume", "shape", "timeout", "total", "gpu", "def", "high", "window", "d", "devices", "distance", "show", "th", "grow", "duration", "dy", "hung", "style", " heights", "thin", "w", "density", "padding", "container", "depth", "dist"], "i": ["ii", "pi", "d", "n", "I", "mi", "it", "k", "y", "m", "info", "z", "ai", "x", "h", "l", "p", "c", "f", "u", "b", "ci", "io", "si", "in"], "v": ["q", "vt", "r", "d", "n", "video", "k", "y", "g", "m", "sv", "z", "h", "l", "c", "p", "w", "e", "f", "u", "V", "o", "b", "t", "va", "volume"], "j": ["js", "adj", "q", "ji", "r", "n", "J", "k", "aj", "ij", "y", "g", "pos", "m", "z", "ch", "h", "l", "x", "p", "w", "jp", "obj", "o", "b"], "aspect": ["Aspect", "exct", "aspec", "acess", "masspect", "act", "Asception", "Aspects", "asspects", "assct", "apects", "apec", "asspect", "ASpect", "raspecting", "expecting", "ASception", "maspect", "expect", " aspec", "maspects", "aspir", " asception", "ASpec", "ASpects", " ascess", "assspect", "asspecting", "asspir", "asception", "raspect", "apir", " asct", " aspir", "aspecting", "apect", "maspec", "Aspec", "rasct", "aspects", "asspec", "asscess", "exspect", "rasspect", "ascess", " aspects", "asct"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static int bdrv_qed_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    QEDHeader le_header;\n\n    int64_t file_size;\n\n    int ret;\n\n\n\n    s->bs = bs;\n\n    QSIMPLEQ_INIT(&s->allocating_write_reqs);\n\n\n\n    ret = bdrv_pread(bs->file, 0, &le_header, sizeof(le_header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qed_header_le_to_cpu(&le_header, &s->header);\n\n\n\n    if (s->header.magic != QED_MAGIC) {\n\n        error_setg(errp, \"Image not in QED format\");\n\n        return -EINVAL;\n\n    }\n\n    if (s->header.features & ~QED_FEATURE_MASK) {\n\n        /* image uses unsupported feature bits */\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"%\" PRIx64,\n\n            s->header.features & ~QED_FEATURE_MASK);\n\n        error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n            bdrv_get_device_name(bs), \"QED\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n    if (!qed_is_cluster_size_valid(s->header.cluster_size)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Round down file size to the last cluster */\n\n    file_size = bdrv_getlength(bs->file);\n\n    if (file_size < 0) {\n\n        return file_size;\n\n    }\n\n    s->file_size = qed_start_of_cluster(s, file_size);\n\n\n\n    if (!qed_is_table_size_valid(s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_is_image_size_valid(s->header.image_size,\n\n                                 s->header.cluster_size,\n\n                                 s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_check_table_offset(s, s->header.l1_table_offset)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    s->table_nelems = (s->header.cluster_size * s->header.table_size) /\n\n                      sizeof(uint64_t);\n\n    s->l2_shift = ffs(s->header.cluster_size) - 1;\n\n    s->l2_mask = s->table_nelems - 1;\n\n    s->l1_shift = s->l2_shift + ffs(s->table_nelems) - 1;\n\n\n\n    /* Header size calculation must not overflow uint32_t */\n\n    if (s->header.header_size > UINT32_MAX / s->header.cluster_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if ((s->header.features & QED_F_BACKING_FILE)) {\n\n        if ((uint64_t)s->header.backing_filename_offset +\n\n            s->header.backing_filename_size >\n\n            s->header.cluster_size * s->header.header_size) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        ret = qed_read_string(bs->file, s->header.backing_filename_offset,\n\n                              s->header.backing_filename_size, bs->backing_file,\n\n                              sizeof(bs->backing_file));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (s->header.features & QED_F_BACKING_FORMAT_NO_PROBE) {\n\n            pstrcpy(bs->backing_format, sizeof(bs->backing_format), \"raw\");\n\n        }\n\n    }\n\n\n\n    /* Reset unknown autoclear feature bits.  This is a backwards\n\n     * compatibility mechanism that allows images to be opened by older\n\n     * programs, which \"knock out\" unknown feature bits.  When an image is\n\n     * opened by a newer program again it can detect that the autoclear\n\n     * feature is no longer valid.\n\n     */\n\n    if ((s->header.autoclear_features & ~QED_AUTOCLEAR_FEATURE_MASK) != 0 &&\n\n        !bdrv_is_read_only(bs->file) && !(flags & BDRV_O_INCOMING)) {\n\n        s->header.autoclear_features &= QED_AUTOCLEAR_FEATURE_MASK;\n\n\n\n        ret = qed_write_header_sync(s);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* From here on only known autoclear feature bits are valid */\n\n        bdrv_flush(bs->file);\n\n    }\n\n\n\n    s->l1_table = qed_alloc_table(s);\n\n    qed_init_l2_cache(&s->l2_cache);\n\n\n\n    ret = qed_read_l1_table_sync(s);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* If image was not closed cleanly, check consistency */\n\n    if (!(flags & BDRV_O_CHECK) && (s->header.features & QED_F_NEED_CHECK)) {\n\n        /* Read-only images cannot be fixed.  There is no risk of corruption\n\n         * since write operations are not possible.  Therefore, allow\n\n         * potentially inconsistent images to be opened read-only.  This can\n\n         * aid data recovery from an otherwise inconsistent image.\n\n         */\n\n        if (!bdrv_is_read_only(bs->file) &&\n\n            !(flags & BDRV_O_INCOMING)) {\n\n            BdrvCheckResult result = {0};\n\n\n\n            ret = qed_check(s, &result, true);\n\n            if (ret) {\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    bdrv_qed_attach_aio_context(bs, bdrv_get_aio_context(bs));\n\n\n\nout:\n\n    if (ret) {\n\n        qed_free_l2_cache(&s->l2_cache);\n\n        qemu_vfree(s->l1_table);\n\n    }\n\n    return ret;\n\n}\n", "idx": 17953, "substitutes": {"bs": ["ns", "ms", "status", "ab", "stat", "bi", "ts", "ros", "lbs", "stats", "rs", "aws", "base", "settings", "ubs", "sb", "cb", "bc", "ls", "ss", "src", "bt", "pb", "lb", "bb", "fs", "bid", "cs", "css", "als", "gb", "bos", "bot", "ins", "obs", "outs", "BS", "iss", "blocks", "bis", "bl", "vs", "bas", "ses", "bh", "ps", "fb", "js", "bits", "b", "ks", "http", "gs", "es", "bytes", "os", "state", "bes", "us", "sa", "ds", "bing"], "options": ["ts", "ch", "stats", "info", "conf", "obj", "settings", "op", "io", "details", "cb", "ops", "fs", "o", "cs", "linux", "args", "outs", "config", "js", "bits", "lib", "fn", "opt", "os", "Options", "params"], "flags": ["status", "ts", "stats", "data", "mode", "settings", "Flags", "reg", "flag", "ips", "files", "ints", "utils", "ops", "fs", "mask", "cs", "args", "features", "config", "bits", "errors", "reads", "bytes", "parts", "opens", "len"], "errp": [" errP", "acerpe", " errfp", "acerp", "erfp", "rorP", "acerpb", "nerpc", "err", "errP", "derpb", "errpc", "acerv", "errv", "derpe", "rorfp", "derp", "Erpb", "errpb", "nerr", "erpc", "erp", "Erv", "errr", "errpo", "derv", "nerp", "errpe", "errfp", " errr", "erP", "Erpe", "erpo", " errpc", " errpo", "rorpo", "rorp", "Erp", "nerP"], "s": ["ns", "spec", "strings", "settings", "service", "ss", "cs", "d", "new", "qs", "sym", "p", "ks", "h", "us", "sets", "sa", "ms", "m", "ts", "sg", "rs", "self", "o", "su", "v", "si", "S", "uses", "a", "ds", "uns", "f", "sv", "r", "sb", "as", "l", "ins", "bis", "vs", "sync", "c", "ps", "rows", "b", "sys", "es", "state", "states", "sq", "session", "t", "stats", "conf", "services", "g", "i", "sl", "ls", "ops", "fs", "xs", "is", "args", "site", "e", "ssl", "ses", "js", "http", "gs", "its", "os", "parts", "u"], "le_header": ["ile_bridge", "le_dr", "ile_name", "le___handler", "le___head", "le_buffer", "LE_header", "LE_handler", "le_bridge", "ele_cover", "le_cover", " le_buffer", "le_manager", "le_head", " le_layer", " le_dr", "le_layer", "le_name", "ele_header", "ele_head", "LE_head", "le_handler", "ile_header", "ele_manager", "LE_pair", "ile_layer", "le___header", "le_pair", "le___pair"], "file_size": ["table_sized", "table_Size", "fileFsize", "file64error", "file_name", "file_source", "fileacsize", "file___source", "ile_name", "ile_align", "table_depth", "file_align", "fieldaclen", "fileperror", "file\u00b7align", "field_range", " file_length", "file_sn", "ile_adjust", "fieldacsize", "field_len", "files_size", "fileFsn", "file_sized", "filelexsource", "file_depth", "file\u00b7size", "file_adjust", "ile_size", "filelexlength", "file64size", "file\u00b7adjust", "filelexsize", "fileFrange", " file_source", "file_location", "file___size", "file___Size", "field_sn", "file64speed", "file___length", "filepspeed", "file\u00b7name", " file_speed", "fieldacsn", "fileFlen", "fileaclen", "fileacsn", "file_error", "field_size", "fileacrange", "file_len", "files_Size", "table_size", "fieldacrange", "file_speed", "files_name", "filelexlocation", "file___sized", "file_Size", "file___location", "file___depth", "file_length", "files_sized", "filepsize", "file_range", " file_error", " file_location"], "ret": ["status", "offset", "code", "t", "data", "x", "bit", "f", "al", "alt", "ref", "let", "err", "rc", "nt", "lit", "reg", "rt", "fun", "result", "num", "flag", "match", "pass", "ext", "fin", "run", "def", "rets", "en", "count", "out", "art", "att", "arr", "val", "re", "Ret", "fail", " RET", "no", "back", "det", "rl", " Ret", "RET", "pat", "error", "pet", "res", "mt", "ft", "reply", "pt", "success", "len"], "buf": ["bin", "br", "ff", "data", "text", "fp", "wrap", "ref", "buffer", "rc", "vec", "fi", "result", "cf", "exc", "block", "cb", "bc", "loc", "src", "msg", "wb", "ctx", "raw", "mem", "byte", "header", "path", "feat", "aux", "config", "queue", "fd", "buff", "fb", "temp", "rb", "seq", "cmd", "uc", "tmp", "pad", "doc", "b", "cap", "la", "alloc", "proc", " buffer", "bytes", "addr", "bag", "uf", "cv"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            TAILQ_REMOVE(&savevm_handlers, se, entry);\n\n            qemu_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 25370, "substitutes": {"vmsd": ["vmesds", "hmsdh", "vssdl", "vmasd", "varesd", "vimsds", " vksdy", " vksdc", "vmsdc", "vmsdy", "vmsD", "vmmhd", "vmmd", "vmasdm", "varesdy", "varesdc", "vmasdh", "vemsdh", " vmshd", "vmsdh", " vmsD", "hmesd", "vmesdm", "hmsds", "vksd", " vmsdc", " vmsds", "hmesds", "vemsd", "vmesdh", " vmmds", "vsshd", "vmmds", " vmsdy", "hmsd", " vksd", "hmesdh", "vimsdl", " vmsdl", "vssds", "vmesd", "vmsds", "vimshd", " vksD", "varesD", " vmmd", "vmshd", "vmesdy", "vmmdl", " vmmdl", "vmasds", "vimsd", "vmsdm", " vmmhd", "vssd", "vmesD", "vemsdm", "vksdy", "vksdc", "hmsdm", "vksD", "hmesdm", "vmsdl", "vemsds", "vmesdc"], "opaque": ["octaques", " opifice", "opifice", "operacity", "oifice", "octga", "operaque", " opaques", "oity", "operity", "operaques", "oaque", "opga", "opaques", "opusacity", "oacity", "opity", "octacity", " opity", "copaques", "copity", "opusaque", "operga", "octaque", "Opaque", "Opaques", "opusaques", "operifice", " opacity", "copacity", "opacity", "opusity", "Opacity", "copaque", "Opga"], "se": ["ve", "sle", "sem", "ses", "sk", "see", "ie", "parse", "sh", "ae", "ge", "sed", "sea", "isse", "cle", "pe", "lex", "te", "so", "sche", "su", "SE", "ne", "e", "es", "sp", "ee", "pse", "s", "session", "ase", "ade", "si", "ser", "le", "sel", "sec", "sa", "serv", "service", "entry", "de", "be", "inse", "sl", "asse", "ke", "ce", "Se", "ze"], "new_se": ["new_parse", "current_se", "new_SE", " new_sem", " new_parse", "new_sem", "new_sche", "current_sche", " new_SE", "current_parse", "new_sea", "current_sea"]}}
{"project": "qemu", "commit_id": "447b0d0b9ee8a0ac216c3186e0f3c427a1001f0c", "target": 1, "func": "static void flatview_ref(FlatView *view)\n\n{\n\n    atomic_inc(&view->ref);\n\n}\n", "idx": 19809, "substitutes": {"view": ["entry", "child", "name", "image", "comment", "action", "show", "see", "block", "match", "face", "node", "package", "index", "model", "watch", "object", "page", "link", "alias", "event", "build", "style", "use", "seen", "client", "update", "layout", "url", "feature", "http", "route", "VIEW", "form", "row", "template", "project", "server", "View", "source"]}}
{"project": "FFmpeg", "commit_id": "582552fb56ba6559cb1d094a7e7ae5dde3073c5c", "target": 0, "func": "static int altivec_uyvy_rgb32 (SwsContext *c,\n\n\t\t\t       unsigned char **in, int *instrides,\n\n\t\t\t       int srcSliceY,\tint srcSliceH,\n\n\t\t\t       unsigned char **oplanes, int *outstrides)\n\n{\n\n  int w = c->srcW;\n\n  int h = srcSliceH;\n\n  int i,j;\n\n  vector unsigned char uyvy;\n\n  vector signed   short Y,U,V;\n\n  vector signed   short vx,ux,uvx;\n\n  vector signed   short R0,G0,B0,R1,G1,B1;\n\n  vector unsigned char  R,G,B;\n\n  vector unsigned char *out;\n\n  ubyte *img;\n\n\n\n  img = in[0];\n\n  out = (vector unsigned char *)(oplanes[0]+srcSliceY*outstrides[0]);\n\n\n\n  for (i=0;i<h;i++) {\n\n    for (j=0;j<w/16;j++) {\n\n      uyvy = vec_ld (0, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R0,&G0,&B0);\n\n\n\n      uyvy = vec_ld (16, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R1,&G1,&B1);\n\n\n\n      R  = vec_packclp (R0,R1);\n\n      G  = vec_packclp (G0,G1);\n\n      B  = vec_packclp (B0,B1);\n\n\n\n      //      vec_mstbgr24 (R,G,B, out);\n\n      out_rgba (R,G,B,out);\n\n\n\n      img += 32;\n\n    }\n\n  }\n\n  return srcSliceH;\n\n}\n", "idx": 17615, "substitutes": {"c": ["dc", "pc", "oc", "m", "ch", "t", "f", "ct", "vc", "rc", "gc", "cm", "cf", "g", "cp", "ctx", "mc", "self", "ca", "cs", "context", "l", "d", "ce", "nc", "ac", "ci", "com", "tc", "xc", "con", "config", "e", "k", "cu", "sc", "cr", "w", "lc", "cur", "p", "b", "cache", "cit", "ec", "cd", "h", "cn", "co", "icc", "C", "y", "cc"], "in": ["m", "bin", "IN", "data", "inn", "din", "ini", "login", "ine", "r", "pin", "cm", "inc", "In", "pass", "index", "min", "inside", "up", "ins", "ac", "isin", "con", "config", "id", "cli", "include", "nin", "win", "a", "lin", "connection", "inner", "source", "conn", "input"], "instrides": ["inputstrides", "instiders", "inputstriders", "instrided", "inputstiders", "inputstide", "instide", "instride", "inStride", "inbrided", "inStrided", "inputstrided", "inputstided", "inputstides", "instriders", "inputstride", "inbriders", "inbrides", "instides", "inStrides", "instided", "inStriders", "inbride"], "srcSliceY": ["srcSlaceG", "srcSlaceY", "srcFliceW", "srcFliceG", "srcSlideG", "srcSlineG", "srcFlaceX", "srcFliceY", "srcSlideW", "srcFlaceY", "srcSliceX", "srcSliseW", "srcSliseX", "srcSlineY", "srcSlaceH", "srcSlaceW", "srcSlineW", "srcSlideX", "srcSlineH", "srcFlaceW", "srcSlideY", "srcSliseH", "srcFlaceG", "srcSliceG", "srcSlaceX", "srcSliseY", "srcFliceX", "srcSlineX", "srcSliceW"], "srcSliceH": ["srcSlaceY", "srcPlineH", "srcSlideN", "srcPliceH", "srcPliceY", "srcPlineW", "srcSlideW", "srcSlideH", "srcSliseW", "srcPliceN", "srcPliceL", "srcPliceW", "srcPlineL", "srcSlineY", "srcSliceL", "srcSlaceH", "srcSlaceW", "srcSlaceL", "srcSlaceN", "srcSlineW", "srcPlineY", "srcSliceN", "srcSlineH", "srcSlideY", "srcSlineN", "srcSliseH", "srcSliseL", "srcSliseY", "srcPlineN", "srcSliceW", "srcSlineL"], "oplanes": ["dylipes", "oplipes", "planes", "ospanes", "ospades", "ospides", "oplane", "oplides", "oclades", "oplips", "dylanes", "oblanes", "oclane", "plips", "oclides", "plane", "oblades", "oblides", "oblipes", "oblane", "plipes", "ospane", "oplades", "oblips", "dylane", "oclanes", "dylips"], "outstrides": ["Outstases", "Outstiding", "Outstades", "outSTRases", "outdrides", "outstriding", "outStriders", "outbrases", "outstides", "outbrides", "outbriders", "OutStriders", "Outstrades", "outbrades", "outStrides", "outStriding", "outSTRides", "outSTRiding", "Outstriders", "outbriding", "Outstrided", "outSTRades", "OutStrided", "outdriders", "Outstrides", "Outstriding", "outbrided", "outdrided", "OutStrides", "Outstrases", "outstrided", "outstrases", "outstiding", "outstases", "outStrided", "outstriders", "outstrades", "outstades", "outdriding", "Outstides", "OutStriding"], "i": ["gi", "m", "bi", "ji", "ami", "x", "f", "ini", "qi", "r", "ai", "mi", "n", "phi", "io", "z", "ii", "ori", "iu", "di", "index", "ie", "I", "vi", "zi", "is", "ip", "chi", "l", "d", "yi", "pi", "ui", "ci", "k", "e", "v", "ni", "si", "p", "xi", "b", "h", "a", "im", "eni", "y", "li", "u"], "j": ["jc", "jl", "ji", "ch", "t", "x", "jp", "f", "jit", "uj", "qi", "r", "n", "jj", "g", "je", "z", "ii", "jet", "ij", "ie", "di", "aj", "o", "l", "d", "dy", "w", "J", "k", "e", "v", "js", "p", "b", "h", "ja", "jam", "im", "y", "li", "u"], "uyvy": ["yuny", "ouppy", " blahny", "gyyo", "chyvy", "oyny", "kyvy", "uezy", "yuy", " uoy", "kydy", "ugdy", "hubzy", "yourvy", "uuoy", "uyvette", "hubny", "ugvey", " uvy", "zyzy", "chydy", "gyny", "youry", "uuzy", "zydy", "gycy", "uuvette", "uuny", "gyvy", "uevy", " blahvette", "chyzy", " uny", "zytsy", "hubtsy", "ouy", "uycy", "uyoy", "uyyo", "oyvey", "zyyo", "uytsy", "zyny", "ouvey", "ugvy", "ouny", "gruvy", "oyvy", "udvette", " blahvy", "kyvey", "gyvey", "ugy", "udvy", "uyvey", "ueny", " uvette", "zyvette", "kycy", "gruny", "uypine", "uetsy", "hubvy", "udzy", "ouvy", "kyy", "kyzy", "oyzy", "yourvey", "oypine", "gruovy", "uyovy", "hubvey", "uuyo", "uevey", "uyny", "oycy", "gyzy", "uyy", "uydy", "uupine", "uyppy", "zyvey", "hubppy", "ueppy", "gruy", "zypine", "uyzy", " blahoy", "ouovy", "yuovy", "chyvette", "yourdy", "yuvy", "uddy", "uuvy", "zyvy"], "Y": ["E", "IE", "Z", "My", "NY", "Up", "Hy", "Col", "T", "YC", "M", "YA", " y", "A", "N", "CH", "K", "YP", "Cy", "XY", "Q", "BY", "SH", "IO", "OU", "I", "IP", "cy", "Ty", "L", "Bu", "YY", "W", "Gy", "Yu", "Ni", "Ch", "YE", "J", "X", "Ky", "F", "D", "Py", "S", "MY", "O", "Year", "IA", "C", "H", "y", "P"], "U": ["UL", "LU", "UC", "Up", "US", "T", "Us", "M", "Su", "UP", "A", "N", "CU", "Q", "OU", "UU", "I", "UD", "L", "W", "Ut", "Lu", "UX", "X", "F", "D", "S", "O", "UV", "UR", "UID", "Ub", "Tu", "UI", " u", "C", "Cu", "H", "P", "MU", "u"], "V": ["E", "Val", "UL", "VA", "AV", "GV", "VT", "M", "CV", "N", "GU", "Q", "OU", "Iv", "I", "UD", "VER", "L", "W", "Vari", "Vs", "UX", "J", "X", "TV", "VC", "v", "F", "D", "VW", "S", "UV", "VK", "C", "H", "P", "VL"], "vx": ["Vy", "Vx", " vX", " vz", "VX", "vy", "uvz", "vX", "vz", "uvX", "Vz", " vy", "uvy"], "ux": ["rx", "au", "xx", "UC", "RGB", "wx", "vc", "RC", "vec", "src", "xy", "uz", "lux", "uu", "ww", "aux", "ru", "XX", " x", "foo", "UX", "xxx", "ue", "X", "VC", "uc", "ud", " u", "sq"], "uvx": ["vpX", "cvx", "cvX", "vpy", "vy", "vX", "uvX", "vpx", "cvy", "uvy"], "R0": [" R2", "G00", "G2", "R2", "V00", "G18", "V0", "B18", " ROrigin", "R00", "V18", "B10", "R10", "R18", "V1", "B2", " GOrigin", "GOrigin", "G10", "B00", "ROrigin", " R10"], "G0": ["B25", "G00", "R8", "B30", "U3", "B000", "U000", " G25", "G3", "U0", "G000", "B8", "G25", "R25", "U30", "R00", "R3", "R000", "G30", "U1", "B3", "G8", "U00", "B00", "R30", " G8"], "B0": ["N00", "G2", "B000", "V3", "N0", "V00", "L00", "G18", "F18", "V0", "B00", "V2", "B18", "N1", "F2", "R00", "V18", "R3", "V1", "R000", "B2", "B3", "F0", "F1", "L3", "L000", "L1", "L0", "V000"], "R1": ["AId", "R8", " RPU", "AOne", "BOne", " ROne", "A1", "ROne", " RK", "A0", "C1", " RId", "GId", "GPU", "GK", "U0", "UK", "B8", "UPU", "C8", "COne", "GOne", "V1", "RK", "V8", "VOne", "U1", "RPU", "RId"], "G1": ["B5", "GName", "Ge1", " G81", " GAP", "R81", "G6", "GIT", "ROne", " GOne", "GAP", "V6", "Gone", "UOne", "G81", "RAP", " GName", " G6", "U81", "V5", "VName", " Gone", "VIT", " GIT", "UAP", " G5", "B6", "G5", "GeIT", "Bone", "GeOne", "GOne", "V1", "Vone", "VOne", "GeName", "U1"], "B1": ["VOnce", "B61", "GOnce", " B2", "L001", "Y81", "BOne", "G2", "R001", "ROne", "YOnce", "B001", "R2", " B001", "R61", "G81", "Y1", "LOne", "J61", "BOnce", "V81", "J2", "G61", "J1", "V1", "B2", " BOne", "B81", "L2", "L1"], "R": ["E", "RGB", "RL", "T", "GR", "RC", "r", "M", "RH", "A", "N", "K", "Q", "I", "L", "RR", "W", "RA", "J", "X", "SR", "F", "D", "S", "Rs", "O", "C", "H", "P"], "G": ["E", "GN", "PG", "VG", "GB", "GV", "GR", "M", "GA", "A", "g", "GL", "Q", "I", "GI", "L", "W", "Ge", "J", "X", "F", "D", "GE", "GP", "GF", "LG", "IG", "C", "Gu", "H", "GS", "GG"], "B": ["E", "Bi", "GB", "BF", "BA", "MB", "N", "A", "Q", "EB", "HB", "I", "L", "BC", "Bs", "W", "BI", "BG", "BS", "J", "X", "F", "D", "WB", "DB", "BL", "b", "O", "SB", "AB", "C", "H", "BM"], "out": ["bin", "extra", "IN", "err", "call", "ref", "image", "Output", "bit", "io", "n", "result", "Out", "In", "o", "again", "flat", "array", "draw", "new", "outs", "prefix", "Image", "buf", "tmp", "lib", "cmd", "p", "OUT", "cache", "output", "opt", "transform", "inner", "input"], "img": ["br", "ch", "small", "ff", "gif", "gd", "image", "ref", "f", "ng", "ctr", "rc", "hr", "io", "cm", "cb", "upp", "z", "src", "ii", "ie", "orig", "dim", "tif", "imag", "irm", "arr", "big", "uv", "gb", "conv", "up", "medium", "config", "bl", "buf", "imp", "bg", "tmp", "inv", "rb", "norm", "picture", "im", "aff", "aug", "input"]}}
{"project": "FFmpeg", "commit_id": "ba3f07d0611d9a6c10eaa90b3c058ecdffe76676", "target": 1, "func": "static void aw_pulse_set2(WMAVoiceContext *s, GetBitContext *gb,\n\n                          int block_idx, AMRFixed *fcb)\n\n{\n\n    uint16_t use_mask_mem[9]; // only 5 are used, rest is padding\n\n    uint16_t *use_mask = use_mask_mem + 2;\n\n    /* in this function, idx is the index in the 80-bit (+ padding) use_mask\n\n     * bit-array. Since use_mask consists of 16-bit values, the lower 4 bits\n\n     * of idx are the position of the bit within a particular item in the\n\n     * array (0 being the most significant bit, and 15 being the least\n\n     * significant bit), and the remainder (>> 4) is the index in the\n\n     * use_mask[]-array. This is faster and uses less memory than using a\n\n     * 80-byte/80-int array. */\n\n    int pulse_off = s->aw_first_pulse_off[block_idx],\n\n        pulse_start, n, idx, range, aidx, start_off = 0;\n\n\n\n    /* set offset of first pulse to within this block */\n\n    if (s->aw_n_pulses[block_idx] > 0)\n\n        while (pulse_off + s->aw_pulse_range < 1)\n\n            pulse_off += fcb->pitch_lag;\n\n\n\n    /* find range per pulse */\n\n    if (s->aw_n_pulses[0] > 0) {\n\n        if (block_idx == 0) {\n\n            range = 32;\n\n        } else /* block_idx = 1 */ {\n\n            range = 8;\n\n            if (s->aw_n_pulses[block_idx] > 0)\n\n                pulse_off = s->aw_next_pulse_off_cache;\n\n        }\n\n    } else\n\n        range = 16;\n\n    pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;\n\n\n\n    /* aw_pulse_set1() already applies pulses around pulse_off (to be exactly,\n\n     * in the range of [pulse_off, pulse_off + s->aw_pulse_range], and thus\n\n     * we exclude that range from being pulsed again in this function. */\n\n    memset(&use_mask[-2], 0, 2 * sizeof(use_mask[0]));\n\n    memset( use_mask,   -1, 5 * sizeof(use_mask[0]));\n\n    memset(&use_mask[5], 0, 2 * sizeof(use_mask[0]));\n\n    if (s->aw_n_pulses[block_idx] > 0)\n\n        for (idx = pulse_off; idx < MAX_FRAMESIZE / 2; idx += fcb->pitch_lag) {\n\n            int excl_range         = s->aw_pulse_range; // always 16 or 24\n\n            uint16_t *use_mask_ptr = &use_mask[idx >> 4];\n\n            int first_sh           = 16 - (idx & 15);\n\n            *use_mask_ptr++       &= 0xFFFF << first_sh;\n\n            excl_range            -= first_sh;\n\n            if (excl_range >= 16) {\n\n                *use_mask_ptr++    = 0;\n\n                *use_mask_ptr     &= 0xFFFF >> (excl_range - 16);\n\n            } else\n\n                *use_mask_ptr     &= 0xFFFF >> excl_range;\n\n        }\n\n\n\n    /* find the 'aidx'th offset that is not excluded */\n\n    aidx = get_bits(gb, s->aw_n_pulses[0] > 0 ? 5 - 2 * block_idx : 4);\n\n    for (n = 0; n <= aidx; pulse_start++) {\n\n        for (idx = pulse_start; idx < 0; idx += fcb->pitch_lag) ;\n\n        if (idx >= MAX_FRAMESIZE / 2) { // find from zero\n\n            if (use_mask[0])      idx = 0x0F;\n\n            else if (use_mask[1]) idx = 0x1F;\n\n            else if (use_mask[2]) idx = 0x2F;\n\n            else if (use_mask[3]) idx = 0x3F;\n\n            else if (use_mask[4]) idx = 0x4F;\n\n            else                  return;\n\n            idx -= av_log2_16bit(use_mask[idx >> 4]);\n\n        }\n\n        if (use_mask[idx >> 4] & (0x8000 >> (idx & 15))) {\n\n            use_mask[idx >> 4] &= ~(0x8000 >> (idx & 15));\n\n            n++;\n\n            start_off = idx;\n\n        }\n\n    }\n\n\n\n    fcb->x[fcb->n] = start_off;\n\n    fcb->y[fcb->n] = get_bits1(gb) ? -1.0 : 1.0;\n\n    fcb->n++;\n\n\n\n    /* set offset for next block, relative to start of that block */\n\n    n = (MAX_FRAMESIZE / 2 - start_off) % fcb->pitch_lag;\n\n    s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0;\n\n}\n", "idx": 14741, "substitutes": {"s": ["south", "sys", "ses", "m", "self", "service", "sync", "t", "sg", "your", "l", "rs", "sym", "utils", "g", "cs", "qs", "S", "settings", "os", "this", "sets", "es", "si", "js", "sq", "session", "conf", "ss", "storage", "sim", "o", "w", "u", "p", "e", "se", "site", "b", "sb", "sf", "f", "gs", "spec", "less", "c", "ns", "is", "stats", "sc", "ssl", "sv", "sl", "states", "services", "ds", "r", "sie", "su", "ls", "ts", "us", "space", "support", "ctx", "ks"], "gb": ["bridge", " bc", "ui", "wm", "mc", "bc", "sg", "gc", "g", "buff", "conf", "gd", "gm", "gg", "bm", "rb", "sb", "usb", "gs", "cfg", "gam", "cb", "gate", "bg", "cmd", "mac", "ga", "src", "gp"], "block_idx": ["block_namexx", "blockObeginxes", "block_lengthx", "block_lengthcent", "block_idw", "blockOindexx", "block_idX", "block_indz", "block__itexx", "blockOindexxs", "blockEidentx", "block_itest", "block_Idxx", "block_modecent", "block_idst", "block_iteng", "block__iteX", "block_identcent", "block_endxes", "block_idsxes", "block_beginz", "block_ridz", "block00idx", "block__idxx", "block_beginx", "blockOindexw", "block_Idx", "block_endX", "blockEidst", "block_lengths", "block_itx", "block00idom", "block_idom", "blockOidx", "block_Idc", "block_identst", "blockOidxx", "block_identom", "block_itex", "block_endw", "block_indexw", "block_defxes", "block00idents", "block_lengthom", "block_identng", "block__idX", "block_Idz", "blockEidx", "blockObeginx", "block_indexxs", "block_idc", "block_idxx", "blockOidxs", "block_endx", "blockOidng", "blockEidentst", "blockEidentxx", "block_indexxes", "block_idents", "block_idxes", "block_itz", "block_ridy", "blockEidxx", "block_Idw", "blockOindexxes", "block_idcent", "block_idsx", "block_itexx", "block00identcent", "block_indxes", "blockEidentng", "block00identx", "block00idcent", "block_endxs", "block_ids", "block_iddxx", "block_namest", "block_Idy", "block__itex", "block_idxs", "blockObeginng", "block_modeom", "block_idz", "block_identx", "block_identxx", "block_endxx", "block_idng", "block_iddng", "block_itxes", "block_beginxes", "block_ridc", "block_indng", "block_namex", "blockEidng", "block_defx", "block_iddx", "block_indexx", "block_modex", "block_beginxx", "block__idx", "block00ids", "block_modes", "block_indx", "block_IdX", "block_beginng", "block_nameng", "block__idw", "blockObeginxx", "block_idy", "blockOidxes", "block00identom", "block__itew", "block_defng", "blockOidw", "block_idsxs", "block_iteX", "block_idsw", "block_defxx", "block_itew", "block_itng", "block_iddxes", "block_ridx"], "fcb": ["fcl", "fcd", "dcl", "FCm", "FCb", "FCl", "fxbs", "fbs", "fcsb", "fb", "dcd", "fec", "fcm", "lcl", "rcn", "fB", "dcb", "FCd", "fnn", "fsb", "fcbs", "fnb", "feb", "fxB", "fcc", "lcd", "rcb", "fnc", "rcc", "fem", "fcn", "rcm", "fxb", "fxsb", "lcm", "fcB", "FCbs", "lcb", "fnm", "FCB", "fen", "dcm", "FCsb"], "use_mask_mem": ["use_mask_all", "use_map_mem", "use_mask_memory", "use_map_ram", "use_mask_ram", "use_map_Mem", "use_ask_ram", "use_mask_Mem", "use_ask_mem", "use_map_all", "use_ask_memory"], "use_mask": [" use_filter", "usePmiss", "match_filter", " use_group", "rule_gap", "use_group", "usePmask", "seePcost", "rule_black", "seePmiss", " use_sum", "usealcount", "seePmask", "match_count", "usePcost", "use\u00b7margin", "use_map", "ride_mask", "usealsign", " use2group", "uselogshape", " use2mask", "match_shape", "uselylock", "see_margin", "matchlogfilter", " use2sum", "use2group", "use_lock", "use_shape", "ridealask", "ride_ask", "use_count", "rule_cache", "apply_window", "usage_cost", "use_window", "use__cache", "usealmask", "use\u00b7cost", "ridealmask", "usexmiss", "use_ask", "use_miss", "usePmargin", "usexmargin", "matchlogshape", "use2lock", "usexmask", "usage_cache", "uselymask", "use\u00b7miss", "use_cache", "use_sign", "seePmargin", "usexcost", "matchlogcount", "uselygap", "ride_cloud", "usealask", "usealshape", "use_margin", "apply_ask", "uselywindow", "rulelymask", "rule_mask", "rulelyblack", "rulelygap", "use2map", "use__mask", "match_mask", "use_cost", "use__cost", "ride_sign", "usealcloud", "use_filter", "ridealcloud", "apply_lock", "use_gap", "use2filter", "uselyblack", "ridealsign", "use_cloud", "use_sum", "see_mask", "use2mask", "rulelycache", "uselogfilter", " use_lock", "see_miss", "usage_sum", " use2map", "use__sum", " use_map", "uselogmask", "matchlogmask", "see_cost", "uselyask", "use\u00b7mask", "use_black", "usage_mask", "usealfilter", "apply_mask", "uselycache", "use2sum", "uselogcount"], "pulse_start": ["pulse_len", "pulse_end", "pitch_start", "pitch_set", "pulse_set", "pitch_len", "pitch_off", "pitch_stop", "pitch_end", "pulse_off", "pulse_stop"], "n": ["m", "d", "ni", "l", "i", "N", "g", "nb", "o", "np", "w", "z", "u", "p", "e", "nc", "b", "f", "c", "ns", "sn", "network", "r", "num", "len", "y", "node"], "idx": ["aidxs", "idex", "aidxc", "midxs", " idw", "aidy", "ridx", "indX", "Idx", "indy", "idec", "indxs", "aidz", "midx", "idw", "sidxs", "Idxs", "ridX", "aidxes", "sidX", " idxc", "indc", "partix", " idz", "ridw", "sidxc", "sidx", "idc", "midX", "idey", " idix", "idX", "idxs", "idz", " idX", "indxes", "partxs", "idix", " idxs", "idxc", "IdX", "Idxc", "indix", "ridxs", "indz", "idexes", "aidc", "aidX", "indx", "partx", "idy", "idxes", "midw", " idxes", "partX"], "range": ["channel", "area", "repeat", "ge", "spread", "domain", "slice", "array", "random", "l", "binary", "row", "gap", "low", "use", "ranged", "ace", "Range", "loc", "error", "frame", "limit", "chain", "fr", "role", "view", "size", "ange", "version", "e", "resource", "ver", "rate", "length", "mode", "none", "lag", "line", "feature", "grade", "nor", "state", "route", "block", "start", "end", "ne", "offset", "from", "rule", "scale", "r", "f", "last", "cache", "nr", "num", "span", "max", "lim", "err"], "aidx": [" idc", "idc", "adc", "aidc", "idr", "aidy", " idy", "adx", "idy", " idr", "aidr", "adr", "ady"], "use_mask_ptr": ["use_mask_ctr", "use_mask__ctr", "use_mask__addr", "use_ask_addr", "use_ask_pointer", "use_mask__tr", "use_mask_pos", "use_ask_ctr", "use_mask_pointer", "use_ask_tr", "use_mask_tr", "use_mask__ptr", "use_mask_addr", "use_ask_ptr"]}}
{"project": "FFmpeg", "commit_id": "6a6bc43f5f79587b8936334cc0b3a6616f4807ac", "target": 0, "func": "static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic,\n\n                                const uint8_t *src, int src_size)\n\n{\n\n    GetByteContext gb;\n\n    GetBitContext  gb2;\n\n    int nslices, slice, slice_height, ref_slice_height;\n\n    int cur_y, next_y;\n\n    uint32_t off, slice_size;\n\n    uint8_t *Y, *U, *V;\n\n    int ret;\n\n\n\n    bytestream2_init(&gb, src, src_size);\n\n    nslices = bytestream2_get_le16(&gb);\n\n    off = FFALIGN(nslices * 4 + 2, 16);\n\n    if (src_size < off) {\n\n        av_log(avctx, AV_LOG_ERROR, \"no slice data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!nslices || avctx->height % nslices) {\n\n        avpriv_request_sample(avctx, \"%d slices for %dx%d\", nslices,\n\n                              avctx->width, avctx->height);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    ref_slice_height = avctx->height / nslices;\n\n    if ((avctx->width & 1) || (avctx->height & 1)) {\n\n        avpriv_request_sample(avctx, \"Frame dimensions %dx%d\",\n\n                              avctx->width, avctx->height);\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    Y = pic->data[0];\n\n    U = pic->data[1];\n\n    V = pic->data[2];\n\n\n\n    cur_y  = 0;\n\n    next_y = ref_slice_height;\n\n    for (slice = 0; slice < nslices; slice++) {\n\n        slice_size   = bytestream2_get_le32(&gb);\n\n        slice_height = (next_y & ~1) - (cur_y & ~1);\n\n        if (slice_size > src_size - off) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"invalid slice size %\"PRIu32\" (only %\"PRIu32\" bytes left)\\n\",\n\n                   slice_size, src_size - off);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (slice_size <= 16) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid slice size %\"PRIu32\"\\n\", slice_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (AV_RL32(src + off) != slice_size - 16) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Slice sizes mismatch: got %\"PRIu32\" instead of %\"PRIu32\"\\n\",\n\n                   AV_RL32(src + off), slice_size - 16);\n\n        }\n\n        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);\n\n        dx2_decode_slice_420(&gb2, avctx->width, slice_height, Y, U, V,\n\n                             pic->linesize[0], pic->linesize[1],\n\n                             pic->linesize[2]);\n\n\n\n        Y += pic->linesize[0] *  slice_height;\n\n        U += pic->linesize[1] * (slice_height >> 1);\n\n        V += pic->linesize[2] * (slice_height >> 1);\n\n        off += slice_size;\n\n        cur_y   = next_y;\n\n        next_y += ref_slice_height;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4306, "substitutes": {"avctx": ["evconn", "avconf", "axcontext", "axloc", "afca", "ajctl", "aveci", "AVlc", "ajcomponent", "axcup", "avercontext", "avecor", "evcontext", "aveqa", "avcomponent", "avesync", " avcor", "apcf", "navcontext", "aveloc", "aveconfig", "afctx", "apconn", "apctx", "evcms", "evloc", "avqa", " avtx", "aveca", "ajctx", "avalc", "navctx", "evci", "afcor", " avcontext", "avca", "evcmp", " avca", "airctx", "ajcos", "avcor", "avalctl", "afci", "Avconn", "afloc", " avcup", "afcmp", "airqa", "avcmp", "avcos", "avalctx", "avec", "aveconf", "avercu", "aveconn", "avconsole", "Avctx", "avecontext", "afcf", "avlc", "axctx", "navsync", "evcu", "AVcu", " avcu", "avecu", "avalcontext", "avsync", "avc", " avcms", "navconfig", "aflc", "afctl", "evlc", "avcu", "avconfig", "AVcontext", "averctx", "avcms", "avalcomponent", " avconf", "afsync", "afconsole", "avcontext", "afconf", "afqa", "avloc", "avconn", "evctx", "afcos", "ajconn", " avcmp", "avalcos", "avctl", "aveconsole", "afcms", "apcontext", "Avcf", "avectx", "avetx", "averconsole", "AVctx", "airca", "avcf", "aftx", "afcup", "avtx", " avloc", "avecomponent", "Avcontext", "aircontext", "avcup", "afconn", "afcontext", "afconfig", "afcomponent", "ajcontext", " avconn", "avci", "avecmp", "afc", "afcu"], "pic": ["plugin", "ig", "vec", "bin", "piece", "pin", "quad", "config", "crop", "cus", "rc", "sync", "typ", "sys", "module", "bi", "image", "pins", "mac", "picture", "pi", "cci", "aci", "pc", "sci", "cam", "file", "pict", "fn", "lib", "bc", "feat", "fp", "jp", "cb", "cycle", "cube", "seq", "ic", "parse", "wire", "mini", "frame", "iv", "fig", "doc", "proc", "capt", "txt", "lc", "cf", "fc", "photo", "ac", "vc", "fi", "git", "chat", "img", "feature", "Pic"], "src": ["sub", "cur", "spec", "rb", "config", "rc", "data", "stream", "in", "loc", "image", "uc", "buf", "attr", "url", "sl", "sci", "split", "sc", "uri", "sb", "inst", "fn", "storage", "ctx", "cb", "fp", "filename", "source", "seq", "input", "iv", "proc", "sel", "fc", "ref", "rs", "img"], "src_size": ["ssl_date", "src_number", "slice_scale", "rc_Size", "rc_width", "share_body", " src_clean", "src_length", "src_width", "src_ize", "src_body", "ssl_size", " src_weight", "ssl_function", "src2Size", "src_function", "src_code", "rc_data", "src_scale", "src_time", "srcallsize", "share_ize", "src2size", "src2data", "src_clean", "src_data", "srcalltime", "src_date", "slice_number", "src2width", "slice_code", "rc_size", "ssl_length", "src_weight", "srcallclean", " src_time", "srcallweight", "src_Size", "share_size"], "gb": [" db", "gp", "gc", "cfg", " rgb", "gm", "hub", "nn", " eg", "ci", "sg", "ki", "rb", "Gb", "bg", "b", "gnu", "bm", "gpu", "gio", "gu", "db", "ga", " rc", "usb", "gin", "abb", "sl", "pc", "py", "cc", "bb", "xb", "gz", "byte", "mc", "sb", "gam", "gs", "rg", "storage", "ctx", "bc", "GB", "cb", "nb", "mb", "gal", "kb", "bf", "g", "gd", "lc", "gram", "fc", "gg", "cv", "cm"], "gb2": [" buffer2", " gcc2", "g2"], "nslices": ["linslices", "nscilores", "nslicences", "outseales", "nsqlences", "onsplees", "nsligises", "nslaes", "nsligops", " nsucitions", " nslicences", "nsucences", "nscilales", "lsciales", "linsaulals", "onslicees", "outslaese", "onslices", "nsquees", "nsplences", "outslicets", " nsucES", "nameslicences", "nsealets", "nameslicores", "nslinences", " nslicES", "nsuces", "nslaions", "nslipets", "Nslices", "outslicions", "nslicees", "nscies", "nslipops", "nsaulales", "nsclises", "nsplales", "lslicists", "nsciees", "outslaences", "nsliges", "lslices", "nslinees", "namesqueences", "nsigets", "Nslicops", "nsealES", "nslicops", "nsquores", "nsigitions", "onslicals", "nameslices", "nsigES", "outslaions", "nsclops", "nslicets", "nsqles", "nsples", "nsciES", "onslicES", "nsaules", "nsealitions", "linslicals", " nsucences", "Nslicises", "namesqueales", "outslaes", "nsucES", "nsealences", "lsciists", "linslicales", "nslinets", "nslines", "nsqlese", "nslicales", "linsaulales", "nslicese", "nsligets", "nameslicales", " nslicitions", "nslicitions", "nsqueences", "nsqlions", "onsplES", "lslicions", "nsligists", "Nslipises", "nsques", "nscanales", "nsquales", "nsqueores", "nslicions", "nsaulals", "nscials", "nscles", "nslaese", "nslicals", "nsciles", "Nslicets", "nslinals", "linslicences", "nscanences", "nsplists", "nslipises", "nsplions", "nsealions", "namesquees", "nsiges", "nsclets", "nseales", "nsligales", "nsciales", "nslipes", "Nslipops", "nslicores", "nsucitions", "outsealies", "nsaulences", "nslinES", "outslicences", "nslicists", "linsaulences", "nslinies", "outslicese", "nsigies", "nsplees", "nsciists", "nsligions", "lslicales", "Nslipets", "outsealences", "onsples", "lscies", "nslicises", "Nslipes", "outslicies", "nsealies", "nslaences", "nsigences", "nscilences", "nsealese", "nscanals", "onsplals", "nsqueales", "namesqueores", "linsaules", "nslicES", "outslices", "nsplES", "outsealets", "nsciions", "lsciions", "nscanes", "nsquences", "nsplals", " nsuces", "nslicies"], "slice": [" slicing", "layer", "position", "diff", "trial", "shape", "edge", "single", "crop", "i", "pe", "blade", "image", "unit", "region", "loc", "live", "missing", "route", "offset", "player", "ii", "sl", "sci", "service", "split", "pie", "part", "len", "uri", "zip", "fit", "volume", "instance", "ski", "mi", "source", "ie", "scale", "ice", "pick", "pocket", "pos", "multiple", "node", "range", "slave", "sq", "video", "li", "sample", "inner", "hole", "dim", "shift", "seed", "slot"], "slice_height": [" slice_width", " slice_head", "slice_data", "slice\u00b7size", "slice_head", " slice_weight", "slice_weight", "slice\u00b7head", "slice_width", " slice_data", "slice\u00b7height", "slice\u00b7width"], "ref_slice_height": ["ref_slot_size", "ref_scale_height", "ref_slice_width", "ref_slot_height", "ref_slot_dim", "ref_scale_width", "ref_slice2depth", "ref_scale_length", "ref_slot_depth", "ref_slot_width", "ref_slice_size", "ref_slice2height", "ref_slice2size", "ref_slice2width", "ref_slice_depth", "ref_slice_length", "ref_slice_dim", "ref_slice2length", "ref_scale_size"], "cur_y": ["fer_y", "curOnz", "next_z", "curJz", "ferAllx", "curOny", "ferAllz", "curAlly", "nextJy", "curJx", "fer_yn", "ferAlly", "fer_x", "cur_x", " cur_z", "cur_yn", " cur_x", "curOnny", "next_x", "curJny", "nextJY", "curAllz", "fer_z", "cur_z", "nextJx", "curJyn", "curAllyn", "ferAllyn", "cur_Y", "cur_ny", "curJy", "nextJz", "next_Y", " cur_ny", "curOnx", "curJY", "curAllx"], "next_y": ["nextJya", " nextJy", " next_ya", "next_yl", " next_x", " nextJY", "next_yd", "post_ys", "nextWys", " nextPy", "nextWy", " nextJyl", "nextPya", "next_ya", "nextOney", "nextOneys", "nextOnery", "post_ry", "nextJy", " nextPx", "nextPy", "nextXy", "nextWry", "nextWyd", "nextXya", " nextJx", "next_ry", "nextPY", "nextOneyd", "next_ys", "nextXY", "next_x", "nextJY", " next_yl", "nextJx", "post_yd", " nextPya", " next_Y", " nextPY", "next_Y", "nextPx", "post_y", "nextJyl", "nextXx"], "off": ["flow", "o", "SIZE", "extra", "block", "open", "alt", "value", "eff", "offs", "op", "non", "style", "shift", "now", "bit", "ON", "unit", "region", "valid", "num", "offset", "ext", "obj", "length", "ack", "small", "original", "def", "len", "down", "error", "online", "out", "dev", "raw", "after", "feat", "own", "of", "load", "old", "output", "pos", "Off", "OFF", "new", "type", "ip", "orig", "back", "half", "ord", "ref", "front", "no", "on", "end", "ff", "low"], "slice_size": ["slot_ize", "slice_ize", "slice_unit", "sample_size", "slice_loc", "slice_length", "sample_height", "archive_length", "sliceingunit", "archiveingunit", "slice_sized", " slice_loc", "slice\u00b7size", "slot_sized", "slice_storage", "slice\u00b7sized", "archive_unit", "slice_width", "slot_width", "sliceingsize", "archiveingsize", " slice_sized", "sample_storage", "archive_size", "slice\u00b7loc", "sample_SIZE", "sliceinglength", "archiveinglength", "slice_SIZE", "slot_size"], "Y": ["H", "D", "ID", "P", "IP", "I", "S", "W", "CI", "M", "YY", "C", "API", "G", "N", "MI", "SH", "UV", "Q", "A", "GB", "B", "IX", "R", "y", "type", "X", " y", "PI", "T", "CH", "Z", "F"], "U": ["D", "IL", "P", "UC", "I", "S", "W", "M", "O", "C", "UD", "G", "N", "OU", "u", "UL", "L", "UV", "Q", "LU", "A", "B", "UT", "US", "R", "UR", "X", "UU", "T", "UI", "UN", "F"], "V": ["H", "D", "Vi", "NV", "P", "VI", "VA", "v", "W", "S", "I", "M", "C", "G", "VC", "N", "VT", "E", "J", "L", "UV", "Q", "VW", "B", "GV", "TV", "R", "X", "T", "VD", "VL", "F"], "ret": ["red", "reg", "rt", "id", "mem", "alt", "nt", "value", "rot", "val", "data", "cat", "info", "reply", " RET", "num", " Ret", "lit", "fin", "ext", "att", "f", "arg", "res", "bad", "match", "def", "code", "len", "det", "out", "arr", "en", "RET", "result", "Ret", "re", "fail", "fun", "back", "success", "ref", "rep", "aux", "no", "rets"]}}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void ff_mpv_frame_end(MpegEncContext *s)\n\n{\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    /* redraw edges for the frame if decoding didn't complete */\n\n    // just to make sure that all data is rendered.\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {\n\n        ff_xvmc_field_end(s);\n\n    } else\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    emms_c();\n\n\n\n    if (s->current_picture.reference)\n\n        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n\n}\n", "idx": 6140, "substitutes": {"s": ["o", "sets", "sf", "sec", "is", "S", "spec", "sg", "b", "si", "i", "sync", "sys", "ses", "services", "m", "in", "support", "l", "f", "client", "ns", "j", "ls", "sl", "service", "us", "ss", "cs", "sports", "u", "e", "w", "gs", "sb", "se", "bis", "ks", "qs", "t", "n", "ctx", "ds", "ts", "storage", "self", "p", "fs", "c", "os", "g", "ssl", "sq", "es", "rs", "src", "ps", "js"], "xvmc_acceleration": ["xvmc_accelation", "xvmc_accelator", "xvmc_encceleration", "xvmc_accelering", "xvmc_enccentation", "xvmc_enccenting", "xvmc_enccelerator", "xvmc_accenting", "xvmc_enccentator", "xvmc_accelerations", "xvmc_acveration", "xvmc_accelations", "xvmc_accentation", "xvmc_accentator", "xvmc_acverator", "xvmc_acceling", "xvmc_enccelerations", "xvmc_accelerator", "xvmc_enccelering", "xvmc_enccentations", "xvmc_acverations", "xvmc_accentations", "xvmc_acvering"], "FF_ENABLE_DEPRECATION_WARNINGS": ["FF_ENABLE_DEPRECATION_WARES", "FF_ENABLE_DEPRECATION_ERRORs", "FF_ENABLE_DEPRECATION_ERRORES", "FF_ENABLE_DEPRECATION_WARNINGDS", "FF_ENABLE_DEPRECATION_WARs", "FF_ENABLE_DEPRECATION_WARNINGES", "FF_ENABLE_DEPRECATION_WARS", "FF_ENABLE_DEPRECATION_WARNINGs", "FF_ENABLE_DEPRECATION_ERRORS", "FF_ENABLE_DEPRECATION_WARDS", "FF_ENABLE_DEPRECATION_ERRORDS"]}}
{"project": "FFmpeg", "commit_id": "a1e093a6fb324612266d40e3168a14f58adab265", "target": 0, "func": "static int decode_element(AVCodecContext *avctx, void *data, int ch_index,\n\n                          int channels)\n\n{\n\n    ALACContext *alac = avctx->priv_data;\n\n    int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret;\n\n    uint32_t output_samples;\n\n    int i, ch;\n\n\n\n    skip_bits(&alac->gb, 4);  /* element instance tag */\n\n    skip_bits(&alac->gb, 12); /* unused header bits */\n\n\n\n    /* the number of output samples is stored in the frame */\n\n    has_size = get_bits1(&alac->gb);\n\n\n\n    alac->extra_bits = get_bits(&alac->gb, 2) << 3;\n\n    bps = alac->sample_size - alac->extra_bits + channels - 1;\n\n    if (bps > 32) {\n\n        av_log(avctx, AV_LOG_ERROR, \"bps is unsupported: %d\\n\", bps);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    /* whether the frame is compressed */\n\n    is_compressed = !get_bits1(&alac->gb);\n\n\n\n    if (has_size)\n\n        output_samples = get_bits_long(&alac->gb, 32);\n\n    else\n\n        output_samples = alac->max_samples_per_frame;\n\n    if (!output_samples || output_samples > alac->max_samples_per_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid samples per frame: %d\\n\",\n\n               output_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!alac->nb_samples) {\n\n        /* get output buffer */\n\n        alac->frame.nb_samples = output_samples;\n\n        if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return ret;\n\n        }\n\n    } else if (output_samples != alac->nb_samples) {\n\n        av_log(avctx, AV_LOG_ERROR, \"sample count mismatch: %u != %d\\n\",\n\n               output_samples, alac->nb_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    alac->nb_samples = output_samples;\n\n    if (alac->direct_output) {\n\n        for (ch = 0; ch < channels; ch++)\n\n            alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch];\n\n    }\n\n\n\n    if (is_compressed) {\n\n        int16_t lpc_coefs[2][32];\n\n        int lpc_order[2];\n\n        int prediction_type[2];\n\n        int lpc_quant[2];\n\n        int rice_history_mult[2];\n\n\n\n        decorr_shift       = get_bits(&alac->gb, 8);\n\n        decorr_left_weight = get_bits(&alac->gb, 8);\n\n\n\n        for (ch = 0; ch < channels; ch++) {\n\n            prediction_type[ch]   = get_bits(&alac->gb, 4);\n\n            lpc_quant[ch]         = get_bits(&alac->gb, 4);\n\n            rice_history_mult[ch] = get_bits(&alac->gb, 3);\n\n            lpc_order[ch]         = get_bits(&alac->gb, 5);\n\n\n\n            /* read the predictor table */\n\n            for (i = lpc_order[ch] - 1; i >= 0; i--)\n\n                lpc_coefs[ch][i] = get_sbits(&alac->gb, 16);\n\n        }\n\n\n\n        if (alac->extra_bits) {\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                if(get_bits_left(&alac->gb) <= 0)\n\n                    return -1;\n\n                for (ch = 0; ch < channels; ch++)\n\n                    alac->extra_bits_buffer[ch][i] = get_bits(&alac->gb, alac->extra_bits);\n\n            }\n\n        }\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int ret=rice_decompress(alac, alac->predict_error_buffer[ch],\n\n                            alac->nb_samples, bps,\n\n                            rice_history_mult[ch] * alac->rice_history_mult / 4);\n\n            if(ret<0)\n\n                return ret;\n\n\n\n            /* adaptive FIR filter */\n\n            if (prediction_type[ch] == 15) {\n\n                /* Prediction type 15 runs the adaptive FIR twice.\n\n                 * The first pass uses the special-case coef_num = 31, while\n\n                 * the second pass uses the coefs from the bitstream.\n\n                 *\n\n                 * However, this prediction type is not currently used by the\n\n                 * reference encoder.\n\n                 */\n\n                lpc_prediction(alac->predict_error_buffer[ch],\n\n                               alac->predict_error_buffer[ch],\n\n                               alac->nb_samples, bps, NULL, 31, 0);\n\n            } else if (prediction_type[ch] > 0) {\n\n                av_log(avctx, AV_LOG_WARNING, \"unknown prediction type: %i\\n\",\n\n                       prediction_type[ch]);\n\n            }\n\n            lpc_prediction(alac->predict_error_buffer[ch],\n\n                           alac->output_samples_buffer[ch], alac->nb_samples,\n\n                           bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]);\n\n        }\n\n    } else {\n\n        /* not compressed, easy case */\n\n        for (i = 0; i < alac->nb_samples; i++) {\n\n            if(get_bits_left(&alac->gb) <= 0)\n\n                return -1;\n\n            for (ch = 0; ch < channels; ch++) {\n\n                alac->output_samples_buffer[ch][i] =\n\n                         get_sbits_long(&alac->gb, alac->sample_size);\n\n            }\n\n        }\n\n        alac->extra_bits   = 0;\n\n        decorr_shift       = 0;\n\n        decorr_left_weight = 0;\n\n    }\n\n\n\n    if (channels == 2 && decorr_left_weight) {\n\n        decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples,\n\n                           decorr_shift, decorr_left_weight);\n\n    }\n\n\n\n    if (alac->extra_bits) {\n\n        append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer,\n\n                          alac->extra_bits, channels, alac->nb_samples);\n\n    }\n\n\n\n    if(av_sample_fmt_is_planar(avctx->sample_fmt)) {\n\n    switch(alac->sample_size) {\n\n    case 16: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch];\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n        }}\n\n        break;\n\n    case 24: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                alac->output_samples_buffer[ch][i] <<= 8;\n\n        }}\n\n        break;\n\n    }\n\n    }else{\n\n        switch(alac->sample_size) {\n\n        case 16: {\n\n            int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 24: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i] << 8;\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 32: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10750, "substitutes": {"avctx": ["afconn", "avalbc", "afctx", "afcup", "AVcf", "avalctx", "avalcontext", "navctx", "avebc", " avdc", "alconn", "Avctl", "avbc", "alctl", "afpkg", "avectx", " avca", "alcontext", "afmac", "avmac", "avemac", "afctl", "verpkg", "avcf", "navconn", "AVcontext", "avdc", "avedc", "avcup", "alctx", "verctx", "vercontext", "afcf", "verlc", "avconn", "aflc", "Avcf", " avmac", "AVlc", "avlc", "AVctx", "AVconn", "afbc", " avcontext", "verconn", "avalconn", "avcontext", "Avctx", " avcf", "navcf", "avpkg", "avca", "navcontext", "afca", "AVctl", "afdc", "alpkg", "avecf", "aveconn", "avecontext", "aveca", "avctl", "afcontext", "navcup", "verctl", "avecup", "navctl", "Avcontext"], "data": ["parent", "base", "context", "source", "media", "window", "da", "d", "config", "batch", "reader", "ata", "memory", "frame", "array", "body", "DATA", "dat", "input", "connection", "audio", "Data", "api", "image", "cache", "result", "buffer", "database"], "ch_index": ["ach_Index", "ch_Index", "chkslice", "chkIndex", "ach_level", "chslevel", "ch_level", "ach_slice", "chklevel", "chsindex", "ach_index", "ch_slice", "chsIndex", "chkindex", "chsslice"], "channels": [" chunks", "cars", "cords", "shannels", "channel", "chords", "Chords", "Chunks", "cannels", "shords", "Chanes", "chunks", "Chars", "shanes", "CHapters", "compunks", "compords", "shars", "companes", " chapters", "CHannel", "chanes", "tchannels", "tchunks", "cunks", " channel", "shunks", "Channels", "chars", "tchapters", "compannels", "CHannels", "chapters", "CHunks", "tchannel"], "alac": ["almac", "alec", "realacs", "alacl", "palacs", "pelacc", "pelax", "malac", "plax", "alsac", "realac", "elmac", "llax", "ilacc", "elact", "ellas", " aljac", "isalacer", "challac", " alacs", "alacc", "allac", "realanc", " alax", "calas", "balacc", "eliac", "palanc", " aloc", "aliacc", "alianc", "alacer", "alas", "llac", "plac", "balas", "ALac", "chalanc", "unalacc", "balact", "llanc", "aloc", "chalacl", "allas", "malacc", "isalAC", "alax", "ellmac", "alsec", "ralanc", "challacc", "alsacc", "aljac", "realacc", "aliiac", "calacs", "calec", " alas", "elacc", "pelac", "isalacl", " alec", " alanc", "alsoc", "ALacs", "llact", "ALAC", "ilas", "belacs", "alanc", "unalac", "belacc", "chalas", "chalacs", "elanc", "ellac", "eloc", "unalmac", "maliac", " alact", "calax", " alacc", "alsiac", "aliacl", "ralact", "llas", "plAC", "alioc", " alacl", "ALacc", "calmac", "ellacc", "calanc", "alsacs", "isaljac", "planc", "baloc", "elas", "challax", "aliacs", "belac", " alacer", "isalacc", "ralacc", "unalax", "palacc", "balanc", "isalanc", "isalac", "chalac", "aliac", "balmac", "alsmac", "calac", "isaloc", "elac", "challas", "alact", "balac", "llacc", "elacs", " alAC", "ilac", "placc", "palac", "caliac", "calacer", "placs", "calacc", "eljac", "ralac", "alacs", "malmac", "elAC", " almac", "belacl", "allanc", "ilanc", "alAC", "calAC", "alsacl", "chalacc", "pelAC", "allacc"], "has_size": ["hasRcount", "has_time", "is_count", "has_sized", "has_width", "hasRwidth", " has_time", "has67sized", "is_sized", "has_count", "hasRsized", "has_speed", "has67speed", "hasRsize", "full_speed", "full_sized", "has67size", "is_width", " has_group", "is_size", "full_size", "has_group"], "bps": ["lp", "vs", "apps", "bb", "abytes", "nb", "strings", "prefix", "lbs", "aps", "stats", "cases", "bp", "prot", "tips", "pps", "ops", "posts", "ipes", "ls", "pb", "parts", "pieces", "fp", "steps", "jobs", "bands", "bits", "rb", "planes", "offs", "pins", "objects", "lines", "bys", "plugins", "limits", "items", "fps", "eps", "bis", "codes", "hops", "details", "sb", "blocks", "bytes", "allows", "rates", "points", "ips", "params", "ps", "nets", "bs"], "is_compressed": ["is_cress", "is_Compressed", "is_suppression", "is_cressed", "is_Compression", "is_ompress", "is_composed", "is_compress", "is_Composed", "is_ompression", "is_suppressed", "is_compression", "is_Compress", "is_cured", "is_cression", "is_compured", "is_ompressed", "is_supposed", "is_suppured", "is_omposed", "is_Compured", "is_suppress"], "decorr_shift": ["decorr_offset", "decoris_left", "decorr\u00b7left", "decorr\u00b7shift", "decorr_left", "decorr\u00b7power", "decorr\u00b7offset", "decoris_power", "decoris_offset", "decorr_power", "decoris_shift"], "decorr_left_weight": ["decorr_left2count", "decorr_shift_weights", "decorr_shift_count", "decorr_left2weight", "decorr_left2shift", "decorr_shift_shift", "decorr_shift_weight", "decorr_left_count", "decorr_left_weights", "decorr_left2weights", "decorr_left_shift"], "ret": ["arr", "valid", "ext", "len", "val", "alt", "def", "nt", "ait", "temp", "Ret", "mem", "reply", "ref", "lit", "fit", "cb", "reg", "obj", "txt", "value", "utf", "rb", "rets", "bc", "rt", "res", "det", "format", "rc", "fun", "att", "req", "mat", "bis", "cur", "ben", "rep", "get", "bit", "fin", "re", "RET", "back", "out", "result", "rev", "ft", "match", "resp", "buffer", "success", "pet"], "output_samples": ["output_asamps", "output_setsamp", "output_sacks", "output_tales", "output_nonents", "output_suffipes", "output_lacks", "output_requamples", "output_sipes", "output\u00b7servicesamples", "output_sones", "output_outsamps", "output_outsiles", "output_setsamples", "output_esamp", "output_vamples", "output_pores", "output_nones", "output_damples", "output_namps", "output_sales", "output_tamps", "output_assips", "output_sips", "output_requones", "output_tamples", "output_siles", "output_nizes", "output_sances", "output_suamples", "output_Sonents", "output_lones", "output_linesills", "output_setsamps", "output_linesamples", "output\u00b7servicesases", "output_samp", "output_sesamp", "output_lannels", "output_seamples", "output_samps", "output_suffannels", "output_asamples", "output\u00b7samp", "output_vips", "output_outspects", "output_suffums", "output_sportsamps", "output_nannels", "output_asales", "output_assamples", "output\u00b7sonents", "output_sannels", "output_esamples", "output_requacks", "output_dannels", "output_dums", "output_sesances", "output_lums", "output\u00b7sases", "output_requamps", "output_dipes", "output_servicesamples", "output\u00b7linesonents", "output_Sills", "output_vamps", "output_lamps", "output\u00b7linesamples", "output_sample", "output\u00b7linesills", "output_pamps", "output_sases", "output_npects", "output\u00b7servicesamp", "output_nales", "output_sills", "output_namples", "output_esases", "output_lamples", "output_suores", "output_pamples", "output_assamps", "output_linesonents", "output_Sessions", "output\u00b7samples", "output_servicesamp", "output\u00b7servicesamps", "output_Samples", "output_outsamples", "output_seores", "output_sessions", "output_sesamps", "output_Samps", "output_servicesessions", "output_suample", "output_sportspects", "output_sores", "output_nips", "output_seample", "output_suffamples", "output\u00b7sills", "output_servicesamps", "output_nacks", "output_sportsiles", "output_sums", "output_lipes", "output_nills", "output_spects", "output_pample", "output_vizes", "output_servicesases", "output_tannels", "output_sizes", "output_niles", "output_namp", "output_setsances", "output_seamps", "output\u00b7samps", "output_nances", "output_suamps", "output_nases", "output_asannels", "output_sportsamples", "output_sesamples", "output_esamps", "output_sonents", "output_assizes"], "i": ["count", "l", "channel", "base", "it", "n", "b", "x", "k", "z", "num", "d", "c", "p", "e", "f", "j", "ai", "v", "chi", "pi", "bi", "ii", "I", "ip", "ci", "io"], "ch": ["count", "l", "channel", "chrom", "conf", "sh", "oy", "cmp", "arch", "ach", "ph", "conn", "ich", "chip", "b", "ver", "c", "cp", "qu", "batch", "och", "p", "app", "cb", "cf", "gh", "CH", "loc", "q", "cho", "f", "sk", "j", "code", "zh", "child", "th", "cht", "cha", "anch", "che", "ind", "cher", "bh", "ctx", "chi", "sch", "cl", "mot", "cor", "col", "Ch", "change", "h", "ech", "dev", "ci", "comp", "length", "cmd", "chan"]}}
{"project": "qemu", "commit_id": "494a8ebe713055d3946183f4b395f85a18b43e9e", "target": 0, "func": "static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,\n\n                         V9fsPath *dir_path, const char *name, FsCred *credp)\n\n{\n\n    int retval;\n\n    V9fsString fullname, target;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_init(&target);\n\n\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    v9fs_string_sprintf(&target, \"%s\", oldpath);\n\n\n\n    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, \"ssdd\",\n\n                          &target, &fullname, credp->fc_uid, credp->fc_gid);\n\n    v9fs_string_free(&fullname);\n\n    v9fs_string_free(&target);\n\n    if (retval < 0) {\n\n        errno = -retval;\n\n        retval = -1;\n\n    }\n\n    return retval;\n\n}\n", "idx": 1896, "substitutes": {"fs_ctx": ["f_conn", "flowadecontext", "flowadectx", "fs_conn", "fsadecmp", "flow_context", "fs_req", "fsadereq", "fs_context", "flowadecmp", "f_ctx", "f_cas", "fs_cas", "flowadereq", "flow_req", "fsadectx", "flow_ctx", "f_context", "fs_cmp", "fsadecontext", "flow_cmp"], "oldpath": ["OLDpath", " olddest", "oldlink", "olderath", "olddest", "olderpath", "oldath", "OLDlink", "OLDpointer", " oldpointer", "OLDurl", " oldurl", "Oldlink", "olderpointer", "Olddest", "Oldpath", " oldlink", "Oldath", "olderlink", " oldath", "olderdest", "oldurl", "olderurl", "oldpointer"], "dir_path": [" dir2pointer", "dir2ath", "dir_context", "dir_ath", "dir_ctx", " dir2path", "dir___ath", " dir2context", "dir___path", " dir_pointer", "dir2context", "dir_info", " dir_info", "dir2pointer", " dir2ath", "dir___pointer", "dir_pointer", " dir_ctx", " dir_context", "dir___context", "dir2path", " dir_ath"], "name": ["base", "missing", "version", "ext", "time", "key", "alias", "acl", "host", "filename", "data", "image", "domain", "url", "new", "n", "type", "parent", "member", "pass", "none", "password", "source", "names", "address", "description", "content", "word", "Name", "size", "node", "prefix", "path", "root", "NAME", "nam"], "credp": ["crcpo", "creedpa", "credf", "credpc", " creedpa", "clds", "eclds", "credpi", "creampc", "cldc", " cprivpc", "creamp", "ecldf", "creedp", "ecldp", "cprivpc", "credpa", "cprivc", "cprivf", "creams", "credpo", "ecreds", "crcpa", "ecldc", "cprivs", "cldp", "creedpo", " creds", "ecredf", " credpc", " credpi", "crdpa", "creedpi", "creamc", "credc", " creedpo", "creds", " credc", " cprivs", " cprivp", " credpo", "crdp", "ecredc", "ecredp", "cldf", "crdpo", " cprivc", " credpa", "cprivp", "crcp", " creedp", " creedpi", "crdpi", "crcpi"], "retval": ["reVAL", "Retv", "returnval", "RetVAL", "returnVal", "refcol", "altval", "altv", "reval", "intvalue", "reeval", "Retvalue", "retvalue", "ntval", "intVal", " retv", "rtcol", "reteval", "intv", "altint", " retvalue", "returnvalue", "ntint", " retVal", "refvalue", " retint", "returnVAL", "rev", "retVAL", "rtval", "rtVal", "intval", "refv", " retvalid", " retVAL", "ntVal", "RetVal", "rtvalid", "altVal", "returnv", " reteval", "refVal", "refval", "refvalid", "retint", "altvalid", "altVAL", "retVal", "retv", "retvalid", "alteval", " retcol", "ntvalid", "Retval", "retcol"], "fullname": ["fulpart", "completeline", "longnamed", "Fullspan", "fuln", "FullName", "fullspan", "fullyline", "shortName", "fulpath", "fullyName", "fulName", "fultext", "Fullpart", "fullyspan", "longcap", "longname", "shortname", "fullyname", "shortn", " fullpath", "fullycap", " fullcap", "fulln", "shortpath", "completenamed", "fullpart", "fullName", "fulcap", " fullName", "longtext", "fullypart", " fulln", "fulspan", "fullline", "fullpath", "Fullname", "fulname", "longName", "fulltext", "completename", "fullnamed", "fullcap", "fullynamed", "longline", "fullytext"], "target": ["route", "base", "null", "channel", "alias", "method", "host", "wrong", "filename", "data", "effect", "url", "tag", "template", "type", "cat", "format", "id", "Target", "prop", "parent", "platform", "client", "next", "output", "label", "component", "dest", "password", "project", "source", "pattern", "pointer", "arget", "address", "content", "result", "owner", "top", "secret", "resource", "reset", "front", "text", "token", "eth", "value", "range", "goal", "shadow", "prefix", "transform", "path", "subject", "root", "protected", "net", "task"]}}
{"project": "FFmpeg", "commit_id": "5127f465bd3e2cf9cbf66dea3cf7b481b522d266", "target": 1, "func": "static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *s;\n\n    unsigned char *d;\n\n    unsigned char *d_end;\n\n    unsigned char queue[QUEUE_SIZE];\n\n    unsigned int qpos;\n\n    unsigned int dataleft;\n\n    unsigned int chainofs;\n\n    unsigned int chainlen;\n\n    unsigned int speclen;\n\n    unsigned char tag;\n\n    unsigned int i, j;\n\n\n\n    s = src;\n\n    d = dest;\n\n    d_end = d + dest_len;\n\n    dataleft = AV_RL32(s);\n\n    s += 4;\n\n    memset(queue, 0x20, QUEUE_SIZE);\n\n    if (AV_RL32(s) == 0x56781234) {\n\n        s += 4;\n\n        qpos = 0x111;\n\n        speclen = 0xF + 3;\n\n    } else {\n\n        qpos = 0xFEE;\n\n        speclen = 100;  /* no speclen */\n\n    }\n\n\n\n    while (dataleft > 0) {\n\n        tag = *s++;\n\n        if ((tag == 0xFF) && (dataleft > 8)) {\n\n            if (d + 8 > d_end)\n\n                return;\n\n            for (i = 0; i < 8; i++) {\n\n                queue[qpos++] = *d++ = *s++;\n\n                qpos &= QUEUE_MASK;\n\n            }\n\n            dataleft -= 8;\n\n        } else {\n\n            for (i = 0; i < 8; i++) {\n\n                if (dataleft == 0)\n\n                    break;\n\n                if (tag & 0x01) {\n\n                    if (d + 1 > d_end)\n\n                        return;\n\n                    queue[qpos++] = *d++ = *s++;\n\n                    qpos &= QUEUE_MASK;\n\n                    dataleft--;\n\n                } else {\n\n                    chainofs = *s++;\n\n                    chainofs |= ((*s & 0xF0) << 4);\n\n                    chainlen = (*s++ & 0x0F) + 3;\n\n                    if (chainlen == speclen)\n\n                        chainlen = *s++ + 0xF + 3;\n\n                    if (d + chainlen > d_end)\n\n                        return;\n\n                    for (j = 0; j < chainlen; j++) {\n\n                        *d = queue[chainofs++ & QUEUE_MASK];\n\n                        queue[qpos++] = *d++;\n\n                        qpos &= QUEUE_MASK;\n\n                    }\n\n                    dataleft -= chainlen;\n\n                }\n\n                tag >>= 1;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11985, "substitutes": {"src": ["rin", "img", "start", "source", "sel", "in", "b", "filename", "buf", "c", "config", "rib", "ls", "stream", "gb", "ins", "rb", "loc", "rs", "sq", "inst", "sub", "rc", "input", "cur", "r", "req", "load", "sb", "rx", "url", "image", "ch", "sr", "sc"], "dest": ["des", "dim", "dom", "source", "class", "path", "decl", "b", "rest", "wb", "delete", "de", "data", "destroy", "output", "Dest", "target", "dist", "du", "dir", "dat", "v", "master", "route", "name", "done", "end", "address", "desc", "dc", " destination", "dev", "del", "text", "dep", "D", "direction"], "dest_len": ["dest2length", "dest_size", "dest_val", "Dest_len", "Dest_size", "dest00len", "dest2val", "dest_Len", " dest_length", "dest00pos", "dest2Len", " dest_Len", "dest00size", "dest_pos", "dest2len", "dest00length", "Dest_length", "dest_length", "Dest_pos", " dest_val"], "s": ["l", "session", "is", "its", "m", "http", "t", "x", "gs", "v", "state", "ns", "hs", "spec", "self", "settings", "sg", "ds", "si", "n", "w", "b", "k", "c", "ids", "e", "se", "request", "args", "lines", "sq", "f", "sym", "slice", "sets", "es", "r", "as", "u", "ps", "su", "site", "ss", "sc", "ks", "sv", "g", "source", "ls", "socket", "os", "cs", "o", "size", "sl", "new", "sb", "side", "a", "sid", "ssl", "ts", "start", "service", "p", "server", "ins", "q", "js", "S", "states", "services", "h", "client", "ses", "y", "events"], "d": ["l", "ld", "dim", "di", "dh", "ds", "did", "dom", "n", "start", "g", "da", "w", "m", "id", "dt", "dos", "b", "x", "t", "z", "fd", "de", "data", "ad", "c", "p", "bd", "e", "cd", "du", "dn", "f", "ded", "dr", "db", "dir", "o", "dat", "v", "nd", "ind", "end", "md", "r", "dd", "dc", "sd", "u", "D", "h", "del", "days", "y", "dad", "dx", "dy", "direction"], "d_end": ["d__ent", "ld_offset", "sd__ent", "d_edge", "d_enter", "d_ended", "sd__end", "d_ent", "sd_ent", "d_start", "sd_start", "d__end", " d_max", "d_End", "dd_ends", "dd_END", "d_END", "ld_end", " d_offset", "sd__start", "dd_end", " d_ended", "sd__End", "d_ends", "ld_enter", " d_get", "d__End", "d_get", "sd_End", "d_offset", "ld_edge", "d_max", "d__start", "sd_end", " d_start"], "queue": ["Queue", "channel", "seq", "message", "context", "table", "client", "class", "view", "que", "store", "buf", "pool", "job", "batch", "config", "stream", "stack", "qa", "p", "server", "fp", "output", "status", "memory", "q", "array", "sequence", "ue", "f", "select", "code", "console", "progress", "fl", "index", "process", "master", "module", "pipe", "proxy", "port", "desc", "list", "command", "null", "Q", "loop", "header", "menu", "complete", "cache", "result", "use", "file", "proc", "buffer", "forward"], "qpos": ["qpid", "quargs", "sqpos", "sqmin", "questval", "sqpat", " qsize", "sqcos", "quos", "quloc", "qufat", "qos", " qpo", "reqpo", " qpose", "qsize", "reqcos", "quval", "rypt", "qpose", "kpose", " qmin", "Qneg", " qpat", "qpt", "questfat", "qupos", "sqval", "qbody", "quposition", "kpo", "qargs", "qposition", "qpointer", "qupo", "sqbody", "qucos", "reqpos", "sqpt", "sqloc", "reqpointer", "qmin", "qumin", " qcos", " qbody", "sqpointer", " qpid", "questpos", "qpo", "qusize", " qfat", "quneg", "sqpo", "qfat", "kos", "qupt", "qupose", " qloc", "Qpos", "rypid", "rypos", "qcos", "rybody", "kpos", "sqargs", "Qpt", "reqposition", " qposition", " qargs", "sqpid", "qloc", " qpt", " qval", "qupointer", "qneg", "Qpo", "qupat", " qneg", "questpo", "sqsize", "qpat", "qval", " qos"], "dataleft": ["datALEFT", "datanext", "databeft", " dataleff", "Datalefts", "datallefts", "datavefort", "datatefts", "dataledkt", "dataalefort", "datalefort", "datalext", "datalewt", " dataleFT", "datareaft", "dataalsefort", " datalesft", "datameaft", "dataledaft", "dataledfts", "databekt", "dataalseaft", "daaleft", "datateaft", "daaleaft", "datamefort", "datarefort", "datalsefort", "Datalsefty", "danefort", "datALEft", "datvaleaft", "daalekt", "datalesfts", "datadefort", "datalefts", "datateft", "dalefts", "Datalseft", "datanewt", " datalesfts", "daneft", "dataleaft", "datALEff", "datalesft", "datALExt", "datalesxt", "dataveaft", " datalesaft", " datalesff", "datalsefty", "dataaleft", " dataleaft", "daatekt", "daateft", "datalleFT", "daateaft", "datalefty", "dataalsefts", "Dataleft", "datvalefts", "datamefty", "daleft", "DatalseFT", "daneaft", "dalefort", " datalesxt", "dataalefts", "datalleaft", "datareft", "daleaft", "Dat\n", "datavefts", "dataaleaft", "danewt", "danefts", " datalefts", "datamefts", "dataleff", "datadeFT", " datalext", "dataneFT", "datanefort", "datarefts", "DataleFT", "datalekt", "daatefts", "datalseaft", "dataledft", "dataneaft", "databefts", "datameft", "datadewt", "Datalefty", "datadefts", "dat\n", "Datalsefts", "daalefts", "datanefts", "datameFT", " datalesFT", "dalewt", "datvalewt", "dataalseft", "datalesff", "datatekt", "datalesfty", "datalesaft", "databeaft", "datalsefts", "data\n", "dataneft", "datalleft", " dat\n", "dataneff", "dataleFT", "datalesFT", "datalseFT", "dataveft", "datvaleft", "datadeaft", "datalseft", "datadeft"], "chainofs": ["chainOfn", "chainaccounth", "chainreturnabs", "chainfeedb", "chainOfh", "chaindicte", "chainforssl", "blockofabs", "blockefe", "chainlibb", "chainoffs", "chainreturns", " chainofses", "chaineffs", "chainofsym", " chainlibses", "containereffsync", " chainaccountssl", "chainfeeds", "chainowns", "blockofs", " chainofn", "chainofabs", "blockofsym", "chaineffn", "chainforh", "chainofn", "chainownb", "chainlibh", "chaindefses", "blockefs", " chainofssl", "chainofe", "chainofssl", "chainownses", " chainaccounts", "containereffs", "chaindictsym", " chainofb", "chaindictabs", "chainfeedn", "chainforn", "chainaccounts", " chainaccounth", "chainefe", "chaindefb", "chainfors", "chainofsync", "chainreturne", "chaindicts", "chainreturnsym", "chainOfssl", "chainlibs", "chainoffn", "chaineffb", "chainaccountn", "blockefsym", "chainoffb", "containerofsync", " chainlibs", "blockefabs", "chainofb", "chainaccountssl", "chaindefh", "chainofses", "blockofe", "chainoffsync", " chainaccountn", "containerofb", "chaineffsync", "chainefsym", "chainofh", "chainOfs", " chainlibb", " chainofh", "containerofn", "chainfeedsync", "containerofs", "chainefabs", " chainlibh", "chaindefs", "chainefs", "chainlibses", "containereffn", "containereffb", "chainownh"], "chainlen": ["groupgen", "rulelen", "blocklon", "cyclelength", "blocklen", "chaingen", "listlon", "listcount", "blockfat", "blockpos", " chainLen", "rowlen", "chainpos", "chainfat", "containerlength", "pathLen", "rangeLen", "blocklim", "containerlen", "blocklength", "groupLen", "rulelon", "pathcount", "rangelength", "cyclefat", "grouplen", " chainlon", "rowLen", "rowlon", "channellen", " chainlength", "containerlim", "rangelen", "blockgen", "cyclelim", "pathlen", "listLen", "chainlon", "channelLen", "rowlength", "pathlon", "blockcount", "ruleLen", "chainlength", "rulelength", "cyclegen", "blockLen", "chainLen", "listlen", " chainpos", "groupfat", "chainlim", "containerLen", "cyclelen", "cycleLen", "channelpos", "rangelon", "chaincount", "channellon"], "speclen": ["speflan", "specplun", "speflent", "speplan", "spelllen", " speclens", "speceleno", "specplent", "speccine", "specileno", "specclan", "seclun", "speplen", " specilen", "speplens", "speflun", "seclenn", "speCLenn", "speplent", " specllen", " specillen", "speblan", "speblen", "speblun", "specilens", "speCleng", " specileno", "speblent", "speClen", "speplenn", " spepleng", "speccun", "specillen", "specclent", "specellen", "specclen", "selline", " speclenn", "sellen", "specclun", "specplen", "speccenn", "specllen", "sellenn", "speclan", "speClenn", "spellens", " speplen", "speplun", "speCLine", "specilen", "speCLun", "specleng", " speplenn", "speccen", "spellenn", "speclens", "seclen", "speClens", "spepleng", "secline", " specleng", "sellun", "specplan", "specelen", "speCLeng", " specilens", " speplens", "specleno", "speclent", "specelens", "speCLen", "spelline", "speclun", " specleno", "spellun", "speCLens", "spellen", "specline", "spelleno", "speclenn", "speflen"], "tag": ["tags", "flag", "ack", "category", "str", "section", "comment", "start", "date", "class", "test", "key", "id", "word", "ban", " tags", "big", "block", "head", "config", "p", "reg", "Tag", "ag", "bug", "style", "loc", "op", "code", "name", "feature", "mod", "token", "sign", "bit", "TAG", "cat", "type", "tail", "gap", "image", "use", "text", "match", "feat", "month"], "i": ["l", "ui", "di", "it", "is", "n", "si", "g", "in", "zi", "m", "xi", "id", "info", "b", "x", "ini", "z", "my", "k", "uli", "c", "ji", "p", "ix", "e", "yi", "mini", "eni", "f", "ie", "ai", "multi", "index", "v", "gi", "ti", "mi", "phi", "ind", "r", "inner", "qi", "im", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "a", "ori", "ni", "io", "y", "ri", "fi", "iu"], "j": ["l", "je", "it", "n", "g", "w", "m", "jet", "t", "k", "b", "z", "x", "dj", "job", "jen", "ji", "p", "jam", "jo", "e", "el", "kj", "jj", "q", "js", "f", "o", "v", "syn", "jit", "ind", "r", "ij", "jp", "ii", "ja", "u", "aj", "pos", "li", "J", "y", "jl", "adj"]}}
{"project": "qemu", "commit_id": "e957f6a9b92439a222ecd4ff1c8cdc9700710c72", "target": 1, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    sPAPRDRConnectorClass *drck;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_dr_connector_by_id(SPAPR_DR_CONNECTOR_TYPE_CPU, index);\n\n    if (drc) {\n\n        drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n        drc_index = drck->get_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cs));\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 24648, "substitutes": {"cs": ["sc", "sk", "rs", "sys", "c", "ns", "cks", "ix", "CS", "ec", "ds", "gb", "cus", "ps", "cons", "ks", "sync", "ocr", "css", "cmp", "cms", "vc", "ics", "spec", "wcs", "cc", "ras", "cn", "ci", "cf", "ctx", "cas", "lc", "ls", "ca", "fs", "qs", "ced", "cing", "core", "acs", "nc", "ce", "pc", "ces"], "fdt": ["fdtm", "fdta", "fedtm", "FDn", "dln", "fdd", "dltm", "vdd", "vdit", "lft", "fedt", "lfd", "fdn", "dlte", "FDt", "vdt", "dfta", "FDte", "dft", "fedn", "dfd", "fdte", "fedte", "lfit", "fdit", "lfta", "dfit", "vdta", "dlt", "FDtm"], "offset": ["location", "slice", "shift", "position", "align", "delay", "address", "prefix", "Offset", "error", "end", "alias", "range", "o", "padding", "initial", "set", "start", "loc", "slot", "output", "size", "off", "length", "origin", "addr", "timeout", "part", "f", "limit", "index", "reset", "pos", "len", "phase"], "spapr": ["pAPn", "spagr", "pAPrs", "papn", "spagR", "spapeR", "spapsR", "scapl", "spapel", "spagrs", "paprs", "pAPR", "papR", "spagn", "scapsl", "spapl", "scapr", "spAPr", "spAPrs", "spAPn", "scapsR", "spAPl", "spapsl", "scapR", "papr", "spapn", "spAPR", "spapprs", "scapsr", "spaper", "spappR", "spapR", "spapsr", "spappn", "pAPr", "spaprs", "spappr"], "cpu": ["CPU", "processor", "node", "socket", "np", "chip", "dc", "c", "frame", "lb", "px", "clock", "component", "config", "bc", "loader", "platform", "instance", "sync", "proc", "linux", "gpu", "cmp", "boot", "fc", "unit", "coe", "hw", "prem", "GPU", "nic", "process", "nc", "cc", "ctx", "cp", "cn", "gp", "roc", "cache", "vm", "device", " CPU", "lc", "pai", "proxy", "CP", "conn", "core", "pu", "uci", "pc"], "env": ["gui", "args", "np", "scope", "exc", "cv", "shell", "enc", "ec", "en", "config", "conf", "style", "export", "opt", "state", "ev", "ea", "environment", "visor", "profile", "e", "path", "err", "dir", "ef", "estate", "viron", "exe", "energy", "skin", "eu", "eni", "esp", "ext", "core", "dest", "equ", "desc"], "pcc": ["Pcca", "jpck", " pcca", "pck", "Pck", " pck", "PCC", "jpCC", "Pcc", "pcca", " pCC", "pCC", "jpcca", "jpcc"], "segs": ["pega", "meg", "mega", "megments", "pegs", "peg", "persega", "megs", "persegments", "segments", "perseg", "sega", "pegments", "persegs", "seg"], "page_sizes_prop": ["page_size_Prop", "page_sizesingProp", "page_sizesingprop", "page_sizesingattr", "page_sizes_Prop", "page_sizes_attr", "page_size_prop", "page_size_attr"], "page_sizes_prop_size": ["page_sizes_prop64max", "page_sizes_prop_length", "page_sizes_prop_max", "page_sizes_prop64size", "page_sizes_Prop_size", "page_sizes_Prop_max", "page_sizes_prop_2", "page_sizes_prop642", "page_sizes_Prop_2", "page_sizes_Prop_length", "page_sizes_prop64length"], "pft_size_prop": ["pft_size_cp", "pft_sizeallprop", "pft_sec_comp", "pft_size_comp", "pft_sec_cp", "pft_size_opt", "pft_sec_prop", "pft_sec_opt", "pft_sizeallcp", "pft_sizeallopt", "pft_sizeallcomp"], "drc": ["dRC", "dirc", " dRC", "bdRC", "bdsc", "ldRC", "bRC", "bsrc", "brc", "Dsrc", "bdsrc", "adrec", "Drc", "bdc", "ldsrc", "bdrec", "drec", "dsrc", "bdbc", "adsrc", "adRC", " dbc", "adrc", "lddc", " dirc", "adbc", "ddc", "ldrc", "Dirc", "Ddc", "Dbc", "adirc", " dsc", "dbc", "DRC", "bdrc", "dsc", "ldbc", " dsrc", "adsc", " drec"], "drck": ["derce", "rrrick", "derck", "drct", "mircc", " drok", " drcus", "derok", " drkk", "dercc", "rrok", " drct", "mircus", "drkk", "drok", "Drce", "rrcc", "drrick", "drce", "derrick", "derct", " drk", "Drck", "Drk", "mirkk", "rrck", "errcc", " drce", "drk", "errkk", " drrick", "Drct", "errcus", "derk", "drcc", " drcc", "drcus", "mirck", "errck"], "drc_index": ["drc_id", "dsrc_index", "drcxlen", "dxc_id", "drc__i", "drc64label", "drc_len", "dxcxnum", "dRC_Index", "drcxid", "drc__position", "dsrc_i", "drc_position", "drc_label", "dxc_num", "dRC_index", "dsrc_label", "dRC_id", "dsrc_position", "dxcxid", "drcxnum", "drc_i", "dxcxindex", "drc64i", "drc__index", "dxc_len", "drcxindex", "drc64index", "drc64position", "dxc_index", "drc__label", "drc_Index", "drc_num", "dxcxlen"], "radix_AP_encodings": ["radix_max_encodings", "radix_max_encodesings", "radix_max_ENCODing", "radix_max_encODINGS", "radix_max_encodering", "radix_max_ENCodINGS", "radix_max_ENCODers", "radix_max_encODing", "radix_max_encODers", "radix_max_ENCODINGS", "radix_max_ENCODings", "radix_max_ENCoding", "radix_max_encodesers", "radix_max_encoding", "radix_max_encodesing", "radix_max_ENCoders", "radix_max_encodesINGS", "radix_max_encodINGS", "radix_max_encoderers", "radix_max_encoderings", "radix_max_encoders", "radix_max_encODings", "radix_max_encoderINGS", "radix_max_ENCodings"], "i": ["abi", "z", "p", "b", "c", "data", "ti", "interface", "qi", "it", "id", "is", "e", "multi", "bi", "ii", "si", "I", "f", "n", "ip", "j", "a", "iu", "pi", "ui", "l"]}}
{"project": "FFmpeg", "commit_id": "984add64a41c3296a8a82051cc90bff2eb449609", "target": 1, "func": "int ff_wma_init(AVCodecContext *avctx, int flags2)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    int i;\n\n    float bps1, high_freq;\n\n    volatile float bps;\n\n    int sample_rate1;\n\n    int coef_vlc_table;\n\n\n\n    if (   avctx->sample_rate <= 0 || avctx->sample_rate > 50000\n\n        || avctx->channels    <= 0 || avctx->channels    > 2\n\n        || avctx->bit_rate    <= 0)\n\n        return -1;\n\n\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    avpriv_float_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n\n\n    if (avctx->codec->id == AV_CODEC_ID_WMAV1) {\n\n        s->version = 1;\n\n    } else {\n\n        s->version = 2;\n\n\n\n\n    /* compute MDCT block size */\n\n    s->frame_len_bits = ff_wma_get_frame_len_bits(avctx->sample_rate,\n\n                                                  s->version, 0);\n\n    s->next_block_len_bits = s->frame_len_bits;\n\n    s->prev_block_len_bits = s->frame_len_bits;\n\n    s->block_len_bits      = s->frame_len_bits;\n\n\n\n    s->frame_len = 1 << s->frame_len_bits;\n\n    if (s->use_variable_block_len) {\n\n        int nb_max, nb;\n\n        nb = ((flags2 >> 3) & 3) + 1;\n\n        if ((avctx->bit_rate / avctx->channels) >= 32000)\n\n            nb += 2;\n\n        nb_max = s->frame_len_bits - BLOCK_MIN_BITS;\n\n        if (nb > nb_max)\n\n            nb = nb_max;\n\n        s->nb_block_sizes = nb + 1;\n\n    } else {\n\n        s->nb_block_sizes = 1;\n\n\n\n\n    /* init rate dependent parameters */\n\n    s->use_noise_coding = 1;\n\n    high_freq = avctx->sample_rate * 0.5;\n\n\n\n    /* if version 2, then the rates are normalized */\n\n    sample_rate1 = avctx->sample_rate;\n\n    if (s->version == 2) {\n\n        if (sample_rate1 >= 44100) {\n\n            sample_rate1 = 44100;\n\n        } else if (sample_rate1 >= 22050) {\n\n            sample_rate1 = 22050;\n\n        } else if (sample_rate1 >= 16000) {\n\n            sample_rate1 = 16000;\n\n        } else if (sample_rate1 >= 11025) {\n\n            sample_rate1 = 11025;\n\n        } else if (sample_rate1 >= 8000) {\n\n            sample_rate1 = 8000;\n\n\n\n\n\n    bps = (float)avctx->bit_rate / (float)(avctx->channels * avctx->sample_rate);\n\n    s->byte_offset_bits = av_log2((int)(bps * s->frame_len / 8.0 + 0.5)) + 2;\n\n\n\n\n\n\n\n    /* compute high frequency value and choose if noise coding should\n\n       be activated */\n\n    bps1 = bps;\n\n    if (avctx->channels == 2)\n\n        bps1 = bps * 1.6;\n\n    if (sample_rate1 == 44100) {\n\n        if (bps1 >= 0.61) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.4;\n\n\n    } else if (sample_rate1 == 22050) {\n\n        if (bps1 >= 1.16) {\n\n            s->use_noise_coding = 0;\n\n        } else if (bps1 >= 0.72) {\n\n            high_freq = high_freq * 0.7;\n\n        } else {\n\n            high_freq = high_freq * 0.6;\n\n\n    } else if (sample_rate1 == 16000) {\n\n        if (bps > 0.5) {\n\n            high_freq = high_freq * 0.5;\n\n        } else {\n\n            high_freq = high_freq * 0.3;\n\n\n    } else if (sample_rate1 == 11025) {\n\n        high_freq = high_freq * 0.7;\n\n    } else if (sample_rate1 == 8000) {\n\n        if (bps <= 0.625) {\n\n            high_freq = high_freq * 0.5;\n\n        } else if (bps > 0.75) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.65;\n\n\n    } else {\n\n        if (bps >= 0.8) {\n\n            high_freq = high_freq * 0.75;\n\n        } else if (bps >= 0.6) {\n\n            high_freq = high_freq * 0.6;\n\n        } else {\n\n            high_freq = high_freq * 0.5;\n\n\n\n    av_dlog(s->avctx, \"flags2=0x%x\\n\", flags2);\n\n    av_dlog(s->avctx, \"version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\\n\",\n\n            s->version, avctx->channels, avctx->sample_rate, avctx->bit_rate,\n\n            avctx->block_align);\n\n    av_dlog(s->avctx, \"bps=%f bps1=%f high_freq=%f bitoffset=%d\\n\",\n\n            bps, bps1, high_freq, s->byte_offset_bits);\n\n    av_dlog(s->avctx, \"use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\\n\",\n\n            s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);\n\n\n\n    /* compute the scale factor band sizes for each MDCT block size */\n\n    {\n\n        int a, b, pos, lpos, k, block_len, i, j, n;\n\n        const uint8_t *table;\n\n\n\n        if (s->version == 1) {\n\n            s->coefs_start = 3;\n\n        } else {\n\n            s->coefs_start = 0;\n\n\n        for (k = 0; k < s->nb_block_sizes; k++) {\n\n            block_len = s->frame_len >> k;\n\n\n\n            if (s->version == 1) {\n\n                lpos = 0;\n\n                for (i = 0; i < 25; i++) {\n\n                    a = ff_wma_critical_freqs[i];\n\n                    b = avctx->sample_rate;\n\n                    pos = ((block_len * 2 * a) + (b >> 1)) / b;\n\n                    if (pos > block_len)\n\n                        pos = block_len;\n\n                    s->exponent_bands[0][i] = pos - lpos;\n\n                    if (pos >= block_len) {\n\n                        i++;\n\n                        break;\n\n\n                    lpos = pos;\n\n\n                s->exponent_sizes[0] = i;\n\n            } else {\n\n                /* hardcoded tables */\n\n                table = NULL;\n\n                a = s->frame_len_bits - BLOCK_MIN_BITS - k;\n\n                if (a < 3) {\n\n                    if (avctx->sample_rate >= 44100) {\n\n                        table = exponent_band_44100[a];\n\n                    } else if (avctx->sample_rate >= 32000) {\n\n                        table = exponent_band_32000[a];\n\n                    } else if (avctx->sample_rate >= 22050) {\n\n                        table = exponent_band_22050[a];\n\n\n\n                if (table) {\n\n                    n = *table++;\n\n                    for (i = 0; i < n; i++)\n\n                        s->exponent_bands[k][i] = table[i];\n\n                    s->exponent_sizes[k] = n;\n\n                } else {\n\n                    j = 0;\n\n                    lpos = 0;\n\n                    for (i = 0; i < 25; i++) {\n\n                        a = ff_wma_critical_freqs[i];\n\n                        b = avctx->sample_rate;\n\n                        pos = ((block_len * 2 * a) + (b << 1)) / (4 * b);\n\n                        pos <<= 2;\n\n                        if (pos > block_len)\n\n                            pos = block_len;\n\n                        if (pos > lpos)\n\n                            s->exponent_bands[k][j++] = pos - lpos;\n\n                        if (pos >= block_len)\n\n                            break;\n\n                        lpos = pos;\n\n\n                    s->exponent_sizes[k] = j;\n\n\n\n\n\n            /* max number of coefs */\n\n            s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) / 100)) >> k;\n\n            /* high freq computation */\n\n            s->high_band_start[k] = (int)((block_len * 2 * high_freq) /\n\n                                          avctx->sample_rate + 0.5);\n\n            n = s->exponent_sizes[k];\n\n            j = 0;\n\n            pos = 0;\n\n            for (i = 0; i < n; i++) {\n\n                int start, end;\n\n                start = pos;\n\n                pos += s->exponent_bands[k][i];\n\n                end = pos;\n\n                if (start < s->high_band_start[k])\n\n                    start = s->high_band_start[k];\n\n                if (end > s->coefs_end[k])\n\n                    end = s->coefs_end[k];\n\n                if (end > start)\n\n                    s->exponent_high_bands[k][j++] = end - start;\n\n\n            s->exponent_high_sizes[k] = j;\n\n#if 0\n\n            tprintf(s->avctx, \"%5d: coefs_end=%d high_band_start=%d nb_high_bands=%d: \",\n\n                    s->frame_len >> k,\n\n                    s->coefs_end[k],\n\n                    s->high_band_start[k],\n\n                    s->exponent_high_sizes[k]);\n\n            for (j = 0; j < s->exponent_high_sizes[k]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_high_bands[k][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n#endif\n\n\n\n\n\n#ifdef TRACE\n\n    {\n\n        int i, j;\n\n        for (i = 0; i < s->nb_block_sizes; i++) {\n\n            tprintf(s->avctx, \"%5d: n=%2d:\",\n\n                    s->frame_len >> i,\n\n                    s->exponent_sizes[i]);\n\n            for (j = 0; j < s->exponent_sizes[i]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_bands[i][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n\n\n#endif\n\n\n\n    /* init MDCT windows : simple sinus window */\n\n    for (i = 0; i < s->nb_block_sizes; i++) {\n\n        ff_init_ff_sine_windows(s->frame_len_bits - i);\n\n        s->windows[i] = ff_sine_windows[s->frame_len_bits - i];\n\n\n\n\n    s->reset_block_lengths = 1;\n\n\n\n    if (s->use_noise_coding) {\n\n\n\n        /* init the noise generator */\n\n        if (s->use_exp_vlc) {\n\n            s->noise_mult = 0.02;\n\n        } else {\n\n            s->noise_mult = 0.04;\n\n\n\n\n#ifdef TRACE\n\n        for (i = 0; i < NOISE_TAB_SIZE; i++)\n\n            s->noise_table[i] = 1.0 * s->noise_mult;\n\n#else\n\n        {\n\n            unsigned int seed;\n\n            float norm;\n\n            seed = 1;\n\n            norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noise_mult;\n\n            for (i = 0; i < NOISE_TAB_SIZE; i++) {\n\n                seed = seed * 314159 + 1;\n\n                s->noise_table[i] = (float)((int)seed) * norm;\n\n\n\n#endif\n\n\n\n\n    /* choose the VLC tables for the coefficients */\n\n    coef_vlc_table = 2;\n\n    if (avctx->sample_rate >= 32000) {\n\n        if (bps1 < 0.72) {\n\n            coef_vlc_table = 0;\n\n        } else if (bps1 < 1.16) {\n\n            coef_vlc_table = 1;\n\n\n\n    s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];\n\n    s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];\n\n    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0], &s->int_table[0],\n\n                  s->coef_vlcs[0]);\n\n    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1], &s->int_table[1],\n\n                  s->coef_vlcs[1]);\n\n\n\n    return 0;\n", "idx": 19908, "substitutes": {"avctx": [" avtx", "devctx", "afcmp", "afcu", "ajcontext", "avecf", "avcmd", "devcf", "avpkg", "averctx", "AVcmp", "avctrl", "AVcu", "afbc", "ovcf", "abcontext", "vercf", "ovcontext", "ajpkg", "airconn", "afloc", " avcmp", "devctrl", "avectrl", "avtx", "AVctx", " avcontext", "avbc", "avcca", "avecmp", "ajcmp", "navcontext", "airctx", "avallc", "ajconn", "avlc", "aveqa", "avctl", "aveconn", "avectl", "avercontext", "ajctl", "avecu", "ajctrl", "AVtx", "afctrl", " avcf", "ovcn", "averbc", "avelc", "avalqa", "navcmd", "afcmd", " avctrl", "navctx", "afqa", "avecca", "avcmp", "afcf", "aftx", "ajcu", "vercontext", "aveloc", "ajctx", "AVpkg", "AVctl", "airctl", "navcf", "avalcca", "afcca", "avcf", "ovctx", "abloc", "avloc", "vercn", "AVcontext", "AVmc", "afmc", "avertx", "avalctx", "afpkg", "avmc", "devcontext", "avalcontext", "avectx", "ajcf", "afctl", "verctx", "avalcn", " avbc", "afcn", "aflc", "avcn", "aircontext", "afcontext", "avconn", "afctx", "abctx", "avecontext", "avecn", "afconn", "AVconn", "abconn", "avqa", "ajmc", "ajcmd", "avcu", "avcontext"], "flags2": ["Flags2", "bits1", "mask4", "args2", "args4", "bits2", "bits3", " flags1", "flags1", " flags3", "flag2", "Flags3", "Flags1", "flags4", "flag4", "flags3", "mask2"], "s": ["ns", "spec", "words", "full", "settings", "service", "ions", "ss", "cs", "d", "new", "qs", "sym", "p", "ks", "sets", "m", "sup", "ts", "sg", "rs", "aws", "times", "self", "lines", "o", "su", "v", "si", "S", "ds", "f", "r", "this", "l", "ins", "w", "features", "sync", "c", "ps", "secondary", "sys", "es", "states", "sq", "params", "sf", "session", "stats", "t", "rates", "conf", "services", "g", "ls", "ops", "ctx", "fs", "xs", "is", "site", "e", "ssl", "ses", "js", "http", "gs", "storage", "its", "os", "parts", "server"], "i": ["ti", "m", "f", "ai", "io", "ii", "iu", "slice", "I", "multi", "ip", "d", "pi", "uni", "ui", "ci", "abi", "batch", "v", "cli", "c", "ni", "si", "p", "li"], "bps1": ["bytes0", "bps0", " pins1", " bytes1", " bytes0", " pins0", "bytes1"], "high_freq": ["high_funq", "high_Freq", "high_FreQ", "high_freeg", "high_freeq", "high_Freg", "high_Frecharge", "high_hardch", "high_freQ", "high_hardq", "high_funcharge", "high_frecharge", "high_freqs", "high_freix", "high_hardQ", "high_hardix", "high_Frech", "high_Freqs", "high_condix", "high_freg", "high_Freix", "high_fung", "high_freecharge", "high_condch", "high_condq", "high_freeqs", "high_funqs", "high_frech", "high_condQ"], "bps": ["ns", " pins", "fps", "base", " fps", "sb", "bp", "cb", "ips", "ls", "pb", "bb", " bytes", "abytes", "bis", "batch", "bits", "ps", " bits", "seq", "p", "SB", "bytes", "Mbps", "eps"], "sample_rate1": ["sample_buffer6", "sample_num001", "sample_rate001", "sample_rate6", "sample_rate4", "sample_slice10", "sample_scale4", "sample_rule6", "sample_rule1", "sample_sum6", "sample_num1", "sample_scale1", "sample_slice1", "sample_time1", "sample_num10", "sampleacrate001", "sample_sum1", "sample_slice001", "sample_rate10", "sample_level1", "sampleacslice001", "sampleacslice10", "sample_rule4", "sampleacslice1", "sample_rates1", "sample_level6", "sample_scale6", "sample_level4", "sampleacrate1", "sample_buffer1", "sampleacrate10"], "coef_vlc_table": ["coef_vlc_db", "coef_vlc_count", "coef_vlc8db", "coef_vlf_count", "coef_vlc8table", "coef_vlf_type", "coef_vlf_db", "coef_vlc8type", "coef_vlf_table", "coef_vlc8count", "coef_vlc_type"], "nb_max": ["np_diff", "bb00index", "nb_rest", "nbjmax", "nb_ax", "lb_rest", "nb67rest", "bb00size", "nb_sum", "nb_scale", "nb24sum", "nb67only", "nb49warm", "nbIPMax", "nbjonly", "nb_warm", "nb_size", "lb_only", "nbjrest", "nb_diff", "nbIPrest", "bb00sum", "nb00size", "bb_index", "nb24max", "nb67count", "bb_size", "lib_max", "np_max", "lb_max", "nb49scale", "nb00index", "bb00max", "nbIPonly", "bb_max", "nb00max", "bb_sum", "lbIPMax", "nb67Max", "nb_only", "nb49max", "nb_cat", "lbIPmax", "lib_count", "nb24size", "lib_cat", "lbIPrest", "nb67cat", "lbIPonly", "nbIPmax", "nb_index", "nb_Max", "nb00sum", "nbjMax", "nb67max", "np_scale", "nb24index", "nb49diff", "nb67ax", "lib_ax", "lb_Max", "np_warm", "nb_count"], "nb": ["ns", "ab", "bin", "bi", "db", "eb", "nd", "obj", "note", "obb", "qi", "ne", "nt", "adj", "bm", "num", "sb", "bp", "cb", "kl", "lab", "bc", "ny", "nl", "quad", "wb", "pb", "abb", "bb", "nob", "zip", "count", "nm", "gb", "kb", "NB", "bf", "uni", "dy", "nu", "bis", "length", "batch", "fb", "spin", "ni", "bits", "rb", "lib", "bn", "sci", "fee", "nz", "split", "api", "nn", "np", "li", "ib", "len"]}}
{"project": "qemu", "commit_id": "1828be316f6637d43dd4c4f5f32925b17fb8107f", "target": 0, "func": "static void quit_timers(void)\n\n{\n\n    alarm_timer->stop(alarm_timer);\n\n    alarm_timer = NULL;\n\n}\n", "idx": 23374, "substitutes": {}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_log(int argc, const char **argv)\n\n{\n\n    int mask;\n\n    \n\n    if (argc != 2)\n\n        goto help;\n\n    if (!strcmp(argv[1], \"none\")) {\n\n        mask = 0;\n\n    } else {\n\n        mask = cpu_str_to_log_mask(argv[1]);\n\n        if (!mask) {\n\n        help:\n\n            help_cmd(argv[0]);\n\n            return;\n\n        }\n\n    }\n\n    cpu_set_log(mask);\n\n}\n", "idx": 14413, "substitutes": {"argc": ["argsc", "Argrc", "Argc", "Argsc", "argrc", "tagc", "igxc", " argrc", "Argpc", " argxc", "igc", "tagsc", "agpc", "argpc", "iglc", "igrc", "Argxc", "Arglc", " arglc", "tagfc", "agfc", "argxc", "argfc", "arglc", "agsc", "Argfc", "agc", "tagpc"], "argv": ["argsc", "argsf", "Argv", "Argc", "argval", "opc", " argp", "tagc", "Argf", "opv", "tagv", "Argp", "arval", "arf", "tagp", "tagsv", "argsv", "opsv", "argsp", " argval", "opp", "arp", "argp", "argf", "argssv", "arv", " argf", "argsval", " argsv"], "mask": ["zip", "bug", "map", "qa", "array", "allow", "id", "code", "unk", "style", "pixel", "weight", "image", "sk", "mark", "hack", "ace", "sum", "comment", "key", "like", "patch", "Mask", "scan", "fix", "filter", "check", "group", "clean", "cost", "sign", "info", "match", "data", "ck", "ask", "count", "result", "parent", "cover", "black", "block", "iq", "offset", "broad", "scale", "ack", "cache", "work", "lock", "ban", "delay", "flag", "strip", "bit", "cloud"]}}
{"project": "qemu", "commit_id": "c83c66c3b58893a4dc056e272822beb88fe9ec7f", "target": 0, "func": "void qmp_block_stream(const char *device, bool has_base,\n\n                      const char *base, Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockDriverState *base_bs = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    bs = bdrv_find(device);\n\n    if (!bs) {\n\n        error_set(errp, QERR_DEVICE_NOT_FOUND, device);\n\n        return;\n\n    }\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (base_bs == NULL) {\n\n            error_set(errp, QERR_BASE_NOT_FOUND, base);\n\n            return;\n\n        }\n\n    }\n\n\n\n    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    /* Grab a reference so hotplug does not delete the BlockDriverState from\n\n     * underneath us.\n\n     */\n\n    drive_get_ref(drive_get_by_blockdev(bs));\n\n\n\n    trace_qmp_block_stream(bs, bs->job);\n\n}\n", "idx": 1227, "substitutes": {"device": ["serial", "unit", "server", "mount", "service", "buffer", "target", "conn", "image", "d", "di", "devices", "type", "de", "android", "remote", "model", "package", "component", "mac", "project", "home", "address", "feature", "dc", "disk", "ip", "block", "phy", "dev", "Device", "node", "driver", "plugin", "module", "element", "product", "engine", "mode", "root", "mobile", "user", "port"], "has_base": ["has_data", "has_cache", " has_data", " has_cache"], "base": ["unit", "based", "server", "name", "buffer", "local", "area", "bare", "image", "binary", "url", "type", "Base", "bid", "ase", "id", "chain", "parent", "common", "client", "api", "model", "builder", "proxy", "mac", "file", "sync", "source", "back", "absolute", "fake", "bas", "address", "home", "pa", "block", "bot", "state", "bi", "lc", "cache", "core", "kit", "prefix", "bu", "b", "plugin", "site", "root", "mode", "part", "db", "family"], "errp": ["errP", "erP", "erpc", "rrf", "erb", "errorpc", "errpc", "rrr", "erf", "errorP", "norp", " errr", "acerpa", "norpa", "errb", "norb", "errorps", "err", "erpa", " errps", " errP", "errps", "errr", " errpa", " errpc", "errorp", "acerp", "erp", " errb", "rrb", "norr", " errf", "erps", "errf", "errpa", "acerr", "acerf", "rrp"], "bs": ["null", "js", "cs", "bh", "ss", "ba", "rs", "ts", "bo", "sb", "bps", "lb", "BS", "eb", "bid", "bc", "ins", "banks", "pb", "android", "bing", "bl", "bis", "pos", "plugins", "ls", "ses", "bits", "sync", "cb", "ds", "bas", "ps", "gs", "ns", "bus", "bot", "block", "css", "vs", "bi", "us", "bos", "bd", "br", "gb", "obj", "bb", "bu", "blocks", "iss", "fb", "b", "s", "os", "las", "bytes", "bes", "fs", "db"], "base_bs": ["base_base", " base_bas", " base_cs", " base_vs", "base_android", "base_vs", "base_b", " base_ls", "base_ls", "base_bas", " base_android", "base_cb", " base_base", " base_b", "base_cs", " base_cb"], "local_err": ["locallytx", "local2Er", "self_err", " local_cr", " local_req", " local_tx", "remote_err", "local_status", "local2req", "local_error", "locallyerr", "local_Er", "remote_status", "remote_error", "local_dr", "local_req", "self_rr", "local2err", "local_rr", " local_Er", "self_dr", " local_error", "local_tx", "locallyerror", "self_error", "locallycr", "local_cr"]}}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static void malta_fpga_write(void *opaque, hwaddr addr,\n\n                             uint64_t val, unsigned size)\n\n{\n\n    MaltaFPGAState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfffff);\n\n\n\n    switch (saddr) {\n\n\n\n    /* SWITCH Register */\n\n    case 0x00200:\n\n        break;\n\n\n\n    /* JMPRS Register */\n\n    case 0x00210:\n\n        break;\n\n\n\n    /* LEDBAR Register */\n\n    case 0x00408:\n\n        s->leds = val & 0xff;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIWORD Register */\n\n    case 0x00410:\n\n        snprintf(s->display_text, 9, \"%08X\", (uint32_t)val);\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* ASCIIPOS0 to ASCIIPOS7 Registers */\n\n    case 0x00418:\n\n    case 0x00420:\n\n    case 0x00428:\n\n    case 0x00430:\n\n    case 0x00438:\n\n    case 0x00440:\n\n    case 0x00448:\n\n    case 0x00450:\n\n        s->display_text[(saddr - 0x00418) >> 3] = (char) val;\n\n        malta_fpga_update_display(s);\n\n        break;\n\n\n\n    /* SOFTRES Register */\n\n    case 0x00500:\n\n        if (val == 0x42)\n\n            qemu_system_reset_request ();\n\n        break;\n\n\n\n    /* BRKRES Register */\n\n    case 0x00508:\n\n        s->brk = val & 0xff;\n\n        break;\n\n\n\n    /* UART Registers are handled directly by the serial device */\n\n\n\n    /* GPOUT Register */\n\n    case 0x00a00:\n\n        s->gpout = val & 0xff;\n\n        break;\n\n\n\n    /* I2COE Register */\n\n    case 0x00b08:\n\n        s->i2coe = val & 0x03;\n\n        break;\n\n\n\n    /* I2COUT Register */\n\n    case 0x00b10:\n\n        eeprom24c0x_write(val & 0x02, val & 0x01);\n\n        s->i2cout = val;\n\n        break;\n\n\n\n    /* I2CSEL Register */\n\n    case 0x00b18:\n\n        s->i2csel = val & 0x01;\n\n        break;\n\n\n\n    default:\n\n#if 0\n\n        printf (\"malta_fpga_write: Bad register offset 0x\" TARGET_FMT_lx \"\\n\",\n\n                addr);\n\n#endif\n\n        break;\n\n    }\n\n}\n", "idx": 23688, "substitutes": {"opaque": ["OPaque", "opaques", "opca", "opsca", "OPaques", "copaques", "opsaques", "copaque", "iopaques", "ocaques", "opacle", "obaques", "ioponymous", "ocacle", "OPca", "obonymous", "obaque", "oconymous", "obacle", "OPac", "ocaque", "opac", "copca", "iopacle", "iopaque", "opsaque", "copac", "opsac", "oponymous"], "addr": ["route", "port", "name", "handle", "ast", "ino", "ref", "config", "hop", "adr", "arg", "mode", "oa", "afi", "amd", "pad", "host", "align", "node", "ea", "pos", "cmp", "r", "address", "data", "ad", "p", "arr", "ace", "point", "work", "slot", "dr", "index", "frame", "add", "rt", " address", "ptr", "x", "value", "sta", "error", "fd", "src", "len", "loc", "v", "sid", "pointer", "offset", "base", "type"], "val": ["rol", "sv", "ee", "fail", "key", "pos", "data", "vals", "var", "live", "pl", "pid", "mem", "slice", "ve", "test", "VAL", "v", "old", "eval", "str", "ind", "valid", "item", "text", "sol", "al", "pre", "enc", "unit", "code", "buf", "aval", "vol", "alt", "vl", "prop", "ival", "reg", "sel", "serv", "ref", "err", "tx", "it", "ret", "arr", "play", "p", "nil", "el", "num", "role", "error", "loc", "Val", "lit", "x", "start", "sl", "arg", "ol", "bl", "pal", "slot", "elt", "py", "index", "cal", "len", "pol", "update", "all", "pt", "base", "value"], "size": [" error", " bytes", "scale", "Size", "bytes", " arg", "data", "vals", " data", " type", "mem", " mem", " length", "length", "len", "VAL", "v", "SIZE", "eval", "type"], "s": ["i", "bis", "es", "uns", "ds", "sys", "y", "slave", "r", "address", "ssl", "os", "ts", "cs", "us", "stats", "js", "aws", "n", "S", "ns", "rs", "ins", "v", "conf", "instance", "l", "an", "ss", "sb", "g", "ses", "private", "d", "sets", "as", "services", "u", "state", "stat", "o", "sg", "c", "self", "a", "scope", "e", "sym", "serv", "sie", "fs", "f", "t", "p", "si", "b", "service", "ps", "gs", "secondary", "x", "sq", "status", "port", "sl", "your", "plugins", "local", "m", "socket", "sync", "is", "settings", "se", "session", "south", "server", "states"], "saddr": ["wsaddr", "sysalt", "sattr", "southlive", "paddr", "parg", "fsattr", "southhost", "sbaddress", " sdr", "slive", " spos", "fsalt", " sattr", "dlive", "player", "spos", "syslayer", " saddress", "daddr", "sysaddress", " sptr", "dhost", "paddress", "sespos", "fsptr", "sbarg", "saddress", " salt", "slayer", "fsaddr", "sesdr", "sysattr", "sbaddr", "sysptr", "sblayer", "wsaddress", "southaddr", "daddress", "sysarg", "sarg", "salt", "sdr", "wsdr", "shost", "wspos", "southaddress", "sesaddr", "sysaddr", "sptr", "sesaddress"]}}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static inline void tcg_out_goto_label(TCGContext *s, int label_index)\n\n{\n\n    TCGLabel *l = &s->labels[label_index];\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);\n\n        tcg_out_goto_noaddr(s);\n\n    } else {\n\n        tcg_out_goto(s, l->u.value_ptr);\n\n    }\n\n}\n", "idx": 17258, "substitutes": {"s": ["ns", "spec", "m", "ts", "sg", "session", "t", "rs", "x", "f", "sv", "settings", "services", "service", "r", "n", "details", "sb", "g", "i", "sl", "ss", "src", "as", "in", "ops", "scope", "fs", "self", "xs", "lines", "is", "o", "cs", "d", "su", "space", "site", "e", "ssl", "ses", "sync", "private", "c", "js", "si", "ps", "sym", "p", "S", "b", "ks", "gs", "sys", "u", "a", "es", "os", "us", "sets", "se", "sq", "south", "ds", "sf"], "label_index": ["label_Index", "displayIdlocation", "labelIdind", " label_Index", "labelIdlength", "labelingindex", "label_start", "label_location", "labelingpos", "abel_index", "label__Index", "label_length", "displayIdind", "labelinglength", "displayIdlength", "display_location", "display_index", " label_pos", "labelIdlocation", "label__number", "display_ind", "labelinglocation", "labellenstart", "labelingind", "label__pos", " label_number", "labellenIndex", "displayIdindex", "labellenindex", "abel_start", "display_length", "label_ind", "label_number", "label__index", "abel_Index", "labelIdindex", "labelingnumber", "labelingIndex", "label_pos"], "l": ["jl", "ell", "al", "n", "pl", "lu", "g", "kl", "i", "sl", "nl", "ls", "lp", "loc", "sel", "dl", "lb", "o", "L", "ln", "lo", "fl", "le", "ol", "il", "e", "bl", "v", "lc", "rl", "ll", "p", "b", "la", "el", "li", "u"]}}
{"project": "qemu", "commit_id": "bea60dd7679364493a0d7f5b54316c767cf894ef", "target": 1, "func": "static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    char buf[1024];\n\n    VncShareMode mode;\n\n    int size;\n\n\n\n    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;\n\n    switch (vs->vd->share_policy) {\n\n    case VNC_SHARE_POLICY_IGNORE:\n\n        /*\n\n         * Ignore the shared flag.  Nothing to do here.\n\n         *\n\n         * Doesn't conform to the rfb spec but is traditional qemu\n\n         * behavior, thus left here as option for compatibility\n\n         * reasons.\n\n         */\n\n        break;\n\n    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:\n\n        /*\n\n         * Policy: Allow clients ask for exclusive access.\n\n         *\n\n         * Implementation: When a client asks for exclusive access,\n\n         * disconnect all others. Shared connects are allowed as long\n\n         * as no exclusive connection exists.\n\n         *\n\n         * This is how the rfb spec suggests to handle the shared flag.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            VncState *client;\n\n            QTAILQ_FOREACH(client, &vs->vd->clients, next) {\n\n                if (vs == client) {\n\n                    continue;\n\n                }\n\n                if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE &&\n\n                    client->share_mode != VNC_SHARE_MODE_SHARED) {\n\n                    continue;\n\n                }\n\n                vnc_disconnect_start(client);\n\n            }\n\n        }\n\n        if (mode == VNC_SHARE_MODE_SHARED) {\n\n            if (vs->vd->num_exclusive > 0) {\n\n                vnc_disconnect_start(vs);\n\n                return 0;\n\n            }\n\n        }\n\n        break;\n\n    case VNC_SHARE_POLICY_FORCE_SHARED:\n\n        /*\n\n         * Policy: Shared connects only.\n\n         * Implementation: Disallow clients asking for exclusive access.\n\n         *\n\n         * Useful for shared desktop sessions where you don't want\n\n         * someone forgetting to say -shared when running the vnc\n\n         * client disconnect everybody else.\n\n         */\n\n        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n            vnc_disconnect_start(vs);\n\n            return 0;\n\n        }\n\n        break;\n\n    }\n\n    vnc_set_share_mode(vs, mode);\n\n\n\n    vs->client_width = surface_width(vs->vd->ds);\n\n    vs->client_height = surface_height(vs->vd->ds);\n\n    vnc_write_u16(vs, vs->client_width);\n\n    vnc_write_u16(vs, vs->client_height);\n\n\n\n    pixel_format_message(vs);\n\n\n\n    if (qemu_name)\n\n        size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemu_name);\n\n    else\n\n        size = snprintf(buf, sizeof(buf), \"QEMU\");\n\n\n\n    vnc_write_u32(vs, size);\n\n    vnc_write(vs, buf, size);\n\n    vnc_flush(vs);\n\n\n\n    vnc_client_cache_auth(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED);\n\n\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n\n\n\n    return 0;\n\n}\n", "idx": 3401, "substitutes": {"vs": ["js", "alls", "qs", "vt", "ver", "ls", "VS", "cv", "css", "prev", "vc", "s", "events", "manager", "va", "wp", "versions", "fs", "blogs", "spec", "vals", "ums", "vert", "cas", "xs", "sv", "utils", "state", "lines", "as", "v", "sts", "vas", "iv", "ves", "plugin", "su", "os", "ks", "bs", "its", "plugins", "obs", "nav", "cs", "vp", "verts", "ss", "rs", "Vs", "eps", "ins", "env", "settings", "ports", "ds", "ps", "gs", "ns", "oss", "values", "vers", "es", "posts", "lv", "points", "las", "vm", "server", "http", "ops", "views", "pg", "ms", "docs", "ils", "sk", "pos", "ov", "otes", "vid", "services", "stats", "vr"], "data": ["media", "base", "response", "ata", "buffer", "da", "offset", "channel", "a", "array", "queue", "vals", "memory", "window", "parent", "sample", "api", "batch", "i", "next", "code", "entry", "args", "body", "config", "ip", "result", "block", "reader", "p", "state", "values", "alpha", "cache", "message", "text", "DATA", "uri", "load", "dat", "Data", "map", "input"], "len": ["lic", "ig", "byte", "Len", "cl", "lf", " limit", "bl", "pos", "z", "vec", "length", "cap", " length", "en", "seq", "ix", "val", "all"], "buf": ["ff", "fd", "nat", "buffer", "src", "bed", "bh", "ctx", "bag", "ba", "Buff", "queue", "bm", "ab", "uc", "fw", "window", "loc", "header", "fl", "bc", "buff", "pb", "batch", "rb", "code", "fp", "box", " cmd", " buffers", "cb", "pool", "pad", "bus", "block", "cv", "Buffer", "vec", "stack", "wb", "bd", "cap", "br", "la", " b", "bg", "cmd", "bp", "bb", "bridge", "seq", "b", "fb", "ucc", "uf", "port", "va", "img", "que", "fi", "map", " buffer", "rc", "mem"], "mode": ["route", "lock", "key", "device", "dim", "command", "ase", " module", "mo", "de", "code", "mid", "direction", "message", "manager", " scheme", "map", "rage", "name", "effect", "activity", "sid", "ui", "type", "id", "mm", "model", "mac", "ode", "gone", "state", "layout", "phrase", "driver", "scale", "plugin", "Mode", "me", "sym", "MODE", "guide", "version", "mod", "ward", "use", "kind", "member", "language", "m", "slice", "role", "definition", "phase", "module", "rule", "slave", "stage", "level", " role", "grade", "operation", "side", "none", "style", "multi", "md", "status", "config", "owner", "token", "range", "ace", "day"], "size": ["unit", "SIZE", "capacity", "name", "offset", "time", "ize", "large", "sized", "area", "small", "speed", "mini", "loc", "align", "weight", "type", "page", " sizes", "empty", "ny", "member", "max", "code", "sync", "number", "style", "z", "storage", "address", "content", "shift", "length", "message", "Size", "sum", "en", "scale", "fee", "iz", "count", "shape"], "client": ["consumer", "server", "cli", "service", "channel", "local", "conn", "command", "cl", "current", "image", "window", "character", "co", "friend", "open", "worker", "con", "Client", "parent", "end", "remote", "api", "secure", "company", "contact", "project", "source", "request", "config", "ce", "ip", "gu", "reader", "state", "custom", "resource", "child", "cache", "core", "contract", "public", "cmd", "connection", "pc", "plugin", "cell", "container", "manager", "session", "socket", "close", "product", "player", "net", "response", "user", "port"]}}
{"project": "qemu", "commit_id": "bd269ebc82fbaa5fe7ce5bc7c1770ac8acecd884", "target": 0, "func": "int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,\n\n                                  SocketAddressLegacy *localAddr,\n\n                                  SocketAddressLegacy *remoteAddr,\n\n                                  Error **errp)\n\n{\n\n    int fd;\n\n\n\n    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);\n\n    fd = socket_dgram(remoteAddr, localAddr, errp);\n\n    if (fd < 0) {\n\n        trace_qio_channel_socket_dgram_fail(ioc);\n\n        return -1;\n\n    }\n\n\n\n    trace_qio_channel_socket_dgram_complete(ioc, fd);\n\n    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3770, "substitutes": {"ioc": ["iaOC", "antioci", "iioci", "ciec", "iog", "uoco", "piog", "pioc", "xioc", "iec", "ioco", "iaog", "piocl", "xiec", "piisc", "piec", "ciocl", "tiocl", "iorg", "antiOC", "iioc", "piorp", "gioci", "uOC", "xiOC", "iiorg", "iioco", "iorp", "giOC", "antioc", "pioco", "antiorg", "ioci", "pioci", " iog", "iaoc", "iocl", "iiorp", "iOC", "uorp", "gioc", "giocl", "xiocl", "iiOC", "tiOC", "piOC", " iisc", "cioc", "tioc", "uoc", "ciOC", "cioci", "piorg", "iaisc", "tioci", "iisc", " iOC"], "localAddr": ["remoteAddp", "localChb", " localChrs", "localIngb", "localAddest", "localErp", "localAttp", "localAddressr", "localAddp", "localStr", "remoteAddressest", "localCher", "localErest", "localIngr", "localErr", "localAdder", "localAtter", "localStest", "localAttrs", "localAddressest", "localIngp", "localAddressp", "localStp", "localAddb", "localAddri", "localAttr", "localAddressri", "localChr", " localAddb", "localChri", " localChr", " localAdder", " localChri", "localAddresser", " localAddrs", "localAddressrs", "localIngri", "localAddrs", "remoteAddressp", "localErrs", "remoteAddressr", "remoteAddressrs", "remoteAddest", " localChb", " localAddri", "localStrs", "remoteAddrs", "localChp", " localChp", " localCher", "localAddressb", "localChrs", " localAddp"], "remoteAddr": [" remoteAddp", "remoteAddp", "remoteAttrs", "remoteAttp", "RemoteAttp", "RemoteAddb", "remoteIdn", " remoteAddressn", "RemoteAddp", "internalAddr", "RemoteAddrs", "remoteErrs", "remoteAddn", "RemoteAttb", "remoteAddressn", "remoteAddrc", "internalAddrs", " remoteAddrs", "remoteIdr", "RemoteAttr", " remoteAddressr", " remoteAddn", "remoteErn", "remoteIdp", "remoteAddressb", "RemoteAttrs", "internalAddrc", "remoteAddressrc", "remoteAddb", "remoteAttb", "remoteErrc", "RemoteAddr", "remoteErp", "remoteAddressr", "remoteAddressp", "remoteErr", "remoteAddressrs", " remoteAddressrs", "internalAddp", "remoteIdrs", "remoteAddrs", "remoteAttr", " remoteAddressp", "remoteIdb"], "errp": ["errorf", "errP", "erP", "rp", "errpe", "rr", "errfp", " errpe", "iterp", "errpc", "erf", "errorP", " errr", "rf", "err", " errps", " errP", "acepc", "iterps", "errr", "errps", " errpc", "errorp", "iterpc", "erp", "aceps", "iterpe", "errorfp", " errf", " errfp", "acepe", "errf", "acep", "rP", "erfp"], "fd": ["flow", "fc", "ff", " FD", "ld", "dn", "da", "fs", "fun", "dd", "fen", "pd", "FD", "sd", "xf", "fed", "fa", "d", " f", "xd", "dl", "fl", "ln", "lf", "fff", "fn", "buf", "draft", "dy", "fp", "sf", "df", "cb", "md", "ds", "pid", "feed", "fe", "dc", "bf", "reader", "fin", "du", "len", "f", "bd", "ffff", " fid", "hd", "cd", "handler", "fx", "wd", "fm", "die", "rd", "fee", "fb", "cf", "af", "vd", "nd", "dat", "diff", "fi", "gd", "db"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_initfn(SCSIDevice *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n\n    Error *err = NULL;\n\n\n\n    if (!s->qdev.conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n        !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return -1;\n\n    }\n\n\n\n    blkconf_serial(&s->qdev.conf, &s->serial);\n\n    if (dev->type == TYPE_DISK) {\n\n        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);\n\n        if (err) {\n\n            error_report(\"%s\", error_get_pretty(err));\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (s->qdev.conf.discard_granularity == -1) {\n\n        s->qdev.conf.discard_granularity =\n\n            MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);\n\n    }\n\n\n\n    if (!s->version) {\n\n        s->version = g_strdup(qemu_get_version());\n\n    }\n\n    if (!s->vendor) {\n\n        s->vendor = g_strdup(\"QEMU\");\n\n    }\n\n\n\n    if (bdrv_is_sg(s->qdev.conf.bs)) {\n\n        error_report(\"unwanted /dev/sg*\");\n\n        return -1;\n\n    }\n\n\n\n    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n            !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);\n\n    } else {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);\n\n    }\n\n    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);\n\n\n\n    bdrv_iostatus_enable(s->qdev.conf.bs);\n\n    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);\n\n    return 0;\n\n}\n", "idx": 20086, "substitutes": {"dev": ["dc", "spec", "grad", "Dev", "dd", "mod", "ch", "data", "info", "conf", "dot", "comment", "conn", "md", "gu", "debug", "de", "block", "app", "var", "di", "der", "development", "def", "prom", "self", "sk", "d", "hw", "adv", "w", "ev", "config", " Dev", "cam", "client", "v", "dom", "device", "req", "driver", "error", "dem", "serial", "DEV", "server", "diff", "ve", "ver", "bug"], "s": ["ns", "spec", "full", "service", "ss", "sec", "cs", "d", "sh", "new", "qs", "sym", "p", "ks", "h", "sets", "m", "sup", "ts", "sg", "j", "rs", "aws", "sim", "self", "o", "sk", "su", "tests", "v", "si", "S", "a", "hs", "an", "ds", "f", "r", "sb", "current", "sd", "l", "serv", "sync", "c", "ps", "b", "sys", "your", "state", "sq", "less", "params", "sf", "session", "t", "stats", "request", "conf", "services", "sp", "n", "g", "i", "sl", "ls", "ops", "fs", "xs", "is", "args", "site", "e", "ssl", "ses", "client", "js", "http", "gs", "storage", "os", "server", "se", "south", "y", "u"], "err": ["m", "rr", "fr", "br", "fg", "ch", "rage", "rs", "ah", "conf", "ref", "eor", "better", "rc", "r", "inc", "ar", "str", "result", "g", "cb", "rh", "var", "msg", "finder", "ind", "cer", "kr", "der", "resp", "magic", "arr", "ln", "erer", "nr", "aster", "mr", "rag", "rar", "order", "sr", "dr", "e", "lr", "ler", "cr", "yr", "req", "acer", "ir", "doc", "fee", "pr", "good", "fy", "error", "sys", "Er", "res", "er", "errors", "Error", "gr", "bug"]}}
{"project": "qemu", "commit_id": "2884cf5b934808f547b5268a51be631805c25857", "target": 0, "func": "static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,\n\n                                void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    GtkDisplayState *s = vc->s;\n\n    InputButton btn;\n\n\n\n    /* implicitly grab the input at the first click in the relative mode */\n\n    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&\n\n        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {\n\n        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),\n\n                                       TRUE);\n\n        return TRUE;\n\n    }\n\n\n\n    if (button->button == 1) {\n\n        btn = INPUT_BUTTON_LEFT;\n\n    } else if (button->button == 2) {\n\n        btn = INPUT_BUTTON_MIDDLE;\n\n    } else if (button->button == 3) {\n\n        btn = INPUT_BUTTON_RIGHT;\n\n    } else {\n\n        return TRUE;\n\n    }\n\n\n\n    qemu_input_queue_btn(vc->gfx.dcl.con, btn,\n\n                         button->type == GDK_BUTTON_PRESS);\n\n    qemu_input_event_sync();\n\n    return TRUE;\n\n}\n", "idx": 20434, "substitutes": {"widget": ["view", "ui", "input", "plugin", "ou", "poll", "pipe", "win", "ac", "owl", "cli", "q", "client", "wp", "ch", "gui", "window", "w", "draw", "fl", "fw", "ogg", "console", "wx", "util", "lib", "Widget"], "button": ["delete", "bc", "target", "attribute", "class", "next", "off", "event", "config", "key", "connection", "cell", "click", "bug", "data", "field", "shift", "submit", "trigger", "select", "type", "password", "object", "option", "text", "style", "lock", "component", "current", "code", "atom", "title", "channel", "element", "action", "ui", "fb", "patch", "p", "or", "number", "comment", "open", "module", "gui", "error", "page", "callback", "html", "bot", "api", "command", "span", "icon", "focus", "press", "category", "loop", "input", "color", "feature", "plugin", "down", "Button", "label", "ctrl", "timeout", "pin", "document", "pull", "flag", "touch", "editor", "skip", "att", "toggle", "url"], "opaque": ["OPaque", "opaques", "OPchid", "OPaques", "oppac", "Opaqu", " opchid", "oppaque", "opaqu", "obaques", "opchid", "Opacity", "obaque", "opacity", "OPacity", "OPac", "opac", " opacity", " opaqu", "obac", "Opaque", "Opchid", "OPaqu", "oppaques"], "vc": ["lc", "bc", "serv", "conn", "nv", "vt", "vim", "input", "cv", "bb", "vg", "pc", "ci", "win", "sys", "nc", "ac", "cs", "wl", "cf", "ctrl", "tc", "iw", "cli", "rc", "c", "ctx", "wp", "ch", "gui", "dc", "ic", "service", "gc", "vv", "fw", "ogg", "VC", "wx", "util", "qt", "vp", "hw", "voc", "oc", "cu", "gb"], "s": ["status", "sv", "i", "sb", "e", "space", "es", "qs", "sie", "sl", "fs", "g", "ses", "xs", "d", "sis", "site", "services", "f", "sys", "less", "m", "args", "storage", "state", "ssl", "os", "p", "cs", "screen", "o", "sync", "is", "stats", "sg", "c", "settings", "js", "spec", "self", "si", "b", "w", "session", "S", "ns", "sf", "south", "h", "secondary", "server", "scope", "ss", "states"], "btn": ["lc", "bc", "sb", "fc", "txt", "focus", "bolt", "jp", "config", "ct", "mot", "nn", "yout", "input", "butt", "kt", "fb", "bb", "token", "ou", "bp", "fp", "Button", "click", "t", "nc", "cmd", "bg", "affle", "bug", "bt", "tick", "ctrl", "wb", "cli", "kn", "c", "cb", "kk", "tag", "wp", "cn", "dt", "colour", "b", "dc", "rl", "wt", "gui", "touch", "lvl", "fl", "qa", "src", "tn", "callback", "batch", "wx", "ko", "bot", "qt", "typ", "toggle", "ctl"]}}
{"project": "qemu", "commit_id": "3a21532626bb5c3ecb0f916843f75ccce6501a9d", "target": 0, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    EHCIState *s = ptr;\n\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n\n    uint32_t old = *mmio;\n\n    int i;\n\n\n\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n\n\n\n    /* Only aligned reads are allowed on OHCI */\n\n    if (addr & 3) {\n\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n        return;\n\n    }\n\n\n\n    if (addr < OPREGBASE) {\n\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n\n\n    /* Do any register specific pre-write processing here.  */\n\n    switch(addr) {\n\n    case USBCMD:\n\n        if (val & USBCMD_HCRESET) {\n\n            ehci_reset(s);\n\n            val = s->usbcmd;\n\n            break;\n\n        }\n\n\n\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n\n            if (!ehci_enabled(s)) {\n\n                qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n\n                SET_LAST_RUN_CLOCK(s);\n\n            }\n\n            ehci_update_halt(s);\n\n        }\n\n\n\n        /* not supporting dynamic frame list size at the moment */\n\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n\n                    val & USBCMD_FLS);\n\n            val &= ~USBCMD_FLS;\n\n        }\n\n        break;\n\n\n\n    case USBSTS:\n\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n\n        val = s->usbsts;\n\n        ehci_set_interrupt(s, 0);\n\n        break;\n\n\n\n    case USBINTR:\n\n        val &= USBINTR_MASK;\n\n        break;\n\n\n\n    case FRINDEX:\n\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n\n        break;\n\n\n\n    case CONFIGFLAG:\n\n        val &= 0x1;\n\n        if (val) {\n\n            for(i = 0; i < NB_PORTS; i++)\n\n                handle_port_owner_write(s, i, 0);\n\n        }\n\n        break;\n\n\n\n    case PERIODICLISTBASE:\n\n        if (ehci_periodic_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n\n\n    case ASYNCLISTADDR:\n\n        if (ehci_async_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n    }\n\n\n\n    *mmio = val;\n\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n}\n", "idx": 20148, "substitutes": {"ptr": ["ts", "t", "tr", "fp", "f", "ctr", "ref", "tty", "eth", "r", "buffer", "str", "sb", "sl", "src", "scope", "pointer", "sh", "tc", "fd", "dr", "sth", "buf", "e", "tmp", "si", "p", "address", "inter", "proc", "inst", "Ptr", "port", "fi", "dll", "pt"], "addr": ["grad", "point", "offset", "vr", "x", "ref", "md", "align", "ar", "str", "arm", "adder", "padding", "pos", "layer", "anne", "config", "id", "asm", "ea", "afi", "p", "pad", "od", "adr", "mt", "conn", "len", "pc", "rx", "part", "eth", "rc", "ne", "hop", "ld", "pointer", "arr", "hw", "slot", "size", "xd", "route", "mac", "port", "aug", "amp", "dc", "code", "base", "alt", "r", "rt", "src", "node", "loc", "sta", "xp", "host", "nr", "ad", "start", "address", "inter", "ace", "amd", "frame", "edge", "eni", "rr", "db", "data", "mode", "ord", "coord", "oa", "ext", "ctx", "index", "slice", "nm", "rd", "alias", "pkg", "nc", "hl", "dr", "seq", "cmd", "kt", "url", "intel", "nn", "attr"], "val": ["Val", "al", "x", "ref", "pl", "num", "var", "pos", "store", "new", "elt", "p", "test", "aval", "valid", "bal", "fi", "ve", "pt", "len", "values", "part", "Value", "cal", "ne", "vals", " old", "ld", "pol", "count", "arg", "arr", "slot", "fl", "vol", "pre", "ol", "key", "bl", "v", "update", "pret", "play", "ret", "base", "err", "f", "alt", "sel", "ind", "VAL", "serv", "b", "live", "value", "cond", "db", "data", "all", "reg", "sl", "pass", "index", "def", " value", "prop", "bo", "old", "fail", "unit", "eval", "local", "el", "li"], "s": ["ns", "spec", "x", "settings", "service", "sie", "details", "ss", "cs", "d", "new", "socket", "qs", "slave", "sym", "p", "h", "sets", "m", "ts", "sg", "j", "rs", "scope", "self", "o", "su", "v", "si", "S", "a", "an", "ds", "ves", "instance", "f", "sv", "r", "sb", "this", "ins", "w", "serv", "sync", "c", "ps", "secondary", "b", "sys", "es", "state", "states", "sq", "sf", "session", "t", "stats", "request", "conf", "services", "n", "g", "sl", "ls", "ops", "fs", "is", "site", "e", "ssl", "ses", "js", "http", "gs", "os", "server", "se", "u"], "mmio": ["mmmno", "mbio", "mbni", "memio", " mmIO", "mbri", "mmmni", "memri", "mpno", "memo", "mIO", "memni", "mmmios", "mmios", "memios", "mbios", "mmri", "mio", " mmiao", "mmmiao", "mbIO", "mmIO", "mmo", " mmri", "mmno", "memori", "mmmio", " mmios", "mios", " mmo", "mmmori", "mpio", "memIO", "mpiao", "mmiao", "mmni", "mpios", "mbori", " mmno", "mo", "mmori"], "i": ["m", "j", "x", "f", "err", "r", "io", "n", "z", "I", "is", "l", "d", "ed", "e", "v", "c", "p", "b", "a", "end"]}}
{"project": "qemu", "commit_id": "f3db17b9514b8d724f8d6111a9f9608ff8bad631", "target": 1, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n\n    return chr;\n\n}", "idx": 20761, "substitutes": {"chr": ["echrr", " chrr", " chrs", "chrb", "Chr", "chrs", "chrc", " chru", "ichrc", "echrc", "corrs", " chlr", "chlr", "chru", " chrc", "corr", "ichr", "Chlr", "ichrr", "corrb", "echru", "echr", "ichru", "chrr", "Chrb", "Chrs", "corlr", " chrb"]}}
{"project": "qemu", "commit_id": "1f8828ef573c83365b4a87a776daf8bcef1caa21", "target": 0, "func": "static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIONet *n = opaque;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n\n\n    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)\n\n        return -EINVAL;\n\n\n\n    return virtio_load(vdev, f, version_id);\n\n}\n", "idx": 3845, "substitutes": {"f": ["fo", "fc", "fd", "tf", "fs", "fen", "a", "fac", "fa", "d", "elf", "fn", "F", "i", "m", "fab", "file", "fp", "sf", "df", "fe", "bf", "l", "c", "p", "e", "fx", "o", "v", "fb", "b", "t", "cf", "af", "fi"], "opaque": ["opacity", "opaques", "OPacity", "Opec", " oponymous", "OPec", "Opace", "OPace", "opace", "opusaque", " opacity", "opusaques", "OPaque", "omponymous", "Opacity", "oponymous", " opec", " opace", "ompaque", "opec", " opaques", "Opaque", "ompaques", "opusonymous"], "version_id": ["ver_id", "version_i", "ver_count", "ver_sid", "versionerid", "version_sid", "versionalsid", "ver_number", " version_ids", "versionerversion", "ver_ids", "versionali", "version_d", "version_name", "ver_version", "version_count", "versionernumber", "versioneri", "ver_name", "version_version", "versionalids", " version_d", "versionalid", " version_i", "version_number", "ver_i", "version_ids"], "n": ["name", "nn", "rn", "d", "nc", "pn", "k", "ne", "na", "y", "i", "g", "j", "ac", "m", "network", "nt", "z", "ns", "N", "c", "p", "l", "w", "e", "nb", "cn", "u", "node", "o", "v", "sn", "s", "b", "nw", "t", "an", "nor", "net"], "vdev": ["lvdevice", "lserv", "Vdevice", "lvver", "vver", "ddev", "vDev", "lvdev", "ldev", "Vserv", "dDev", " vda", " vDev", "vda", "lver", "vev", " vev", "lvserv", "dev", "pev", "dda", "Vdev", "vserv", "ldevice", "pdev", "Vver", "pda", "pDev", "vdevice"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *notifier,\n\n                            bool is_external,\n\n                            EventNotifierHandler *io_read,\n\n                            AioPollFn *io_poll)\n\n{\n\n    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,\n\n                       (IOHandler *)io_read, NULL, io_poll, notifier);\n\n}\n", "idx": 16794, "substitutes": {"ctx": ["pc", "cc", "fp", "obj", "cca", "rc", "gc", "io", "cm", "cf", "cb", "cp", "loc", "bc", "cas", "Context", "ca", "context", "pkg", "nc", "tx", "ci", "tc", "config", "xc", "sc", "cam", "client", "cli", "lc", "cr", "c", "qa", "cmp", "connection", "cv", "conn", "reader"], "notifier": ["notifer", "signification", "butification", "annifer", "notify", "annotifer", "netify", "notification", "annotizer", "signifer", "butifer", "netifier", "noticator", "butifier", "annifier", "signifier", "ntizer", "notizer", "netification", "annotifier", "annoticator", "toolification", "buticator", "nticator", " notizer", "annicator", "toolify", "toolifer", "ntifier", "toolifier", "annification", "netifer", "signicator", "annify", "ntifer", " notifer", " noticator"], "is_external": ["is_internal", "isingexternal", "isingExternal", " is_https", "isinghttps", " is_internal", "isingglobal", "is_https", "is_External", " is_global", " is_External", "is_global"], "io_read": [" io_run", "iopreader", " io_reader", "iopread", "event_poll", "ioseach", "iosrun", "iosread", "io_each", "event_read", "iosreader", "io_reader", "ioppoll", " io_each", "io_run", "event_reader"], "io_poll": ["iofselect", "io_select", "iofpoll", "iofwait", "io2poll", "io67wait", "io2install", "io67install", "io_scan", "io\u00b7scan", "io\u00b7wait", "io\u00b7select", " io_wait", "io_install", " io_select", "io_wait", " io_scan", "io2wait", "io67poll", "iofscan", " io_install", "io\u00b7poll"]}}
{"project": "FFmpeg", "commit_id": "136ce8baa4fc16cf38690cb457f7356c00e00a28", "target": 1, "func": "static void scale_coefs (\n\n    int32_t *dst,\n\n    const int32_t *src,\n\n    int dynrng,\n\n    int len)\n\n{\n\n    int i, shift, round;\n\n    int16_t mul;\n\n    int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7;\n\n\n\n    mul = (dynrng & 0x1f) + 0x20;\n\n    shift = 4 - ((dynrng << 23) >> 28);\n\n    if (shift > 0 ) {\n\n      round = 1 << (shift-1);\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp = temp + round;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          temp1 = temp1 + round;\n\n          dst[i] = temp >> shift;\n\n          temp3 = src[i+3] * mul;\n\n          temp2 = temp2 + round;\n\n\n\n          dst[i+1] = temp1 >> shift;\n\n          temp4 = src[i + 4] * mul;\n\n          temp3 = temp3 + round;\n\n          dst[i+2] = temp2 >> shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          temp4 = temp4 + round;\n\n          dst[i+3] = temp3 >> shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 >> shift;\n\n          temp5 = temp5 + round;\n\n          temp7 = src[i+7] * mul;\n\n          temp6 = temp6 + round;\n\n\n\n          dst[i+5] = temp5 >> shift;\n\n          temp7 = temp7 + round;\n\n          dst[i+6] = temp6 >> shift;\n\n          dst[i+7] = temp7 >> shift;\n\n\n\n      }\n\n    } else {\n\n      shift = -shift;\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          dst[i] = temp << shift;\n\n          temp3 = src[i+3] * mul;\n\n\n\n          dst[i+1] = temp1 << shift;\n\n          temp4 = src[i + 4] * mul;\n\n          dst[i+2] = temp2 << shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          dst[i+3] = temp3 << shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 << shift;\n\n          temp7 = src[i+7] * mul;\n\n\n\n          dst[i+5] = temp5 << shift;\n\n          dst[i+6] = temp6 << shift;\n\n          dst[i+7] = temp7 << shift;\n\n\n\n      }\n\n    }\n\n}\n", "idx": 19595, "substitutes": {"dst": ["dsl", "idrc", "dstr", "ndsc", "dset", "idsta", "pdst", "Dstr", "ldss", "pdsc", "dss", "lsta", "dsc", "Dsts", " dset", "pdsts", "idsc", "deste", "adsts", "Dstd", " dstr", "frc", "ldsc", "ldste", "ldest", "ldst", "dest", "dste", "idsts", "frest", "Dsc", "Dset", "Drc", " dsc", "idss", "addest", "lddest", "idset", " dest", "adsc", "drc", "idrest", "Dst", "sdsl", "adset", "lsts", " dste", "dstd", "idst", "ndst", "adstd", "sddest", "Dsl", "Drest", "sdsts", "lst", " ddest", "ndsl", "ldsts", "iddest", " dsts", "lsc", " dstd", "destd", "dests", "fst", "ldsl", "ddest", "dsta", "sdst", "ldstd", "pdset", "adst", "idstr", " dsta", "drest", "idest", " dss", "fsts", "idsl", "nddest", "dsts", " dsl"], "src": ["spec", "gn", "sup", "grad", "btn", "txt", "sit", "sur", "stat", "func", "rest", "irc", "dest", "sort", "rc", "supp", "sb", "cb", "sl", "attr", "loc", "sel", "ctx", "sec", "low", "gb", "rob", "usc", "inf", "secure", "conv", "feat", "ins", "stack", "www", "sites", "sn", "st", "img", "sub", "sr", "sc", "config", "sth", "ssl", "sync", "start", "gl", "rb", "seq", "lib", "support", "uc", "rss", "sci", "tmp", "url", "obl", "sys", "split", "proc", "inst", "iv", "ser", "rect", "desc", "sq", "kk", "source", "dist"], "dynrng": ["dynrface", "dynamrface", "dblRgen", "dynarng", "dynRgn", "dynsrNG", "dyncrNG", "dynrreg", "dynframp", "dynfrNG", "dynfrng", "dynamicrNG", "dynargen", "dblrgn", "dynsrng", "dynrNG", "dynRNG", "dynrangeface", "dblrng", "dynamrrng", "dynamrNG", "dynrrng", "dynRamp", "dynamrrNG", "dynsrgn", "dynrrface", "dynamicfrng", "dyncrgn", "dynRng", "dynamrng", "dynrangeNG", "dynrangereg", "dynrgen", "dynRreg", "dynamrrface", "dynamicrgen", "dynRface", "dynRgen", "dblRNG", "dynamrrreg", "dynamicfrNG", "dynrrNG", "dynamicframp", "dynrangeng", "dyncrng", "dblRgn", "dynfrgen", "dynamrreg", "dyncrgen", "dynramp", "dblrNG", "dynaramp", "dynamicrng", "dynrrreg", "dynamicramp", "dynsrgen", "dynarNG", "dynrgn", "dynamicfrgen", "dblRng", "dblrgen"], "len": ["lon", "bin", "offset", "lim", "alt", "all", "lit", "n", "num", "sl", "z", "loc", "ld", "pos", "dl", "dim", "en", "lf", "ln", "l", "val", "fl", "size", "length", "limit", "bl", "lc", "ll", "lvl", "depth", "lock", "fn", "split", "lin", "list", "el", "li", "Len"], "i": ["uri", "ic", "bi", "ji", "x", "jit", "qi", "ai", "phi", "hi", "ie", "d", "pi", "id", "cli", "ni", "p", "xi", "h", "us", "it", "me", "fi", "source", "gi", "m", "sup", "ei", "init", "j", "ix", "ini", "iu", "I", "o", "key", "k", "v", "si", "ki", "iv", "list", "ti", "f", "image", "r", "mi", "try", "ii", "di", "ind", "mini", "multi", "zi", "page", "l", "oi", "yi", "ci", "start", "q", "c", "line", "b", "eni", "mu", "info", "io", "n", "wait", "g", "ani", "z", "index", "slice", "is", "ip", "ui", "site", "isin", "e", "isi", "api", "my", "inner", "y", "li", "u"], "shift": ["set", "offset", "sample", "center", "align", "pack", "late", "pos", "zip", "reverse", "wind", "range", "ress", "sh", "select", "box", "length", "send", "mix", "crop", "pad", "pop", "loop", "repeat", "end", "scale", "sup", "init", "ff", "frac", "ix", "sort", "lower", "count", "vert", "share", "force", "load", "size", "patch", "off", "depth", "field", "flower", "cart", "order", "transfer", "push", "hift", "drop", "ice", "keep", "back", "ize", "start", "delay", "power", "gravity", "transform", "sq", "version", "sleep", "shape", "small", "throw", "hide", "slice", "ip", "half", "space", "seed", "roll", "use", "adjust", "pull", "limit", "fix", "pick", "cap", "error", "radius", "Shift", "diff", "escape", "dist"], "round": ["vel", "scale", "offset", "ff", "shape", "push", "ort", "call", "track", "alt", "ound", "sort", "scroll", "r", "feed", "drop", "Round", "type", "method", "control", "slice", "run", "low", "half", "range", "wind", "pair", "keep", "sound", "close", "rol", "hold", "build", "seed", "tab", "roll", "length", "key", "pull", "wave", "high", "shock", "patch", "render", "crop", "mix", "play", "lock", "rounded", "col", "cell", "field", "form", "row", "flower", "sign", "rect", "loop", "end", "port", "diff", "order", "attr", "grow", "version"], "mul": ["Mul", " muse", "amul", "Muli", " mil", "pmule", "nulus", "str", " mold", "Mule", "nuli", "pulus", "emula", "dil", "luse", "Mpull", " mulus", "tmUL", "pmula", "Male", "nul", "dUL", "amull", "pil", " mulation", "cmul", "mUL", "frac", "emule", "eff", "ctr", "mmold", "amule", "emul", "lesh", "lush", "mpull", "pmull", "mulus", "smul", " mun", "smUL", "mull", "smulation", "duse", "pUL", "null", " mull", "ampull", "dulation", "emull", "lUL", "dul", "dold", "amUL", "mmUL", "mula", "pale", "mmula", "mule", " mpull", "jull", "r", "Mush", " male", "mmul", "mun", "jesh", " mush", "mmuli", " mula", "smush", "smull", "cmull", "jUL", "mulation", "mush", "Mesh", "pmul", "Mulation", "mesh", "tmull", "lule", "amuli", " mule", "muli", " muli", "mil", "dull", "tmuli", "mold", "amulus", "tmul", "s", "pun", "dush", "Mil", "g", "lale", "jul", "muse", "cmun", "male", "pul", "dule", "MUL", "lull", "lula", " mUL", "add", "pull", "pmuli", "_", "Mull", "cmulus", "dale", "mmule", "mmull", "lul", "dula"], "temp": ["extra", "full", "pack", "copy", "empty", "cu", "comb", "cli", "mix", "p", "test", "tw", "dat", "output", "valid", "source", "pt", "input", "Temp", "tem", "m", "thin", "txt", "content", "mag", "dest", "mist", "stable", "clean", "cp", "timeout", "min", "magic", "count", "flat", "pre", "style", "flow", "key", "tmp", "null", "iter", "dc", "wave", "time", "base", "mi", "current", "toc", "loc", "orig", "mini", "model", "ctrl", "atom", "fake", "keep", "white", "w", "c", "emp", "cut", "template", "pure", "pot", "small", "data", "wrap", "buffer", "wait", "get", "porary", "partial", "seed", "cel", "tc", "unit", "perature", "cache", "form", "wa", "level", "api", "sign", "tp"], "temp1": ["fake1", "tem4", "temp0", "tmp1", "tem3", "fake0", "Temp15", " temp15", "tmp01", "Temp5", "Temp1", "fake3", "tmp2", "tmp15", "Temp01", "tem1", "tem5", " temp0", "tem2", " temp01", "Temp0", "fake4", "Temp3", "temp15", "tem0", "temp01", "Temp2"], "temp2": ["test5", "tem4", "temp0", "temp72", "tem3", "emp2", "test3", "tmp72", "pt4", "tem8", " temp72", "temp8", "tempB", "tmpB", "Temp5", " tempB", "Temp1", "pt2", "tmp2", "tem6", " temp02", "tem5", "tem1", "pt02", "Temp4", " temp0", "tem2", "Temp8", "tmp8", "emp72", "test2", "Temp0", "Temp3", "tem02", "tem0", "pt6", "emp8", "Temp2", " temp8", "empB", "test4", "temp02"], "temp3": ["tem4", "fake1", "test5", "temp03", "tem3", "tem7", "test3", " temp23", "emp23", "fake03", "emp3", "Temp5", "Temp1", "fake3", "emp30", " temp03", "tem5", "tem1", "test03", "Temp4", "tem2", "test2", "fake4", "temp30", "tempThree", " temp30", "Temp3", "tem30", "Temp7", "temp23", "tem23", "Temp2", "fake5", "fake2", " tempThree", "temThree", "empThree"], "temp4": ["tem4", "fake1", "iter1", "Temp6", "emp400", "emp40", "tmp400", " temp40", "fake6", "Temp5", "Temp1", "tem6", "temp400", "iter5", "tem5", "tem1", "emp5", "Temp4", "tem2", "test2", "test6", "fake4", "tmp4", "tmp5", "emp4", "test1", "tmp40", "iter4", "temp40", "Temp2", "fake5", "fake2", "test4", " temp400", "iter2"], "temp5": ["tem4", "iter1", "temp55", "tem3", " temp53", "Temp6", "iter6", " temp50", "tem53", " temp55", "Temp5", "fake6", "Temp1", "tem6", "iter3", "iter5", "tem5", "tem1", "Temp4", "tem2", "tem55", "fake4", "Temp3", "tmp55", "tmp5", "tmp50", "tem50", "tmp53", "Temp2", "temp50", "fake5", "fake2", "temp53"], "temp6": ["test5", "tem4", "tem7", "tem8", "Temp6", "tmp66", "fake8", "temp8", "temp06", "fake6", "Temp5", "tem6", "Temp68", "tmp06", " temp66", "tem5", "Temp4", "Temp8", "tmp8", "test6", "fake4", " temp68", "tmp6", "tmp5", "Temp7", " temp06", "Temp66", "Temp2", "tmp68", " temp8", "temp68", "fake2", "test4", "test8", "tem06", "temp66"], "temp7": ["temp13", "tem7", "temp67", "tem8", " temp87", "Temp6", "tem67", "tmp47", "tmp7", "temp8", " temp47", "tem87", "fake7", "fake6", "Temp5", "test67", "temp47", "tmp17", "temp17", "Temp4", "Temp47", "tmp8", " temp67", "test6", "test13", "fake4", "temp87", " temp13", "tmp6", "tmp5", "tmp67", "Temp7", "Temp67", "test7", " temp8", "fake5", "Temp13", "Temp17", " temp17", "tmp87"]}}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void arm_cpu_do_interrupt(CPUState *cs)\n{\n    ARMCPU *cpu = ARM_CPU(cs);\n    CPUARMState *env = &cpu->env;\n    unsigned int new_el = env->exception.target_el;\n    assert(!arm_feature(env, ARM_FEATURE_M));\n    arm_log_exception(cs->exception_index);\n    qemu_log_mask(CPU_LOG_INT, \"...from EL%d to EL%d\\n\", arm_current_el(env),\n                  new_el);\n    if (qemu_loglevel_mask(CPU_LOG_INT)\n        && !excp_is_internal(cs->exception_index)) {\n        qemu_log_mask(CPU_LOG_INT, \"...with ESR %x/0x%\" PRIx32 \"\\n\",\n                      env->exception.syndrome >> ARM_EL_EC_SHIFT,\n                      env->exception.syndrome);\n    }\n    if (arm_is_psci_call(cpu, cs->exception_index)) {\n        arm_handle_psci_call(cpu);\n        qemu_log_mask(CPU_LOG_INT, \"...handled as PSCI call\\n\");\n        return;\n    }\n    /* Semihosting semantics depend on the register width of the\n     * code that caused the exception, not the target exception level,\n     * so must be handled here.\n    if (check_for_semihosting(cs)) {\n        return;\n    }\n    assert(!excp_is_internal(cs->exception_index));\n    if (arm_el_is_aa64(env, new_el)) {\n        arm_cpu_do_interrupt_aarch64(cs);\n    } else {\n        arm_cpu_do_interrupt_aarch32(cs);\n    }\n    arm_call_el_change_hook(cpu);\n    if (!kvm_enabled()) {\n        cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n    }\n}", "idx": 19216, "substitutes": {"cs": ["pc", "ns", "spec", "ts", "s", "bs", "rs", "core", "ras", "cal", "cus", "vc", "ix", "conn", "cm", "cf", "Cs", "CS", "cp", "ls", "bc", "ces", "ctx", "wcs", "utils", "fs", "cer", "cons", "cas", "cks", "sk", "ca", "css", "acs", "cms", "ce", "nc", "ins", "args", "ci", "qs", "sc", "ics", "vs", "codes", "sync", "alls", "lc", "c", "ps", "js", "ck", "ks", "cmp", "ec", "sys", "ced", "cn", "cases", "cc", "ds"], "cpu": ["pc", "process", "instance", "cal", "core", "jp", "cus", "platform", "uci", "component", "runner", "cm", "nic", "cf", "loader", "cpp", "anc", "cp", "bc", "ctx", "fc", "mc", "console", "bench", "vm", "auc", "css", "roc", "hw", "linux", "chip", "nc", "CPU", "gpu", "config", "cu", "processor", "cli", "lc", "c", "kernel", "uc", "cache", "cmp", "ec", "orc", "clock", "boot", "cn", "proc", "os", "pu", "mac", "eni", "np", "cow", "conn"], "env": ["viron", "cfg", "extra", "settings", "cf", "anc", "environment", "console", "energy", "enc", "vm", "stack", "kn", "config", "ev", "cli", "impl", "ea", "opt", "enh", "cv", "conn", "cdn", "cal", "eve", "eye", "eu", "engine", "ne", "bc", " environment", "scope", "eng", "hw", "exe", "style", "iss", "v", "nw", "ec", "et", "export", "ds", "code", "core", "err", "net", "icer", "ass", "inet", "vs", "csv", "sys", "ace", "edge", "eni", "np", "Environment", "db", "conf", "skin", "exc", "loader", "module", "oa", "ext", "ctx", "en", "context", "ce", "nc", "args", "site", "e", "esm", "que", "cache", "osc", "agent", "el"], "depend": ["data", "dep", "dependent", "depending", "ependence", " react", "epend", "react", " independ", "respond", "cript", "Dep", " insist", "reflect", "ind", "Depending", "draw", "cend", " depended", " dependency", "sil", " Depend", " dependent", " dep", "ependent", "desc", " dependence"], "the": ["t", "athe", "f", "true", "all", "eth", "natural", "ethe", "their", "then", "n", "pe", "The", "current", "or", "match", "type", "public", "as", "th", "function", "this", "in", " The", "THE", "my", "what", "member", "page", "non", "broad", "d", "same", "to", "new", "and", "team", "no", "het", "last", "length", "ev", "since", "display", "_", "you", "by", "one", "test", "total", "\u00eb", "ure", "wh", "your", "end", "that", "them", "he", "with", "it", "an"], "of": ["at", "without", "name", "component", "OF", "from", "n", "on", "channel", "or", "type", "in", "Of", "oft", "new", "e", "by", "outside", "number", "during", "that", "with", "own", "one", "less", "source", "sf"], "caused": ["caated", "Caated", "Caued", "taued", "accuses", "Causes", "accused", "causes", "taused", "tauses", "Caused", "caued", "taated", "accated", "accued"], "exception": ["EXparent", "excevent", "extvention", "execformer", "excvention", "execception", "exceptions", "exposure", "EXception", "EXacket", "externalchange", " exformer", "extceptions", "execacket", "extposure", "exformer", "extception", " exacket", "excception", "lexception", "excexc", "execceptions", "excposure", "exchange", "ceptionception", "externalevent", "lexevent", "exevent", "EXceptions", "ceptionchange", "EXvention", "EXposure", "externalerror", "extparent", "pexevent", "exexc", "pexexc", "expresschange", "EXformer", "pexception", "exerror", "expresserror", "lexexc", "ceptionerror", "expressevent", "exacket", "exparent", "Exposition", "exposition", "EXposition", "expressception", "excposition", "extposition", "Exparent", "Exceptions", "externalception", "Exception", "exvention", "ceptionevent", " exceptions"], "not": ["at", "set", "un", "t", "ot", "note", "all", "nt", "ne", "n", "or", "nor", "match", "is", "bad", "non", "found", "Not", "no", "about", "NOT", "but", "et", "it", "by"], "target": ["rest", "platform", "arget", "current", "root", "master", "match", "effective", "top", "nat", "host", "lead", "new", "site", "config", "parent", "unit", "test", "external", "average", "next", "tail", "export", "supported", "real", "source"], "level": ["Level", "status", "point", "scale", "name", "type", "index", "scope", "location", "layer", "class", "path", "stack", "rule", "style", "length", "id", "limit", "levels", "stage", "line", "lvl", "depth", "error", "number", "sequence", "value"], "so": ["ans", "thus", "say", "s", "plus", "then", "because", "see", "who", "new", "and", "no", "since", "xxx", "e", "you", "can", " which", " So", "how", "now", " thus", "So", "co", "also"], "be": ["call", "ste", "fe", "ape", "see", "make", "te", "help", "en", "ae", "is", "ome", "stay", "always", "Be", "to", "le", "use", "st", "bl", "play", "BE", "bes", "co", "se"]}}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||\n\n        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n        (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        return lchown(rpath(fs_ctx, path, buffer),\n\n                      credp->fc_uid, credp->fc_gid);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        return local_set_mapped_file_attr(fs_ctx, path, credp);\n\n    }\n\n    return -1;\n\n}\n", "idx": 5102, "substitutes": {"fs_ctx": ["fsptx", "FS_cb", "fsalcb", "fs_cn", "FS_context", "ts_tx", "ws_cu", "fsdbcrit", "fsprectx", "fspcb", "fs_sem", "cs_conn", "fs__cas", "fs__cl", "fsprecn", "fs__ctx", "ts_git", "fs_scope", "fsdbctx", "fsalgit", "fs32gc", "FS_scope", "ts_gc", "cs_ca", "fs_cor", "fs_cb", "FS_ctx", "fsjctx", "cs_cor", "fs_cl", "ts_ctx", "FS_cn", "FS_la", "ws_conn", "fsaltx", "fs_crit", "fsalcontext", "fs_cu", "FS_sem", "fs_tx", "fsdbconn", "FS_cl", "fs_wcs", "fsjcl", "fs32tx", "fsprecontext", "fs_conn", "fsprewcs", "fs_la", "ws_ctx", "fsjcontext", "cs_ctx", "ws_crit", "fsalctx", "fsalgc", "fs32git", "fs_gc", "fs32ctx", "FS_wcs", "fspctx", "fs_ca", "FS_cas", "fsdbcu", "FS_tx", "fs_context", "fs_cas", "fs_git", "fs__context", "fsjcas", "fspcontext"], "fs_path": ["f_crit", "f_source", "fc_config", "fs___context", "fsscontext", "fsmlpath", "fsmlsource", "fs___crit", "fs___path", "fs_config", "fs_source", "f_context", "fs_crit", "fssobject", "fc_context", "fs_object", "f_path", "fs_context", "fsmlcrit", "fssconfig", "fsmlcontext", "fc_path", "fc_object", "fs___source", "fsspath"], "credp": ["acrdP", "credpa", "credv", "cedl", "credpart", "chedpa", " credpre", "cribP", "ancreaml", "caredP", " credpt", "cronc", "cribv", " creditsp", " creditsc", "critpre", "scredc", "crdpi", "cribpre", "cedpc", "crafpart", "credP", "encredP", "cronh", " credc", "credpi", "creampi", "cachedp", "encdefp", "carpp", "creamp", "creditspa", "acredp", "creampa", "encdefc", "caredpc", " cribp", "encredpart", "acredc", "scribh", "encredc", "credpre", "crafP", "crafc", "cachedP", "cdefP", "crcpre", "cdefc", "caredp", " cprivP", "creditspi", "crcp", "ancreamP", " cprivp", "ancreamp", "scredh", "creampc", "crafp", "scribp", "ancreampc", "creditsp", "scribc", "cprivp", "creamc", "crcpt", "cprivc", " cribpt", " creditspa", " credpi", "credpt", "cribpt", "cachedc", "ancredP", "cdefp", "credpc", "crdP", "cribh", "creamP", " credpc", "scredp", " cribv", "scredpa", "cronp", " credP", "cdefpart", "critp", "acrdpi", "cronpa", "cprivpc", "acrdc", "carpc", "cedp", "carph", " cprivc", "encdefpart", "chedpi", "cribpc", "crcv", "cprivP", "cachedpart", "credh", "caredl", "cedP", "ancredl", "credc", " credv", "critv", "credl", "acredP", "scribpa", " cprivpc", " credpa", "cribpi", "acrdp", "critpt", "cprivpi", "chedc", "acredpi", "encredp", "ancredpc", " creditspi", "cribp", "chedp", "encdefP", "cribpa", "creditsc", " cribpre", "creaml", "crdc", "ancredp", "carppa", "cribc", "crdp"], "buffer": ["writer", "base", "flow", "name", "feed", "buff", "header", "padding", "iter", "block", "count", "b", "uffer", "data", "slice", "abi", "queue", "info", "map", "buf", "null", "fb", "uf", "f", "url", "limit", "length", "byte", "len", "Buffer", " buffers", "binary", " buf", "bytes", "pad", "cb", "str", "source", "array", "batch", "reader", "transfer", "slave", "type", "cache", "reference", "loader", "seed", "size"], "path": ["name", "area", "anc", "id", "parent", "entry", "config", "object", "data", "home", "sync", "enc", "pattern", "uc", "image", "loc", "route", "th", "key", "rh", "content", "child", "url", "Path", "arc", "dir", "part", "uri", "mount", "col", "file", "binary", "port", "container", "loader", "filename", "ith", "source", "p", "temp", "root", "PATH", "ath", "pointer", "node", "txt", "location", "transform", "link", "inner", "text", "ref", "cache", "host", "end", "prefix"]}}
{"project": "FFmpeg", "commit_id": "066ad0926a53ea6ee9d5cb3e348160a881145e73", "target": 1, "func": "static int tmv_read_seek(AVFormatContext *s, int stream_index,\n\n                         int64_t timestamp, int flags)\n\n{\n\n    TMVContext *tmv = s->priv_data;\n\n    int64_t pos;\n\n\n\n    if (stream_index)\n\n        return -1;\n\n\n\n    pos = timestamp *\n\n          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);\n\n\n\n    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);\n\n    tmv->stream_index = 0;\n\n    return 0;\n\n}\n", "idx": 3551, "substitutes": {"s": ["sg", "server", "js", "service", "src", "cs", "http", "ss", "spec", "ts", "a", "sb", "d", "n", "aws", "client", "i", "g", "m", "ls", "ses", "sf", "sync", "settings", "slice", "storage", "sets", "ds", "gs", "ns", "c", "p", "services", "w", "e", "self", "f", "es", "sq", "o", "v", "S", "t", "os", "socket", "support", "ssl"], "stream_index": ["streamerindex", "forwardidsource", "fileerpointer", "streamerstring", "stream_prefix", "streamidposition", "streamidindex", "streamidsource", "streamerlevel", "streamflowsource", "fileerindex", "forward_source", "stream_string", "streamalindex", "stream_level", "forward_length", "fileerstring", "forward_index", "streamingprefix", "stream_length", "forwardidlength", "streamingindex", "file_pointer", "stream_source", "forwardidposition", "streamingaddress", "streamerpointer", "streamflowposition", " stream_address", "forwardidindex", "streamalstring", "streamflowlength", "streamflowindex", "fileerlevel", "forward_position", "streamidlength", "stream_pointer", " stream_prefix", "stream_address", "file_index", "stream_position", "streamallevel", "file_level", "file_string", "streamalpointer"], "timestamp": ["framestamp", "paramcision", "memoffset", "Timetime", "timcision", "timmark", "paramoffset", " Timeline", " Timetime", "timoffset", "paramestamp", "Timeline", "neweline", "Timmark", " Timestamp", "newmark", "memcision", "memestamp", "newetime", "timetime", "framoffset", "newestamp", "memetime", "parametime", "Timestamp", "timeline", "framcision", "frametime", " Timmark"], "flags": ["ff", "fd", "Flags", "time", "spec", "ts", "vals", "ms", " flag", "options", "bits", "args", " positions", "style", "xff", "len", "f", "flag", "date", "mask", "sec", " whence", "seq", "bytes", "count", "fs", "port"], "tmv": ["tmg", "mmtv", "mtper", "htmcf", "tctv", "pmf", "tomv", "tmov", "timv", "mmcf", "TMv", "tcv", "timg", "tmvv", "tomper", "tcver", "TMcf", "tomg", "tmper", "htmvv", "mmvc", "tomcf", "pmv", "timov", "TMver", "TMvv", "pmvc", "htmv", "mf", "tmver", "tktv", "mtov", "tmvc", "tkv", "mmuv", "htmver", "tmuv", "mv", "tmtv", "tomov", "tmcf", "tkvv", "tomf", "mq", "tomvc", "tcf", "tkf", "timper", "pmcf", "mmq", "muv", "tmf", "tccf", "mmv", "mmf", "tcvv", "mmvv", "tlf", "tmq", "tlq", "tluv", "mtg", "mtv", "tlv"], "pos": ["POS", "no", "offset", "spec", "loc", "position", " position", "slot", "prop", "tell", "type", "found", "end", "neg", "pres", "i", "pass", "po", "index", "pid", "pointer", "cond", "pad", "block", "p", "len", "size", "patch", "mon", "cache", "conf", "min", "obj", "rel", "pc", "o", "seq", "os", "Pos", "val", "addr", "part", "pt", "start", "port"]}}
{"project": "FFmpeg", "commit_id": "4691a77db4672026d62d524fd292fb17db6514b4", "target": 1, "func": "static inline int get_chroma_qp(H264Context *h, int qscale){\n\n    return h->pps.chroma_qp_table[qscale & 0xff];\n\n}\n", "idx": 17893, "substitutes": {"h": ["m", "ch", "t", "eh", "image", "oh", "n", "gh", "i", "cpp", "hd", "rh", "ctx", "host", "context", "hw", "header", "ht", "him", "sh", "ahi", "w", "hl", "q", "e", "bh", "ih", "v", "c", "hp", "p", "hm", "b", "http", "hh", "ec", "ph", "ha", "hs", "he", "ah", "H"], "qscale": ["eqset", "eqslice", "qualcale", "bitcale", "qqshape", "qualset", "bitset", " qcale", "qqcale", "bitscale", "qshape", "wcale", "eqscale", "eqcale", " qshape", "wshape", "qset", "wscale", "qcale", "qualscale", "qslice", "qqscale", "bitslice", "qualslice"]}}
{"project": "qemu", "commit_id": "dde3a2184074f5c4279fd7fbfc597b5dc5859fb8", "target": 1, "func": "static void hmp_migrate_status_cb(void *opaque)\n\n{\n\n    MigrationStatus *status = opaque;\n\n    MigrationInfo *info;\n\n\n\n    info = qmp_query_migrate(NULL);\n\n    if (!info->has_status || strcmp(info->status, \"active\") == 0) {\n\n        if (info->has_disk) {\n\n            int progress;\n\n\n\n            if (info->disk->remaining) {\n\n                progress = info->disk->transferred * 100 / info->disk->total;\n\n            } else {\n\n                progress = 100;\n\n            }\n\n\n\n            monitor_printf(status->mon, \"Completed %d %%\\r\", progress);\n\n            monitor_flush(status->mon);\n\n        }\n\n\n\n        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);\n\n    } else {\n\n        if (status->is_block_migration) {\n\n            monitor_printf(status->mon, \"\\n\");\n\n        }\n\n        monitor_resume(status->mon);\n\n        timer_del(status->timer);\n\n        g_free(status);\n\n    }\n\n\n\n    qapi_free_MigrationInfo(info);\n\n}\n", "idx": 2967, "substitutes": {"opaque": ["opacity", "opaques", "operaques", "ovacity", "operaque", "copaques", "obacity", "obque", "copque", "ovaque", "copacity", "operacity", "oacity", "ovque", "obaque", "obaques", "oque", "copaque", "oaques", "ovaques", "opque", "operque", "oaque"], "status": ["js", "active", "success", "Status", "sp", "job", "wait", "code", "args", "index", "description", "sys", "message", "summary", "comment", "s", "action", "fs", "login", "name", "stat", "spec", "image", "id", "api", "model", "update", "state", "uses", "serv", "site", "plugin", "user", "base", "version", "data", "complete", "settings", "str", "json", "content", "result", "order", "size", "date", "cache", "note", "prefix", "error", "module", "msg", "mode", "si", "stage", "server", "service", "check", "gi", "method", "STAT", "scope", "num", "score", "details", "sync", "style", "source", "temp", "reason", "token", "stats", "full"], "info": ["ret", "job", "options", "args", "index", "feed", "archive", "information", "f", "comment", "by", "fi", "start", "name", "abi", "stat", "extra", "zip", "image", "type", "id", "end", "Info", "api", "off", "update", "parse", "ie", "state", "conf", "die", "io", "init", "base", "INFO", "ii", "fw", "data", "di", "is", "op", "py", "i", "json", "result", "bot", "iso", "note", "about", "error", "si", "inf", "fo", "service", "check", "total", "gi", "http", "def", "ga", "alias", "now", "num", "detail", "details", "source", "config", "ip", "fb", "full", "part", "diff"], "progress": ["flow", "total", "version", "active", "usage", "percent", "grade", "activity", "data", "area", "speed", "success", "complete", "current", "press", "recent", "help", "wait", "pass", "max", "fail", "update", "move", "partial", "sync", "err", " Progress", "pool", "step", "result", "content", "work", "p", "Progress", "resource", "length", "size", "track", "demand", "history", "message", "grades", "value", "scale", "rss", "error", "bar", "quick", "path", "count", "performance", "export", "diff", "dist", "done"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_whitespace(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        LiteralQObject decoded;\n\n    } test_cases[] = {\n\n        {\n\n            .encoded = \" [ 43 , 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        {\n\n            .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\",\n\n            .decoded = QLIT_QLIST(((LiteralQObject[]){\n\n                        QLIT_QINT(43),\n\n                        QLIT_QDICT(((LiteralQDictEntry[]){\n\n                                    { \"h\", QLIT_QSTR(\"b\") },\n\n                                    { \"a\", QLIT_QINT(32) },\n\n                                    { }})),\n\n                        QLIT_QLIST(((LiteralQObject[]){\n\n                                    { }})),\n\n                        QLIT_QINT(42),\n\n                        { }\n\n                    })),\n\n        },\n\n        { }\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QObject *obj;\n\n        QString *str;\n\n\n\n        obj = qobject_from_json(test_cases[i].encoded, NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        str = qobject_to_json(obj);\n\n        qobject_decref(obj);\n\n\n\n        obj = qobject_from_json(qstring_get_str(str), NULL);\n\n        g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1);\n\n\n\n        qobject_decref(obj);\n\n        QDECREF(str);\n\n    }\n\n}\n", "idx": 3179, "substitutes": {"i": ["yi", "my", "li", "gi", "abi", "ni", "ii", "zi", "ji", "jit", "ui", "pi", "oi", "d", "I", "n", "di", "id", "mi", "it", "iu", "k", "j", "bis", "y", "m", "eni", "inner", "ri", "info", "ti", "slice", "multi", "index", "ini", "ai", "ie", "x", "ind", "ip", "phi", "adi", "bi", "p", "e", "l", "f", "c", "u", "idi", "ori", "o", "v", "iv", "qi", "b", "t", "ix", "uri", "ci", "io", "init", "part", "fi", "si", "in", "xi"], "encoded": [" enccoded", "engoder", " encoder", "enoding", "enrypted", "entoding", "Encoding", "unicoder", "decoding", "integoding", "decoded", "integcoded", " encicated", "entcoded", "decicated", "Encrypted", "engoding", "Encoder", "deccoded", "encoder", "unicoded", "enoder", "Encoded", "engoded", " encoding", "Enccoded", "encicated", "encoding", "entoder", "unicoding", "encrypted", "enccoded", "uniccoded", "integoded", "decoder", "entoded", "engcoded", "enoded", "integicated", "decrypted"], "test_cases": ["testpleclasses", "testAllcontent", "testedParfiles", "testLfiles", "test_content", "testEreports", "test64rooms", "testingrooms", "test64cases", "test_test", "tested_reports", "test_tips", "Test_cases", "testaldetails", "testalclasses", "testaltips", "testalcases", "testEtests", "testedPartests", "test_tests", "serveralclasses", "serveraldetails", "testAlltest", "testalsteps", "test_files", "test_details", "Test_rooms", "testingcases", "testaltimes", "test_steps", "testLdetails", "testingtests", "tested_tests", "server_details", "testalfiles", " test_tips", "testplefiles", "testEcases", "test64reports", "testPartests", "testParfiles", "Test_tests", "testAllcases", "serveralcases", "testLcases", "testplecases", "testdefcases", "server_classes", "test_rooms", " test_times", "testingreports", " testdefcontent", "testEtips", "testParreports", "testEtimes", "test_reports", " testdeftests", "testEsteps", "test_classes", "tested_files", "server_cases", "testpledetails", "testEfiles", "testdefcontent", " test_test", "testAlltests", "test_times", " test_content", " test_tests", "testLclasses", "testdeftest", " test_steps", "test64tests", "testParcases", "tested_cases", " testdeftest", "server_files", "serveralfiles", "testedParreports", "testdeftests", " testdefcases", "Test_reports", "testedParcases"], "obj": ["ob", "js", "act", "ass", "active", "txt", "n", "alt", "Obj", "j", "code", "eff", "err", "opt", "x", "pr", "css", "object", "jp", "ex", "ot", "name", "ext", "id", "arr", "tmp", "api", "off", "po", "Object", "z", "p", "sn", "lib", "iv", "os", "val", "init", "pt", "so", "att", "ctx", "data", "out", "cat", "op", "py", "cb", "json", "ns", "result", "nb", "ref", "attr", "el", "o", "inst", "img", "adj", "elt", "bo", "dict", "pos", "coll", "style", "block", "kl", "art", "b", "part", "obb"], "str": ["dr", "js", "name", "cs", "ext", "Str", "rs", "elt", "wr", "data", "r", "n", "sl", "dict", "arr", "enc", "Obj", "j", "bl", "pass", "hr", "stri", "code", "fr", "err", "style", "cr", "tr", "z", "st", "ind", "block", "css", "pr", "br", "text", "object", "sr", "o", "pt", "STR"]}}
{"project": "FFmpeg", "commit_id": "e477f09d0b3619f3d29173b2cd593e17e2d1978e", "target": 1, "func": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int v, i;\n\n\n\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        if (length > 256 || !(s->state & PNG_PLTE))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length; i++) {\n\n            v = bytestream2_get_byte(&s->gb);\n\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n\n        }\n\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length / 2; i++) {\n\n            /* only use the least significant bits */\n\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n\n\n\n            if (s->bit_depth > 8)\n\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n\n            else\n\n                s->transparent_color_be[i] = v;\n\n        }\n\n    } else {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    s->has_trns = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23309, "substitutes": {"avctx": ["avesci", "Avsci", "avectx", "afsci", "Avmedia", "Avctx", "afcontext", "afctx", "avcontext", "afmedia", "avemedia", "avmedia", "avsci", "Avcontext", "avecontext"], "s": ["ions", "sv", "es", "uns", "xs", "ds", "sys", "r", "os", "ssl", "ts", "cs", "us", "params", "js", "aws", "ms", "S", "ns", "rs", "ins", "ans", "conf", "http", "l", "ss", "this", "sb", "rows", "g", "ses", "d", "sets", "as", "ches", "services", "u", "o", "sg", "c", "self", "spec", "a", "sf", "ies", "ats", "su", "e", "sym", "qs", "hs", "fs", "lines", "ings", "f", "t", "new", "p", "si", "b", "service", "ims", "parts", "ps", "gs", "h", "sq", "sl", "ubs", "als", "your", "ops", "plugins", "ks", "m", "args", "its", "strings", "ys", "ls", "sync", "is", "settings", "session", "comments"], "length": ["off", "part", "duration", "oh", "buffer", "path", "other", "sequence", "j", "list", "url", "load", "pl", "line", "slice", "angle", "l", "type", "delay", "end", "text", "style", "sth", "lock", "code", "child", "position", "tail", "ph", "k", "section", "size", "full", "zip", "p", "number", "el", "form", "ength", "total", "th", "count", "shape", "limit", "level", "sl", "Length", "build", "id", "L", "supp", "match", "sh", "se", "seq", "len", " lengths", "block", "value"], "v": ["conv", "tv", "sv", "e", "limit", "end", "nv", "V", "lv", "iv", "g", "gu", "val", "av", "cv", "d", "vd", "qv", "f", "t", "y", "u", "r", "m", "j", "p", "uv", "vals", "vs", "vi", "code", "o", " V", "q", "c", "ver", "a", "b", "ii", "volt", "w", "vol", "n", "va", "vv", "ve", "z", "vp", "h", "ev", "l", "x", "k", "value"], "i": ["io", "ix", "e", "ie", "fi", "qi", "ri", "ind", "iv", "ui", "eni", "pi", "gi", "uri", "ti", "I", "f", "ci", "y", "oi", "u", "ini", "info", "phi", "j", "it", "ip", "p", "abi", "id", "vi", "bi", "o", "is", "mi", "cli", "c", "mu", "index", "si", "ii", "b", "ji", "n", "iu", "slice", "ai", "xi", "hi", "di", "multi", "yi", "li", "z", "api", "l", "x", "zi", "k", "ni", "ori"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float32 HELPER(ucf64_abss)(float32 a)\n\n{\n\n    return float32_abs(a);\n\n}\n", "idx": 10316, "substitutes": {"a": ["va", "area", "abc", "n", "window", "ba", "m", "b", "x", "ab", "pa", "d", "i", "sa", "data", "c", "addr", "p", "e", "ata", "at", "au", "value", "f", "ac", "an", "la", "alpha", "ae", "ea", "aux", "ga", "A", "offset", "as", "u", "h", "aa"]}}
{"project": "FFmpeg", "commit_id": "73dacabfc9b9ef1fd2c08105fdab6238ee29c2fc", "target": 0, "func": "av_cold int ffv1_init_slice_contexts(FFV1Context *f)\n\n{\n\n    int i;\n\n\n\n    f->slice_count = f->num_h_slices * f->num_v_slices;\n\n    if (f->slice_count <= 0) {\n\n        av_log(f->avctx, AV_LOG_ERROR, \"Invalid number of slices\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < f->slice_count; i++) {\n\n        FFV1Context *fs = av_mallocz(sizeof(*fs));\n\n        int sx          = i % f->num_h_slices;\n\n        int sy          = i / f->num_h_slices;\n\n        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;\n\n        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;\n\n        int sys         = f->avctx->height *  sy      / f->num_v_slices;\n\n        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;\n\n        f->slice_context[i] = fs;\n\n        memcpy(fs, f, sizeof(*fs));\n\n        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));\n\n\n\n        fs->slice_width  = sxe - sxs;\n\n        fs->slice_height = sye - sys;\n\n        fs->slice_x      = sxs;\n\n        fs->slice_y      = sys;\n\n\n\n        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *\n\n                                      sizeof(*fs->sample_buffer));\n\n        if (!fs->sample_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2083, "substitutes": {"f": ["fo", "fc", "flow", "feature", "files", "this", "tf", "fd", "fun", "fen", "def", "flat", "raf", "fac", "fw", "form", "fa", "d", "lf", "fl", "field", "k", "rf", "F", "g", "j", "m", "fab", "sf", "fp", "info", "df", "fr", "file", "framework", "bf", "feed", "fe", "function", "x", "l", "c", "p", "fi", "h", "w", "e", "self", "ref", "conf", "u", "fx", "of", "fm", "v", "s", "fb", "b", "t", "cf", "uf", "af", "full", "diff", "inf", "family"], "i": ["ami", "li", "gi", "ni", "ii", "zi", "area", "ui", "pi", "mini", "d", "I", "di", "n", "id", "mi", "im", "iu", "it", "k", "ij", "api", "j", "y", "eni", "m", "inner", "ri", "info", "ti", "ini", "index", "z", "multi", "ai", "ie", "x", "l", "ip", "p", "hi", "bi", "c", "e", "ind", "phi", "u", "o", "v", "s", "ki", "qi", "ix", "b", "uri", "ci", "io", "fi", "start", "si", "xi"], "fs": ["fc", "files", "fd", "tf", "cs", "Fs", "FS", "qs", "rs", "ts", "raf", "flat", "vals", "fw", "ips", "flags", "ums", "cells", "reads", "fits", "lf", "ms", "fn", "rets", "fps", "frames", "ls", "fp", "sf", "args", "df", "fr", "file", "outs", "flows", "ds", "utils", "json", "ps", "bf", "feed", "fe", "ns", "fi", "irs", "gs", "vs", "vers", "lines", "ports", "features", "pages", "rows", "posts", "fat", "fx", "uses", "s", "linux", "fields", "fb", "ves", "cf", "ks", "times", "uf", "full", "bs", "os", "ows", "fer", "obs"]}}
{"project": "qemu", "commit_id": "e774a278d82c9391c9fb6c9af42cd08bb9364b9f", "target": 0, "func": "static void ide_sector_write(IDEState *s)\n\n{\n\n    int64_t sector_num;\n\n    int ret, n, n1;\n\n\n\n    s->status = READY_STAT | SEEK_STAT;\n\n    sector_num = ide_get_sector(s);\n\n#if defined(DEBUG_IDE)\n\n    printf(\"write sector=%Ld\\n\", sector_num);\n\n#endif\n\n    n = s->nsector;\n\n    if (n > s->req_nb_sectors)\n\n        n = s->req_nb_sectors;\n\n    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);\n\n    s->nsector -= n;\n\n    if (s->nsector == 0) {\n\n        /* no more sector to write */\n\n        ide_transfer_stop(s);\n\n    } else {\n\n        n1 = s->nsector;\n\n        if (n1 > s->req_nb_sectors)\n\n            n1 = s->req_nb_sectors;\n\n        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);\n\n    }\n\n    ide_set_sector(s, sector_num + n);\n\n    \n\n#ifdef TARGET_I386\n\n    if (win2k_install_hack) {\n\n        /* It seems there is a bug in the Windows 2000 installer HDD\n\n           IDE driver which fills the disk with empty logs when the\n\n           IDE write IRQ comes too early. This hack tries to correct\n\n           that at the expense of slower write performances. Use this\n\n           option _only_ to install Windows 2000. You must disable it\n\n           for normal use. */\n\n        qemu_mod_timer(s->sector_write_timer, \n\n                       qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));\n\n    } else \n\n#endif\n\n    {\n\n        ide_set_irq(s);\n\n    }\n\n}\n", "idx": 27046, "substitutes": {"s": ["sys", "server", "ns", "ts", "sites", "request", "ps", "states", "sync", "sis", "self", "u", "es", "gs", "south", "sie", "sym", "xs", "f", "service", "status", "js", "qs", "fs", "t", "tests", "ops", "S", "p", "m", "c", "se", "ds", "us", "state", "su", "is", "sets", "ims", "ions", "spec", "new", "services", "details", "sl", "settings", "in", "its", "side", "g", "rs", "ses", "args", "ss", "d", "conf", "sg", "ks", "e", "session", "hs", "sb", "your", "ches", "ssl", "cs", "i", "site", "o", "si", "os", "uns", "as", "ls", "a", "parts", "l"], "sector_num": [" sector_number", "sector_n", "sector_number", "sector_su", "section_num", "sector_sum", "sector_unit", "section_n", " sector_sum", "section_name", " sector_name", "section_unit", " sector_n", " sector_su", "sector_name"], "ret": ["fin", "ner", "nat", "sn", "ll", " RET", "fn", "en", "br", "nn", "ern", " Ret", "id", "ne", "al", "iter", "bit", "det", "RET", "re", "nt", "sec", " r", "Ret", " result", " fun", "f", "j", "t", "conn", "ind", "g", "result", "len", "val", "fun"], "n": ["nan", "np", "k", "nm", "none", "z", "w", "i", "b", "m", "p", "pn", "c", "ns", "rn", "d", "sn", "name", "adj", "x", "fn", "en", "no", "nn", "num", "ne", "nor", "o", "nb", "ni", "nt", "mn", "cn", "eni", "N", "f", "y", "nr", "na", "j", "t", "un", "nl", "conn", "net", "init", "nu", "r", "v", "an", "in", "nc", "l", "g", "dn", "nat"], "n1": ["nvar", "N2", "N1", "N0", "done", "d91", "ynOne", "enif", "numif", "yn1", "none", "nname", "n81", "m2", "ynif", "dOne", "m1", "m0", "unOne", "envar", "un91", " nname", "n01", " n0", "d1", "rnname", " n01", "sn2", "nif", "ynvar", "sn01", "num81", " n2", "sn1", "yn0", " nOne", "ynname", "na91", "un1", "rnOne", "n91", "en81", "naOne", "nOne", "rn1", "naone", "n2", "num1", "N01", "rn0", "unone", "yn81", "numvar", "na1", "n0", "en1"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void *rom_ptr(target_phys_addr_t addr)\n\n{\n\n    Rom *rom;\n\n\n\n    rom = find_rom(addr);\n\n    if (!rom || !rom->data)\n\n        return NULL;\n\n    return rom->data + (addr - rom->addr);\n\n}\n", "idx": 26225, "substitutes": {"addr": ["ref", "node", "md", "code", "seq", "obj", " address", "Address", "arm", "name", "dr", "x", "asm", "data", "base", "pointer", "ad", "align", "address", "type", "dd", "port", "id", "alias", "url", "pad", "amp", "arr", "adr", "grad", "rm", "start", "ord", "loc", "offset", "coord", "order", "target", "hop", "ptr", "ar", "off", "arg", "dist", "amd", "rt", "ext", "nr", "rx", "src", "alt", "host", "index", "inter", "r", "pos", "ace", "rr", "attr", "tx", "len"], "rom": ["hom", "ru", "comm", " chrom", "rome", "comb", "cm", "ril", "RM", "m", "arm", "rod", "cry", "rn", "roll", "norm", "om", "cr", "am", "chrome", "ROM", "dom", "prom", "rob", "Rom", "dem", "ram", "cmd", "rc", "rm", "stim", "sym", "ray", "ros", "ctr", "tro", "com", "rock", "irm", "ro", "co", "roc", "roman", "rim", "im", "mod", "rem", "ore", "roy", "aram", "sim", "drm", "cum", "rx", "mm", "coll", "r", "rum", "chrom"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "static inline float64 ucf64_itod(uint64_t i)\n\n{\n\n    union {\n\n        uint64_t i;\n\n        float64 d;\n\n    } v;\n\n\n\n    v.i = i;\n\n    return v.d;\n\n}\n", "idx": 15066, "substitutes": {"i": ["qi", "it", "ui", "m", "I", "d", "t", "ai", "xi", "l", "iu", "gi", "ini", "a", "oi", "val", "ci", "ig", "h", "di", "x", "si", "ie", "ii", "vi", "o", "u", "p", "e", "li", "k", "ix", "b", "j", "phi", "f", "n", "ti", "c", "is", "pi", "ic", "r", "bi", "ri", "ik", "index"], "v": ["m", "d", "t", "vv", "l", "val", "vp", "iv", "g", "x", "vm", "value", "vi", "var", "tv", "o", "av", "w", "u", "p", "e", "ver", "k", "data", "j", "n", "f", "c", "lv", "ov", "sv", "q", "nv", "va", "uv", "V", "ev", "vd", "vt", "vs", "vals"]}}
{"project": "FFmpeg", "commit_id": "d7e9533aa06f4073a27812349b35ba5fede11ca1", "target": 1, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    \n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    skip_bits(&s->gb, 4);\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        s->has_b_frames = 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        mpeg1_init_vlc(s);\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_intra_matrix[i];\n\n            s->intra_matrix[i] = v;\n\n            s->chroma_intra_matrix[i] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->non_intra_matrix[j] = v;\n\n            s->chroma_non_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->non_intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_non_intra_matrix[i];\n\n            s->non_intra_matrix[i] = v;\n\n            s->chroma_non_intra_matrix[i] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    return 0;\n\n}\n", "idx": 3499, "substitutes": {"avctx": ["apconnection", "ajctx", "afsq", "afcontext", "mpctx", "mpcontext", "awcf", "afloc", "avcontext", " avconnection", "aveloc", "afxc", "apcmp", "avconnection", "awtx", "aveconfig", "afcmp", "AVcontext", "avecu", " avconn", "mpconfig", "avectx", "afctx", "aveconn", "aptx", "afconnection", "avcf", "afconn", "airsq", "ajconfig", "mpcu", "avcb", "abcf", "avconfig", "abcontext", "airsys", "awctx", "AVtx", "evctx", "evcontext", "abtx", "avxc", "avtx", "AVcb", "abloc", "aftx", "aircontext", "apcontext", "AVconfig", "abctx", "afcu", "afcf", "afsys", "evconn", "avsq", "ajcontext", "apconn", "afconfig", "AVctx", " avxc", "avconn", "AVconn", " avcontext", "avexc", "aircmp", "ajcb", "evsys", "awcontext", "avsys", "apctx", "avloc", "airconn", "abconn", "avecontext", "apsq", "avcu", "avcmp", "afcb", "airctx"], "buf": ["ff", "fd", "src", "buffer", "ctx", "byte", "queue", "mem", "data", "ab", "bc", "buff", "pb", "num", "batch", "max", "rb", "proc", "fp", "cb", "raw", "c", "block", "cv", "Buffer", "vec", "nb", "wb", "ref", "br", "gb", "cmd", "alloc", "seq", "fb", "b", "conv", "uf", "img", "rc", "port"], "buf_size": ["buf_source", "buflexsize", "cmd_size", "path_chan", "buflexspeed", "cmdlexspeed", "pathamsize", "buf_SIZE", "bufamsize", "bufamsource", "cmd_speed", "buf_chan", "path_size", "pathamchan", "bufamSIZE", "buflexSIZE", "pathamSIZE", "cmdlexsize", "path_source", "cmd_SIZE", "pathamsource", "buf_speed", "path_SIZE", "bufamchan", "cmdlexSIZE"], "s1": ["shareOne", " s_", "s0", " s0", " sOne", "sesOne", "s01", "share01", "share1", "sh1", "Sons", "ps2", "ses1", "ses01", "SOne", "shOne", "args2", "shons", "ses_", "s2", " s2", "ps1", "sOne", "share_", "c001", "c1", "s_", " s001", "sons", "args0", "kons", " s01", "S1", "ss2", "c2", "c0", "s001", "args1", "kOne", "ssOne", "args001", "psOne", "k1", "ss1"], "s": ["sg", "js", "this", "qs", "sa", "n", "sl", "g", "ses", "ls", "args", "x", "vs", "us", "self", "f", "sys", "u", "an", "your", "se", "fs", "parts", "spec", "ts", "sb", "aws", "y", "xs", "request", "sets", "p", "e", "conf", "as", "serv", "su", "S", "t", "ks", "os", "session", "site", "bs", "its", "in", "sym", "plugins", "ssl", "cs", "ctx", "ss", "rs", "a", "new", "r", "is", "ins", "settings", "ds", "ps", "gs", "ns", "h", "c", "words", "es", "south", "sec", "o", "si", "server", "service", "http", "ops", "d", "ms", "params", "sync", "l", "services", "w", "sq", "stats", "b", "full", "states"], "height": ["resolution", "capacity", "dim", "stroke", "ty", "lat", "direction", "images", "quality", "arrow", "hang", "rh", "ows", "Height", "port", "we", "host", "image", "ht", "id", "html", "gap", "y", "max", "dom", "gallery", "work", "layout", "length", "inches", "wa", "huge", "bottom", "gh", "family", "crop", "build", "above", "tight", "data", "fw", "wrap", "slice", "han", "h", "pad", "deep", "rank", "size", "rows", "history", "definition", "img", "volume", "shape", "timeout", "gpu", "def", "high", "window", "d", "distance", "th", "grow", "duration", "iii", "dy", "hung", "style", " heights", "ip", "thin", "w", "density", "range", "padding", "container", "depth"], "i": ["yi", "ami", "li", "gi", "ni", "ii", "zi", "ji", "ui", "pi", "oi", "r", "d", "n", "I", "di", "mi", "uli", "k", "iu", "g", "y", "m", "eni", "ti", "ini", "index", "z", "ani", "multi", "ai", "ie", "x", "h", "l", "p", "c", "phi", "w", "e", "bi", "f", "u", "ip", "ori", "b", "vi", "ix", "qi", "t", "ci", "io", "fi", "si", "in", "xi"], "v": ["q", "volt", "ii", "d", "n", "av", "k", "y", "g", "m", "ve", "sv", "z", "vv", "x", "l", "h", "p", "c", "vs", "w", "e", "f", "u", "uv", "V", "b", "vi", "lv", "tv", "val", "si"], "j": ["js", "li", "q", "ii", "ji", "jit", "r", "d", "n", "jj", "J", "k", "aj", "ij", "uj", "y", "g", "max", "m", "z", "x", "h", "l", "p", "c", "jc", "w", "f", "u", "jp", "dj", "o", "b", "si"]}}
{"project": "FFmpeg", "commit_id": "d82eccea2bf905cd51889954658f4e7f64876df8", "target": 1, "func": "static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,\n\n                                                    int16_t *block, int n)\n\n{\n\n    int level, i, j, run;\n\n    RLTable *rl = &ff_rl_mpeg1;\n\n    uint8_t * const scantable = s->intra_scantable.permutated;\n\n    const int qscale          = s->qscale;\n\n    OPEN_READER(re, &s->gb);\n\n    i = -1;\n\n\n\n    // special case for first coefficient, no need to add second VLC table\n\n    UPDATE_CACHE(re, &s->gb);\n\n    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {\n\n        level = (3 * qscale) >> 1;\n\n        if (GET_CACHE(re, &s->gb) & 0x40000000)\n\n            level = -level;\n\n        block[0] = level;\n\n        i++;\n\n        SKIP_BITS(re, &s->gb, 2);\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            goto end;\n\n    }\n\n\n\n    /* now quantify & encode AC coefficients */\n\n    for (;;) {\n\n        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\n\n\n\n        if (level != 0) {\n\n            i += run;\n\n            j  = scantable[i];\n\n            level = ((level * 2 + 1) * qscale) >> 1;\n\n            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n\n            SKIP_BITS(re, &s->gb, 1);\n\n        } else {\n\n            /* escape */\n\n            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);\n\n            UPDATE_CACHE(re, &s->gb);\n\n            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);\n\n\n\n            i += run;\n\n            j  = scantable[i];\n\n            if (level < 0) {\n\n                level = ((-level * 2 + 1) * qscale) >> 1;\n\n                level = -level;\n\n            } else {\n\n                level = ((level * 2 + 1) * qscale) >> 1;\n\n            }\n\n        }\n\n\n\n        block[j] = level;\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            break;\n\n        UPDATE_CACHE(re, &s->gb);\n\n    }\n\nend:\n\n    LAST_SKIP_BITS(re, &s->gb, 2);\n\n    CLOSE_READER(re, &s->gb);\n\n    s->block_last_index[n] = i;\n\n    return 0;\n\n}\n", "idx": 6972, "substitutes": {"s": ["serv", "sf", "S", "b", "f", "d", "service", "conf", "w", "same", "h", "aws", "sa", "g", "sym", "sets", "is", "services", "its", "states", "server", "sl", "ls", "sie", "ops", "ds", "ts", "settings", "sv", "fs", "sq", "ms", "site", "rs", "sr", "sec", "sg", "sche", "sync", "ses", "cs", "u", "e", "sb", "qs", "t", "p", "re", "ges", "c", "os", "ssl", "sup", "r", "ps", "o", "v", "http", "session", "si", "sys", "m", "side", "ns", "space", "res", "ss", "gs", "su", "sample", "es", "js"], "block": ["Block", "base", "row", "layer", "bin", "box", "channel", "chain", "session", "list", "b", "object", "bit", "record", "unit", "buffer", "clock", "section", "lock", "coll", "array", "blocks", "batch", "frame", "un", "re", "BL", "line", "node", "rule", "range", "type", "bl", "ref", "cache", "group", "r", "rec", "view"], "n": ["nl", "nn", "b", "nc", "l", " N", "num", "N", "ns", "d", "len", "e", "all", "w", "en", "k", "nat", "nb", "p", "ne", "z", "ner", "ln", "c", "g", "r", "rec"], "level": ["layer", "local", "ll", "unit", "letter", "f", "weight", "d", "code", "len", "all", "col", "depth", "file", "pass", "stage", "where", "line", "lc", "index", "mode", "le", "row", "build", "id", "count", "value", "val", "url", "limit", "sol", "loop", "round", "lo", "sc", "path", "str", "scale", "fail", "ld", "rule", "type", "model", "rol", "low", "size", "clean", "vel", "loc", "inc", "key", "cl", "Level", "temp", "global", "ul", "location", "wl", "VEL", "set", "levels", "la", "total", "ell", "l", "child", "call", "length", "roll", "full", "day", "lock", "coll", "lvl", "cost", "step"], "i": ["uni", "gi", "layer", "o", "position", "ti", "v", "id", "I", "is", "di", "ci", "ni", "x", "b", "si", "io", "xi", "slice", "ri", "info", "bi", "in", "qi", "l", "f", "pi", "yi", "phi", "iu", "ii", "it", "ai", "init", "u", "e", "uri", "ori", "k", "mi", "ini", "ie", "p", "z", "start", "hi", "c", "ip", "ind", "y", "li", "index", "r", "ui"], "j": ["jet", "o", "el", "v", "note", "jl", "jump", "ji", "op", "b", "ani", "rel", "m", "kj", "l", "job", "ij", "aj", "q", "J", "jc", "k", "uj", "jp", "err", "str", "jo", "p", "jit", "un", "z", "pos", "jj", "ind", "g", "dj", "ja", "br", "li", "adj", "syn", "r", "js"], "run": ["base", "name", "row", "layer", "clean", "build", "reg", "play", "runs", "nn", "config", "update", "val", "skip", "use", "sync", "vel", "unit", "ran", "inc", "num", "ru", "job", "child", "order", "call", "weight", "limit", "version", "mod", "loop", "round", "len", "con", "Run", "day", "win", "pass", "go", "exec", "running", "output", "runner", "un", "batch", "pos", "step", "fun", "type", "thread", "UN", "index", "set", "r", "min", "max", "end", "add"], "rl": ["nl", "fr", "vr", "lb", "sr", "rt", "el", "rr", "rb", "rc", "rel", "lp", "ll", "l", "repl", "ru", "tl", "fl", "ls", "sl", "sb", "rg", "lr", "ruby", "gb", "mr", "sel", "bf", "ssl", "ro", "lc", "lv", "dl", "il", "fc", "pl", "rs", "rol", "r", "ctrl"], "scantable": ["scandor", "Scandiable", "scentiable", "Scantiable", "Scandor", "scantsiable", "scaptables", "Scaptable", "scactables", "scaptor", "scantible", "Scantables", "scentible", "scentables", "scactable", "scantsable", "scandables", "scaptable", "Scandables", "Scaptables", "scantsables", "scactiable", "scantables", "Scantible", "scantor", "scactible", "scantiable", "scantsible", "Scantable", "scentable", "Scaptible", "Scaptiable", "Scandible", "scandible", "scaptible", "scantsor", "scaptiable", "scandable", "Scandable", "Scantor", "scandiable"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,\n\n                                    uint64_t offset,\n\n                                    int n_start, int n_end,\n\n                                    int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int nb_clusters, i = 0;\n\n    QCowL2Meta *old_alloc;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);\n\n    if (ret == 0)\n\n        return 0;\n\n\n\n    nb_clusters = size_to_clusters(s, n_end << 9);\n\n\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* We keep all QCOW_OFLAG_COPIED clusters */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, 0);\n\n\n\n        cluster_offset &= ~QCOW_OFLAG_COPIED;\n\n        m->nb_clusters = 0;\n\n\n\n        goto out;\n\n    }\n\n\n\n    /* for the moment, multiple compressed clusters are not managed */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COMPRESSED)\n\n        nb_clusters = 1;\n\n\n\n    /* how many available clusters ? */\n\n\n\n    while (i < nb_clusters) {\n\n        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,\n\n                &l2_table[l2_index], i, 0);\n\n\n\n        if(be64_to_cpu(l2_table[l2_index + i]))\n\n            break;\n\n\n\n        i += count_contiguous_free_clusters(nb_clusters - i,\n\n                &l2_table[l2_index + i]);\n\n\n\n        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        if ((cluster_offset & QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /*\n\n     * Check if there already is an AIO write request in flight which allocates\n\n     * the same cluster. In this case we need to wait until the previous\n\n     * request has completed and updated the L2 table accordingly.\n\n     */\n\n    LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t end_offset = offset + nb_clusters * s->cluster_size;\n\n        uint64_t old_offset = old_alloc->offset;\n\n        uint64_t old_end_offset = old_alloc->offset +\n\n            old_alloc->nb_clusters * s->cluster_size;\n\n\n\n        if (end_offset < old_offset || offset > old_end_offset) {\n\n            /* No intersection */\n\n        } else {\n\n            if (offset < old_offset) {\n\n                /* Stop at the start of a running allocation */\n\n                nb_clusters = (old_offset - offset) >> s->cluster_bits;\n\n            } else {\n\n                nb_clusters = 0;\n\n            }\n\n\n\n            if (nb_clusters == 0) {\n\n                /* Set dependency and wait for a callback */\n\n                m->depends_on = old_alloc;\n\n                m->nb_clusters = 0;\n\n                *num = 0;\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* save info needed for meta data update */\n\n    m->offset = offset;\n\n    m->n_start = n_start;\n\n    m->nb_clusters = nb_clusters;\n\n\n\nout:\n\n    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);\n\n\n\n    *num = m->nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 9548, "substitutes": {"bs": ["vs", "base", "bb", "ks", "ds", "bas", "bm", "b", "iss", "sa", "ls", "pb", "cb", "gb", "bits", "us", "rs", "BS", "os", "bc", "js", "obs", "cs", "bl", "bps", "es", "bh", "lb", "bi", "ns", "sb", "ms", "fs", "ses", "ps", "ob", "css", "ss", "bos"], "offset": ["count", "location", "seq", "timeout", "base", "initial", "start", "nb", "len", "prefix", "conn", "id", "shift", "slot", "ron", "config", "ref", "addr", "meta", "fp", "set", "off", "loc", "o", "index", "alloc", "size", "slice", "end", "address", "acl", "part", "position", "error", "type", "pos", "url", "fee", "Offset", "reset"], "n_start": [" n_base", "nunlast", "n_last", "nFlast", " n_last", "nFbase", "nFend", "nFstart", "n_base", "nunbase", "nunend", "nunstart"], "n_end": ["n_info", "n__start", " n2info", "n__all", " n2start", " n_all", " n2all", "nunstop", " n_stop", "nunrange", "n2end", "n2info", " n2end", "n_range", " n_range", "n_all", "n__end", "n__info", "n2all", "n_stop", "n2start", "nunend", "nunstart", " n_info"], "num": ["count", "seq", "dim", "len", "alt", "id", "mult", "mem", "con", "batch", "max", "split", "number", "off", "f", "mid", "multi", "index", "ctr", "Num", "node", "orig", "init", "uni", "fn", "um", "NUM"], "m": ["man", "n", "g", "mr", "bm", "b", "t", "mm", "gm", "mem", "d", "i", "metadata", "c", "p", "meta", "e", "machine", "pm", "f", "manager", "fm", "o", "mp", "v", "mi", "r", "md", "sm", "ms", "tm", "dm", "h", "cm", "mt", "M", "mc", "rm"], "s": ["vs", "sg", "ts", "ks", "sv", "ds", "is", "si", "g", "its", "sites", "stats", "b", "t", "stat", "ops", "gs", "sa", "c", "p", "ls", "se", "e", "ins", "qs", "xs", "rs", "sq", "js", "os", "f", "cs", "sym", "sets", "S", "v", "sync", "states", "sl", "state", "services", "sn", "ns", "storage", "sb", "spec", "ms", "sys", "sim", "ses", "fs", "su", "ps", "y", "ss", "settings"], "l2_index": ["l2acindex", "l96_lock", "l2_region", "l2_dimension", "l2Mdimension", "lao_index", "l2hthread", "l2_slice", "l52Jthread", "l96Jdimension", "l2_length", "lappingJlength", "l2dslice", "l2xinfo", "l4_info", "l2Cposition", "l2Hindex", "l96Jwidth", "l96_width", "laoamcount", "l2_header", "l2kindex", "l2_ini", "l2_module", "l52_module", "l2vkey", "l2vregion", "l2Jlock", "l2amcount", "l2dini", "laoammodule", "l96_dimension", "lapping_index", "l1_length", "l2_shape", "l2_key", "l2_value", "l2dindex", "l4_region", "l2kheader", "l2hmodule", "l2klabel", "l2Mindex", "l96_index", "l2Jlabel", "l2Jthread", "l1_index", "lapping_length", "l2xslice", "l2Mwidth", "l52_thread", "l2vindex", "lappingJindex", "l22dslice", "l2amindex", "l2ammodule", "l22dindex", "l2Celement", "l22dini", "l4_slice", "l4_size", "l52Jindex", "l22_ini", "l22_slice", "l22_element", "l2_Index", "l1_slice", "l2amshape", "ltwo_value", "l2Hwidth", "l2acelement", "l2Jdimension", "l4_Index", "l2_label", "ltwo_index", "l52Jmodule", "l2fheader", "l2hindex", "l2Hdimension", "l2xindex", "l2klength", "l52_index", "lao_count", "l2Jheader", "l4_key", "lappingJlabel", "ltwo_element", "laoamshape", "l2Hlock", "l96Jlock", "lapping_header", "l2Jmodule", "l2acvalue", "l4_index", "lao_module", "l22delement", "lapping_label", "lao_shape", "l2_lock", "l1_size", "ltwo_position", "l52Jpath", "lappingJheader", "l2Mlock", "l2_width", "l2Cvalue", "laoamindex", "l2_thread", "l22_index", "l2acposition", "l2delement", "l2hpath", "l2_path", "l52_path", "l2_count", "l2Jindex", "l2xlength", "l2Cindex", "l2Jlength", "l2findex", "l2_info", "l2flabel", "l2_position", "l2_size", "l2Jwidth", "l96Jindex", "l2_element", "l2xsize", "l2vIndex", "l2Jpath", "l2flength"], "ret": ["count", "arr", "rem", "ext", "len", "val", "alt", "g", "info", "nt", "Ret", "conn", "b", "i", "ref", "obj", "status", "reg", "iter", "rets", "f", "j", "rt", "res", "bf", "det", "al", "opt", "mi", "r", "att", "fun", "en", "hash", "ur", "re", "RET", "back", "result", "rev", "match", "ber", "fi", "success"], "l2_offset": ["l2_type", "l4_offset", "l2xstart", "l4_type", "l2xoffset", "l2xOffset", "l1_Offset", "l1_offset", "l1_start", "l2_size", "l2_Offset", "l4_index", "l2_start", "l4_size", "l2xsize", "l1_size"], "l2_table": ["l2xstable", "l2Ptable", "l02scontainer", "l2jblock", "l2Ptab", "l2Pconfig", "l2stype", "l2scontainer", "l2dtree", "l02_stable", "ltwosfeature", "l2ttable", "l2_page", "l6_module", "lserverstable", "l2Jfeature", "l2_module", "l2_cache", "l2_tab", "l2soffset", "ltwo_view", "lserverscache", "l2_package", "l2_body", "l6_stable", "ltwo_table", "l2_container", "l2Jtable", "l2jmodule", "l2tstable", "l6_body", "l2thestable", "ltwo_body", "lserversoffset", "l2jpackage", "l2_file", "l2Jview", "l2tbody", "l02_table", "l3_size", "l02_page", "l2Jbody", "l6_table", "l2xpackage", "l02sstable", "l3_tree", "l6_tree", "l2xblock", "l2_type", "lserver_table", "l6_time", "lserver_offset", "lserver_type", "ltwo_feature", "l02spage", "l2sfeature", "l6_block", "l2xmodule", "l2thecontainer", "l2sstable", "l3_cache", "l6_file", "l2dtime", "l2tcache", "l2sview", "l2_block", "l2spage", "l2thetable", "ltwosbody", "l6_tab", "l02_container", "l2xtable", "l2jtable", "l2xcontainer", "l2scache", "l6_cache", "l6_index", "l2thepage", "l2Pindex", "ltwostable", "l2_config", "l2_tree", "l6_config", "lserver_cache", "l2_feature", "l6_package", "l02stable", "l2sbody", "l2xpage", "l2_stable", "l2_view", "ltwosview", "l2_size", "l2_time", "l2stable", "l2dfile", "lserverstype", "l2dtable", "l3_table"], "cluster_offset": ["cluster67offset", "clusteracoffset", "clusterLend", "cluster_attribute", "clusterPend", "cluster_entry", "cluster_off", "clusterLoffset", "clusterPpadding", "clinical_Offset", "clard_entry", "cluster67format", "clusterFattribute", "clancPleft", "clrome_url", "clrome67offset", "clusterLpadding", "clusterFpadding", "clrome67shift", "clusterPOffset", "clider_ref", "clrome_position", "clause_off", "clution_padding", "clution_attribute", "cluster_position", "clause_offset", "cluster_ref", "clutionFpadding", "clanc_format", "cluster_option", "cluster67left", "cluster_format", "clutionFattribute", "cluster_count", "clard_start", "cluster_addr", "clinical_limit", "clusterPentry", "clutionFend", "cluster_Offset", "cluster_padding", "clause_addr", "clusterPleft", "clanc_Offset", "clutionFoffset", "clause_Offset", "clancPformat", "cluster_start", "cluster_left", "cluster_size", "clider_offset", "cluster_shift", "clusterFend", "clause_set", "cluster67url", "clusterPstart", "cluster67Offset", "cluster67position", "cluster_area", "clution_end", "clusteracOffset", "clrome67position", "cluster_end", "clanc_offset", "clanc_left", "cluster_set", "clution_offset", "clusterLattribute", "clusteraclimit", "clusterPoffset", "cluster67shift", "clrome67url", "clrome_offset", "cluster_url", "clancPOffset", "clinical_offset", "clause_area", "cluster_limit", "clard_offset", "clider_count", "clinical_option", "clusterFoffset", "clusterPattribute", "clancPoffset", "clusteracoption", "clause_end", "clusterPformat", "clider_size", "clrome_shift"], "nb_clusters": ["nb_declunks", "nb_contusters", "nb00flappers", "nb_pluster", "nb_sclocations", "nb_custers", "nb00sclocations", "nb67decunks", "nb_blancers", "nb_licusters", "nb_combicas", "nb_blroups", "nb_clonents", "nb_chuster", "nb67clayers", "nb00clappers", "nb_slorders", "nb_sclashes", "nb00flroups", "nb_compashes", "nb_combonents", "nb_sclusters", "nb_clients", "nb_zusters", "nb00sclusters", "nb_slusters", "nb_combroups", "nb_lconents", "nb67clorders", "nb_decients", "nb_ciders", "nb_clists", "nb00explists", "nb_declappers", "nb_compusters", "nb_decunks", "nb_flroups", "nb_blitors", "nb_chitors", "nb_bluster", "nb00flusters", "nb__clords", "nb_collodes", "nb_collicas", "nb00sclorders", "nb2chitors", "nb_filunks", "nb_decayers", "nb_plashes", "nb_clurations", "nb00clists", "nb_explusters", "nb00explusters", "nb_plonents", "nb_llorders", "nb2chores", "nb_clorders", "nb_clocations", "nb2chusters", "nb67decorders", "nb_sclores", "nb00clubes", "nb_plores", "nb_clores", "nb_plicas", "nb_chusters", "nb00clroups", "nb_conticas", "nb_clust", "nb_clayers", "nb_condusters", "nb_decusters", "nb_cancers", "nb_clitors", "nb_explubes", "nb_splust", "nb_deciders", "nb_lcust", "nb_condores", "nb_chicas", "nb_clancers", "nb_glorders", "nb_decancers", "nb_chances", "nb_tust", "nb2clusters", "nb67clunks", "nb_turations", "nb_lcroups", "nb_clodes", "nb_explunks", "nb_clords", "nb_chients", "nb__clicas", "nb_blients", "nb_lcappers", "nb_filubes", "nb00clust", "nb_zappers", "nb2clores", "nb_condients", "nb_zust", "nb_glusters", "nb_llusters", "nb_declorders", "nb_clances", "nb_plusters", "nb_bliders", "nb_clunks", "nb_clashes", "nb__clodes", "nb67clusters", "nb_slunks", "nb_licances", "nb_contodes", "nb00clodes", "nb_flusters", "nb67decayers", "nb_plroups", "nb2clients", "nb_explists", "nb2chients", "nb_filusters", "nb_filists", "nb2clitors", "nb_collords", "nb_declroups", "nb_combusters", "nb__chodes", "nb_flust", "nb_cliders", "nb_splusters", "nb_clubes", "nb00explunks", "nb_blances", "nb_scluster", "nb_conditors", "nb_chroups", "nb__chords", "nb_slayers", "nb_llocations", "nb_blores", "nb_tappers", "nb__clusters", "nb_splurations", "nb_lcusters", "nb_lcicas", "nb_sclorders", "nb_declusters", "nb_declayers", "nb_zurations", "nb_glodes", "nb_clicas", "nb_declust", "nb_sclodes", "nb00explubes", "nb_chodes", "nb_tusters", "nb_chords", "nb_clroups", "nb_licuster", "nb_compores", "nb_glocations", "nb00clorders", "nb_licroups", "nb_cluster", "nb__chicas", "nb_splists", "nb_cients", "nb_chores", "nb_compuster", "nb00sclodes", "nb_splubes", "nb_clappers", "nb__chusters", "nb_llodes", "nb_splunks", "nb00clusters", "nb_blusters", "nb00clunks", "nb_decorders", "nb67decusters", "nb_splappers", "nb_contords", "nb00clocations", "nb_flappers", "nb00flust", "nb_collusters"], "old_alloc": ["old__stat", " old_meta", " old_stat", "old_meta", "old2aux", "old2stat", "old__meta", "old2meta", "old2alloc", "old__alloc", "old_aux", "old_stat", " old_aux", "old__aux"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)\n\n{\n\n    return timer_list->clock->type;\n\n}\n", "idx": 21110, "substitutes": {"timer_list": ["timer2base", "timerlisttype", "timer_part", "timer2part", "timerlisttable", "loader_queue", "timerprequeue", "timer_base", "timerpretype", "loader_list", "loader_table", "timer_table", "timerlistlist", "timer2list", "timer_type", "timerlistqueue", "timerprelist", "timer_queue", "loader_type", " timer_part", "timer2type", " timer_type", " timer_base", "timerpretable"]}}
{"project": "FFmpeg", "commit_id": "1bc64c2814d409d3cc129c27c493ee915bebdc4a", "target": 1, "func": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n                                              int *got_picture_ptr,\n                                              AVPacket *avpkt)\n{\n    int ret;\n    *got_picture_ptr = 0;\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n        return -1;\n    avctx->pkt = avpkt;\n    apply_param_change(avctx, avpkt);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n                                         avpkt);\n        else {\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n                                       avpkt);\n            picture->pkt_dts             = avpkt->dts;\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n            picture->width               = avctx->width;\n            picture->height              = avctx->height;\n            picture->format              = avctx->pix_fmt;\n        }\n        emms_c(); //needed to avoid an emms_c() call before every return;\n        if (*got_picture_ptr)\n            avctx->frame_number++;\n    } else\n        ret = 0;\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n     * make sure it's set correctly */\n    picture->extended_data = picture->data;\n    return ret;\n}", "idx": 372, "substitutes": {"avctx": ["ajctx", "amctx", "alconn", "afcontext", "afsync", "alcontext", "avsync", "ajsync", "avcus", "afctl", "akcmp", "avelc", "akconn", "avecca", "avcontext", "afwcs", "avca", "avalcb", "afxc", "navconn", "akctx", "afcca", "AVcca", "afcmp", "AVcontext", "avecu", "akcu", "avalcca", "ajcf", "afcv", "avectx", "amcu", "avecf", "afctx", "navctx", "aveconn", "navcf", "akcontext", "avcf", "evcas", "afconn", "ajctrl", "avcb", "abcf", "avercus", "avalcontext", "aucontext", "abcontext", "umcontext", "verctx", "ajca", "avcv", "AVcmp", "avalctrl", "avecmp", "avcas", "avalctx", "evctx", "evcu", "evcontext", "evcmp", "avewcs", "ajchan", "avxc", "afcas", "vercas", "alctx", "ajconn", "abcmp", "avecb", "umconn", "vercu", "auctx", "avalwcs", "abctx", "avctrl", "afchan", "afcu", "afctrl", "avcca", "avectl", "aflc", "afcf", "afsys", "avctl", "verlc", "aucu", "avecv", "aucf", "avwcs", "umctx", "ajctl", "ajcontext", "vercontext", "ajcus", "AVctx", "avalcv", "avconn", "avchan", "avercontext", "aveca", "vercf", "avesys", "ajcv", "avalsys", "avsys", "afcus", "avalcu", "amcmp", "alcf", "navcontext", "averchan", "evxc", "akcf", "avesync", "avecontext", "afca", "amcontext", "averctx", "akxc", "avcu", "avlc", "avcmp", "afcb", "umcf"], "picture": ["media", "base", "winner", "guide", "piece", "cam", "movie", "ctx", "ami", "service", "large", "bank", "figure", "ji", "data", "audio", "image", "share", "video", "profile", "query", "study", "frame", "camera", "package", "photo", "anti", "file", "info", "entry", "attribute", "style", "license", "storage", "parse", "feat", "config", "home", "pict", "feature", "sea", "game", "library", "ana", "summary", "definition", "comment", "shadow", "pie", "plugin", "pic", "module", "manager", "error", "statement", "family", "img", "cover", "player", "view", "import", "quote", "pause", "gif", "Picture"], "got_picture_ptr": ["got_image_struct", "got_image_address", "got_picture__addr", "got_image_ptr", "got_image_addr", "got_picture__address", "got_picture__ptr", "got_picture_reference", "got_picture_pointer", "got_picturenaddr", "got_profile_addr", "got_image_pos", "got_picturenreference", "got_image_pointer", "got_picture__offset", "got_picture_addr", "got_picturenptr", "got_image_offset", "got_picture_address", "got_picture_struct", "got_picturenpointer", "got_picture_offset", "got_profile_reference", "got_picture__pointer", "got_profile_pointer", "got_picture_pos", "got_profile_ptr"], "avpkt": ["avgpkn", "avcpdt", "avepeth", "avgpdt", "affkt", "avpake", "ajpkt", "avppct", "avspacket", "avpkn", "avlpkt", "affiece", "avpakt", "avecpqt", "avjpkn", "avcpkn", "ajdpkt", "afpct", "avfcht", "avdpkt", "avdpkh", "avepdt", "avcpet", "ajdpsk", "avlpke", "ajpsk", "avpqt", "avpacht", "avpacket", "avemeth", "avemkt", "avdpet", "avpdt", "ajdpetsk", "avpaacket", "akpaacket", "avmiece", "avepkh", "avcpnt", "avcpsk", "avfpacket", "avcpqt", "avpki", "avcpkt", "avppacket", "avemiece", "avfki", "avepki", "affacket", "avppkt", "avwke", "avfct", "avdpetsk", "avlpeth", "avfpki", "avpet", "avfke", "avfiece", "avfkt", "avpetsk", "avmkt", "avepnt", "avepkt", "avlpct", "avwcht", "akpake", "avgpkt", "avlpacket", "avecpkt", "avefpki", "avcpiece", "afpcht", "ajpetsk", "avjpdt", "avpeth", "avspcht", "avlpiece", "avpct", "avspkt", "avlpnt", "avfkh", "avpke", "avecpkn", "avdpsk", "avmnt", "avpnt", "afpkt", "akpke", "avjpqt", "avemnt", "avmeth", "avepkn", "avipetsk", "affcht", "avjpkt", "akpacket", "avipkt", "avipsk", "avfpkt", "avcpeth", "avdpki", "avpcht", "avcpetsk", "avefpacket", "akpkt", "avpkh", "akpakt", "akpacht", "affke", "avepacket", "ajpet", "avppke", "affct", "avpsk", "avefpkh", "avfacket", "avepiece", "akpcht", "avpiece", "afpacket", "avspiece", "afpke", "avfpcht", "avgpqt", "avipet", "avwacket", "avefpkt", "avwkt", "avdpacket", "avfpkh", "avfpiece", "afpiece", "avepqt", "avecpdt", "ajdpet"], "ret": ["ur", "match", "rot", "base", "arg", "fun", "att", "mt", "def", "success", "data", "get", "alt", "job", "ure", "pet", "rets", "num", "rb", "code", "ft", "nt", "rev", "back", "reply", "feat", "Ret", "rc", "bf", "result", "et", "ut", "fin", "len", "f", "ref", "flag", "gt", "art", "value", "RET", "lit", "re", "reg", "val", "rt", "det", "res"], "frame_number": ["video_no", "frameblockversion", "frame_counter", "frame_no", "frameblockno", "frameblocknumber", "video_version", "video_number", "frame_version", "video_counter", "frameblockcounter"]}}
{"project": "FFmpeg", "commit_id": "6fd00e9dd94ac3aecf4fa14ca6fa23c395215ac9", "target": 1, "func": "static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,\n\n                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],\n\n                      GetBitContext *gb)\n\n{\n\n    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;\n\n    int comment_len;\n\n\n\n    skip_bits(gb, 2);  // object_type\n\n\n\n    sampling_index = get_bits(gb, 4);\n\n    if (m4ac->sampling_index != sampling_index)\n\n        av_log(avctx, AV_LOG_WARNING, \"Sample rate index in program config element does not match the sample rate index configured by the container.\\n\");\n\n\n\n    num_front       = get_bits(gb, 4);\n\n    num_side        = get_bits(gb, 4);\n\n    num_back        = get_bits(gb, 4);\n\n    num_lfe         = get_bits(gb, 2);\n\n    num_assoc_data  = get_bits(gb, 3);\n\n    num_cc          = get_bits(gb, 4);\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // mono_mixdown_tag\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 4); // stereo_mixdown_tag\n\n\n\n    if (get_bits1(gb))\n\n        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround\n\n\n\n\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );\n\n    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );\n\n    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );\n\n\n\n    skip_bits_long(gb, 4 * num_assoc_data);\n\n\n\n    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );\n\n\n\n    align_get_bits(gb);\n\n\n\n    /* comment field, first byte is length */\n\n    comment_len = get_bits(gb, 8) * 8;\n\n    if (get_bits_left(gb) < comment_len) {\n\n\n\n\n    skip_bits_long(gb, comment_len);\n\n    return 0;\n", "idx": 20600, "substitutes": {"avctx": ["avcot", "Avconnection", "avcv", "groundcontext", "groundcv", "avercv", "afctx", "avercontext", "groundctrl", "averctx", "navctx", "Avcontext", "navconnection", "averctrl", "Avcot", "avcontext", "groundctx", "afcot", "avconnection", "Avctx", "afcontext", "avctrl", "afcv", "afctrl", "navcot", "navcontext", "afconnection"], "m4ac": ["m4jac", "m8mac", "cmfourmac", "m04acc", "m4acc", "mfourmac", "mfourac", "mfourAC", "m8ac", "cmfouracc", "m104fac", "m4fac", "cm4acs", " m04ac", " m04jac", "m4mac", "m04ac", " m4jac", "mfourfac", "m104ac", "m8acs", "cm4acc", "cm4mac", "m04jac", "mfouracs", "m8acc", "m4AC", "m4acs", "cm4ac", "cmfourac", "m04AC", " m4AC", "m104jac", "m04acs", "m04fac", "m104AC", "m04mac", " m04AC", " m4fac", "mfouracc", "mfourjac", " m04fac", "cmfouracs"], "new_che_pos": ["new_pe_pos", "new_sche_pos", "new_che_cos", "new_cheadpos", "new_che___neg", "new_che_os", "new_ch_val", "new_che_val", "new_ch_pose", "new_ch_trans", "new_che___pos", "new_che___vis", "new_onge_pose", "new_che_neg", "new_chy_loc", "new_chy_pos", "new_onge_neg", "new_ch_cos", "new_sche_po", "new_che_tag", "new_ch_position", "new_cheadtag", "new_che_vis", "new_chy_po", "new_che_po", "new_pe_pose", "new_che_pose", "new_che__pos", "new_pe_pid", "old_\n", "new_che__neg", "new_che__pose", "new_ch_pos", "new_chy_tag", "new_ch_ass", "new_onge_pos", "new_cheadloc", "new_che_pid", "new_sche_set", "new_che_ass", "new_che_trans", "new_cheadpo", "new_onge_vis", "new_ch_loc", "new_pe_os", "new_che_loc", "new_che__vis", "new_che___pose", "new_sche_pose", "new_\n", "new_che_set", "new_che_position", "new_ch_neg"], "gb": ["gio", "bc", "sb", "binary", "lb", "gpu", "gt", "usb", "gram", "gal", "g", "gu", "ui", "db", "mb", "gnu", "gl", "gi", "bb", "og", "gin", "ged", "yg", "pc", "bridge", "gd", "pg", "Gb", "eb", "ga", "gow", "phy", "bg", "gru", "storage", "hd", "agg", "tg", "bn", "gy", "kb", "gg", "wb", "gz", "gae", "sg", "cfg", "gp", "b", "go", "bo", "hub", "gc", "bm", "ogg", "gh", "nb", "gs", "boot", "lib", "bf", "gam", "ko", "GB", "rb", "gm", "cgi", "ge", "abb", "rg"], "num_front": ["num_behind", "num_board", "num64fore", "sum_back", "dim_behind", "dim_fore", "num64front", "num_forward", "dim_back", "num__fore", "num__behind", "sum_front", " num_forward", "sum_fore", " num_board", "num__front", "num__back", "num64behind", "num64back", "num_fore", "sum_behind", "dim_front"], "num_side": ["num_sided", " num_server", "num\u00b7server", " num__front", "num_board", "sum_back", " num__back", "num__side", " num__server", "num2center", "num_center", "sum_center", "num__server", "num2side", "sum_sided", "sum_front", "sum_side", "num\u00b7side", "num\u00b7back", "num\u00b7front", "num__front", "num__back", "sum_board", "num2back", "num2sided", "num_server", " num__side"], "num_back": ["num68before", "num68bridge", "sum_back", "n67front", "n67side", "num_bottom", "n_back", "n_before", "num67before", "numjcross", "numedfront", "numedbridge", "n67before", "num68front", "num_cross", "num68bottom", "n_front", "sum_bridge", "numjback", "sum_front", "num68back", "num67back", "sum_side", "num67side", "numjside", "numedback", "sum_cross", "n_side", "sum_bottom", "num_before", "n67back", "numedbottom", "num67front", "num68side", "numjfront", "num_bridge"], "num_lfe": ["num_afe", "num_lafe", "num_alffe", "num_lale", "num_affleoe", "num_lae", "num_lfde", "num_lfc", "num_afea", "num_affe", "num_seqoe", "num_efde", "num_efea", "num_ffieldde", "num_ffielde", "num_lfle", "num_efe", "num_alfe", "num_seqee", "num_efc", "num_afc", "num_afee", "num_alfle", "num_seqe", "num_alfoe", "num_affleee", "num_affleeb", "num_afde", "num_lffe", "num_afflee", "num_laee", "num_afle", "num_alfee", "num_lfoe", "num_ffieldea", "num_lfeb", "num_lfee", "num_ffieldc", "num_alfeb", "num_lfea", "num_seqeb"], "num_assoc_data": ["num_assoc_only", "num_assocwdata", "num_assoc2only", "num_assoc2len", "num_association_data", "num_associ_data", "num_assocaldat", "num_assoc_dat", "num_assvoc2len", "num_associ_cache", "num_assoc2dat", "num_assocaldevices", "num_assvoc2only", "num_associ2cache", "num_assocaldata", "num_assoc_Data", "num_assvoc_only", "num_assoc2data", "num_assoc_len", "num_assoc2devices", "num_association_len", "num_assvoc2data", "num_associ_devices", "num_assvoc_len", "num_assoc_cache", "num_assocalcache", "num_associ2dat", "num_associ2devices", "num_associ_dat", "num_association_Data", "num_associ2data", "num_assocwonly", "num_assoc_devices", "num_assocwlen", "num_assvoc_data", "num_assoc2cache"], "num_cc": ["num_cs", "num_ff", "num_ce", "num67rc", "num_cca", "num_rc", "num67ff", "num54rc", " num67cc", " num67ff", "num67cc", " num67rc", "num67ce", " num_rc", " num67ce", " num_cca", " num_ck", "num54cc", "num_ck", " num_ce", " num_ff", " num_cs", "num54ce", "num54ff"], "sampling_index": ["sampling_id", "sampler_index", "sampping_ind", "sampling_list", "sampling67index", "sampler_field", "sampling_Index", "sampling67token", "sampled_ind", "sampling67size", "sampled_list", "sampling67ind", "sampling67base", "sampping_id", "sampled_index", "sampling_field", "sampler_size", "sampling_token", "sampling67field", "sampling_ind", "sampled_Index", "sampling67Index", "sampling_base", "sampling_size", "sampler_Index", "sampping_index"], "comment_len": [" byteaclen", " byte_long", " byteacval", " record_length", " byteaclength", " record_val", " byteaclong", " byte_length", " recordaclong", " record_len", " recordacval", " recordaclength", " byte_len", " record_long", " byte_val", " recordaclen"]}}
{"project": "qemu", "commit_id": "bb3cb951ef530da7d248051347c974e4d20e6ea0", "target": 0, "func": "static void dec_bit(DisasContext *dc)\n\n{\n\n    TCGv t0, t1;\n\n    unsigned int op;\n\n    int mem_index = cpu_mmu_index(dc->env);\n\n\n\n    op = dc->ir & ((1 << 9) - 1);\n\n    switch (op) {\n\n        case 0x21:\n\n            /* src.  */\n\n            t0 = tcg_temp_new();\n\n\n\n            LOG_DIS(\"src r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            if (dc->rd) {\n\n                t1 = tcg_temp_new();\n\n                read_carry(dc, t1);\n\n                tcg_gen_shli_tl(t1, t1, 31);\n\n\n\n                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1);\n\n                tcg_temp_free(t1);\n\n            }\n\n\n\n            /* Update carry.  */\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            break;\n\n\n\n        case 0x1:\n\n        case 0x41:\n\n            /* srl.  */\n\n            t0 = tcg_temp_new();\n\n            LOG_DIS(\"srl r%d r%d\\n\", dc->rd, dc->ra);\n\n\n\n            /* Update carry.  */\n\n            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);\n\n            write_carry(dc, t0);\n\n            tcg_temp_free(t0);\n\n            if (dc->rd) {\n\n                if (op == 0x41)\n\n                    tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n                else\n\n                    tcg_gen_sari_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);\n\n            }\n\n            break;\n\n        case 0x60:\n\n            LOG_DIS(\"ext8s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext8s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x61:\n\n            LOG_DIS(\"ext16s r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_ext16s_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x64:\n\n        case 0x66:\n\n        case 0x74:\n\n        case 0x76:\n\n            /* wdc.  */\n\n            LOG_DIS(\"wdc r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0x68:\n\n            /* wic.  */\n\n            LOG_DIS(\"wic r%d\\n\", dc->ra);\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                 && mem_index == MMU_USER_IDX) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_PRIVINSN);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n                return;\n\n            }\n\n            break;\n\n        case 0xe0:\n\n            if ((dc->tb_flags & MSR_EE_FLAG)\n\n                && (dc->env->pvr.regs[2] & PVR2_ILL_OPCODE_EXC_MASK)\n\n                && !((dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR))) {\n\n                tcg_gen_movi_tl(cpu_SR[SR_ESR], ESR_EC_ILLEGAL_OP);\n\n                t_gen_raise_exception(dc, EXCP_HW_EXCP);\n\n            }\n\n            if (dc->env->pvr.regs[2] & PVR2_USE_PCMP_INSTR) {\n\n                gen_helper_clz(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            }\n\n            break;\n\n        case 0x1e0:\n\n            /* swapb */\n\n            LOG_DIS(\"swapb r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_bswap32_i32(cpu_R[dc->rd], cpu_R[dc->ra]);\n\n            break;\n\n        case 0x1e2:\n\n            /*swaph */\n\n            LOG_DIS(\"swaph r%d r%d\\n\", dc->rd, dc->ra);\n\n            tcg_gen_rotri_i32(cpu_R[dc->rd], cpu_R[dc->ra], 16);\n\n            break;\n\n        default:\n\n            cpu_abort(dc->env, \"unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\\n\",\n\n                     dc->pc, op, dc->rd, dc->ra, dc->rb);\n\n            break;\n\n    }\n\n}\n", "idx": 3778, "substitutes": {"dc": ["dr", "roc", "device", "ct", "nc", "director", "rec", "head", "circ", "ec", "cu", "du", "sc", "gui", "vc", "cca", "qa", "wp", "dir", "acc", "da", "spec", "mc", "cloud", "bc", "cci", "ea", "cdn", "dom", "mac", "ac", "lc", "dm", "cit", "td", "input", "fc", "cm", "cc", "mic", "data", "loc", "di", "cat", "cgi", "cr", "ds", "c", "xc", "design", "cache", "ku", "center", "cmd", "disc", "cf", "ic", "enter", "uc", "DC", "ga", "conn", "d", "tc", "dest", "df", "source", "dt", "central", "config", "jc", "doc", "draw", "cd", "exec", "pc", " DC", "dat", "inc", "desc", "db", "rc"], "t0": ["t4", "temp100", "d0", "p1", "t00", "l0", " t000", "l50", "temp0", "t5", "f0", "t000", " t50", " t3", "f000", "ta2", "it192", "p100", "ta50", "t2", "l2", "T100", "temp1", "T3", "it0", "temp00", "T4", " t4", " t2", "l8", "T050", " t6", "temp2", "t100", "t6", "f192", "p5", "f1", " t8", "p00", "ta0", "dt192", "t050", "at050", "t50", "t8", "d1", "tty0", "t3", "it000", "d5", "t192", "T6", "temp5", "T1", "et0", "dt0", "tty1", "dt000", "p4", "at3", "T2", "tty000", "T0", "it1", "dt1", "at0", "p0", "et1", "et6", "d00", "at1", "ta8", "p2", " t050", "T000"], "t1": ["t4", "dt0", " tname", "pone", "tty1", "tty01", "f1", "tone", "ttone", "p8", "pt1", " t8", "it91", "f4", "pt91", "tt1", "ptone", "dt4", "T2", "p1", "t9", "pt0", "f2", "t91", "tt0", "T0", "it1", "tty3", "T5", "itone", "t01", "dt1", " t9", "t2", "p0", "tt3", "t5", "tt5", "it0", "t8", "p9", "f0", " t5", "T4", "t3", "T8", " t01", "T01", "tname", " t4", " t2", "Tname", "p2", "tt01", "ttyone", " t3", " tone", "dtname", "p91", "T9", "T1"], "op": ["orb", "lock", "offset", "ops", "bit", "mod", "expr", "oper", "oop", "opus", "loc", "operation", "type", "prop", "cat", "sp", "operator", "opp", "id", "cop", "it", "open", "oid", "off", "loop", "pos", "ac", "ok", "info", "index", "om", "cod", "post", "opt", "ip", "ind", "top", "p", "pop", "hop", "len", "prev", "app", "oc", "set", "jp", "mp", "o", "cmp", "lit", "Op", "OP", "option"]}}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void compute_frame_duration(int *pnum, int *pden,\n\n                                   AVFormatContext *s, AVStream *st, \n\n                                   AVCodecParserContext *pc, AVPacket *pkt)\n\n{\n\n    int frame_size;\n\n\n\n    *pnum = 0;\n\n    *pden = 0;\n\n    switch(st->codec.codec_type) {\n\n    case CODEC_TYPE_VIDEO:\n\n        *pnum = st->codec.frame_rate_base;\n\n        *pden = st->codec.frame_rate;\n\n        if (pc && pc->repeat_pict) {\n\n            *pden *= 2;\n\n            *pnum = (*pnum) * (2 + pc->repeat_pict);\n\n        }\n\n        break;\n\n    case CODEC_TYPE_AUDIO:\n\n        frame_size = get_audio_frame_size(&st->codec, pkt->size);\n\n        if (frame_size < 0)\n\n            break;\n\n        *pnum = frame_size;\n\n        *pden = st->codec.sample_rate;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 11084, "substitutes": {"pnum": ["ennumb", "rnui", "pronenum", "snumb", "rnuma", "snumer", "pronumb", "pronumber", "hnum", "snam", "PNumer", "atanenum", "rnummer", "gnuma", "ynum", "gnum", "hnuma", "atanum", "pnumb", "ennume", "pnuma", "hnumm", "pnumm", "PNam", "rnumber", "PNuma", "pnumber", "rnumer", "nnumer", "pnummer", "rnenum", "rnum", "nnum", "pnui", "atanuma", "pnenum", "atanummer", "nnumb", "nnenum", "ynumb", "pronum", "ennumber", "hnumb", "PNumm", "pnam", "PNum", "ennum", "nnumm", "rnam", "ynumer", "bnumber", "bnui", "ennui", "ennummer", "PNumb", "nnumber", "bnume", "rnumb", "snum", "pnumer", "rnume", "bnum", "gnumb", "pnume", "ennenum", "ynumm", "snumm", "ennuma", "gnumm"], "pden": ["Ponder", " pne", "pDen", "cdan", "pronder", "czen", "priden", " pDen", "nDen", "spden", "piden", "nden", "nzen", "prdon", "przen", " pzen", "ndan", "ciden", "prden", "Pne", "Pden", "cden", " ponder", " pdon", "pdon", "prlen", "pne", "plen", "Pdan", " piden", "clen", "pzen", "cDen", "splen", "pdan", "spne", "Plen", " plen", "prdan", "spdan", "Pzen", "ponder", "cdon", " pdan"], "s": ["ts", "is", "g", "w", "m", "t", "ops", "c", "p", "qs", "e", "us", "sq", "parser", "cs", "v", "sync", "r", "spec", "ms", "as", "sys", "ps", "ses", "fs", "ss", "ssl"], "st": ["ld", "ts", "std", "str", "start", "est", "ust", "stage", "nt", "fr", "src", "t", "rest", "sa", "c", "ct", "stress", "ost", "pt", "sec", "ut", "inst", "cs", "th", "nd", "sts", "sta", "sl", "r", "cur", "ist", "sth", "sn", "ste", "sb", "sty", "sd", "ast", "St", "ST", "ft", "mt", "ss", "td", "sc"], "pc": ["lp", "arc", "asc", "td", "co", "pg", "cca", "tc", "cz", "pl", "pa", "pp", "pat", "c", "ct", "cp", "con", "p", "pb", "pd", "sc", "pt", "pm", "ec", "bc", "pn", "ac", "cc", "cs", "mp", "amp", "inc", "rc", "pac", "ctx", "pr", "cl", "spec", "enc", "nc", "icc", "px", "ps", "vc", "lc", "anc", "func", "proc", "mc", "uc", "PC", "fc"], "pkt": [" packet", "ppkg", "ppkt", " pkg", "Pkt", " ptk", "Pett", "Ptk", "lpkt", "lpacket", "ppett", "Pkg", " pett", "pett", "packet", "lptk", "lpct", "ppacket", "ptk", "Pct", "Packet", " pct", "pct", "pkg"], "frame_size": ["frame_loc", "file_description", "frame_len", " frame_count", "fram_count", "file_loc", "frame_sized", " frame_sized", "frame_count", "frame___description", " frame_len", "fram_size", "frame_name", "frame_description", "fram_sized", "frame___rate", "frame_rate", " frame_name", "file_rate", "fram_rate", "file_size", "frame___size", "frame___loc"]}}
{"project": "FFmpeg", "commit_id": "18516d3e695980525bd9758dc7b8a8e36cd3f09e", "target": 1, "func": "static int dxva2_map_frame(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame *src,\n\n                           int flags)\n\n{\n\n    IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];\n\n    DXVA2Mapping      *map;\n\n    D3DSURFACE_DESC    surfaceDesc;\n\n    D3DLOCKED_RECT     LockedRect;\n\n    HRESULT            hr;\n\n    int i, err, nb_planes;\n\n    int lock_flags = 0;\n\n\n\n    nb_planes = av_pix_fmt_count_planes(dst->format);\n\n\n\n    hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Error getting a surface description\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (!(flags & AV_HWFRAME_MAP_WRITE))\n\n        lock_flags |= D3DLOCK_READONLY;\n\n    if (flags & AV_HWFRAME_MAP_OVERWRITE)\n\n        lock_flags |= D3DLOCK_DISCARD;\n\n\n\n    hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unable to lock DXVA2 surface\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    map = av_mallocz(sizeof(*map));\n\n    if (!map)\n\n        goto fail;\n\n\n\n    err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,\n\n                                dxva2_unmap_frame, map);\n\n    if (err < 0) {\n\n        av_freep(&map);\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < nb_planes; i++)\n\n        dst->linesize[i] = LockedRect.Pitch;\n\n\n\n    av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,\n\n                           (uint8_t*)LockedRect.pBits, dst->linesize);\n\n\n\n    if (dst->format == AV_PIX_FMT_PAL8)\n\n        dst->data[1] = (uint8_t*)map->palette_dummy;\n\n\n\n    return 0;\n\nfail:\n\n    IDirect3DSurface9_UnlockRect(surface);\n\n    return err;\n\n}\n", "idx": 21037, "substitutes": {"ctx": ["conv", "lc", "bc", "txt", "cam", "wcs", "cc", "support", "conn", "sci", "config", "pkg", "cv", "kt", "cm", "tx", "ca", "anc", "cas", "fp", "cmp", "ci", "nc", "cmd", "cp", "setup", "xc", "cs", "ctrl", "kb", "context", "cf", "cli", "rc", "c", "cb", "client", "cn", "sc", "ann", "qa", "fw", "loc", "cca", "utils", "wx", "cms", "kw", "ck", "sq", "vc"], "dst": ["Dst", "adsc", "sdste", "Dsc", "post", "dist", "idust", "wust", "sdst", "sdsts", "Dsts", "nste", "pdst", "idsts", "Dste", "dnsc", "Dost", "wst", " dost", "idste", "dsc", "fdsp", " dsc", "idst", "nst", "dsost", "adST", "sdsc", "adst", "nist", " dstream", "dste", "Dput", "pST", " dsp", "wput", "dnsts", "DST", " dST", "dsp", "idist", "nsts", "dost", "fdstream", " dstack", "fdsc", "dssc", "Drest", "dust", "dstream", " dste", "pdsts", "wsts", " dsts", "dnost", "fdst", "adost", "dsst", "dsST", "psc", " drest", "dST", "pdstack", "dnrest", "idput", "dstack", "pst", "dsts", "pdsc", "Dust", "drest", "dnsp", "dput", "dnstream", "dnst", "Dstack", "Dist"], "src": ["conv", "bc", "pb", "sb", "sel", "support", "uc", "sl", "scene", "cv", "impl", "func", "rin", "cur", "img", "scl", "sth", "rob", "storage", "ssl", "setup", "sync", "buf", "rc", "reflect", "cb", "source", "roc", "sc", "RC", "sr", "rl", "sub", "ptr", "sur", "inst", "sup", "loc", "req", "st", "proc", "dest", "rb", "stream", "bs", "sn", "sq", "gb"], "flags": ["ips", "types", "ints", "fs", "features", "xs", "lines", "locks", "ops", "properties", "nl", "fps", "planes", "args", "faces", "vals", "ports", "stats", "ants", "settings", "Flags", "lag", "frames", "styles", "bits", "limits", "flag", "FLAG", "fl", "fd", "details", "mask", "ns", "fields", "utils", "options", "alls", "lf", "links", "ats", "files", "atts", "fi", "format"], "surface": ["package", "port", "area", "sym", "sample", "scene", "ser", "metadata", "rect", "pad", "cur", "layer", "dra", "slave", "FACE", "master", "data", "faces", "sheet", "ample", "sa", "filename", "tile", "reflect", "source", "sea", "material", "sc", "sr", "ptr", "face", "sur", "save", "desc", "slice", "sf", " Surface", "skin", "cover", "aster", "sta", "texture"], "map": ["port", "plane", "shape", "ap", "app", "scale", "maps", "apper", "file", "pad", "bridge", "wave", "node", "img", "per", "master", "address", "m", "Map", "data", "cache", "msg", "zip", "lock", "arr", "change", "code", "work", "addr", "mi", "tool", "tile", "move", "module", "pl", "match", "sh", "mp", "create", "replace", "mem", "rule", "save", "mage", "mask", "bm", "test", "co", "mg", "ape", "MAP", "image", "ge", "cover", "pack", "block", "scope", "aster", "cap"], "surfaceDesc": ["surfaceInfo", "faceDescription", " surfaceDescription", "faceInfo", " SurfaceDesc", "sourceDes", " SurfaceStruct", "sourceStruct", " surfaceDes", " surfacedesc", "surfaceDescription", "surfaceDes", " SurfaceInfo", "faceDesc", "surfacedesc", " Surfacedesc", "sourceDesc", "sourceDescription", " surfaceStruct", "sourcedesc", "facedesc", "faceDes", "surfaceStruct", " surfaceInfo", " SurfaceDescription"], "LockedRect": ["LockerRect", "LlockedRect", "IlotedRect", "LockingRECT", "LockRECT", "Liedrect", "LockerRECT", "Blockedrect", " LockingText", " LockingRECT", "LockedBox", "Slockingrect", "LiedRect", "BlockingRect", "IlockedText", "LotedText", "LockingRect", " LockedText", "Lockingrect", "Lockerrect", "IlockedRect", "LippedRECT", "Lockrect", "IlotedBox", "Slockedrect", "LockerText", "LlockedText", " Lockedrect", " Lockingrect", "LockingText", " LockedRECT", "LotedRect", "LotedRECT", "LockRect", "LrictedRect", "Llockedrect", "BlockedRect", "LotedBox", "LrictedRECT", "Lippedrect", "SlockedRECT", " LockingRect", "BlockingRECT", "Blockingrect", "IlotedText", "SlockingRECT", "BlockedRECT", "LlockedRECT", "LockingBox", "IlockedRECT", "Lockedrect", "IlotedRECT", "LockedText", "IlockedBox", "SlockingRect", "LiedRECT", "LippedRect", "SlockedRect", "LrictedBox", "LockedRECT", "LrictedText"], "hr": ["ih", "str", "e", "rd", "ig", "ref", "ride", "sl", "g", "cv", "ctr", "rx", "rin", "rr", "wr", "tr", "rec", "yr", "img", "lr", "f", "hei", "r", "s", "her", "p", "arr", "rh", "code", "dr", "rc", "fe", "resh", "fr", "pr", "roc", "shr", "ar", "RR", "a", "vr", "sr", "pull", "ocr", "hl", "cr", "er", "gr", "br", "mr", "req", "HR", "rs", "hour", "kr", "h", "ir", "ec", "rg"], "i": ["io", "uli", "ix", "start", "ik", "ie", "fi", "qi", "e", "ind", "ri", "ui", "eni", "gi", "d", "uri", "ti", "I", "l", "f", "layer", "ci", "y", "t", "phi", "r", "info", "ini", "it", "j", "oi", "u", "adi", "p", "ip", "id", "code", "ani", "mi", "c", "index", "si", "ii", "b", "line", "n", "iu", "ai", "xi", "di", "multi", "v", "li", "h", "pi", "x", "zi", "k", "ni", "ori"], "err": ["str", "delay", "ind", "ctr", "der", "Er", "rr", "yr", "r", "init", "cache", "bug", "arr", "act", "or", "rh", "code", "inner", "dy", "dr", "cb", "nr", "fr", "ar", "rar", "ver", "sr", "arm", "error", "min", "magic", "er", "gr", "len", "loc", "test", "iter", "req", "mr", "try", "br", "ner", "rage", "ler", "user", "kr", "ir", "fi", "resp", "attr"], "nb_planes": ["nbOfviews", "nbxframes", "nb_rows", "nbxviews", "nb_plates", "np_frames", "nb__frames", "npxframes", "npxplates", "nb_liners", "lnOflevels", "lnOfviews", "npxplanes", "nballrows", "nballplanes", "lnOfplanes", "npxrows", "nbxrows", "nbxlevels", "np_rows", "nbxplates", "nbxplanes", "np_planes", "num_bands", "nb_levels", "nb_views", "nbOfplanes", "lnOfbands", "num_liners", "nb_frames", "nbOflevels", "nballplates", "ln_views", "np_plates", "nballframes", "ln_planes", "nb_bands", "nbxbands", "num_frames", "nb__plates", "nb__rows", "num_planes", "nbOfbands", "nb__planes", "ln_bands", "ln_levels"]}}
{"project": "qemu", "commit_id": "1110bfe6f5600017258fa6578f9c17ec25b32277", "target": 0, "func": "static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,\n\n                                   int error_code, unsigned int next_eip,\n\n                                   int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr, ssp;\n\n    int type, dpl, selector, ss_dpl, cpl;\n\n    int has_error_code, new_stack, shift;\n\n    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;\n\n    uint32_t old_eip, sp_mask;\n\n    int vm86 = env->eflags & VM_MASK;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 8 + 7 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    ptr = dt->base + intno * 8;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 5: /* task gate */\n\n        /* must do that check here to return the correct error code */\n\n        if (!(e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n        }\n\n        switch_tss(env, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);\n\n        if (has_error_code) {\n\n            int type;\n\n            uint32_t mask;\n\n\n\n            /* push the error code */\n\n            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;\n\n            shift = type >> 3;\n\n            if (env->segs[R_SS].flags & DESC_B_MASK) {\n\n                mask = 0xffffffff;\n\n            } else {\n\n                mask = 0xffff;\n\n            }\n\n            esp = (env->regs[R_ESP] - (2 << shift)) & mask;\n\n            ssp = env->segs[R_SS].base + esp;\n\n            if (shift) {\n\n                cpu_stl_kernel(env, ssp, error_code);\n\n            } else {\n\n                cpu_stw_kernel(env, ssp, error_code);\n\n            }\n\n            SET_ESP(esp, mask);\n\n        }\n\n        return;\n\n    case 6: /* 286 interrupt gate */\n\n    case 7: /* 286 trap gate */\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_C_MASK) && dpl < cpl) {\n\n        /* to inner privilege */\n\n        get_ss_esp_from_tss(env, &ss, &esp, dpl, 0);\n\n        if ((ss & 0xfffc) == 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if ((ss & 3) != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (load_segment(env, &ss_e1, &ss_e2, ss) != 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;\n\n        if (ss_dpl != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_S_MASK) ||\n\n            (ss_e2 & DESC_CS_MASK) ||\n\n            !(ss_e2 & DESC_W_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        new_stack = 1;\n\n        sp_mask = get_sp_mask(ss_e2);\n\n        ssp = get_seg_base(ss_e1, ss_e2);\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (vm86) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        sp_mask = get_sp_mask(env->segs[R_SS].flags);\n\n        ssp = env->segs[R_SS].base;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        sp_mask = 0; /* avoid warning */\n\n        ssp = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n\n\n    shift = type >> 3;\n\n\n\n#if 0\n\n    /* XXX: check that enough room is available */\n\n    push_size = 6 + (new_stack << 2) + (has_error_code << 1);\n\n    if (vm86) {\n\n        push_size += 8;\n\n    }\n\n    push_size <<= shift;\n\n#endif\n\n    if (shift == 1) {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHL(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHL(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHL(ssp, esp, sp_mask, error_code);\n\n        }\n\n    } else {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHW(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHW(ssp, esp, sp_mask, error_code);\n\n        }\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        if (vm86) {\n\n            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);\n\n        }\n\n        ss = (ss & ~3) | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss,\n\n                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);\n\n    }\n\n    SET_ESP(esp, sp_mask);\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 26941, "substitutes": {"env": ["exec", "her", "exc", "server", "pg", "shell", "enc", "vs", "chal", "eur", "gear", "export", "inet", "ne", "dev", "uv", "core", "nc", "et", "obj", "engine", "cv", "ec", "qt", "en", "Environment", "jp", "address", "proc", "ception", "password", "dh", "enter", "energy", "eni", "erv", "forge", "dep", "stage", "enh", "que", "args", "np", "console", "context", "inv", "eve", "conf", "global", "loader", "ev", "ea", "profile", "db", "e", "cdn", "output", "exe", "here", "req", "nw", "init", "org", "anne", "cot", "img", "config", "vt", "end", "environment", "site", "esi", "dat", "viron", "ctx", "eu", "vm", "osc", "ext", "conn", "net", "v", "reset", "eng"], "intno": ["indnumber", " intdo", "intNO", "intnum", "pointnum", "initnum", "structnumber", "integernumber", "intnr", "integerno", " inteno", "pointno", "integerdo", "structna", "INTnumber", "indNO", " intnum", "argname", "structno", "idNO", "extno", "argnum", "extdo", "intNo", "uintNO", "Intnos", "pointname", "extnumber", "initno", "intnos", "INTnr", " intna", " intnot", "integernum", "Intno", "indnos", "intnot", "integereno", "INTno", " intnr", "argnot", "idnumber", " intNO", "structNo", "intna", "initNO", " intnos", "indnum", "intdo", "idnos", "extnum", "intname", " intnumber", "idno", "structnos", "IntNo", "intnumber", "argno", "indno", "uinteno", " intNo", "pointNO", "uintno", "pointnot", "INTNo", "inteno", "integerNO", "structnr", " intname", "Intna", "uintnum"], "is_int": ["is_ip", " is_integer", "is_INT", "as_nt", "is6nt", "as_inter", " is_nt", "as_INT", "is6inner", "as_int", "is6ci", "is_ci", "is_inner", "is_integer", " is_ip", "as_ci", "is_nt", "as_inner", "is_inter", "is6int"], "error_code": ["error_size", " error_mode", "errorwavemode", " error_size", "error_codes", " error_codes", "errorwavecode", "error_mode", "errorwavesize", "errorwavecodes"], "next_eip": ["next_peIP", "next_feof", "next_eep", "next_seep", "next_feIP", "next_peof", "next_eeips", "next_peip", "next_seIP", "next_eIP", "next_eeIP", "next_eeep", "next_eips", "next_feep", "next_feip", "next_seip", "next_peep", "next_peips", "next_seof", "next_eof", "next_eeip", "next_seips"], "is_hw": ["isAhw", " is_ht", "isAiw", "isAfw", "is_ht", "is_iw", " is_fw", "is_ether", "isAether", "is_rw", " is_iw", " is_rw", " is_ether", "is_fw"], "dt": ["txt", "tk", "cm", "np", "dc", "ta", "dr", "tm", "qt", "ds", "tz", "jp", "vt", "ct", "tif", "ea", "db", "e", "td", "tu", "adr", "dh", "dat", "tmp", "cmd", "mt", "tick", "tt", "ctx", "target", "elt", "rt", "tn", "uv", "wt", "tc", "tp", "dm", "t", "DT", "fp", "dq", "bt", "utm", "ut", "kt"], "ptr": ["ref", "seq", "code", "slice", "fe", "obj", " pointer", "p", "pt", "dr", "cur", "br", "pointer", "jp", "pointers", "address", "inst", "port", "tr", "proc", "pad", "cmp", "eger", "sp", "td", "str", "start", "loc", "rot", "ctr", "alloc", "req", "Ptr", "cache", "addr", "rc", "length", "rt", "count", "ext", "prot", "index", "reg", "fp", "src", "memory", "attr", "reset", "pos", "len"], "ssp": ["csm", "sslp", "csl", "ssm", "cssm", "cssl", "assm", "cssp", "asslp", "csp", "csslp", "cslp", "ssl", "assp", "assl"], "type": ["ref", "code", "call", "slice", "class", "info", "p", "i", "name", "x", "test", "action", "base", "weight", "style", "var", "label", "py", "pe", "address", "types", "error", "version", "state", "col", "port", "id", "kind", "op", "method", "typ", "key", "unit", "o", "rel", "bit", "loc", "Type", "parent", "like", "size", "sort", "scale", "shape", "ype", "length", "part", "count", "TYPE", "y", "value", "ip", "t", "null", "map", "ty", "block", "pos", "mark", "val", "format", "layer"], "dpl": ["fPL", "dcPL", " dfl", "dcfl", " dPL", "fpl", "dcpl", "ffl", "fsl", "dsl", " dsl", "dPL", "dcsl", "dfl"], "selector": ["constructors", "constructor", "processor", "constructur", "selectory", "processur", "electur", "processory", "selectur", "electors", "constructory", "elector", "processors", "selectors", "electory"], "ss_dpl": ["ss_rdll", "ss_rdpe", "ss_dbl", "ss_rdpl", "ss_dll", "ss_fpe", "ss_rdbl", "ss_ppl", "ss_dpe", "ss_fll", "ss_pll", "ss_fbl", "ss_pbl", "ss_fpl", "ss_ppe"], "cpl": ["ctpl", "cPL", "xcpy", " cps", "ctpy", "xcps", "cpy", " cPL", " cpy", "xcpl", "ctPL", "ctps", "cps", "xcPL"], "has_error_code": ["has_error_call", "has_active_count", "has_err_codes", "has_active_size", "has_error_codes", "has_errorfulcode", "has_ror_done", "has_errorfulsize", "has_active_code", "has_error64call", "has_error_size", "has_errorfulclass", "has_error_done", "has_error64code", "has_errorifcode", "has_error_class", "has_ror_count", "has_activeureclass", "has_ror_codes", "has_errorureclass", "has_error64size", "has_errorifcodes", "has_err_desc", "has_error64codes", "has_error_count", "has_err_error", "has_error_error", "has_errorifdesc", "has_erroruredone", "has_activeuresize", "has_ror_size", "has_errorurecall", "has_errorfulcount", "has_active_class", "has_errorurecode", "has_erroruresize", "has_activeurecount", "has_erroriferror", "has_activeurecode", "has_error_desc", "has_err_code", "has_ror_code", "has_ror_call", "has_errorurecount"], "new_stack": ["new__buffer", "raw__stack", "new_trace", "raw__buffer", "new_buffer", "raw__window", "new__trace", "new_window", "newlwindow", "new__stack", "newvalstack", "newlbuffer", "raw_stack", "newvaltrace", "newvalwindow", "raw_trace", "newlstack", "raw__trace", "raw_window", "newltrace", "new__window", "newvalbuffer", "raw_buffer"], "shift": ["skip", "seq", "slice", "pop", "cost", "sum", "align", "weight", "address", "Shift", "error", "push", "cmp", "seed", "extra", "ff", "small", "hift", "ctr", "scale", "shape", "sup", "dist", "slave", "count", "pull", "ip", "index", "init", "ind", "block", "pos", "sh"], "e1": ["p3", "e9", "eone", "ec2", "E3", "ec1", "ae3", "oe1", "oe32", " e3", "E1", "p1", "E6", "ae1", "Eone", "oe2", "E2", "e3", "ae2", "p2", "econe", "ec9", "oe3", " e32", "e6", " e6", " eone", "ae32", " e9", "E9", "p6", "e32"], "e2": ["ea4", " eTwo", " e4", "ee1", "eeTwo", "ea2", " e8", "ea1", "ee4", "E4", "E3", "ea8", "ee2", "E8", "E1", "E32", "p1", " e3", "E6", "ea6", "e4", "E2", "e3", "p2", "p8", " e32", "ee3", "e6", " e6", "eTwo", "ETwo", "ee32", "ee8", "e8", "e32"], "offset": ["seq", "skip", "slice", "adjust", "position", "align", "address", "error", "op", "alias", "sp", "padding", "loc", "slot", "order", "size", "ip", "index", "pos", "len"], "esp": ["yp", "esc", "temp", "pp", "asp", "sk", "ep", "np", "slice", "ss", "sn", "parser", "sw", "ism", "py", "eff", "sg", "css", "eps", "expr", "rss", "sp", "esi", "ef", "eb", "cp", "sb", "gp", "addr", "sup", "ext", "lv", "xp", "arp", "resp", "ace", "isp"], "old_eip": ["old_eeIP", "old_aeis", "old_edIP", "old_peis", "old_seep", "old_eeep", "old_eeips", "old_eIP", "old_eeid", "old_edis", "old_aeip", "old_seid", "old_peid", "old_edip", "old_seIP", "old_peIP", "old_eis", "old_eid", "old_eips", "old_peip", "old_edid", "old_aeIP", "old_seip", "old_aeid", "old_eep", "old_peep", "old_seips", "old_eeip", "old_peips"], "sp_mask": ["ss_mask", "ss_delay", "ss_map", "ss_ask", "sp_ask", "sp_map", "sp_delay"], "mask": ["args", "class", "info", "flag", "flags", "filter", "dr", "data", "fix", "weight", "sum", "bug", "op", "ask", "alias", "depth", "allow", "key", "patch", "arr", "max", "zero", "bit", "Mask", "group", "sign", "scale", "shape", "field", "scan", "asks", "count", "bits", "pull", "index", "header", "match", "map", "pack", "block", "ace", "mark", "ph", "lock"]}}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "build_dsdt(GArray *table_data, GArray *linker,\n\n           AcpiPmInfo *pm, AcpiMiscInfo *misc,\n\n           PcPciInfo *pci, MachineState *machine)\n\n{\n\n    CrsRangeEntry *entry;\n\n    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;\n\n    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    uint32_t nr_mem = machine->ram_slots;\n\n    int root_bus_limit = 0xFF;\n\n    PCIBus *bus = NULL;\n\n    int i;\n\n\n\n    dsdt = init_aml_allocator();\n\n\n\n    /* Reserve space for header */\n\n    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));\n\n\n\n    build_dbg_aml(dsdt);\n\n    if (misc->is_piix4) {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_piix4_pm(dsdt);\n\n        build_piix4_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_piix4_pci_hotplug(dsdt);\n\n        build_piix4_pci0_int(dsdt);\n\n    } else {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCST\", AML_SYSTEM_IO, aml_int(0xae00), 0x0c));\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCSB\", AML_SYSTEM_IO, aml_int(0xae0c), 0x01));\n\n        field = aml_field(\"PCSB\", AML_ANY_ACC, AML_NOLOCK, AML_WRITE_AS_ZEROS);\n\n        aml_append(field, aml_named_field(\"PCIB\", 8));\n\n        aml_append(sb_scope, field);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A08\")));\n\n        aml_append(dev, aml_name_decl(\"_CID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n        aml_append(dev, build_q35_osc_method());\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_q35_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_q35_pci0_int(dsdt);\n\n    }\n\n\n\n    build_legacy_cpu_hotplug_aml(dsdt, machine, pm->cpu_hp_io_base);\n\n    build_memory_hotplug_aml(dsdt, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n    scope =  aml_scope(\"_GPE\");\n\n    {\n\n        aml_append(scope, aml_name_decl(\"_HID\", aml_string(\"ACPI0006\")));\n\n\n\n        if (misc->is_piix4) {\n\n            method = aml_method(\"_E01\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method,\n\n                aml_acquire(aml_name(\"\\\\_SB.PCI0.BLCK\"), 0xFFFF));\n\n            aml_append(method, aml_call0(\"\\\\_SB.PCI0.PCNT\"));\n\n            aml_append(method, aml_release(aml_name(\"\\\\_SB.PCI0.BLCK\")));\n\n            aml_append(scope, method);\n\n        }\n\n\n\n        method = aml_method(\"_E03\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_call0(MEMORY_HOTPLUG_HANDLER_PATH));\n\n        aml_append(scope, method);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    bus = PC_MACHINE(machine)->bus;\n\n    if (bus) {\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            uint8_t bus_num = pci_bus_num(bus);\n\n            uint8_t numa_node = pci_bus_numa_node(bus);\n\n\n\n            /* look only for expander root buses */\n\n            if (!pci_bus_is_root(bus)) {\n\n                continue;\n\n            }\n\n\n\n            if (bus_num < root_bus_limit) {\n\n                root_bus_limit = bus_num - 1;\n\n            }\n\n\n\n            scope = aml_scope(\"\\\\_SB\");\n\n            dev = aml_device(\"PC%.02X\", bus_num);\n\n            aml_append(dev, aml_name_decl(\"_UID\", aml_int(bus_num)));\n\n            aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n            aml_append(dev, aml_name_decl(\"_BBN\", aml_int(bus_num)));\n\n\n\n            if (numa_node != NUMA_NODE_UNASSIGNED) {\n\n                aml_append(dev, aml_name_decl(\"_PXM\", aml_int(numa_node)));\n\n            }\n\n\n\n            aml_append(dev, build_prt(false));\n\n            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent),\n\n                            io_ranges, mem_ranges);\n\n            aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n            aml_append(scope, dev);\n\n            aml_append(dsdt, scope);\n\n        }\n\n    }\n\n\n\n    scope = aml_scope(\"\\\\_SB.PCI0\");\n\n    /* build PCI0._CRS */\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0, root_bus_limit,\n\n                            0x0000, root_bus_limit + 1));\n\n    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));\n\n\n\n    aml_append(crs,\n\n        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                    AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));\n\n\n\n    crs_replace_with_free_ranges(io_ranges, 0x0D00, 0xFFFF);\n\n    for (i = 0; i < io_ranges->len; i++) {\n\n        entry = g_ptr_array_index(io_ranges, i);\n\n        aml_append(crs,\n\n            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                        AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                        0x0000, entry->base, entry->limit,\n\n                        0x0000, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    aml_append(crs,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_CACHEABLE, AML_READ_WRITE,\n\n                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));\n\n\n\n    crs_replace_with_free_ranges(mem_ranges, pci->w32.begin, pci->w32.end - 1);\n\n    for (i = 0; i < mem_ranges->len; i++) {\n\n        entry = g_ptr_array_index(mem_ranges, i);\n\n        aml_append(crs,\n\n            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE,\n\n                             0, entry->base, entry->limit,\n\n                             0, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    if (pci->w64.begin) {\n\n        aml_append(crs,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_CACHEABLE, AML_READ_WRITE,\n\n                             0, pci->w64.begin, pci->w64.end - 1, 0,\n\n                             pci->w64.end - pci->w64.begin));\n\n    }\n\n\n\n    if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n    }\n\n    aml_append(scope, aml_name_decl(\"_CRS\", crs));\n\n\n\n    /* reserve GPE0 block resources */\n\n    dev = aml_device(\"GPE0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"GPE0 resources\")));\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(scope, dev);\n\n\n\n    g_ptr_array_free(io_ranges, true);\n\n    g_ptr_array_free(mem_ranges, true);\n\n\n\n    /* reserve PCIHP resources */\n\n    if (pm->pcihp_io_len) {\n\n        dev = aml_device(\"PHPR\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n        aml_append(dev,\n\n            aml_name_decl(\"_UID\", aml_string(\"PCI Hotplug resources\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,\n\n                   pm->pcihp_io_len)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n        aml_append(scope, dev);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    /*  create S3_ / S4_ / S5_ packages if necessary */\n\n    scope = aml_scope(\"\\\\\");\n\n    if (!pm->s3_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */\n\n        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S3\", pkg));\n\n    }\n\n\n\n    if (!pm->s4_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */\n\n        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(pm->s4_val));\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S4\", pkg));\n\n    }\n\n\n\n    pkg = aml_package(4);\n\n    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */\n\n    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(scope, aml_name_decl(\"_S5\", pkg));\n\n    aml_append(dsdt, scope);\n\n\n\n    /* create fw_cfg node, unconditionally */\n\n    {\n\n        /* when using port i/o, the 8-bit data register *always* overlaps\n\n         * with half of the 16-bit control register. Hence, the total size\n\n         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the\n\n         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */\n\n        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),\n\n                                                   \"dma_enabled\", NULL) ?\n\n                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :\n\n                          FW_CFG_CTL_SIZE;\n\n\n\n        scope = aml_scope(\"\\\\_SB.PCI0\");\n\n        dev = aml_device(\"FWCF\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0002\")));\n\n\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->applesmc_io_base) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n        dev = aml_device(\"SMC\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"APP0001\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,\n\n                   0x01, APPLESMC_MAX_DATA_LENGTH)\n\n        );\n\n        aml_append(crs, aml_irq_no_flags(6));\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->pvpanic_port) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n\n\n        dev = aml_device(\"PEVT\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0001\")));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(dev, aml_operation_region(\"PEOR\", AML_SYSTEM_IO,\n\n                                              aml_int(misc->pvpanic_port), 1));\n\n        field = aml_field(\"PEOR\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n        aml_append(field, aml_named_field(\"PEPT\", 8));\n\n        aml_append(dev, field);\n\n\n\n        /* device present, functioning, decoding, shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n\n\n        method = aml_method(\"RDPT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_name(\"PEPT\"), aml_local(0)));\n\n        aml_append(method, aml_return(aml_local(0)));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"WRPT\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_arg(0), aml_name(\"PEPT\")));\n\n        aml_append(dev, method);\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    sb_scope = aml_scope(\"\\\\_SB\");\n\n    {\n\n        build_memory_devices(sb_scope, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n        {\n\n            Object *pci_host;\n\n            PCIBus *bus = NULL;\n\n\n\n            pci_host = acpi_get_i386_pci_host();\n\n            if (pci_host) {\n\n                bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n            }\n\n\n\n            if (bus) {\n\n                Aml *scope = aml_scope(\"PCI0\");\n\n                /* Scan all PCI buses. Generate tables to support hotplug. */\n\n                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n\n\n\n                if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n                    dev = aml_device(\"ISA.TPM\");\n\n                    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n\n                    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n                    crs = aml_resource_template();\n\n                    aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                               TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n                    /*\n\n                        FIXME: TPM_TIS_IRQ=5 conflicts with PNP0C0F irqs,\n\n                        Rewrite to take IRQ from TPM device model and\n\n                        fix default IRQ value there to use some unused IRQ\n\n                     */\n\n                    /* aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ)); */\n\n                    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n                    aml_append(scope, dev);\n\n                }\n\n\n\n                aml_append(sb_scope, scope);\n\n            }\n\n        }\n\n        aml_append(dsdt, sb_scope);\n\n    }\n\n\n\n    /* copy AML table into ACPI tables blob and patch header there */\n\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n\n    build_header(linker, table_data,\n\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n\n        \"DSDT\", dsdt->buf->len, 1, NULL, NULL);\n\n    free_aml_allocator();\n\n}\n", "idx": 17682, "substitutes": {"entry": ["plugin", "spec", "session", "data", "mode", "info", "comment", "engine", "debug", "result", "module", "index", "sec", "def", "parser", "parse", "path", "Entry", "config", "line", "cache", "cmp", "cell", "row", "se", "card", "reader"], "dsdt": ["jstd", "jsdt", "vsdt", "desdm", "sdt", "ksdat", "ksdt", "dsds", "nastd", "nsdt", "jskt", "nasdt", "ststd", "desdt", "nscb", "ddds", "DSdat", "dsdat", "osdt", "vsds", "dddm", "stskt", "dddt", "dsdl", "dlecd", "dsqt", "nskt", "psdt", "dtd", "skt", "DSDT", "dsDT", "fsdt", "ddtd", "dltd", "dscb", "fstd", "dlDT", "nasdm", "DSdh", "psdat", "dsecd", "vsDT", "nstd", "kstd", "psDT", "ddm", "dstd", "vskt", "std", "pskt", "dqt", "DSkt", "ysdt", "stsdh", "kskt", "vstd", "ysqt", "stsds", "oskt", "DSecd", "DSdt", "ddt", "sskt", "ksDT", "fsdl", "stsdt", "dkt", "yskt", "ddDT", "destd", "osqt", "ksdm", "desdl", "pscb", "ddecd", "sstd", "naskt", "jsdat", "ystd", "nsdh", "ssdt", "dldm", "pstd", "dldt", "dskt", "fsdm", "ddkt", "ssdl", "dsdh", "ssdm", "dcb", "dlkt", "dsdm", "DStd", "sdat", "ostd"], "sb_scope": ["sb_module", "www67spec", "lb_secret", "www67scope", "www_module", "lb_sc", "www_spec", "sbthescope", "sb_project", "sb_window", "blog_session", "gb_depth", "gb_module", "blog_secret", "bs_project", "gb_region", "sb_scale", "sbthescale", "sb__scope", "sb67scope", "blog_stack", "sb__module", "lb_module", "sb__secret", "gb_scope", "sbthespec", "www_scale", "sb67scale", "www_scope", "sb__region", "sb__sc", "sb_sc", "sb_stack", "sb_region", "sb_context", "sb_session", "sb67spec", "sb_depth", "www67module", "bs_spec", "sb_parent", "sb_secret", "bs_scope", "sbthemodule", "lb_context", "bs_window", "www67scale", "sb_spec", "sb67module", "blog_scope", "lb_parent", "lb_scope", "sb__depth"], "scope": ["spec", "scale", "code", "core", "mode", "engine", "module", "root", "loc", "environment", "index", "model", "tag", "ope", "controller", "range", "context", "path", "style", "prefix", "sc", "device", "depth", "resource", "error", "project", "source"], "dev": ["dc", "Dev", "dd", "data", "mode", "conf", "err", "dep", "comment", "pub", "push", "engine", "gu", "md", "debug", "de", "loader", "block", "devices", "app", "package", "var", "kind", "di", "develop", "def", "der", "development", "prom", "self", "home", "d", "adv", "ev", " device", "v", "private", "device", "cmd", "driver", "test", "pad", "depth", "error", "serial", "priv", "DEV", "dem", "project", "end", "die", "diff", "env", "ve", "ver", "dist", "bug"], "method": ["plugin", "session", "mod", "time", "tr", "user", "mode", "comment", "op", "module", "block", "package", "auth", "app", "raw", "prop", "METHOD", "class", "path", "roll", "prefix", "cmd", "url", "depth", "serial", "port", "school"], "field": ["plugin", "Field", "instance", "time", "f", "fields", "comment", "file", "debug", "loader", "module", "coll", "package", "var", "def", "tag", "path", "style", "rule", "prefix", "mount", "cache", "message", "port", "mm", "input"], "pkg": ["plugin", "packages", "spec", "prov", "mag", "mod", "fp", "pub", "dir", "pool", "install", "pack", "loader", "module", "app", "package", "cp", "utils", "comp", "prefix", "mount", "lib", "cmd", "kg", "cmp", "arch", "proc", "lang"], "crs": ["grs", "Crs", " cris", "gris", "grc", "Crc", "crd", "grd", "crc", " crc", "Crd", "cris", " crd", "Cris"], "mem_ranges": ["mem_brange", "mem_range", "mem_branges", "mem_rebaps", "mem_raps", "mem_rebange", "mem_rebays", "mem_braps", "mem_bange", "mem_banges", "mem_rays", "mem_baps", "mem_bays", "mem_brays", "mem_rebanges"], "io_ranges": ["ioingranges", "ioingralls", "io_banges", "ioingregalls", "io_regounds", "io_brange", "io_rounds", "io_balls", "io_tanges", "io_reganges", "ioingrounds", "io_regrange", "ioingregounds", "ioingreganges", "ioingregrange", "ioingrrange", "io_talls", "io_tounds", "io_regalls", "io_bounds", "io_trange", "io_ralls", "io_rrange"], "pcms": ["mcms", "mcma", "dcps", "mcMS", "dcms", "dcma", "bcms", "mcps", "pcps", "pcma", "dcMS", "bcps", "pcMS", "bcma", "bcMS"], "bus": ["board", "plugin", "bin", "session", "engine", "usb", "service", "bridge", "Bus", "cpu", "block", "machine", "disk", "config", "mount", "device", "unit", "driver", "cache", "BUS", "lock", "boot", "serial", "connection", "port", "bug"], "i": ["m", "bi", "j", "info", "f", "r", "io", "n", "z", "ii", "in", "iu", "I", "is", "ip", "l", "pi", "e", "v", "c", "si", "p", "b", "a", "it", "li", "u"]}}
{"project": "qemu", "commit_id": "9366f4186025e1d8fc3bebd41fb714521c170b6f", "target": 1, "func": "int register_savevm(const char *idstr,\n\n                    int instance_id,\n\n                    int version_id,\n\n                    SaveStateHandler *save_state,\n\n                    LoadStateHandler *load_state,\n\n                    void *opaque)\n\n{\n\n    SaveStateEntry *se, **pse;\n\n\n\n    se = qemu_malloc(sizeof(SaveStateEntry));\n\n    if (!se)\n\n        return -1;\n\n    pstrcpy(se->idstr, sizeof(se->idstr), idstr);\n\n    se->instance_id = (instance_id == -1) ? 0 : instance_id;\n\n    se->version_id = version_id;\n\n    se->save_state = save_state;\n\n    se->load_state = load_state;\n\n    se->opaque = opaque;\n\n    se->next = NULL;\n\n\n\n    /* add at the end of list */\n\n    pse = &first_se;\n\n    while (*pse != NULL) {\n\n        if (instance_id == -1\n\n                && strcmp(se->idstr, (*pse)->idstr) == 0\n\n                && se->instance_id <= (*pse)->instance_id)\n\n            se->instance_id = (*pse)->instance_id + 1;\n\n        pse = &(*pse)->next;\n\n    }\n\n    *pse = se;\n\n    return 0;\n\n}\n", "idx": 23274, "substitutes": {"idstr": ["midstring", "pidStr", "sidstr", "midbytes", "IDbytes", "endstr", "idobj", "sidobj", "pidstr", "aidstr", " idarr", "sidStr", "idStr", "pidcr", "aidbr", "idcode", "IDarr", " idStr", " idbytes", "midstr", "midarr", "aidstring", "idst", "idlist", "IDSTR", "pidcode", "aidst", "idSTR", "IdStr", "pidbr", "IDstring", "keystr", "endSTR", "idcr", "keyStr", "nameStr", "namestring", "IDcr", "midStr", "midbr", "idbytes", "pidlist", "namestr", "pidstring", "endobj", " idcr", "idstring", " idlist", "nameobj", "IDobj", "Idcode", "Idstr", "IDstr", "endStr", " idobj", " idSTR", "keystring", "idbr", "midst", "pidst", "keyobj", "IDStr", "pidSTR", "sidSTR", "idarr", " idcode", "Idlist"], "instance_id": ["ance_ids", "instance64ids", "instance64name", " instance_offset", "instance_version", "instance_offset", "instance64i", "instance_end", "ance_name", "ance_sid", "instance64base", "ance_Id", "instance___version", " instance_base", "instance_Id", "instance___id", "instance_sid", "instance___name", "instance_base", "instance_oid", " instance_type", "ance_version", " instance_oid", " instance_name", "instance_i", "instance_type", "instance64id", "instance_name", " instance_i", "ance_id", "instance_ids", " instance_ids", "instance___ids", "instance_count", "ance_end", " instance_sid", "ance_count"], "version_id": ["instance_ident", "versionalstart", "versionalname", "instance_code", "versionPoolid", "versioneename", "version_start", "versionfulident", " version_ident", "instance_start", "instance_source", "versionPoolsource", "version_ident", " version_index", "versioneeid", "versionfulid", "version_code", "version_name", "versioneesource", " version_ids", "versionalid", "versionPoolname", "instance_name", "versionfulstart", "version_source", "versionfulname", "version_index", "versioneecode", "versionPoolcode", "version_ids", "versionalident"], "save_state": ["saveedpolicy", "load_policy", "savefpolicy", "saveedstatus", "save__resource", "ave_state", "instanceedstate", "saveedstates", "saveedstate", "load_rule", "save_id", "saveingstate", "instanceedstatus", "save_rule", "instanceedstates", "instance_policy", "ave_rule", "save__state", "instance_state", "save_policy", "savefstates", "instance_states", "save_states", "saveingpolicy", "save__id", "save_config", "save_status", "instanceedpolicy", "ave_id", "savefstate", "saveingrule", "savefstatus", "save__rule", "instance_status", "load_config", "ave_resource", "save_resource", "saveingconfig"], "load_state": ["loadingingstate", "loadingingstring", "load_session", "loadalsession", "loaderjob", "load_states", "load_rule", "load_string", "load_type", "loadamstates", "loaderrule", "save_session", "loadingstates", " load_rule", "loadingstring", "loadamjob", "loadingingstates", "loading_rule", "loadingtype", " load_states", "loadamrule", "loadalstate", "load_job", "loadingrule", "loadaltype", " load_job", "save_type", "loadingingrule", "loaderstate", "loadingstate", "loading_state", "loading_string", "loaderstates", "loading_states", "loadingsession", "loadamstate"], "opaque": ["operacity", "opaques", "operaque", "opsicit", "copicit", "uppicate", "copaques", " opicate", "opsacity", "obasso", "opsaques", "uppacity", "copaque", "oppaque", "opicit", "oppacity", "oppity", "opicate", "Opicit", "operacement", "Opacity", "operity", "obaque", "uppaque", "opacity", "oppasso", " opacity", " opacement", "obity", "Opaque", "opericate", "obacity", "Opaques", "copacity", "operasso", "opity", "opasso", "opacement", "opsaque", "uppacement"], "se": ["ede", "ite", "asse", "e", "sel", "sed", "es", "ie", "serv", "send", "sk", "sl", "ph", "ser", "ses", "ade", "pe", "lex", "be", "isse", "de", "parse", "site", "so", "ine", "ide", "ue", "s", "Se", "seed", "esse", "del", "cle", "ace", "SE", "sync", "le", "sa", "ese", "sd", "ste", "sea", "sh", "sc", "ch", "si", "sing", "te", "ve", "spe", "see", "sem", "ae", "ce", "ne", "sp", "sec", "ke", "ge", "su", "ase", "ze", "sle"], "pse": ["ple", "pas", "ede", "je", "syn", "ite", "pen", "press", "ee", "oe", "jp", "ene", " pe", "xe", "ade", "pe", "lex", "me", "isse", "clus", "phone", "pm", "pex", "pei", "parse", "process", "sei", "pos", "ine", "esi", "pre", "ffe", "tp", "p", "na", "SE", "cess", "sa", "coe", "pes", "pr", "fe", "la", "inse", "sea", "perse", "pass", "pose", "si", "pid", "ste", "kes", "vale", "seq", "te", "spe", "ve", "phe", "ps", "psy", "sem", "proc", "ae", "ne", "ship", "pty", "ke", "ge", "su", "ph", "poke", "pa"]}}
{"project": "qemu", "commit_id": "97f1c45c6f456572e5b504b8614e4a69e23b8e3a", "target": 1, "func": "static void vpc_close(BlockDriverState *bs)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    g_free(s->pagetable);\n\n#ifdef CACHE\n\n    g_free(s->pageentry_u8);\n\n#endif\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n", "idx": 1817, "substitutes": {"bs": ["cms", "cs", "ss", "bh", "ba", "rs", "sa", "sb", "lb", "BS", "bc", "ins", "ms", "pb", "rb", "ls", "ses", "ds", "ps", "gs", "ns", "vs", "state", "bi", "bos", "gb", "bt", "bb", "bp", "iss", "fb", "b", "blocks", "os", "ks", "fs"], "s": ["sg", "js", "service", "cs", "http", "ss", "a", "sa", "rs", "ts", "sb", "qs", "d", "aws", "is", "sl", "bis", "g", "m", "ls", "ses", "sync", "xs", "ds", "ps", "gs", "ns", "c", "p", "services", "state", "e", "f", "es", "sys", "sq", "south", "o", "stats", "b", "S", "t", "os", "session", "your", "its", "states", "si", "sym", "ssl"]}}
{"project": "qemu", "commit_id": "4d68e86bb10159099da0798f74e7512955f15eec", "target": 0, "func": "void qemu_coroutine_adjust_pool_size(int n)\n\n{\n\n    qemu_mutex_lock(&pool_lock);\n\n\n\n    pool_max_size += n;\n\n\n\n    /* Callers should never take away more than they added */\n\n    assert(pool_max_size >= POOL_DEFAULT_SIZE);\n\n\n\n    /* Trim oversized pool down to new max */\n\n    while (pool_size > pool_max_size) {\n\n        Coroutine *co = QSLIST_FIRST(&pool);\n\n        QSLIST_REMOVE_HEAD(&pool, pool_next);\n\n        pool_size--;\n\n        qemu_coroutine_delete(co);\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool_lock);\n\n}\n", "idx": 14904, "substitutes": {"n": ["nat", "m", "en", "nl", "d", "t", "len", "l", "i", "nn", "N", "a", "cn", "nb", "x", "init", "fn", "o", "z", "u", "an", "p", "nan", "s", "e", "nc", "k", "b", "min", "j", "count", "f", "ns", "number", "c", "ne", "sn", "num", "ln"], "pool_size": ["pool__size", "pool__sized", "pool_max", "pool_capacity", "poolFsized", "poolFlimit", "pool_address", "queue_address", "queue_capacity", "queue_size", "queue_limit", "poolFsize", "poolFcapacity", "pool__limit", "pool_limit", "queue_max", "queue_sized", "pool__capacity", "pool_sized"], "co": ["aco", "mc", "bc", "po", "ca", "coe", "rc", "cc", "pc", "ko", "ra", "lc", "ci", "Co", "fo", "con", "loc", "o", "la", "lo", "nc", "ck", "oo", "ico", "mo", "fe", "c", "cu", "pe", "bo", "ro", "ce", "cf", "coll", "wo", "cl", "go", "CO"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int milkymist_memcard_init(SysBusDevice *dev)\n\n{\n\n    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);\n\n    DriveInfo *dinfo;\n\n    BlockDriverState *bs;\n\n\n\n    dinfo = drive_get_next(IF_SD);\n\n    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;\n\n    s->card = sd_init(bs, false);\n\n    if (s->card == NULL) {\n\n        return -1;\n\n    }\n\n\n\n    s->enabled = bs && bdrv_is_inserted(bs);\n\n\n\n    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,\n\n            \"milkymist-memcard\", R_MAX * 4);\n\n    sysbus_init_mmio(dev, &s->regs_region);\n\n\n\n    return 0;\n\n}\n", "idx": 17587, "substitutes": {"dev": ["dc", "spec", "Dev", "dn", "dd", "mod", "ch", "data", "gd", "conf", "md", "de", "rad", "devices", "app", "dt", "di", "des", "def", "self", "d", "hw", "w", "ev", "dm", "prof", "cam", "v", "device", "dom", "ded", "driver", "p", "od", "dem", "priv", "pro", "serial", "pu", "os", "valid", "fi", "bus", "ve", "ver", "ds"], "s": ["ns", "spec", "m", "session", "sg", "ts", "t", "rs", "f", "sv", "settings", "services", "r", "service", "plugins", "n", "sb", "g", "i", "sl", "ss", "ls", "fs", "self", "sd", "is", "o", "cs", "css", "l", "d", "su", "w", "blocks", "bis", "e", "ssl", "vs", "ses", "sync", "v", "js", "ps", "si", "c", "p", "S", "b", "gs", "sys", "u", "es", "os", "us", "sets", "south", "sq", "server", "sa", "ds", "sf"], "dinfo": ["dsid", "dsinfo", "dInfo", "odinfo", "odINFO", "ldinfo", "mdfo", "mdfi", "dfo", "ldinf", "Dinfo", "dinf", "adstate", " did", "odInfo", " dinf", "vdinfo", "vdfo", "ldfi", "Dfi", "adinfo", "dstate", "vdfi", "mdinfo", "did", "dsfi", "dINFO", " dfi", "Did", "adInfo", "Dinf", "odstate", " dfo", "mdinf", " dstate", " dInfo", "vdinf", "adINFO", " dINFO", "dfi"], "bs": ["ns", "ab", "bi", "db", "rs", "base", "ob", "ubs", "sb", "cb", "ss", "bc", "ls", "ops", "pb", "fs", "bb", "lb", "des", "ba", "bid", "cs", "gb", "android", "Bs", "bos", "bf", "BS", "iss", "bd", "blocks", "bis", "bl", "vs", "bh", "fb", "sync", "js", "bas", "ps", "ses", "lib", "b", "ks", "gs", "bytes", "os", "banks", "bes", "bus", "uds", "ds"]}}
{"project": "qemu", "commit_id": "cf29a570a7aa7abab66bf256fdf9540873590811", "target": 1, "func": "static void quorum_vote(QuorumAIOCB *acb)\n\n{\n\n    bool quorum = true;\n\n    int i, j, ret;\n\n    QuorumVoteValue hash;\n\n    BDRVQuorumState *s = acb->common.bs->opaque;\n\n    QuorumVoteVersion *winner;\n\n\n\n    if (quorum_has_too_much_io_failed(acb)) {\n\n        return;\n\n    }\n\n\n\n    /* get the index of the first successful read */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (!acb->qcrs[i].ret) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    assert(i < s->num_children);\n\n\n\n    /* compare this read with all other successful reads stopping at quorum\n\n     * failure\n\n     */\n\n    for (j = i + 1; j < s->num_children; j++) {\n\n        if (acb->qcrs[j].ret) {\n\n            continue;\n\n        }\n\n        quorum = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov);\n\n        if (!quorum) {\n\n            break;\n\n       }\n\n    }\n\n\n\n    /* Every successful read agrees */\n\n    if (quorum) {\n\n        quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov);\n\n        return;\n\n    }\n\n\n\n    /* compute hashes for each successful read, also store indexes */\n\n    for (i = 0; i < s->num_children; i++) {\n\n        if (acb->qcrs[i].ret) {\n\n            continue;\n\n        }\n\n        ret = quorum_compute_hash(acb, i, &hash);\n\n        /* if ever the hash computation failed */\n\n        if (ret < 0) {\n\n            acb->vote_ret = ret;\n\n            goto free_exit;\n\n        }\n\n        quorum_count_vote(&acb->votes, &hash, i);\n\n    }\n\n\n\n    /* vote to select the most represented version */\n\n    winner = quorum_get_vote_winner(&acb->votes);\n\n\n\n    /* if the winner count is smaller than threshold the read fails */\n\n    if (winner->vote_count < s->threshold) {\n\n        quorum_report_failure(acb);\n\n        acb->vote_ret = -EIO;\n\n        goto free_exit;\n\n    }\n\n\n\n    /* we have a winner: copy it */\n\n    quorum_copy_qiov(acb->qiov, &acb->qcrs[winner->index].qiov);\n\n\n\n    /* some versions are bad print them */\n\n    quorum_report_bad_versions(s, acb, &winner->value);\n\n\n\nfree_exit:\n\n    /* free lists */\n\n    quorum_free_vote_list(&acb->votes);\n\n}\n", "idx": 2328, "substitutes": {"acb": ["aclmb", "ucfb", "aclb", "uck", "ancf", "akmb", "acf", "acl", "mack", "ancp", "ancbb", "actk", "racn", "akwb", " acbase", "aclf", "racb", "macd", "accb", "uclb", "acp", "ecp", "acmb", "ucp", "acgb", "ack", "macp", "accl", "aucbase", " acB", "anca", "acsgb", "aucfb", "ascbb", "aucp", "accbf", "arcf", "acclb", "ancfb", "ecfb", "eck", "acc", "acfb", "acnb", "racv", "acxb", "acbf", "macb", " acl", "raclb", "acob", "acB", "ecb", "ucbd", " acxb", "ocbb", "ancB", "ancl", " acgb", "ocb", "arcB", "arcb", "ecv", "aclsb", "ucn", "accc", "acsb", "aca", "ecc", "ecd", " acsb", "ancwb", "akp", "actxb", "ucbc", "macxb", "accfb", " acfb", "akrb", "acsxb", "actfb", "aklb", "acwb", "accbase", "ancb", "accf", "accrb", "axbb", "racl", "akbc", "macfb", " acbb", "acca", "accmb", "ecmb", "akxb", "akb", "aucb", "accn", "axbd", "ucb", "acbase", "ascb", "ucrb", "acv", "akgb", "ascfb", "actb", "acrb", "ucc", "uca", "aucf", "acbc", "ecsb", "ucnb", "ucl", "racbf", "accv", "accp", "accbb", "axnb", "acbb", " acf", "ecwb", "ucbb", " acmb", "racbb", "ecbar", "aucob", "akfb", "acbd", "macsb", "axb", "accbar", "ocl", "ACl", "eca", "acck", "ACb", "accsb", " acp", "ucv", "acbar", " acnb", "accob", "aucbf", "ascbar", " aca", "acn", "accd", "ecbb", "aucbb", "ACf", "aucl", "akbb", "ancbc", " acbd", "ecxb", "ocp", "acd", " acob", "arcbb", "ACbb", "acsbb", "ecf", "ecl"], "i": ["q", "key", "mini", "n", "im", "ij", "anti", "ti", "index", "x", "ind", "hi", "f", "u", "ori", "uri", "fi", "ami", "zi", "ji", "ui", "pi", "ib", "id", "mi", "iu", "k", "api", "y", "ri", "z", "ie", "p", "e", "ia", "v", "ix", "qi", "ik", "io", "mu", "init", "li", "a", "ni", "ii", "r", "I", "di", "m", "inner", "info", "ini", "h", "c", "phi", "o", "si", "yi", "gi", "oi", "d", "it", "eni", "multi", "ai", "ip", "l", "bi", "ki", "b", "ci", "part", "my", "xi"], "j": ["jan", "js", "li", "q", "jl", "a", "ni", "ii", "ji", "ui", "r", "jen", "d", "n", "jj", "J", "k", "aj", "ij", "uj", "y", "g", "m", "jo", "bj", "index", "z", "ie", "x", "l", "ind", "p", "jc", "e", "f", "br", "je", "u", "jp", "jet", "o", "v", "b", "qi", "si", "ja"], "ret": ["match", "rot", "arg", "fun", "att", "mt", "ext", "def", "bit", "flat", "desc", "success", "url", "out", "alt", "cat", "store", "id", "rets", "num", "pass", "fail", "lt", "nt", "ft", "err", "rev", "back", "reply", "status", "Ret", "rc", "bf", "opt", "last", "result", "bot", "et", "f", "len", "ref", "flag", "gt", "art", "en", "RET", "seq", "req", "error", "valid", "hard", "re", "reg", "val", "rt", "lit", "count", "det", "res", "mem"], "hash": ["match", "base", "lock", "total", "version", "key", " Hash", "ruby", "her", "url", "header", "alt", "bc", "id", "sh", "num", "ha", "pass", "rh", "g", "info", "number", "rev", "err", "str", "index", "status", "pool", "result", "h", "block", "ref", "Hash", "cache", "message", "dig", " hashes", "node", "sum", "sha", "seq", "error", "depth", "full", "val", "msg", "kh", "response", "res", "user", "ash"], "s": ["sg", "submit", "js", "sa", "qs", "n", "sites", "sl", "g", "ls", "ses", "sf", "args", "self", "us", "f", "set", "sys", "sc", "u", "admin", "se", "fs", "parser", "sup", "spec", "sb", "aws", "y", "xs", "sets", "p", "state", "e", "conf", "su", "site", "S", "os", "ks", "sym", "ssl", "cs", "ss", "a", "new", "r", "is", "m", "settings", "ds", "ps", "gs", "ns", "c", "es", "south", "o", "si", "server", "service", "http", "ops", "d", "scope", "sis", "sync", "l", "services", "w", "sq", "stats", "b", "sort", "states", "game"], "winner": ["unit", "parser", "version", "ner", "breaker", "addon", "success", "division", "n", "student", "author", "bc", "widget", "adder", "worker", "bin", "nic", "lot", "won", "num", "next", "year", "builder", "vict", "seller", "inner", "score", "master", "number", "rev", "live", "leader", "index", "status", "Winner", " winners", "runner", "ani", "slice", "result", "owner", "writer", "role", "reader", "block", "maker", "rank", "alpha", "draw", "nick", "token", "node", "creator", "win", "v", "gen", "winning", "vote", "player", "root", "init", "wp", "game"]}}
{"project": "qemu", "commit_id": "947995c09ebd35a752837a5573985ba5a9942ec1", "target": 0, "func": "static int path_has_protocol(const char *path)\n\n{\n\n#ifdef _WIN32\n\n    if (is_windows_drive(path) ||\n\n        is_windows_drive_prefix(path)) {\n\n        return 0;\n\n    }\n\n#endif\n\n\n\n    return strchr(path, ':') != NULL;\n\n}\n", "idx": 20728, "substitutes": {"path": ["col", "transform", "request", "name", "port", "cross", "ath", "object", "end", "next", "pattern", "config", "text", "part", "Path", "key", "file", "broken", "sign", "temp", "host", "node", "anc", "dir", "ith", "entry", "data", "full", "PATH", "method", "p", "or", "enc", "prefix", "code", "word", "open", "c", "self", "index", "match", "pass", "core", "child", "loc", "test", "root", "parent", "then", "pointer", "image", "url", "value"]}}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)\n\n{\n\n    uint32_t v, spf;\n\n    MPADecodeHeader c;\n\n    int vbrtag_size = 0;\n\n    MP3DecContext *mp3 = s->priv_data;\n\n\n\n    ffio_init_checksum(s->pb, ff_crcA001_update, 0);\n\n\n\n    v = avio_rb32(s->pb);\n\n    if(ff_mpa_check_header(v) < 0)\n\n      return -1;\n\n\n\n    if (avpriv_mpegaudio_decode_header(&c, v) == 0)\n\n        vbrtag_size = c.frame_size;\n\n    if(c.layer != 3)\n\n        return -1;\n\n\n\n    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */\n\n\n\n    mp3->frames = 0;\n\n    mp3->size   = 0;\n\n\n\n    mp3_parse_info_tag(s, st, &c, spf);\n\n    mp3_parse_vbri_tag(s, st, base);\n\n\n\n    if (!mp3->frames && !mp3->size)\n\n        return -1;\n\n\n\n    /* Skip the vbr tag frame */\n\n    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);\n\n\n\n    if (mp3->frames)\n\n        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},\n\n                                    st->time_base);\n\n    if (mp3->size && mp3->frames && !mp3->is_cbr)\n\n        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);\n\n\n\n    return 0;\n\n}\n", "idx": 4879, "substitutes": {"s": ["sets", "ches", "sf", "is", "S", "spec", "sg", "session", "b", "si", "sync", "sys", "ses", "services", "m", "its", "states", "xs", "f", "ns", "sl", "ls", "space", "service", "bs", "cs", "ss", "us", "conf", "e", "sc", "sb", "w", "se", "sim", "gs", "ks", "ds", "storage", "t", "qs", "ops", "ts", "su", "self", "p", "aws", "sv", "fs", "sup", "sa", "os", "g", "ssl", "sq", "sym", "es", "rs", "src", "ps", "js"], "st": ["std", "r", "est", "ste", "store", "ost", "tmp", "b", "si", "style", "sn", "stack", "stream", "ust", "support", "sts", "rest", "state", "d", "sl", "St", "fe", "cs", "ss", "td", "e", "sc", "sth", "sb", "stop", "inst", "sh", "sd", "ds", "t", "ctx", "storage", "ts", "ST", "str", "p", "sta", "stage", "sp", "start", "step", "sa", "ct", "src", "ast", "nd"], "base": ["bas", "kit", "address", "name", "area", "stable", "origin", "store", "id", "a", "beta", "val", "ada", "b", "i", "stack", "bi", "ace", " bases", "l", "ma", "rest", "client", "at", "f", "offset", "version", "server", "ii", "byte", "u", "buffer", "len", "out", "full", "bound", "pad", "ase", "p", "old", "based", "scale", "root", "Base", "stage", "temp", "gb", "zero", "start", "ver", "hi", "bf", "api", "cache", "ases", "set", "index", "r", "end", "ui", "prefix"], "v": ["o", "ch", "store", "a", "vd", "vm", "channel", "va", "V", "value", "b", "val", "x", "i", "format", "m", "uv", " channel", "l", "f", "pi", "at", "conv", "d", "ve", "j", "q", "u", "vi", "code", "e", "vs", "w", "k", "t", "n", "volt", "rev", "p", "h", "vert", "z", "sv", "iv", "ver", "g", "api", "lv", "vv", "cv", "vc", " version", "r"], "spf": [" spp", "ipF", "ipv", "SPp", "aspfw", "aspv", "ipf", " spg", "scg", "scf", "arpfx", "swfs", "scv", "scfg", "epf", "spF", " spfw", "epF", " spfg", "aspf", "spb", "swb", " spv", "scfe", "arpf", "SPb", "spv", " spF", "ispfs", "scfs", "scfd", "scfw", "ispfg", "ispf", " spfd", "scfx", " spfs", "spfe", "spfo", "spfx", " spfx", "arpfd", "spfd", "epfs", "aspfo", "scfo", "swf", " spfo", "SPf", "swp", "spfw", "spg", "SPfs", "epv", "ispfe", "spp", " spb", "arpg", "spfs", " spfe", "ipfs", "spfg"], "c": ["cp", "ch", "cr", "a", "spec", "ci", "config", "b", "x", "rc", "i", "cy", "enc", "co", "C", "m", "uc", "l", "cl", "f", "d", "pc", "cc", "cs", "ce", "u", "code", "e", "sc", "mc", "con", "t", "dc", "n", "ctx", "k", "bc", "cu", "coll", "p", "ic", "ctrl", "ec", "h", "g", "ct", "cf", "lc", "fc", "ac", "vc", "cm", "xc", "tc"], "mp3": ["pp3", "comp3", "pm3", "mag13", "mt23", " mp53", "mb3", " mpthree", "mm6", "mp6", "Mp13", "map253", "avthree", "mb35", "mp23", "mb23", "Mp3", "MP3", "map3", "media23", "av253", "MP6", "Mp03", " mp6", "mag6", "media03", "pp35", "Mp2", "mb1", "av03", "Mp6", "pp53", "mbthree", "mt15", "mp2", " mp15", "mp35", "mapthree", " mpcd", "mb6", "mb13", "mp253", "mp13", "amp3", "mp48", "mb253", "mag3", " mp23", "pp03", "av3", "mb15", "jp1", "av48", " mp4", "mpthree", "jp4", "mb03", "map03", "ampcd", "jp03", "MP03", "mp15", "magthree", "mp03", "MPthree", "mm3", " mp2", "mm03", "mb2", " mp03", "comp13", "mediathree", "MP13", " mp1", "comp03", "mpcd", "mb4", "amp6", "pp23", "mt3", "Mpcd", "mb53", "mm53", "jp3", "pm03", "pm35", "pm23", "mt6", "ppthree", "pp2", "MP48", "mp1", "amp2", "media3", "mp4", "mp53", "comp48"]}}
{"project": "qemu", "commit_id": "40ff6d7e8dceca227e7f8a3e8e0d58b2c66d19b4", "target": 1, "func": "int inet_dgram_opts(QemuOpts *opts)\n\n{\n\n    struct addrinfo ai, *peer = NULL, *local = NULL;\n\n    const char *addr;\n\n    const char *port;\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int sock = -1, rc;\n\n\n\n    /* lookup peer addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;\n\n    ai.ai_family = PF_UNSPEC;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"host\");\n\n    port = qemu_opt_get(opts, \"port\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = \"localhost\";\n\n    }\n\n    if (port == NULL || strlen(port) == 0) {\n\n        fprintf(stderr, \"inet_dgram: port not specified\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (qemu_opt_get_bool(opts, \"ipv4\", 0))\n\n        ai.ai_family = PF_INET;\n\n    if (qemu_opt_get_bool(opts, \"ipv6\", 0))\n\n        ai.ai_family = PF_INET6;\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n\treturn -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: peer (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, peer);\n\n    }\n\n\n\n    /* lookup local addr */\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    ai.ai_family = peer->ai_family;\n\n    ai.ai_socktype = SOCK_DGRAM;\n\n\n\n    addr = qemu_opt_get(opts, \"localaddr\");\n\n    port = qemu_opt_get(opts, \"localport\");\n\n    if (addr == NULL || strlen(addr) == 0) {\n\n        addr = NULL;\n\n    }\n\n    if (!port || strlen(port) == 0)\n\n        port = \"0\";\n\n\n\n    if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) {\n\n        fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port,\n\n                gai_strerror(rc));\n\n        return -1;\n\n    }\n\n    if (sockets_debug) {\n\n        fprintf(stderr, \"%s: local (%s:%s)\\n\", __FUNCTION__, addr, port);\n\n        inet_print_addrinfo(__FUNCTION__, local);\n\n    }\n\n\n\n    /* create socket */\n\n    sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol);\n\n    if (sock < 0) {\n\n        fprintf(stderr,\"%s: socket(%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family), strerror(errno));\n\n        goto err;\n\n    }\n\n    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on));\n\n\n\n    /* bind socket */\n\n    if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen,\n\n                    uaddr,INET6_ADDRSTRLEN,uport,32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) {\n\n        fprintf(stderr,\"%s: bind(%s,%s,%d): OK\\n\", __FUNCTION__,\n\n                inet_strfamily(local->ai_family), uaddr, inet_getport(local));\n\n        goto err;\n\n    }\n\n\n\n    /* connect to peer */\n\n    if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen,\n\n                    uaddr, INET6_ADDRSTRLEN, uport, 32,\n\n                    NI_NUMERICHOST | NI_NUMERICSERV) != 0) {\n\n        fprintf(stderr, \"%s: getnameinfo: oops\\n\", __FUNCTION__);\n\n        goto err;\n\n    }\n\n    if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) {\n\n        fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", __FUNCTION__,\n\n                inet_strfamily(peer->ai_family),\n\n                peer->ai_canonname, uaddr, uport, strerror(errno));\n\n        goto err;\n\n    }\n\n\n\n    freeaddrinfo(local);\n\n    freeaddrinfo(peer);\n\n    return sock;\n\n\n\nerr:\n\n    if (-1 != sock)\n\n        closesocket(sock);\n\n    if (local)\n\n        freeaddrinfo(local);\n\n    if (peer)\n\n        freeaddrinfo(peer);\n\n    return -1;\n\n}\n", "idx": 1519, "substitutes": {"opts": ["OPTS", "promets", "optfs", "OPuts", "opertr", "operfs", "otuts", "opments", "OPts", "opps", "opert", "OPfs", "optes", "operTS", "opercs", "otts", "opted", "optr", "otments", "popts", " opTS", "poputs", "optt", "obted", "promtes", "optted", " optr", "ottes", "opt", "poptes", "optets", "opTS", "optts", "optcs", "opcs", "obt", "OPtes", "optuts", "opertes", "operps", "optments", "opttr", "OPt", "promts", "obTS", "OPted", "optps", " opments", "operts", "opttes", "OPcs", "operments", "promps", "opfs", "popt", "operuts", "obts", "oputs", "optTS", "opets", "operets"], "ai": ["sa", "hai", "apache", "client", "ti", "asc", "address", "AI", "gui", "ais", "qa", "af", "an", "admin", "ae", " sa", "ami", " bi", " ca", "ui", "mi", "parent", "api", "adr", "mac", "ac", "pai", "pa", "p", "org", "lib", "qi", "plugin", "wa", "sci", "io", "pin", " ga", " mi", "cm", "li", "channel", "a", "mod", "ni", "ee", "loc", "di", "ta", "ha", "py", "i", "ait", "afi", "attr", "app", "cache", "connection", "asm", "SA", "bridge", "ay", "agi", "module", "net", "si", "server", "http", "gi", "ga", "conn", "ei", "asi", "fa", " ta", " pri", "co", "aa", "ape", "aii", "na", " li", "eni", "aud", "config", "au", "bi", " ac", "ca", " api", "pc", "ci", "ann", "db"], "peer": ["layer", "server", "name", "src", "ctx", "offset", "channel", "inter", "conn", "pe", "host", "url", "r", "type", "unknown", "chain", "scope", "worker", "parent", "client", "remote", "instance", "wire", "tp", "proc", "info", "master", "er", "source", "request", "pool", "address", "owner", "ip", "pkg", "state", "ptr", "resource", "attr", "sys", "conf", "eth", "username", "node", "ssl", "pc", "socket", "family", "mode", "slave", "root", "vr", "ace", "user"], "local": ["layer", "http", "url", "localhost", "loc", "global", "lang", "auth", "remote", "shared", "loop", "tp", "ac", "file", "tx", "master", "pool", "pkg", "state", "private", "conf", "cache", "public", "node", "pc", "lib", "location", "ssl"], "addr": ["dr", "route", "url", "alt", "adder", "direction", "home", "address", "ack", "air", "Address", "ress", "aug", "od", "uri", "arrow", "rt", "name", "ext", "host", "nn", "filename", "align", "html", "auth", "arr", "adr", "mac", "ac", "pkg", "work", "ptr", "hop", "wd", "amp", "ast", "layer", "offset", "pe", "az", "rr", "loc", "ad", "env", "ha", "str", "usr", "attr", "arm", "cmd", "node", "bb", "prefix", "rss", "enter", "oa", "server", "href", "src", "dd", "conn", "alias", "area", "ord", "config", "ip", "east", "art", "email", "amd", "over", "vr", "part", "ace"], "port": ["allow", "rot", "rest", "key", "url", "alt", "wait", " Port", "password", "direction", "address", "select", "opt", "pr", "round", "cp", "path", "all", "option", "name", "time", "target", "host", "pi", "tag", "type", "position", "id", "end", "pair", "api", "adr", "mac", "Port", "post", "non", "p", "ptr", "per", "length", "hop", "patch", "text", "pt", "nat", "version", "offset", "loc", "op", "py", "pre", "proxy", "body", "project", "slice", "ports", "pid", "pad", "h", "size", "attr", "value", "tt", "PORT", "rule", "ort", "test", "service", "no", "method", "class", "prop", "th", "pos", "phone", "dest", "source", "ip", "col", "token", "fat", "username", "point", "part"], "uaddr": ["uwd", "Uaddr", "luaddr", "luhost", "Uhost", "Uaddress", "luaddress", "uhost", "uaddress", "luwd", "Uwd"], "uport": ["ueip", "uename", "ulname", "ulip", "ulport", "uip", "ueport", "uname"], "rc": ["PC", "fc", "rg", "src", "rs", "roc", "anc", "cc", "rw", "rn", "success", "r", "loc", "rr", "rect", "ru", "ck", "nc", "RC", "rec", "bc", "cur", "tc", " RC", "rf", "irc", "ac", "rb", "ri", "cr", "back", "ras", "reply", "dc", "ack", "result", "c", "xc", "lc", "rl", "sc", "rd", "pc", "sr", "RR", "error", "rx", "ci", "rt", "inc", "rh"]}}
{"project": "qemu", "commit_id": "a718978ed58abc1ad92567a9c17525136be02a71", "target": 1, "func": "static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)\n\n{\n\n    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n\n    IDEState *s = bmdma_active_if(bm);\n\n    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);\n\n    struct {\n\n        uint32_t addr;\n\n        uint32_t size;\n\n    } prd;\n\n    int l, len;\n\n\n\n    pci_dma_sglist_init(&s->sg, pci_dev,\n\n                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            /* end of table (with a fail safe of one page) */\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {\n\n                return s->io_buffer_size;\n\n            }\n\n            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n\n\n\n            /* Note: We limit the max transfer to be 2GiB.\n\n             * This should accommodate the largest ATA transaction\n\n             * for LBA48 (65,536 sectors) and 32K sector sizes. */\n\n            if (s->sg.size > INT32_MAX) {\n\n                error_report(\"IDE: sglist describes more than 2GiB.\");\n\n                break;\n\n            }\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n\n\n    qemu_sglist_destroy(&s->sg);\n\n    s->io_buffer_size = 0;\n\n    return -1;\n\n}\n", "idx": 3970, "substitutes": {"dma": ["Dda", "mdma", "mdla", "mwa", "mma", " dwa", "bMA", "bma", " dta", "mdwa", "mdMA", "dwa", "Dwa", "mMA", "dta", "Dmm", " dMA", " dda", "dmm", "bta", " dmm", "ldla", "dMA", "mmp", " dmp", "dda", "ldma", "ldMA", "DMA", "bmp", "ldwa", "mmm", "Dma", "dmp", "dla", "Dla", "mta", "mda"], "is_write": ["is_read", "id_writ", "id_mode", "id_write", "is_writ", "id_read", "is_mode"], "bm": ["cm", "base", "vm", "dn", "bh", "bn", "em", "bo", "mc", "sb", "lb", "binary", "fl", "bc", "BM", "mi", "bin", "im", "pb", "mm", "bl", "umi", "y", "lim", "m", "gm", "cb", "sbm", "md", "om", "bf", "gs", "hm", "p", "bi", "nb", "dm", "ym", "bd", "ram", "cache", "wm", "rm", "gb", "rem", "bt", "pm", "obj", "bg", "fm", "bb", "mr", "tm", "nm", "sm", "b", "bp", "module", "bs", "an", "cfg", "am", "gp", "db"], "s": ["sg", "js", "service", "so", "cs", "ss", "rs", "sa", "spec", "ts", "sb", "ings", "qs", "r", "d", "is", "ins", "sl", "ions", "ms", "y", "sis", "g", "m", "ses", "ls", "sync", "ys", "sv", "storage", "ds", "sets", "ps", "gs", "ns", "c", "p", "state", "services", "e", "w", "f", "es", "secondary", "sys", "sq", "conf", "set", "sn", "sr", "o", "stats", "b", "su", "S", "os", "session", "serv", "sim", "t", "bs", "an", "its", "hs", "states", "se", "fs", "si", "sym", "ssl"], "pci_dev": ["pcm_device", "pci__addr", "pdi_div", "pciMdevice", "pci__mode", "pci2div", "pcm_div", "pci2device", "pci__device", "pci_priv", "pci_device", "pci2conn", "pci_addr", "pciMmode", "pciMdiv", "pdi_mode", "pci__dev", "pdi_priv", "pcm_dev", "pdi_device", "pcm_conn", "pci2dev", "pci_div", "pciMdev", "pci_conn", "pdi_dev", "pci2priv", "pci_mode", "pdi_addr"], "prd": ["frdd", " prcd", "sprdm", " prdh", "sprb", " prdt", "perd", "yrdd", "frd", " prt", "prb", "rd", "prs", "rt", " prn", "prr", "erdh", "perr", "parb", "sprdd", "privd", "Prd", "sprd", "parcd", "Prds", "erds", " prb", "sprs", "erd", "prcd", "prdh", "ptrds", " prs", "privs", "sprcd", "perb", "frn", "pert", "ird", "Prdh", "prdm", "ptrn", "sprdy", "trd", "ern", "prdy", " prr", "trds", "rr", " prdd", "pern", "frds", "prt", "ptrs", "prds", "privdt", "pard", "yrd", "irdy", "ptrdy", " prdy", "trs", "prdt", "privds", "ptrdm", "perdy", "ptrb", " prds", "yrds", "sprds", " prdm", "ptrd", "rb", "Prn", "parn", "irs", "prn", "yrb", "trdt", "prdd", "sprn", "irds"], "l": ["ell", "ld", "li", "ol", "jl", "ul", "lp", "lb", "vl", "r", "d", "n", "dl", "lu", "ln", "fl", "lf", "sl", "nl", "i", "j", "m", "ls", "ll", "z", "tl", "c", "p", "L", "e", "lc", "f", "length", "kl", "rl", "El", "u", "la", "el", "il", "en", "o", "v", "b", "lin", "lit", "le"], "len": ["base", "ell", "ld", "li", "lan", "ol", "lp", "elt", "ni", "Len", "url", "loc", "n", "lf", "lu", "ln", "fl", "sl", "dl", "bl", "j", "lim", "pos", "dy", "ll", "lt", "err", "rev", "z", "lon", "L", "ler", "lc", "length", "kl", "f", "size", "la", "el", "il", "en", "v", "hl", "lib", "lin", "full", "line", "low", "val", "count", "limit", "le"]}}
{"project": "FFmpeg", "commit_id": "c1f2c4c3b49277d65b71ccdd3b6b2878f1b593eb", "target": 0, "func": "static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n                      int src_count, int src_size, int dest_len)\n\n{\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetByteContext gb;\n\n\n\n    bytestream2_init(&gb, src, src_size);\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            return 0;\n\n        *pd++ = bytestream2_get_byteu(&gb);\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            break;\n\n        l = bytestream2_get_byteu(&gb);\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)\n\n                return bytestream2_tell(&gb);\n\n            bytestream2_get_bufferu(&gb, pd, l);\n\n            pd += l;\n\n        } else {\n\n            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)\n\n                return bytestream2_tell(&gb);\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n            }\n\n            bytestream2_skip(&gb, 2);\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return bytestream2_tell(&gb);\n\n}\n", "idx": 18648, "substitutes": {"src": ["sur", "rs", "gd", "image", "rc", "sb", "cb", "sl", "attr", "ources", "loc", "sel", "ctx", "slice", "inf", "rib", "sub", "img", "config", "sr", "sc", "ssl", "sth", "buff", "sync", "cur", "rb", "uc", "url", "gz", "storage", "split", "inst", "sq", "source", "dist"], "dest": ["dc", "sup", "dd", "data", "destroy", "rest", "gd", " destination", "mode", "delete", "lit", "de", "sb", "usr", "cp", "wb", "slice", "done", "wd", "ptr", "pb", "home", "d", "class", "later", "std", "path", "ident", "large", "img", "config", "standard", "remote", "buff", "comb", "sync", "target", "v", "tmp", "trans", "slave", "uc", "dev", "route", "wh", "Dest", "end", "desc", "source", "dist"], "src_count": ["src_low", " src_order", "source_size", "src__size", "src__sum", "src64size", "src__len", "srcqsize", "src__low", " src_length", "src__limit", " src_limit", "source_len", "src_length", "src_sum", "src64count", "src__count", "source_sum", "srcqlength", "src_id", "src_order", "src_len", "src_limit", " src_id", "srcqorder", " src_low", "source_count", "src64order", "srcqcount", "src__id", "src__length", "src64length"], "src_size": [" src_len", "src2name", " src_length", "src2len", "src2length", "src_length", " src_name", "src2size", "src_len", "src_name"], "dest_len": ["Dest_pos", "dest_pos", "Dest_len", "dest_l", "dest_length", "Dest_size", "Dest_line", "Dest_l", "Dest_length", "dest_line", "dest_size"], "pd": ["pc", "dra", "wp", "grad", "dd", "sg", "db", "pid", "cdn", "data", "gd", "fp", "sv", "pod", "td", "md", "edd", "pl", "sb", "pm", "hd", "cp", "lp", "vd", "wb", "dt", "ld", "dl", "pb", "bb", "wd", "slice", "sd", "lv", "parser", "po", "dp", "pg", "d", "std", "pkg", "bf", "pi", "ci", "bd", "fd", "sth", "xd", "lc", "lib", "PD", "p", "da", "ud", "ppa", "od", "god", "cd", "dL", "wa", "api", "pro", "tp", "py", "php", "dk", "li", "ds"], "i": ["ti", "uri", "gi", "m", "bi", "j", "ji", "t", "x", "f", "ix", "ini", "qi", "r", "ai", "io", "n", "mi", "phi", "fi", "g", "hi", "z", "ii", "in", "ie", "iu", "index", "ind", "di", "I", "dl", "count", "o", "ip", "L", "d", "yi", "pi", "ui", "ci", "id", "start", "e", "k", "v", "cli", "c", "ni", "si", "lc", "ri", "p", "xi", "ll", "b", "split", "list", "el", "y", "li", "u"], "l": ["m", "s", "j", "ell", "t", "f", "all", "r", "n", "pl", "lu", "g", "kl", "sl", "z", "nl", "ls", "lp", "dl", "lb", "o", "L", "lf", "ln", "tl", "d", "lo", "fl", "le", "ol", "length", "il", "e", "bl", "k", "v", "lc", "c", "ll", "p", "line", "b", "col", "la", "ul", "u", "h", "el", "li", "len"], "dest_end": ["dest___start", "dest_tail", "src_end", "src_tail", "Dest_end", "destacstart", "Dest_limit", "Dest_len", "src_last", "dest_limit", "destactail", "dest_start", "destallstart", "destallimit", "destallname", "dest___len", "dest_enc", "destallend", "dest___end", "destacend", "destaclast", "destalstart", "Dest_name", "src_start", "dest___enc", "destalllimit", "destalname", "dest_name", "dest_last", "destalend", "Dest_enc", "Dest_start"], "gb": ["pc", "gi", "gn", "gram", "cfg", "eb", "db", "GB", "gd", "gal", "yg", "gio", "gow", "rc", "usb", "gu", "gc", "gg", "bm", "gae", "gom", "sb", "g", "gin", "cb", "sl", "hd", "bc", "gru", "hub", " storage", "greg", "gam", "rg", "bb", "phy", "nb", " db", "git", " rgb", "pg", "range", "gp", "bo", " rg", "kb", "bf", "ui", "ci", "mb", "gh", "gl", "ga", "cli", "lc", "rb", "bg", "gt", "b", "gz", "gs", " rc", "cd", "gy", "gm", "storage", "boot", " GB", "Gb", "ub", "ds"]}}
{"project": "FFmpeg", "commit_id": "9924f1bc34242bb9315c355108f3ce744c1f33c5", "target": 0, "func": "static int mkv_write_header(AVFormatContext *s)\n\n{\n\n    MatroskaMuxContext *mkv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    ebml_master ebml_header;\n\n    AVDictionaryEntry *tag;\n\n    int ret, i, version = 2;\n\n    int64_t creation_time;\n\n\n\n    if (!strcmp(s->oformat->name, \"webm\"))\n\n        mkv->mode = MODE_WEBM;\n\n    else\n\n        mkv->mode = MODE_MATROSKAv2;\n\n\n\n    if (mkv->mode != MODE_WEBM ||\n\n        av_dict_get(s->metadata, \"stereo_mode\", NULL, 0) ||\n\n        av_dict_get(s->metadata, \"alpha_mode\", NULL, 0))\n\n        version = 4;\n\n\n\n    if (s->nb_streams > MAX_TRACKS) {\n\n        av_log(s, AV_LOG_ERROR,\n\n               \"At most %d streams are supported for muxing in Matroska\\n\",\n\n               MAX_TRACKS);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 ||\n\n            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"The Matroska muxer does not yet support muxing %s\\n\",\n\n                   avcodec_get_name(s->streams[i]->codecpar->codec_id));\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS ||\n\n            av_dict_get(s->streams[i]->metadata, \"stereo_mode\", NULL, 0) ||\n\n            av_dict_get(s->streams[i]->metadata, \"alpha_mode\", NULL, 0))\n\n            version = 4;\n\n    }\n\n\n\n    mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks));\n\n    if (!mkv->tracks) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLVERSION        ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLREADVERSION    ,           1);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXIDLENGTH    ,           4);\n\n    put_ebml_uint   (pb, EBML_ID_EBMLMAXSIZELENGTH  ,           8);\n\n    put_ebml_string (pb, EBML_ID_DOCTYPE            , s->oformat->name);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEVERSION     ,     version);\n\n    put_ebml_uint   (pb, EBML_ID_DOCTYPEREADVERSION ,           2);\n\n    end_ebml_master(pb, ebml_header);\n\n\n\n    mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0);\n\n    mkv->segment_offset = avio_tell(pb);\n\n\n\n    // we write 2 seek heads - one at the end of the file to point to each\n\n    // cluster, and one at the beginning to point to all other level one\n\n    // elements (including the seek head at the end of the file), which\n\n    // isn't more than 10 elements if we only write one of each other\n\n    // currently defined level 1 element\n\n    mkv->main_seekhead    = mkv_start_seekhead(pb, mkv->segment_offset, 10);\n\n    if (!mkv->main_seekhead) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    ret = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb));\n\n    if (ret < 0) goto fail;\n\n\n\n    ret = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0);\n\n    if (ret < 0)\n\n        return ret;\n\n    pb = mkv->info_bc;\n\n\n\n    put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000);\n\n    if ((tag = av_dict_get(s->metadata, \"title\", NULL, 0)))\n\n        put_ebml_string(pb, MATROSKA_ID_TITLE, tag->value);\n\n    if (!(s->flags & AVFMT_FLAG_BITEXACT)) {\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT);\n\n        if ((tag = av_dict_get(s->metadata, \"encoding_tool\", NULL, 0)))\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, tag->value);\n\n        else\n\n            put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT);\n\n\n\n        if (mkv->mode != MODE_WEBM) {\n\n            uint32_t segment_uid[4];\n\n            AVLFG lfg;\n\n\n\n            av_lfg_init(&lfg, av_get_random_seed());\n\n\n\n            for (i = 0; i < 4; i++)\n\n                segment_uid[i] = av_lfg_get(&lfg);\n\n\n\n            put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, segment_uid, 16);\n\n        }\n\n    } else {\n\n        const char *ident = \"Lavf\";\n\n        put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident);\n\n        put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident);\n\n    }\n\n\n\n    if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) {\n\n        // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds.\n\n        int64_t date_utc = (creation_time - 978307200000000LL) * 1000;\n\n        uint8_t date_utc_buf[8];\n\n        AV_WB64(date_utc_buf, date_utc);\n\n        put_ebml_binary(pb, MATROSKA_ID_DATEUTC, date_utc_buf, 8);\n\n    }\n\n\n\n    // reserve space for the duration\n\n    mkv->duration = 0;\n\n    mkv->duration_offset = avio_tell(pb);\n\n    if (!mkv->is_live) {\n\n        int64_t metadata_duration = get_metadata_duration(s);\n\n\n\n        if (s->duration > 0) {\n\n            int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else if (metadata_duration > 0) {\n\n            int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE);\n\n            put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration);\n\n            av_log(s, AV_LOG_DEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration);\n\n        } else {\n\n            put_ebml_void(pb, 11);              // assumes double-precision float to be written\n\n        }\n\n    }\n\n    if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n\n        end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info);\n\n    else\n\n        end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info);\n\n    pb = s->pb;\n\n\n\n    // initialize stream_duration fields\n\n    mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n    mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t));\n\n\n\n    ret = mkv_write_tracks(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    for (i = 0; i < s->nb_chapters; i++)\n\n        mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id);\n\n\n\n    ret = mkv_write_chapters(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    if (mkv->mode != MODE_WEBM) {\n\n        ret = mkv_write_attachments(s);\n\n        if (ret < 0)\n\n            goto fail;\n\n    }\n\n\n\n    ret = mkv_write_tags(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live)\n\n        mkv_write_seekhead(pb, mkv);\n\n\n\n    mkv->cues = mkv_start_cues(mkv->segment_offset);\n\n    if (!mkv->cues) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) {\n\n        mkv->cues_pos = avio_tell(pb);\n\n        put_ebml_void(pb, mkv->reserve_cues_space);\n\n    }\n\n\n\n    av_init_packet(&mkv->cur_audio_pkt);\n\n    mkv->cur_audio_pkt.size = 0;\n\n    mkv->cluster_pos = -1;\n\n\n\n    avio_flush(pb);\n\n\n\n    // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or\n\n    // after 4k and on a keyframe\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 5000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 5 * 1024 * 1024;\n\n    } else {\n\n        if (mkv->cluster_time_limit < 0)\n\n            mkv->cluster_time_limit = 1000;\n\n        if (mkv->cluster_size_limit < 0)\n\n            mkv->cluster_size_limit = 32 * 1024;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    mkv_free(mkv);\n\n    return ret;\n\n}\n", "idx": 3117, "substitutes": {"s": ["sg", "submit", "js", "this", "qs", "sa", "n", "sites", "sl", "client", "g", "ses", "ls", "sf", "self", "us", "f", "secondary", "sys", "u", "single", "events", "your", "an", "se", "fs", "parts", "sup", "spec", "ts", "sb", "aws", "uploads", "uns", "xs", "sv", "request", "sets", "p", "e", "conf", "v", "su", "serv", "S", "os", "ks", "session", "bs", "its", "hs", "in", "plugins", "sym", "ssl", "cs", "ss", "a", "rs", "new", "r", "is", "ins", "ions", "m", "settings", "ds", "als", "ps", "gs", "ns", "c", "es", "south", "si", "server", "service", "http", "ops", "ads", "d", "ans", "sis", "comments", "sync", "tests", "l", "services", "w", "features", "sq", "stats", "b", "support", "states"], "mkv": ["ikv", "okv", "okV", "ikov", "skov", "wkv", "ckv", "mku", "okh", "ckV", "mkl", "kv", "mkver", "ckj", "tkver", " mkh", "ckvv", "skc", "ikc", " mkl", "mkj", " mkV", " mkver", "bbov", " mkj", "mkvv", "okl", "wkvv", "tkov", "wkj", "mkc", "okov", "skV", "tkv", "mkV", "skv", "kl", "bbv", "bbver", "mkh", "ikV", "tku", "okc", "mkov", "kV", " mkvv", "wkV", "kh", "bbu", " mku", " mkov"], "pb": ["parser", "verb", "ctx", "primary", "lp", "sb", "mc", "lb", "ab", "bm", "cpp", "hub", "ub", "prot", "vim", "type", "bc", "platform", "buf", "tmp", "PB", "rb", "fp", "cb", "pa", "cv", "wb", "message", "gb", "summary", "pm", "obj", "phrase", "amp", "meta", "bp", "pc", "bb", "mp", "fb", "cp", "bs", "wp", "typ", "db"], "ebml_header": ["ebsl_headers", "ebml_metadata", "ebsl_header", "ebsl_main", "ebml_headers", "ebml_main", "ebsl_metadata"], "tag": ["test", "row", "version", "name", "TAG", "key", "xml", "cat", "type", "rec", "id", "record", "entry", "bug", "tr", "config", "last", "description", "feature", "ack", "stream", "comment", "module", "tags", "Tag", "desc"], "ret": ["vision", "server", " compat", "out", " val", " revision", "con", "j", " clen", " resp", " result", " Version", "code", "rev", " success", "result", " r", "cv", "dev", " ver", "len", "resp", " vers", "VERSION", " rc", "rc"], "i": ["ski", "cli", "yi", "name", "my", "li", "gi", "abi", "iri", "ni", "ii", "zi", "pi", "ui", "mini", "oi", "d", "n", "I", "type", "di", "id", "mi", "it", "iu", "api", "j", "g", "y", "eni", "ri", "inner", "m", "info", "ti", "ini", "index", "multi", "temp", "ai", "ie", "ip", "ind", "p", "phi", "e", "f", "ori", "o", "v", "iv", "qi", "ix", "b", "ik", "uri", "ci", "io", "mu", "init", "fi", "start", "si", "xi"], "creation_time": ["creation4time", "creation4info", "creation2tc", "create_tc", "creation2info", "create_time", "creation4timer", "creation4tc", "create_info", "creation_tc", "creation2timer", "creation2time", "create_timer", "creation_info", "creation_timer"]}}
{"project": "qemu", "commit_id": "0dacea92d26c31d453c58de2e99c178fee554166", "target": 1, "func": "putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)\n\n{\n\n    uint32_t sum;\n\n\n\n    if (cse && cse < n)\n\n        n = cse + 1;\n\n    if (sloc < n-1) {\n\n        sum = net_checksum_add(n-css, data+css);\n\n        stw_be_p(data + sloc, net_checksum_finish(sum));\n\n    }\n\n}\n", "idx": 15594, "substitutes": {"sum": ["Sum", "pal", "val", "style", "mean", "ass", "g", "weight", "user", "acc", "loss", "si", "vol", "total", "fat", "comment", "aa", "hash", "alpha", "ul", "cost", "summary", "mem", "sign", "doc", "size", "parse", "match", "count", "dot", "result", "skip", "add", "average", "gram", "ac", "scale", "out", "cal", "sh", "um", "sa", "cache", "fee", "pos", "num"]}}
{"project": "qemu", "commit_id": "ef4c9fc8542e06b1d567172c04b0c0377c7ab0c5", "target": 1, "func": "int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)\n\n{\n\n    unsigned int idx, rec_off, old_idx, new_idx;\n\n    uint32_t rec_len = sizeof(TraceRecord) + datasize;\n\n    uint64_t event_u64 = event;\n\n    uint64_t timestamp_ns = get_clock();\n\n\n\n    do {\n\n        old_idx = g_atomic_int_get(&trace_idx);\n\n        smp_rmb();\n\n        new_idx = old_idx + rec_len;\n\n\n\n        if (new_idx - writeout_idx > TRACE_BUF_LEN) {\n\n            /* Trace Buffer Full, Event dropped ! */\n\n            g_atomic_int_inc(&dropped_events);\n\n            return -ENOSPC;\n\n        }\n\n    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));\n\n\n\n    idx = old_idx % TRACE_BUF_LEN;\n\n\n\n    rec_off = idx;\n\n    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));\n\n    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));\n\n    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));\n\n    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));\n\n\n\n    rec->tbuf_idx = idx;\n\n    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;\n\n    return 0;\n\n}\n", "idx": 18477, "substitutes": {"rec": ["ic", "oc", "record", "data", "irc", "Rec", "ref", "comment", "track", "reg", "rc", "inc", "rel", "exc", "acc", "ctx", "mc", "bb", "abc", "resp", "enc", "exec", "ack", "re", "REC", "change", "pre", "disc", "ac", "con", "prev", "cl", "sync", "cur", "req", "c", "history", "Record", "xml", "ck", "doc", "cache", "win", "ec", "form", "co", "rem"], "event": ["instance", "issue", "record", "time", "data", "view", "x", "name", "image", " record", "attribute", " exception", "exc", "document", "type", "package", "ception", "index", "date", "object", "Event", "ce", " Event", "ev", "id", "received", "handler", "update", "xml", "vent", "address", "events", "resource", "error", "row", "ace", "message", "command", "value", "source", "input"], "datasize": ["datalsize", "datacsize", "datASIZE", " datasIZE", "datatsite", "datasizing", " datacsize", "datasiz", "datacize", " datacize", "datasesize", "datarssize", "datalsiz", "datarsite", "datasesizes", "datasizes", "datasIZE", " datasizes", " datasiz", "datacite", "datatssize", "datacizing", " datacite", "datalsizes", " datasizing", "datASizes", "datasesIZE", "datatsizing", " datASizes", "datassize", " datASIZE", "datalsIZE", " datacizing", "datarsizing", "datatsize", "datarsize", "datasite", "datASize", " datASiz", "datASiz", " datassize", " datASize", " datasite", "datasesiz"], "idx": ["idxc", "indxc", "Idc", "inX", "idexc", "idX", "idxp", " idxc", "Idz", "indX", "idz", "inxc", "idex", "idc", "IDf", "sidX", "idec", " idc", "Idxp", " idz", "Idf", "Idx", "sidxc", "idf", "inx", "sidxs", " idX", "Idxs", "IDz", "IdX", "IDx", "sidx", "IDxc", "inxs", "ideX", " idxp", "indxp", "indx", "idxs", "Idxc", " idxs", " idf"], "rec_off": ["rec_len", " rec_offer", " rec_wo", "RECdover", "recPover", "rec2offs", "rec___offs", " rec_offs", "rec_num", "rec8offer", "rec__off", "rec_offset", "rec_OFF", "Rec_offer", "recfend", " rec_oa", "rec_online", "rec_end", "rec8off", "recFoffs", "rec8offs", "recfoffer", "record_on", "REC_offer", "rec__OFF", "Rec_on", "recdoffer", "recdOff", "receroffs", "Rec_off", "rec_offer", "receronline", "Rec_len", "rec8offset", "rec_none", "rec2len", "record_offs", "rec_output", " rec_end", "Rec_OFF", "rec8Off", "rec___num", " rec_len", "rec2off", "rec_on", "rec8len", "rec__len", "REC_over", "Rec_none", " rec_num", "RECdoff", "record_off", "recdover", "REC_Off", "RECdoffer", "recdoff", "recFoutput", "recFon", "record_len", "rec___off", "recfoff", "rec8on", "rec_oa", "recPoffer", "rec2OFF", "Rec_online", "receroff", " rec_online", "record_OFF", "RECdOff", "REC_off", "recfonline", "Rec_Off", "rec___oa", "rec_over", "recFoff", "recPOff", "record_output", "rec_offs", "rec_wo", "recPoff", "Rec_offset", "Rec_offs", "recernone", "rec__offs", "rec_Off"], "old_idx": ["old_itc", "old_idex", "old_idg", "old_idz", "old_endxs", "old_idux", "old_videx", "old_vidxc", "old_idn", "old_indy", "old_idxx", "old_idexx", "old_ridx", "old_Idux", "old_idy", "old_idc", "old_iden", "old_endg", "old_Idz", "old_vidxi", "old_vidz", "old_Idx", "old_itex", "old_idexe", "old_itg", "old_index", "old_ridxx", "old_idxi", "old_endc", "old_indxe", "old_vidx", "old_Idxc", "old_indxx", "old_indx", "old_vidy", "old_ridn", "old_ridz", "old_indxs", "old_indg", "old_vidxx", "old_idxc", "old_itexc", "old_itx", "old_idxe", "old_endx", "old_indc", "old_indn", "old_itxs", "old_idxs", "old_iteux", "old_itez", "old_indxi", "old_ridxc", "old_ridxe"], "new_idx": ["new_ipz", "new_idv", "new_aidn", "new_pidx", "new_aidx", "new_indv", "new_idX", "new_pidz", "new_intx", "new_intn", "new_indX", "new_Idy", "new_ipw", "new_ipy", "new_Idn", "new_idxc", "new_Idv", "new_inty", "new_Idw", "new_idpx", "new_IdX", "new_idw", "new_indz", "new_indx", "new_idn", "new_intpx", "new_pidy", "new_Idpx", "new_Idxc", "new_ipx", "new_Idx", "new_idz", "new_pidxc", "new_Idz", "new_idy", "new_aidy", "new_aidpx"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)\n\n{\n\n    CPU_DoubleU farg;\n\n    float32 f32;\n\n\n\n    farg.ll = arg;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg.d))) {\n\n        /* sNaN square root */\n\n        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n    }\n\n    f32 = float64_to_float32(farg.d, &env->fp_status);\n\n    farg.d = float32_to_float64(f32, &env->fp_status);\n\n\n\n    return farg.ll;\n\n}\n", "idx": 2594, "substitutes": {"env": ["eu", "oa", "np", "server", "emb", "ctx", "ext", "cal", "fen", "ass", "conn", "context", "txt", "queue", "her", "environment", "global", "pg", "ea", "eng", "enc", "eni", "proc", "code", "args", "erv", "ah", "info", "eff", "err", "ep", "config", "impl", "ec", "exc", "Environment", "anne", "cv", "e", "loader", "conf", "gui", "viron", "chal", "obj", "exec", "en", "v", "ev", "site", "manager", "engine", "qt", "que", "console", "energy", "db"], "arg": ["argument", "call", "ig", "target", "inter", "bit", "lb", "weight", "cat", "Arg", "ag", "grad", "op", "arr", "num", "enc", "param", "g", "par", "arp", "mac", "args", "config", "result", "ang", "p", "arc", "len", "ax", "flag", "ar", "attr", "ray", "amp", "v", "pc", "var", "val", "load", "all", "ace", "option"], "farg": [" ffrg", "larm", "fcarc", " farm", "infflag", "larg", " frg", " Falloc", "fcarg", "larp", "famp", "elfarg", "tg", "fflag", "farp", "ifamp", " ffalloc", "elfargs", " ffargs", "dfreg", "ufarp", "ifarg", "refarg", "ufreg", "elfflag", " fargs", "fwarc", "fcg", "farc", "refarc", "larc", " freg", "infarc", "ufarg", " Fargs", "refamp", " Farg", "refarm", " ffarg", " farc", "ifarc", "fwarg", "fwamp", "infargs", "frg", "fg", "targ", " falloc", "tload", "infarg", "tarc", "fload", "ifarp", " Frg", "fargs", "freg", "ufargs", "fcload", "refarp", "falloc", " fg", "dfarg", "dfarp", " farp", " fflag", "dfargs", "fwarp", " fload", "elfarc", "farm"], "f32": ["utf34", "c31", "f31", "tf31", "c34", "utf64", "tf34", "tf32", "f64", "sf32", "f16", "sf34", "sf64", "utf32", "sf16", "c32", "utf31", "c16", "tf16", " f34", " f31", " f16", "f34", " f64", "sf31"]}}
{"project": "qemu", "commit_id": "7c24384b3b984f0256ba10eb26d877ec28985019", "target": 1, "func": "static int64_t nfs_client_open(NFSClient *client, const char *filename,\n\n                               int flags, Error **errp)\n\n{\n\n    int ret = -EINVAL, i;\n\n    struct stat st;\n\n    URI *uri;\n\n    QueryParams *qp = NULL;\n\n    char *file = NULL, *strp = NULL;\n\n\n\n    uri = uri_parse(filename);\n\n    if (!uri) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    if (!uri->server) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    strp = strrchr(uri->path, '/');\n\n    if (strp == NULL) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    file = g_strdup(strp);\n\n    *strp = 0;\n\n\n\n    client->context = nfs_init_context();\n\n    if (client->context == NULL) {\n\n        error_setg(errp, \"Failed to init NFS context\");\n\n        goto fail;\n\n    }\n\n\n\n    qp = query_params_parse(uri->query);\n\n    for (i = 0; i < qp->n; i++) {\n\n        if (!qp->p[i].value) {\n\n            error_setg(errp, \"Value for NFS parameter expected: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n        if (!strncmp(qp->p[i].name, \"uid\", 3)) {\n\n            nfs_set_uid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"gid\", 3)) {\n\n            nfs_set_gid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"tcp-syncnt\", 10)) {\n\n            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));\n\n        } else {\n\n            error_setg(errp, \"Unknown NFS parameter name: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_mount(client->context, uri->server, uri->path);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to mount nfs share: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    if (flags & O_CREAT) {\n\n        ret = nfs_creat(client->context, file, 0600, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to create file: %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    } else {\n\n        ret = nfs_open(client->context, file, flags, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to open file : %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_fstat(client->context, client->fh, &st);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to fstat file: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);\n\n    client->has_zero_init = S_ISREG(st.st_mode);\n\n    goto out;\n\nfail:\n\n    nfs_client_close(client);\n\nout:\n\n    if (qp) {\n\n        query_params_free(qp);\n\n    }\n\n    uri_free(uri);\n\n    g_free(file);\n\n    return ret;\n\n}\n", "idx": 9434, "substitutes": {"client": ["session", "context", "prefix", "chrome", "worker", "conn", "open", "http", "consumer", "public", "container", "project", "con", "Client", "c", "service", "config", "server", "reader", "util", "cli", "package", "request", "local", "private", "wrapper", "queue", "gui", "app", "cod", "socket", "manager", "entry", "host", "call", "child", "https", "ce", "current", "connection", "remote", "event", "google", "ctx", "user", "custom", "storage", "get", "plugin", "command", "handler", "single", "api", "image", "cache", "cell", "ssl"], "filename": ["fil", "il", "source", "prefix", "password", "fd", "path", "files", "tty", "buf", "username", "utf", "fp", "txt", "title", "Filename", "f", "binary", "bf", "database", "slice", "folder", "name", "content", "connection", "phrase", "loader", "buffer", "dll", "acl", "fn", "url", "directory", "which", "rl", "kl"], "flags": ["flag", "features", "stats", "files", "ops", "s", "mask", "util", "status", "bits", "args", "lag", "errors", "mode", " flag", "FLAG", "Flags", "format", "fun", " bits", " Flags", "rep", "bytes", "bit", "ips", "options", "fs", "gen"], "errp": ["erp", "armfp", "rarpa", "rrr", " errP", "rarpo", "ferlp", "lerfp", "finderpc", "errr", " errlp", "acerp", "arrsp", "acerpr", "armpr", "ferp", "erP", "err", "erpc", "lerlp", "ferpc", "erfp", "erpo", "rarsp", "errpr", "argpa", "finderping", "asterlp", "errpre", "asterpr", "erpr", "armpo", "argp", "arrpr", "errlp", "errpi", "errorpa", "armsp", " errr", "armp", "ferpi", "finderfp", "errorfp", "arrpo", "ferfp", "errorp", "errping", "arrfp", "rrpre", "errsp", "errP", "errpc", "argb", "errpo", "ferpr", "yrpe", "acerpi", "errb", "errfp", "yrpa", "rarp", "errorping", "errorpe", "errpe", "erping", "erpre", "argpe", " errpc", "acerlp", "errorpc", "rrp", "armpa", "finderp", " errpre", "errpa", "arrpa", "yrb", "asterpi", "yrp", "arrp", "lerpc", " errfp", "lerp", "rrP", "asterp", "errorb"], "i": ["l", "is", "m", "t", "x", "z", "iv", "ie", "v", "phi", "abi", "err", "ii", "init", "type", "ori", "ri", "fi", "oi", "gu", "si", "n", "id", "xi", "b", "c", "e", "mu", "f", "j", "index", "slice", "jit", "r", "bi", "u", "li", "ni", "lc", "hi", "di", "g", "source", "adi", "d", "status", "cli", "yi", "eni", "dr", "ai", "o", "gi", "chi", "pi", "I", "ret", "result", "iu", "ui", "start", "in", "info", "ini", "ji", "line", "p", "ix", "isi", "multi", "ti", "mi", "inner", "qi", "idi", "ip", "ci", "io", "y"], "st": ["ld", "l", "std", "str", "est", "nt", "no", "istic", "x", " sc", "ct", "stream", "obj", "ost", "f", "code", "v", "r", "ist", "sth", "et", "ST", "func", "fi", "fe", "sc"], "uri": ["ui", "archive", "location", "term", "di", " URI", "si", "source", "adi", "processor", "http", "path", "iri", "ini", "service", "metadata", "config", "server", "username", "reader", "cli", "package", "component", "ir", "gui", "eni", "parser", "manager", "binary", "unit", "resource", "multi", "slice", "umi", "route", "gi", "connection", "query", "folder", "doi", "mi", "address", "qi", "document", "pi", "storage", "git", "plugin", "uni", "handler", "api", "ci", "url", "io", "ori", "attribute", "directory", "ri", "URI", "transfer", "database"], "qp": ["idp", "ppP", "qP", "sqn", "sqP", "qn", "sqnp", "qop", "qq", "qpart", "reqop", "reqp", "questv", "sqf", "queste", "sqi", "idpc", "QP", "questpoint", "pgb", "qz", "sqpoint", "requpre", " qtp", "sqe", "qpre", "qupart", "requh", "qpc", "sqv", "sqpre", "sqtp", "qtp", "ql", "Qr", "que", "requp", "quc", "requl", "sqb", " qf", "sqm", "pgpr", "sqpart", "quq", "questf", " qr", "Qp", "qutp", "qunp", "qupc", "qufp", "sqop", "sqfp", "qc", "questh", "sqr", "reql", "idv", "sqz", "sqc", "questz", " qfp", "sqpr", "sql", "Qps", "qh", " qs", "Qi", "questp", "qpoint", " qm", "qul", "ppi", "sqh", "sqps", "qupre", "qfp", " qc", "quf", "qupoint", "sqp", "qnp", "qup", "ppp", "questpart", "Qs", "qps", "qupr", "qr", "qum", " qn", "Qc", "pgp", "sqq", "qs", "qun", "qf", "quz", "sqs", " qb", "ppps", "quop", "qv", "questl", "sqpc", "qub", "qe", "qpr", "pgh", "qi", "qm", "reqnp", "quh", "quv", "questq", "qb", "idh"], "file": ["parent", "base", "il", "flag", "comment", "ile", "source", "info", "http", "files", "path", "data", "line", "rule", "local", "queue", "feed", "f", "unit", "dir", "resource", "format", "folder", "name", "live", "pipe", "fat", "current", "pic", "full", "part", "offset", "get", "root", "File", "ignore", "image", "cache", "io", "buffer"], "strp": ["drpc", "irP", "drpe", "irp", "strpi", "nerpa", "drlp", "strpe", "Strpr", "strpatch", "strib", "strfp", "rrpatch", "nerp", "rrpr", "yrlp", "nerP", "Strb", "Strn", "strpr", "trn", "stripc", "strP", "arrpc", " strpe", "Strpc", "yrpc", "Strfp", "strb", "strip", "Strpe", "strpc", "arrpe", " strpatch", "StrP", "strpa", "rrp", "drp", "strifp", "Strp", "Strpi", " strn", "yrp", "trP", "arrp", " strpr", "trpe", " strpc", "Strpa", "strlp", "trp", " strb", "yrpe", "arrlp", "rrP", "irpi", "Strpatch", " strP", "nerpi", "irpa", "strn", " strfp"]}}
{"project": "qemu", "commit_id": "01cd90b641e1aed40cf13a577e6a737af94d55e7", "target": 0, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}\n", "idx": 19490, "substitutes": {"xendev": ["wxendov", "xndev", "exenderv", "xendown", "wxendedov", "zenddev", "exendev", "genddiv", "zendedev", "zendee", "gendedev", "xendedove", "gendev", "xendep", "xEndep", "xnderv", "xtendev", "xpendev", "xtentev", "xendee", "genderv", "zendedee", "exendedruction", "xndeva", "xnddev", "xentev", "xtendov", "xndown", "exndev", "xendsev", "xedgediv", " xendove", "zendedov", "wxenderv", "zendev", "xenderv", "xstarterv", "xendedev", "exendedep", "wxendedev", "zendov", "exendown", "xentown", "xtentep", "wxendedeva", "exendedev", "xtendep", "xndov", " xendedev", "xtentov", "xEnderv", "xentee", "xendeddev", "xendederv", "xendsep", " xenddev", "xendedov", "exnderv", "xenterv", "wxendev", "xendedruction", "xendedown", "xendedep", "exnddev", "xstartov", " xenderv", "exendep", "xentov", "xedgeerv", "wxendederv", " xendederv", "gendederv", "xEndev", "xenddev", "xendeddiv", "xendedeva", "xendedee", "xedgeov", "exenddev", "xendov", "xendeva", "xenddiv", "exendederv", "xedgeev", "xpendov", "xstartev", "gendeddiv", "xtenderv", "gendedov", "xendserv", " xendov", "gendov", "exndown", "xpenderv", "wxendeva", "xendruction", " xendedov", "xndee", "xentove", "xendsruction", "xstartdiv", "xpendeva", "xtenterv", "xentdev", "xentep", "xEndruction", "zendeddev", "exendruction", " xendown", "xendove", " xendeddev"], "i": ["uri", "bi", "ji", "x", "qi", "ai", "phi", "hi", "gui", "ie", "d", "pi", "id", "cli", "ni", "xi", "p", "\u0438", "interface", "it", "fi", "source", "gi", "m", "init", "j", "ix", "ini", "iu", "I", "count", "o", "v", "lc", "si", "ri", "field", "a", "iv", "ti", "f", "r", "mi", "ii", "di", "ind", "multi", "zi", "l", "yi", "ci", "abi", "c", "line", "b", "eni", "reply", "mu", "t", "info", "io", "n", "g", "z", "ij", "slice", "index", "ip", "adi", "idi", "ui", "isin", "e", "isi", "api", "inner", "y", "li", "u"], "xen_9pdev": ["xen_ninepadv", "xen_09pengine", "xen_9pfail", "xen_ninepmode", "xen_9badv", "xen_9fpdev", "xen_9lpdem", "xen_9fapp", "xen_9peadv", "xen_9pedef", "xen_10papp", "xen_9cdev", "xen_9fdevice", "xen_9pdevice", "xen_9psvalid", "xen_9fadv", "xen_9fpvalid", "xen_9pidevice", "xen_9cpconf", "xen_8ddevice", "xen_9pudev", "xen_ninedrad", "xen_09fdef", "xen_nineddev", "xen_ninefdev", "xen_9qdevice", "xen_9psde", "xen_9padv", "xen_10pcdevice", "xen_9cpdev", "xen_9cde", "xen_9fcomment", "xen_9pivalid", "xen_109pdev", "xen_09phome", "xen_9fconf", "xen_9psconf", "xen_09fdev", "xen_9ldevice", "xen_10pdev", "xen_ninepcdevice", "xen_9phome", "xen_9pcde", "xen_10pdevice", "xen_9dod", "xen_9pediv", "xen_09fdem", "xen_9piconf", "xen_9vengine", "xen_9cprad", "xen_9bdev", "xen_ninepconf", "xen_9dadv", "xen_09pdem", "xen_09pde", "xen_9frad", "xen_9pvalid", "xen_ninefdevice", "xen_09ffail", "xen_19pcd", "xen_09pdef", "xen_109prad", "xen_9fde", "xen_9pedev", "xen_nineddevice", "xen_9ppdevice", "xen_9prad", "xen_9pdem", "xen_975pdev", "xen_9pde", "xen_ninepcmode", "xen_8pconf", "xen_09fadv", "xen_9fdc", "xen_9fmode", "xen_9lconf", "xen_09fengine", "xen_9lrad", "xen_09pev", "xen_9psdebug", "xen_9pmode", "xen_09pdc", "xen_9fdef", "xen_9puadv", "xen_09pfail", "xen_9drad", "xen_9qdev", "xen_09fdi", "xen_9pdiv", "xen_9pengine", "xen_9ppod", "xen_9bpdev", "xen_9ppdev", "xen_9fod", "xen_9bpcd", "xen_ninepdiv", "xen_9pcapp", "xen_9fvalid", "xen_8ddev", "xen_9fdi", "xen_8pod", "xen_9lpengine", "xen_19pdev", "xen_9pufail", "xen_9pev", "xen_9qdi", "xen_9pconf", "xen_19pvalid", "xen_9pcdev", "xen_9vdev", "xen_19bpvalid", "xen_nineprad", "xen_109pconf", "xen_9ppfail", "xen_9picomment", "xen_ninebdev", "xen_8dod", "xen_09fdc", "xen_9pdi", "xen_9pcmode", "xen_9cdi", "xen_09fhome", "xen_9ddebug", "xen_9pirad", "xen_19bpcd", "xen_109ddev", "xen_9ddem", "xen_ninepdef", "xen_9vdem", "xen_975fpdev", "xen_9papp", "xen_9fdiv", "xen_ninecdev", "xen_10pcapp", "xen_19bpdev", "xen_9pcdevice", "xen_9qde", "xen_9ffail", "xen_9bdiv", "xen_9ppev", "xen_ninepdev", "xen_9fev", "xen_975pcomment", "xen_09fdevice", "xen_9pod", "xen_9ldev", "xen_8drad", "xen_975pvalid", "xen_9bpvalid", "xen_9ddef", "xen_9fengine", "xen_9dhome", "xen_ninepdebug", "xen_9pdebug", "xen_9npdev", "xen_09pcd", "xen_9cdevice", "xen_ninecconf", "xen_9nprad", "xen_9fdem", "xen_109dconf", "xen_9prdevice", "xen_09fcd", "xen_09fev", "xen_9pscd", "xen_ninecde", "xen_9dapp", "xen_09padv", "xen_9qdef", "xen_9psdev", "xen_9lpdevice", "xen_975fpcomment", "xen_ninepcdev", "xen_ninebadv", "xen_8pdevice", "xen_9fhome", "xen_9dconf", "xen_ninepdevice", "xen_8pdev", "xen_8dconf", "xen_ninepde", "xen_9pehome", "xen_09pdi", "xen_9pude", "xen_9pdef", "xen_9ddc", "xen_9puev", "xen_9dde", "xen_9lpmode", "xen_09fde", "xen_ninefdef", "xen_09pdev", "xen_9npdevice", "xen_975fpvalid", "xen_ninecdebug", "xen_9cconf", "xen_09pdevice", "xen_8prad", "xen_9fcd", "xen_9prdev", "xen_9pidev", "xen_9pdc", "xen_9lpdev", "xen_109ddevice", "xen_109pdevice", "xen_9cdebug", "xen_9dcd", "xen_9pcd", "xen_9pcomment", "xen_9fdev", "xen_9ddev", "xen_9lpdc", "xen_9ddevice", "xen_9fpcomment", "xen_ninebdiv", "xen_10pcdev", "xen_9cpdevice", "xen_9prcd", "xen_109drad", "xen_9lpdef"], "s": ["spec", "m", "session", "stats", "t", "f", "settings", "services", "r", "service", "n", "g", "sa", "fs", "o", "d", "w", "e", "ssl", "sync", "v", "c", "p", "S", "b", "server", "states", "params"], "fsdev": ["wsconf", "wsdev", "wsdef", "fsdef", "nsDev", "fsDev", "nsdev", "dsconf", "dsdef", "wsDev", "dsDev", "fsconf", "dsdev", "nsdef", "nsconf"], "str": ["fr", "txt", "br", "code", "tr", "text", "rs", "obj", "err", "name", "ctr", "f", "sp", "expr", "ct", "r", "hr", "try", "sl", "z", "ocr", "pass", "var", "stri", "ss", "orig", "ext", "kr", "STR", "arr", "sta", "exec", "enc", "dict", "read", "style", "st", "sr", "dr", "bl", "e", "sc", "cr", "cl", "cur", "c", "req", "temp", "Str", "doc", "wr", "strike", "pr", "h", "er", "iter", "list", "inner", "input"], "ring_order": ["ringparray", " ring_info", "ringpoffset", " ring_array", "ring_array", "ring__order", "ring__info", "ring__array", "ringporder", "ring_offset", "ring_info", "ringpinfo", "ring__offset", " ring_offset"]}}
{"project": "qemu", "commit_id": "f9749f28b78be36471d3d0f5d4b6eed030f8942e", "target": 0, "func": "static int coroutine_fn is_allocated_base(BlockDriverState *top,\n\n                                          BlockDriverState *base,\n\n                                          int64_t sector_num,\n\n                                          int nb_sectors, int *pnum)\n\n{\n\n    BlockDriverState *intermediate;\n\n    int ret, n;\n\n\n\n    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);\n\n    if (ret) {\n\n        *pnum = n;\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * Is the unallocated chunk [sector_num, n] also\n\n     * unallocated between base and top?\n\n     */\n\n    intermediate = top->backing_hd;\n\n\n\n    while (intermediate != base) {\n\n        int pnum_inter;\n\n\n\n        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,\n\n                                   &pnum_inter);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            *pnum = pnum_inter;\n\n            return 0;\n\n        }\n\n\n\n        /*\n\n         * [sector_num, nb_sectors] is unallocated on top but intermediate\n\n         * might have\n\n         *\n\n         * [sector_num+x, nr_sectors] allocated.\n\n         */\n\n        if (n > pnum_inter) {\n\n            n = pnum_inter;\n\n        }\n\n\n\n        intermediate = intermediate->backing_hd;\n\n    }\n\n\n\n    *pnum = n;\n\n    return 1;\n\n}\n", "idx": 7762, "substitutes": {"top": ["master", "as", "block", "http", "parent", "prev", "best", "pre", "up", "bottom", "support", "null", "job", "client", "state", "TOP", "Top", "space", "upper", "initial", "super", "part", "high", "above", "file", "bot", "path", "p", "root", "tops", "start", "higher", "primary", "new", "central", "front", "site", "current", "next", "first", "prefix"], "base": ["bas", "area", "layer", "stable", "extra", "copy", "local", "change", "http", "parent", "ite", "pre", "b", "stack", "bottom", "status", "fake", "state", "init", "part", "basic", "full", "bot", "bare", "source", "old", "based", "root", "Base", "start", "core", "inner", "site", "cache", "front", "max", "super", "prefix"], "sector_num": [" sector_number", "sector_no", "section_no", " sector_sum", " sector_ident", " sector_name", "sector_name", " sector_prefix", "section_num", "sector_four", "sector_ident", "sector_prefix", "section_number", "sector_sum", "sector_number", "section_four"], "nb_sectors": ["nb_psevers", "nb_specsec", "nb_specivers", "nb_tesections", "nb_sesections", "nb_specgments", "nb_spevers", "nb_desrets", "nb_spegments", "nb_tegments", "nb_tections", "nb_vesec", "nb_gectors", "nb_spectors", "nb_sperets", "nb_vegments", "nb_specctors", "nb_seivers", "nb_vections", "nb_gegments", "nb_desvers", "nb_sections", "nb_psectors", "nb_gections", "nb_spesec", "nb_tectors", "nb_segments", "nb_desgments", "nb_serets", "nb_veivers", "nb_severs", "nb_speivers", "nb_vesections", "nb_desctors", "nb_psegments", "nb_pserets", "nb_vectors", "nb_gesections", "nb_sesec"], "pnum": ["rnumption", "panman", "pcumb", "pinum", "pnuman", "snumm", "pinumi", "pinuman", "pnumm", "pnman", "panenum", "rnenum", "panuc", "pronenum", "pronman", "pronum", "pnumi", "pnumb", "pinumer", "snumer", "panumi", "pnumption", "atanum", "pronumb", "pinumption", "pnuc", "pinumb", "pnenum", "snum", "rnman", "pcuman", "panumer", "snuc", "atanenum", "pnumer", "panumb", "atanumm", "rnum", "pinuc", "panum", "pcumption", "pcum", "snumb", "snenum", "pronumm", "rnuman", "atanumb", "snumi", "rnumb"], "intermediate": ["extference", "internmedi", "interfinal", "INTERiguous", "INTERior", "transference", "imfinal", "indruction", "internmediate", " interior", "transmediate", "investior", "interplementation", "interporal", "itermedi", "intmedi", "instmediate", "INTERmediately", "prommediate", "adparent", "overior", "implementation", "adior", "exference", " interfinal", "intermediately", "INTERruction", "extplementation", "indmediate", "intersvious", "explementation", " interplementation", "interiguous", "investmediate", "intermedi", "transplementation", "indporal", "intvious", "instiguous", "intior", "internparent", "iterior", "interruction", "INTERplementation", "investmediately", "admedi", "INTERfinal", "promporal", "investiguous", "itervious", "instior", "indior", "intervious", "promior", "imior", "intmediate", "extmediate", "promruction", "overparent", "INTERmediate", "admediate", "itermediate", "instmediately", "exior", "transior", "interference", "interparent", "interior", "overmedi", "immediate", "intersior", "internior", "intersmedi", "extior", "INTERporal", "exmediate", "overmediate", "intersmediate"], "ret": ["flag", "reset", "iter", "tr", "real", "status", "nm", "arg", "active", "match", "code", "len", "det", "error", "RET", "nat", "pass", "err", "rl", "rev", "ft", "fun", "id", "al", "nt", "value", "val", "rf", "art", "mn", "ne", "back", "nl", "reg", "rt", "alt", "rot", "rc", "bit", "cat", "repl", "num", "fin", "ext", "att", "obj", "py", "out", "t", "Ret", "fab", "run", "ner", "re", "gt", "ref", "rets", "mem", "pre", "inter", "reply", "res", "init", "ry", "def", "part", "fn", "result", "req", "opt", "bf", "br", "success", "hard"], "n": ["rn", "nl", "o", "nor", "na", "v", "nn", "dn", "s", "nt", "ni", "x", "b", "nc", "i", "sn", "non", "m", "l", "num", "f", "ng", "N", "ns", "mn", "nm", "j", "d", "nr", "net", "number", "len", "e", "pn", "en", "out", "t", "nat", "nb", "p", "ne", "network", "un", "none", "node", "c", "new", "y", "cn", "adj", "no", "r", "conn"], "pnum_inter": ["pnUM_cur", "pnum_iter", "pnum_pre", "pnum_INTER", "pnuma_inf", "pnumer_cur", "pnum_inf", "pnum_cur", "pnUM_inter", "pnum_pointer", "pnumer_inter", "pnumer_ext", "pnumm_INTER", "pnum_ext", "pnumm_ar", "pnum_inc", "pnuma_pointer", "pnum_rev", "pnumm_inter", "pnum_ar", "pnum__inter", "pnuma_rev", "pnumm_Inter", "pnuma_inter", "pnum__pre", "pnum_Inter", "pnum__cur", "pnUM_inc", "pnum_ref", "pnum__inc", "pnuma_ext", "pnumer_iter", "pnUM_pre", "pnuma_ref"]}}
{"project": "qemu", "commit_id": "660edd4eda903e32811a4929d1434cceda3284aa", "target": 1, "func": "static int connect_namedsocket(const char *path)\n\n{\n\n    int sockfd, size;\n\n    struct sockaddr_un helper;\n\n\n\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n    if (sockfd < 0) {\n\n        fprintf(stderr, \"socket %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    strcpy(helper.sun_path, path);\n\n    helper.sun_family = AF_UNIX;\n\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n\n        fprintf(stderr, \"socket error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    /* remove the socket for security reasons */\n\n    unlink(path);\n\n    return sockfd;\n\n}", "idx": 5508, "substitutes": {"path": ["base", "address", "r", "name", "id", "open", "method", "parent", "entry", "ex", "data", "home", "enc", "pattern", "loc", "key", "url", "Path", "dir", "code", "uri", "w", "error", "here", "file", "port", "binary", "pass", "ith", "loader", "filename", "work", "p", "context", "temp", "root", "PATH", "ath", "pointer", "c", "location", "handler", "core", "text", "cache", "host", "conn", "prefix"], "sockfd": ["sockfn", "sesockFD", "sesinkfun", "dsockaddr", " swinfn", "socksaddr", "sinkfn", "sockaddr", "sigstream", "sockf", "sinkaddr", "sinkf", "sigfd", " socksaddr", " sockFD", "sockfat", "sbootFD", "swinfd", " swinFD", "sigbuf", " socksf", " socksFD", "scpaddr", "sourceFD", "dsocksFD", "dockstream", "dockfd", "sockerfat", "sesinkFD", "sockeraddr", "socksfd", "dsocksfd", "sckfd", "sockbuf", "sockerFD", "sourcef", " sockfn", "dsocksaddr", " sockf", "scpfat", "dinkstream", "sesinkaddr", "scpFD", "dsockfat", "sockstream", "sesinkfd", " sockfun", "dsocksfat", "dsockFD", "sigFD", "dinkfd", "dinkFD", "sckaddr", "sinkFD", "sbootfd", "sinkfd", "sinkbuf", "sesockaddr", "sinkfun", "sesockfun", "sockFD", "sockfun", "sourceaddr", " swinfd", "swinfn", "sbootfun", " swinfun", "swinFD", "scpfd", "dsockfd", "dockbuf", "sbootfn", "sockerfd", "sourcefd", "dockFD", "socksstream", "socksfat", "dinkbuf", " sockaddr", "sckfun", "sckFD", "socksf", "socksfun", "socksFD", "socksbuf", "swinfun", "sesockfd", " socksfd", "sinkstream"], "size": ["address", "name", "time", "SIZE", "large", "sec", "count", "complete", "fee", "send", "security", "x", "sum", "si", "sync", "sn", "loc", "unit", "speed", "capacity", "content", "offset", "weight", "length", "small", "Size", "fe", "code", "len", "storage", "esc", "sized", "empty", "ey", "scale", "ice", "c", "g", "iz", "ize", "max"], "helper": ["thelber", "Helter", "haped", "schepler", "hport", "perler", "helped", "helpers", " helpers", "waper", " helter", "harler", "halpers", "happer", "haber", "hapers", "hpper", "harper", "hyper", "halper", "Helpert", "wamer", "thelper", "thelped", "hypper", "wapler", "helter", "scheler", "helport", "impropers", "scheper", "perpler", "haport", "haller", "harter", "helber", " heller", "theller", "impropper", " helperpert", "helpert", " helperpper", "helmer", "improper", "helpher", "haler", "hyter", " Helpher", "permer", " helperper", "hapher", " helperter", "perper", "waler", "hypert", "harport", "helpler", " Helpper", "harpers", "harped", "helpper", "Helpper", "hper", "harber", " Helpers", "impropher", "halter", "harpper", "haper", "heller", " Helper", "schemer", "Helper"]}}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),\n\n        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),\n\n        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),\n\n        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),\n\n        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),\n\n    };\n\n    static uint32_t prev_state;\n\n\n\n    if (prev_state != state) {\n\n        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);\n\n        prev_state = state;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,\n\n                             real_screen->w);\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,\n\n                             real_screen->h);\n\n    } else {\n\n        if (guest_cursor) {\n\n            x -= guest_x;\n\n            y -= guest_y;\n\n            guest_x += x;\n\n            guest_y += y;\n\n            dx = x;\n\n            dy = y;\n\n        }\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 794, "substitutes": {"dx": ["yx", "dn", "da", "ud", "dd", "dh", "data", "zx", "loc", "d", "xd", "distance", "px", "xy", "max", "ady", "push", "xs", "dt", "ds", "z", "xp", "xx", "dc", "step", "down", "pad", "phy", "w", "front", "patch", "fix", "ww", "fx", "wd", "prefix", "ix", "rx", "DX", "depth", "view", "xxx", "start", "ex", "diff", "dist", "xi", "wx"], "dy": ["delay", "yi", "dn", "da", "dd", "ii", "dim", "zi", "data", "ui", "zy", "idy", "iy", "d", "di", "gy", "dl", "ry", "xy", "ny", "ty", "j", "i", "py", "ady", "yd", "sync", "direction", "z", "yy", "md", "ey", "dir", "ds", "lon", "down", "hi", "vy", "f", "b", "depth", "dist", "yer", "eddy", "wy", "diff", "db", "sy"], "x": ["name", "yx", "q", "image", "r", "d", "n", "px", "id", "xy", "i", "pos", "m", "X", "xs", "z", "index", "xx", "down", "h", "p", "l", "c", "w", "e", "hi", "xc", "ax", "height", "u", "en", "o", "v", "b", "ix", "rx", "t", "path", "xxx", "one", "ex", "xi"], "y": ["yi", "q", "ye", "yl", "ish", "yo", "zy", "iy", "d", "n", "type", "yan", "ry", "cy", "xy", "ny", "ya", "ty", "j", "i", "year", "py", "ady", "m", "ky", "z", "yy", "ey", "ch", "h", "l", "p", "w", "vy", "col", "yt", "o", "ay", "b", "t", "Y", "oy", "sky", "wy", "sy"], "state": ["version", "name", "key", "active", "area", "new", "d", "type", "STATE", "id", "scope", "parent", "seed", "j", "instance", "next", "State", "i", "update", "inner", "m", "none", "code", "sync", "event", "direction", "style", "err", "z", "index", "ch", "status", "st", "step", "down", "p", "e", "force", "size", "length", "f", "resource", "private", "self", "set", "value", "up", "range", "scale", "b", "ate", "error", "old", "rule", "notice", "val", "mode", "states", "part", "start", "in", "sy"], "bmap": ["cMap", "cmap", "bMAP", " bMAP", "cbmaps", "pmaps", "cmaps", "bMap", "bbmap", "bbMap", " bMap", "bmaps", "cMAP", "cbmap", "cbMap", "pmap", " bmaps", "cbMAP", "pMAP", "pMap", "bbmaps", "bbMAP"], "prev_state": ["keep_status", "keepfstate", "prev_State", "keep_state", " prev_connection", "keepfstatus", " prev_rule", "prev___states", "prev___state", "keep_call", "prevfscale", " prev_State", "prevPstatus", "prev_rule", "prev_scale", "prevPscale", "prevfcall", "prevfstate", "prev_connection", "prev___connection", "prev_call", "keep_scale", "prevPstate", " prev_config", "prevfstatus", " prev_states", "prev_status", "prevPcall", "prev_states", "prev_config", "keepfcall", "keepfscale"]}}
{"project": "qemu", "commit_id": "d3ac1a87b228bcd231d19acf1ebe9844b7639237", "target": 1, "func": "static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n    scsi_req_cancel(s->req);\n\n}\n", "idx": 4165, "substitutes": {"dev": ["pack", "pid", "ch", "o", "v", "md", "rad", "pu", "pro", " priv", "Dev", "progress", "device", "plug", "data", "io", "pipe", "ad", "info", "private", "de", "pi", "d", "pc", "conf", "ev", "def", "u", "dp", "priv", "push", "w", "cam", "port", " device", "pad", "pub", "req", "prop", "ver", "proc", "c", "api", "app", "r"], "p": ["cp", "P", "o", "bp", "v", "pp", "op", "i", "m", "f", "pi", "pc", "param", "np", "dp", "e", "w", "t", "n", "fp", "vp", "prop", "proc", "c", "g", "tp", "pb", "r"], "s": ["o", "sr", "v", "S", "spec", "sg", "session", "si", "sync", "sys", "ses", "m", "ns", "stats", "sl", "d", "service", "ss", "e", "sh", "an", "sb", "ops", "se", "ds", "n", "ts", "su", "sv", "sp", "fs", "c", "os", "g", "ssl", "sq", "sym", "es", "rs", "ps", "js"]}}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "void trace_init_file(const char *file)\n\n{\n\n#ifdef CONFIG_TRACE_SIMPLE\n\n    st_set_trace_file(file);\n\n#elif defined CONFIG_TRACE_LOG\n\n    /* If both the simple and the log backends are enabled, \"-trace file\"\n\n     * only applies to the simple backend; use \"-D\" for the log backend.\n\n     */\n\n    if (file) {\n\n        qemu_set_log_filename(file);\n\n    }\n\n#else\n\n    if (file) {\n\n        fprintf(stderr, \"error: -trace file=...: \"\n\n                \"option not supported by the selected tracing backends\\n\");\n\n        exit(1);\n\n    }\n\n#endif\n\n}\n", "idx": 22693, "substitutes": {"file": ["port", "place", "ile", "name", "class", "e", "txt", "binary", "config", "ban", "db", "message", "time", "key", "connection", "uri", "handler", "function", "f", "buffer", "path", "write", "model", "fp", "use", "entry", "socket", "data", "cache", "bug", "id", "code", "work", "le", "comment", "cli", "filename", "hide", "single", "source", "future", "line", "File", "call", "feed", "http", "folder", "resource", "files", "empty", "l", "base", "output", "command", "type", "letter"]}}
{"project": "qemu", "commit_id": "ab0997e0afdcb272fd04784a280b2df46b0c759f", "target": 1, "func": "static int qcow2_co_readv(BlockDriverState *bs, int64_t sector_num,\n\n                          int remaining_sectors, QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster, n1;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset = 0;\n\n    uint64_t bytes_done = 0;\n\n    QEMUIOVector hd_qiov;\n\n    uint8_t *cluster_data = NULL;\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        /* prepare next request */\n\n        cur_nr_sectors = remaining_sectors;\n\n        if (s->crypt_method) {\n\n            cur_nr_sectors = MIN(cur_nr_sectors,\n\n                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n        }\n\n\n\n        ret = qcow2_get_cluster_offset(bs, sector_num << 9,\n\n            &cur_nr_sectors, &cluster_offset);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (!cluster_offset) {\n\n\n\n            if (bs->backing_hd) {\n\n                /* read from the base image */\n\n                n1 = qcow2_backing_read1(bs->backing_hd, &hd_qiov,\n\n                    sector_num, cur_nr_sectors);\n\n                if (n1 > 0) {\n\n                    BLKDBG_EVENT(bs->file, BLKDBG_READ_BACKING_AIO);\n\n                    qemu_co_mutex_unlock(&s->lock);\n\n                    ret = bdrv_co_readv(bs->backing_hd, sector_num,\n\n                                        n1, &hd_qiov);\n\n                    qemu_co_mutex_lock(&s->lock);\n\n                    if (ret < 0) {\n\n                        goto fail;\n\n                    }\n\n                }\n\n            } else {\n\n                /* Note: in this case, no need to wait */\n\n                qemu_iovec_memset(&hd_qiov, 0, 512 * cur_nr_sectors);\n\n            }\n\n        } else if (cluster_offset & QCOW_OFLAG_COMPRESSED) {\n\n            /* add AIO support for compressed blocks ? */\n\n            ret = qcow2_decompress_cluster(bs, cluster_offset);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            qemu_iovec_from_buffer(&hd_qiov,\n\n                s->cluster_cache + index_in_cluster * 512,\n\n                512 * cur_nr_sectors);\n\n        } else {\n\n            if ((cluster_offset & 511) != 0) {\n\n                ret = -EIO;\n\n                goto fail;\n\n            }\n\n\n\n            if (s->crypt_method) {\n\n                /*\n\n                 * For encrypted images, read everything into a temporary\n\n                 * contiguous buffer on which the AES functions can work.\n\n                 */\n\n                if (!cluster_data) {\n\n                    cluster_data =\n\n                        g_malloc0(QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n                }\n\n\n\n                assert(cur_nr_sectors <=\n\n                    QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_add(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n\n\n            BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n            qemu_co_mutex_unlock(&s->lock);\n\n            ret = bdrv_co_readv(bs->file,\n\n                                (cluster_offset >> 9) + index_in_cluster,\n\n                                cur_nr_sectors, &hd_qiov);\n\n            qemu_co_mutex_lock(&s->lock);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n            if (s->crypt_method) {\n\n                qcow2_encrypt_sectors(s, sector_num,  cluster_data,\n\n                    cluster_data, cur_nr_sectors, 0, &s->aes_decrypt_key);\n\n                qemu_iovec_reset(&hd_qiov);\n\n                qemu_iovec_copy(&hd_qiov, qiov, bytes_done,\n\n                    cur_nr_sectors * 512);\n\n                qemu_iovec_from_buffer(&hd_qiov, cluster_data,\n\n                    512 * cur_nr_sectors);\n\n            }\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n\n\n\n    return ret;\n\n}", "idx": 24222, "substitutes": {"bs": ["ses", "sys", "iss", "ss", "b", "bas", "bis", "lbs", "ns", "lb", "bb", "vs", "base", "ab", "ds", "bh", "gb", "us", "bos", "bc", "BS", "bl", "outs", "ks", "ins", "bu", "css", "db", "gs", "ubs", "pb", "http", "eb", "bi", "os", "ros", "bes", "sb", "fb", "obs", "sa", "bid", "ls", "fs", "js", "bits", "bm", "bing", "bps", "cs", "banks"], "sector_num": ["sector_length", "sector_size", "section_offset", "sector0count", "shadow_name", "region_sum", "sector0num", "shadow_num", "shadowIDtun", "sector0sum", "section_no", "sectorpname", "sector_no", "sectorpsum", " sector_un", "sector_count", "sectorpoffset", " sector_offset", "sector_div", "shadowIDname", "sectorIDnum", "sectorIDname", "region_count", " sector_length", "sector_number", "shadow_div", "section_num", "sector_tun", "sector_un", "sector_sum", "shadowIDdiv", "region_num", "region_size", " sector_sum", "sector_offset", " sector_number", "sector0size", "sectorIDtun", "sectorpnum", "sectorIDdiv", "shadow_tun", "section_number", "shadowIDnum", " sector_name", "sector_name"], "remaining_sectors": ["remaining_teces", "remaining_pecs", "remaining_vectors", "remaining_bellers", "remaining_serctions", "remaining_serctor", "remaining_sector", "remaining_vector", "remaining_psectors", "remaining_vections", "remaining_sections", "remaining_bectors", "remaining_peces", "remaining_seapters", "remaining_psector", "remaining_secs", "remaining_pellers", "remaining_secapters", "remaining_serctors", "remaining_vecs", "remaining_peapters", "remaining_pectors", "remaining_vegments", "remaining_secces", "remaining_secgments", "remaining_tegments", "remaining_becs", "remaining_sergments", "remaining_psections", "remaining_segments", "remaining_seces", "remaining_pegments", "remaining_begments", "remaining_psegments", "remaining_sellers", "remaining_tectors", "remaining_teapters", "remaining_secctors", "remaining_vellers"], "qiov": ["sqrolet", " qiris", "sqoren", " qroxy", " qoyer", "quoren", "requoyer", "requiov", "sqiris", "quroxy", "sqiov", "qoren", "quveh", "qurolet", "questiov", "quiop", "quoyer", "qrolet", " qoby", "qoby", "requveh", "questiop", " qiop", "quiris", "requrolet", "qroxy", "qoyer", "qiop", "quoby", "questoby", "qiris", "quiov", " qoren", "qveh", " qveh", " qrolet", "questroxy"], "s": ["S", "rs", "ses", "sys", "args", "ss", "b", "server", "c", "p", "ns", "d", "ts", "storage", "sq", "ds", "conf", "ps", "sg", "state", "secondary", "states", "sync", "sis", "is", "su", "self", "e", "stats", "ess", "site", "gs", "o", "sets", "sie", "session", "spec", "l", "sym", "si", "aws", "os", "stat", "sb", "utils", "services", "sa", "ls", "f", "service", "js", "fs", "t", "v", "sl", "r", "settings", "ops", "parts", "ssl", "cs", "g"], "index_in_cluster": ["index_in_Cluration", "index_in_clructure", "index_in_hellayer", "index_in_Clayer", "index_in_ecructure", "index_in_secryption", "index_in_helluration", "index_in_clayer", "index_in_clryption", "index_in_Cluster", "index_in_hellusters", "index_in_secusters", "index_in_helluster", "index_in_secructure", "index_in_ecusters", "index_in_ecryption", "index_in_Clusters", "index_in_CLuster", "index_in_clusters", "index_in_CLayer", "index_in_CLuration", "index_in_secuster", "index_in_cluration", "index_in_Clructure", "index_in_CLusters", "index_in_ecuster", "index_in_Clryption"], "n1": ["p3", "N3", "N2", "N1", "c2", "N0", "n8", "unOnce", "none", "un8", "nn1", "n9", "c0", "ln1", " n91", "ln2", "p1", "sn2", " n3", "nnone", "snOnce", " n2", "sn1", "sn8", "N9", "nn8", "snone", "p2", "n3", "c1", "un1", "n91", "nnOnce", "n2", "nOnce", "N91", "c9", "unone", "sn9", "ln91", "n0", "sn0"], "ret": ["ref", "seq", "fin", "ft", "res", "info", "cat", "flag", "data", "test", "job", "rb", "success", "fail", "ct", "att", "opt", "def", " Ret", "end", "rep", "url", "rets", "iter", "bit", "mt", "det", "rev", "lit", "RET", "fit", "re", "art", "nt", "rc", "let", "pet", "arg", "Ret", "rt", "part", "ext", "sat", "j", "alt", "reg", "match", "result", "len", "val", "gt", "ut", "fun"], "cur_nr_sectors": ["cur_nr_peators", "cur_nr_secctors", "cur_nr_tections", "cur_nr_semvers", "cur_nr_selators", "cur_nr_cerets", "cur_nr_secctions", "cur_nr_SEgments", "cur_nr_psecs", "cur_nr_semcs", "cur_nr_sector", "cur_nr_perets", "cur_nr_seivers", "cur_nr_selgments", "cur_nr_severs", "cur_nr_psegments", "cur_nr_secgments", "cur_nr_pectors", "cur_nr_securities", "cur_nr_peurities", "cur_nr_pections", "cur_nr_secbits", "cur_nr_pexes", "cur_nr_seitors", "cur_nr_curctor", "cur_nr_psectors", "cur_nr_veitors", "cur_nr_serets", "cur_nr_pebits", "cur_nr_selctors", "cur_nr_seurities", "cur_nr_curgments", "cur_nr_semgments", "cur_nr_vevers", "cur_nr_pecs", "cur_nr_secs", "cur_nr_sections", "cur_nr_pegments", "cur_nr_curctors", "cur_nr_specs", "cur_nr_SEctors", "cur_nr_lectors", "cur_nr_spegments", "cur_nr_segments", "cur_nr_leivers", "cur_nr_secctor", "cur_nr_sexes", "cur_nr_sebits", "cur_nr_pevers", "cur_nr_seators", "cur_nr_selivers", "cur_nr_psections", "cur_nr_SEctions", "cur_nr_tectors", "cur_nr_cexes", "cur_nr_cectors", "cur_nr_cegments", "cur_nr_legments", "cur_nr_teurities", "cur_nr_semctors", "cur_nr_vecs", "cur_nr_vegments", "cur_nr_curbits", "cur_nr_peivers", "cur_nr_SEcs", "cur_nr_tegments", "cur_nr_pector", "cur_nr_peitors", "cur_nr_speitors", "cur_nr_spectors", "cur_nr_vectors", "cur_nr_leators"], "hd_qiov": ["hd_qanr", "hd_qqiov", "hd_ceiop", "hd_qaiop", "hd_sqiop", "hd_Qiov", "hd_miop", "hd_qoyer", "hd_cliov", "hd_sqilo", "hd_qiris", "hd_goyer", "hd_chiov", "hd_qnr", "hd_quicho", "hd_qqiop", "hd_sqirin", "hd_qaliv", "hd_ceiev", "hd_shoyer", "hd_qurolet", "hd_Qilo", "hd_chilo", "hd_quiev", "hd_clnr", "hd_chiris", "hd_qaicho", "hd_choyer", "hd_poyer", "hd_qilo", "hd_clicho", "hd_quiov", "hd_qairin", "hd_Qoyer", "hd_clliv", "hd_sqoyer", "hd_shilo", "hd_shiris", "hd_shiov", "hd_gliv", "hd_sqiov", "hd_quilo", "hd_qarolet", "hd_mirin", "hd_quoyer", "hd_quiop", "hd_qicho", "hd_pliv", "hd_qqilo", "hd_qirin", "hd_milo", "hd_grolet", "hd_prolet", "hd_piov", "hd_qiop", "hd_ceiov", "hd_miov", "hd_ceilo", "hd_Qiris", "hd_giov", "hd_qaiov", "hd_qqiev", "hd_qiev", "hd_qunr", "hd_qrolet", "hd_quliv", "hd_qliv", "hd_qaoyer", "hd_sqrolet", "hd_qailo"], "cluster_data": ["cluster_size", "clusteringsize", "clusters_size", "clusters_entry", "clusteringdata", "cluster_offset", "clusteringoffset", "clusters_data", "clusteringentry", "cluster_entry", "clusters_offset"]}}
{"project": "FFmpeg", "commit_id": "f028d4d1c393a13c66e828d45ba8412c0b4df6da", "target": 1, "func": "static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    KLVPacket klv;\n\n    int64_t essence_offset = 0;\n\n\n\n    mxf->last_forward_tell = INT64_MAX;\n\n\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, -14, SEEK_CUR);\n\n    mxf->fc = s;\n\n    mxf->run_in = avio_tell(s->pb);\n\n\n\n    while (!s->pb->eof_reached) {\n\n        const MXFMetadataReadTableEntry *metadata;\n\n\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n\n            /* EOF - seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        PRINT_KEY(s, \"read header\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n            if (!mxf->current_partition->essence_offset) {\n\n                compute_partition_essence_offset(s, mxf, &klv);\n\n            }\n\n\n\n            if (!essence_offset)\n\n                essence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    return mxf_parse_structural_metadata(mxf);\n\n}\n", "idx": 1878, "substitutes": {"s": ["sg", "js", "this", "sa", "qs", "n", "client", "g", "ses", "ls", "sf", "storage", "self", "us", "f", "sys", "sc", "types", "se", "fs", "sup", "spec", "ts", "sb", "aws", "xs", "sv", "sets", "p", "e", "conf", "v", "su", "site", "S", "os", "session", "t", "its", "sci", "in", "sym", "ssl", "cs", "ss", "r", "is", "ins", "space", "m", "ds", "ps", "gs", "native", "ns", "c", "es", "south", "sec", "o", "sim", "si", "server", "service", "http", "ops", "d", "sync", "l", "services", "sq", "stats", "b", "support"], "ap": ["pl", "np", "att", "prop", "sp", "op", "arr", "api", "py", "AP", "arp", "tp", "ac", "aps", "ams", "ps", "attr", "cap", "jp", "mp", "as", "cp", "al", "pro", "wp", "am", "map", "pp"], "mxf": ["dxe", " mfc", " mxe", "dfx", " mfx", "dfc", "hfx", "dcf", "dxd", "fmxf", "jxf", "Mfc", "jxc", "cxf", "Mxe", "mxd", "dxf", "ccf", "cmcf", "jxd", "kcf", "fmxc", "mcf", "fmcf", "hxd", "hxf", "kxe", " mxc", "Mxa", " mxd", "mxe", " mcf", "dxc", "Mxc", "cxd", "cmxf", "Mxd", "cmxc", "hxc", "kxf", "fmxd", " mxa", "Mcf", "jcf", "mfx", "kxa", "cmxd", "mxc", "mfc", "mxa", "Mxf", "cxc"], "klv": ["kswl", "klee", "Klc", "kvd", "kevd", " knv", "riskif", " klev", "kll", "mkvl", "skwl", " kvm", " klf", "ckwl", "okli", "skln", "Kla", "Klan", "kslev", "Kvl", " kell", "kla", " klan", "riskwl", "klly", "sklf", "knv", " kwl", "mklf", "jlp", "kwl", "aklev", "klan", "mklv", "ckvd", " klc", "okvd", "skva", "oklf", "okcol", "kslee", "akell", "kcol", "skif", "klf", "kln", "kslv", "kvm", "sklan", "jwl", "kif", "kli", "Kli", " kcol", "keva", "aklv", "sklp", "akvm", "skvm", " kif", "arklv", "cklv", "Kwl", "kdd", "arkwl", "skdd", "Klf", "jlv", "sknv", "kql", "skvc", "mkla", " kla", "kslly", "klev", "arklc", "kickll", "Kql", "kicklv", "Klp", "jlf", "skvd", "okva", "sklv", "kelee", "klp", "sklev", "kewl", "ksdd", "risklv", "okvc", "arkvd", "oklc", " kdd", "cklf", "klc", "kelv", " kvl", "jql", "okwl", "kva", " kvc", "Kln", "kicklee", "risknv", "kell", "kvc", "skcol", "ksll", "skell", "Klv", "oklv", "kelly", "kvl", " kln", " kli", "sklc", "kicklly", "skql", "cklc"], "metadata": ["parser", "ata", "data", "filename", "header", "ATA", "ma", "tmp", "shared", "member", "package", "m", "entry", "info", "details", "properties", "json", "description", "adata", "iterator", "message", "stream", "summary", "definition", "node", "meta", "session", "met"]}}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_codec_desc(const void *a, const void *b)\n\n{\n\n    const AVCodecDescriptor * const *da = a;\n\n    const AVCodecDescriptor * const *db = b;\n\n\n\n    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :\n\n           strcmp((*da)->name, (*db)->name);\n\n}\n", "idx": 19667, "substitutes": {"a": ["na", "ab", "s", "f", "n", "ar", "A", "i", "am", "as", "self", "ae", "ba", "ca", "art", "d", "ac", "ama", "aa", "ad", "asa", "e", "ak", "c", "p", "ada", "va", "la", "ra", "an", "sa"], "b": ["ab", "eb", "bs", "s", "x", "f", "ob", "sb", "i", "cb", "as", "wb", "B", "xb", "bb", "lb", "abb", "ba", "d", "arb", "bur", "bd", "mb", "e", "k", "fb", "v", "be", "c", "emb", "rb", "p", "boot", "ub", "y", "ib"], "da": ["na", "dd", "data", "gd", "aka", "lla", "aea", "pd", "de", "Da", "fa", "onda", "as", "ld", "bb", "ba", "sta", "ca", "oda", "ta", "d", "aa", "ad", "bd", "asa", "ga", "DA", "pa", "lambda", "ea", "ada", "ppa", "dat", "va", "la", "wa", "ra", "ke", "ja", "ma", "sa", "ds"], "db": ["ab", "eb", "bi", "dd", "bs", "data", "ah", "gd", "base", "ob", "dir", "ib", "sb", "cb", "bc", "loc", "vd", "bb", "ae", "sd", "ba", "d", "deb", "gb", "database", "bf", "aa", "dy", "bd", "ad", "fd", "fb", "bh", "rb", "ade", "lib", "DB", "doc", "ada", "ud", "Db", "ub", "lab", "ds"]}}
{"project": "FFmpeg", "commit_id": "f21cf2b38365caaa8a130a32521c2648600c3f50", "target": 0, "func": "static int encode_hq_slice(AVCodecContext *avctx, void *arg)\n\n{\n\n    SliceArgs *slice_dat = arg;\n\n    VC2EncContext *s = slice_dat->ctx;\n\n    PutBitContext *pb = &slice_dat->pb;\n\n    const int slice_x = slice_dat->x;\n\n    const int slice_y = slice_dat->y;\n\n    const int quant_idx = slice_dat->quant_idx;\n\n    const int slice_bytes_max = slice_dat->bytes;\n\n    uint8_t quants[MAX_DWT_LEVELS][4];\n\n    int p, level, orientation;\n\n\n\n    avpriv_align_put_bits(pb);\n\n    skip_put_bytes(pb, s->prefix_bytes);\n\n    put_bits(pb, 8, quant_idx);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++)\n\n        for (orientation = !!level; orientation < 4; orientation++)\n\n            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (p = 0; p < 3; p++) {\n\n        int bytes_start, bytes_len, pad_s, pad_c;\n\n        bytes_start = put_bits_count(pb) >> 3;\n\n        put_bits(pb, 8, 0);\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                encode_subband(s, pb, slice_x, slice_y,\n\n                               &s->plane[p].band[level][orientation],\n\n                               quants[level][orientation]);\n\n            }\n\n        }\n\n        avpriv_align_put_bits(pb);\n\n        bytes_len = (put_bits_count(pb) >> 3) - bytes_start - 1;\n\n        if (p == 2) {\n\n            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);\n\n            pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        } else {\n\n            pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        }\n\n        pb->buf[bytes_start] = pad_s;\n\n        flush_put_bits(pb);\n\n        skip_put_bytes(pb, pad_c);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12616, "substitutes": {"avctx": ["evconv", "Avconv", "Avpkg", "afconv", "afpkg", "avconv", "afctx", "avcontext", "Avcontext", "evctx", "afcontext", "Avctx", "avpkg", "evcontext", "evpkg"], "arg": [" argument", "args", "call", "slice", "amp", "array", "arm", "ai", "val", "ray", "or", "g", "ig", "ace", "v", "AR", "var", "ad", "parse", "ang", "ag", "Args", "arp", "ann", "arc", "att", "ay", "am", "parser", "arr", "par", "ac", "argument", "anc", "attr", "Arg", "load", "param", "mac", "ar", "alias", "asm"], "slice_dat": ["pixel_not", "volume_typ", " slice_def", " slice_att", "slice_vari", "sliceOgrad", "pixel_grad", "slice_not", " sliceacinit", "volumeJgat", "sliceingdest", "volume_gat", "package_dim", "slice___att", "sliceOvari", "slice_def", "slice_typ", "slice_data", "sliceOld", "sliceOdef", " slice_Dat", "slice_init", "slice_grad", "package_bat", "pixelOgrad", "slicealldist", "pixelOdat", "packageOdim", "sliceJbatch", "slice_batch", "volumeJbatch", "slice_dest", "pixel_dat", "sliceOdat", "slice_Dat", "seed_dist", "slice_att", "sliceJdat", "pixelOld", "slice_gat", " slice_list", "volumeJdat", "package_dat", "sliceObat", "pixel_ld", "sliceacinit", "sliceOatt", "sliceingdata", "slice_dim", "pixelOnot", "volume_dat", "slice___dat", "packageObat", "seed_data", "sliceJtyp", "slicealldest", "slice_dist", "volume_batch", "slice_list", "sliceingdat", "sliceingdist", "seed_ld", "slice_ld", "sliceOlist", "slicealldata", "sliceOnot", "seed_dest", "seed_dat", "volumeJtyp", "slice___def", "slice_conn", "sliceOdim", "package_vari", "slice_dan", "packageOdat", "slice___list", "slice_bat", "sliceJgat", " sliceacDat", "seed_conn", " sliceacdat", " slice_init", "sliceacdat", " sliceacdan", "sliceacDat", "packageOvari", " slice_dan", "sliceacdan", "slicealldat"], "s": ["secondary", "south", "sys", "ses", "self", "m", "slice", "service", "sync", "t", "sg", "fs", "ins", "l", "i", "rs", "sym", "utils", "g", "cs", "qs", "S", "settings", "os", "js", "si", "scope", "sq", "es", "session", "v", "ps", "ss", "client", "w", "u", "e", "groups", "site", "sf", "b", "sb", "j", "n", "f", "gs", "spec", "c", "ns", "single", "is", "sc", "ssl", "side", "sv", "sl", "ops", "services", "ds", "r", "sa", "su", "ls", "ts", "core", "ctx", "aws"], "pb": ["xb", "proc", "pkg", "python", "bc", "slice", "plain", "tmp", "pc", "jp", "vp", "mp", "fb", "phys", "api", "prot", "ub", "uf", "pg", "hub", "lp", "nb", "dl", "pp", "buffer", "esi", "fp", "bj", "phrase", "platform", "bp", "pd", "alist", "summary", "plugin", "bot", "bm", "rb", "pa", "buf", "sb", "wb", "b", "pl", "tc", "bf", "wp", "gb", "bh", "ab", "pm", "parser", "bps", "lab", "cb", "eb", "rob", "PB", "dp", "cp", "cpp", "db", "prototype", "lb", "ppa", "fc", "tp", "ctx", "asm", "gp"], "quants": ["quats", "instants", "aquants", "chants", "quands", "operans", "quant", "instats", "aquant", "operant", "chant", "aquands", " quads", "iquads", " quats", "iquANT", "iquants", "chads", "aquans", "aquats", " quans", "quANT", "quans", "chANT", " quands", " quANT", "instaints", "operants", "quaints", "quads", " quant", "iquant", "aquaints", "instant", "operands", " quaints"], "MAX_DWT_LEVELS": ["MAX_DWT_LEVELN", "MAX_DWT_SLLLING", "MAX_DWT_LEENGTHN", "MAX_DWT_LELLV", "MAX_DWT_LEENGTHV", "MAX_DWT_SLLLN", "MAX_DWT_LEENGTHING", "MAX_DWT_SLVELV", "MAX_DWT_LELLN", "MAX_DWT_LELLS", "MAX_DWT_LEVELV", "MAX_DWT_SLVELING", "MAX_DWT_SLVELN", "MAX_DWT_SLVELS", "MAX_DWT_SLLLV", "MAX_DWT_LEVELING", "MAX_DWT_SLLLS", "MAX_DWT_LELLING", "MAX_DWT_LEENGTHS"], "p": ["port", "m", "part", "po", "d", "t", "pc", "code", "i", "l", "jp", "a", "pre", "period", "g", "pg", "h", "lp", "pp", "pressure", "position", "fp", "pid", "v", "patch", "ps", " P", "o", "np", "bp", "u", "e", "pa", "pl", "b", "base", "op", "j", "n", "f", "point", "at", "parent", "pair", "ip", "c", "ping", "pe", "per", "type", "pi", "q", "dp", "r", "cp", "pr", "pos", "pad", "P", "tp", "depth"], "level": ["fl", "ale", "child", "local", "pre", "low", "status", "model", "loc", "limit", "ul", "lo", "temp", "sol", "pl", "count", "flow", "line", "sc", "iter", "fail", "pri", "lock", "index", "sync", "id", "lc", "weight", "full", "ld", "key", "error", "w", "pass", "clean", "version", "length", "url", "al", "rel", "wl", "el", "round", "path", "condition", "lvl", "levels", "style", "variable", "unit", "update", "like", "value", "o", "step", "layer", "stage", "found", "lf", "point", "f", "global", "inc", "Level", "type", "wall", "cl", "any", "l", "code", "letter", "name", "col", "size", "time", "where", "rol", "parent", "file", "rule", "scale", "coll", "vel", "day", "len", "depth"], "orientation": ["pectation", "pection", "orientoration", "denation", "directionication", "rientmentation", "varioration", "rientment", "orientization", "rientication", "animation", "designrelation", "organimation", " orientimation", "orientotation", "orientication", "rientATION", " orientate", "occupate", "rotator", " orientization", "rientator", "orientification", "designations", "directionrelation", "orientator", "designATION", "occupance", "orientration", "organization", " orientification", "denization", "orientated", "variation", "animification", "oriention", "pectning", "rientoration", " orientated", "variational", "organment", "rientational", "rotization", "variimation", "organification", "ortator", "ortning", "rientization", "directionration", "rientration", "organature", "rientimation", "orientmentation", "animication", "designation", "orientature", "orientance", " orientmentation", "ortion", "directionation", "occupment", "animimation", "rotature", "rotation", "denotation", "organator", "designate", "directionment", "rientated", "orientATION", "orientning", "riention", "organication", "rientature", "rientning", "occupATION", "animment", "directionated", "rientance", "occupration", " orientations", "orientational", "organoration", "orientimation", "organation", " orientration", "animator", "denated", "animmentation", "rientotation", "occupotation", " orientication", "orientment", "occupication", "ortation", "orientrelation", "rientation", "occupations", "directionization", "orientations", "organational", "animance", "animotation", " orientotation", "pectator", "designration", "orientate", "rientification", "occupator", "occupation", "rientrelation", "directionATION"], "bytes_start": ["bytes_mean", "bytes_init", "bytes_ad", "bytes_n", "bytes_end", "bits_init", "bits_mean", " bytes_n", "bits_start", " bytes_count", "bits_end", " bytes_ad", " bytes_end", "bytes_count"], "bytes_len": ["tes_en", "seconds_min", "bytes_max", "seconds_base", "bytes_", "bytes_min", "files_l", "bytesxdl", "files_diff", "tes_", "bits2", " bytes2", " bytes\n", "bytes_dl", "tes2", "tes_dl", "tesxmax", "bytes5dl", "files_start", "bytes_diff", "tes\n", "seconds_len", "tesxdl", "bytesxen", "bytesxmax", "bytes5en", "bytes_l", "bytesxlen", "bytes\n", "bytes5max", "tesxen", "seconds_start", "bits_", "tes_max", "bytes2", "bytes5len", "bytes_base", "bytes_en", "tesxlen", " bytes_", "bits\n", "files_len", "tes_len"], "pad_s": ["pad_space", "padregsum", " pad_i", "pad_y", "pad_sum", "strip_y", "strip_sum", "padregs", "pad_su", "padregspace", "padXspace", "strip_s", "stripregy", "padXy", "padregy", "pad_i", "padXs", "pad_d", "strip_space", "stripregsum", "stripregspace", "padXsum", " pad_su", " pad_d", "stripregs"], "pad_c": ["pad24cn", "pad___c", "padPcat", "pad_sc", "pad67c", "pad_cat", "padding_c", "pad_cn", "pad___count", "pad24c", "pad___s", "pad67s", "pad24cat", " pad_cn", "padding_s", "padding_count", "pad67sc", "padding_sc", "padPc", " pad_cat", "pad_count", "padPcn", "pad___sc", "padPs", "pad67count", "pad24s"]}}
{"project": "qemu", "commit_id": "39f80521df1e7f1252960d1ada2bd1a41d4d2cd3", "target": 0, "func": "static int inet_listen_saddr(InetSocketAddress *saddr,\n\n                             int port_offset,\n\n                             bool update_addr,\n\n                             Error **errp)\n\n{\n\n    struct addrinfo ai,*res,*e;\n\n    char port[33];\n\n    char uaddr[INET6_ADDRSTRLEN+1];\n\n    char uport[33];\n\n    int slisten, rc, port_min, port_max, p;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai,0, sizeof(ai));\n\n    ai.ai_flags = AI_PASSIVE;\n\n    if (saddr->has_numeric && saddr->numeric) {\n\n        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n\n    }\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return -1;\n\n    }\n\n\n\n    if (saddr->host == NULL) {\n\n        error_setg(errp, \"host not specified\");\n\n        return -1;\n\n    }\n\n    if (saddr->port != NULL) {\n\n        pstrcpy(port, sizeof(port), saddr->port);\n\n    } else {\n\n        port[0] = '\\0';\n\n    }\n\n\n\n    /* lookup */\n\n    if (port_offset) {\n\n        unsigned long long baseport;\n\n        if (strlen(port) == 0) {\n\n            error_setg(errp, \"port not specified\");\n\n            return -1;\n\n        }\n\n        if (parse_uint_full(port, &baseport, 10) < 0) {\n\n            error_setg(errp, \"can't convert to a number: %s\", port);\n\n            return -1;\n\n        }\n\n        if (baseport > 65535 ||\n\n            baseport + port_offset > 65535) {\n\n            error_setg(errp, \"port %s out of range\", port);\n\n            return -1;\n\n        }\n\n        snprintf(port, sizeof(port), \"%d\", (int)baseport + port_offset);\n\n    }\n\n    rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL,\n\n                     strlen(port) ? port : NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, port, gai_strerror(rc));\n\n        return -1;\n\n    }\n\n\n\n    /* create socket + bind */\n\n    for (e = res; e != NULL; e = e->ai_next) {\n\n        getnameinfo((struct sockaddr*)e->ai_addr,e->ai_addrlen,\n\n\t\t        uaddr,INET6_ADDRSTRLEN,uport,32,\n\n\t\t        NI_NUMERICHOST | NI_NUMERICSERV);\n\n        slisten = qemu_socket(e->ai_family, e->ai_socktype, e->ai_protocol);\n\n        if (slisten < 0) {\n\n            if (!e->ai_next) {\n\n                error_setg_errno(errp, errno, \"Failed to create socket\");\n\n            }\n\n            continue;\n\n        }\n\n\n\n        socket_set_fast_reuse(slisten);\n\n\n\n        port_min = inet_getport(e);\n\n        port_max = saddr->has_to ? saddr->to + port_offset : port_min;\n\n        for (p = port_min; p <= port_max; p++) {\n\n            inet_setport(e, p);\n\n            if (try_bind(slisten, saddr, e) >= 0) {\n\n                goto listen;\n\n            }\n\n            if (p == port_max) {\n\n                if (!e->ai_next) {\n\n                    error_setg_errno(errp, errno, \"Failed to bind socket\");\n\n                }\n\n            }\n\n        }\n\n        closesocket(slisten);\n\n    }\n\n    freeaddrinfo(res);\n\n    return -1;\n\n\n\nlisten:\n\n    if (listen(slisten,1) != 0) {\n\n        error_setg_errno(errp, errno, \"Failed to listen on socket\");\n\n        closesocket(slisten);\n\n        freeaddrinfo(res);\n\n        return -1;\n\n    }\n\n    if (update_addr) {\n\n        g_free(saddr->host);\n\n        saddr->host = g_strdup(uaddr);\n\n        g_free(saddr->port);\n\n        saddr->port = g_strdup_printf(\"%d\",\n\n                                      inet_getport(e) - port_offset);\n\n        saddr->has_ipv6 = saddr->ipv6 = e->ai_family == PF_INET6;\n\n        saddr->has_ipv4 = saddr->ipv4 = e->ai_family != PF_INET6;\n\n    }\n\n    freeaddrinfo(res);\n\n    return slisten;\n\n}\n", "idx": 25353, "substitutes": {"saddr": ["sprot", "dsptr", "salign", "southenv", "servicehop", "sesaddr", "symaddress", "pvr", " slayer", "servicelayer", "saddress", "serviceaddr", "slayer", "southaddress", "wsvr", " sadr", " sprot", "svaddress", "svr", "padr", "nsaddr", "senv", "taddress", " sconfig", "shipalign", "shipaddress", " sptr", "shipprot", " svr", "ssladdress", "fadr", "seslayer", " salign", "faddr", "nslayer", "taddr", "tlayer", "paddress", "dsaddr", "shop", "svvr", "shost", "tconfig", "nconfig", "dsvr", "sord", "sadr", "nshost", "nsaddress", "sslhost", "symenv", "sattr", "sconfig", "dsaddress", "servicesalign", "ssladdr", "wsaddress", " sadd", "svadr", "southaddr", "wsptr", "seshop", "sesaddress", "ford", "svadd", "symaddr", "svord", " saddress", "servicesprot", " sord", "sadd", "paddr", "svhost", "naddr", "naddress", "servicesaddress", "nlayer", "fenv", "shipaddr", "southattr", "svaddr", " shop", "phost", "faddress", "dslayer", "serviceaddress", "dshost", "ssladr", "servicesaddr", "fattr", "nsadr", " shost", "wsaddr", "symattr", "sptr"], "port_offset": ["ort_offset", "ort_len", "ort_off", "port_default", "port_len", "port_bound", "port67off", "port_alt", "port_padding", "port_auto", "connection_optional", "port___offset", "port67ext", "port_limit", "port67offset", "ort_ext", "portlendefault", "Port_default", "port_optional", "connection_limit", "ort_alt", "port___off", "Port_range", "portlenoffset", "port___alt", "port_ext", "connection_padding", "port_range", "port_off", "port___ext", "Port_off", "portlenoff", "ort_auto", "connection_offset", "portlenrange", "ort_bound", "Port_offset", "port67alt"], "update_addr": ["updateIfaddr", "updateFmac", " change_ptr", "updateIfptr", " changeFmac", "updateIfmac", "update_ptr", "update64mac", " changeFptr", "updateIforig", "update64addr", " change_orig", " change_addr", "updateForig", "updateFaddr", "update_mac", "update_orig", "update64ptr", " changeForig", " change_mac", "update64orig", " changeFaddr", "updateFptr"], "errp": ["arrk", "errpc", "erP", "errb", " errk", "erfp", "errpe", "erpi", "errorpc", "arrf", " errpi", " errr", "rrf", " erpi", "rrp", "errpre", "errk", "errorf", "grp", "grf", "erpc", "rrr", " errP", "errpi", " errb", "grc", " errpe", " erf", "errr", " erp", " errf", "errorfp", "erf", " errfp", "erpre", "erk", "arrr", " errpc", "grfp", "erb", "rrpe", "errorP", "rrb", "errorc", "erp", "arrp", "rrc", "errP", "errfp", " erb", " erc", "rrfp", " errpre", "errorpre", " errc", "errc", " erpe", "errf", "errorp"], "ai": ["acc", "ana", "qa", "ee", "sub", "ini", "bi", "ann", "ig", "issue", "agi", "ga", "sa", "aii", "ca", "ait", "ami", "ru", "oci", "af", " bi", "ay", "ti", "ia", "mi", "address", "qi", "ra", "aaa", "ci", " mi", "eni", "man", "auth", "aud", "fa", "attr", "pc", "ais", "gui", "abi", "ae", "iam", "mac", "ani", "asi", "iri", "afi", "uri", "fi", "pai", "au", "umi", "na", "ha", " AI", "pa", "air", "i", "info", "aa", "aim", "api", "config", "access", "iana", "AI", "si", "ni", "hai", "aci", "net", "an", "AU", "a", "conn", "pi", "ui", "ac", "iat"], "res": ["ru", "rs", "gr", "mr", "rec", "rss", "arr", "rh", "rev", "rar", "re", "os", "ras", "ros", "ret", "response", "ress", "req", "ry", "rem", "Res", "ack", "rx", "pres", "reg", "conn", "resp", "results", "r", "ex", "ris", "result", "rr"], "e": ["esc", "rs", "ep", "fe", "er", "exc", "c", "ae", "enc", "ec", "en", "debug", "ei", "ev", "end", "ea", "ee", "es", "ef", "re", "eu", "ir", "E", "resp", "event", "r", "ace"], "port": ["socket", "date", "server", "name", "mail", "phrase", "request", "export", "bug", "version", "url", "project", "term", "contract", "object", "hop", "number", "ptr", "zip", "serv", "username", "part", "service", "entry", "match", "core", "code", "body", "slice", "option", "m", "PORT", "mount", "test", "queue", "text", "address", "ORT", "duration", "form", "point", "feed", "patch", "password", "resource", "path", "target", "json", "timeout", "rule", "stream", "value", "report", "table", "file", "rest", "token", "nat", "pt", "data", "component", "pointer", "select", "mac", "message", "uri", "offset", "phone", "parent", "cp", "length", "proxy", "ort", "host", "null", "header", "pos", "post", "connection", "pid", "page", "Port", "position", "api", "config", "interface", "ports", "type", "opt", "end", "method", "pad", "allow", "fat", "channel", "direction", "comment", "pr", "ip", "route", "pre", "format"], "uaddr": ["_host", " uptr", "uaddress", "uuhost", "uuaddress", "uptr", " uhost", "_address", "uuaddr", "uuptr", "uhost", "_addr", "_ptr", " uaddress"], "uport": ["urports", "urhost", "usconfig", "uhost", "ushost", "usport", "usports", "urconfig", "Uhost", "urport", "Uconfig", "Uports", "uports", "Uport", "uconfig"], "slisten": ["nslisten", "snamon", "snamen", "sdefener", "nslistener", "slistener", "sliston", "sdefon", "snamener", "nsliston", "nsnamen", "nsnamon", "snamenc", "slistenc", "nsnamenc", "nsnamener", "sdefen", "sdefenc", "nslistenc"], "rc": ["sr", "rn", "add", "cb", "num", "vc", "rg", "r", "nc", "auc", "anc", "c", "ec", "rec", "src", "rr", "pc", "g", "rs", " RC", "uc", "parse", "d", "back", "xc", "rb", "success", "error", "abc", "fc", "rh", "cc", "ror", "ras", "reply", "ack", "rx", "RC", "ck", "_", "ok", "sc", "dc", "oc", "cur", "bc", "end", "id", "rl", "loc", "roc", "co", "rt", "irc", "result", "ac"], "port_min": ["port64min", "port64range", "port64limit", "port_range", " port_limit", "port_limit", "port64max", " port_range"], "port_max": ["portfmin", "portflimit", "portfmax", " port_diff", "portfdiff", " port_limit", "port_diff", "port_limit"], "p": ["pp", "param", "i", "c", "P", "jp", "ping", "ps", "dp", "op", "proc", "patch", "pb", "cp", "pat", "po", "ip", "tp", "a", "fp", "q", "r", "pi", "pos", "pc", "pid"], "err": ["rs", "sys", "er", "errors", "rage", "exc", "der", "dr", "acer", "doc", "ec", "ise", "cr", "gz", "cb", "gr", "ler", "error", "mr", "rag", "bug", "ev", "fr", "oe", "rss", "ee", "iter", "arr", "Error", "rh", "rm", " er", "aaa", "lr", "rev", "rar", "fee", "cer", "ait", "here", "fi", "order", "fy", " error", "ar", "req", "kr", "ir", "pr", "rx", "resp", "runner", "erg", "ind", "r", "aster", "Er", "rr", "result", "tx", "ace", "eor"], "baseport": ["basect", "bideto", "ancect", "sitestate", " baseto", "basety", " basect", "baseland", "bideport", "baseename", "baseto", " basep", "siteto", "basestate", "Baseport", "Basename", "Basep", "anceport", " basety", "siteport", "baseety", "Baseland", " basetime", "ancename", "anceland", " basename", "Basect", "baseetime", " basemin", "Basemin", "basetime", " baseland", "Basetime", "basemin", "Basety", "baseemin", "sitename", "basename", "basep", "bidestate", "baseep", " basestate", "bidename", "baseeport"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 8565, "substitutes": {"timer_list": ["tick_tree", "timer_record", "timerlisttest", "timer_count", "er_batch", "later_add", "meter_config", "timerlistget", "timer_stack", "timerappdef", "timerxList", "theme6stack", "timeridlist", "timerlistqueue", "timer2get", "timer_left", "timerlistlist", "theme_stack", "timerallconfig", "timer_table", "timerdrecord", "tick_List", " timer_diff", "timer_def", "meter_get", "timerkdiff", "timerxlist", "timer6LIST", "timerktable", "meterappdef", "timer0test", "theme0detail", "ticklisttree", "timer5stack", "theme_detail", "timer_type", "er_pair", "theme_LIST", "timer_queue", "theme_get", "timer_diff", "theme6list", "ticklistlist", "timerdlist", "timerAcount", "timerapplist", "meterappget", "timerlistList", "meter_def", "theme0get", "timer0detail", "theme_test", "timer6stack", "later_left", "ticklistList", "tick_queue", "timerlList", "timer0list", "timer5LIST", "tick_list", "timer6list", "timer_LIST", "timer6get", "timer_tree", "timerallget", "timerappget", "timerxpair", "timerklist", "ticklistqueue", "timeridleft", "timerAlist", "timerltree", "later_list", "timer_detail", "timer_config", "timer0get", "timeralldef", "er_list", "theme6get", "lateridbatch", "timerxrecord", "timer_lock", "timerappstack", "timer5get", "timerdList", "theme0list", "timerappLIST", "timer_batch", "timerlqueue", "timer_pair", "later_batch", "timerAtable", "theme0test", "er_type", "meterappconfig", "timer2config", "timer_List", "timer2list", "timer_add", " timer_count", "timer2def", "lateridlist", "timeralllist", "theme_list", "er_List", "timerllist", "timerlisttree", "timeridbatch", "timerappconfig", "timerlistdetail", "timerAdiff", "er_record", "er_lock", " timer_table", "lateridleft", "theme6LIST", "meter_list", "meterapplist", "timerkcount", "lateridadd", "timer_get", "timerdpair", "timer_test", "timeridadd", "timer5list"], "expire_time": ["expire___hour", "expirexmoney", "expireycount", "expireyhour", "expirexmode", "expire64money", "expire64hour", "expire___count", "expireytime", "expire64start", "expire_mode", "expire___time", "exake_start", "expiration_money", "expiration_timeout", "expire64timeout", "exire_money", "exire_count", "expireystart", "exire_Time", "expire__money", "expire___start", "expire_money", "exake___count", "exake___time", "expiration_time", "expire_Time", "expire_count", "expirextime", "expire_timeout", "expire64count", "expirefmoney", "expireftime", "expirefmode", "exire_time", "expire_hour", "exake_count", "exire_mode", "exake_hour", "expire__timeout", "exake___start", "expire64time", "expire__time", "expire_start", "exake_time", "exake___hour"]}}
{"project": "qemu", "commit_id": "913440249ea2e697177e9d43167ac325a8dfe907", "target": 0, "func": "static int usbnet_can_receive(NetClientState *nc)\n\n{\n\n    USBNetState *s = qemu_get_nic_opaque(nc);\n\n\n\n    if (!s->dev.config) {\n\n        return 0;\n\n    }\n\n\n\n    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {\n\n        return 1;\n\n    }\n\n\n\n    return !s->in_len;\n\n}\n", "idx": 19291, "substitutes": {"nc": ["ns", "pc", "dc", "cdn", "cus", "ct", "conn", "ng", "rc", "nt", "ne", "n", "nic", "nec", "sb", "bc", "ctx", "fc", "mc", "enc", "cs", "nm", "sn", "rn", "NC", "sc", "lc", "c", "nw", "kt", "osc", "ec", "unc", "cn", "nn", "cv", "cc"], "s": ["ns", "ms", "spec", "ts", "sg", "sis", "stats", "rs", "f", "settings", "services", "n", "sb", "g", "i", "sl", "ss", "ls", "src", "ops", "fs", "xs", "self", "is", "o", "cs", "als", "sports", "d", "sn", "qs", "e", "ssl", "k", "ses", "v", "sync", "c", "ps", "si", "js", "sym", "p", "S", "ks", "b", "http", "gs", "sys", "a", "es", "os", "state", "hs", "parts", "states", "sq", "ds", "u"]}}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint16(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx16 : \"%\" PRIu16;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 19554, "substitutes": {"dev": ["grad", "Dev", "dd", "br", "mod", "ch", "data", "gd", "conf", "err", "obj", "md", "debug", "de", "rad", "dt", "wd", "def", "prom", "sd", "self", "d", "sh", "comp", "w", "ev", "prof", "private", "dom", "device", "req", "od", "proc", "inst", "dem", "priv", "iv", "pro", "gr", "attr", "ver"], "prop": ["part", "data", "info", "pred", "obj", "ref", "dep", "name", "op", "f", "property", "lit", "r", "rt", "root", "type", "ctx", "pb", "phy", "pos", "def", "pointer", "Prop", "val", "device", "tmp", "p", "pr", "proc", "properties", "priv", "pro", "prot", "attr", "pt"], "str": ["spec", "part", "fr", "strings", "br", "code", "tr", "text", "data", "rs", "err", "name", "ctr", "obj", "sp", "expr", "r", "hr", "ext", "stri", "sec", "arr", "STR", "enc", "val", "st", "sr", "dr", "cr", "cur", "Str", "test", "pr", "attr", "pt"], "ptr": ["pc", "fr", "offset", "tr", "t", "fp", "func", "err", "ref", "sp", "tty", "r", "nt", "rt", "src", "loc", "pos", "pointer", "val", "st", "length", "dr", "fd", "buf", "p", "vt", "pad", "inter", "pr", "spr", "inst", "addr", "Ptr", "py", "prot", "pt", "len"], "fmt": ["fnt", "Frt", "defnt", "tfMT", "frrt", "fMT", "defmbol", "frtr", "defmt", " fnt", "frmt", "sfMT", "Fmt", "fmbol", "Fmbol", " fmbol", "tfprintf", "sfmt", "tfrt", "FMT", "frMT", "Fnt", "ftr", "sftr", " fMT", " frt", "frt", "Fprintf", "tfmt", "defMT", "Ftr", "sfrt"]}}
{"project": "FFmpeg", "commit_id": "cea9eb9520fab9e5ec79d3a2d4dbd03eb71b7fa3", "target": 1, "func": "static av_cold int dnxhd_decode_close(AVCodecContext *avctx)\n\n{\n\n    DNXHDContext *ctx = avctx->priv_data;\n\n\n\n    ff_free_vlc(&ctx->ac_vlc);\n\n    ff_free_vlc(&ctx->dc_vlc);\n\n    ff_free_vlc(&ctx->run_vlc);\n\n\n\n    av_freep(&ctx->mb_scan_index);\n\n    av_freep(&ctx->rows);\n\n\n\n    return 0;\n\n}\n", "idx": 22718, "substitutes": {"avctx": ["AVcmp", "avercb", "AVwcs", "afcmp", "avconn", "afctx", "AVcontext", "avercontext", "avecmp", "avwcs", "averctx", "avecontext", "avcontext", "AVconn", "AVcb", "avcb", "averwcs", "afcb", "avectx", "avcmp", "afcontext", "AVctx", "afconn", "aveconn", "afwcs"], "ctx": ["conv", "lc", "bc", "fc", "cc", "wcs", "cam", "conn", "obj", "sci", "config", "coll", "pkg", "cv", "cm", "crit", "tx", "ca", "Context", "anc", "cas", "fp", "cmp", "ci", "alloc", "nc", "cmd", "cp", "data", "cs", "cf", "xc", "ctrl", "tc", "context", "cli", "buf", "coe", "c", "cb", "cn", "la", "sq", "aux", "sc", "comp", "dc", "soc", "auc", "qa", "gc", "fw", "loc", "cca", "cus", "utils", "cms", "hw", "voc", "cu", "vc"]}}
{"project": "FFmpeg", "commit_id": "482ee63641f4fa50f017538af384aadbceee7a18", "target": 1, "func": "static int thp_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    ThpDemuxContext *thp = s->priv_data;\n\n    AVStream *st;\n\n    AVIOContext *pb = s->pb;\n\n    int i;\n\n\n\n    /* Read the file header.  */\n\n                           avio_rb32(pb); /* Skip Magic.  */\n\n    thp->version         = avio_rb32(pb);\n\n\n\n                           avio_rb32(pb); /* Max buf size.  */\n\n                           avio_rb32(pb); /* Max samples.  */\n\n\n\n    thp->fps             = av_d2q(av_int2float(avio_rb32(pb)), INT_MAX);\n\n    thp->framecnt        = avio_rb32(pb);\n\n    thp->first_framesz   = avio_rb32(pb);\n\n                           avio_rb32(pb); /* Data size.  */\n\n\n\n    thp->compoff         = avio_rb32(pb);\n\n                           avio_rb32(pb); /* offsetDataOffset.  */\n\n    thp->first_frame     = avio_rb32(pb);\n\n    thp->last_frame      = avio_rb32(pb);\n\n\n\n    thp->next_framesz    = thp->first_framesz;\n\n    thp->next_frame      = thp->first_frame;\n\n\n\n    /* Read the component structure.  */\n\n    avio_seek (pb, thp->compoff, SEEK_SET);\n\n    thp->compcount       = avio_rb32(pb);\n\n\n\n    /* Read the list of component types.  */\n\n    avio_read(pb, thp->components, 16);\n\n\n\n    for (i = 0; i < thp->compcount; i++) {\n\n        if (thp->components[i] == 0) {\n\n            if (thp->vst != 0)\n\n                break;\n\n\n\n            /* Video component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* The denominator and numerator are switched because 1/fps\n\n               is required.  */\n\n            avpriv_set_pts_info(st, 64, thp->fps.den, thp->fps.num);\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            st->codec->codec_id = CODEC_ID_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->width = avio_rb32(pb);\n\n            st->codec->height = avio_rb32(pb);\n\n            st->codec->sample_rate = av_q2d(thp->fps);\n\n            thp->vst = st;\n\n            thp->video_stream_index = st->index;\n\n\n\n            if (thp->version == 0x11000)\n\n                avio_rb32(pb); /* Unknown.  */\n\n        } else if (thp->components[i] == 1) {\n\n            if (thp->has_audio != 0)\n\n                break;\n\n\n\n            /* Audio component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            st->codec->codec_id = CODEC_ID_ADPCM_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->channels    = avio_rb32(pb); /* numChannels.  */\n\n            st->codec->sample_rate = avio_rb32(pb); /* Frequency.  */\n\n\n\n            avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n            thp->audio_stream_index = st->index;\n\n            thp->has_audio = 1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12951, "substitutes": {"s": ["sys", "ses", "service", "t", "sg", "ins", "sym", "g", "cs", "S", "sp", "os", "sr", "si", "sq", "aps", "ps", "ss", "p", "e", "sam", "se", "sb", "sf", "b", "n", "f", "gs", "spec", "c", "ns", "sn", "sc", "ssl", "sci", "sv", "sl", "services", "ds", "r", "sa", "su", "src", "ls", "sis", "ts", "us", "ks"], "ap": ["aram", "map", "as", "amp", "array", "ai", "pac", "mp", "api", "sp", "pp", "aps", "av", "pa", "arp", "au", "att", "am", "AP", "pm", "ac", "ams", "cap", "attr", "ast", "cp", "ar", "al"], "thp": [" thfp", "uthf", "stht", "ethe", "ftw", "aklp", "ethn", "uthpe", "athcp", "phfp", "ethcp", "htjp", "thv", "althp", "ithpo", "ithtp", " thpc", "ethv", "hell", "pathp", "ithf", "Thps", "ntlp", "helt", "othlp", "rahpc", "sthf", "thps", "ethw", "whg", "whf", "thpi", " thw", "whpc", " thg", "helpe", "ethpi", "ithpc", "ntn", "whpe", "thinm", "sthn", "akpe", " thm", "thinpe", "sthlp", "thcp", "thjp", "akp", "othpc", " the", "ethp", "sthtp", "pathop", " thv", " thwp", "harpe", " thf", "ethop", "htp", "rahp", "tht", "thf", "sthpe", "althtp", "ithn", "thg", "ethper", " thper", " thip", "ithfp", "ethf", "ftp", "whlp", "ethk", "ethl", "ethlp", "ntpe", "whl", "thm", "phn", "ithop", "harl", "ithlp", " thcp", "ethg", "ithe", "ethps", "whp", "patht", "thwp", "sthps", "htpe", "athpc", "ftf", "Thp", "sthpo", " thlp", "athp", "othp", " thpe", "athl", "thfp", "help", "sthpc", "ithm", "thpc", "thk", "thpe", "thip", "thpo", "ethm", "ithip", "thlp", "uthp", "sthv", "phl", "thbp", "thper", "thop", "thn", "pathps", "the", "akwp", "rahk", "ethpc", "hellp", "sthper", " thn", "php", "rahpi", " thk", "ithl", "thtp", " thl", "sthp", "althpo", "Thbp", "htm", " thpi", "thinop", "hart", "othf", "thw", "thinp", "ithpe", "helwp", "althn", "ethjp", "ethpe", " tht", "rahl", "itht", "harp", "sthop", "rahip", "etht", "Thpc", " thps", "thl", "ithp", " thjp", " thbp", "ntp", "uthpc", "ftpe", "ethbp"], "st": ["bt", "sta", "ft", "part", "amp", "t", "rd", "art", "put", "pc", "l", "pt", "td", "sp", "ust", "ste", "sth", "std", "sw", "pp", "str", "sr", "nd", "ct", "ld", "fr", "ss", "irst", "obj", "ut", "bl", "stop", "sec", "ST", "kt", "sb", "sf", "sd", "St", "inst", "est", "sty", "pe", "sn", "sc", "nt", "stim", "sv", "sl", "rt", "ast", "stress", "sh", "sa", "src", "rest", "ist", "ts", "et", "cl", "sts", "ost", "start"], "pb": ["plug", "xb", "typ", "pkg", "uc", "bc", "cv", "tmp", "pc", "mp", "vp", "jp", "fb", "phys", "bb", "api", "prot", "ub", "uf", "pg", "pit", "hub", "lp", "txt", "wikipedia", "abc", "fp", "pid", "apy", "rpm", "platform", "phrase", "bp", "pd", "summary", "plugin", "p", "bot", "bm", "rb", "pl", "pa", "sb", "wb", "b", "http", "bf", "wp", "gb", "bh", "ab", "pm", "bps", "lab", "cb", "eb", "rob", "PB", "dp", "cp", "db", "um", "src", "lb", "prop", "ppa", "fc", "tp", "cpp"], "i": ["hi", "qi", "ui", "I", "d", "t", "ai", "ni", "xi", "id", "iu", "code", "gi", "ini", "a", "l", "sup", "ci", "di", "x", "si", "ie", "ii", "key", "v", "gu", "clip", "yi", "u", "p", "e", "fi", "mini", "mi", "li", "k", "b", "ix", "multi", "j", "n", "f", "phi", "ti", "ip", "c", "eni", "diff", "counter", "is", "inner", "pi", "chi", "loop", "uli", "bi", "ri", "pos", "num", "zi", "y", "abi", "index"]}}
{"project": "qemu", "commit_id": "f68945d42bab700d95b87f62e0898606ce2421ed", "target": 1, "func": "void qemu_savevm_state_complete(QEMUFile *f)\n\n{\n\n    QJSON *vmdesc;\n\n    int vmdesc_len;\n\n    SaveStateEntry *se;\n\n    int ret;\n\n\n\n    trace_savevm_state_complete();\n\n\n\n    cpu_synchronize_all_states();\n\n\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n        if (!se->ops || !se->ops->save_live_complete) {\n\n            continue;\n\n        }\n\n        if (se->ops && se->ops->is_active) {\n\n            if (!se->ops->is_active(se->opaque)) {\n\n                continue;\n\n            }\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_END);\n\n\n\n        ret = se->ops->save_live_complete(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n            return;\n\n        }\n\n    }\n\n\n\n    vmdesc = qjson_new();\n\n    json_prop_int(vmdesc, \"page_size\", TARGET_PAGE_SIZE);\n\n    json_start_array(vmdesc, \"devices\");\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n\n\n        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {\n\n            continue;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        json_start_object(vmdesc, NULL);\n\n        json_prop_str(vmdesc, \"name\", se->idstr);\n\n        json_prop_int(vmdesc, \"instance_id\", se->instance_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_FULL);\n\n\n\n        vmstate_save(f, se, vmdesc);\n\n\n\n        json_end_object(vmdesc);\n\n        trace_savevm_section_end(se->idstr, se->section_id, 0);\n\n\n    }\n\n\n\n    qemu_put_byte(f, QEMU_VM_EOF);\n\n\n\n    json_end_array(vmdesc);\n\n    qjson_finish(vmdesc);\n\n    vmdesc_len = strlen(qjson_get_str(vmdesc));\n\n\n\n    if (should_send_vmdesc()) {\n\n        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);\n\n        qemu_put_be32(f, vmdesc_len);\n\n        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);\n\n    }\n\n    object_unref(OBJECT(vmdesc));\n\n\n\n    qemu_fflush(f);\n\n}", "idx": 21670, "substitutes": {"f": ["fa", "fc", "e", "config", "fs", "g", "fb", "file", "d", "_", "parse", "ops", "rf", "fp", "df", "write", "t", "u", "m", "j", "s", "new", "p", "fx", "cf", "inf", "code", "q", "af", "c", "fe", "fr", "tf", "form", "b", "fd", "F", "sf", "feed", "update", "bf", "fen", "z", "v", "fn", "lf", "h", "l", "fi", "this", "fo", "k"], "vmdesc": ["vmdec", "vamddesc", " vcmdesc", "mmandesc", "vmaosc", "vmandocument", " vmaosc", "vcmdec", " vcmdasc", "vmnrec", "vmdex", " vcmdex", " vmdrec", " vMDesc", "vmodosc", "vmddesc", "vamdasc", "vmadoc", "vnddesc", "vmdrec", "vmderella", "vddisc", " vmdasc", "vmef", "gmmesc", "vmdest", " vcmdrec", "vndoc", "vMDsc", "vcmdest", "mmdesc", "vMDasc", "vcmdrec", " vmdsc", "vmdect", "vmandest", " vmdisc", "vmesc", "vMDest", "vmanderella", "vmonddesc", " vmdex", "mmdocument", "mmdest", "vamdef", " vMDdesc", " vmaser", "gmdisc", " vcmdest", "vamddec", "vamdser", "vmondest", "vmandrec", "vmnex", "vamdesc", "vmtesc", "vMDesc", "mmdoc", "vnddec", "vamderella", "vmdasc", "vcmddesc", "vmmasc", "vMDisc", "vmterella", "vmondisc", "gmmisc", " vmdef", "vmondasc", " vmaesc", "vmest", "mmderella", "vddasc", "vcmdsc", "gmdasc", "vamdocument", " vmdser", "vndesc", "vmadesc", " vcmdef", " vmdest", "vmondoc", "vmec", "vmaser", "vmtocument", "vmmisc", "gmdect", "vmasc", "vmodser", "vmddec", " vMDisc", "mmandest", "vmadest", "vmondesc", "vmdisc", "vcmdoc", "vddect", "vmodesc", "vmondsc", "vMDdesc", " vcmdoc", "vMDec", " vMDsc", " vmdoc", "vcmdasc", "vmandesc", "vmanddesc", "mmandoc", "gmdesc", "vmdser", "mmanddec", "gmmasc", "mmanddesc", "vcmdesc", "vmmect", "gmmect", "vamdsc", "vmaesc", "vcmdisc", " vmddesc", "vmanddec", " vmdec", "vmdoc", "vmandex", "mmanderella", " vcmdec", "vmmesc", "vmdsc", "mmandocument", "vmadasc", " vcmddesc", "vamdest", "vamdoc", "vMDect", "vcmdef", "vmnesc", "vmsc", " vmadesc", "mmddec", "vmtest", "vmdef", "vmnef", "vddesc", "vmdosc", "vmoddesc", " vmdosc", "mmddesc", "vamdosc", " vcmdsc", "vmandoc", "vmdocument", "vcmdex", "vmandef"], "vmdesc_len": ["vmdsc_length", "vmdsc_len", "vmdesc_long", "vmdsc_Len", "vmdsc_long", "vmdesc_Len", "vmdesc_length"], "se": ["ite", "e", "sel", "sed", "sk", "es", "serv", "ie", "ee", "sl", "ser", "ses", "ade", "pe", "lex", "sche", "be", "de", "parse", "site", "so", "ine", "oss", "entry", "s", "ue", "Se", "esse", "del", "cle", "SE", "sync", "le", "sa", "pse", "ese", "el", "spec", "ste", "sea", "si", "sh", "sc", "ch", "he", "service", "sing", "te", "spe", "ve", "loc", "see", "sem", "st", "ae", "ce", "ne", "sp", "sec", "ke", "pack", "ge", "su", "ase", "ze", "sle"], "ret": ["status", "bc", "reg", "def", "en", "xt", "gt", "ref", "err", "valid", "result", "val", "arg", "det", "repl", "Ret", "mt", "get", "no", "art", "cur", "rf", "bl", "al", "r", "bit", "msg", "res", "data", "cat", "rets", "fin", "last", " RET", "fun", "code", "success", "rc", "ext", "num", "match", "let", "RET", "rt", " Ret", "sr", "flag", "rev", "sur", "re", "reply", "error", "len", "lt", "back", "alt", "nt", "lit", "pt", "att", "ft"]}}
{"project": "qemu", "commit_id": "5e755519ac9d867f7da13f58a9d0c262db82e14c", "target": 0, "func": "void op_cp1_64bitmode(void)\n\n{\n\n    if (!(env->CP0_Status & (1 << CP0St_FR))) {\n\n        CALL_FROM_TB1(do_raise_exception, EXCP_RI);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 2880, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "1577526b47439f33a999339efdec5d624b70e1da", "target": 1, "func": "static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n    opj_image_cmptparm_t cmptparm[4] = {{0}};\n    opj_image_t *img;\n    int i;\n    int sub_dx[4];\n    int sub_dy[4];\n    int numcomps;\n    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;\n    sub_dx[0] = sub_dx[3] = 1;\n    sub_dy[0] = sub_dy[3] = 1;\n    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;\n    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;\n    numcomps = desc->nb_components;\n    switch (avctx->pix_fmt) {\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_YA8:\n    case AV_PIX_FMT_GRAY16:\n    case AV_PIX_FMT_YA16:\n        color_space = CLRSPC_GRAY;\n        break;\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n    case AV_PIX_FMT_RGB48:\n    case AV_PIX_FMT_RGBA64:\n    case AV_PIX_FMT_GBR24P:\n    case AV_PIX_FMT_GBRP9:\n    case AV_PIX_FMT_GBRP10:\n    case AV_PIX_FMT_GBRP12:\n    case AV_PIX_FMT_GBRP14:\n    case AV_PIX_FMT_GBRP16:\n    case AV_PIX_FMT_XYZ12:\n        color_space = CLRSPC_SRGB;\n        break;\n    case AV_PIX_FMT_YUV410P:\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9:\n    case AV_PIX_FMT_YUV422P9:\n    case AV_PIX_FMT_YUV444P9:\n    case AV_PIX_FMT_YUVA420P9:\n    case AV_PIX_FMT_YUVA422P9:\n    case AV_PIX_FMT_YUVA444P9:\n    case AV_PIX_FMT_YUV420P10:\n    case AV_PIX_FMT_YUV422P10:\n    case AV_PIX_FMT_YUV444P10:\n    case AV_PIX_FMT_YUVA420P10:\n    case AV_PIX_FMT_YUVA422P10:\n    case AV_PIX_FMT_YUVA444P10:\n    case AV_PIX_FMT_YUV420P12:\n    case AV_PIX_FMT_YUV422P12:\n    case AV_PIX_FMT_YUV444P12:\n    case AV_PIX_FMT_YUV420P14:\n    case AV_PIX_FMT_YUV422P14:\n    case AV_PIX_FMT_YUV444P14:\n    case AV_PIX_FMT_YUV420P16:\n    case AV_PIX_FMT_YUV422P16:\n    case AV_PIX_FMT_YUV444P16:\n    case AV_PIX_FMT_YUVA420P16:\n    case AV_PIX_FMT_YUVA422P16:\n    case AV_PIX_FMT_YUVA444P16:\n        color_space = CLRSPC_SYCC;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR,\n               \"The requested pixel format '%s' is not supported\\n\",\n               av_get_pix_fmt_name(avctx->pix_fmt));\n    }\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = sub_dx[i];\n        cmptparm[i].dy = sub_dy[i];\n        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];\n        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];\n    }\n    img = opj_image_create(numcomps, cmptparm, color_space);\n    // x0, y0 is the top left corner of the image\n    // x1, y1 is the width, height of the reference grid\n    img->x0 = 0;\n    img->y0 = 0;\n    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;\n    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;\n    return img;\n}", "idx": 1883, "substitutes": {"avctx": ["camctx", "afsci", "AVctx", "avectx", "avsci", "avconn", "afcmp", "afctx", "afcontext", "afpkg", "aveconn", "Avcontext", "akcontext", "Avconn", "Avctx", "avpkg", "akcmp", "AVpkg", "afconn", "AVcontext", "avecca", "camcontext", "camcca", "avcca", "avcontext", "avesci", "avecontext", "akpkg", "akctx", "Avsci", "afcca", "camconn", "AVcmp", "avcmp"], "parameters": ["paramseters", "configparams", "paramParameters", "ramParameters", "configParameters", "paramparams", "paramsParameters", "configeters", "ramparams", "paramsparams", "rameters"], "desc": ["sub", "name", "ext", "def", "esc", "conn", "dim", "loc", "d", "Description", "rec", "der", "de", "neg", "enc", "reci", "adr", "des", "dest", "dep", "info", "df", "config", "asc", "description", "dc", "ec", "dev", "doc", "design", "diff", "Desc", "text", "sc", "decl", "ca", "summary", "sec", "comment", "req", "dir", "pri", "dist"], "cmptparm": ["cmptpore", "cmptpair", "cmppfare", "cmptpare", "cmptfare", "cmpppare", "cmppparm", "cmptbare", "cmptppare", "cmptfair", "cmppfarm", "cmptbair", "cmpppair", "cmppfore", "cmppfair", "cmpppore", "cmptppore", "cmptpparm", "cmptfarm", "cmptppair", "cmptbore", "cmptfore", "cmptbarm"], "img": ["crop", "ff", "src", "sup", "imp", "ii", "norm", "picture", "orig", "im", "ng", "buf", "tmp", "cb", "tif", "iframe", "fig", "aff", "gd", "app", "br", "cube", "obj", "bg", "amp", "iv", "transform"], "i": ["cli", "ii", "pi", "ui", "r", "d", "I", "n", "iu", "j", "pixel", "ti", "ip", "l", "c", "p", "bi", "e", "f", "u", "v", "s", "b", "qi", "t", "ci", "io", "xi"], "sub_dx": [" sub_du", "Sub_dc", "sub__ded", "sub_ds", "Sub_dx", " sub_coe", "sub__dx", "sub_du", "sub__eddy", " sub_dq", "Sub_dy", "Sub_du", "sub_wd", "sub_ded", "sub_dj", "sub__dy", "sub__dc", " sub_eddy", "sub_dc", " sub_dj", "Sub_ded", "sub_eddy", "Sub_ds", "sub__wd", "sub_coe", "sub_dq", " sub_wd"], "sub_dy": [" sub_y", "Sub_dx", " sub_d", "sub_dt", "Sub_idd", "Sub_dj", "Sub_die", "sub__dx", "Sub_di", "sub_done", "sub_y", "sub__eddy", "sub_idd", "Sub_dy", "Sub_der", "sub__dt", "sub2dx", "sub_d", "sub_der", "sub__d", "sub__y", "sub_dj", "sub__dy", "Sub_done", " sub_eddy", "sub_die", "sub_di", "sub_eddy", "sub2dj", " sub_dt", "sub2dy", "sub2done"], "numcomps": ["numquonents", "numquples", "numcompos", "nbcomps", "numcomPS", "numcomponents", "numcompps", "numproPS", "numcompples", "nbcompples", "numcomonents", "ncomppos", "numproples", "numCompos", "nbcompPS", "numComonents", "numComples", "nbcomppos", "ncomonents", "ncompps", "nbcompps", "ncompos", "ncomples", "nbcompos", "numComPS", "numComps", "numcomples", "ncompples", "numcompPS", "numcomppos", "numqups", "ncomponents", "numpropos", "numqupos", "nbcomples", "numprops", "nbcomPS", "ncomps"]}}
{"project": "qemu", "commit_id": "47c16ed56aa6bc4037bdb7b61f049097993cd244", "target": 0, "func": "static void page_init(void)\n\n{\n\n    /* NOTE: we can always suppose that qemu_host_page_size >=\n\n       TARGET_PAGE_SIZE */\n\n#ifdef _WIN32\n\n    {\n\n        SYSTEM_INFO system_info;\n\n\n\n        GetSystemInfo(&system_info);\n\n        qemu_real_host_page_size = system_info.dwPageSize;\n\n    }\n\n#else\n\n    qemu_real_host_page_size = getpagesize();\n\n#endif\n\n    if (qemu_host_page_size == 0) {\n\n        qemu_host_page_size = qemu_real_host_page_size;\n\n    }\n\n    if (qemu_host_page_size < TARGET_PAGE_SIZE) {\n\n        qemu_host_page_size = TARGET_PAGE_SIZE;\n\n    }\n\n    qemu_host_page_mask = ~(qemu_host_page_size - 1);\n\n\n\n#if defined(CONFIG_BSD) && defined(CONFIG_USER_ONLY)\n\n    {\n\n#ifdef HAVE_KINFO_GETVMMAP\n\n        struct kinfo_vmentry *freep;\n\n        int i, cnt;\n\n\n\n        freep = kinfo_getvmmap(getpid(), &cnt);\n\n        if (freep) {\n\n            mmap_lock();\n\n            for (i = 0; i < cnt; i++) {\n\n                unsigned long startaddr, endaddr;\n\n\n\n                startaddr = freep[i].kve_start;\n\n                endaddr = freep[i].kve_end;\n\n                if (h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                    } else {\n\n#if TARGET_ABI_BITS <= L1_MAP_ADDR_SPACE_BITS\n\n                        endaddr = ~0ul;\n\n                        page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n#endif\n\n                    }\n\n                }\n\n            }\n\n            free(freep);\n\n            mmap_unlock();\n\n        }\n\n#else\n\n        FILE *f;\n\n\n\n        last_brk = (unsigned long)sbrk(0);\n\n\n\n        f = fopen(\"/compat/linux/proc/self/maps\", \"r\");\n\n        if (f) {\n\n            mmap_lock();\n\n\n\n            do {\n\n                unsigned long startaddr, endaddr;\n\n                int n;\n\n\n\n                n = fscanf(f, \"%lx-%lx %*[^\\n]\\n\", &startaddr, &endaddr);\n\n\n\n                if (n == 2 && h2g_valid(startaddr)) {\n\n                    startaddr = h2g(startaddr) & TARGET_PAGE_MASK;\n\n\n\n                    if (h2g_valid(endaddr)) {\n\n                        endaddr = h2g(endaddr);\n\n                    } else {\n\n                        endaddr = ~0ul;\n\n                    }\n\n                    page_set_flags(startaddr, endaddr, PAGE_RESERVED);\n\n                }\n\n            } while (!feof(f));\n\n\n\n            fclose(f);\n\n            mmap_unlock();\n\n        }\n\n#endif\n\n    }\n\n#endif\n\n}\n", "idx": 23052, "substitutes": {"system_info": ["system_id", "systemdbstatus", " system_status", " system_inf", "system_Info", "systemdbinfo", "systemdbInfo", " system_information", " system_fo", "systemdbinformation", " system_id", "system_information", " system_Info", "system_inf", "system_status", "system_fo"], "freep": ["Freyp", "feip", "faip", "freip", "fremp", "freeps", "feeak", "feeep", "faeps", "Freap", "feeEP", "Freek", " freap", " freq", "feap", "faak", "speeps", "fapp", "passep", "speep", "freq", "feq", "passeps", "fayp", "faEP", "faep", "freeap", "flemp", "fleek", "freap", " freEP", "Freq", "freeek", "Freak", "feeeps", "faec", "faek", "FreEP", "Freeps", "feep", "freek", "freec", " frepp", "passip", "fleap", "speEP", "feec", "freemp", "Freep", "freyp", "Frepp", "passEP", "freak", " freek", "frepp", "speip", " freyp", " fremp", " freec", " freip", "freeep", "fleep", " freeps", "freEP", "feek"], "i": ["io", "lc", "udi", "jit", "uli", "ix", "start", "e", "ie", "fi", "qi", "ri", "eni", "ui", "part", "gi", "uri", "chi", "ti", "I", "l", "hei", "ci", "y", "t", "phi", "oi", "ini", "it", "j", "ip", "abi", "p", "id", "o", "inner", "mi", "c", "mu", "index", "si", "gui", "ii", "b", "ji", "iu", "slice", "ai", "xi", "di", "yi", "multi", "z", "li", "pi", "api", "zi", "ni", "count"], "cnt": ["cnd", "ncnt", "lcid", "Cnc", "ncnc", " cnc", "lcno", "Cid", "crnc", "Crt", "crno", "ncnd", "cno", " cid", "lcnt", "cnc", "lcount", "Count", "cnn", "crt", "crnt", " crt", " cnn", "ncnn", " cnd", "Cno", " cno", " count", "cid", "Cnd", "Cnt", "crrt", "Cnn", "count"], "startaddr": ["patchaddr", " startadr", "sumptr", "endattr", "stopattr", "stopaddress", "stopaddr", "loadaddr", " startptr", "startptr", "partattr", "endadr", " startaddress", "likeaddr", "sumhop", "endptr", "patchaddress", "partptr", "startaddress", "endaddress", "sourceaddress", "starthop", "sourceaddr", "shareptr", "sourcehop", "partaddr", " starthop", "loadptr", "sumaddr", "shareaddress", "sourceptr", "startattr", "sumaddress", "patchptr", "likeaddress", "endhop", "stopptr", "loadaddress", "startadr", "shareaddr", "partaddress", "patchhop", "likeadr"], "endaddr": ["Endaddress", " endalign", " endoffset", "endattr", " endwork", "stopaddress", " endaug", "Endattr", "endalign", "pendalign", " endorder", " startorder", "stopaddr", "startoffset", "startwork", " startptr", "endnode", "startaug", " endnode", " endhop", "ENDaddress", "endoffset", "stopoffset", " startaddress", "startnode", "endptr", " endattr", "endaug", "startaddress", "endaddress", "ENDattr", "pendaddress", " endconn", "endedconn", "pendaddr", "alladdress", " endaddress", "startconn", "starthop", "endedaddress", " enddr", "endwork", "startalign", " endptr", "ENDhop", "allorder", "endedhop", "endedaddr", "endedwork", "endedattr", "endedaug", "Endaddr", "startattr", "enddr", "endhop", "stopdr", "endednode", "alladdr", "ENDaddr", "pendaug", "Endhop", "endorder", "endconn", "startdr", "allptr"], "f": ["fa", "e", "fs", "fb", "file", "d", "func", "handler", "rf", "fp", "function", "df", "t", "fu", "u", "r", "m", "p", "c", "fe", "fr", "form", "a", "b", "x", "w", "fl", "fd", "F", "fw", "ff", "feed", "buff", "fen", "v", "fn", "h", "files", "l", "fi", "fo", "fun"]}}
{"project": "qemu", "commit_id": "e155494cf0b876c45c3c68a9ab6c641aac22dfdf", "target": 1, "func": "static void qio_channel_command_finalize(Object *obj)\n\n{\n\n    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);\n\n    if (ioc->readfd != -1) {\n\n        close(ioc->readfd);\n\n        ioc->readfd = -1;\n\n    }\n\n    if (ioc->writefd != -1) {\n\n        close(ioc->writefd);\n\n        ioc->writefd = -1;\n\n    }\n\n    if (ioc->pid > 0) {\n\n#ifndef WIN32\n\n        qio_channel_command_abort(ioc, NULL);\n\n#endif\n\n    }\n\n}\n", "idx": 21135, "substitutes": {"obj": ["sb", "class", "org", "object", "conn", "jp", "Object", "coll", "orb", "ops", "so", "po", "op", "cmd", "j", "data", "init", "ob", "os", "opt", "o", "buf", "ctx", "self", "cb", "Obj", "tmp", "objects", "n", "src", "nb", "boot", "ock", "bh", "nt", "pt", "bj", "emb"], "ioc": ["giocl", "uroc", "dioca", "hoc", "aoc", "uioco", "ieoco", "idroc", "uioc", "gioca", "uOC", "piroc", "ieroc", "cioca", "ieocal", "pioca", "ioca", "aocl", "uiroc", "iroc", "riroc", "diocl", "giocon", "giOC", "inoc", "abioc", "uiocl", "oac", "oisc", "ciOC", "iac", "gioc", "uac", "uocl", "inocom", "piocom", "ciocal", "uocom", "riocl", "iocon", "piocol", "ciocom", "aoca", "piocl", "iocom", "iOC", " iOC", " ioca", "hroc", "rioc", "uiocal", "abiocol", "ooc", "inac", "ieoc", "giisc", "ciocol", "ciisc", "hocal", "cioc", "ioco", "abiocom", "ciocl", "idoc", "aroc", "iocal", "uiocom", "iocl", "iisc", " iisc", "piOC", "idocl", "oocom", "riOC", "inisc", "giocol", "hocl", "diroc", "ciroc", "iocol", "piocon", "idocal", "ciocon", "uoc", "abioca", "uisc", "cioco", "dioc", "pioc"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 3681, "substitutes": {"s": ["sg", "js", "service", "src", "cs", "ctx", "rs", "ts", "a", "context", "sb", "txt", "d", "i", "g", "m", "ses", "sf", "sync", "settings", "sv", "xs", "temp", "ds", "ps", "ns", "c", "p", "services", "w", "e", "f", "es", "sys", "sq", "u", "conf", "south", "v", "b", "su", "t", "S", "session", "support", "fs", "ssl"], "rlow": ["Rlower", "plow", "irmid", " rlo", "irlow", "rwlow", "rlower", "rmid", "rwmid", " rlower", "xlower", "Rhigh", "rlo", "xhigh", " rmid", "rwlo", "plower", "rold", "Rlow", "Rold", "irlower", "xlow", "irlo", "rwlower", "xold", "pold", "phigh"], "rhigh": [" rhighest", " rhi", "rrhigh", "rthi", "frhi", "rhighest", " rlimit", "rttop", "rthigh", "rtop", "rlimit", "frlimit", "rrlimit", "rhi", "rrhi", "frtop", "rrtop", "rrhighest", " rtop", "rthighest", "frhigh"], "val": ["base", "test", "vol", "ctx", "a", "elt", "vt", "vals", "data", "r", "loc", "Val", "fl", "prop", "alt", "sl", "py", "pre", "g", "j", "bl", "pos", "m", "cond", "temp", "func", "fe", "sel", "x", "ind", "p", "f", "eval", "ref", "len", "ffff", "value", "el", "min", "v", "b", "t", "var", "valid", "al", "reg", "VAL", "rt", "pt", "part", "xxx", "db"], "tmp": ["property", "np", "test", "vm", "ff", "src", "ctx", "TB", "vt", "sb", "txt", "data", "buff", "cro", "pb", "tab", "buf", "emp", "tc", "api", "py", "j", "pre", "boot", "tp", "rb", "m", "proc", "fp", "stuff", "cb", "storage", "temp", "config", "vv", "fake", "Temp", "p", "cv", "beta", "ptr", "nb", "f", "attr", "cache", "app", "br", "uv", "mp", "jp", "obj", "tt", "kk", "bt", "v", "fb", "b", "cp", "t", "abb", "tv", "rt", "pt", "part", "pot"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, long width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"movq \"MANGLE(bm01010101)\", %%mm4           \\n\\t\"\n\n        \"mov                    %0, %%\"REG_a\"       \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq    (%1, %%\"REG_a\",4), %%mm0           \\n\\t\"\n\n        \"movq   8(%1, %%\"REG_a\",4), %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"psrlw                  $8, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm0           \\n\\t\"\n\n        \"movq                %%mm0, %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"pand                %%mm4, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm0, %%mm0           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm1           \\n\\t\"\n\n        \"movd                %%mm0, (%3, %%\"REG_a\") \\n\\t\"\n\n        \"movd                %%mm1, (%2, %%\"REG_a\") \\n\\t\"\n\n        \"add                    $4, %%\"REG_a\"       \\n\\t\"\n\n        \" js                    1b                  \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        dstU[i]= src1[4*i + 1];\n\n        dstV[i]= src1[4*i + 3];\n\n    }\n\n#endif\n\n    assert(src1 == src2);\n\n}\n", "idx": 17206, "substitutes": {"dstU": ["dstP", "dstsUR", "dSTG", "drcCU", "drcP", "dstUR", "srcP", "DSTUR", "DstM", "DSTM", "dSTU", "srcI", "dsrcUV", "dblUV", "dsrcM", "dstUV", "ddestU", "dsrcI", "dSTUV", "sstP", "dsrcO", "dstsU", "DstO", "dSTM", "DSTUV", "DstI", "srcCU", "dsrcU", "DSTG", "dsrcG", "dSTO", "dstG", "sstI", "dblM", "DSTU", "dstM", "DstUR", "dstCU", "ddestP", "drcU", "dblU", "dstsO", "dstsI", "DSTI", "DstG", "srcU", "DSTO", "sstCU", "dstI", "dsrcUR", "drcI", "ddestCU", "dspI", "dspP", "dSTI", "dSTUR", "dspCU", "DstU", "dblG", "dstO", "dspU", "ddestI", "sstU", "DstUV"], "dstV": ["dsrcV", "dstP", "destR", " dSTU", "dstsV", "dostV", " destV", "dstsNV", "dconstU", "dsrcI", "dSTU", "dconstV", "DstV", "dblV", " dSTI", "dstsU", "dstR", "DstI", " dstR", " dstI", " dstNV", "dSTV", "dostU", "dsrcU", " dstP", "dblNV", "destV", "DSTV", "dsrcP", "DSTU", "dostP", "DstP", "dstsR", "DSTP", "dSTP", "dstNV", "dconstP", "dstsI", "dblU", " destNV", " destU", "DSTI", " dSTV", "dstI", "dostI", " destR", "dSTI", " dSTP", "DstU", "dstsP", "destNV", "dblR", "dconstI", "destU"], "src1": ["srcN", "rcOne", " src01", "rc2", "src3", "distone", "sur2", "srcone", "source1", "rc3", "sourceOne", " src3", "sur1", "host1", "hostN", "source2", "src01", "sur3", "rc01", "config2", "dist1", "host2", "source3", "rc1", "rcone", "configone", "rcN", "config1", "sur01", "dist2", "srcOne", " srcN", " srcOne"], "src2": [" src0", "srcTwo", "rc2", "src0", "src4", "source1", "rcTwo", " src4", "rc02", "source2", " src02", "source0", "sourceTwo", "source4", "rc1", "source02", "rc4", "src02", "rc0", " srcTwo"], "unused": ["unaligned", "unainitialized", "Unused", "untchecked", "unaused", "unaaligned", "Uninitialized", "unchecked", "Unchecked", "untaligned", "untinitialized", "unachecked", "uninitialized", "Unaligned", "untused"], "i": ["gi", "ti", "uri", "m", "bi", "j", "ji", "s", "info", "x", "ix", "ini", "qi", "ai", "io", "n", "phi", "fi", "hi", "block", "z", "var", "ii", "di", "index", "ind", "slice", "I", "mini", "multi", "zi", "count", "vi", "ip", "l", "oi", "pi", "ui", "ci", "abi", "id", "k", "e", "v", "lc", "c", "si", "ri", "xi", "p", "b", "mu", "col", "uli", "h", "it", "eni", "diff", "li", "u"]}}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "uint16_t eeprom93xx_read(eeprom_t *eeprom)\n\n{\n\n    /* Return status of pin DO (0 or 1). */\n\n    logout(\"CS=%u DO=%u\\n\", eeprom->eecs, eeprom->eedo);\n\n    return (eeprom->eedo);\n\n}\n", "idx": 25510, "substitutes": {"eeprom": ["pseeprome", "eegrome", "peefron", "eeprome", "eepron", "eapron", " eppram", "eepchrom", "eepsron", "emprim", "peeprm", "eefram", " eeprim", "eEprom", "eefrm", "eeprod", "eppron", "peeprom", "eaprom", "eaprod", "empram", " eaprom", " eapron", "pseepram", " eaprod", "eegrom", "pseeprm", "epprom", "eEpchrom", "pseegrom", "pseeprom", "eegrm", "peepram", "peefram", "eeprim", "eepram", "eegram", "eefrom", "pseegrm", "emprm", " epprom", "eapchrom", "epprome", "eEprod", "eEpron", " eepchrom", "eeprm", "epprim", "eefron", " eeprod", " eapchrom", "peefrm", " eepram", "peefrom", "pseegram", " epprim", "eefrim", "eepschrom", "empron", "pseegrome", "eefrome", "emprom", " eppron", " eepron", "eppram", "eepsrom", "eepsrod", "epprm", "peepron"]}}
{"project": "qemu", "commit_id": "581b9e29f36eec5de0779c3dbade980e4405d92e", "target": 0, "func": "static int qiov_is_aligned(QEMUIOVector *qiov)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < qiov->niov; i++) {\n\n        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 20410, "substitutes": {"qiov": ["quiov", "quir", "qqliv", "hilo", "Qrolet", " qrolet", " qwav", "Qiov", " qio", "qurolet", " qrons", "qrolet", "qqiov", "qir", "kiov", "hiov", " qilo", "qliv", "kwav", "qrons", "kio", " qliv", "kilo", "Qilo", "hrons", "qilo", "qqrons", " qir", "hliv", "qqilo", "quilo", "quwav", "quio", "qio", "Qir", "qwav"], "i": ["io", "e", "start", "ix", "fi", "qi", "ri", "ui", "pi", "gi", "d", "uri", "chi", "ti", "I", "l", "f", "ci", "t", "u", "oi", "ini", "m", "it", "j", "info", "phi", "ip", "p", "o", "bi", "c", "mu", "index", "si", "a", "ii", "b", "ji", "iu", "slice", "ai", "xi", "di", "v", "z", "multi", "li", "yi", "h", "ie", "x", "zi", "k", "count"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_close(AudioFrameQueue *afq)\n\n{\n\n    /* remove/free any remaining frames */\n\n    while (afq->frame_queue)\n\n        delete_next_frame(afq);\n\n    memset(afq, 0, sizeof(*afq));\n\n}\n", "idx": 22949, "substitutes": {"afq": ["artqs", "artqa", "afqs", "awq", "afqa", "afiq", "apqu", " afqu", "avalqu", "rafqs", " afquest", "afcl", "avquest", "afe", "avalqs", " afqa", "afick", "alfq", "apque", "affqa", "avq", "afQ", "afiquest", "avz", " afqs", "alfque", "avalq", " afque", "afck", "afqu", "apq", "artcl", "alfqa", "afque", "affque", "artq", " afcl", "rafqa", "afiz", "afz", "awqs", "rafq", "afquest", "avale", " afe", "alfQ", " afz", " afQ", "affQ", "apck", "afique", "afiqu", "awe", "awqu", "affq", "avque", "rafcl", " afck"]}}
{"project": "FFmpeg", "commit_id": "2254b559cbcfc0418135f09add37c0a5866b1981", "target": 1, "func": "static av_always_inline void hyscale(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                     const uint8_t *src_in[4], int srcW, int xInc,\n\n                                     const int16_t *hLumFilter,\n\n                                     const int16_t *hLumFilterPos, int hLumFilterSize,\n\n                                     uint8_t *formatConvBuffer,\n\n                                     uint32_t *pal, int isAlpha)\n\n{\n\n    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;\n\n    void (*convertRange)(int16_t *, int) = isAlpha ? NULL : c->lumConvertRange;\n\n    const uint8_t *src = src_in[isAlpha ? 3 : 0];\n\n\n\n    if (toYV12) {\n\n        toYV12(formatConvBuffer, src, srcW, pal);\n\n        src= formatConvBuffer;\n\n    } else if (c->readLumPlanar && !isAlpha) {\n\n        c->readLumPlanar(formatConvBuffer, src_in, srcW);\n\n        src = formatConvBuffer;\n\n    }\n\n\n\n    if (!c->hyscale_fast) {\n\n        c->hyScale(c, dst, dstWidth, src, hLumFilter, hLumFilterPos, hLumFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hyscale_fast(c, dst, dstWidth, src, srcW, xInc);\n\n    }\n\n\n\n    if (convertRange)\n\n        convertRange(dst, dstWidth);\n\n}\n", "idx": 20613, "substitutes": {"c": ["lc", "bc", "fc", "e", "cc", "uc", "conn", "ct", "config", "g", "this", "coll", "com", "unc", "cm", "d", "con", "ca", "pc", "cur", "cl", "cu", "f", "ci", "can", "t", "u", "ac", "m", "s", "nc", "cp", "r", "oc", "p", "mc", "cs", "enc", "cf", "tc", "context", "ctrl", "xc", "rc", "ctx", "ch", "sc", "comp", "b", "dc", "w", "cpp", "ic", "cy", "gc", "core", "n", "cr", "call", "C", "co", "v", "ce", "conf", "h", "cit", "l", "ec", "k", "vc"], "dst": ["Dst", "adsc", "ldda", " dST", "sdsth", "dsc", "isdst", "tdsrc", " dsc", "dST", "dsrc", "idst", "dsl", "isdsc", "adest", "Dsrc", "sdST", "ldst", "tdsth", "isdST", "dsts", "idsc", "sdsc", "Dsth", " dsth", " dest", "bdst", "isdsth", "adst", "adsts", "dda", "sdst", "bdsl", "tdst", "tdsts", "Dsts", "bdsc", " dsts", "dsth", " dsrc", "idsts", "dest", "ldsl", " dda", "idest", "bdda", "ldsc", " dsl"], "dstWidth": [" dstLength", "drcHeight", "dSTwidth", "dgestwidth", " dstwidth", " dSTLength", "dSTExp", "drcwidth", " dSTHeight", "destwidth", "dscWidth", "dgestHeight", "dstswidth", "DstLength", "dgestPath", "destWidth", "DSTLength", "dstwidth", " dSTWidth", "dSTHeight", " dstPath", "dstExp", "dscHeight", "dstHeight", " dscExp", " dscwidth", "dgestWidth", " dstExp", "dscwidth", "DstWidth", "dstsHeight", "dscExp", " dscHeight", "dirstExp", "dStLength", "dSTWidth", "dStWidth", "dstLength", "dSTLength", "dSTPath", "dscPath", "dstPath", "dStwidth", "DSTwidth", "dstsLength", "drcWidth", "dirstWidth", "destLength", "Dstwidth", " dstHeight", "DSTWidth", "DSTHeight", "DstHeight", "dirstHeight", "dStHeight", "destHeight", "drcLength", " dSTwidth", " dscWidth", " dscPath", "dstsWidth", "dirstwidth"], "src_in": ["loc_ins", "src2inc", " src_inc", "loc_inn", "rc_ins", "src_ins", "loc_out", "src2in", "src_out", "src_inn", " src_out", "rc_in", "rc_again", "src_again", "src_inc", "src2out", "loc_in"], "srcW": ["locw", "instW", "locV", " srcH", "instw", " srcWidth", "instH", "srcWidth", "rcL", "sourceW", "instV", "srcL", "instL", "rcWidth", "srcw", "locW", "srcV", " srcV", " srcw", "sourceL", "rcV", "locWidth", "sourceV", "rcH", "rcw", "sourcew", " srcL", "srcH", "rcW"], "xInc": ["xaInc", "xinc", "XInc", "xiInc", " xIncre", "xiinc", "xainc", " xINC", "Xinc", "xiINC", "xaINC", "xiAdd", " xAdd", "xaIncre", "xINC", "XIncre", "xIncre", "xAdd", "XAdd", " xinc", "XINC"], "hLumFilter": ["hLUMMask", "hPlumF", "hElUMMask", "hElUMLayer", "hElumFilter", "hLoughFilter", "hElumMask", "hLUMF", "hLumberF", "hLamFilter", "hLoughFrame", "hPlUMTarget", "hPlumMask", "hElUMFrame", "hPlumTarget", "hElumFrame", "hLUMFrame", "hLoughLayer", "hLumFrame", "hLUMTarget", "hLamF", "hLumberMask", "hPlUMFilter", "hLumTarget", "hLoughMask", "hElUMFilter", "hLUMLayer", "hLumLayer", "hElumLayer", "hLamTarget", "hLUMFilter", "hLamFrame", "hPlumFilter", "hLamMask", "hLumMask", "hLamLayer", "hPlUMMask", "hLumberFilter", "hLumberTarget", "hPlUMF", "hLumF"], "hLumFilterPos": ["hLumFSize", "hLumBufferPos", "hLUMFilterRel", "hLumFilterDef", "hLumFileDef", "hLumGroupRes", "hLUMFPos", "hLumGroupRel", "hLumFilePosition", "hLumbFPos", "hLumFilterRes", "hLumFilterPosition", "hLUMFilterPosition", "hLumBufferRes", "hLumFDef", "hLumbFilterDef", "hLUMFRel", "hLumbFSize", "hLumbFilterPos", "hLumbFilterSize", "hLumBufferSize", "hLumFRel", "hLUMFPosition", "hLumGroupPosition", "hLumGroupPos", "hLumbFilterPosition", "hLumBufferRel", "hLUMFilterRes", "hLumFilterRel", "hLumFileSize", "hLumFPosition", "hLUMFilterPos", "hLumbFPosition", "hLumBufferPosition", "hLumbFDef", "hLumBufferDef", "hLumFPos", "hLUMFRes", "hLumFilePos", "hLumFRes"], "hLumFilterSize": ["hLumFSize", "hLumLimitOffset", "hLumMaskCount", "hLumBufferPos", "hLumBlockLen", "hLUMFilterSize", "hLumBufferStyle", "hLUMFStyle", "hLUMFPos", "hLumBufferLen", "hLumFilterStyle", "hLumbBufferSize", "hLumMaskSize", "hLumFStyle", "hLumBufferCount", "hLumFOffset", "hLumLimitPos", "hLumbBufferCount", "hLumBufferOffset", "hLumFilterCount", "hLumbFilterPos", "hLumbFilterCount", "hLumbFilterSize", "hLumBufferSize", "hLumLimitSize", "hLumBlockSize", "hLumbBufferLen", "hLumMaskPos", "hLumbFilterLen", "hLumbBufferPos", "hLUMFilterPos", "hLUMFSize", "hLumFilterLen", "hLUMFOffset", "hLumMaskLen", "hLUMFilterOffset", "hLumLimitStyle", "hLUMFilterStyle", "hLumFPos", "hLumFilterOffset", "hLumBlockPos", "hLumBlockCount"], "formatConvBuffer": ["formatConVBuff", "formatEnVBuffer", "formatConvBegin", "formatConvertBar", "formatEnVReader", "formatConvCache", "formatConvPtr", "formatConVPtr", "formatConVBuffer", "formatEnfbuffer", "formatConvertSource", "formatConventionBuffer", "formatEnfFile", "formatConvReader", "formatConvertReader", "formatConventionbuffer", "formatConvertBuffer", "formatEnvBegin", "formatConfBuffer", "formatEnvReader", "formatConvertBuff", "formatEnvBar", "formatConvtFile", "formatEnvFile", "formatConVBar", "formatConVFile", "formatEnfBar", "formatConfbuffer", "formatConfFile", "formatEnfBuffer", "formatConvBar", "formatConvpCache", "formatConfCache", "formatConVBegin", "formatConuvPtr", "formatEnvCache", "formatConuvBuff", "formatConVCache", "formatConvSource", "formatEnfSource", "formatConvBuff", "formatConVSource", "formatConvpBuffer", "formatEnVBegin", "formatConVReader", "formatConVbuffer", "formatConfBegin", "formatConvtBuffer", "formatConfBuff", "formatConvertbuffer", "formatEnfBuff", "formatEnvbuffer", "formatConvtbuffer", "formatConvtBuff", "formatConuvBuffer", "formatConuvBegin", "formatConfBar", "formatConfSource", "formatEnVBuff", "formatEnVPtr", "formatEnvPtr", "formatConventionBuff", "formatEnVBar", "formatConvbuffer", "formatConvpBuff", "formatConfPtr", "formatConventionReader", "formatConvpBar", "formatConvFile", "formatEnvBuffer", "formatEnVCache", "formatEnvBuff", "formatEnVbuffer", "formatEnvSource"], "pal": ["app", "scale", "Pal", "val", "bin", "align", "pad", "bl", "as", "local", "pixel", "cell", "al", "cache", "rel", "pp", "p", "opal", "ace", "pl", "ar", "cal", "real", " Pal", "face", "alias", "ass", "plan", "ab", "cale", "conf", "alpha", "li", "isal", "pack"], "isAlpha": ["isalpha", "hasAlpha", "ISAlias", "Isalpha", "hasalpha", " isRa", "areRa", "ISFace", "arealpha", " isalpha", "isaalpha", "areAlias", "hasBeta", "areFace", "IsAlias", " isDelta", "ISAlpha", "IsDelta", "areAlpha", "isAlias", "IsAlpha", " isFace", "isaRa", " isBeta", "hasDelta", "isRa", "isBeta", "isFace", " isAlias", "IsBeta", "isaAlpha", "isaAlias", "ISalpha", "isDelta", "ISBeta"], "toYV12": ["toXv14", "toYF12", "toYv15", "toXV6", "toYYV15", "toYH12", "toYX13", "toYv14", "toYV20", "toYv52", "toYYH13", "toXV12", "toYGV12", "toYX52", "toYv11", "toYYV13", "toYN13", "toYV11", "toXv6", "toYV13", "toYN12", "toYYH15", "toXv13", "toXv12", "toXv11", "toYYV52", "toYv6", "toYX12", "toYYH12", "toYV14", "toYGV6", "toYYH52", "toYGV20", "toYv20", "toYF13", "toYM11", "toYF20", "toYF6", "toYH52", "toXV20", "toYX15", "toYv12", "toYV52", "toYM12", "toYM13", "toYV6", "toYGV13", "toYv13", "toXV11", "toYN14", "toYV15", "toYH15", "toYN11", "toYH13", "toXV14", "toXV13", "toXv20", "toYYV12", "toYM14"], "convertRange": ["Converrange", "convertingrange", "conversionRGB", "ConverRing", "ConvertRing", "pervertedRange", "ConversionRange", "convertingRing", "pervertedrange", "pervertFrame", "convertedrange", "converResource", "conversionRegion", "conpectRange", "convertingRGB", "conformatrange", "convertingRange", "Conversionrange", "convertRing", "conversionRange", "convertedRange", "convertFrame", "ConvertResource", "convertRegion", "conformatRange", "conversionFrame", "conversionrange", "convertrange", "conformatRegion", "pervertRegion", "convertedFrame", "converRing", "conpectRGB", "converrange", "ConversionRGB", "pervertedRegion", "ConvertRange", "pervertRange", "converRange", "pervertrange", "conpectrange", "convertedRegion", "convertRGB", "ConverResource", "convertResource", "pervertedFrame", "ConvertRGB", "conformatFrame", "Convertrange", "ConverRange", "convertingResource"], "src": ["bc", "sb", "fc", "sel", "uc", "support", "config", "sl", "asc", "gl", "impl", "uri", "func", "rin", "rect", "img", "scl", "gb", "secure", "sys", "rob", "stat", "ssl", "sit", "sync", "rc", "cb", "ctx", "supp", "source", "sq", "sc", "comp", "rl", "sub", "sr", "usr", "sur", "inst", "sup", "loc", "rss", "rs", "proc", "st", "lib", "sid", "dest", "rb", "stream", "sn", "href", "feat", "attr", "url", "rg"]}}
{"project": "FFmpeg", "commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "target": 1, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *src_buffer)\n\n{\n\n    AVFilterContext  *ctx = inlink->dst;\n\n    ATempoContext *atempo = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n\n\n    int ret = 0;\n\n    int n_in = src_buffer->nb_samples;\n\n    int n_out = (int)(0.5 + ((double)n_in) / atempo->tempo);\n\n\n\n    const uint8_t *src = src_buffer->data[0];\n\n    const uint8_t *src_end = src + n_in * atempo->stride;\n\n\n\n    while (src < src_end) {\n\n        if (!atempo->dst_buffer) {\n\n            atempo->dst_buffer = ff_get_audio_buffer(outlink, n_out);\n\n            if (!atempo->dst_buffer)\n\n                return AVERROR(ENOMEM);\n\n            av_frame_copy_props(atempo->dst_buffer, src_buffer);\n\n\n\n            atempo->dst = atempo->dst_buffer->data[0];\n\n            atempo->dst_end = atempo->dst + n_out * atempo->stride;\n\n        }\n\n\n\n        yae_apply(atempo, &src, src_end, &atempo->dst, atempo->dst_end);\n\n\n\n        if (atempo->dst == atempo->dst_end) {\n\n            int n_samples = ((atempo->dst - atempo->dst_buffer->data[0]) /\n\n                             atempo->stride);\n\n            ret = push_samples(atempo, outlink, n_samples);\n\n            if (ret < 0)\n\n                goto end;\n\n        }\n\n    }\n\n\n\n    atempo->nsamples_in += n_in;\n\nend:\n\n    av_frame_free(&src_buffer);\n\n    return ret;\n\n}\n", "idx": 18812, "substitutes": {"inlink": ["inlog", " inlog", "outline", "innercall", "innerLink", "innlog", "incstyle", "incmachine", " instyle", "innerlink", "innerline", "outcall", " inLink", " inmachine", "innstyle", "innlink", "innmachine", " incall", "incall", "instyle", "outLink", "inLink", "inmachine", "inclog", "inclink"], "src_buffer": ["source_layer", "rc_buffer", "src2buf", " src_buf", "src00handler", "src_handler", "source_uffer", "rc_queue", " src_queue", "source_source", "src_buf", "src00queue", "rc_cache", "source_buffer", "rc_handler", "src_layer", "src00buffer", "src_source", "src2buffer", "src2queue", "source_queue", "src_queue", "src__queue", "src_reference", "src_buff", "src_cache", "src_uffer", "src__buf", "rc_buff", "src__buffer", "source_reference"], "ctx": ["instance", "init", "btn", "fw", "conf", "cca", "jp", "cus", "ref", "obj", "conn", "rc", "cm", "cf", "cpp", "cb", "anc", "cp", "bc", "loc", "utils", "ctrl", "act", "cas", "Context", "ca", "exec", "cs", "context", "hw", "conv", "pkg", "tx", "ci", "tc", "config", "xc", "cli", "lc", "c", "cmd", "cmp", "cn", "cv", "cc"], "atempo": ["iampa", "tmapo", "impos", "empos", "ormpo", "iempe", "ommpa", "iempo", "edompos", "atemapo", "impi", "idempi", "ommo", "ommppo", "atempa", "ammapo", "adempo", "iampi", "tmpos", "edompo", "tmpi", "amypi", "ormote", "tmote", "atemcho", "impa", "emapo", "temapo", "impo", "tomapo", "temota", "ompi", "iamo", "atemota", "edomota", "immo", "ademota", "dempi", "ammpo", "dempe", "ompos", "atempe", "iampos", "tempo", "adempe", "empi", "immpo", "immpos", "temo", "dempo", "iampe", "ommapo", "omo", "idempo", "amenpi", "tmpo", "amypo", "ymmcho", "mmote", "ommpe", "immote", "idempa", "ymapo", "tempos", "ymmbo", "adempa", "amenpos", "tempa", "atemo", "ademo", "atemppo", "ammpe", "impe", "atembo", "iempa", "mmpos", "ymcho", "demppo", "iempi", "tombo", "emo", "amyo", "iampo", "emanpos", "ademppo", "imo", "ompo", "aimpos", "ymbo", "gampo", "aimo", "gampe", "temote", "atempi", "mmpo", "ammo", "ommpo", "atemote", "tmpa", "edomo", "tomcho", "ameno", "ormapo", "tempi", "amypos", "adempos", "ammpi", "emanpa", "iemo", "gampi", "idempos", "empo", "ammpos", "atempos", "demo", "amenpo", "aimpo", "gampos", "iemapo", "emanpi", "emanpe", "ommpos", "tompo", "ammote", "adempi", "ommpi", "ormpos", "dempos", "ammpa", "iempos", "mmo", "aimapo", "ympo", "emanpo", "ymmapo", "ademote", "ymmpo", "ademapo", "iemote", "tmpe"], "outlink": ["outload", "mainlink", "outline", "offlinked", "outlinks", "againline", "inloop", "offlink", "OutLink", " outLink", "outlinked", " outloop", "offLink", "outLink", " outlinks", "Outline", "againLink", " outdo", "againlink", "outdo", "offdo", "againload", " outload", "againlinks", "Outlink", "outloop", "Outload", " outline", "maindo", " outlinked", "mainlinked", "inlinks", "mainLink", "againloop"], "src": ["uri", "sup", "sit", "sur", "data", "core", "rs", "rest", "dest", "text", "RC", "scene", "rc", "sb", "stream", "cb", "sl", "bc", "loc", "ources", "sel", "sec", "filename", "username", "head", "again", "gb", "rec", "rob", "rib", "sub", "length", "img", "sr", "sc", "ssl", "send", "st", "start", "config", "ource", "req", "cur", "rb", "tmp", "rss", "uc", "url", "rl", "sys", "proc", "inst", "sq", "source", "dist"], "src_end": [" src_ending", "rc_ended", "src_ends", "src0ends", "src0end", " src_ends", " src_close", "src0ending", "src_close", "src_entry", "src_ended", "src_ending", "src0start", "src_start", " src_entry", " src_start", "rc_end", "rc_start"]}}
{"project": "qemu", "commit_id": "94ad5b00a31113ed36b9d03a8db16de5535e90c4", "target": 0, "func": "static void cpu_set_irq(void *opaque, int irq, int level)\n\n{\n\n    CPUState *env = opaque;\n\n\n\n    if (level) {\n\n        CPUIRQ_DPRINTF(\"Raise CPU IRQ %d\\n\", irq);\n\n        env->halted = 0;\n\n        env->pil_in |= 1 << irq;\n\n        cpu_check_irqs(env);\n\n    } else {\n\n        CPUIRQ_DPRINTF(\"Lower CPU IRQ %d\\n\", irq);\n\n        env->pil_in &= ~(1 << irq);\n\n        cpu_check_irqs(env);\n\n    }\n\n}\n", "idx": 24853, "substitutes": {"opaque": ["OPque", "operaque", " opaques", "OPacity", "OPaques", "operaques", "defacity", "oplaques", "opaques", "defaque", "defque", "opercca", "oplcca", "oplaque", "Opaque", "Opaques", "defaques", " opque", " opacity", "opacity", "opque", "opcca", "Opque", "oplque", "operque", "Opcca", "OPaque"], "irq": ["risqs", "rinqt", " irqs", "iref", "iraf", "irque", "irry", "virquest", "risf", "IRqu", "iraq", "virflow", "ironq", "iraQ", "risq", "ireqs", " irf", "rinQ", "irquest", "IRf", "riQ", "ireq", "ierQ", "irflow", "ariq", "iriquest", "iriq", "ierq", "irtq", "ierqual", "irtqual", "rif", "IRq", "irequ", "iraqu", "arique", "ierqt", "irqu", " irry", "riqu", "ironqu", "ironQ", "ireQ", "irqs", "irtQ", "irf", "ariflow", "rinqual", "irQ", "IRQ", "ironf", "ariquest", "virque", "virq", "risry", "riq", "rinq", "irery", "irqt", "irique", "iriflow", "irqual", "irtqt"], "level": ["code", "thread", "scope", "lvl", "cost", "name", "enc", "weight", "style", "letter", "type", "id", "url", "method", "depth", "key", "point", "str", "path", "levels", "loc", "wl", "clean", "mode", "parent", "inc", "length", "round", "loop", "stage", "wall", "limit", "index", "coll", "full", "Level", "vel", "where", "layer"], "env": ["her", "fen", "code", "args", "console", "np", "er", "scope", "exc", "engine", "server", "context", "enc", "qa", "queue", "ec", "en", "config", "conf", "chal", "style", "dict", "ev", "ah", "ea", "inet", "environment", "loader", "ne", "end", "db", "e", "el", "password", "esi", "err", "ef", "nc", "viron", "que", "edge", "ctx", "here", "energy", "eu", "eni", "cache", "erv", "esp", "oa", "ench", "vm", "erb", "req", "forge", "conn", "net", "core", "v", "enh", "et", "vel", "equ", "eng"]}}
{"project": "qemu", "commit_id": "a369da5f31ddbdeb32a7f76622e480d3995fbb00", "target": 0, "func": "void alpha_pci_vga_setup(PCIBus *pci_bus)\n\n{\n\n    switch (vga_interface_type) {\n\n#ifdef CONFIG_SPICE\n\n    case VGA_QXL:\n\n        pci_create_simple(pci_bus, -1, \"qxl-vga\");\n\n        return;\n\n#endif\n\n    case VGA_CIRRUS:\n\n        pci_cirrus_vga_init(pci_bus);\n\n        return;\n\n    case VGA_VMWARE:\n\n        if (pci_vmsvga_init(pci_bus)) {\n\n            return;\n\n        }\n\n        break;\n\n    }\n\n    /* If VGA is enabled at all, and one of the above didn't work, then\n\n       fallback to Standard VGA.  */\n\n    if (vga_interface_type != VGA_NONE) {\n\n        pci_vga_init(pci_bus);\n\n    }\n\n}\n", "idx": 11843, "substitutes": {"pci_bus": ["pki_bridge", "pdi_boot", "pci__system", "pci_system", "pci__bus", "pciADboot", "pciAMboot", "pcu_usb", "pcu_boot", "pcm_bus", "pdi_usb", "pki_system", "pcm_connection", "pciADusb", "pcm_boot", "pci_us", "pci__bridge", "pcm_system", "pci_usb", "pcu_bus", "pci__boot", "pki_bus", "pci_connection", "pciAMinterface", "pcu_interface", "pciAMusb", "pdi_bus", "pci_bridge", "pciADbus", "pciAMbus", "pci_boot", "pki_boot", "pciADconnection", "pdi_us", "pci_interface", "pcm_usb"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stq_be_phys(target_phys_addr_t addr, uint64_t val)\n\n{\n\n    val = cpu_to_be64(val);\n\n    cpu_physical_memory_write(addr, &val, 8);\n\n}\n", "idx": 20282, "substitutes": {"addr": ["target", "ref", "adr", "config", "kt", "arg", "eth", "amd", "align", "host", "pc", "node", "device", "layer", "ld", "pos", "address", "data", "ad", "p", "ace", "point", "slot", "index", "ar", "cpu", "rt", " address", "ptr", "x", "src", "slice", "mx", "pointer", "offset", "base", "attr", "inter"], "val": ["grad", "sel", "ee", "fail", "ref", "sl", "valid", "ind", "db", "arg", "key", "cond", "tx", "bin", "al", "pre", "data", "p", "arr", "vals", "unit", "count", "slot", "py", "el", "index", "aval", "cal", "b", "pid", "mem", "vol", "fl", "len", "test", "loc", "VAL", "base", "Val", "lib", "v", "eval", "all", "pt", "x", "value"]}}
{"project": "qemu", "commit_id": "048c74c4379789d03c857cea038ec00d95b68eaf", "target": 0, "func": "static int rtc_initfn(ISADevice *dev)\n\n{\n\n    RTCState *s = DO_UPCAST(RTCState, dev, dev);\n\n    int base = 0x70;\n\n    int isairq = 8;\n\n\n\n    isa_init_irq(dev, &s->irq, isairq);\n\n\n\n    s->cmos_data[RTC_REG_A] = 0x26;\n\n    s->cmos_data[RTC_REG_B] = 0x02;\n\n    s->cmos_data[RTC_REG_C] = 0x00;\n\n    s->cmos_data[RTC_REG_D] = 0x80;\n\n\n\n    rtc_set_date_from_host(s);\n\n\n\n    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        s->coalesced_timer =\n\n            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);\n\n#endif\n\n    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);\n\n    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);\n\n\n\n    s->next_second_time =\n\n        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;\n\n    qemu_mod_timer(s->second_timer2, s->next_second_time);\n\n\n\n    register_ioport_write(base, 2, 1, cmos_ioport_write, s);\n\n    register_ioport_read(base, 2, 1, cmos_ioport_read, s);\n\n\n\n    register_savevm(\"mc146818rtc\", base, 1, rtc_save, rtc_load, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        register_savevm(\"mc146818rtc-td\", base, 1, rtc_save_td, rtc_load_td, s);\n\n#endif\n\n    qemu_register_reset(rtc_reset, s);\n\n    return 0;\n\n}\n", "idx": 3838, "substitutes": {"dev": ["serial", "test", "server", "cam", "def", "dd", "mod", "device", "dim", "data", "r", "development", "ver", "d", "devices", "priv", "grad", "de", "dom", " Dev", "DEV", "Dev", "m", "ve", "info", "bug", "temp", "pub", "gu", "w", "prom", "e", "dm", "f", "conf", "Device", " device", "die", "driver", "v", "o", "ev", "rad", "dem", "error", "pro", "engine", "debug", "mode"], "s": ["sg", "js", "qs", "n", "sites", "sl", "g", "ses", "ls", "sf", "storage", "sie", "self", "f", "set", "sys", "u", "changes", "an", "fs", "spec", "ts", "sb", "y", "uns", "sv", "request", "sets", "p", "state", "e", "lines", "conf", "as", "v", "less", "su", "serv", "S", "t", "session", "os", "site", "ks", "its", "hs", "sym", "plugins", "ssl", "cs", "ss", "rs", "a", "new", "r", "is", "ins", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "south", "o", "sim", "si", "server", "service", "http", "d", "ms", "side", "params", "details", "sync", "status", "l", "services", "w", "features", "stats", "b"]}}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint8(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx8 : \"%\" PRIu8;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 1994, "substitutes": {"dev": ["serial", "def", "dd", "gr", "mod", "device", "sd", "data", "d", "ver", "sh", "priv", "prof", "de", "grad", "dom", "comp", "Dev", "proc", "err", "dt", "md", "ch", "tr", "w", "private", "self", "attr", "conf", "br", "wd", "rad", "dem", "ev", "iv", "od", "inst", "req", "pro", "debug", "gd"], "prop": ["property", "name", "ctx", "def", "device", "Prop", "data", "prot", "r", "type", "priv", "pb", "op", "tmp", "pos", "proc", "info", "properties", "pointer", "p", "phy", "pr", "pred", "f", "ref", "attr", "obj", "pro", "lit", "val", "root", "pt", "part"], "str": ["test", "arg", "name", "ext", "Str", "spec", "rs", "expr", "data", "r", "strings", "sp", "sl", "cur", "arr", "enc", "hr", "stri", "code", "fr", "err", "cr", "tr", "st", "pr", "br", "text", "ctr", "attr", "obj", "sec", "sr", "s", "val", "pt", "STR"], "ptr": ["dr", "fd", "src", "offset", "inter", "prot", "tty", "r", "loc", "sp", "buf", "py", "pos", "spr", "proc", "fp", "nt", "fr", "err", "tr", "pointer", "func", "st", "pad", "p", "pr", "Ptr", "len", "length", "ref", "br", "t", "inst", "addr", "rt", "val", "pt"], "fmt": ["cnt", "cmt", "Fformat", "ftt", "FMT", "hmt", "cfformat", "fxmt", "Fmd", " fformat", "Fnt", " fmd", "cfmt", "hpr", "fxpr", "fnt", "Fpr", "fmd", "fMT", "Fmt", "cfprintf", "Ftt", "cfMT", "cMT", "hMT", "fpr", "fxtt", "Fprintf", " fMT", "fformat", "cmd", "fxMT", " fnt", "htt"]}}
{"project": "FFmpeg", "commit_id": "8a57ca5c6a1c0ad28afa7ea6f824981e6761cce1", "target": 0, "func": "static int aasc_decode_frame(AVCodecContext *avctx,\n\n                              void *data, int *data_size,\n\n                              AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    AascContext *s = avctx->priv_data;\n\n    int compr, i, stride;\n\n\n\n    s->frame.reference = 3;\n\n    s->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &s->frame)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    compr = AV_RL32(buf);\n\n    buf += 4;\n\n    buf_size -= 4;\n\n    switch (avctx->codec_tag) {\n\n    case MKTAG('A', 'A', 'S', '4'):\n\n        bytestream2_init(&s->gb, buf - 4, buf_size + 4);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    case MKTAG('A', 'A', 'S', 'C'):\n\n    switch(compr){\n\n    case 0:\n\n        stride = (avctx->width * 3 + 3) & ~3;\n\n        for(i = avctx->height - 1; i >= 0; i--){\n\n            if(avctx->width*3 > buf_size){\n\n                av_log(avctx, AV_LOG_ERROR, \"Next line is beyond buffer bounds\\n\");\n\n                break;\n\n            }\n\n            memcpy(s->frame.data[0] + i*s->frame.linesize[0], buf, avctx->width*3);\n\n            buf += stride;\n\n            buf_size -= stride;\n\n        }\n\n        break;\n\n    case 1:\n\n        bytestream2_init(&s->gb, buf, buf_size);\n\n        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown compression type %d\\n\", compr);\n\n        return -1;\n\n    }\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Unknown FourCC: %X\\n\", avctx->codec_tag);\n\n        return -1;\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n", "idx": 26819, "substitutes": {"avctx": ["afcas", "AVlc", "avalconsole", "navcontext", "afkb", "avcontext", "afcontext", "avectx", "ajctx", "ajcmd", "ajcmp", "avekb", "avct", "akcca", "AVsync", "afxc", "abcmp", "akctx", "akcontext", "navlc", "ajcomponent", "ajxc", "afcca", "AVcontext", "afconsole", "avcu", "abcf", "afsync", "avcoll", "avalct", "avcca", "abca", "abcontext", "avconsole", "AVconfig", "avalcontext", "aftx", "avaltx", "afctx", "avconfig", "avalctx", "afca", "avecoll", "abctx", "navsync", "AVctx", "avxc", "aveca", "akcb", "ajcb", "avcb", "avecb", "avcf", "avelc", "ajtx", "avalcf", "afproc", "akcmd", " avcb", "avalcmp", "avecontext", "abproc", "avcmp", "AVcu", "aucoll", "avtx", "aucontext", "akkb", "avsync", "afcf", "avca", "auctx", "avecu", "afcb", "aflc", "abconn", " avxc", "avconn", "afcoll", "afconn", "ajcontext", "avalcca", "avecf", "ajcas", "abct", "afcmd", "afct", "ajproc", "avecca", "akcas", "avkb", "auconn", "aveconfig", "afcu", "abconfig", "aveconn", "avcomponent", "avalcomponent", "afcomponent", "AVconsole", " avcontext", "avproc", "avlc", "avcas", "avcmd", "navctx", "avalconfig", "afcmp", "ajcca", "afconfig"], "data": ["load", "Data", "uf", "body", "code", "slice", "margin", "bin", "p", "m", "batch", "frame", "empty", "image", "d", "buffer", "queue", "base", "media", "read", "config", "next", "reader", "pad", "feed", "open", "message", "padding", "input", "dat", "start", "offset", "output", "parent", "size", "cache", "response", "block", "length", "buff", "window", "f", "bytes", "index", "DATA", "content", "memory", "alpha", "result", "connection", "val"], "data_size": ["data___number", "data___len", "data___count", "data_count", " data_count", "data_number", " data_number", "data_len", " data_len", "data___size"], "avpkt": ["avppKT", "afpct", "avpcf", "avPkt", "AVvpKT", "avPacket", "avpbk", "avppk", "abcpacket", "avtkt", "afpacket", "affacket", "abpka", "abpkt", "avfct", "affk", "affkt", "avPk", "abcpkt", "AVvpkt", "avcpk", "avpka", "abpacket", "avpbcf", "abcpct", "avvpk", "AVpk", "avpk", "affct", "avvpkt", "avpbKT", "AVpKT", "avcpacket", "avcpkt", "avtct", "avcpka", "avppkt", "avPct", "abcpka", "avpacket", "abpct", "avfkt", "afpk", "avpbkt", "AVvpk", "avfka", "avpKT", "avpct", "AVvpcf", "avvpKT", "avfk", "AVpcf", "avvpcf", "avppcf", "avfacket", "afpkt", "avtacket", "avcpct", "avtka", "AVpkt"], "buf": ["ref", "seq", "uf", "font", "ru", "bag", "done", "uc", "p", "b", "batch", "wb", "c", "cv", "Buff", "bb", "vec", "buffer", "queue", "text", "rb", "config", "br", "img", "prop", "cb", "ab", "bc", "bd", "port", "proc", "pad", "orig", "feed", "aux", "home", "ff", "cmd", "tmp", "cap", "la", "loc", "box", "ctx", "cur", "fb", "cf", "cp", "utf", "alloc", "Buffer", "feat", "rc", "cas", "length", "buff", "array", "f", "src", "fp", "func", "v", "pack", "block", "wa", "fd"], "s": ["S", "side", "sc", "ses", "rs", "sys", "args", "ss", "p", "c", "ns", "context", "d", "ts", "sq", "ds", "ms", "conf", "us", "ps", "sg", "ins", "ks", "sync", "self", "su", "is", "e", "cs", "gs", "es", "o", "session", "spec", "l", "si", "sym", "hs", "aws", "os", "services", "sa", "sup", "as", "ls", "f", "service", "js", "qs", "fs", "j", "y", "a", "t", "r", "ops", "parts", "ssl", "sv", "in", "its", "g"], "compr": ["corpol", "corpr", "c", "compre", "ocompro", "x", "cumpr", "buffer", "imbr", "compro", "impre", "comppol", "compPr", "imPr", "ocompr", "all", "comppre", "comppro", "cumpol", "impr", " compre", "compol", "combr", "comPR", "corbr", "cumPR", "corPR", "comppr", "ocompre", "compPR", " combr", "cumbr", " compro", "compbr", "r", "_", "comPr", " comPr", "g"], "i": ["abi", "slice", "k", "z", "ie", "p", "b", "dim", "c", "m", "d", "x", "ti", "mi", "phi", "qi", "io", "u", "e", "gi", "li", "ji", "o", "zi", "multi", "xi", "start", "uri", "ii", "bi", "si", "ai", "ini", "ni", "di", "ci", "fi", "vi", "lc", "h", "f", "I", "ki", "y", "n", "j", "index", "ip", "t", "a", "v", "iu", "r", "pi", "mu", "ind", "ui", "l", "hi", "g"], "stride": [" strided", "strue", "Strider", "Strie", "STRider", "strise", "yride", "divite", "STRide", "divide", "strie", "STRise", "divise", "trince", "yrince", "Strite", " strIDE", " strie", "yrided", "drite", "Strided", "strite", "trip", " strince", "STRIDE", " strue", "trided", "STRided", "strIDE", "STRite", " strise", "strip", "dride", "strider", " strip", "Stride", " strite", "tride", "drider", "drie", "strince", "strided", "STRue", "yrip", " strider", "divIDE", "Strue"]}}
{"project": "qemu", "commit_id": "45eb768c706d3a5fbe55224c589e8b4e252781d9", "target": 0, "func": "static void pci_init_mask_bridge(PCIDevice *d)\n\n{\n\n    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and\n\n       PCI_SEC_LETENCY_TIMER */\n\n    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);\n\n\n\n    /* base and limit */\n\n    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;\n\n    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;\n\n    pci_set_word(d->wmask + PCI_MEMORY_BASE,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,\n\n                 PCI_MEMORY_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,\n\n                 PCI_PREF_RANGE_MASK & 0xffff);\n\n\n\n    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */\n\n    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);\n\n\n\n    /* Supported memory and i/o types */\n\n    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;\n\n    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n    pci_word_test_and_set_mask(d->config + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_64);\n\n\n\n/* TODO: add this define to pci_regs.h in linux and then in qemu. */\n\n#define  PCI_BRIDGE_CTL_VGA_16BIT\t0x10\t/* VGA 16-bit decode */\n\n#define  PCI_BRIDGE_CTL_DISCARD\t\t0x100\t/* Primary discard timer */\n\n#define  PCI_BRIDGE_CTL_SEC_DISCARD\t0x200\t/* Secondary discard timer */\n\n#define  PCI_BRIDGE_CTL_DISCARD_STATUS\t0x400\t/* Discard timer status */\n\n#define  PCI_BRIDGE_CTL_DISCARD_SERR\t0x800\t/* Discard timer SERR# enable */\n\n/*\n\n * TODO: Bridges default to 10-bit VGA decoding but we currently only\n\n * implement 16-bit decoding (no alias support).\n\n */\n\n    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_PARITY |\n\n                 PCI_BRIDGE_CTL_SERR |\n\n                 PCI_BRIDGE_CTL_ISA |\n\n                 PCI_BRIDGE_CTL_VGA |\n\n                 PCI_BRIDGE_CTL_VGA_16BIT |\n\n                 PCI_BRIDGE_CTL_MASTER_ABORT |\n\n                 PCI_BRIDGE_CTL_BUS_RESET |\n\n                 PCI_BRIDGE_CTL_FAST_BACK |\n\n                 PCI_BRIDGE_CTL_DISCARD |\n\n                 PCI_BRIDGE_CTL_SEC_DISCARD |\n\n                 PCI_BRIDGE_CTL_DISCARD_SERR);\n\n    /* Below does not do anything as we never set this bit, put here for\n\n     * completeness. */\n\n    pci_set_word(d->w1cmask + PCI_BRIDGE_CONTROL,\n\n                 PCI_BRIDGE_CTL_DISCARD_STATUS);\n\n    d->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK;\n\n    d->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK;\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_BASE,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n    pci_word_test_and_set_mask(d->cmask + PCI_PREF_MEMORY_LIMIT,\n\n                               PCI_PREF_RANGE_TYPE_MASK);\n\n}\n", "idx": 1616, "substitutes": {"d": ["dr", "ld", "fd", "dn", "da", "dd", "pd", "sd", "dh", "dad", "data", "ad", "n", "xd", "dl", "di", "id", "dict", "de", "dom", "i", "g", "j", "m", "sync", "dt", "ds", "md", "config", "z", "dc", "ind", "c", "p", "dos", "l", "e", "f", "bd", "cd", "dj", "die", "wd", "driver", "b", "plugin", "t", "od", "session", "vd", "td", "nd", "dat", "D", "gd", "db", "done"]}}
{"project": "FFmpeg", "commit_id": "e89f58810d0d508552089495781e2a70e95edb99", "target": 0, "func": "static void check_default_settings(AVCodecContext *avctx)\n\n{\n\n    X264Context *x4 = avctx->priv_data;\n\n\n\n    int score = 0;\n\n    score += x4->params.analyse.i_me_range == 0;\n\n    score += x4->params.rc.i_qp_step == 3;\n\n    score += x4->params.i_keyint_max == 12;\n\n    score += x4->params.rc.i_qp_min == 2;\n\n    score += x4->params.rc.i_qp_max == 31;\n\n    score += x4->params.rc.f_qcompress == 0.5;\n\n    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;\n\n    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;\n\n    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;\n\n    if (score >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Default settings detected, using medium profile\\n\");\n\n        x4->preset = av_strdup(\"medium\");\n\n        if (avctx->bit_rate == 200*1000)\n\n            avctx->crf = 23;\n\n    }\n\n}\n", "idx": 22093, "substitutes": {"avctx": ["mpctx", "attcontext", "evca", "autcms", "Avcf", "AVcmp", "afca", "autctx", "afcf", "akcn", "afcn", "afcmp", "Avjp", "afctx", "AVcontext", "evcontext", "avcf", "mpcontext", "avca", "attcms", "akcontext", "afcms", "Avcontext", "AVcms", "akctx", "akcms", " avjp", "mpca", "avcontext", " avcf", "attcmp", "afjp", "evcmp", "avcms", " avcn", "evctx", "autcontext", " avcms", "avcmp", "Avctx", "afcontext", "AVctx", "autcmp", " avcontext", "avjp", "avcn", "mpcmp", "attctx"], "x4": [" x14", "f2", "yfour", "ex6", "i72", "cross384", "xi384", "wa54", " x484", "y84", " x24", "xi484", "x24", "pfour", "cross4", "ex004", "x2004", "cross24", "y2", "rx4", "i004", "q72", "crossfour", " x104", "wa004", "u004", "xoutput", "u04", "exfour", "q2004", " x40", "ax2004", "ffour", "ax04", "ax4", "work84", "ax6", "wa104", "X4", "f4", "wa4", "p4", "ex4", "f04", "viewoutput", "axfour", "Xfour", "q4", "X14", "p104", "view4", " x54", "ax104", "x6", "p40", "y2004", "qfour", "X40", "rx40", "cross6", "x14", " x004", "xi400", "x54", "u6", "cross400", " x6", "view484", " x44", "workfour", "cross104", "x2", "cross54", "cross004", " x04", " xoutput", "ax40", "x04", "u4", "work2", "f14", "i4", "ifour", "q004", "y4", "u72", " x2", "x104", "x484", "ufour", "x40", "x004", "X2", "x44", "X84", "x384", "work4", "x84", "xi4", "xfour", "x72", "xi14", "view14", "rxfour", "xioutput", " x400", " xfour", "rx44", "x400", " x384", "X44", "xi24", "f6"]}}
{"project": "FFmpeg", "commit_id": "6d24231e504f71a76a8fabe87c8d7cfa826da75a", "target": 0, "func": "static int raw_init_encoder(AVCodecContext *avctx)\n\n{\n\n    avctx->coded_frame = (AVFrame *)avctx->priv_data;\n\n    avctx->coded_frame->pict_type = FF_I_TYPE;\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->codec_tag = findFourCC(avctx->pix_fmt);\n\n    return 0;\n\n}\n", "idx": 10410, "substitutes": {"avctx": ["aucu", "aveobj", "appcontext", "avcmp", "afctx", "akcmp", "avobj", "avalctx", "avalcontext", "avelc", "appcu", "appqa", "AVqa", "ajconfig", "afcmp", "akca", "avectx", "avcp", "auctx", "avcf", "avecu", "AVcmp", "AVca", "avalcf", "AVcontext", "avcu", "afcf", "avedc", "afcu", "avdc", "aveconfig", "aflc", "AVlc", "ajctx", "aucp", "afconfig", "ajcontext", "AVctx", "avlc", "avconfig", "avcontext", "appctx", "ajcf", "akctx", "avctrl", "avecp", "avca", "ajdc", "afca", "avecf", "afqa", "afdc", "avalobj", "avecontext", "aucontext", "aveqa", "afcontext", "akcontext", "avqa", "ajctrl", "afcp", "avectrl", "afctrl", "afobj"]}}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int idcin_decode_init(AVCodecContext *avctx)\n\n{\n\n    IdcinContext *s = avctx->priv_data;\n\n    int i, j, histogram_index = 0;\n\n    unsigned char *histograms;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the Huffman tables make it */\n\n    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  Id CIN video: expected extradata size of %d\\n\", HUFFMAN_TABLE_SIZE);\n\n        return -1;\n\n    }\n\n\n\n    /* build the 256 Huffman decode trees */\n\n    histograms = (unsigned char *)s->avctx->extradata;\n\n    for (i = 0; i < 256; i++) {\n\n        for(j = 0; j < HUF_TOKENS; j++)\n\n            s->huff_nodes[i][j].count = histograms[histogram_index++];\n\n        huff_build_tree(s, i);\n\n    }\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 12305, "substitutes": {"avctx": ["afcca", "AVconfig", "AVpc", "AVcmd", "abcontext", "Avcontext", "evctx", "AVcmp", "avca", "Avctx", "ajcu", " avcca", " avcf", "ajcontext", "avcmp", "abcmp", "abpkg", "avepkg", "afcf", " avpc", "avcf", "evcci", "AVcontext", "avecu", "AVca", "avectx", "vercontext", "abcu", "aveca", "AVcu", "afcu", "abconfig", "Avpc", "Avca", "afcmp", "evcu", "evcf", " avca", "AVcf", "vercf", "ajctx", "afcontext", "afconfig", "avcmd", "avecci", "abcf", "avcu", "ajcmd", " avcontext", "avcontext", "avecf", "verctx", "ajcmp", "afctx", "avpc", "afcmd", "avcci", "AVctx", "avecontext", " avcci", "avconfig", "ajcf", " avcu", "avpkg", "abctx", "vercca", "ajpkg", "avcca"], "s": ["rs", "qs", "new", "js", "si", "server", "ps", "spec", "c", "is", "sv", "states", "aws", "args", "south", "m", "self", "d", "t", "sync", "sg", "fs", "sym", "g", "cs", "es", "full", "session", "storage", "b", "sf", "ns", "sa", "space", "ks", "sys", "parts", "service", "os", "sets", "opens", "o", "e", "sec", "http", "sb", "f", "services", "ls", "comments", "ctx", "ses", "a", "S", "settings", "sq", "v", "conf", "ss", "p", "se", "n", "gs", "xs", "stats", "ssl", "ds", "src", "su", "ts", "us"], "i": ["qi", "it", "ui", "adi", "m", "I", "d", "ai", "ni", "xi", "jp", "iu", "ini", "gi", "id", "a", "io", "oi", "api", "l", "ci", "ki", "x", "di", "si", "ie", "ii", "v", "vi", "uri", "yi", "u", "ind", "z", "p", "e", "fi", "info", "mini", "mi", "k", "li", "b", "ix", "multi", "n", "f", "ip", "c", "eni", "ji", "pi", "bi", "ri", "zi", "y", "ij", "index", "start"], "j": ["jj", "uj", "adj", "qi", "m", "ch", "aj", "kj", "ja", "jp", "l", "xi", "oj", "name", "g", "dj", "h", "di", "js", "si", "ie", "ii", "key", "bj", "v", "job", "o", "obj", "z", "ind", "jit", "p", "e", "u", "note", "k", "li", "b", "ix", "n", "jo", "jl", "jc", "je", "ji", "q", "J", "pr", "y", "ij", "index"], "histograms": ["historyograms", "historyures", "histrams", "gregographies", "thambers", "historyobs", "thobs", "rhograms", " histambers", " histros", "histores", "historyros", " histrams", "gregograms", "histobs", "histambers", "rhores", "thograms", " histores", "thros", "rhures", "historyambers", "historyographies", "histros", "historyores", "histographies", " histobs", "rhographies", "gregrams", "histures", " histures", "historyrams", "gregambers", " histographies"]}}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "void readline_show_prompt(ReadLineState *rs)\n\n{\n\n    monitor_printf(rs->mon, \"%s\", rs->prompt);\n\n    monitor_flush(rs->mon);\n\n    rs->last_cmd_buf_index = 0;\n\n    rs->last_cmd_buf_size = 0;\n\n    rs->esc_state = IS_NORM;\n\n}\n", "idx": 12663, "substitutes": {"rs": ["RC", "args", "Rs", "rr", "acs", "rss", "as", "hr", "rd", "bs", "rc", "ins", "pc", "airs", "rates", "rics", "ra", "cs", "req", "hs", "rg", "sw", "sr", "str", "rows", "ros", "ras", "ps", "ss", "cr", "ms", "mr", "ris", "rb", "rx", "ars", "RS", "gs", "arts", "acks", "spec", "ans", "xs", "ats", "ro", "rys", "stats", "results", "rt", "ack", "r", "ds", "pr", "src", "ls", "dr", "res", "ts", "ks"]}}
{"project": "qemu", "commit_id": "068593deea6cc61b06243a33c7fcfadb1650b654", "target": 1, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    } else {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if (dest != (src + 1)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version crossing pages with byte accesses */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 12946, "substitutes": {"env": ["forge", "proc", "en", "context", "enh", "esp", "queue", "qa", "enc", "ea", "ench", "config", "cdn", "priv", "iv", "eu", "ah", "style", "kn", "er", "vm", "init", "gear", "server", "v", "conn", "np", "console", "loader", "energy", "e", "equ", "viron", "exc", "info", "engine", "buf", "net", "eng", "tern", "her", "qt", "Environment", "assets", "dep", "export", "eni", "shell", "dt", "here", "atten", "que", "exec", "db", "ev", "vel", "ec", "chal", "stack", "hess", "environment", "el", "fen", "opt", "ctx", "esi", "esm"], "l": ["ln", "m", "nl", "lin", "d", "fl", "t", "level", "lc", "g", "source", "dl", "lp", "h", "x", "lang", "lit", "loc", "v", "o", "ul", "w", "layer", "ll", "la", "p", "lr", "kl", "z", "u", "s", "e", "li", "k", "b", "j", "L", "n", "f", "length", "line", "rl", "c", "shell", "url", "il", "ol", "lu", "ell", "sl", "ls", "al", "lb", "el", "len"], "dest": ["future", "proc", "dist", "delete", "priv", "bound", "other", "loc", "dev", "temp", "pl", "end", "attr", "text", "transform", "Dest", "class", "prop", "destroy", "st", "comb", "south", "head", "vision", "done", "slice", "d", "seed", "cdn", "home", "sup", "lc", "front", "lower", "di", "txt", "dir", "session", "grad", "img", "resource", "du", "data", "wb", "b", "inst", "origin", "url", "route", "gen", "cont", "uv", "wd", "path", "gz", "config", "again", "source", "null", "lit", "secure", "master", "output", "desc", "dep", "diff", "usr", "uc", "tmp", " destination", "shift", "name", "ident", "later", "v", "gl", "de", "feat", "sign", "trans", "store", "dat", "dc", "norm", "target", "ssl", "rest", "coord", "opt", "start"], "src": ["rib", "proc", "remote", "bc", "dist", "fl", "low", "image", "sth", "project", "gin", "loc", "ul", "rb", "cb", "sn", "sc", "sl", "sur", "sub", "ruby", "st", "vision", "slice", "sync", "rc", "iv", "sup", "lc", "front", "req", "sr", "img", "resource", "s", "b", "inst", "length", "url", "r", "ource", "support", "username", "filename", "sys", "gz", "config", "source", "null", "lit", "gn", "view", "download", "sec", "desc", "sb", "gb", "rl", "rob", "sh", "SOURCE", "sel", "cur", "bl", "RC", "connect", "uc", "hl", "stream", "back", "uri", "gl", "feat", "nil", "target", "ssl", "rest", "start"], "i": ["hi", "qi", "it", "ui", "m", "I", "d", "t", "ni", "ai", "xi", "id", "ini", "gi", "iu", "my", "io", "mu", "ci", "x", "di", "si", "ie", "ii", "v", "uri", "o", "yi", "u", "z", "p", "e", "fi", "mi", "li", "b", "ix", "j", "L", "n", "f", "phi", "ti", "ip", "c", "ji", "pi", "bi", "ri", "zi", "y", "index"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_frame(int sig, struct emulated_sigaction *ka,\n\n\t\t\ttarget_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t           && current->exec_domain->signal_invmap\n\n\t\t           && sig < 32\n\n\t\t           ? current->exec_domain->signal_invmap[sig]\n\n\t\t           : */ sig),\n\n\t\t          &frame->sig);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tsetup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\tif (TARGET_NSIG_WORDS > 1) {\n\n\t\terr |= __copy_to_user(frame->extramask, &set->sig[1],\n\n\t\t\t\t      sizeof(frame->extramask));\n\n\t}\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is popl %eax ; movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb858, (short *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_sigreturn, (int *)(frame->retcode+2));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+6));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 24720, "substitutes": {"sig": ["nsigma", "Sig", " sigma", "asigma", "gigma", "setsigh", "nslic", "pigh", " slic", "setsigs", "slic", " sigh", "Slic", "gib", "psigh", "SIG", "pigs", "setsigma", "sigs", "asig", "nsigh", " sib", "psigma", "pib", "psig", "nsIG", "sigma", "asigh", "sIG", "Sigs", "psigs", "pig", "setsig", "sigh", "pIG", "nsig", "gigs", "nsigs", "sib", " sIG", " sigs", "asigs", "pigma", "gig"], "ka": ["sc", "pa", "kernel", "qua", "cca", "ana", "va", "ta", "ama", "ae", "qa", "ket", "ia", "aka", "ea", "kb", "ua", "asa", "ma", "ba", "sta", "la", "eka", "ker", "Ka", "KA", "ko", "ai", "LA", "ctx", "ga", "cha", "oa", "sci", "sa", "ca", "ki", "au", "java", "na", "da", "ha", "kee", "ke", "ku", "kl", "ya", "ja", "kt"], "set": ["ner", "gen", "setting", "iss", "section", "parse", "context", "se", "SET", "test", "base", "send", "en", "config", "ise", "lex", "export", "def", "state", "end", "sync", "op", "sche", "store", "unit", "site", "el", "sets", "get", "dat", "start", "session", "spec", "loc", "kit", "sign", "ets", "stat", "vert", "setup", "Set", "update", "net", "ha", "init", "ind", "ex", "settings", "pack", "reset", "tx", "et", "ut", "ze"], "env": ["fen", "her", "etta", "exc", "shell", "enc", "chal", "gear", "export", "dict", "inet", "ne", "el", "ef", "ini", "dt", "define", "eq", "ette", "core", "et", "vel", "er", "engine", "me", "qt", "ec", "en", "Environment", "enter", "vag", "eni", "ench", "oa", "eh", "stage", "enh", "que", "equ", "gui", "ep", "args", "np", "console", "scope", "context", "global", "ev", "ah", "ea", "db", "e", "cfg", "session", "po", "init", " environment", "anne", "ze", "esm", "iss", "config", "ise", "environment", "ey", "esi", "dat", "viron", "ctx", "eu", "ext", "net", "conn", "eng"], "frame": ["build", "element", "call", "thread", "fe", "face", "module", "frames", "next", "ne", "nil", "el", "tick", "rame", "object", "define", "sequence", "cf", "game", "f", "Frame", "draw", "document", "val", "processor", "code", "body", "slice", "ock", "none", "b", "play", "c", "scene", "def", "state", "cycle", "fr", "boot", "line", "point", "shape", "update", "stage", "event", "block", "que", "ce", "file", "load", "node", "zone", "gen", "shot", "scope", "section", "parse", "context", "function", "data", "trace", "up", "za", "sche", "orig", "e", "step", "cfg", "message", "session", "fb", "setup", "fi", "view", "fake", "init", "plate", "ke", "lock", "ze", "fram", "framework", "seq", "position", "image", "dr", "raise", "style", "config", "ise", "figure", "feature", "flow", "die", "cpu", "sample", "vert", "iframe", "runner", "ind", "ace", "range", "show"]}}
{"project": "FFmpeg", "commit_id": "c9f6eab184cac379c7a44d5899979165798d45d4", "target": 1, "func": "static av_cold int ac3_decode_init(AVCodecContext *avctx)\n\n{\n\n    AC3DecodeContext *s = avctx->priv_data;\n\n    s->avctx = avctx;\n\n\n\n    ff_ac3_common_init();\n\n    ac3_tables_init();\n\n    ff_mdct_init(&s->imdct_256, 8, 1, 1.0);\n\n    ff_mdct_init(&s->imdct_512, 9, 1, 1.0);\n\n    ff_kbd_window_init(s->window, 5.0, 256);\n\n    dsputil_init(&s->dsp, avctx);\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    av_lfg_init(&s->dith_state, 0);\n\n\n\n    /* set scale value for float to int16 conversion */\n\n    s->mul_bias = 32767.0f;\n\n\n\n    /* allow downmixing to stereo or mono */\n\n    if (avctx->channels > 0 && avctx->request_channels > 0 &&\n\n            avctx->request_channels < avctx->channels &&\n\n            avctx->request_channels <= 2) {\n\n        avctx->channels = avctx->request_channels;\n\n    }\n\n    s->downmixed = 1;\n\n\n\n    /* allocate context input buffer */\n\n    if (avctx->error_recognition >= FF_ER_CAREFUL) {\n\n        s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!s->input_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n    return 0;\n\n}\n", "idx": 8171, "substitutes": {"avctx": ["akcontext", "verctl", " avcf", " avctr", "awctx", "afca", "ovtx", "evcontext", "afctr", "avecoll", "abcmp", "vercu", "afxc", "avalcoll", "aveconfig", "afctx", "AVctl", "awcontext", "aveca", "ajctx", "evtx", "devctx", "ovcu", " avcit", "avcli", " avcontext", "afcit", "vercit", "avca", " avcv", "ajca", "avevoc", "afcv", "avcmd", "Avconn", "vercf", "afcmp", "avcmp", "abcli", "akctx", "abcontext", "ajcmd", "avcv", "avalctx", "avxc", "AVcmd", "ajcu", "aveconn", "AVcmp", "ovcontext", "Avctx", "avecontext", "akxc", "afcf", "ajcmp", "evcu", "AVcu", " avcu", "AVconn", "awcmp", "avecu", "devcontext", "Avcu", "afcli", "ajcf", "awctl", "akcit", "afctl", "vercontext", "avcu", "avconfig", "AVcontext", "afsci", "ajcit", "afcmd", "avcontext", "ajxc", "afcoll", "ajvoc", "avvoc", "avsci", "ajctr", "avesci", "avconn", "evctx", "abctx", "devconfig", "avctl", "avectx", "ovctx", "ajcv", "AVctx", "avalcmp", "avcoll", "avcf", "aftx", "avalconn", "avecf", "avtx", "ajcli", "Avcontext", "avcit", "verctx", " avctl", "afconn", "afcontext", "afvoc", "afconfig", "ajcontext", "avctr", " avsci", "avecmp", "devcf", "afcu", "abcu", "abconfig"], "s": ["o", "sets", "sf", "v", "sec", "is", "S", "a", "spec", "sg", "session", "b", "data", "i", "sync", "si", "sys", "ses", "services", "so", "states", "xs", "l", "f", "ns", "d", "ls", "args", "service", "cs", "ss", "u", "e", "sc", "w", "ops", "gs", "sb", "ks", "se", "ds", "qs", "n", "ctx", "t", "ts", "storage", "su", "self", "p", "this", "h", "aws", "fs", "sup", "sa", "c", "os", "g", "ssl", "sq", "sym", "utils", "es", "rs", "ps", "js"]}}
{"project": "FFmpeg", "commit_id": "55815edca038997ec283569a192a3eca7f2143bc", "target": 0, "func": "static void build_feed_streams(void)\n\n{\n\n    FFStream *stream, *feed;\n\n    int i;\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (!stream->is_feed) {\n\n                /* we handle a stream coming from a feed */\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (stream->is_feed) {\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = i;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* create feed files if needed */\n\n    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {\n\n        int fd;\n\n\n\n        if (url_exist(feed->feed_filename)) {\n\n            /* See if it matches */\n\n            AVFormatContext *s;\n\n            int matches = 0;\n\n\n\n            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {\n\n                /* Now see if it matches */\n\n                if (s->nb_streams == feed->nb_streams) {\n\n                    matches = 1;\n\n                    for(i=0;i<s->nb_streams;i++) {\n\n                        AVStream *sf, *ss;\n\n                        sf = feed->streams[i];\n\n                        ss = s->streams[i];\n\n\n\n                        if (sf->index != ss->index ||\n\n                            sf->id != ss->id) {\n\n                            http_log(\"Index & Id do not match for stream %d (%s)\\n\",\n\n                                   i, feed->feed_filename);\n\n                            matches = 0;\n\n                        } else {\n\n                            AVCodecContext *ccf, *ccs;\n\n\n\n                            ccf = sf->codec;\n\n                            ccs = ss->codec;\n\n#define CHECK_CODEC(x)  (ccf->x != ccs->x)\n\n\n\n                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n\n                                http_log(\"Codecs do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {\n\n                                http_log(\"Codec bitrates do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                                if (CHECK_CODEC(time_base.den) ||\n\n                                    CHECK_CODEC(time_base.num) ||\n\n                                    CHECK_CODEC(width) ||\n\n                                    CHECK_CODEC(height)) {\n\n                                    http_log(\"Codec width, height and framerate do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n                                if (CHECK_CODEC(sample_rate) ||\n\n                                    CHECK_CODEC(channels) ||\n\n                                    CHECK_CODEC(frame_size)) {\n\n                                    http_log(\"Codec sample_rate, channels, frame_size do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else {\n\n                                http_log(\"Unknown codec type\\n\");\n\n                                matches = 0;\n\n                            }\n\n                        }\n\n                        if (!matches)\n\n                            break;\n\n                    }\n\n                } else\n\n                    http_log(\"Deleting feed file '%s' as stream counts differ (%d != %d)\\n\",\n\n                        feed->feed_filename, s->nb_streams, feed->nb_streams);\n\n\n\n                av_close_input_file(s);\n\n            } else\n\n                http_log(\"Deleting feed file '%s' as it appears to be corrupt\\n\",\n\n                        feed->feed_filename);\n\n\n\n            if (!matches) {\n\n                if (feed->readonly) {\n\n                    http_log(\"Unable to delete feed file '%s' as it is marked readonly\\n\",\n\n                        feed->feed_filename);\n\n                    exit(1);\n\n                }\n\n                unlink(feed->feed_filename);\n\n            }\n\n        }\n\n        if (!url_exist(feed->feed_filename)) {\n\n            AVFormatContext s1 = {0}, *s = &s1;\n\n\n\n            if (feed->readonly) {\n\n                http_log(\"Unable to create feed file '%s' as it is marked readonly\\n\",\n\n                    feed->feed_filename);\n\n                exit(1);\n\n            }\n\n\n\n            /* only write the header of the ffm file */\n\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n\n                http_log(\"Could not open output feed file '%s'\\n\",\n\n                         feed->feed_filename);\n\n                exit(1);\n\n            }\n\n            s->oformat = feed->fmt;\n\n            s->nb_streams = feed->nb_streams;\n\n            for(i=0;i<s->nb_streams;i++) {\n\n                AVStream *st;\n\n                st = feed->streams[i];\n\n                s->streams[i] = st;\n\n            }\n\n            av_set_parameters(s, NULL);\n\n            if (av_write_header(s) < 0) {\n\n                http_log(\"Container doesn't supports the required parameters\\n\");\n\n                exit(1);\n\n            }\n\n            /* XXX: need better api */\n\n            av_freep(&s->priv_data);\n\n            avio_close(s->pb);\n\n        }\n\n        /* get feed size and write index */\n\n        fd = open(feed->feed_filename, O_RDONLY);\n\n        if (fd < 0) {\n\n            http_log(\"Could not open output feed file '%s'\\n\",\n\n                    feed->feed_filename);\n\n            exit(1);\n\n        }\n\n\n\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n\n        /* ensure that we do not wrap before the end of file */\n\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n\n            feed->feed_max_size = feed->feed_size;\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 666, "substitutes": {"stream": ["wheel", "row", "queue", "current", "url", "sl", "client", "roll", "pipe", "forward", "event", "ream", "control", "ack", "down", "sw", "track", "f", "child", "message", "object", "round", "single", "path", "board", "port", "flow", "group", "host", "form", "image", "cloud", "model", "request", "resource", "length", "web", "transform", "wave", "load", "input", "user", "channel", "loop", "filter", "live", "document", "pool", "raw", "food", "content", "design", "node", "cf", "hook", "uc", "Stream", "null", "server", "follow", "header", "output", "draft", "sync", "coll", "source", "config", "reader", "draw", "pull", "thread", "fuel", "clean", "full", "view", "table", "upload"], "feed": ["allow", "row", "large", "fed", "queue", "sl", "wait", "next", "roll", "forward", "event", "index", "control", "ack", "f", "child", "sc", "comment", "cell", "valid", "af", "board", "acc", "accept", "flow", "read", "gram", "zip", "host", "form", "image", "scroll", "id", "pass", "model", "update", "write", "request", "post", "feeding", "layout", "length", "handler", "driver", "link", "load", "import", "keep", "input", "gh", "Feed", "fast", "build", "channel", "hub", "report", "page", "insert", "loop", "search", "cr", "raw", "food", "design", "rss", "cf", "close", "fork", "gen", "low", "hook", "cook", "uc", "inf", "service", "check", "def", "ga", "throw", "follow", "grow", "seed", "gg", "draft", "entry", "bug", "source", "config", "reader", "zero", "draw", "pull", "fuel", "full", "view"], "i": ["q", "j", "g", "ti", "index", "x", "hi", "f", "u", "ori", "vi", "uri", "fi", "start", "abi", "zi", "pi", "ui", "image", "id", "mi", "k", "iu", "y", "ri", "z", "ie", "p", "e", "lc", "isi", "v", "qi", "ix", "t", "io", "root", "in", "li", "a", "ni", "ii", "chi", "data", "r", "I", "di", "is", "m", "inner", "info", "slice", "ini", "h", "c", "phi", "o", "si", "yi", "gi", "ei", "oi", "d", "it", "iii", "eni", "none", "multi", "ai", "ip", "l", "block", "reader", "bi", "min", "b", "ci", "part", "xi"], "fd": ["fc", "ff", "find", "form", "fa", "d", "ct", "di", "aa", "ma", "fff", "fn", "found", "file", "flows", "fr", "cond", "feat", "fe", "iff", "f", "ffff", " fid", "handler", "fm", "ci"], "s": ["server", "js", "service", "spec", "qs", "ts", "rs", "a", "sb", "n", "aws", "sl", "search", "y", "g", "space", "m", "ses", "ls", "sync", "xs", "sv", "storage", "sets", "ds", "settings", "ps", "gs", "source", "ns", "l", "c", "p", "sw", "services", "e", "f", "es", "sq", "u", "o", "v", "stats", "b", "su", "S", "t", "session", "single", "site", "rss", "hs", "se", "fs", "si", "ssl"], "sf": ["fc", "tf", "vp", "fs", "sd", "sb", "xf", "fy", "fw", "cpp", "uci", "lf", "dl", "sl", "fl", "rf", "ef", "fp", "df", "fr", "ft", "sv", "bf", "fe", "fg", "sw", "aff", "f", "sq", "fx", "eph", "fm", "fee", "fb", "nw", "su", "SF", "cf", "rss", "sm", "uf", "fi", "si", "ssl"], "ss": ["cs", "sch", "ass", "rs", "sd", "sb", "pg", "sp", "sl", "sh", "ssh", "ses", "fts", "ls", "sync", "ys", "xs", "sv", "ds", "SS", "WS", "ess", "xx", "ns", "ps", "css", "vs", "sw", "oss", "f", "es", "hess", "sq", "sc", "sys", "uss", "sr", "iss", "rss", "su", "serv", "cf", "os", "bs", "se", "fs", "si", "ssl"], "ccf": ["cff", "csv", "CCb", "acf", "cfrf", "ccrf", "CCfs", "ecb", "CCs", "ecfs", "cfv", "csfs", "acfs", "ecs", "ucb", "csf", "ucs", "cffs", "CCf", "acv", "acrf", "csrf", "ucfs", "ucf", "ccb", "ecf", "ccv", "ccfs"], "ccs": ["csp", "cff", "csv", "rcl", "ccl", "ctp", "accf", "cts", "rcc", "cfs", "cfv", "ccp", "css", "accl", "csf", "ucs", "ccc", "cfp", "accc", "rcf", "ucc", "accs", "ucf", "ctf", "ctv", "ucl", "rcs", "ccv"]}}
{"project": "qemu", "commit_id": "601b9a9008c5a612d76073bb3f178621cff41980", "target": 0, "func": "uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,\n\n                      uint64_t cpu_addr)\n\n{\n\n    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n\n\n    HELPER_LOG(\"%s: %016\" PRIx64 \" %08x %016\" PRIx64 \"\\n\",\n\n               __func__, order_code, r1, cpu_addr);\n\n\n\n    /* Remember: Use \"R1 or R1 + 1, whichever is the odd-numbered register\"\n\n       as parameter (input). Status (output) is always R1. */\n\n\n\n    switch (order_code) {\n\n    case SIGP_SET_ARCH:\n\n        /* switch arch */\n\n        break;\n\n    case SIGP_SENSE:\n\n        /* enumerate CPU status */\n\n        if (cpu_addr) {\n\n            /* XXX implement when SMP comes */\n\n            return 3;\n\n        }\n\n        env->regs[r1] &= 0xffffffff00000000ULL;\n\n        cc = 1;\n\n        break;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    case SIGP_RESTART:\n\n        qemu_system_reset_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n    case SIGP_STOP:\n\n        qemu_system_shutdown_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n#endif\n\n    default:\n\n        /* unknown sigp */\n\n        fprintf(stderr, \"XXX unknown sigp: 0x%\" PRIx64 \"\\n\", order_code);\n\n        cc = SIGP_CC_NOT_OPERATIONAL;\n\n    }\n\n\n\n    return cc;\n\n}\n", "idx": 26152, "substitutes": {"env": ["fen", "gui", "file", "code", "obj", "args", "np", "ep", "er", "info", "exc", "server", "context", "manager", "enc", "ec", "en", "config", "conf", "style", "export", "opt", "priv", "state", "dict", "ev", "inst", "ea", "loader", "environment", "proc", "db", "e", "site", "esi", "err", "dev", "viron", "worker", "exe", "cp", "eu", "eni", "cache", "erv", "esp", "vm", "req", "ext", "conn", "v", "que", "equ", "eng"], "order_code": ["orderprecodes", "orderalcount", "order2Code", "orderpreclass", "orderprecode", "order2class", " order_class", "order_class", "sort_codes", " order_key", "sort_Code", "sort_call", "orderalcode", " order_call", "orderycall", "orderylevel", "order_codes", "order2call", "orderprecount", "orderalkey", " order_codes", "order2count", "order_key", "orderycodes", "orderalcodes", " order_count", "orderycode", "order_count", "order_Code", "order_level", "sort_code", " order_level", "order_call", "order2code", "order2codes"], "r1": ["order0", " r9", "r9", "order9", "R3", "R2", "r0", " r2", "r2", " r4", "e3", "R0", "R4", "sr1", "sr4", "order2", "e1", "order1", "sr0", "r3", " r0", "sr2", "R9", "e2", " r3", "r4", "R1"], "cpu_addr": ["cpu_offset", "gpu_ord", "cpu2addr", "cpu_ord", "gpu_addr", "gpu_offset", "cpu2address", "cpu_address", "cpu2ord", "cpu2offset", "cpu_port", "gpu_address", "gpu_port"]}}
{"project": "FFmpeg", "commit_id": "89d4d7d759a59e8535b267b7f5af757f731da712", "target": 1, "func": "static void process_client(AVIOContext *client, const char *in_uri)\n\n{\n\n    AVIOContext *input = NULL;\n\n    uint8_t buf[1024];\n\n    int ret, n, reply_code;\n\n    uint8_t *resource = NULL;\n\n    while ((ret = avio_handshake(client)) > 0) {\n\n        av_opt_get(client, \"resource\", AV_OPT_SEARCH_CHILDREN, &resource);\n\n        // check for strlen(resource) is necessary, because av_opt_get()\n\n        // may return empty string.\n\n        if (resource && strlen(resource))\n\n            break;\n\n\n    }\n\n    if (ret < 0)\n\n        goto end;\n\n    av_log(client, AV_LOG_TRACE, \"resource=%p\\n\", resource);\n\n    if (resource && resource[0] == '/' && !strcmp((resource + 1), in_uri)) {\n\n        reply_code = 200;\n\n    } else {\n\n        reply_code = AVERROR_HTTP_NOT_FOUND;\n\n    }\n\n    if ((ret = av_opt_set_int(client, \"reply_code\", reply_code, AV_OPT_SEARCH_CHILDREN)) < 0) {\n\n        av_log(client, AV_LOG_ERROR, \"Failed to set reply_code: %s.\\n\", av_err2str(ret));\n\n        goto end;\n\n    }\n\n    av_log(client, AV_LOG_TRACE, \"Set reply code to %d\\n\", reply_code);\n\n\n\n    while ((ret = avio_handshake(client)) > 0);\n\n\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    fprintf(stderr, \"Handshake performed.\\n\");\n\n    if (reply_code != 200)\n\n        goto end;\n\n    fprintf(stderr, \"Opening input file.\\n\");\n\n    if ((ret = avio_open2(&input, in_uri, AVIO_FLAG_READ, NULL, NULL)) < 0) {\n\n        av_log(input, AV_LOG_ERROR, \"Failed to open input: %s: %s.\\n\", in_uri,\n\n               av_err2str(ret));\n\n        goto end;\n\n    }\n\n    for(;;) {\n\n        n = avio_read(input, buf, sizeof(buf));\n\n        if (n < 0) {\n\n            if (n == AVERROR_EOF)\n\n                break;\n\n            av_log(input, AV_LOG_ERROR, \"Error reading from input: %s.\\n\",\n\n                   av_err2str(n));\n\n            break;\n\n        }\n\n        avio_write(client, buf, n);\n\n        avio_flush(client);\n\n    }\n\nend:\n\n    fprintf(stderr, \"Flushing client\\n\");\n\n    avio_flush(client);\n\n    fprintf(stderr, \"Closing client\\n\");\n\n    avio_close(client);\n\n    fprintf(stderr, \"Closing input\\n\");\n\n    avio_close(input);\n\n\n}", "idx": 17929, "substitutes": {"client": ["pc", "util", "plugin", "session", "global", "request", "child", "core", "reader", "call", "google", "image", "conn", "service", "chrome", "worker", "current", "clean", "cod", "public", "ctx", "container", "host", "context", "secure", "ce", "path", "ac", "socket", "con", "config", "prefix", "ssl", "remote", "cli", "cat", "c", "open", "batch", "parent", "private", "uc", "cl", "cache", "http", "cell", "consumer", "product", "wrapper", "Client", "api", "local", "connection", "project", "cn", "port", "server", "mac", "custom", "connect"], "in_uri": [" in_collection", "in_collection", "in_resource", "inpri", "in_path", " in_resource", "invaluri", "In_binary", " in_URI", "invalcollection", "inpURI", "inppath", "inpuri", "invalURI", "in_ri", " in_ri", " in_filename", "In_ri", "in_binary", " in_path", "invalfilename", "In_uri", "in_filename", "in_URI", "In_URI"], "input": ["entry", "dc", "util", "plugin", "instance", "bin", "session", "init", "request", "data", "view", "reader", "child", "image", "text", "buffer", "inc", "current", "stream", "i", "in", "accept", "active", "act", "container", "context", "Input", "event", "ac", "import", "socket", "back", "img", "config", "queue", "id", "pull", "ssl", "batch", "cli", "temp", "cat", "include", "qa", "uc", "binary", "url", "http", "output", "interface", "form", "storage", "field", "api", "local", "connection", "list", "server", "command", "inner", "source"], "buf": ["Buffer", "br", "ff", "data", "text", "err", "pool", "buffer", "rc", "vec", "window", "cb", "block", "bc", "msg", "raw", "ctx", "wb", "pb", "cas", "context", "header", "box", "queue", "config", "fd", "buff", "batch", "fb", "map", "c", "temp", "rb", "seq", "tmp", "uc", "cmd", "b", "cache", "output", "cap", "alloc", " buffer", "port", "bag", "uf", "cv"], "ret": ["br", "obj", "al", "ref", "nt", "result", "str", "job", "ut", "att", "store", "reset", "rev", "repl", "pat", "res", "mt", "prot", "len", "part", "j", "sur", "rest", "rc", "ne", "fun", "fin", "timeout", "rf", "resp", "arg", "art", "Ret", "bf", "cat", "RET", "pet", "ft", "iter", "rem", "ner", "err", "alt", "lit", "rt", "sb", "match", "nl", "mem", "nb", "ry", "val", "re", " RET", "back", "sr", "post", "rl", "detail", "er", "reply", "success", "db", "t", "info", "reg", "flag", "ext", "def", "rets", "en", "out", "old", "fail", "det", "bot", "cur", "rb", "url", "ur", "error", "red", "usr"], "n": ["ns", "not", "na", "m", "ner", "dn", "j", "s", "gn", "t", "un", "x", "f", "name", "pn", "ng", "r", "nt", "ne", "num", "N", "g", "i", "nor", "z", "nl", "node", "pos", "nb", "min", "en", "count", "nat", "o", "l", "d", "nr", "nc", "size", "no", "sn", "nu", "rn", "k", "e", "c", "ni", "p", "none", "b", "fn", "cn", "number", "body", "nn", "an", "y", "conn", "len"], "reply_code": ["reply67code", "reply_number", "response_codes", "response_coded", "replyxCode", "reply_text", "replyalcount", "replyalnumber", "reply_count", "replyaccoded", "replySline", "reply_handler", "replySnumber", "reply_coded", "replyflowcodes", "reply_start", "replyflowhandler", "replyIPcount", "replyflownumber", "reply_codes", "response_cod", "replyachandler", "replyxcode", "replyingcodes", "replyingcod", "replyflowCode", "replyflowcod", "repl_code", "replyIPcode", "replyaccount", "replyScount", "reply_line", "repl_start", "replyIPcoded", "replyxhandler", "replyflowcode", "repl_class", "reply67codes", "reply_cod", "response_number", "replyingcode", "response_handler", "replyalcode", "reply_class", "response_Code", "replyxcodes", " reply_codes", "response_code", "replyingnumber", "reply_Code", " reply_count", "response_line", "replyIPhandler", "reply67text", " reply_text", "replyalline", "response_count", "reply67count", "replyScode", "replyaccode", "repl_codes"], "resource": ["uri", "rage", "content", "record", "offset", "request", "data", "core", "rest", "search", "ref", "attribute", "token", "media", "name", "buffer", "Resource", "r", "random", "file", "result", "channel", "document", "query", "region", "type", "src", "reference", "resources", "rg", "scope", "index", "byte", "password", "progress", "replace", "pointer", "range", "context", "re", "event", "rule", "value", "config", "response", "sr", "prefix", "remote", "ruby", "id", "parent", "ri", "url", "address", "output", "error", "res", "number", "character", "connection", "project", "rect", "message", "server", "operation", "reply", "source", "reader"]}}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static void virtio_init_pci(VirtIOPCIProxy *proxy, VirtIODevice *vdev,\n\n                            uint16_t vendor, uint16_t device,\n\n                            uint16_t class_code, uint8_t pif)\n\n{\n\n    uint8_t *config;\n\n    uint32_t size;\n\n\n\n    proxy->vdev = vdev;\n\n\n\n    config = proxy->pci_dev.config;\n\n    pci_config_set_vendor_id(config, vendor);\n\n    pci_config_set_device_id(config, device);\n\n\n\n    config[0x08] = VIRTIO_PCI_ABI_VERSION;\n\n\n\n    config[0x09] = pif;\n\n    pci_config_set_class(config, class_code);\n\n\n\n    config[0x2c] = vendor & 0xFF;\n\n    config[0x2d] = (vendor >> 8) & 0xFF;\n\n    config[0x2e] = vdev->device_id & 0xFF;\n\n    config[0x2f] = (vdev->device_id >> 8) & 0xFF;\n\n\n\n    config[0x3d] = 1;\n\n\n\n    if (vdev->nvectors && !msix_init(&proxy->pci_dev, vdev->nvectors, 1, 0)) {\n\n        pci_register_bar(&proxy->pci_dev, 1,\n\n                         msix_bar_size(&proxy->pci_dev),\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                         msix_mmio_map);\n\n    } else\n\n        vdev->nvectors = 0;\n\n\n\n    proxy->pci_dev.config_write = virtio_write_config;\n\n\n\n    size = VIRTIO_PCI_REGION_SIZE(&proxy->pci_dev) + vdev->config_len;\n\n    if (size & (size-1))\n\n        size = 1 << qemu_fls(size);\n\n\n\n    pci_register_bar(&proxy->pci_dev, 0, size, PCI_BASE_ADDRESS_SPACE_IO,\n\n                           virtio_map);\n\n\n\n    if (!kvm_has_many_ioeventfds()) {\n\n        proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;\n\n    }\n\n\n\n    virtio_bind_device(vdev, &virtio_pci_bindings, proxy);\n\n    proxy->host_features |= 0x1 << VIRTIO_F_NOTIFY_ON_EMPTY;\n\n    proxy->host_features |= 0x1 << VIRTIO_F_BAD_FEATURE;\n\n    proxy->host_features = vdev->get_features(vdev, proxy->host_features);\n\n}\n", "idx": 18893, "substitutes": {"proxy": ["plugin", "Proxy", "instance", "db", "request", "child", "shadow", "core", "base", "image", "ping", "coe", "pool", "component", "clone", "engine", "io", "service", "bridge", "rc", "library", "pe", "phi", "module", "PRO", "slice", "index", "phy", "model", "zip", "web", "roxy", "ca", "force", "profile", "bo", "gp", "linux", "alias", "pse", "queue", "remote", "cop", "ruby", "client", "cube", "parent", "slave", "ube", "driver", "lib", "ghost", "que", "cache", "http", "resource", "proc", "wrapper", "pro", "connection", "project", "py", "port", "server", "callback", "bus", "apache", "source"], "vdev": ["fdev", "vserv", "vdi", "vdiff", " vdef", "vdiv", "vmdev", "nvconn", "ndiv", "pdev", " vow", "vev", "lvdevice", "vmdata", "nvvalid", "hdevice", " vconf", "pdata", "ppriv", "svconf", "Vserv", "nvdevice", "vmdevice", "svver", "vdc", "vdef", "nvow", "Vev", "fdevice", "vmod", "hdev", "vself", "vvalid", "ldev", "vdata", " vde", "Vdiv", "vde", " vdata", "ndef", "vmdd", "pconf", "pserv", " vdiv", "lconn", "Vdev", "vver", "svdevice", "udev", "svvalid", "fdi", "vdevice", "lvdiv", "pdd", "vconf", "hprof", "svde", "pver", "ndev", "vdd", "pself", "udi", "lvdc", "vmvalid", "lvpriv", "hdi", "vmdiff", "udevice", "pde", "nself", "vmpriv", "svdev", "nvdiff", "vpriv", "lvself", "nmod", "lmod", " vdd", "npriv", "fprof", "hdef", "vprof", "lvow", " vserv", "uprof", "nvdef", " vpriv", " vdc", "vconn", " vdevice", " vmod", "nvdc", " vver", "pdiv", "lvdev", "pev", "ldevice", "vow", "hconn", "nvdev", " vev", "ldef", "svdiff"], "vendor": ["ivendor", "coice", "lvendor", "soven", "bnc", "quendor", " voice", "lvirgin", " virgin", "birgin", "sendor", "uvender", "vnc", " voy", " voven", "cirgin", "firgin", "navendor", "qudev", "navnc", "navoven", "lvoice", "voy", "boven", "fendor", "lvender", "cendor", "svoven", "quoy", "voven", " vnc", "foice", "sender", "svendor", "voice", "svender", "ivdev", "ivoice", "bendor", "cender", "uvoven", "svirgin", "ivoy", "uvendor", "uvirgin", "navirgin", "sirgin", "virgin", "vender", "quoice", "fender"], "device": ["dc", "dn", "vision", "mode", "direction", "attribute", "dir", "Device", "component", "engine", "md", "service", "mi", "module", "devices", "package", "node", "di", "model", "password", "description", "d", "disk", "directory", "mobile", "drive", "unit", "dev", "driver", "address", "feature", "domain", "product", "serial", "connection", "project", "mac", "version", "target"], "class_code": ["class_coded", "classblockcode", "classercoded", "classercodes", "class_id", "classermessage", " class_two", "classblockmessage", " class_coded", " class_desc", " class_codes", " class_message", " class_id", "class_message", "classercode", "class_codes", "classblockcoded", "class_two", "class_desc", "classblockcodes"], "pif": ["Piff", " pIF", "fiff", "Pif", "pIF", "pifer", "Pifer", " pip", "pip", " piff", "piff", "fIF", " pifer", "Pip", "PIF", "fifer", "fip", "fif"], "config": ["set", "spec", "cfg", "settings", "options", "service", "inc", "supp", "cf", "gui", "control", "sec", "exec", "design", "contract", "path", "feat", "comp", "Config", "lib", "account", "p", "output", "source", "conn", "input", "not", "plugin", "content", "init", "name", "rc", "app", "bc", "controller", "load", "class", "sc", "cat", "tail", "connection", "desc", "license", "code", "text", "view", "f", "image", "ct", "json", "block", "ca", "host", "c", "qa", "access", "address", "project", "state", "connect", "session", "ch", "capacity", "data", "info", "conf", "attribute", "pool", "ext", "index", "password", "css", "context", "fig", "gate", "args", "front", "client", "man", "driver", "support", "cache", "body", "section", "custom"], "size": ["set", "scale", "offset", "small", "capacity", "code", "data", "SIZE", "name", "shape", "time", "core", "full", "sized", "six", "type", "loc", "z", "max", "sec", "mini", "timeout", "member", "count", "speed", "empty", "complete", "args", "large", "ci", "security", "ize", "length", "key", "limit", "e", "sync", "c", "si", "iz", "shift", "address", "cache", "fee", "sum", "form", "storage", "number", "weight", "Size", "server", "value", "len"]}}
{"project": "FFmpeg", "commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "target": 1, "func": "static AVFrame *do_psnr(AVFilterContext *ctx, AVFrame *main,\n\n                        const AVFrame *ref)\n\n{\n\n    PSNRContext *s = ctx->priv;\n\n    double comp_mse[4], mse = 0;\n\n    int j, c;\n\n    AVDictionary **metadata = avpriv_frame_get_metadatap(main);\n\n\n\n    s->compute_mse(s, (const uint8_t **)main->data, main->linesize,\n\n                      (const uint8_t **)ref->data, ref->linesize,\n\n                       main->width, main->height, comp_mse);\n\n\n\n    for (j = 0; j < s->nb_components; j++)\n\n        mse += comp_mse[j] * s->planeweight[j];\n\n\n\n    s->min_mse = FFMIN(s->min_mse, mse);\n\n    s->max_mse = FFMAX(s->max_mse, mse);\n\n\n\n    s->mse += mse;\n\n    for (j = 0; j < s->nb_components; j++)\n\n        s->mse_comp[j] += comp_mse[j];\n\n    s->nb_frames++;\n\n\n\n    for (j = 0; j < s->nb_components; j++) {\n\n        c = s->is_rgb ? s->rgba_map[j] : j;\n\n        set_meta(metadata, \"lavfi.psnr.mse.\", s->comps[j], comp_mse[c]);\n\n        set_meta(metadata, \"lavfi.psnr.psnr.\", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));\n\n    }\n\n    set_meta(metadata, \"lavfi.psnr.mse_avg\", 0, mse);\n\n    set_meta(metadata, \"lavfi.psnr.psnr_avg\", 0, get_psnr(mse, 1, s->average_max));\n\n\n\n    if (s->stats_file) {\n\n        fprintf(s->stats_file, \"n:%\"PRId64\" mse_avg:%0.2f \", s->nb_frames, mse);\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"mse_%c:%0.2f \", s->comps[j], comp_mse[c]);\n\n        }\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"psnr_%c:%0.2f \", s->comps[j],\n\n                    get_psnr(comp_mse[c], 1, s->max[c]));\n\n        }\n\n        fprintf(s->stats_file, \"\\n\");\n\n    }\n\n\n\n    return main;\n\n}\n", "idx": 17350, "substitutes": {"ctx": ["cal", "core", "conf", "cca", "gc", "cm", "cf", "comm", "cb", "anc", "bc", "src", "cp", "bt", "scope", "ctrl", "cas", "Context", "ca", "setup", "cs", "context", "acs", "cms", "conv", "tx", "tc", "config", "sc", "q", "cam", "client", "cmd", "support", "sci", "cmp", "mac", "sq", "cv", "conn"], "ref": ["part", "ab", "fr", "m", "db", "info", "conf", "base", "ob", "f", "obj", "alt", "af", "full", "reg", "Ref", "rel", "block", "reference", "pb", "mem", "def", "range", "arc", "rec", "re", "old", "diff", "fact", "pre", "comp", "img", "config", "id", "remote", "primary", "parent", "req", "p", "external", "b", "cache", "wa", "local", "aff", "end", " reference", "rem", "source", "REF"], "s": ["ns", "set", "spec", "full", "settings", "service", "ss", "cs", "d", "qs", "sym", "p", "ks", "h", "us", "sets", "comments", "sa", "m", "ts", "sg", "sis", "rs", "aws", "self", "lines", "o", "su", "sc", "v", "si", "S", "single", "a", "hs", "ds", "ans", "f", "sv", "shared", "r", "sb", "ys", "src", "as", "l", "ins", "w", "sync", "ps", "secondary", "b", "sys", "es", "states", "sq", "sf", "session", "stats", "t", "conf", "data", "services", "n", "plugins", "g", "i", "sl", "ls", "ops", "fs", "xs", "is", "sites", "site", "e", "ssl", "ses", "client", "js", "http", "gs", "its", "os", "parts", "tp", "server", "y", "u"], "comp_mse": ["comp_kmse", "comp_rmce", "comp_amme", "comp_nke", "comp_magge", "comp_nso", "comp_amce", "comp_mpe", "comp_magme", "comp_cze", "comp_nse", "comp_amte", "comp_magse", "comp_rce", "comp_ampe", "comp_Mpe", "comp_mce", "comp_mese", "comp_cpe", "comp_Mge", "comp_rmte", "comp_cmso", "comp_cmce", "comp_mbe", "comp_rmse", "comp_rmze", "comp_misse", "comp_amse", "comp_mrese", "comp_cisse", "comp_nte", "comp_amesh", "comp_nge", "comp_mrse", "comp_rmbe", "comp_amese", "comp_cse", "comp_mge", "comp_mesh", "comp_Mse", "comp_amge", "comp_rmesh", "comp_MSE", "comp_mke", "comp_rso", "comp_cmse", "comp_mSE", "comp_rmSE", "comp_nce", "comp_npe", "comp_rke", "comp_cmke", "comp_Mte", "comp_ambe", "comp_kmisse", "comp_mte", "comp_Mze", "comp_mme", "comp_mrge", "comp_kmze", "comp_mso", "comp_rse", "comp_kmpe", "comp_mze", "comp_magese", "comp_mrme"], "j": ["jo", "jc", "m", "fr", "jl", "ji", "code", "t", "br", "ch", "x", "jp", "f", "uj", "jit", "obj", "json", "bj", "note", "err", "r", "adj", "n", "syn", "jj", "job", "qi", "g", "i", "je", "z", "ie", "ij", "jet", "pos", "aj", "dj", " l", "o", "l", "d", "jen", "w", "oj", "J", "key", "k", "e", "q", "kj", "v", "js", "p", "off", "b", " i", "h", "er", "ja", " ii", "im", "jam", "it", "el", "section", "y", "li", "u"], "c": ["dc", "m", "ch", "code", "t", "x", "f", "err", "vc", "r", "n", "cm", "cf", "g", "i", "coll", "cb", "z", "mc", "count", "cy", "o", "ca", "sc", "cs", "arc", "l", "d", "ac", "ci", "con", "w", "e", "k", "cu", "q", "cr", "v", "lc", "cat", "cl", "p", "uc", "b", "cache", "col", "cell", "ec", "h", "cn", "co", "C", "y", "cc", "u"], "metadata": ["uri", "wp", "m", "session", "metal", "stats", "data", "info", "cookie", "note", "archive", "annot", "shared", "json", "track", "md", "ann", "bm", "details", "java", "document", "communication", "package", "utils", "zip", "filename", "magic", "parser", "nm", "generic", "database", "sound", "header", "summary", "adata", "carbon", "memory", "args", "met", "config", "general", "mx", "meta", "binary", "xml", "metry", "music", "storage", "properties", "gm", "template", "mt", "message", "notes", "mm", "valid", "np", "tm", "collection"], "nb_frames": ["ni_images", "num_steps", "nbCimages", "nb__lines", "nb_images", "nb_frame", "num_points", "nb_steps", "nbCshots", "ni_shots", "nb__frames", "num_frames", "nb__images", "nbofpoints", "nb_lines", "nbCframes", "nbClines", "nbofsteps", "nb_shots", "nb__shots", "ni_lines", "nbofframe", "nb_points", "ni_frames", "num_frame", "nbofframes"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    musicpal_lcd_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_LCD_IRQCTRL:\n\n        s->irqctrl = value;\n\n        break;\n\n\n\n    case MP_LCD_SPICTRL:\n\n        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {\n\n            s->mode = value;\n\n        } else {\n\n            s->mode = MP_LCD_SPI_INVALID;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_INST:\n\n        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {\n\n            s->page = value - MP_LCD_INST_SETPAGE0;\n\n            s->page_off = 0;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_DATA:\n\n        if (s->mode == MP_LCD_SPI_CMD) {\n\n            if (value >= MP_LCD_INST_SETPAGE0 &&\n\n                value <= MP_LCD_INST_SETPAGE7) {\n\n                s->page = value - MP_LCD_INST_SETPAGE0;\n\n                s->page_off = 0;\n\n            }\n\n        } else if (s->mode == MP_LCD_SPI_DATA) {\n\n            s->video_ram[s->page*128 + s->page_off] = value;\n\n            s->page_off = (s->page_off + 1) & 127;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 16862, "substitutes": {"opaque": ["copaques", "ipec", "operacity", "oponymous", "ipque", "copaque", "copec", "pque", "OPonymous", "opec", "opacity", "OPque", "operaque", "ospacity", "ipaques", "paques", "operque", "paque", "OPaque", "operonymous", "copque", "ipaque", "pec", "OPacity", "opaques", "ospaque", "osponymous", "opque", "ospque"], "offset": ["set", "scale", "skip", "data", "mode", "Offset", "bit", "fp", "f", "attribute", "from", "align", "option", "num", "reference", "padding", "index", "pos", "timeout", "pointer", "o", "ip", "location", "slot", "aque", "alias", "oid", "seed", "reset", "prefix", "length", "start", "parent", "position", "p", "off", "address", "pad", "shift", "error", "addr", "port", "operation"], "value": ["set", "element", "volume", "comment", "service", "money", "num", "max", "reference", "padding", "always", "non", "no", "length", "id", "VALUE", "total", "area", "feature", "resource", "none", "va", "end", "valid", "command", "values", "m", "scale", "Value", "name", "media", "done", "timeout", "description", "style", "flow", "key", "when", "v", "off", "null", "iv", "port", "expression", "native", "image", "current", "block", "ou", "type", "node", "function", "vi", "home", "page", "gap", "val", "array", "email", "memory", "w", "ue", "start", "amount", "selected", "address", "fee", "version", "hello", "data", "mode", "info", "buffer", "option", "i", "index", "member", "create", "format", "complete", "unit", "wa", "number", "message", "server"], "size": ["set", "scale", "data", "SIZE", "buffer", "type", "padding", " amount", " bytes", "count", " address", " error", "ize", "length", "address", "fee", " buffer", "bytes", "Size", " length", "len"], "s": ["ns", "spec", "strings", "settings", "service", "ss", "copy", "cs", "d", "new", "sym", "p", "h", "us", "sets", "comments", "source", "m", "ts", "sg", "rs", "self", "o", "su", "v", "si", "S", "a", "hs", "port", "ds", "status", "uns", "f", "r", "sb", "uploads", "this", "l", "ins", "sync", "c", "ps", "secondary", "sum", "sys", "your", "es", "state", "states", "sq", "params", "sf", "session", "t", "data", "conf", "services", "n", "plugins", "g", "sl", "ls", "ops", "fs", "is", "sites", "site", "e", "ssl", "ses", "js", "gs", "its", "os", "server", "u"]}}
{"project": "FFmpeg", "commit_id": "ea97859c8c218b83ab747a7eabcb88ca446f6751", "target": 1, "func": "static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab)\n\n{\n\n    CURSORINFO ci = {0};\n\n\n\n#define CURSOR_ERROR(str)                 \\\n\n    if (!gdigrab->cursor_error_printed) {       \\\n\n        WIN32_API_ERROR(str);             \\\n\n        gdigrab->cursor_error_printed = 1;      \\\n\n    }\n\n\n\n    ci.cbSize = sizeof(ci);\n\n\n\n    if (GetCursorInfo(&ci)) {\n\n        HCURSOR icon = CopyCursor(ci.hCursor);\n\n        ICONINFO info;\n\n        POINT pos;\n\n        RECT clip_rect = gdigrab->clip_rect;\n\n        HWND hwnd = gdigrab->hwnd;\n\n        info.hbmMask = NULL;\n\n        info.hbmColor = NULL;\n\n\n\n        if (ci.flags != CURSOR_SHOWING)\n\n            return;\n\n\n\n        if (!icon) {\n\n            /* Use the standard arrow cursor as a fallback.\n\n             * You'll probably only hit this in Wine, which can't fetch\n\n             * the current system cursor. */\n\n            icon = CopyCursor(LoadCursor(NULL, IDC_ARROW));\n\n        }\n\n\n\n        if (!GetIconInfo(icon, &info)) {\n\n            CURSOR_ERROR(\"Could not get icon info\");\n\n            goto icon_error;\n\n        }\n\n\n\n        pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot;\n\n        pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot;\n\n\n\n        if (hwnd) {\n\n            RECT rect;\n\n\n\n            if (GetWindowRect(hwnd, &rect)) {\n\n                pos.x -= rect.left;\n\n                pos.y -= rect.top;\n\n            } else {\n\n                CURSOR_ERROR(\"Couldn't get window rectangle\");\n\n                goto icon_error;\n\n            }\n\n        }\n\n\n\n        av_log(s1, AV_LOG_DEBUG, \"Cursor pos (%li,%li) -> (%li,%li)\\n\",\n\n                ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y);\n\n\n\n        if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left &&\n\n                pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) {\n\n            if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon))\n\n                CURSOR_ERROR(\"Couldn't draw icon\");\n\n        }\n\n\n\nicon_error:\n\n\n\n\n\n        if (icon)\n\n            DestroyCursor(icon);\n\n    } else {\n\n        CURSOR_ERROR(\"Couldn't get cursor info\");\n\n    }\n\n}", "idx": 2946, "substitutes": {"s1": ["s6", "c3", "s01", "c6", "f1", "sg1", "s3", "c01", "f7", "ms2", "sg6", "sg2", "f2", "sg01", "f3", "ms1", " s7", "s2", " s2", "c7", "c1", "s7", "ms01", "c2", "ms6", " s3"], "gdigrab": ["sdircab", "eddibrabe", "gdigrub", "gdrigalog", "hdigrateab", "gdrigub", "gdyrabo", "gdigralog", "hdyrab", "hdigrabo", "gdibrob", "hdigrob", "gdyrabe", "eddigrob", "gdibrabo", "gdigrationub", "sdircabo", "gdigrabe", "sdigrabe", "hdigrateabs", "gdigrationabi", "sdigrabo", "gdigrationab", "hdyrabs", "gdigerab", "gdigrateabs", "gdyrabs", "gdibrub", "gdibrabs", "eddibrob", "sdibrab", "gdarinabi", "gdirmabe", "gdatarabo", "eddigrabe", "sdibrub", "hdigrabb", "hdigratealog", "eddigrab", "gdigrationabe", "gdrigabe", "gdigerob", "gdrigabs", "gdirmab", "gdirmob", "gdigrateob", "hdyrabo", "hdigrateob", "gdigeralog", "gdigerabs", "gdibrab", "gdrigab", "gdrigabo", "gdatarabs", "gdibrabi", "gdibrabe", "sdibrabe", "gdircab", "gdatarabb", "gdrigabi", "gdircabi", "gdyrob", "sdigrabi", "sdigrub", "sdigrab", "gdibrabb", "hdigralog", "sdircabi", "gdrigob", "gdarinab", "gdatarab", "gdigrateab", "gdigrabo", "gdigrabi", "gdigrabb", "gdarinabo", "gdyrabb", "gdyrab", "gdigratealog", "hdigrab", "eddibrab", "gdigrob", "gdircabo", "hdigrabs", "gdigrabs", "hdyrabb", "sdibrabi"], "info": ["fo", "ami", "name", "li", "http", "time", "inter", "offset", "stat", "extra", "INFO", "ii", "alias", "area", "txt", "data", "image", "ui", "loc", "icon", "di", " INFO", "type", "open", "id", "end", "Info", "op", "api", "py", "i", "in", "off", "inner", "event", "bug", "util", "source", "index", "ani", "config", "function", "result", "hi", "information", "f", "conf", "text", "all", "object", "handler", "obj", "comment", "about", "hand", "of", "ix", "error", "link", "path", "ci", "io", "init", "part", "fi", "si", "inf"], "pos": ["act", " error", "sp", "px", "open", " loc", " p", "lat", "push", " positions", "index", "opt", "x", "trans", "pop", "Pos", "on", "start", "port", "POS", "pl", " POS", "spec", " src", "position", "type", "pick", "parent", "off", "pass", "po", " trans", "post", "p", "patch", "text", "os", "val", "pt", "plus", "in", "offset", "ss", "pose", "data", "loc", "axis", "press", " position", "is", " Pos", "neg", "op", " LA", " data", "pid", "feat", " response", "ps", "pad", "bot", "len", "ref", "cache", " offset", "obj", "vis", " prop", "res", " img", "no", "tip", "def", "prop", "pres", " index", "style", "config", "block", "doc", "min", "pull", "point", "rad", "pro", "line", "part"], "rect": ["rot", "row", "src", "shape", "area", "tri", "data", "url", "image", "prot", "r", "loc", "txt", "type", "grad", "client", "lat", "RECT", "box", "coll", "project", "slice", "cont", "coord", "tr", "feat", "pad", "block", "ptr", "col", "attr", "text", "patch", "contract", "object", "ect", "rat", "region", "round", "Rect", "path", "rt", "pt", "dir", "map", "radius", "rc", "port"]}}
{"project": "FFmpeg", "commit_id": "8000d484b83aafa752d84fbdbfb352ffe0dc64f8", "target": 1, "func": "void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){\n\n    c->bytestream_start=\n\n    c->bytestream= buf;\n\n    c->bytestream_end= buf + buf_size;\n\n\n\n#if CABAC_BITS == 16\n\n    c->low =  (*c->bytestream++)<<18;\n\n    c->low+=  (*c->bytestream++)<<10;\n\n#else\n\n    c->low =  (*c->bytestream++)<<10;\n\n#endif\n\n    c->low+= ((*c->bytestream++)<<2) + 2;\n\n    c->range= 0x1FE;\n\n}\n", "idx": 21919, "substitutes": {"c": ["lc", "fc", "e", "cc", "uc", "ct", "config", "g", "coll", "cm", "d", "con", "pc", "cur", "cl", "cu", "f", "ci", "t", "ac", "u", "m", "s", "cp", "nc", "cache", "oc", "p", "mc", "cs", "xc", "enc", "cf", "tc", "o", "rc", "ctx", "self", "sc", "ch", "b", "dc", "ic", "cy", "gc", "cr", "n", "C", "co", "z", "ce", "v", "cit", "l", "x", "ec", "vc"], "buf": ["uint", "pb", "port", "bc", "uf", "uc", "end", "config", "text", "cv", "fb", "queue", "ffff", "bin", "bridge", "home", "cur", "fp", "f", "buffer", "cmp", "alloc", "cmd", "tab", "data", "cache", "cf", "que", "context", "count", "pool", "rc", "cb", "ctx", "num", "aux", "b", "tmp", "seq", "fd", "src", "loc", "br", "ab", "batch", "buff", "v", "vec", "rb", "block", "offset", "max", "gb", "pub"], "buf_size": ["queue_size", " buf_len", "buf_count", " buf_length", "queue_len", "queue_count", "buf_length", "buf_len"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void *memory_region_get_ram_ptr(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 4440, "substitutes": {"mr": ["dr", "gr", "fr", "er", "vr", "sr", "rt", "pr", "rr", "md", "rb", "shr", "mid", "MR", "tr", "rc", "rd", "rf", "bm", "wk", "m", "rm", "rh", "tx", "attr", "mn", "nr", "pc", "km", "mc", "mt", "Mr", "rg", "timer", "tm", "rx", "lr", "rl", "err", "gro", "war", "usr", "yr", "mm", "RR", "hr", "br", "lc", "adr", "kr", "rs", "r"]}}
{"project": "FFmpeg", "commit_id": "ba571f6b4d15a998d6fde387509cd84177fccd96", "target": 0, "func": "static void event_loop(VideoState *cur_stream)\n\n{\n\n    SDL_Event event;\n\n    double incr, pos, frac;\n\n\n\n    for(;;) {\n\n        double x;\n\n        SDL_WaitEvent(&event);\n\n        switch(event.type) {\n\n        case SDL_KEYDOWN:\n\n            if (exit_on_keydown) {\n\n                do_exit(cur_stream);\n\n                break;\n\n            }\n\n            switch(event.key.keysym.sym) {\n\n            case SDLK_ESCAPE:\n\n            case SDLK_q:\n\n                do_exit(cur_stream);\n\n                break;\n\n            case SDLK_f:\n\n                toggle_full_screen(cur_stream);\n\n                break;\n\n            case SDLK_p:\n\n            case SDLK_SPACE:\n\n                if (cur_stream)\n\n                    toggle_pause(cur_stream);\n\n                break;\n\n            case SDLK_s: //S: Step to next frame\n\n                if (cur_stream)\n\n                    step_to_next_frame(cur_stream);\n\n                break;\n\n            case SDLK_a:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_AUDIO);\n\n                break;\n\n            case SDLK_v:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_VIDEO);\n\n                break;\n\n            case SDLK_t:\n\n                if (cur_stream)\n\n                    stream_cycle_channel(cur_stream, AVMEDIA_TYPE_SUBTITLE);\n\n                break;\n\n            case SDLK_w:\n\n                if (cur_stream)\n\n                    toggle_audio_display(cur_stream);\n\n                break;\n\n            case SDLK_LEFT:\n\n                incr = -10.0;\n\n                goto do_seek;\n\n            case SDLK_RIGHT:\n\n                incr = 10.0;\n\n                goto do_seek;\n\n            case SDLK_UP:\n\n                incr = 60.0;\n\n                goto do_seek;\n\n            case SDLK_DOWN:\n\n                incr = -60.0;\n\n            do_seek:\n\n                if (cur_stream) {\n\n                    if (seek_by_bytes) {\n\n                        if (cur_stream->video_stream >= 0 && cur_stream->video_current_pos>=0){\n\n                            pos= cur_stream->video_current_pos;\n\n                        }else if(cur_stream->audio_stream >= 0 && cur_stream->audio_pkt.pos>=0){\n\n                            pos= cur_stream->audio_pkt.pos;\n\n                        }else\n\n                            pos = avio_tell(cur_stream->ic->pb);\n\n                        if (cur_stream->ic->bit_rate)\n\n                            incr *= cur_stream->ic->bit_rate / 8.0;\n\n                        else\n\n                            incr *= 180000.0;\n\n                        pos += incr;\n\n                        stream_seek(cur_stream, pos, incr, 1);\n\n                    } else {\n\n                        pos = get_master_clock(cur_stream);\n\n                        pos += incr;\n\n                        stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE), (int64_t)(incr * AV_TIME_BASE), 0);\n\n                    }\n\n                }\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            break;\n\n        case SDL_MOUSEBUTTONDOWN:\n\n            if (exit_on_mousedown) {\n\n                do_exit(cur_stream);\n\n                break;\n\n            }\n\n        case SDL_MOUSEMOTION:\n\n            if(event.type ==SDL_MOUSEBUTTONDOWN){\n\n                x= event.button.x;\n\n            }else{\n\n                if(event.motion.state != SDL_PRESSED)\n\n                    break;\n\n                x= event.motion.x;\n\n            }\n\n            if (cur_stream) {\n\n                if(seek_by_bytes || cur_stream->ic->duration<=0){\n\n                    uint64_t size=  avio_size(cur_stream->ic->pb);\n\n                    stream_seek(cur_stream, size*x/cur_stream->width, 0, 1);\n\n                }else{\n\n                    int64_t ts;\n\n                    int ns, hh, mm, ss;\n\n                    int tns, thh, tmm, tss;\n\n                    tns = cur_stream->ic->duration/1000000LL;\n\n                    thh = tns/3600;\n\n                    tmm = (tns%3600)/60;\n\n                    tss = (tns%60);\n\n                    frac = x/cur_stream->width;\n\n                    ns = frac*tns;\n\n                    hh = ns/3600;\n\n                    mm = (ns%3600)/60;\n\n                    ss = (ns%60);\n\n                    fprintf(stderr, \"Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d)       \\n\", frac*100,\n\n                            hh, mm, ss, thh, tmm, tss);\n\n                    ts = frac*cur_stream->ic->duration;\n\n                    if (cur_stream->ic->start_time != AV_NOPTS_VALUE)\n\n                        ts += cur_stream->ic->start_time;\n\n                    stream_seek(cur_stream, ts, 0, 0);\n\n                }\n\n            }\n\n            break;\n\n        case SDL_VIDEORESIZE:\n\n            if (cur_stream) {\n\n                screen = SDL_SetVideoMode(event.resize.w, event.resize.h, 0,\n\n                                          SDL_HWSURFACE|SDL_RESIZABLE|SDL_ASYNCBLIT|SDL_HWACCEL);\n\n                screen_width = cur_stream->width = event.resize.w;\n\n                screen_height= cur_stream->height= event.resize.h;\n\n            }\n\n            break;\n\n        case SDL_QUIT:\n\n        case FF_QUIT_EVENT:\n\n            do_exit(cur_stream);\n\n            break;\n\n        case FF_ALLOC_EVENT:\n\n            video_open(event.user.data1);\n\n            alloc_picture(event.user.data1);\n\n            break;\n\n        case FF_REFRESH_EVENT:\n\n            video_refresh(event.user.data1);\n\n            cur_stream->refresh=0;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 10767, "substitutes": {"cur_stream": ["curplesource", "ser_thread", "curacsystem", "curksystem", "ser_system", " cur_source", "cour_client", "curplesteam", "cur__steam", "curksurface", "public_steam", "curxform", "ur_form", "curacsteam", "curksteam", "cur_steam", "prev_object", "tur_stream", "curtheform", "curssource", "cur_speed", "rah_row", "rah_form", "cur_engine", "curplesound", "curfsteam", "cur1stream", "curfsurface", "publictheenc", "currsample", "pr_surface", "cur_form", "pull_stream", "cur_sound", "curappform", "cur_cloud", "curvalstream", "cur_model", "ur_sw", "curkstream", "curtheenc", "pull_system", "Cur_stream", "curUsystem", "pullUsystem", "cour_host", "curalstream", "Cur_clean", "curappstream", "curgsurface", "curappclean", "cur_surface", "cur_sw", "curgstream", "curxstem", "cur_source", "prvalsteam", "cour_thread", "cur_object", "cur1thread", "pull_sound", "cur__form", "cour_cloud", "cur_track", "ser_speed", " cur_steam", "Cur_form", "pull_sw", "curvalslice", " cur_stem", "curxtrack", "cur_sample", "cour_design", "curappcloud", "curacsurface", "Cur_cloud", "courUsurface", "cour_system", "cour_engine", "publictheform", "curvalsteam", "pr_slice", "curUsteam", "courUstream", "curthestream", "curplestream", "prvalstream", "cur1sound", "cursstream", " cur_track", "cur_row", "ur_stream", "curgstick", "pull_thread", "cur1source", "public_enc", "curthesteam", "prvalsurface", "prev_track", "curkspeed", "pr_steam", "curalthread", "cur_enc", "cur__stream", "pr_stream", "courUengine", "curUstick", "cur_clean", "cur_slice", " cur_clean", "cour_form", "cur_system", "cour_stick", "tur1sound", "tur_source", "cur_transform", "pull_source", "pullUsteam", "cursthread", "pull_surface", "curactransform", "Cur_transform", " cur_form", "curgengine", "curUsurface", "rah_stream", "cur_host", "cur_client", " cur_thread", "prev_thread", "Cur_model", "curalhost", "publicthestream", "public_stream", "prev_stream", "ur_sample", "cur__speed", "curacstream", "curfstream", "tur1source", "curaldesign", "cur_stick", "curacmodel", "curvalsurface", "curssteam", "curxstream", "publicthesteam", "cur_thread", "courUstick", "currsw", "tur_sound", "cour_surface", "prvalslice", "cur_stem", "pullUstream", " cur_speed", "pull_steam", "rah_sample", "ser_stream", "currform", "tur1stream", "cur1form", "cursform", "curfslice", "cur_design", "cour_stream", "currstream", "pullUsurface", "public_form", "curUengine", "curkthread", "curacform", "cour_source", "curUstream"], "event": ["ee", "element", "g", "val", "in", "comment", "test", "view", "key", "ent", "t", "instance", "update", "vent", "data", "c", "e", "Event", "xml", "pe", "bug", "ec", "condition", "empty", "style", "f", " Event", "an", "entry", "ev", "call", "exc", "ce", "name", "input", "feature", "end", "object", "entity", "address", "ception", "load", "error", "advert", "node", "type", "self", "change", "form", "handler", "message", "command", "esc", "ge", "image", "result", "press", "text", "events", "exec"], "incr": ["indrs", "integr", "incre", "integrs", "encpr", "Incerr", "intr", "discrl", " incre", "incrs", "discra", "imprs", " incrb", "infr", "infpr", "integre", "incpr", "intre", "encrl", "accl", "encerr", "Incre", "infra", "incra", "imperr", " incp", "accp", "accr", "encp", " incrum", "Incrb", "incrum", "infrl", "incrl", " incerr", "incp", "impr", "intrs", "integerr", "incl", "encrb", "inderr", "indr", "discpr", " incra", "incerr", " incrs", " incl", "encre", "incrb", "imprum", "encl", "discr", "encr", "indrum", "interr", "encra", "Incr", "accra"], "pos": ["POS", "diff", "sp", "conf", "area", "cond", "location", "pass", "start", "str", "len", "val", "axis", "def", "all", "pl", "pid", "pointer", "block", "slot", "sum", "p", "ref", "limit", "config", "rel", "po", "pt", "style", "loc", "prop", "push", "os", "rot", "next", "unit", "vol", "index", "slice", "pres", "ind", "space", "Pos", "fat", "pr", "end", "port", "patch", "part", "pc", "position", "offset", "spec", "col", "fin", "type", "cache", "resp", "feat"], "frac": ["count", "abc", "window", "win", " fraction", "cut", "angle", "ref", "qa", "sec", "ac", "unit", "alpha", "exc", "fre", "cap", "format", "rc", "fun", " circ", "repeat", "callback", "circ", "bit", " delta", "feat", "fc"], "x": [" cx", "xf", " X", "xp", "xx", "w", "m", "b", "z", "d", "c", "ct", "X", " dx", "f", "xa", "index", " tx", "wx", "xc", "xy", "xe", "rx", "y", "ex"]}}
{"project": "FFmpeg", "commit_id": "72555f4a382744dd7f02edcb7fe6f8ed91f4dc3c", "target": 1, "func": "int ff_alloc_entries(AVCodecContext *avctx, int count)\n\n{\n\n    int i;\n\n\n\n    if (avctx->active_thread_type & FF_THREAD_SLICE)  {\n\n        SliceThreadContext *p = avctx->internal->thread_ctx;\n\n        p->thread_count  = avctx->thread_count;\n\n        p->entries       = av_mallocz_array(count, sizeof(int));\n\n\n\n        if (!p->entries) {\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        p->entries_count  = count;\n\n        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));\n\n        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));\n\n\n\n        for (i = 0; i < p->thread_count; i++) {\n\n            pthread_mutex_init(&p->progress_mutex[i], NULL);\n\n            pthread_cond_init(&p->progress_cond[i], NULL);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 439, "substitutes": {"avctx": ["abca", "AVctx", "avectx", "afcmp", "afctx", "afcontext", "raftcontext", "afpkg", "abcmp", "avpkg", "afctl", "aveca", "svcal", "auctl", "afcal", "auctx", "AVcu", "AVctl", "abctx", "svctx", "afcu", "raftpkg", "avctl", "aucontext", "avcontext", "avca", "abcontext", "svpkg", "avecontext", "svcontext", "afca", "avcmp", "raftctx", "avcu", "raftcal", "AVcmp", "AVcontext", "avecmp", "aucmp", "avecu", "avcal"], "count": ["call", "base", "name", "total", "offset", "ext", "counter", "current", "n", "page", "type", "weight", "id", "found", "parent", "num", "max", "code", "number", "index", "work", "c", "deep", "len", "length", "size", "child", "cache", "force", "col", "sum", "seq", "depth", "path", "low", "Count", "limit", "list", "part", "start"], "i": ["yi", "li", "gi", "q", "abi", "key", "a", "ni", "ii", "zi", "ji", "ui", "pi", "oi", "r", "d", "I", "di", "n", "id", "it", "iu", "k", "j", "y", "m", "ri", "info", "ti", "multi", "index", "ini", "ai", "ip", "l", "c", "phi", "bi", "h", "e", "x", "f", "lc", "u", "o", "v", "s", "qi", "b", "t", "ix", "uri", "ci", "io", "mu", "fi", "start", "si", "xi"], "p": ["np", "parser", "vp", "ctx", "http", "lp", "pe", "data", "pi", "current", "d", "n", "ap", "pg", "sp", "cop", "it", "parent", "pb", "k", "op", "api", "pre", "j", "comp", "tp", "g", "y", "m", "fp", "P", "sync", "ps", "post", "pa", "l", "c", "ip", "e", "private", "per", "f", "patch", "hp", "u", "jp", "pm", "exec", "up", "o", "pc", "bp", "s", "at", "v", "cp", "b", "t", "plugin", "wp", "part", "pp", "port"]}}
{"project": "qemu", "commit_id": "217bfb445b54db618a30f3a39170bebd9fd9dbf2", "target": 1, "func": "static void gic_complete_irq(gic_state * s, int cpu, int irq)\n\n{\n\n    int update = 0;\n\n    int cm = 1 << cpu;\n\n    DPRINTF(\"EOI %d\\n\", irq);\n\n    if (s->running_irq[cpu] == 1023)\n\n        return; /* No active IRQ.  */\n\n    if (irq != 1023) {\n\n        /* Mark level triggered interrupts as pending if they are still\n\n           raised.  */\n\n        if (!GIC_TEST_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm)\n\n                && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) {\n\n            DPRINTF(\"Set %d pending mask %x\\n\", irq, cm);\n\n            GIC_SET_PENDING(irq, cm);\n\n            update = 1;\n\n        }\n\n    }\n\n    if (irq != s->running_irq[cpu]) {\n\n        /* Complete an IRQ that is not currently running.  */\n\n        int tmp = s->running_irq[cpu];\n\n        while (s->last_active[tmp][cpu] != 1023) {\n\n            if (s->last_active[tmp][cpu] == irq) {\n\n                s->last_active[tmp][cpu] = s->last_active[irq][cpu];\n\n                break;\n\n            }\n\n            tmp = s->last_active[tmp][cpu];\n\n        }\n\n        if (update) {\n\n            gic_update(s);\n\n        }\n\n    } else {\n\n        /* Complete the current running IRQ.  */\n\n        gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]);\n\n    }\n\n}\n", "idx": 13706, "substitutes": {"s": ["i", "rs", "qs", "new", "si", "js", "times", "ps", "groups", "lines", "tests", "stat", "spec", "c", "is", "sv", "sl", "states", "m", "self", "t", "sync", "sg", "fs", "sym", "g", "cs", "es", "session", "u", "sf", "b", "ns", "ops", "r", "sie", "ks", "secondary", "sys", "parts", "service", "sets", "o", "e", "http", "site", "sb", "f", "state", "services", "ls", "comments", "ses", "l", "changes", "sites", "S", "settings", "this", "its", "uns", "sq", "v", "ss", "request", "p", "se", "plugins", "gs", "xs", "stats", "ssl", "ds", "su", "vs"], "cpu": ["proc", "mc", "course", "pixel", "module", "cmp", "fp", "screen", "gru", "server", "np", "count", "c", "cp", "num", "nic", "cpp", "chip", "gc", "lc", "cn", "vm", "uca", "campus", "loader", "GPU", " CPU", "lag", "clock", "cale", "cap", "cache", "xc", "mac", "lb", "core", "thread", "username", "consumer", "queue", "ilo", "config", "pc", "current", "connection", "ci", "uu", "unit", "px", "pid", "conn", "processor", "boot", "nc", "CPU", "site", "uci", "gpu", "lu", "loop", "net", "ctx", "node", "gp", "piece", "bench", "cm", "uc", "tmp", "worker", "name", "PC", "capacity", "performance", "computer", "rpm", "pu", "platform", "col", "cli", "component", "cu", "process", "network", "login", "pai", "css", "len"], "irq": ["ierqi", "ircle", "earquest", "irue", "hrqu", "irqa", "iriche", "IRquest", "irtq", "iriqa", "irtQ", "urqa", "airq", " irrc", "irtque", "irequal", "iriqu", "arinqu", "urqi", "ireQ", "ariqu", "irreq", "ariQ", "irinQ", "iriquest", "hrue", "irireq", "irinq", "irce", " irqu", "srue", "yrche", "arinqa", "arinquest", "ierq", "ierquest", "earQ", "rrque", "irrc", "earqu", "irtch", "srque", "irirc", "iriQ", "irqual", "ariq", "ironq", " irue", "airqa", "IRqi", "yrq", "irquest", "irch", "ierreq", "irique", "arique", "yrQ", "ironqu", "iraqu", " irqa", "irtcle", "irqi", "iraque", "yrque", "rrq", "irque", "srq", "ierqu", "IRche", "irQ", "earque", "irtqi", "irach", "airqu", "iraqual", "srqu", "ierQ", "urqu", "irtqa", "yrquest", "rrqa", "rrcle", " irQ", "urq", "airreq", "hrq", "irtqu", "iraqi", "iraqa", "iracle", "irtquest", "IRq", "irtqual", "irace", " irque", "irinqu", "irche", "irerc", "irache", " irquest", "ierqa", "irtche", "hrque", "IRque", "ireque", "earqa", "irece", "iraq", "ironch", "ireche", "IRQ", "irinque", "irtce", "arinq", "ireq", "earq", "ironque", "iriq", "irqu"]}}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void xen_remap_bucket(MapCacheEntry *entry,\n\n                             hwaddr size,\n\n                             hwaddr address_index)\n\n{\n\n    uint8_t *vaddr_base;\n\n    xen_pfn_t *pfns;\n\n    int *err;\n\n    unsigned int i;\n\n    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;\n\n\n\n    trace_xen_remap_bucket(address_index);\n\n\n\n    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));\n\n    err = g_malloc0(nb_pfn * sizeof (int));\n\n\n\n    if (entry->vaddr_base != NULL) {\n\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n\n            perror(\"unmap fails\");\n\n            exit(-1);\n\n        }\n\n    }\n\n    g_free(entry->valid_mapping);\n\n    entry->valid_mapping = NULL;\n\n\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;\n\n    }\n\n\n\n    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,\n\n                                     pfns, err, nb_pfn);\n\n    if (vaddr_base == NULL) {\n\n        perror(\"xc_map_foreign_bulk\");\n\n        exit(-1);\n\n    }\n\n\n\n    entry->vaddr_base = vaddr_base;\n\n    entry->paddr_index = address_index;\n\n    entry->size = size;\n\n    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *\n\n            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));\n\n\n\n    bitmap_zero(entry->valid_mapping, nb_pfn);\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        if (!err[i]) {\n\n            bitmap_set(entry->valid_mapping, i, 1);\n\n        }\n\n    }\n\n\n\n    g_free(pfns);\n\n    g_free(err);\n\n}\n", "idx": 18512, "substitutes": {"entry": ["extra", "element", "comment", "service", "inc", "package", "ie", "enc", "import", "comp", "config", "end", "it", "command", "source", "reader", "plugin", " Entry", "archive", "name", "engine", "ge", "entity", "existing", "parse", "the", "Entry", "key", "update", "lc", "cat", "si", "table", "item", "cell", "row", "export", "connection", "ent", "view", "image", "component", "try", "match", "ry", "ae", "post", "address", "lock", "ace", "session", "record", "data", "info", "feed", "option", "enter", "module", "index", "member", "get", "parser", "ce", "event", "cel", "add", "e", "ries", "cur", "insert", "cache", "error", "server", "se", "inner"], "size": ["set", "offset", "file", "num", "six", "max", "strength", "sec", "empty", "location", "sh", "new", "path", "large", "length", "send", "external", "bytes", "Size", "len", "scale", "content", "name", "handle", "engine", "from", "cm", "timeout", "count", "si", "shift", "gz", "weight", "code", "time", "core", "SIZE", "sized", "block", "loc", "speed", "memory", "sn", "ize", "security", "sync", "c", "address", "fee", "sum", "s", "small", "capacity", "data", "mode", "shape", "gc", "password", "member", "ui", "use", "limit", "e", "unit", "cache", "storage", "number", "body"], "address_index": ["address_ind", "ip_id", "position_index", "address_length", "address2index", " address_position", " address_address", "address2Index", "ip__slice", "address__id", "address2prefix", "address__address", "address__slice", " address_length", "address__index", " address_ind", "position2index", "address_Index", "position_offset", "position_prefix", "address_start", "address_position", "address2id", "address__ind", " address_slice", "address_offset", "address__list", "address_slice", "address_prefix", "address_list", "address2offset", "ip_start", "ip_slice", "ip__start", "position2prefix", "position2offset", "address_id", " address_list", "position2Index", "ip__id", "address2slice", "ip__index", "address2start", "address__start", "ip_index", "address_address", "position_Index"], "vaddr_base": ["vaddr2area", "vsp_base", "vsp__count", "vaddr__count", "vattr_bas", "vaddr_bas", "vsp__base", "vaddr2Base", "vdr_index", "vaddr_area", "vaddr_bi", "vaddr2cache", "vaddr_prefix", "vaddr2base", "vaddr_address", "vsp_Base", "vrt_bas", "vaddress_bas", "vaddress_home", "vad_full", "vattr_full", "vaddr_cache", "vaddr_count", "vaddr_home", "vaddress_base", "vdr_base", "vsp__len", "vad_base", "vaddr_based", "vad_Base", "vattr_address", "vaddr__len", "vrt_base", "vdr_prefix", "vdr_bas", "vsp_count", "vrt_area", "vaddr_len", "vaddr_full", "vaddr_index", "vsp__Base", "vaddress_based", "vsp_len", "vaddr__base", "vad_bi", "vaddr_Base", "vaddr__Base", "vattr_base"], "pfns": ["pcfails", "pafns", "pfxks", "vfks", "Pfails", "pfks", "pdfts", "pffs", "pdfns", "Pfks", "psfirs", "pfcns", "pofls", "pfcnc", "pfnes", "pfn", "pcfks", "psfns", "pfsails", "pafnc", "pcfls", "poffs", "pfsbs", "pdfls", "psfnes", "pdfnc", "Pcfails", "pcfnc", "pcfbs", "pfdls", "pfls", "Pfbs", "vfns", "pfbs", "prefks", "pofns", "Pcfns", "pfdks", " pdefnc", " pfls", "pdefls", "prefns", "pofks", "tfcn", "pfxns", "pcfns", "tfcns", "pfdfs", "pfcls", " pdefns", "pofbs", "tfls", "Pcffs", "pafn", "pfcn", "pfnc", "pfxnes", "tfnc", " pfts", "tfn", "tfns", "Pcfbs", " pdefts", "vfnes", "pcffs", "pcfn", " pdefls", "Pfns", "pfsls", "vfxns", "Pcfls", "pdefns", "pfxirs", "psfks", "prefirs", "pfirs", "tfcnc", "vfxks", "prefnes", "vfirs", " pfnc", "pdefts", "pfdns", "pfails", "vfxirs", "pfsns", "pafls", "Pcfks", "pcfts", "tfcls", "Pffs", "pdefnc", "Pfls", "vfxnes", "pofails", "pfts"], "err": ["status", "rr", "ner", "rage", "fr", "ch", "conf", "f", "eor", "runner", "sp", "ini", "rc", "r", "inc", "phi", "result", "ar", "str", "late", "ok", "cb", "icer", "nor", "arm", "rh", "loc", "msg", "finder", "ind", "der", "ise", "resp", "arr", "fer", "gr", "bug", "nr", "aster", "order", "mr", "rar", "aa", "rn", "ler", "dr", "lr", "acer", "req", "erg", "yr", "ir", "p", "test", "Error", "error", "Er", "res", "er", "errors", "iter", "fi", "inner", "attr", "len"], "i": ["uri", "gi", "ti", "m", "bi", "ei", "init", "j", "ji", "info", "x", "f", "ix", "ini", "qi", "r", "io", "mi", "n", "phi", "ai", "hi", "z", "ii", "in", "ie", "di", "iu", "index", "ori", "I", "mini", "multi", "zi", "o", "ip", "chi", "l", "d", "oi", "yi", "pi", "ui", "ci", "id", "start", "e", "v", "c", "ni", "si", "ri", "p", "xi", "b", "mu", "u", "a", "it", "eni", "fi", "inner", "y", "li", "len"]}}
{"project": "FFmpeg", "commit_id": "d2ee495fb241fa4ef5b8b56161328c4379d1c79a", "target": 1, "func": "void ff_mlp_init_x86(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n#if HAVE_7REGS && HAVE_TEN_OPERANDS\n\n    c->mlp_filter_channel = mlp_filter_channel_x86;\n\n#endif\n\n}\n", "idx": 5731, "substitutes": {"c": ["cmp", "ch", "cr", "v", "cur", "s", "ci", "config", "nc", "rc", "enc", "C", "m", "cm", "f", "pc", "cc", "cs", "arc", "e", "mc", "sc", "dc", "t", "ctx", "bc", "cb", "self", "context", "p", "ec", "ca", "g", "cf", "lc", "fc", "cv", "ac", "vc", "cpp", "ctrl", "xc", "tc"], "avctx": ["afcontext", "avkb", "afconfig", " avcontext", "avcontext", "AVctx", "AVconfig", "avconfig", "AVcontext", " avconfig", "afkb", " avkb", "AVkb", "afctx"]}}
{"project": "qemu", "commit_id": "e2f89926f19d2940eda070542501f39f51a8c81f", "target": 1, "func": "int usb_packet_map(USBPacket *p, QEMUSGList *sgl)\n\n{\n\n    int is_write = (p->pid == USB_TOKEN_IN);\n\n    target_phys_addr_t len;\n\n    void *mem;\n\n    int i;\n\n\n\n    for (i = 0; i < sgl->nsg; i++) {\n\n        len = sgl->sg[i].len;\n\n        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,\n\n                                      is_write);\n\n        if (!mem) {\n\n            goto err;\n\n        }\n\n        qemu_iovec_add(&p->iov, mem, len);\n\n        if (len != sgl->sg[i].len) {\n\n            goto err;\n\n        }\n\n    }\n\n    return 0;\n\n\n\nerr:\n\n    usb_packet_unmap(p);\n\n    return -1;\n\n}\n", "idx": 16211, "substitutes": {"p": ["port", "proc", "m", "po", "d", "t", "pc", "jp", "l", "a", "pre", "g", "sp", "lp", "pp", "post", "ap", "v", "patch", "ps", "o", "bp", "u", "e", "pb", "pa", "data", "b", "op", "j", "n", "f", "point", "wp", "parent", "c", "pe", "per", "pi", "q", "process", "cp", "r", "pr", "pat", "P", "tp"], "sgl": ["sgb", "pssl", "sGl", "psgl", " sbl", "chesgb", "wsdl", "fsgl", "sysGL", "ssbl", "chesgel", "sgn", "opsgl", "wsgl", "anslu", " sdl", "sysdl", " sGL", "sbl", "opsbl", " slu", "fsgb", " sgel", "wsGL", "slu", "fsgel", "sdl", "chesgl", " sGl", "slam", "ansgb", "cheslam", "fslam", "sGL", "ssgb", " splay", "sysplay", "opsdl", "ansgl", " slam", " ssl", "wsplay", "ssl", "sslu", "sgel", "ssgl", "ansbl", " sgb", " sglobal", "opsgn", "sysgl", "sglobal", " sgn", "splay", "psGl", "psglobal"], "len": ["ln", "en", "rev", "part", "lin", "non", "fl", "Len", "ni", "id", "l", "val", "lan", "lic", "lon", "split", "label", "name", " length", "lc", "fun", "low", "dl", "str", "lang", "ie", "lit", "ld", "limit", "lib", " l", "z", "ll", "size", "la", "lif", "fi", "fin", "li", "data", "pl", "base", "min", "ler", "length", "lf", "n", "f", "line", "count", "il", "lu", "afi", "gen", "ell", "cap", "le", "lex", "den", "seq", "pos", "num", "lock", "el", "bl", "del", "lim", "err"], "mem": ["device", "m", "bin", "ram", "val", "l", "memory", "mp", "me", "home", "name", "g", " Mem", "fun", "sp", "mob", "cpu", "pool", "ref", "vm", "buffer", "mm", "loc", "em", "job", "buff", "mb", "conn", "size", "la", "med", "mor", "lif", "fi", "temp", "mi", "buf", "data", "base", "f", "lf", "mo", "ann", "rm", "ip", "dem", "wa", "le", "lex", "cache", "mac", "Mem", "num", "reg", "el", "hw", "nm", "lim", "alloc"], "i": ["en", "val", "oi", "x", "si", "limit", "base", "phi", "c", "ami", "zi", "in", "index", "hi", "m", "d", "t", "xi", "id", "iu", "iv", "io", "api", "ki", "di", "u", "s", "fi", "b", "ti", "ip", "eni", "r", "bi", "el", "mu", "qi", "ni", "ini", "ci", "ie", "o", "z", "e", "info", "li", "ix", "multi", "j", "f", "err", "it", "ui", "adi", "I", "ai", "l", "gi", "ii", "uri", "v", "yi", "mi", "cli", "n", "pi", "all", "ri", "ori", "y", "abi"]}}
{"project": "qemu", "commit_id": "ffad4116b96e29e0fbe892806f97c0a6c903d30d", "target": 0, "func": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(buf, sizeof(buf), params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n", "idx": 10899, "substitutes": {"arg": ["mac", "arc", "gen", "arr", "param", "oc", "argument", "flag", "pg", "g", "val", "mor", "tag", "ang", "doc", "ad", "slot", "ref", "ace", "reg", "ag", "args", "op", "ac", "call", "parse", "amp", "ig", "inc", "input", "ar", "pc", "enc", "rg", "match", "Arg", "par", "exec"], "snapshot": ["preshot", "preview", "preprint", "snapview", "picshot", "imagevision", "imageprint", "snapvision", "picview", "picprint", "picvision", "prevision", "snapprint", "imageshot", "imageview"], "opaque": ["paque", "operc", "opacity", "opcam", " opc", "opac", "ospaque", "ospcam", "iopacity", "operacity", "iopaque", " opac", " opacity", "iopac", "pac", "opc", "ospac", "opercam", "pacity", "pc", "ospacity", "iopcam", "operaque", "operac"], "buf": ["bag", "grab", "uf", "ru", "seq", "arr", "holder", "img", "context", "pad", "src", "fd", "path", "b", "filename", "num", "wb", "fw", "pool", "doc", "block", "bridge", "fb", "config", "ref", "cb", "queue", "usr", "cf", "rb", "loc", "array", "args", "bc", "nat", "code", "bt", "ctr", "cv", "msg", "cap", "exc", "rc", "input", "cas", "ctx", "cur", "loader", "port", "begin", "desc", "bus", "uint", "header", "text", "buff", "vec", "proc", "br", "cmd", "buffer", "result", "func", "box", "uc", "runner"], "file": ["cpu", "channel", "byte", "base", "comment", "source", "class", "id", "model", "files", "path", "filename", "block", "line", "data", "uri", "stream", "queue", "array", "body", "f", "binary", "unit", "db", "resource", "profile", "name", "input", "object", "port", "part", "bus", "File", "image", "buffer", "book"], "devname": ["busno", "defno", " devpath", "defnames", " devnames", "modsize", "devnames", "busName", "divno", " devName", "modName", "devicesize", "divsize", "devicenames", "evname", "evno", "divName", " devno", "buspath", "modname", "devsize", "divname", "devicepath", "modnames", "evpath", "deviceName", "busname", "devicename", "devName", "devpath", "defname", "modno", "devno", "defName", "deviceno"], "serial": ["parent", "pass", "cmp", "comment", "prefix", "model", "pack", "tag", "mount", "toc", "mask", "uri", "util", "status", "loc", "mode", "device", "version", "series", "master", "desc", " bus", "spec", "controller", "lang", "dev", "proc"], "mediastr": ["generustrs", "mediestry", "mediustrb", "generustr", "mediastrs", "generastrb", "mediastry", "mediustrs", "generastr", "generastry", "mediastrb", "mediestrs", "generustrb", "mediastsr", "mediustr", "mediastsrs", "mediestrb", "mediastsrb", "generustry", "generastrs", "mediastsry", "mediestr", "mediustry"], "type": ["parent", "base", "comment", "source", "class", "key", "view", "info", "method", "id", "model", "like", "tag", "t", "instance", "by", "Type", "block", "rule", "config", "p", "data", "pb", "time", "rel", "pe", "role", "style", "types", "code", "unit", "label", "o", "resource", " TYPE", "format", "name", "state", "user", "ty", "full", "part", "position", "error", "TYPE", "link", "command", "image", "y", "ype", "family", "typ"], "media": ["library", "music", "Media", "source", "record", "m", "model", "i", "data", "vm", "package", "script", "memory", "style", "language", "mode", "manager", "resource", "device", "shared", "format", "medi", "connection", "document", "port", "audio", "pi", "storage", "java", "command", "ma", "volume", "medium", "interface", "image", "ype"], "bus_id": ["bus__num", "BUS_info", " bus_num", "bus_num", "us__ids", " bus_name", "us_id", "bus__name", "busuuid", "busuuname", "bus_Id", "bus_name", "BUS_ids", "busuuhead", "bus_ids", "unit_ids", "busuunum", "busPname", "BUS_id", "busPhead", "bus_kid", "BUS_kid", "bus__id", " bus_head", "us_name", "bus_head", "bus__ids", "us__num", "us_num", "busPid", "us__name", "bus_info", "us__id", "us_ids", "busPnum", "unit_Id", "unit_name"], "unit_id": [" unit_name", "unit_sid", "unit__ident", "bus_ident", "unit_ident", "unit__id", "bus_name", "unit_num", " unit_sid", "block_kid", "block_id", " unit_num", "block_name", "unit_name", "unit_kid", "unit__name"], "cyls": ["cheles", "tyils", "gyls", "gyll", "cryils", "coples", "gyles", "gyvs", "coplf", "tylf", "cyll", "cryls", " cyvs", "cryles", " cyles", "cyles", "chevs", "copils", "chell", "cyvs", "cyils", " cyll", "tyls", "tyles", "crylf", "chels", "copls", "cylf"], "heads": ["loads", "stars", "devices", "frames", "workers", "rows", "links", "files", "head", "reads", "views", "jobs", "tests", "ids", "drivers", "offs", "pages", "lines", "types", "plugins", "tails", "obs", "sections", "flags", "modules", "checks", "locks", "pull", "scenes", "blocks", "headers", "shots", "docs", "HEAD", "times", "comments", "issues"], "secs": [" seclocks", "sectS", "ECS", "seclocks", "sects", " secls", "isecls", "secls", "iseclocks", "SECls", "SEClocks", "isecs", "sectds", "secr", " secS", "SECs", "isecds", "SECS", "secds", "secS", "sectr", "isecS", "ECds", "ECr", "isecr", "ECs"], "translation": ["Translation", "alias", "conf", "utils", "base", "comment", "source", "prefix", "val", "info", " translations", "layout", "late", "qa", "language", "loc", "padding", "rot", "la", "version", "description", "master", "name", "port", "trans", "ping", "position", "offset", "lang", "seconds", "pos", "message", "border", "options", "comments", "length", "text", "activation", "settings"], "bdrv": ["Bdrw", "Bdrp", "BDrp", "Bdrf", "BDrw", "BDrf", "bdrp", "bDrf", "bdrf", "BDrv", "bdrw", "bDrv", "bDrw", "bDrp", "bdriw", "Bdrv", "bdrif", "bdriv", "bdrip"], "drv": [" drb", "DrV", "srp", "drp", "srV", "drV", "Drp", "srb", " drp", "srv", " drV", "Drb", "drb", "Drv"], "machine": ["mac", "boot", "m", "info", "model", "mob", "mount", "template", "instance", "bridge", "vm", "service", "config", "meta", "computer", "driver", "target", "memory", "Machine", "slave", "mode", "manager", "unit", "device", "process", "connection", "storage", "bus", "node", "controller", "ma", "interface", "image", "engine", "proc", "mc", "buffer"], "max_devs": ["max_evs", "max_devns", "max_evS", "max_devicen", "max_devps", "max_devges", "max_devi", "max_pubi", "max_deps", "max_deviceS", "max_evges", "max_pubs", "max_depi", "max_deviceps", "max_depn", "max_devicei", "max_devS", "max_devicep", "max_devn", "max_evi", "max_devices", "max_libges", "max_pubps", "max_pubS", "max_evn", "max_evps", "max_evns", "max_depp", "max_libi", "max_devicens", "max_libs", "max_devp", "max_deviceges", "max_evp", "max_libns"], "index": ["parent", "diff", "level", "axis", "prefix", "key", "view", "info", "speed", "id", "x", "page", "Index", "num", "toc", "pointer", "head", "config", "action", "condition", "loc", "priority", "unit", "scan", "version", "slice", "inc", "input", "connection", "ind", "proxy", "miss", "position", "error", "offset", "ticket", "pos", "loop", "image", "length", "weight", "depth"], "cache": ["count", "parent", "conf", "session", "timeout", "base", "delay", "cmp", "comment", "prefix", "capacity", "temp", "pack", "tag", "pool", "toc", "c", "Cache", "pointer", "batch", "config", "ref", "slot", "block", "global", "ac", "child", "scan", "race", "master", "sync", "rc", "pre", "miss", "frac", "acl", "pc", "read", "lock", "cat", "ache", "loop", "result", "lc", "buffer"], "bdrv_flags": ["bdrv_bits", "bdrv_ops", "bdrf_flags", "bdrf_ops", "bdrv_flag", "bdrf_flag", "bdrf_bits"], "onerror": ["error", "override", "erride", "onerrors", "rerride", "onerception", "rerception", "rerror", "rerrors", "overrors", "onerride", "overror", "overception", "erception", "errors"], "drives_table_idx": ["drives_table_sidxs", "drives_table_dx", "drives_table_sidx", "drives_table_sidv", "drives_table_dxs", "drives_table_dxc", "drives_table_idxc", "drives_table_dv", "drives_table_idxs", "drives_table_idv", "drives_table_sidxc"], "str": ["cr", "sp", "seq", "arr", "pass", "tr", "proc", "strings", "dict", "fr", "Str", "String", "doc", "c", "config", "obj", "lit", "STR", "iter", "cf", "strip", "rs", "empty", "st", "bc", "dr", "inst", "cs", "ctr", "msg", "format", "sync", "name", "sl", "r", "req", "err", "expr", "part", "spec", "enc", "cat", "ocr", "url", "text", "lc", "br", "vec", "par", "exec"], "params": ["vs", " param", "vals", "mac", "conf", "Parameters", "arr", "param", "ams", "info", " args", "data", "block", "config", "p", "obj", "names", "attr", "afi", "args", "rb", "rs", "prop", "types", "array", "description", "ctx", "req", "r", "acl", "details", "desc", "spec", " parameters", "pos", "options", "url", "ps", "css", "proc", "par", "settings"]}}
{"project": "FFmpeg", "commit_id": "b7b8fc340632d15cb3b26a57915ebea84f37d03e", "target": 0, "func": "static int rtsp_read_header(AVFormatContext *s,\n\n                            AVFormatParameters *ap)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    char host[1024], path[1024], tcpname[1024], cmd[2048];\n\n    URLContext *rtsp_hd;\n\n    int port, i, ret, err;\n\n    RTSPHeader reply1, *reply = &reply1;\n\n    unsigned char *content = NULL;\n\n    AVStream *st;\n\n    RTSPStream *rtsp_st;\n\n    int protocol_mask;\n\n\n\n    rtsp_abort_req = 0;\n\n    \n\n    /* extract hostname and port */\n\n    url_split(NULL, 0,\n\n              host, sizeof(host), &port, path, sizeof(path), s->filename);\n\n    if (port < 0)\n\n        port = RTSP_DEFAULT_PORT;\n\n\n\n    /* open the tcp connexion */\n\n    snprintf(tcpname, sizeof(tcpname), \"tcp://%s:%d\", host, port);\n\n    if (url_open(&rtsp_hd, tcpname, URL_RDWR) < 0)\n\n        return AVERROR_IO;\n\n    rt->rtsp_hd = rtsp_hd;\n\n    rt->seq = 0;\n\n    \n\n    /* describe the stream */\n\n    snprintf(cmd, sizeof(cmd), \n\n             \"DESCRIBE %s RTSP/1.0\\r\\n\"\n\n             \"Accept: application/sdp\\r\\n\",\n\n             s->filename);\n\n    rtsp_send_cmd(s, cmd, reply, &content);\n\n    if (!content) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    if (reply->status_code != RTSP_STATUS_OK) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n        \n\n    /* now we got the SDP description, we parse it */\n\n    ret = sdp_parse(s, (const char *)content);\n\n    av_freep(&content);\n\n    if (ret < 0) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    \n\n    protocol_mask = rtsp_default_protocols;\n\n\n\n    /* for each stream, make the setup request */\n\n    /* XXX: we assume the same server is used for the control of each\n\n       RTSP stream */\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        char transport[2048];\n\n        AVInputFormat *fmt;\n\n\n\n        st = s->streams[i];\n\n        rtsp_st = st->priv_data;\n\n\n\n        /* compute available transports */\n\n        transport[0] = '\\0';\n\n\n\n        /* RTP/UDP */\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP)) {\n\n            char buf[256];\n\n            int j;\n\n\n\n            /* first try in specified port range */\n\n            if (rtsp_rtp_port_min != 0) {\n\n                for(j=rtsp_rtp_port_min;j<=rtsp_rtp_port_max;j++) {\n\n                    snprintf(buf, sizeof(buf), \"rtp://?localport=%d\", j);\n\n                    if (!av_open_input_file(&rtsp_st->ic, buf, \n\n                                            &rtp_demux, 0, NULL))\n\n                        goto rtp_opened;\n\n                }\n\n            }\n\n\n\n            /* then try on any port */\n\n            if (av_open_input_file(&rtsp_st->ic, \"rtp://\", \n\n                                       &rtp_demux, 0, NULL) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n            }\n\n\n\n        rtp_opened:\n\n            port = rtp_get_local_port(url_fileno(&rtsp_st->ic->pb));\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/UDP;unicast;client_port=%d-%d\",\n\n                     port, port + 1);\n\n        }\n\n\n\n        /* RTP/TCP */\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_TCP)) {\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/TCP\");\n\n        }\n\n\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP_MULTICAST)) {\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), \n\n                     sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/UDP;multicast\");\n\n        }\n\n        snprintf(cmd, sizeof(cmd), \n\n                 \"SETUP %s RTSP/1.0\\r\\n\"\n\n                 \"Transport: %s\\r\\n\",\n\n                 rtsp_st->control_url, transport);\n\n        rtsp_send_cmd(s, cmd, reply, NULL);\n\n        if (reply->status_code != RTSP_STATUS_OK ||\n\n            reply->nb_transports != 1) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        /* XXX: same protocol for all streams is required */\n\n        if (i > 0) {\n\n            if (reply->transports[0].protocol != rt->protocol) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n        } else {\n\n            rt->protocol = reply->transports[0].protocol;\n\n        }\n\n\n\n        /* close RTP connection if not choosen */\n\n        if (reply->transports[0].protocol != RTSP_PROTOCOL_RTP_UDP &&\n\n            (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP))) {\n\n            av_close_input_file(rtsp_st->ic);\n\n            rtsp_st->ic = NULL;\n\n        }\n\n\n\n        switch(reply->transports[0].protocol) {\n\n        case RTSP_PROTOCOL_RTP_TCP:\n\n            fmt = &rtp_demux;\n\n            if (av_open_input_file(&rtsp_st->ic, \"null\", fmt, 0, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n\n            break;\n\n            \n\n        case RTSP_PROTOCOL_RTP_UDP:\n\n            {\n\n                char url[1024];\n\n                \n\n                /* XXX: also use address if specified */\n\n                snprintf(url, sizeof(url), \"rtp://%s:%d\", \n\n                         host, reply->transports[0].server_port_min);\n\n                if (rtp_set_remote_url(url_fileno(&rtsp_st->ic->pb), url) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n                }\n\n            }\n\n            break;\n\n        case RTSP_PROTOCOL_RTP_UDP_MULTICAST:\n\n            {\n\n                char url[1024];\n\n                int ttl;\n\n\n\n                fmt = &rtp_demux;\n\n                ttl = reply->transports[0].ttl;\n\n                if (!ttl)\n\n                    ttl = 16;\n\n                snprintf(url, sizeof(url), \"rtp://%s:%d?multicast=1&ttl=%d\", \n\n                         host, \n\n                         reply->transports[0].server_port_min,\n\n                         ttl);\n\n                if (av_open_input_file(&rtsp_st->ic, url, fmt, 0, NULL) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* use callback if available to extend setup */\n\n    if (ff_rtsp_callback) {\n\n        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, \n\n                             NULL, 0, rt->last_reply) < 0) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n    }\n\n                         \n\n    /* start playing */\n\n    snprintf(cmd, sizeof(cmd), \n\n             \"PLAY %s RTSP/1.0\\r\\n\"\n\n             \"Range: npt=0-\\r\\n\",\n\n             s->filename);\n\n    rtsp_send_cmd(s, cmd, reply, NULL);\n\n    if (reply->status_code != RTSP_STATUS_OK) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n#if 0\n\n    /* open TCP with bufferized input */\n\n    if (rt->protocol == RTSP_PROTOCOL_RTP_TCP) {\n\n        if (url_fdopen(&rt->rtsp_gb, rt->rtsp_hd) < 0) {\n\n            err = AVERROR_NOMEM;\n\n            goto fail;\n\n        }\n\n    }\n\n#endif\n\n\n\n    return 0;\n\n fail:\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        st = s->streams[i];\n\n        rtsp_st = st->priv_data;\n\n        if (rtsp_st) {\n\n            if (rtsp_st->ic)\n\n                av_close_input_file(rtsp_st->ic);\n\n        }\n\n        av_free(rtsp_st);\n\n    }\n\n    av_freep(&content);\n\n    url_close(rt->rtsp_hd);\n\n    return err;\n\n}\n", "idx": 20237, "substitutes": {"s": ["ns", "spec", "settings", "series", "service", "ss", "cs", "d", "new", "qs", "sym", "p", "ks", "sets", "sa", "ts", "sg", "rs", "aws", "self", "o", "su", "v", "si", "S", "ds", "f", "r", "sb", "src", "this", "l", "sync", "private", "c", "ps", "sci", "b", "sys", "your", "es", "sq", "session", "t", "conf", "services", "n", "g", "sl", "ls", "shell", "fs", "xs", "is", "space", "args", "site", "e", "ssl", "client", "ses", "js", "support", "gs", "storage", "parts", "tp", "os", "server", "se", "y"], "ap": ["wp", "au", "al", "jp", "op", "sp", "ar", "ams", "am", "as", "pac", "arr", "att", "aps", "pp", "AP", "ac", "ax", "ad", "pa", "ars", "apt", "mp", "cap", "api", "tp", "arp", "attr", "sa"], "rt": ["rx", "RT", "rr", "tt", "fr", "t", "rs", "vr", "ot", "NT", "tr", "vc", "ct", "rc", "r", "nt", "rm", "rh", "ut", "dt", "bt", "irt", "rf", "art", "att", "rd", "ht", "rn", "rot", "sr", "dr", "qt", "ant", "cr", "req", "rl", "rb", "rss", "vt", "gt", "adr", "sys", "boot", "mt", "ft", "pt"], "host": ["uri", "pattern", "name", "full", "dir", "component", "proxy", "file", "hop", "stream", "method", "type", "node", "src", "localhost", "loc", "password", "object", "head", "ip", "home", "container", "context", "uid", "header", "format", "prefix", "config", "key", "id", "client", "driver", "address", "http", "route", "domain", "h", "Host", "addr", "connection", "frame", "server", "source", "conn", "target"], "path": ["uri", "pattern", "code", "request", "text", "data", "core", "name", "image", "dir", "file", "root", "method", "auth", "ath", "node", "loc", "pass", "ctx", "password", "prop", "container", "PATH", "prefix", "key", "id", "config", "cli", "parent", "temp", "Path", "address", "resource", "route", "desc", "source", "conn", "input"], "tcpname": ["fcppath", "tpname", "tmpname", "fcpname", "tpnam", "fcpurl", "Tcppath", "tcpName", "Tmpname", "tpurl", "twpname", "tfpName", "tppath", "tfpname", "fcpName", "TcpName", "tpprefix", "TmpName", "twpnames", "fmpurl", "tpnames", "Tcpnames", "tchurl", " tcpName", "Tmppath", "tcppath", "tportprefix", "tcpprefix", "tfppath", "tmpurl", "tmppath", "tportnam", "tpName", "tportName", " tportprefix", "Tmpnames", "tchpath", " tcpnam", "twppath", "tmpName", "tcpnames", "tcpurl", "tcpnam", "fmpname", "tchname", " tportName", " tportname", "twpName", " tcpprefix", "fmppath", "tportname", "Tcpname", "fmpName", "tmpnames", "tchName", " tportnam", "tmpprefix"], "cmd": ["cfg", "code", "text", "mode", "cookie", "name", "md", "file", "cf", "comm", "module", "cb", "method", "cp", "src", "auth", "msg", "shell", "ext", "ctx", "password", "filename", "head", "setup", "crypt", "header", "pkg", "Cmd", "config", "pipe", "prefix", "client", "cl", "cat", "req", "cli", "seq", "patch", "cmp", "route", "domain", "cd", "message", "mac", "command", "conn", "target"], "rtsp_hd": ["rtsnp_cd", "rtsp_conn", "rtsc_vd", "rtsp_ctx", "rtsc_hd", "rtsp_xd", "rtsp_dh", "rtsp_rh", "rtsnp_dh", "rtsnp_vd", "rtsp_vd", "rtsnp_ctx", "rtsc_conn", "rtsp_cd", "rtsc_cd", "rtsp_ld", "rtsnp_hd", "rtsnp_hm", "rtsnp_xd", "rtsp_hm", "rtsnp_ld", "rtsnp_rh"], "port": ["part", "m", "offset", "time", "text", "mode", "direction", "ort", "name", "ports", "file", "n", "hop", "stream", "method", "type", "cp", "index", "pos", "priority", "zip", "timeout", "count", "ip", "size", "PORT", "length", "id", "key", "config", "limit", "phone", "parent", "position", "p", "address", "test", "line", "Port", "col", "route", "export", "number", "message", "connection", "end", "server", "source", "version", "target", "len"], "i": ["uri", "gi", "ti", "m", "ami", "info", "x", "image", "jit", "ix", "ini", "qi", "gu", "io", "mi", "ai", "phi", "n", "hi", "type", "ii", "ori", "ie", "iu", "index", "di", "I", "multi", "ip", "chi", "l", "yi", "idi", "pi", "ui", "ci", "id", "start", "key", "e", "k", "v", "ni", "c", "si", "ri", "p", "xi", "b", "u", "h", "iter", "it", "eni", "fi", "inner", "y", "li", "mu"], "ret": ["status", "code", "info", "bit", "ref", "alt", "reg", "r", "rc", "nt", "fun", "lit", "result", "str", "num", "flag", "match", "ut", "msg", "pass", "mem", "resp", "rets", "count", "en", "def", "arg", "arr", "att", "val", "re", "Ret", "read", "feat", "no", "det", "sr", "rev", "RET", "pat", "rep", "res", "fi", "success", "len"], "err": ["raise", "rr", "fr", "rage", "ner", "br", "code", "fg", "r", "hr", "result", "str", "ar", "cb", "rh", "msg", "orig", "ind", "der", "kr", "arr", "fer", "mr", "order", "ler", "dr", "e", "lr", "cr", "cur", "req", "acer", "ir", "Error", "pr", "fy", "error", "er", "iter", "fi", "gr", "ver", "bug"], "reply1": ["request2", "replyOne", "resp1", " replyOne", "Reply2", "resp0", "Reply1", "requestOne", " reply0", " reply2", "request1", "Reply0", "reply2", "reply0", "ReplyOne", "resp2"], "reply": ["entry", "status", "rr", "fr", "request", "info", "data", "f", "call", "comment", "sp", "buffer", "rc", "proxy", "respond", "r", "service", "report", "result", "query", "shell", "msg", "ry", "resp", "replace", "link", "rec", "answer", "parse", "re", "response", "sr", "serv", "prev", "send", "sync", "rev", "req", "repl", "address", "b", "resource", "next", " replies", "sys", "rep", "write", "message", "server", "sq", "Reply", "transfer"], "content": ["status", "ch", "code", "data", "text", "x", "connect", "comment", "media", "reg", "results", "rc", "file", "cm", "script", "result", "cf", "clean", "match", "msg", "accept", "ext", "ctx", "resp", "enc", "exec", "load", "cs", "rec", "header", "found", "read", "cont", "cms", "complete", "size", "resh", "con", "config", "response", "temp", "c", "address", "xml", "resource", "Content", "output", "body", "message", "desc", "server", "command", "conn"], "st": ["ist", "est", "part", "fr", "nd", "t", "rest", "ct", "sp", "ste", "td", "fe", "str", "sb", "ost", "stream", "sl", "ast", "ss", "src", "ut", "ld", "ptr", "ST", "sa", "sd", "sta", "d", "std", "sn", "start", "sc", "dr", "sth", "stage", "sts", "St", "inst", "mt", "ft", "se", "pt"], "rtsp_st": ["rtsf__ct", "rtsf_stream", "rtsf__st", "rtsp__st", "rtsf_sth", "rtsf_ct", "rtsp_sth", "rtsv_hd", "rtsf_st", "rtsp__ct", "rtsp_stream", "rtsp_ct", "rtsv_sth", "rtsv_da", "rtsv_st", "rtsp_da", "rtsp__stream", "rtsf__stream", "rtsp__sth", "rtsf__sth"], "protocol_mask": ["protocol__mask", "protocol__depth", "protolution_Mask", "protolution_mask", "protocol_delay", "protchannel_delay", "protocol_count", "protocol_depth", "protocol_Mask", "protchannel_count", "protocol_pad", "protolution_ask", "protchannel_mask", "protocol__pad", "protocol_ask"], "transport": ["traport", " transpose", "ranscode", "transocol", " transocol", "trapose", "Transmission", "Transport", "transpose", "transferpose", "transmission", "Transports", "transferocol", "tramission", "traports", "ransport", "ranspose", "transports", "transcode", "transferport", "ransocol", "transfercode", " transcode", " transmission", "Transpose", " transports"], "fmt": [" fm", "cfmt", "cfkt", "FMT", "Fmt", "fm", " fkt", " fMT", "fMT", "fkt", "cfMT", "Fkt", "Fm", "cfm"], "buf": ["Buffer", "br", "func", "data", "bind", "ref", "pool", "buffer", "feed", "block", "stream", "method", "ba", "xff", "box", "buff", "map", "seq", "off", "pad", "cap", "alloc", "cast", "bag", "uf"]}}
{"project": "qemu", "commit_id": "f06ee3d4aa547df8d7d2317b2b6db7a88c1f3744", "target": 1, "func": "static void qed_aio_read_data(void *opaque, int ret,\n\n                              uint64_t offset, size_t len)\n\n{\n\n    QEDAIOCB *acb = opaque;\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    BlockDriverState *bs = acb->common.bs;\n\n\n\n    /* Adjust offset into cluster */\n\n    offset += qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_read_data(s, acb, ret, offset, len);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Handle zero cluster and backing file reads */\n\n    if (ret == QED_CLUSTER_ZERO) {\n\n        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);\n\n        qed_aio_next_io(acb, 0);\n\n        return;\n\n    } else if (ret != QED_CLUSTER_FOUND) {\n\n        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,\n\n                              qed_aio_next_io, acb);\n\n        return;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,\n\n                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,\n\n                   qed_aio_next_io, acb);\n\n    return;\n\n\n\nerr:\n\n    qed_aio_complete(acb, ret);\n\n}\n", "idx": 707, "substitutes": {"opaque": ["opacity", " opque", "opaques", "ocacre", "ropxb", "ospaque", "ropacre", "opxb", "ospacre", "oconymous", "ocaque", "opacre", " opacity", "ropque", "ipxb", "ipaque", "ipque", "ospaques", "oponymous", "ipacity", "ropaques", "ropaque", "ropacity", "roponymous", " opxb", "osponymous", "opque", "ocaques"], "ret": ["rot", "match", "fun", "total", "att", "ext", "mt", "def", "hash", "Len", "success", "data", "url", "complete", "prot", "get", "alt", "bc", "id", "cur", "section", "ry", "rets", "num", "off", "rep", "nil", "code", "lt", "info", "ft", "nt", "rev", "reply", "feat", "Ret", "rc", "pub", "opt", "status", "result", "bot", "ut", "ptr", "length", "flag", "reset", "ref", "obj", "sec", "RET", "seq", "error", "sur", "al", "lit", "re", "addr", "val", "count", "rt", "reg", "det", "res", "mem"], "offset": ["rot", "base", "skip", "data", "url", "loc", "align", "position", "id", "timeout", "from", "fn", "end", "num", "off", "initial", "i", "pos", "output", "fp", "index", "pointer", "address", "shift", "et", "ptr", "size", "length", "set", "reset", "ref", "f", "origin", "obj", "range", "o", "prefix", "seq", "Offset", "error", "location", "af", "addr", "count", "part", "start"], "len": ["base", "fun", "name", "split", "elt", "conn", "Len", "data", "url", "loc", "n", "lif", "lf", "fl", "ln", "bin", "fn", "num", "enc", "pos", "lim", "file", "lt", "nt", "rev", "str", "lon", "l", "block", "fin", "length", "size", "ref", "el", "en", "seq", "bytes", "gen", "line", "val", "load", "count", "limit", "part", "all", "mem"], "acb": ["ocf", "aclb", "ancf", "achbb", "acf", "acba", "acl", "ancp", "ancbb", "ancj", "anck", "accb", "acp", "ucj", " acbe", "encbr", "ack", "ancbe", "ancsb", "macp", "accl", "aclv", "ancd", "anca", "accbd", " acba", "akib", " acr", "ACr", "aclbody", "accbf", "accr", "ancfb", "eck", " acbar", "ACba", "acfb", "ancbr", "acbf", "macb", " acl", "accbody", "acbr", "ecbo", "appk", "arcfb", "achbr", "ecb", "ecba", "ocsb", "ACv", "ocbb", "axbf", "ancl", "acll", "ocb", "arcb", " acbo", "ecv", "accbe", "macf", "ACp", "acsb", "aca", " acsb", "ucbr", "ocba", "ACsb", "appb", "accfb", " acfb", " acbr", "arczb", "achb", "ancb", "accf", "axbb", "ACd", "appd", " acv", "ancn", "macfb", "anczb", "aczb", " acbb", "akbar", "encb", "akb", " ack", "accn", "ucb", "axk", "acczb", "acv", " acib", "ecbd", "ACk", "acj", "ancbo", "ecsb", "ecbody", "acib", "ancbf", "accv", "accp", "acbe", "accbb", "acbb", " acf", "appbb", "acbo", "ucbb", "acbd", "axb", "ocl", "ACl", "encib", "eca", "acck", "ACb", "accsb", "acbody", " acp", "acbar", " acd", " aca", "acn", "arck", "accd", "ecbb", "accba", "acr", "ACf", "acd", " acn", "ACbd", "ancv", "ACbb", "akbr", "achj", "encbar", "ecf", "ecl"], "s": ["submit", "js", "opens", "src", "cs", "http", "ss", "ops", "rs", "sa", "spec", "a", "sb", "r", "is", "sl", "bis", "g", "ses", "ls", "storage", "ds", "sets", "ps", "gs", "ns", "h", "c", "p", "state", "services", "self", "e", "f", "bos", "sys", "sq", "south", "o", "iss", "stats", "b", "site", "os", "ks", "session", "socket", "states", "se", "si", "obs", "ssl"], "bs": ["cms", "base", "js", "cs", "ss", "bh", "ba", "rs", "ts", "sb", "bps", "lb", "bm", "BS", "eb", "bid", "bc", "ins", "ms", "ros", "pb", "cus", "fps", "bl", "bis", "ls", "ses", "bits", "cb", "ds", "bas", "ps", "gs", "ns", "css", "vs", "bi", "us", "bos", "gb", "bt", "bg", "bb", "iss", "fb", "b", "os", "ks", "bytes", "its", "bes", "fs", "board", "db", "obs"]}}
{"project": "FFmpeg", "commit_id": "f4aaf987a588fcf5978e636edf2193df35b3e83b", "target": 1, "func": "int ff_thread_video_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *frame, int *got_packet_ptr){\n\n    ThreadContext *c = avctx->internal->frame_thread_encoder;\n\n    Task task;\n\n    int ret;\n\n\n\n    av_assert1(!*got_packet_ptr);\n\n\n\n    if(frame){\n\n        if(!(avctx->flags & CODEC_FLAG_INPUT_PRESERVED)){\n\n            AVFrame *new = avcodec_alloc_frame();\n\n            if(!new)\n\n                return AVERROR(ENOMEM);\n\n            pthread_mutex_lock(&c->buffer_mutex);\n\n            ret = c->parent_avctx->get_buffer(c->parent_avctx, new);\n\n            pthread_mutex_unlock(&c->buffer_mutex);\n\n            if(ret<0)\n\n                return ret;\n\n            new->pts = frame->pts;\n\n            new->quality = frame->quality;\n\n            new->pict_type = frame->pict_type;\n\n            av_image_copy(new->data, new->linesize, (const uint8_t **)frame->data, frame->linesize,\n\n                          avctx->pix_fmt, avctx->width, avctx->height);\n\n            frame = new;\n\n        }\n\n\n\n        task.index = c->task_index;\n\n        task.indata = (void*)frame;\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        av_fifo_generic_write(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_cond_signal(&c->task_fifo_cond);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n\n\n        c->task_index = (c->task_index+1) % BUFFER_SIZE;\n\n\n\n        if(!c->finished_tasks[c->finished_task_index].outdata && (c->task_index - c->finished_task_index) % BUFFER_SIZE <= avctx->thread_count)\n\n            return 0;\n\n    }\n\n\n\n    if(c->task_index == c->finished_task_index)\n\n        return 0;\n\n\n\n    pthread_mutex_lock(&c->finished_task_mutex);\n\n    while (!c->finished_tasks[c->finished_task_index].outdata) {\n\n        pthread_cond_wait(&c->finished_task_cond, &c->finished_task_mutex);\n\n    }\n\n    task = c->finished_tasks[c->finished_task_index];\n\n    *pkt = *(AVPacket*)(task.outdata);\n\n    av_freep(&c->finished_tasks[c->finished_task_index].outdata);\n\n    c->finished_task_index = (c->finished_task_index+1) % BUFFER_SIZE;\n\n    pthread_mutex_unlock(&c->finished_task_mutex);\n\n\n\n    *got_packet_ptr = 1;\n\n\n\n    return task.return_code;\n\n}\n", "idx": 16135, "substitutes": {"avctx": ["AVconfig", "afconn", "Avcontext", "avecmd", "afkb", "AVcmp", "Avctx", "ajcontext", "avcmp", "afcb", "AVkb", "navcmd", "AVcontext", "akcb", "avectx", "averctl", "akloc", "averlib", "navctx", "aflib", "AVcci", "afcmp", "AVconn", "averctx", "afconfig", "afcontext", "ajctx", "avelib", "Avcb", "avecci", "avcmd", " avkb", "navconfig", "avectl", "aveconfig", "avkb", "avecmp", "afloc", "Avloc", "avcontext", "avcb", "akctx", "avconn", "aveconn", " avcontext", "avloc", "ajcci", "ajcmp", "afctx", "afcmd", "afctl", "avcci", "AVctx", "avecontext", "navcontext", " avconn", "avconfig", "avctl", "avlib", "akcontext", "avercontext"], "pkt": ["pct", "Pqt", "pqt", "pdu", "Pdu", "Pkt", " pdu", "opdu", " pct", " pqt", "opqt", "Pct", "opkt", "opct"], "frame": ["remote", "shape", "motion", "image", "event", "module", "model", "fp", "force", "rame", "obj", "base", "old", "bf", "flow", "frames", "line", "cb", "cycle", "window", "message", "draw", "call", "m", "part", "slice", "session", "parse", "fake", "fi", "data", "create", "function", "thread", "Frame", "fram", "config", "iframe", "fb", "style", "connection", "source", "game", "buffer", "update", "live", "scope", "element", "document", "view", "e", "info", "f", "none", "point", "cfg", "feature", "state", "fe", "block", "cf", "video", "node", "channel", "up", "object", "position", "zone", "p", "time", "parent", "definition", "setup", "next", "now", "file", "target", "coll", "figure", "callback"], "got_packet_ptr": ["got_packet_thread", "got_packet64handle", "got_packet__thread", "got_packet__addr", "got_packacket_pointer", "got_packet_addr", "got_packet__ptr", "got_packet__pointer", "got_packet_tr", "got_packet_handle", "got_packacket_handle", "got_packacket_thread", "got_packet64pointer", "got_packet64ptr", "got_packacket_ptr", "got_packet_pointer", "got_packet64tr", "got_packacket_addr", "got_packacket_tr"], "c": ["call", "m", "ch", "mc", "cm", "uc", "bc", "d", "t", "ca", "course", "rc", "cc", "l", "pc", "i", "container", "config", "C", "lc", "cs", "ctrl", "g", "ci", "h", "cn", "this", "cy", "con", "ct", "v", "conf", "conn", "cr", "w", "u", "oc", "p", "e", "s", "rec", "nc", "k", "b", "can", "co", "tc", "n", "f", "arc", "cat", "dc", "cu", "ac", "sc", "ce", "cf", "ic", "coll", "icc", "cp", "center", "vc", "cache", "exec", "ec", "r", "cur", "fc", "cl", "ctx"], "task": ["channel", "func", "device", "transfer", "proc", "remote", "piece", "tx", "course", "complete", "service", "t", "sync", "queue", "batch", "config", "worker", "object", "container", "nn", "child", "manager", "test", "image", "event", "project", "module", "game", "kk", "session", "error", "master", "job", "key", "patch", "slave", "table", "layer", "Task", "instance", "resource", "pack", "data", "tc", "ask", "result", "parent", "next", "block", "tf", "target", "process", "ack", "exec", "empty", "class", "work", "tag", "thread", "node", "message"], "ret": ["alt", "ft", "en", "rev", "part", "reply", "_", "art", "rc", "val", "code", "back", "rets", "gt", "fun", "sr", "ref", "det", "lit", "error", "br", "mt", "mem", "fin", "rb", "success", "data", "Ret", "bf", "result", " RET", "att", "url", " Ret", "file", "nt", "re", "out", "rt", "fail", "resp", "rot", "RET", "al", "res", "num", "reg", "flag", "run", "len", "bit", "replace"], "new": ["word", "remote", "child", "msg", "image", "other", "raw", "box", "old", "make", "ec", "copy", "message", "func", "m", "self", "d", "array", "or", "g", "missing", "to", "full", "unknown", "client", "w", "resource", "data", "create", "gen", " New", "r", "mac", "another", "el", "small", "and", "extra", "again", "current", "large", "unique", "null", "game", "update", "valid", "New", "package", "e", "found", "j", "f", "add", "inc", "block", "first", "more", "fresh", "node", "replace", "root", "existing", "l", "ew", "news", "name", "this", "user", "later", "v", "same", "NEW", "p", "n", "next", "now", "one", "content", "join"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,\n\n                        int *duration)\n\n{\n\n    int64_t out_pts = AV_NOPTS_VALUE;\n\n    int removed_samples = 0;\n\n\n\n#ifdef DEBUG\n\n    ff_af_queue_log_state(afq);\n\n#endif\n\n\n\n    /* get output pts from the next frame or generated pts */\n\n    if (afq->frame_queue) {\n\n        if (afq->frame_queue->pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->frame_queue->pts - afq->remaining_delay;\n\n    } else {\n\n        if (afq->next_pts != AV_NOPTS_VALUE)\n\n            out_pts = afq->next_pts - afq->remaining_delay;\n\n    }\n\n    if (pts) {\n\n        if (out_pts != AV_NOPTS_VALUE)\n\n            *pts = ff_samples_to_time_base(afq->avctx, out_pts);\n\n        else\n\n            *pts = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    /* if the delay is larger than the packet duration, we use up delay samples\n\n       for the output packet and leave all frames in the queue */\n\n    if (afq->remaining_delay >= nb_samples) {\n\n        removed_samples      += nb_samples;\n\n        afq->remaining_delay -= nb_samples;\n\n    }\n\n    /* remove frames from the queue until we have enough to cover the\n\n       requested number of samples or until the queue is empty */\n\n    while (removed_samples < nb_samples && afq->frame_queue) {\n\n        removed_samples += afq->frame_queue->duration;\n\n        delete_next_frame(afq);\n\n    }\n\n    afq->remaining_samples -= removed_samples;\n\n\n\n    /* if there are no frames left and we have room for more samples, use\n\n       any remaining delay samples */\n\n    if (removed_samples < nb_samples && afq->remaining_samples > 0) {\n\n        int add_samples = FFMIN(afq->remaining_samples,\n\n                                nb_samples - removed_samples);\n\n        removed_samples        += add_samples;\n\n        afq->remaining_samples -= add_samples;\n\n    }\n\n    if (removed_samples > nb_samples)\n\n        av_log(afq->avctx, AV_LOG_WARNING, \"frame_size is too large\\n\");\n\n    if (duration)\n\n        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);\n\n}\n", "idx": 22637, "substitutes": {"afq": ["offqs", "avqa", "aphsq", "affcl", "avqs", "afg", "auxk", "ajQ", " afquest", "ufque", "efqa", "abq", "affqa", "aup", "avz", "phz", "abqa", "affsq", "ajq", "afsq", "affque", "afiqt", "awcl", " afk", "efq", "affqi", "cfq", "rafq", "alfqu", "afiqs", "awsq", "awqi", "afcle", "afiq", "abz", "efcle", " afg", "avct", "faque", "alfq", "awk", "avq", "phq", "avQ", "affkg", "ajk", "cfk", "affz", "phqu", "ufkg", "affct", "cfg", "rafqa", "phqa", "alfk", "aphq", "aphk", "avk", "awqs", "affw", "afp", "alfQ", "offq", "alfg", "alfcl", "afqu", "affq", " afck", "ajqi", "cfqa", "afqs", "awqa", "afqa", "auqt", "awck", " afkg", "rafqs", "affg", "affp", "auqs", " afqa", "awquest", "afct", "afQ", "afqt", "auxcle", " afque", "afck", "avck", "afque", "awQ", "auquest", "alfquest", "awg", "faw", "efk", "afiqu", "ajquest", "rafw", " afQ", "offqa", "affQ", "avw", "awqu", "afkg", "ufck", "aww", "faqs", "auct", "aphquest", "avqt", "affqu", "ajg", "ajp", "avcl", "awq", "affck", "affk", "affquest", "aucl", "afcl", "ajqs", "alfck", "affqt", "auk", "afw", "abqu", "rafque", "faq", "afk", " afqs", "auxq", "affcle", "alfqa", "offque", "ufq", "auxqa", "afz", "afquest", " afsq", "auq", " afz", "faqa", "awz", "ajqt", "avqu", "ajsq", "awqt", "affqs", "afqi"], "nb_samples": ["nb_tsipes", "nb_nocks", "nb_vamples", "nb_sourses", "nb_tummies", "nb_inspects", "nb_sessions", "nb_svamps", "nb7timesamples", "nb25outsances", "nb7samples", "nb_eventsalls", "nb_sickets", "nb_nourses", "nb_tsickets", "nb_timesims", "nb_npects", "nb_svpects", "nb_sources", "nb_nources", "nb_insummies", "nb_insamps", "nb_psamps", "nb_seubs", "nb_syspects", "nb_nimens", "nb_spects", "nb_insippers", "nb_namps", "nb_timesamples", "nb_vipes", "nb_nipes", "nb_vickets", "nb_samps", "nb_tsamples", "nb7sipes", "nb_specalls", "nb_namples", "nb7socks", "nb_vourses", "nb_ssources", "nb_seipes", "nb_tippers", "nb_sipes", "nb_outsamples", "nb7timesocks", "nb_compipes", "nb7timesipes", "nb_svamples", "nb_nalls", "nb_timesocks", "nb_summies", "nb_ssances", "nb_eventsamples", "nb_insamples", "nb25samples", "nb_sippers", "nb_sysances", "nb_ssubs", "nb_insimens", "nb_outspects", "nb_eventsources", "nb_compims", "nb_scamps", "nb_scamples", "nb_tsourses", "nb_eventsessions", "nb_psances", "nb_psamples", "nb_ssipes", "nb7sims", "nb25outsamples", "nb25outsipes", "nb25outspects", "nb_timesipes", "nb_nickets", "nb_tipes", "nb_nims", "nb_subs", "nb_svimens", "nb_sances", "nb_compocks", "nb_tamples", "nb_sysamples", "nb_specamples", "nb_socks", "nb25sances", "nb_seamples", "nb_outsipes", "nb_ssamples", "nb_sims", "nb_tamps", "nb7timesims", "nb_specources", "nb_psources", "nb_solutions", "nb_nessions", "nb_scippers", "nb25sipes", "nb_salls", "nb_outsances", "nb_tolutions", "nb_ssolutions", "nb_ssamps", "nb_nances", "nb_compamples", "nb_seolutions", "nb_specessions", "nb_scummies", "nb_tubs", "nb25spects", "nb_simens", "nb_sysipes"], "pts": ["ptsk", "iptds", "prds", "ctns", "ctsk", "ptss", "lls", "cold", "ctn", "aptsum", "cts", "roundns", "xtd", "ptn", "txss", "prs", "txd", "empts", "emptd", "prsid", "roundd", "ptsets", "ipts", "iptsum", "ptns", "ptsum", "ptd", "txs", "xtss", "aptd", "rounds", "prd", "colsets", "lld", "emptsk", "ptds", "iptd", "iptsid", "iptn", "lln", "colsid", "iptns", "ctd", "cols", "xts", "prsk", "iptsets", "prsum", "roundn", "aptds", "apts", "ptsid", "iptss", "prsets"], "duration": ["span", "delay", "period", "phase", "timer", "until", "amount", "age", "time", "seconds", "d", "pause", "pad", "term", "series", "address", "fee", "rate", "sequence", "description", "Duration", "videos", "version", "unit", "depth", "timeout", "memory", "later", "audio", "lag", "document", "distance", "direction", "window", "date", "runtime", "length", "grade", "angle", "doc", "range", "stage", "volume", "frequency", "gap", "sleep", "repeat", "video", "type"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void connex_init(MachineState *machine)\n\n{\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t connex_rom = 0x01000000;\n\n    uint32_t connex_ram = 0x04000000;\n\n\n\n    cpu = pxa255_init(address_space_mem, connex_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"connext.rom\", connex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, connex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 36 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 36));\n\n}\n", "idx": 16792, "substitutes": {"machine": ["process", "m", "instance", "session", "image", "loader", "master", "node", "manager", "mem", "computer", "vm", "host", "linux", "config", "processor", "parent", "device", "slave", "VM", "cache", "boot", "Machine", "proc", "connection", "state", "mac"], "cpu": ["pc", "pty", "process", "instance", "core", "component", "conn", "net", "thread", "proxy", "ro", "loader", "cp", "node", "mem", "computer", "bench", "vm", "setup", "GPU", "hw", "linux", "disk", " CPU", "memory", "CPU", "gpu", "config", "processor", "device", "kernel", "cache", "cmp", "sys", "clock", "proc", "uca", "boot", "pu", "eni", "prem", "ilo", "chip"], "dinfo": ["rdstate", "Dopen", "einf", "pInfo", "dbInfo", "dsinfo", "fcheck", "fInfo", "dInfo", "dlinf", "dfo", " dopen", "dsindex", "popen", "Dinfo", "dopen", "dinf", "dscheck", "dsfo", "echeck", "dcheck", " dinf", "dsstate", "finf", "dindex", " dcheck", "dlinfo", "dslink", "pinfo", "dbinf", "dlink", "dstate", "finfo", "rdindex", "rdinf", " dlink", "einfo", " dfo", " dstate", " dInfo", "dllink", " dindex", "dsInfo", "eInfo", "dlfo", "dsinf", "dbinfo", "rdinfo", "DInfo", "dbcheck"], "be": ["enable", "scale", "eb", "ere", "obe", "ste", "ine", "hide", "fe", "ne", " Be", "pe", "beat", "trace", " probe", "ro", "de", "ble", "sb", "see", "ver", "ave", "ge", "ate", "te", "leave", "byte", "replace", "ee", "ae", "ze", "ome", "is", "range", "Be", "are", " BE", "ce", "le", "ignore", "bf", "stop", "use", "fore", "ride", "bis", "e", "abe", "bre", "none", "b", "ben", "ke", "ace", "bee", "BE", "bes", "se", "me", "ve", "ose", "by"], "address_space_mem": ["address_space__ram", "address_space2ram", "address_space2memory", "address_system_mem", "address_system_lim", "address_space2dem", "address_space__mem", "address_pace_dem", "address_space2mem", "address_space_lim", "address_pace_ram", "address_pace_mem", "address_space__memory", "address_space__dem", "address_space_space", "address_space_memory", "address_space_ram", "address_system_space", "address_pace_memory", "address_space_dem"]}}
{"project": "qemu", "commit_id": "e0891bd8bfd3349fc3fecde30e51900059f53f11", "target": 0, "func": "static inline int num_effective_busses(XilinxSPIPS *s)\n\n{\n\n    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&\n\n            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;\n\n}\n", "idx": 1290, "substitutes": {"s": ["server", "js", "service", "opens", "cs", "http", "ss", "ops", "rs", "qs", "ts", "a", "sb", "spec", "ips", "new", "r", "is", "sl", "i", "g", "m", "ses", "sync", "ds", "sets", "ps", "ns", "c", "p", "rates", "services", "e", "self", "f", "es", "secondary", "sys", "sq", "south", "o", "stats", "b", "events", "S", "t", "os", "fs", "sym", "ssl"]}}
{"project": "FFmpeg", "commit_id": "15d14ce47cb39b93a80a2c6b8396db81c16934e6", "target": 1, "func": "static int64_t get_bit_rate(AVCodecContext *ctx)\n\n{\n\n    int64_t bit_rate;\n\n    int bits_per_sample;\n\n\n\n    switch (ctx->codec_type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n    case AVMEDIA_TYPE_DATA:\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n    case AVMEDIA_TYPE_ATTACHMENT:\n\n        bit_rate = ctx->bit_rate;\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);\n\n        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;\n\n        break;\n\n    default:\n\n        bit_rate = 0;\n\n        break;\n\n    }\n\n    return bit_rate;\n\n}\n", "idx": 4761, "substitutes": {"ctx": ["cp", "cmp", "gc", "hw", "anc", "fw", "hub", "ci", "component", "config", "ctl", "cus", "rc", "cca", "sync", "concept", "loc", "cm", "support", "tx", "cl", "client", "conv", "cli", "cc", "cs", "sci", "crit", "ck", "sc", "mc", "cam", "conn", "cmd", "bc", "cb", "exec", "cu", "fp", "coll", "context", "kw", "qa", "ca", "css", "gb", "kb", "c", "ct", "cn", "cf", "lc", "fc", "cv", "vc", "src", "cpp", "cas", "cdn", "ctrl", "pkg", "xc", "tc"], "bit_rate": ["bituresize", "rot_scale", "bitfscale", "biturerate", " bit_rates", " bit_width", "bits_rates", "bit_rat", "bit__scale", "bit__rate", "bit_type", "bit_size", " bit_ration", "bits_width", "rot_size", "bits_type", " bit_scale", "bitfrates", "rot_loop", "bit___rates", "bitfdelay", " bit_size", "bit_loop", "bit_ration", " bit_address", "bit___rat", "bitfrate", "bit__type", "bitureaddress", "biturescale", "bit___rate", "bit_rating", "bit_address", "bit_width", "bit_delay", "bit_rates", "bit___ration", " bit_rat", " bit_rating", "bit__width", "bits_base", "bits_rate", "bits_delay", "rot_rate", "bits_scale", "bit_scale", "bit_base"], "bits_per_sample": ["bits_per_group", "bits_per_scale", "bits_in_scale", "bits_in_sample", "bits_per_slice", "bits_per_channel", "bits_per_size", "bits_per_space", "bits_in_channel", "bits_per_side"]}}
{"project": "qemu", "commit_id": "778358d0a8f74a76488daea3c1b6fb327d8135b4", "target": 1, "func": "static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,\n\n                                   RockerTlv **group_tlvs)\n\n{\n\n    OfDpaGroup *l2_group;\n\n    RockerTlv **tlvs;\n\n    int err;\n\n    int i;\n\n\n\n    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||\n\n        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {\n\n        return -ROCKER_EINVAL;\n\n    }\n\n\n\n    group->l2_flood.group_count =\n\n        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);\n\n\n\n    tlvs = g_malloc0((group->l2_flood.group_count + 1) *\n\n                     sizeof(RockerTlv *));\n\n    if (!tlvs) {\n\n        return -ROCKER_ENOMEM;\n\n    }\n\n\n\n    g_free(group->l2_flood.group_ids);\n\n    group->l2_flood.group_ids =\n\n        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));\n\n    if (!group->l2_flood.group_ids) {\n\n        err = -ROCKER_ENOMEM;\n\n        goto err_out;\n\n    }\n\n\n\n    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,\n\n                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        group->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]);\n\n    }\n\n\n\n    /* All of the L2 interface groups referenced by the L2 flood\n\n     * must have same VLAN\n\n     */\n\n\n\n    for (i = 0; i < group->l2_flood.group_count; i++) {\n\n        l2_group = of_dpa_group_find(of_dpa, group->l2_flood.group_ids[i]);\n\n        if (!l2_group) {\n\n            continue;\n\n        }\n\n        if ((ROCKER_GROUP_TYPE_GET(l2_group->id) ==\n\n             ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) &&\n\n            (ROCKER_GROUP_VLAN_GET(l2_group->id) !=\n\n             ROCKER_GROUP_VLAN_GET(group->id))) {\n\n            DPRINTF(\"l2 interface group 0x%08x VLAN doesn't match l2 \"\n\n                    \"flood group 0x%08x\\n\",\n\n                    group->l2_flood.group_ids[i], group->id);\n\n            err = -ROCKER_EINVAL;\n\n            goto err_out;\n\n        }\n\n    }\n\n\n\n    g_free(tlvs);\n\n    return ROCKER_OK;\n\n\n\nerr_out:\n\n    group->l2_flood.group_count = 0;\n\n    g_free(group->l2_flood.group_ids);\n\n    g_free(tlvs);\n\n\n\n    return err;\n\n}\n", "idx": 2846, "substitutes": {"of_dpa": ["of_Dpa", "of_mdao", "of_duppa", "of_dpe", "of__cppa", "of_dupi", "of__dpe", "of__dao", "of_dao", "of__cpe", "of_ducp", "of_cao", "of__dpa", "of_dupa", "of_nppa", "of_mdpe", "of_Dpi", "of_mdpa", "of_dpi", "of__dppa", "of_cpa", "of_madppa", "of_cppa", "of_madpa", "of_dcp", "of_madpi", "of_Dppa", "of_mdppa", "of__cao", "of_npa", "of_Dcp", "of_madcp", "of_cpe", "of_npe", "of__cpa", "of_nao", "of_dppa"], "group": ["match", "call", "server", "name", "row", "any", "q", "key", "gru", "class", "global", "out", "gh", "type", "co", "Group", "field", "pg", "GROUP", "parent", "pair", "gap", "batch", "package", "g", "member", "output", "gg", "component", "company", "coll", "project", "event", "sync", "multi", "back", "number", "database", "config", "result", "block", "gu", "order", "diff", "child", "app", "cache", "message", "game", "agg", "object", "join", "comment", "range", "single", "plugin", "cell", "module", "rule", "option", "gen", "full", "an", "list", "band", "input", "user", "committee"], "group_tlvs": ["group_llvd", "group_tlss", "group_tlevn", "group_llvn", "group_tlln", "group_dlvs", "group_Tlfe", "group_tlegd", "group_tlevs", "group_Tlve", "group_tlls", "group_Tlvs", "group_tlli", "group_llvs", "group_tlse", "group_Tlfn", "group_tcfen", "group_tgtd", "group_dlln", "group_tlegs", "group_tlsd", "group_Tlvn", "group_tlevi", "group_tlegS", "group_tlle", "group_tlve", "group_Tlfi", "group_tlvn", "group_tcfd", "group_tgts", "group_tgtn", "group_tlsi", "group_tlfn", "group_llvi", "group_tllS", "group_tcfs", "group_Tlvi", "group_Tlvd", "group_tlegn", "group_Tlfd", "group_tlvS", "group_dlls", "group_tlld", "group_llevd", "group_dlvd", "group_tlfe", "group_tlevd", "group_dlven", "group_dlld", "group_dllen", "group_llevn", "group_tlfs", "group_tlfen", "group_tcfn", "group_tlven", "group_llevi", "group_tllen", "group_Tlfs", "group_tlfd", "group_llevs", "group_tlfS", "group_tlfi", "group_dlvn", "group_tlvi", "group_tlvd"], "l2_group": ["l2__channel", "l2_type", "l2ibclient", "l4__channel", "l3_groups", "l2_Group", "l1_group", "l1_g", "l4__g", "l2_client", "l3_type", "l4__group", "l2__group", "l2__g", "l2_g", "l4_groups", "l4__groups", "l2_channel", "l3_group", "l2ibtype", "l1_Group", "l2ibgroup", "l2ibgroups", "l2_groups", "l4_channel", "l2__groups", "l3_client", "l4_group", "l4_g"], "tlvs": ["tlvt", "untLVs", " tlve", "wtvlf", " tlimd", "tlimd", "tLVs", " tlims", "tlld", "tvlids", "tlss", "tlsids", "tinyls", "tLVabs", "wtvlids", "tlegits", "tinylstat", "itlls", "tllt", "tlvits", "untlvabs", "wtlvt", "tlvf", "wtlvs", "tllits", "tlimp", "tservs", "wtvle", "tcols", "tlegabs", "tlvids", "wtvlt", "wtlvids", "tvalls", "tlegstat", "tvle", "untLVstat", "itllits", "tlsf", "tvals", "tinylabs", "itlvits", "tlims", "tvlf", "tlve", "wtvls", "itllp", "tllp", "wtvlls", "tlime", "tservf", "tLVe", "wtlve", "tlegp", "tlvls", "itlvs", " tlvp", "tllls", "itlvp", "tvlls", "tlls", "tLVp", "tvls", "tvalt", "tvlt", "tlvstat", "tvale", "wtlvf", "tlvabs", "wtlvls", " tlime", "tlvd", "tLVstat", " tlimp", "untlvs", "tLVd", "untLVabs", "tlegs", " tlvd", "tlvp", "tservids", "tcolp", "tcolits", "untlvstat", "tlle"], "err": ["dr", "ise", "rage", "gi", "gr", "Error", "rr", " error", "orig", "cur", "lr", "arr", "rb", "code", "er", "fr", "ir", "str", "bug", "progress", "errors", "result", "ind", "usr", "phi", "dev", " Err", "br", "ctr", "resp", "error", "var", "Er", "msg", "debug", "init", "cfg", "fi", "rh", "diff", "rc"], "i": ["my", "yi", "li", "sup", "gi", "key", "a", "l", "ni", "ii", "ji", "chi", "pi", "ui", "oi", "r", "mini", "d", "I", "n", "di", "id", "mi", "uli", "iu", "k", "j", "g", "y", "m", "ri", "eni", "inner", "info", "ti", "slice", "multi", "z", "ini", "index", "ai", "ie", "x", "ip", "c", "p", "ind", "bi", "h", "e", "hi", "f", "phi", "u", "v", "qi", "ix", "t", "b", "uri", "ci", "count", "io", "mu", "init", "fi", "si", "in", "xi"]}}
{"project": "qemu", "commit_id": "aa8f057e74ae08014736a690ff41f76c756f75f1", "target": 0, "func": "static void virtio_crypto_instance_init(Object *obj)\n\n{\n\n    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);\n\n\n\n    /*\n\n     * The default config_size is sizeof(struct virtio_crypto_config).\n\n     * Can be overriden with virtio_crypto_set_config_size.\n\n     */\n\n    vcrypto->config_size = sizeof(struct virtio_crypto_config);\n\n\n\n    object_property_add_link(obj, \"cryptodev\",\n\n                             TYPE_CRYPTODEV_BACKEND,\n\n                             (Object **)&vcrypto->conf.cryptodev,\n\n                             virtio_crypto_check_cryptodev_is_used,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);\n\n}\n", "idx": 7213, "substitutes": {"obj": ["o", "act", "objects", "emb", "parent", "Obj", "obb", "nt", "config", "po", "tmp", "op", "ob", "object", "b", "cat", "module", "orb", "so", "attr", "org", "j", "init", "conf", "kt", "inst", "bot", "instance", "Object", "n", "ctx", "jp", "cb", "coll", "boot", "prop", "node", "os", "class", "api", "src", "img", "bh", "conn", "pkg", "bj", "js"], "vcrypto": ["vccrypto", "vcprotode", "vcrimto", "vcryptor", "vcryptode", "vcryptionos", "VCryptto", "vccryptode", "VCcryptos", "vconto", "vcCryptos", "vccryptor", "vcritor", "vccryptoa", "vcryptionor", "vcritio", "VCcrypto", "vcprotto", "fcrito", "vccryptio", "fcryptio", "vcCryptoa", "vcrimos", "vcrito", "VCryptos", "fcryptor", "vcryptoa", "VCcrypta", "vcrimode", "fcritio", "vcCrypto", "vcryptio", "vcCrypta", "vcryptos", "vccryptos", "VCcryptode", "vcrimo", "vcontoa", "fcritor", "vcproto", "fcryptos", "fcritos", "vconta", "VCryptode", "vcrypta", "VCcryptoa", "VCrypta", "vcontos", "vcryptto", "vcryptiono", "vcprotos", "vccrypta", "vcryptionio", "fcrypto", "VCcryptto", "vccryptto", "VCrypto", "VCryptoa", "vcritos"]}}
{"project": "qemu", "commit_id": "a01d8cadadf4c0dad8fc5157ee56aea8ec323982", "target": 1, "func": "PCIBus *pci_prep_init(qemu_irq *pic)\n\n{\n\n    PREPPCIState *s;\n\n    PCIDevice *d;\n\n    int PPC_io_memory;\n\n\n\n    s = qemu_mallocz(sizeof(PREPPCIState));\n\n    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);\n\n\n\n    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);\n\n    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);\n\n\n\n    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);\n\n    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);\n\n    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);\n\n    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);\n\n    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);\n\n    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);\n\n\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,\n\n                                           PPC_PCIIO_write, s);\n\n    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);\n\n\n\n    /* PCI host bridge */\n\n    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\",\n\n                            sizeof(PCIDevice), 0, NULL, NULL);\n\n    d->config[0x00] = 0x57; // vendor_id : Motorola\n\n    d->config[0x01] = 0x10;\n\n    d->config[0x02] = 0x01; // device_id : Raven\n\n    d->config[0x03] = 0x48;\n\n    d->config[0x08] = 0x00; // revision\n\n    d->config[0x0A] = 0x00; // class_sub = pci host\n\n    d->config[0x0B] = 0x06; // class_base = PCI_bridge\n\n    d->config[0x0C] = 0x08; // cache_line_size\n\n    d->config[0x0D] = 0x10; // latency_timer\n\n    d->config[0x0E] = 0x00; // header_type\n\n    d->config[0x34] = 0x00; // capabilities_pointer\n\n\n\n    return s->bus;\n\n}\n", "idx": 10406, "substitutes": {"pic": ["oc", "cci", "xi", "pid", "i", "c", "config", "p", "cli", "fp", "ec", "pins", "bc", "ac", "cus", "lib", "ig", "ics", "ic", "jp", "pc", "Pic", "nic", "file", "soc", "lic", "lc", "pict", "jc", "anc", "pot", "mc", "fi", "vec", "pin", "sc", "fc"], "s": ["l", "session", "is", "m", "t", "z", "gs", "v", "state", "groups", "ns", "spec", "self", "settings", "ds", "n", "si", "sites", "your", "sf", "w", "b", "i", "c", "e", "request", "lines", "sq", "f", "j", "sym", "es", "r", "storage", "u", "ps", "su", "fs", "site", "ss", "sv", "g", "features", "sa", "ls", "status", "socket", "os", "cs", "o", "sync", "south", "sl", "new", "sb", "sys", "secondary", "a", "ssl", "ts", "service", "p", "server", "qs", "js", "rs", "S", "states", "services", "sd", "less", "null", "ses", "y"], "d": ["l", "ld", "diff", "session", "dim", "di", "dh", "ds", "n", "g", "did", "dom", "and", "dict", "da", "w", "m", "id", "dt", "dos", "b", "t", "k", "z", "i", "de", "c", "data", "config", "p", "ad", "ct", "e", "pd", "cd", "q", "dn", "f", "ded", "dl", "j", "db", "device", "dat", "o", "dr", "nd", "sync", "md", "dd", "dc", "sd", "D", "dm", "dy"], "PPC_io_memory": ["PPC_io_mem", "PPC_iogmem", "PPC_ioammemory", "PPC_iogaddress", "PPC_auto_buffer", "PPC_io_address", "PPC_IO_memory", "PPC_iogmemory", "PPC_io_buffer", "PPC_auto_device", "PPC_IO_address", "PPC_auto_memory", "PPC_ioambuffer", "PPC_auto_mem", "PPC_io_Memory", "PPC_ioammem", "PPC_IO_Memory", "PPC_iogMemory", "PPC_ioamdevice", "PPC_io_device", "PPC_IO_mem"]}}
{"project": "qemu", "commit_id": "fbeadf50f2f965741def823036b086bbc2999b1f", "target": 1, "func": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t\t unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp |= ~0UL >> (BITS_PER_LONG - offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (~tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if (~(tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp |= ~0UL << size;\n\n    if (tmp == ~0UL) {\t/* Are any bits zero? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ffz(tmp);\n\n}\n", "idx": 23888, "substitutes": {"addr": ["hp", "asm", "ref", "adr", "amp", "g", "oa", "ord", "amd", "align", "host", "pad", "nc", "r", "address", "ad", "ip", "ace", "prefix", "np", "buf", "dr", "rc", "nr", "inet", "ar", "ptr", "Address", "src", "slice", "alpha", "array", "pointer", "rb", "image", "x", "padding"], "size": ["confirmed", "i", "area", "esc", "es", "message", "extra", "ize", "pos", "order", "address", "data", "false", "last", "shift", "small", "negative", "n", "global", "since", "from", "name", "response", "end", "scale", "g", "term", "fee", "unit", "when", "code", "c", "complete", "capacity", "needed", "set", "see", "SIZE", "empty", "position", "sum", "e", "ui", "result", "sized", "bytes", "function", "white", "new", "score", "or", "number", "max", "answer", "num", "second", "si", "speed", "error", "length", "loc", "side", "page", "sec", "count", "shape", "start", "en", "send", "Size", "done", "cache", "storage", "change", "sync", "timeout", "source", "len", "large", "grade", "range", "value"], "offset": ["exclusive", "adjust", "after", "i", "limit", "start", "attribute", "end", "off", "ref", "next", "option", "result", "part", "origin", "extra", "oa", "disabled", "align", "no", "pos", "order", "optional", "address", "ace", "id", "prefix", "o", "initial", "operation", "shift", "count", "timeout", "number", "answer", "index", "second", "ptr", "set", "now", "location", "alias", "online", "error", "Offset", "length", "iterator", "slice", "loc", "len", "page", "range", "alpha", "array", "pointer", "aligned", "empty", "position", "attr", "padding", "type"], "p": ["i", "e", "ap", "jp", "lp", "g", "d", "P", "bp", "pc", "l", "fp", "f", "po", "t", "op", "r", "u", "m", "cp", "pre", "s", "tp", "pp", "ip", "point", "o", "np", "q", "py", "c", "wp", "a", "b", "x", "w", "n", "proc", "v", "pair", "sp", "pointer", "vp", "h", "api", "pi", "dp"], "tmp": ["sample", "config", "vt", "part", "extra", "copy", "temp", "pad", "bp", "emp", "buffer", "front", "cp", "address", "data", "tp", "shift", "crop", "slice", "test", "wx", "proc", "v", "pointer", "rb", "output", "attr", "sb", "binary", "txt", "jp", "bb", "tt", "fp", "pre", "treatment", "opt", "code", "buf", "c", "cb", "wp", "tf", "mp", "appy", "st", "opp", "prev", "wrapper", "result", "meta", "fb", "f", "cmp", "t", "zip", "tc", "gz", "cro", "b", "ptr", "sup", "loc", "page", "buff", "clip", "api", "start", "obj", "input", "po", "m", "storage", "cache", "pp", "np", "py", "kk", "source", "now", "stuff", "paper", "array", "sp"]}}
{"project": "FFmpeg", "commit_id": "2f4233614a7fbe176b81de0ef14bf38bad8e6693", "target": 0, "func": "static void add_codec(FFServerStream *stream, AVCodecContext *av,\n\n                      FFServerConfig *config)\n\n{\n\n    AVStream *st;\n\n    AVDictionary **opts, *recommended = NULL;\n\n    char *enc_config;\n\n\n\n    if(stream->nb_streams >= FF_ARRAY_ELEMS(stream->streams))\n\n        return;\n\n\n\n    opts = av->codec_type == AVMEDIA_TYPE_AUDIO ?\n\n           &config->audio_opts : &config->video_opts;\n\n    av_dict_copy(&recommended, *opts, 0);\n\n    av_opt_set_dict2(av->priv_data, opts, AV_OPT_SEARCH_CHILDREN);\n\n    av_opt_set_dict2(av, opts, AV_OPT_SEARCH_CHILDREN);\n\n    if (av_dict_count(*opts))\n\n        av_log(NULL, AV_LOG_WARNING,\n\n               \"Something is wrong, %d options are not set!\\n\", av_dict_count(*opts));\n\n\n\n    if (config->stream_use_defaults) {\n\n    //TODO: reident\n\n    /* compute default parameters */\n\n    switch(av->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        if (av->bit_rate == 0) {\n\n            av->bit_rate = 64000;\n\n            av_dict_set_int(&recommended, \"ab\", av->bit_rate, 0);\n\n        }\n\n        if (av->sample_rate == 0) {\n\n            av->sample_rate = 22050;\n\n            av_dict_set_int(&recommended, \"ar\", av->sample_rate, 0);\n\n        }\n\n        if (av->channels == 0) {\n\n            av->channels = 1;\n\n            av_dict_set_int(&recommended, \"ac\", av->channels, 0);\n\n        }\n\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        if (av->bit_rate == 0) {\n\n            av->bit_rate = 64000;\n\n            av_dict_set_int(&recommended, \"b\", av->bit_rate, 0);\n\n        }\n\n        if (av->time_base.num == 0){\n\n            av->time_base.den = 5;\n\n            av->time_base.num = 1;\n\n            av_dict_set(&recommended, \"time_base\", \"1/5\", 0);\n\n        }\n\n        if (av->width == 0 || av->height == 0) {\n\n            av->width = 160;\n\n            av->height = 128;\n\n            av_dict_set(&recommended, \"video_size\", \"160x128\", 0);\n\n        }\n\n        /* Bitrate tolerance is less for streaming */\n\n        if (av->bit_rate_tolerance == 0) {\n\n            av->bit_rate_tolerance = FFMAX(av->bit_rate / 4,\n\n                      (int64_t)av->bit_rate*av->time_base.num/av->time_base.den);\n\n            av_dict_set_int(&recommended, \"bt\", av->bit_rate_tolerance, 0);\n\n        }\n\n\n\n        if (!av->rc_eq) {\n\n            av->rc_eq = av_strdup(\"tex^qComp\");\n\n            av_dict_set(&recommended, \"rc_eq\", \"tex^qComp\", 0);\n\n        }\n\n        if (!av->rc_max_rate) {\n\n            av->rc_max_rate = av->bit_rate * 2;\n\n            av_dict_set_int(&recommended, \"maxrate\", av->rc_max_rate, 0);\n\n        }\n\n\n\n        if (av->rc_max_rate && !av->rc_buffer_size) {\n\n            av->rc_buffer_size = av->rc_max_rate;\n\n            av_dict_set_int(&recommended, \"bufsize\", av->rc_buffer_size, 0);\n\n        }\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    } else {\n\n        switch(av->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if (av->bit_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio bit rate is not set\\n\");\n\n            if (av->sample_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio sample rate is not set\\n\");\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (av->width == 0 || av->height == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"video size is not set\\n\");\n\n            break;\n\n        default:\n\n            av_assert0(0);\n\n        }\n\n    }\n\n\n\n    st = av_mallocz(sizeof(AVStream));\n\n    if (!st)\n\n        return;\n\n    av_dict_get_string(recommended, &enc_config, '=', ',');\n\n    av_dict_free(&recommended);\n\n    av_stream_set_recommended_encoder_configuration(st, enc_config);\n\n    st->codec = av;\n\n    stream->streams[stream->nb_streams++] = st;\n\n}\n", "idx": 15555, "substitutes": {"stream": ["channel", "oper", "path", "port", "record", "m", "uc", "input", "cv", "iver", "object", "iv", "audio", "image", "sw", "AV", "raw", "model", "Stream", "server", "v", "form", "client", "upload", "view", "wave", "media", "instance", "http", "data", "f", "parent", "spec", "url", "wav", "feed", "transform", "loop", "sv", "sl", "REAM", "coll", "ack", "video", "src", "archive", "ream"], "av": ["port", "ak", "capt", "art", "audio", "auc", "image", "aut", "avi", "aim", "raft", "media", "dev", "ver", "af", "att", "am", "attr", "sv", "aux", "com", "off", "array", "bb", "iv", "uf", "api", "ra", "air", "acc", "nav", "data", "ann", "cap", "ack", "um", "ev", "archive", "lv", "aver", "aj", "cv", "tr", "AV", "aa", "aph", "app", "raf", "aps", "ad", "ave", "http", "li", "bh", "ac", "man", "aud", "record", "uc", "ai", "a", "act", "auth", "user", "ap", "v", "var", "oc", "aw", "buf", "au", "ab", "wav", "ov", "aval", "sav"], "config": ["fig", "path", "context", "ch", "bc", "capt", "ca", "allow", "input", "Config", "rc", "ctrl", "lc", "manager", "settings", "image", "acc", "con", "ct", "nav", "app", "server", "conf", "conn", "client", "sec", "options", "img", "data", "ext", "driver", "cfg", "control", "spec", "c", "design", "cap", "text", "sc", "cf", "man", "cal", "exec", "aux", "cache", "db", "FIG", "reg", "support", "ctx"], "st": ["sta", "ru", "amp", "capt", "art", "ste", "std", "sth", "sw", "str", "ct", "ss", "ad", "stage", "se", "ST", "sb", "est", "inst", "St", "sn", "sc", "sl", "ast", "sa", "rest", "src", "ost"], "opts": ["optte", "ots", "operfs", " opt", " opfs", " optt", "OPt", " optfs", " optty", "OPments", "optts", " oprs", "opertx", " opets", "opals", "opertd", "opta", " optta", "opouts", " optrs", "optd", "optets", "optrs", " optter", "operta", " opments", " optouts", "opfs", "optments", "operter", "ops", "optr", "oprs", "otets", " optals", " opouts", "opert", "opttd", "opets", "opty", " optes", "optouts", " optd", "opter", " opals", " optths", " optr", "optt", "operals", " optx", " opths", " opte", "optx", "opttx", "operts", "opte", " opter", "opments", "OPta", " opttes", "optTS", "optes", "OPte", " ops", "OPfs", "opths", "otts", "opttes", "opTS", "otTS", " optts", "OPts", "OPths", " opTS", "OPty", "opttr", "opertr", " opty", "opt"], "recommended": ["suspened", "shortended", "depended", "recommened", "shortending", "shortension", "recommENDED", "recommend", "suspend", "pretended", "depened", "pretributed", "advertened", "navending", "shortened", "depending", "navended", "pretending", "suspended", "dependending", "extend", "advertended", "advertension", "pretened", "dependended", "depENDED", "navributed", "advertend", "extened", "dependened", "depend", "recommension", "advertENDED", "dependension", "navened", "recommributed", "suspending", "pretENDED", "pretension", "extributed", "extension", "advertending", "pretend", "depension", "suspension", "extended", "recommending", "extending"], "enc_config": ["sec7content", "encodercontext", "enc7config", "sec_content", "enc__content", "encoderconfig", "sec7config", "enc_length", "sec7context", "enc7content", "enc__length", "sec_context", "sec_config", "sec_length", "encoderlength", "encodercontent", "enc7length", "enc_context", "sec7length", "enc__config", "enc_content", "enc__context", "enc7context"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    g_assert(addr >= QPCI_PIO_LIMIT);\n\n    dev->bus->memread(dev->bus, addr, buf, len);\n\n}\n", "idx": 17449, "substitutes": {"dev": ["grad", "Dev", "dd", "mod", "gd", "info", "conf", "pub", "comment", "engine", "gu", "debug", "de", "rad", "app", "var", "di", "mem", "def", "enc", "d", "hw", "adv", "w", "ev", "ad", "img", "cam", "temp", "device", "driver", "test", "plug", "pad", "error", "dem", "priv", "DEV", "end", "valid", "die", "diff", "bus", "ver", "bug"], "data": ["Data", "offset", "reader", "base", "buffer", "window", "src", "index", "pos", "def", "arr", "d", "val", "empty", "read", "size", "zero", "img", "ad", "start", "parent", "device", "da", "shift", "address", "pad", "cache", "dat", "next", "a", "DATA", "addr", "bytes", "bus", "input"], "buf": ["db", "ff", "fp", "func", "base", "ref", "lim", "buffer", "vec", "window", "cb", "bc", "src", "loc", "orig", "ctx", "raw", "lb", "mem", "bound", "aux", "length", "queue", "config", "fd", "buff", "batch", "v", "rb", "seq", "cmd", "off", "b", "cap", "alloc", "bytes", "addr", "bag", "uf"], "len": ["bin", "offset", "ff", "lim", "base", "name", "f", "all", "nt", "n", "fun", "num", "str", "block", "z", "fin", "pos", "ind", "mem", "en", "enc", "lf", "ln", "l", "val", "fl", "size", "length", "fd", "cl", "seq", "off", "line", "lan", "cap", "fn", "la", "addr", "el", "Len"]}}
{"project": "qemu", "commit_id": "fa3aad24d94a6cf894db52d83f72a399324a17bb", "target": 0, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n\n\n    if (version_id > vmsd->version_id) {\n\n        return -EINVAL;\n\n    }\n\n    if (version_id < vmsd->minimum_version_id_old) {\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        return vmsd->load_state_old(f, opaque, version_id);\n\n    }\n\n    while(field->name) {\n\n        if (field->version_id <= version_id) {\n\n            void *base_addr = opaque + field->offset;\n\n            int ret, i, n_elems = 1;\n\n\n\n            if (field->flags & VMS_ARRAY) {\n\n                n_elems = field->num;\n\n            } else if (field->flags & VMS_VARRAY) {\n\n                n_elems = *(size_t *)(opaque+field->num_offset);\n\n            }\n\n            if (field->flags & VMS_POINTER) {\n\n                base_addr = *(void **)base_addr;\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *addr = base_addr + field->size * i;\n\n\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, addr, version_id);\n\n                } else {\n\n                    ret = field->info->get(f, addr, field->size);\n\n\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n            }\n\n        }\n\n        field++;\n\n    }\n\n    if (vmsd->run_after_load)\n\n        return vmsd->run_after_load(opaque);\n\n    return 0;\n\n}\n", "idx": 16147, "substitutes": {"f": ["func", "m", "ff", "self", "fd", "elf", "d", "fs", "l", "inf", "fb", "framework", "uf", "fm", "g", "h", "fx", "this", "fo", "fp", "fn", "v", "raf", "fr", "buff", "conf", "form", "o", "F", "p", "e", "info", "handler", "fed", "b", "af", "sf", "lf", "fe", "c", "df", "feed", "tf", "file", "xf", "cf", "fen", "rf", "fc", "fa"], "vmsd": ["envmsds", " vamsdm", "fmsdn", "fcsds", " vmsdm", "ventsd", "vmsdal", " vmsdd", " vmsde", "vmasd", "vnsdal", "svmsdc", " vMSds", "vamsdm", "vmmd", "vopsdy", "vpsdos", "vicsdt", "vmssd", "vmasdy", "vMSdy", "vamsd", "vmsde", "vmesp", "vmsdn", " vMSdy", "vmesds", "vmesdo", " vamsdd", "svatsdal", " vmpp", "ventsds", "vmsD", "envmsd", " vMSdt", "vamsdo", " vamsdt", "vvsbd", "vmesD", "svatsds", "vMSds", "vcsdy", "fpsz", "vmsdc", "vatsdc", "vopsbd", "fmsdy", "fmsds", "vssdc", " vmsdc", " vamscd", " vmesde", "envmssd", "varmsdo", "vomsd", "vcsdc", "vopsd", " vmsD", "vmpd", "vvsd", "vcsdal", "enventsds", "vicsd", " vmpds", "vMSdt", " vmesD", "vpsd", "vomsdt", "vpsz", "vMSde", "vopsdn", "fcsd", "vamsdd", "vmsdos", "fcsdn", "vamsdt", " vmsdo", "svatsd", "varmsdy", "enventssd", "vMSd", "vmpdc", " vMSd", "vmsdt", " vmesd", "vatsd", "svmsdal", "vcsdn", "vmsds", " vmsds", "vcsde", "vicsdm", "vmmds", "vmsdb", "vvsz", "vmsdd", "vssds", "varmscd", "vvsds", "vopsz", "vmmsd", " vmsdb", "vnsd", "envmsdos", "varmsdn", "vmpp", "vmscd", " vmscd", "vssdt", "vopsds", "vatsdal", "varmsds", "vmescd", "fpsd", "fpsds", "vpsds", "ventssd", "ventsdos", "vssdy", "fcsdy", "enventsdos", " vmsdy", "vnsds", "vcsds", "svmsds", "vatsds", "svatsdc", "vpssd", "vmsdm", "vcsd", "vmesd", "enventsd", "vmmdos", "vmesdb", "vicsdd", " vamsd", "vmesde", "vamsdb", " vmsdt", "vMSD", "vmpds", "vmsz", "vssp", "svmsd", "vamscd", "fmsd", " vmpdc", "vmasdt", "vnsdc", " vamsdo", "vmasds", "varmsdb", "vssd", " vmsp", "vcsD", "fmsbd", " vamsdb", "vmsbd", "fmsz", "fpsbd", "vpsbd", "vmsdo", "vmesdc", " vmpd", " vmesds", "vmsdy", "varmsd", "vmsp", "vomsdm", "vomsdd"], "opaque": ["ospacity", "copacity", "paque", "copica", "pula", "oppacity", "pac", "opsacity", "opsaques", "opsane", "oponymous", "oppula", "copane", "ipque", "opac", "operacity", "opane", "oppaque", "opaques", "ospacle", "opsaque", "operaque", "operacle", "copaques", "ipac", "ipacity", "operica", "opacity", "ipaque", "operque", " opac", "iopaque", "operonymous", "ospaque", "osponymous", "ioponymous", "iopacity", " opque", "copaque", "oppac", "opque", " opacity", "iopane", "iopaques", "iopacle", "opula", "operula", "opacle", "pacity", "operac", " opica", "copque", "opica"], "version_id": ["version_Id", "install_id", " version_count", "version_offset", "package_kind", "version_uid", "package_info", "versioningid", "install_ids", "version0name", " version_offset", "version_ids", "version_sid", "creation_ID", "versionxids", " version_sid", "instanceingvid", "version_ident", "creation_id", "ver_id", "version0id", "version_ide", "ver_name", "versionxid", "version11vid", "version_type", "version0ID", " version_size", "versioninglike", "version11like", "version_kind", "version0ids", "version0kind", "versioningis", "versioningsid", " version_name", "versionxoffset", "version_like", "version11is", " version_Id", "version_is", "version_ID", " version_ids", "version11id", "versionxsize", "instanceingid", "version_count", "instance_vid", "package_id", "version0info", "version_info", "install_uid", "version0ident", "instanceinglike", "creation_ident", "versioningId", "instanceingis", "versioningvid", "install_ide", "package_name", "creation_ids", "instance_like", "instance_is", "version_name", "version_vid", "ver_ids", "version_size", "instance_id", " version_i", "ver_type", "versioningi", "version_i"], "field": ["word", "child", "label", "event", "module", "method", "model", "force", "handler", "box", "list", "line", "end", "cell", "off", "window", "index", "message", "wire", "slice", "lc", "manager", "comment", "key", "error", "fix", "group", "Field", "data", "entry", "number", "function", "um", "flag", "condition", "after", "service", "ield", "and", "style", "section", "option", "ref", "machine", "member", "package", "value", "element", "term", "layer", "document", "lf", "feature", "holder", "diff", "block", "type", "loop", "load", "man", "FIELD", "post", "record", "player", "object", "back", "name", "row", "er", "form", "open", "plugin", "match", "attribute", "file", "rule"], "base_addr": [" base_pos", "base_pos", " base_url", "base_url", "base_point", " base_address", " base_offset", " base_name", "base_ptr", " base_coord", " base_ptr", "base_address", "base_offset", "base_name", "base_coord", " base_point"], "ret": [" fun", "alt", "pet", "en", "ft", "rev", "reply", "rc", "val", "back", "def", "rets", "fun", " def", "str", "ref", "arg", "det", "lit", "error", " reply", "job", "value", " arg", "feat", "obj", "mem", "fi", "info", "match", "success", "data", "Ret", "count", "bf", "result", " RET", "att", "url", "red", "cat", "end", " result", "nt", " success", "re", "rt", "get", "r", "rep", "et", "pat", "RET", "res", "reg", "num", "flag", "len", "bit", "err"], "i": ["hi", "qi", "it", "ui", "I", "ni", "ai", "xi", "id", "ini", "inf", "gi", "iu", "l", "ci", "ig", "di", "x", "arg", "si", "ie", "ii", "key", "v", "uri", "u", "ind", "z", "p", "e", "ib", "info", "fi", "mi", "li", "k", "ix", "b", "multi", "j", "phi", "ti", "ip", "c", "eni", "pi", "r", "ri", "ami", "zi", "abi", "index", "start"], "addr": ["ord", "area", "osi", "pkg", "part", "slice", "amp", "amd", "rc", "id", "align", "x", "ref", "ace", "loc", " address", "uri", "ad", "adr", "layer", "p", "la", "rx", "pointer", "ix", "result", "address", "ip", "url", "route", "arr", "afi", "offset", "r", "host", "ar", "work", "dr", "hop", "prefix", "coord", "pad", "alias", "pos", "ptr", "index"]}}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, long width)\n\n{\n\n#ifdef HAVE_MMX\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" (-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= src1[4*i + 1];\n\n\t\tdstV[i]= src1[4*i + 3];\n\n\t}\n\n#endif\n\n        assert(src1 == src2);\n\n}\n", "idx": 6432, "substitutes": {"dstU": ["dsrcM", "fstU", "dspU", "dspV", "destU", "dspUV", "dSTM", "dstO", "DestO", "DestCU", "DestU", "fstV", "dstUR", "DestM", "dsrcV", "dspM", "DestA", "ddestCU", "fspM", "dstdU", "DstO", "destA", "dstCU", "ddestUR", "dSTUV", "dstA", "DstA", "destCU", "fspV", "fspU", "dstM", "fstUV", "dsrcUV", "destO", "destM", "dSTU", "dstUV", "dSTV", "DstUR", "dstdA", "DstM", "dsrcU", "ddestM", "fspUV", "DstU", "dstdUR", "ddestU", "DstCU", "ddestO", "dSTO", "fstM", "ddestA", "dstdCU", "DestUR", "destUR", "dSTUR"], "dstV": ["dconstVB", "destU", "dSTv", "DestU", "DstVI", "dsrcV", "dconstv", "destVI", "dstsL", "DstI", "dblV", "dsrcVI", "dconstU", "dstsVB", "dconstI", "Dsrcv", "dstVB", "DstV", "dconstL", "dblL", "dSTI", "DestV", "dblVB", "dsrcv", "dstL", "destV", "dstv", "dstVI", "dstI", "dblUV", "dSTVI", "dconstUV", "dSTU", "dsrcI", "dstsUV", "DsrcVI", "dSTV", "dstUV", "dstsV", "DstU", "Destv", "destI", "dconstV", "DsrcV", "DestI", "destv", "Dstv", "DsrcI"], "src1": ["url2", "src3", " srcA", " srcN", "gb3", "sourceOne", "rcU", "rc3", " src0", "url1", "rc0", "loc1", "gbU", "source1", "rc1", " srcOne", "src01", " srcU", "rcN", "srcA", "rc01", "sourceA", "source3", "url0", "loc0", "rcA", "srcU", "srcN", "source2", "url01", "rc2", " src01", "rcOne", "gb1", "gb2", "locOne", "sourceN", " src3", "src0", "srcOne", "source0", "loc2"], "src2": ["src3", "rc3", " src0", "rc0", "rib2", "source1", "rc1", "ribV", " srcV", "source3", "rcV", "srcV", "rib0", "source2", "rc2", "rib1", " src3", "src0", "source0"], "i": ["gi", "o", "ti", "v", "id", "I", "count", "di", "ci", "ji", "xi", "x", "si", "slice", "b", "abi", "ri", "info", "bi", "m", "io", "qi", "l", "key", "pi", "phi", "adi", "j", "length", "ii", "d", "it", "ai", "u", "vi", "e", "uri", "n", "multi", "ini", "p", "temp", "z", "eni", "start", "line", "oi", "hi", "var", "ip", "c", "page", "lc", "li", "fi", "index", "zi", "diff", "mu", "ui"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int i2c_start_transfer(i2c_bus *bus, int address, int recv)\n\n{\n\n    DeviceState *qdev;\n\n    i2c_slave *slave = NULL;\n\n\n\n    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {\n\n        slave = I2C_SLAVE_FROM_QDEV(qdev);\n\n        if (slave->address == address)\n\n            break;\n\n    }\n\n\n\n    if (!slave)\n\n        return 1;\n\n\n\n    /* If the bus is already busy, assume this is a repeated\n\n       start condition.  */\n\n    bus->current_dev = slave;\n\n    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);\n\n    return 0;\n\n}\n", "idx": 26792, "substitutes": {"bus": ["driver", "this", "info", "engine", "mount", "usb", "data", "test", "config", "interface", "us", "bc", "port", "io", "serial", "plugin", "proc", "self", "boot", "feed", "bridge", "http", "controller", "Bus", "dev", "drive", "board", "cache", "device", "proxy", "loop", "service", "f", "plug", "block", "connection", "lock", "BUS"], "address": ["node", "location", "code", "account", "Address", "i", "master", "server", "name", "attribute", "request", "pointer", "interface", "capacity", "type", "reference", "state", "end", "port", "alias", "message", "resource", "uri", "object", "enter", "offset", "mode", "target", "order", "size", "number", "shape", "channel", "device", "addr", "length", "transfer", "source", "network", "ip", "index", "pair", "host", "content", "event", "route", "connection", "localhost", "layer"], "recv": ["ref", "reV", "RECf", "renv", "RECV", " reccv", "recb", "respv", " recb", " recf", "recV", "respcv", " recV", "reccv", "rev", "respceive", "renb", "rencv", "RECq", "req", "renceive", " recceive", " recq", "recceive", "recf", "RECv", "recq", "respb"], "qdev": ["quickdes", "sqdes", "qtsd", "Qde", "QDev", "Qdev", "qtdes", "qudes", "sqcase", "sqde", "qucase", "Qdef", "Qsd", "qusd", "quickdev", "sqdevice", "pdevice", "qudev", "qude", "qdef", "qde", "quickde", "quickcase", "quDev", "qcase", "pde", "sqdev", "pdef", "Qdes", "Qdevice", "qDev", "qtDev", "pdev", "qdes", "qtdev", "qsd", "sqdef", "qdevice"], "slave": ["fork", "server", "bean", "sync", "seed", "bridge", "controller", "object", "dev", "serv", "wife", "entry", "slice", "driver", "shared", "engine", "attribute", "port", "hole", "link", "ssh", "seat", "lane", "stable", "root", "sl", "machine", "table", "sh", "ve", "node", "ship", "boat", "plugin", "player", "command", "session", "uri", "mode", "ser", "parent", "copy", "future", "sb", "length", "proxy", "sett", "source", "host", "connection", "seller", "lease", "shift", "master", "interface", "type", "instance", "id", "unit", "vid", "role", "si", "worker", "owner", "channel", "missing", "device", "loop", "child", "route", "adder", "ace", "result", " slaves"]}}
{"project": "qemu", "commit_id": "bb44619b06c0bef20b658ff532cf850c16362ae7", "target": 1, "func": "DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)\n\n{\n\n    const char *buf;\n\n    const char *file = NULL;\n\n    const char *serial;\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriver *drv = NULL;\n\n    int max_devs;\n\n    int index;\n\n    int ro = 0;\n\n    int bdrv_flags = 0;\n\n    int on_read_error, on_write_error;\n\n    const char *devaddr;\n\n    DriveInfo *dinfo;\n\n    BlockIOLimit io_limits;\n\n    int snapshot = 0;\n\n    bool copy_on_read;\n\n    int ret;\n\n    Error *error = NULL;\n\n\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n    bus_id  = qemu_opt_get_number(opts, \"bus\", 0);\n\n    unit_id = qemu_opt_get_number(opts, \"unit\", -1);\n\n    index   = qemu_opt_get_number(opts, \"index\", -1);\n\n\n\n    cyls  = qemu_opt_get_number(opts, \"cyls\", 0);\n\n    heads = qemu_opt_get_number(opts, \"heads\", 0);\n\n    secs  = qemu_opt_get_number(opts, \"secs\", 0);\n\n\n\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    ro = qemu_opt_get_bool(opts, \"readonly\", 0);\n\n    copy_on_read = qemu_opt_get_bool(opts, \"copy-on-read\", false);\n\n\n\n    file = qemu_opt_get(opts, \"file\");\n\n    serial = qemu_opt_get(opts, \"serial\");\n\n\n\n    if ((buf = qemu_opt_get(opts, \"if\")) != NULL) {\n\n        for (type = 0; type < IF_COUNT && strcmp(buf, if_name[type]); type++)\n\n            ;\n\n        if (type == IF_COUNT) {\n\n            error_report(\"unsupported bus type '%s'\", buf);\n\n            return NULL;\n\n\t}\n\n    } else {\n\n        type = block_default_type;\n\n    }\n\n\n\n    max_devs = if_max_devs[type];\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1) {\n\n            error_report(\"invalid physical cyls number\");\n\n\t    return NULL;\n\n\t}\n\n        if (heads < 1) {\n\n            error_report(\"invalid physical heads number\");\n\n\t    return NULL;\n\n\t}\n\n        if (secs < 1) {\n\n            error_report(\"invalid physical secs number\");\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"trans\")) != NULL) {\n\n        if (!cyls) {\n\n            error_report(\"'%s' trans must be used with cyls, heads and secs\",\n\n                         buf);\n\n            return NULL;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            error_report(\"'%s' invalid translation type\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"media\")) != NULL) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                error_report(\"CHS can't be set with media=%s\", buf);\n\n\t        return NULL;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    error_report(\"'%s' invalid media\", buf);\n\n\t    return NULL;\n\n\t}\n\n    }\n\n\n\n    if ((buf = qemu_opt_get(opts, \"discard\")) != NULL) {\n\n        if (bdrv_parse_discard_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid discard option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= BDRV_O_CACHE_WB;\n\n    if ((buf = qemu_opt_get(opts, \"cache\")) != NULL) {\n\n        if (bdrv_parse_cache_flags(buf, &bdrv_flags) != 0) {\n\n            error_report(\"invalid cache option\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n#ifdef CONFIG_LINUX_AIO\n\n    if ((buf = qemu_opt_get(opts, \"aio\")) != NULL) {\n\n        if (!strcmp(buf, \"native\")) {\n\n            bdrv_flags |= BDRV_O_NATIVE_AIO;\n\n        } else if (!strcmp(buf, \"threads\")) {\n\n            /* this is the default */\n\n        } else {\n\n           error_report(\"invalid aio option\");\n\n           return NULL;\n\n        }\n\n    }\n\n#endif\n\n\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n\n        if (is_help_option(buf)) {\n\n            error_printf(\"Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            error_printf(\"\\n\");\n\n            return NULL;\n\n        }\n\n        drv = bdrv_find_whitelisted_format(buf);\n\n        if (!drv) {\n\n            error_report(\"'%s' invalid format\", buf);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* disk I/O throttling */\n\n    io_limits.bps[BLOCK_IO_LIMIT_TOTAL]  =\n\n                           qemu_opt_get_number(opts, \"bps\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_READ]   =\n\n                           qemu_opt_get_number(opts, \"bps_rd\", 0);\n\n    io_limits.bps[BLOCK_IO_LIMIT_WRITE]  =\n\n                           qemu_opt_get_number(opts, \"bps_wr\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_TOTAL] =\n\n                           qemu_opt_get_number(opts, \"iops\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_READ]  =\n\n                           qemu_opt_get_number(opts, \"iops_rd\", 0);\n\n    io_limits.iops[BLOCK_IO_LIMIT_WRITE] =\n\n                           qemu_opt_get_number(opts, \"iops_wr\", 0);\n\n\n\n    if (!do_check_io_limits(&io_limits, &error)) {\n\n        error_report(\"%s\", error_get_pretty(error));\n\n        error_free(error);\n\n        return NULL;\n\n    }\n\n\n\n    if (qemu_opt_get(opts, \"boot\") != NULL) {\n\n        fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \"\n\n                \"ignored. Future versions will reject this parameter. Please \"\n\n                \"update your scripts.\\n\");\n\n    }\n\n\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO && type != IF_NONE) {\n\n            error_report(\"werror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_write_error = parse_block_error_action(buf, 0);\n\n        if (on_write_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI && type != IF_NONE) {\n\n            error_report(\"rerror is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n\n\n        on_read_error = parse_block_error_action(buf, 1);\n\n        if (on_read_error < 0) {\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if ((devaddr = qemu_opt_get(opts, \"addr\")) != NULL) {\n\n        if (type != IF_VIRTIO) {\n\n            error_report(\"addr is not supported by this bus type\");\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            error_report(\"index cannot be used with bus and unit\");\n\n            return NULL;\n\n        }\n\n        bus_id = drive_index_to_bus_id(type, index);\n\n        unit_id = drive_index_to_unit_id(type, index);\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        error_report(\"unit %d too big (max is %d)\",\n\n                     unit_id, max_devs - 1);\n\n        return NULL;\n\n    }\n\n\n\n    /*\n\n     * catch multiple definitions\n\n     */\n\n\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n\n        error_report(\"drive with bus=%d, unit=%d (index=%d) exists\",\n\n                     bus_id, unit_id, index);\n\n        return NULL;\n\n    }\n\n\n\n    /* init */\n\n\n\n    dinfo = g_malloc0(sizeof(*dinfo));\n\n    if ((buf = qemu_opts_id(opts)) != NULL) {\n\n        dinfo->id = g_strdup(buf);\n\n    } else {\n\n        /* no id supplied -> create one */\n\n        dinfo->id = g_malloc0(32);\n\n        if (type == IF_IDE || type == IF_SCSI)\n\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n        if (max_devs)\n\n            snprintf(dinfo->id, 32, \"%s%i%s%i\",\n\n                     if_name[type], bus_id, mediastr, unit_id);\n\n        else\n\n            snprintf(dinfo->id, 32, \"%s%s%i\",\n\n                     if_name[type], mediastr, unit_id);\n\n    }\n\n    dinfo->bdrv = bdrv_new(dinfo->id);\n\n    dinfo->bdrv->open_flags = snapshot ? BDRV_O_SNAPSHOT : 0;\n\n    dinfo->bdrv->read_only = ro;\n\n    dinfo->devaddr = devaddr;\n\n    dinfo->type = type;\n\n    dinfo->bus = bus_id;\n\n    dinfo->unit = unit_id;\n\n    dinfo->cyls = cyls;\n\n    dinfo->heads = heads;\n\n    dinfo->secs = secs;\n\n    dinfo->trans = translation;\n\n    dinfo->opts = opts;\n\n    dinfo->refcount = 1;\n\n    dinfo->serial = serial;\n\n    QTAILQ_INSERT_TAIL(&drives, dinfo, next);\n\n\n\n    bdrv_set_on_error(dinfo->bdrv, on_read_error, on_write_error);\n\n\n\n    /* disk I/O throttling */\n\n    bdrv_set_io_limits(dinfo->bdrv, &io_limits);\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n    case IF_NONE:\n\n        dinfo->media_cd = media == MEDIA_CDROM;\n\n        break;\n\n    case IF_SD:\n\n    case IF_FLOPPY:\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n        break;\n\n    case IF_VIRTIO:\n\n        /* add virtio block device */\n\n        opts = qemu_opts_create_nofail(qemu_find_opts(\"device\"));\n\n        if (arch_type == QEMU_ARCH_S390X) {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-s390\");\n\n        } else {\n\n            qemu_opt_set(opts, \"driver\", \"virtio-blk-pci\");\n\n        }\n\n        qemu_opt_set(opts, \"drive\", dinfo->id);\n\n        if (devaddr)\n\n            qemu_opt_set(opts, \"addr\", devaddr);\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    if (!file || !*file) {\n\n        return dinfo;\n\n    }\n\n    if (snapshot) {\n\n        /* always use cache=unsafe with snapshot */\n\n        bdrv_flags &= ~BDRV_O_CACHE_MASK;\n\n        bdrv_flags |= (BDRV_O_SNAPSHOT|BDRV_O_CACHE_WB|BDRV_O_NO_FLUSH);\n\n    }\n\n\n\n    if (copy_on_read) {\n\n        bdrv_flags |= BDRV_O_COPY_ON_READ;\n\n    }\n\n\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n\n        bdrv_flags |= BDRV_O_INCOMING;\n\n    }\n\n\n\n    if (media == MEDIA_CDROM) {\n\n        /* CDROM is fine for any interface, don't check.  */\n\n        ro = 1;\n\n    } else if (ro == 1) {\n\n        if (type != IF_SCSI && type != IF_VIRTIO && type != IF_FLOPPY &&\n\n            type != IF_NONE && type != IF_PFLASH) {\n\n            error_report(\"readonly not supported by this bus type\");\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    bdrv_flags |= ro ? 0 : BDRV_O_RDWR;\n\n\n\n    if (ro && copy_on_read) {\n\n        error_report(\"warning: disabling copy_on_read on readonly drive\");\n\n    }\n\n\n\n    ret = bdrv_open(dinfo->bdrv, file, NULL, bdrv_flags, drv);\n\n    if (ret < 0) {\n\n        if (ret == -EMEDIUMTYPE) {\n\n            error_report(\"could not open disk image %s: not in %s format\",\n\n                         file, drv->format_name);\n\n        } else {\n\n            error_report(\"could not open disk image %s: %s\",\n\n                         file, strerror(-ret));\n\n        }\n\n        goto err;\n\n    }\n\n\n\n    if (bdrv_key_required(dinfo->bdrv))\n\n        autostart = 0;\n\n    return dinfo;\n\n\n\nerr:\n\n    bdrv_delete(dinfo->bdrv);\n\n    g_free(dinfo->id);\n\n    QTAILQ_REMOVE(&drives, dinfo, next);\n\n    g_free(dinfo);\n\n    return NULL;\n\n}\n", "idx": 22801, "substitutes": {"opts": [" opted", " optt", " oppt", "Opters", "OPts", "optns", "ott", "omted", "Oputs", "otments", "OPTs", " opats", "omments", "opta", "hopts", "oprs", "OPrs", "otters", "experts", "optt", "expert", "optats", " opsts", "experns", "OPments", "OPuts", "hopta", "OPta", "opcs", "optters", "copters", "hoputs", "omts", "opersts", "opt", " optns", "opps", "oppt", "copcs", "OPt", "optcs", "opats", "OPns", "OPpt", "opns", "OPted", "OPsts", "copts", "optted", "opters", "operrs", "Opts", "otuts", " optters", "Opted", " opt", " oprs", "OPters", "OPats", "otsts", "opert", "otcs", "hopted", " opps", "optuts", "otTs", "copats", "coprs", "optta", "optts", "optps", "opments", "opted", "copt", "operts", "oputs", "optpt", "OPps", "optrs", "operments", "optments", "optTs", "Opta", "experted", "omt", " optts", "opTs", "otts", "opercs", "optsts", " opments", "opsts"], "block_default_type": ["block_default_class", "block_default_t", "block_block_type", "block_block_t", "block_default_types", "block_block_types", "block_block_class"], "buf": ["conv", "bc", "uf", "binary", "uc", "ref", "config", "text", "input", "pkg", "cv", "fb", "queue", "func", "img", "fp", "cas", "buffer", "path", "alloc", "cmd", "box", "data", "runner", "label", "rc", "filename", "cb", "pool", "ctx", "aux", "b", "tmp", "seq", "ff", "desc", "src", "fd", "br", "callback", "Buffer", "buff", "proc", "bag", "vec", "bus", "rb", "block", "output"], "file": ["place", "port", "ile", "name", "class", "ul", "il", "input", "time", "connection", "uri", "fp", "f", "model", "path", "dir", "socket", "data", "cache", "zip", "unit", "filename", "pool", "la", "mail", "source", "book", "File", "show", "http", "resource", "files", "image", "base", "where", "url", "letter"], "serial": ["io", "rol", "package", "sel", "tel", "usb", "ser", "mount", "xxx", "mode", "phone", "device", "local", "model", "mobile", "custom", "series", "roll", "socket", "dev", "zip", "version", "tag", "random", "spec", "pass", "alias", "unknown", "iso", "select", "proc", "http", "template", "volume", "resource", "Serial"], "mediastr": ["mediastril", "mediendrs", "mediastrl", "datestr", "mediestr", "mediostrl", "mediestrs", "mediendril", "datastril", "datastrs", "mediendrl", "datestrl", "datestril", "datastrl", "mediostrs", "mediostr", "mediendr", "mediastrs", "mediostril", "mediestrl", "datastr", "datestrs", "mediestril"], "type": ["span", "col", "like", "i", "Type", "name", "types", "class", "shape", "object", "level", "config", "ping", "pe", "part", "message", "time", "key", "TYPE", "style", "ty", "weight", "no", "model", "split", "t", "other", "info", "y", "pre", "size", "data", "state", "lock", "p", "diff", "number", "id", "code", "count", "unit", "var", "comment", "py", "day", "tag", "create", "month", "value", "ype", "length", "call", "unknown", "test", "total", "options", "parent", "typ", "block", "all", "sort", "position", "x"], "media": ["io", "package", "port", "medi", "message", "mode", "meta", "metadata", "uri", "control", "device", "model", "m", "medium", "data", "storage", "memory", "module", "audio", "spec", "source", "document", "material", "Media", "library", "reader", "http", "template", "manager", "volume", "resource", "image", "record", "format", "import"], "bus_id": ["unitpid", "unit_version", "bus_version", "unitpsid", "buspsid", "unitpbid", "unit_sid", "unitpversion", "bus_ids", "buspbid", "bus_bid", " bus_type", "bus_name", "buspid", " bus_name", "bus_sid", "bus_type", " bus_ids", "unit_bid", "buspversion"], "unit_id": ["device_version", "unit_ids", "unit_name", "device_name", "unitacversion", "unit_type", "device_id", " unit_type", "device_type", "unitacname", "unitactype", " unit_ids", "unitacid", " unit_name", "unit_version"], "cyls": ["ryps", " cyrs", " crols", " cyles", "cyrs", "rylf", "cyols", " crls", "zylf", "corrs", "cyps", "zyls", "cylf", "corles", "rycs", "zycs", " crrs", " cyps", "corls", " cycs", "ryls", "zyps", "cycs", "cyles", "corols", " cylf", " cyols", " crles"], "heads": ["obs", "outs", "docs", "workers", "headers", "tests", "maps", "rows", "hook", "HEAD", "locks", "plugins", "tails", "shots", "flags", "offs", "members", "head", "shows", "cases", "tops", "modules", "loads", "sections", "opens", "jobs", "frames", "reads", "blocks", "views", "sticks", "checks", "links", "mods", "files", "times", "pages"], "secs": [" secp", "seqseconds", "seqs", "supps", " secseconds", "ribn", "suppp", "suppn", "seqls", "seco", "seqo", "ribo", "suppseconds", "secls", "ribls", " secn", "seqp", " seco", "ribs", "secseconds", "seqn", "secp", " secls", "secn"], "translation": ["port", "name", "flash", "language", "acl", "message", "rating", "protection", "Translation", "bl", "local", "flags", "pos", "proxy", "info", "mo", "description", "version", "abi", "misc", "trans", "comment", "rot", "settings", "la", "title", "alias", "loc", "utils", "options", "http", "template", "conf", "lang", "image", "resource", "lit", "offset", "base"], "drv": ["srv", " drc", "Drf", " drf", "drw", " drw", "srf", "drc", "Drv", "Drc", "srw", "Drw", "drf", "src"], "max_devs": ["max_evi", "max_devid", "max_evp", "max_devp", "max_devicei", "max_deviceid", "max_devicep", "max_defi", "max_evs", "max_devi", "max_devices", "max_defs", "max_defp", "max_defid", "max_evid"], "index": ["name", "shape", "target", "limit", "level", "config", "ind", "input", "inc", "key", "connection", "height", "weight", "pos", "proxy", "info", "axis", "dir", "head", "cache", "version", "unit", "diff", "id", "prefix", "number", "depth", "Index", "num", "match", "x", "length", "slice", "loc", "parent", "image", "position", "block"], "on_read_error": ["on_read_ror", "on_write_progress", "on_read_progress", "on_read_errors", "on_write_ror", "on_write_errors"], "on_write_error": ["on_writing_error", "on_writeoutresult", "on_write_result", "on_writeouterr", "on_writing_err", "on_writeouterror", "on_writing_result", "on_write_err", "on_writing_change", "on_write_change", "on_writeoutchange"], "devaddr": ["devaddress", "pubAddress", "evaddr", "pubaddr", "devAddress", "devicesid", "deviceaddr", "pubaddress", "deviceAddress", "pubsid", "evAddress", "evaddress", "deviceaddress", "devsid", "evsid"], "dinfo": ["dcconf", "dlconf", " dconf", "dlinfo", "dconf", " dInfo", "dlInfo", " dapi", "dcInfo", "dlapi", "dInfo", "dapi", "dcinfo", "dcapi"], "io_limits": ["IO_limited", "IO_maps", "IO_limit", "io_limit", "IO_limits", "io_limited", "io_maps"], "copy_on_read": ["copy_on__reader", "copy_on__read", "copy_on_READ", "copy_onCaccess", "copy_On_write", "copy_On_access", "copy_On_read", "copy_on_reader", "copy_off_reader", "copy_on__write", "copy_off_read", "copy_On_load", "copy_on_write", "copy_on_access", "copy_off_write", "copy_off_READ", "copy_on__READ", "copy_onCwrite", "copy_onCread", "copy_on_load", "copy_onCload"], "ret": ["class", "def", "ref", "result", "val", " reply", "Ret", " resp", "model", "res", "rc", "rot", "num", "RET", "rt", "mem", "reply", "rev", "re", "rs", "nt", "lang", "lit", "resp", "rets"], "error": ["status", "ror", "row", "attribute", "query", "err", "option", "result", "progress", "ack", "layer", "op", "info", "bug", "ERROR", "comment", "success", "Error", "call", "slice", "parser", "rage", "resource", "block", "server", "danger", "command"]}}
{"project": "qemu", "commit_id": "f57ba05823b7c444133f0862077b45824a6a89b5", "target": 0, "func": "static int virtio_ccw_handle_set_vq(SubchDev *sch, CCW1 ccw, bool check_len,\n\n                                    bool is_legacy)\n\n{\n\n    int ret;\n\n    VqInfoBlock info;\n\n    VqInfoBlockLegacy linfo;\n\n    size_t info_len = is_legacy ? sizeof(linfo) : sizeof(info);\n\n\n\n    if (check_len) {\n\n        if (ccw.count != info_len) {\n\n            return -EINVAL;\n\n        }\n\n    } else if (ccw.count < info_len) {\n\n        /* Can't execute command. */\n\n        return -EINVAL;\n\n    }\n\n    if (!ccw.cda) {\n\n        return -EFAULT;\n\n    }\n\n    if (is_legacy) {\n\n        linfo.queue = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        linfo.align = address_space_ldl_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(linfo.queue),\n\n                                           MEMTXATTRS_UNSPECIFIED,\n\n                                           NULL);\n\n        linfo.index = address_space_lduw_be(&address_space_memory,\n\n                                            ccw.cda + sizeof(linfo.queue)\n\n                                            + sizeof(linfo.align),\n\n                                            MEMTXATTRS_UNSPECIFIED,\n\n                                            NULL);\n\n        linfo.num = address_space_lduw_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(linfo.queue)\n\n                                          + sizeof(linfo.align)\n\n                                          + sizeof(linfo.index),\n\n                                          MEMTXATTRS_UNSPECIFIED,\n\n                                          NULL);\n\n        ret = virtio_ccw_set_vqs(sch, NULL, &linfo);\n\n    } else {\n\n        info.desc = address_space_ldq_be(&address_space_memory, ccw.cda,\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.index = address_space_lduw_be(&address_space_memory,\n\n                                           ccw.cda + sizeof(info.desc)\n\n                                           + sizeof(info.res0),\n\n                                           MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.num = address_space_lduw_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.avail = address_space_ldq_be(&address_space_memory,\n\n                                          ccw.cda + sizeof(info.desc)\n\n                                          + sizeof(info.res0)\n\n                                          + sizeof(info.index)\n\n                                          + sizeof(info.num),\n\n                                          MEMTXATTRS_UNSPECIFIED, NULL);\n\n        info.used = address_space_ldq_be(&address_space_memory,\n\n                                         ccw.cda + sizeof(info.desc)\n\n                                         + sizeof(info.res0)\n\n                                         + sizeof(info.index)\n\n                                         + sizeof(info.num)\n\n                                         + sizeof(info.avail),\n\n                                         MEMTXATTRS_UNSPECIFIED, NULL);\n\n        ret = virtio_ccw_set_vqs(sch, &info, NULL);\n\n    }\n\n    sch->curr_status.scsw.count = 0;\n\n    return ret;\n\n}\n", "idx": 10364, "substitutes": {"sch": ["sac", "conf", "sp", "channel", "sh", "src", "ich", "chip", "sw", "ssh", "chid", "chn", "CH", "gh", "squ", "sk", "cs", "isc", "wic", "cht", "sky", "chy", "shop", "inch", "sche", "sl", "chi", "sb", "igh", "usb", "sd", "kh", "spec", "ech", "soc", "ses", "ch", "Sch", "sr", "ocr", "ssl", "sc"], "ccw": ["CChw", "ccwan", "ecy", "ucwa", "ecwal", "accfw", " ccW", "ghw", "rcl", "uccwall", "ghwork", "CCwa", "rcw", "rcwa", "rcW", "ccfw", "CCf", "cwd", "ccy", "CCw", "ccl", "acW", "ucw", "ccn", "ucwall", "ucfw", "uchw", "ccwork", "CCow", "ncw", " cchw", " ccwan", "ghws", "accw", "ccwall", "CCws", "acws", " ccy", "llwan", "ncW", "CCwe", "accW", "ecwd", "ghwall", " ccwd", " ccl", "cff", "ccwal", "ucwork", "ccwe", "cfws", "rcwan", "CCW", "cfW", "cw", "ccwd", " ccwa", "uccw", "cfow", " ccn", " ccws", "cfw", "ccow", "ccf", "cchw", " ccwal", "ncwe", "ecw", "ccW", "CCn", "ucW", "cwal", "ccws", "ucws", "ncws", "llwa", "uccwork", "accwa", "accf", "acw", "rcws", "accow", "cfwa", "cfn", "ccwa", "acwe", "uccws", "CCfw", "llw", "lll", "cy"], "check_len": ["check_count", "checkingcount", " checkercount", "check32length", "check64num", "checkercount", "checkerlen", "check_num", " checkerlen", "check64count", "checkingnum", " check_length", "check64len", "checkablelength", "block_num", "blockingcount", "blockinglength", "check_length", "check32count", "checkinglen", "block_count", " checkerlength", "checkerlength", "checkablelen", "block_length", "blockingnum", "check32len", "block_len", " check_count", "check64length", "blockinglen", "checkablecount", "checkinglength"], "is_legacy": ["is_legace", "is_legimental", "is_Legastic", "is_ledastic", "is_regacy", "is_Legace", "is_legantic", "is_Legantic", "is_regazy", "is_levacy", "is_lowimental", "is_regastic", "is_Legacy", "is_legazy", "is_regACY", "is_levimental", "is_lowACY", "is_ledazy", "is_levace", "is_regace", "is_legastic", "is_ledacy", "is_regimental", "is_lowace", "is_regantic", "is_ledace", "is_legACY", "is_Legazy", "is_levantic", "is_levACY", "is_lowacy"], "ret": ["arr", "valid", "alt", "val", "def", "nt", "Ret", " Ret", "data", "reply", "red", "ref", "arg", "lit", "reg", "rets", "ut", "res", "det", "opt", "aux", "rc", "fun", "att", "hash", "get", "bit", "eth", "fin", "cat", "re", "gc", "RET", " RET", "result", "rev", "mt", "match", "resp", "success"], "info": ["archive", "base", "json", "where", "http", "fw", "block", "config", "cb", "txt", "afi", "thin", "frame", "loc", "opt", "about", "end", "ii", "offset", "now", "orig", "init", "type", "image", "buff", "help", "fi", "alias", "si", "Info", "iso", "id", "i", "information", "work", "app", "f", "op", "index", "py", "hand", "error", "wx", "extra", "zip", "hi", "di", "ext", "def", "data", "util", "part", "cache", "result", "success", "diff", "conf", "ui", "fo", "start", "comment", "update", "job", "service", "INFO", "obj", "off", "bug", "name", "inner", "check", "api", "ignore", "inf"], "linfo": ["lanph", "lineno", "linece", "lenco", "Lincf", "lango", "lanfi", "leneno", "Linfo", "elinfi", "lnjo", "lanfo", "lanf", "lenbo", " Linjo", " Linf", "elinfo", "ilfo", "linetto", "ilph", "lenf", " linzo", "alincf", "synfo", "vinjo", " lingo", "linph", " Linfo", "lintto", "lubo", "lenph", "linjo", "synce", "vinfo", "linso", " linato", "Linjo", "vinf", "synso", "lanato", "elinjo", "elinbo", "lnfi", "lnzo", "Lintto", "synzo", "synf", "linfi", "lufo", "linefo", " linjo", "lingo", "lance", "elinzo", "Linma", "lnph", "luzo", "lenfo", "luso", "vinzo", "linbo", "lancf", "Lingo", "lanco", "vinco", "linego", "vinbo", " Linbo", " linf", "linema", "laneno", "lnfo", " linbo", "lincf", "linato", "alinbo", "elinf", "linco", " linma", "elinco", "Linf", "synato", "linzo", "alingo", "lineph", "Linbo", "linef", "linma", "synco", "Linph", "lanzo", "lneno", " linco", " lintto", " linso", " lineno", "ilbo", "lanbo", "lnbo", "linf", "ilco", "synph", "lenzo", "ilf", "lnf", "synbo", "alinfo", "ilzo", "lince", "vinph", "syneno", "lnco"]}}
{"project": "qemu", "commit_id": "af957387547b05ed6dc4d84c10cca42700a7aeda", "target": 0, "func": "void do_delvm(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    Error *err = NULL;\n\n    const char *name = qdict_get_str(qdict, \"name\");\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    bs1 = NULL;\n\n    while ((bs1 = bdrv_next(bs1))) {\n\n        if (bdrv_can_snapshot(bs1)) {\n\n            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);\n\n            if (err) {\n\n                monitor_printf(mon,\n\n                               \"Error while deleting snapshot on device '%s':\"\n\n                               \" %s\\n\",\n\n                               bdrv_get_device_name(bs),\n\n                               error_get_pretty(err));\n\n                error_free(err);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16507, "substitutes": {"mon": ["part", "m", "phys", "mag", "mod", "demon", "un", "base", "login", "ann", "mi", "bm", "mn", "pm", "module", "master", "mun", "mot", "am", "mo", "mc", "mat", "mini", "member", " monitor", "atom", "bro", "bo", "mr", "mos", "dm", "man", "chron", "meter", "dom", "mont", "danger", "mor", "Monitor", "domain", "monitor", "mer", "mm", "MON", "tom", "Mon", "mu"], "qdict": ["queststr", "qdatabase", " qdirectory", "reqds", "qdirectory", "reqdt", " qdatabase", "questdatabase", "sqstr", "qstr", "sqdirectory", "questdict", " qdt", "sqdatabase", "qdt", " qstr", "eqdt", "qds", "reqdict", " qds", "questdirectory", "sqdict", "eqds", "eqdict"], "bs": ["ns", "bugs", "ab", "bi", "s", "db", "rs", "obj", "base", "ob", "las", "ports", "bm", "ubs", "aos", "sb", "bc", "ls", "ss", "pb", "fs", "bb", "lb", "ba", "bid", "cs", "css", "gb", "Bs", "bos", "ins", "obs", "bu", "BS", "iss", "blocks", "bis", "abi", "bl", "vs", "bh", "bas", "fb", "ses", "ps", "js", "bits", "b", "gs", "bytes", "os", "bes", "us", "bal", "conn", "ds", "bing"], "bs1": ["lsone", "ras0", "nsone", "bes0", "psone", "bsone", "besone", "bas3", "rasone", "bes91", "bs0", "BSOne", "b1", "b0", "ps0", "obsOne", "bas1", "ns1", "bone", "ras1", "bes1", "obsone", "bc2", "BS0", "bes3", "bc0", "bs91", "bs2", "obs1", "osone", "osOne", "psOne", "ns91", "bas2", "ls1", "os1", "bs3", "bcone", "bsOne", "ras91", "obs0", "bc1", "bc3", "BS1", "lsOne", "ns0", "ps1", "bas0", "BSone", "bes2"], "err": ["rr", "ner", "fr", "br", "rage", "runner", "cor", "ref", "r", "ar", "str", "result", "arm", "finder", "ext", "ind", "ore", "progress", "resp", "der", "ee", "ger", "arr", "orr", "erer", "fer", "later", "gr", "aster", "order", "mr", "rar", "rn", "id", "ler", "e", "dr", "lr", "cr", "acer", "req", "ir", "fee", "good", "fy", "error", "sys", "Er", "ace", "er", "errors", "res", "iter", "Error", "inner", "attr", "ver", "bug"], "name": ["part", "code", "data", "x", "base", "comment", "ame", "n", "num", "str", "block", "type", "pass", "Name", "min", "description", "label", "nm", "NAME", "alias", "new", "path", "size", "no", "prefix", "id", "key", "parent", "url", "b", "error", "names", "len", "desc", "version"]}}
{"project": "qemu", "commit_id": "40f08e87f613273f9dcc8df7d6a0f574b7d28d05", "target": 1, "func": "static void mm_stop_timer(struct qemu_alarm_timer *t)\n\n{\n\n    timeKillEvent(mm_timer);\n\n    timeEndPeriod(mm_period);\n\n}\n", "idx": 25185, "substitutes": {"t": ["w", "i", "p", "m", "b", "c", "d", "ts", "time", "T", "ct", "it", "port", "e", "o", "tick", "s", "tt", "dt", "f", "n", "tp", "v", "r", "tty", "l", "ut", "g"]}}
{"project": "qemu", "commit_id": "3c529d935923a70519557d420db1d5a09a65086a", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,\n\n        int64_t sector_num, uint8_t *buf, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    /*\n\n     * If O_DIRECT is used and the buffer is not aligned fall back\n\n     * to synchronous IO.\n\n     */\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {\n\n        QEMUBH *bh;\n\n        acb = qemu_aio_get(bs, cb, opaque);\n\n        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);\n\n        bh = qemu_bh_new(raw_aio_em_cb, acb);\n\n        qemu_bh_schedule(bh);\n\n        return &acb->common;\n\n    }\n\n\n\n    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (aio_read(&acb->aiocb) < 0) {\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 23393, "substitutes": {"bs": ["obs", "bc", "pb", "lc", "sb", "bos", "lb", "bis", "qs", "ba", "fs", "ses", "ubs", "db", "fb", "bytes", "bid", "bl", "bes", "css", "ds", "bing", "cas", "eb", "fps", "bas", "ob", "os", "vs", "cs", "ls", "bi", "bps", "sa", "js", "b", "bits", "ns", "BS", "iss", "ps", "gs", "http", "rb", "base", "ss", "las", "gb"], "sector_num": ["section_dom", " sector_name", "sector_begin", "block_begin", "section_num", "sectoridnom", "block_name", "sector_end", " sector_length", "block_number", "block_num", "sector_dom", "sectoriddom", "sector_nom", "sectoringnom", "sectoridend", "sectoringend", " sector_number", "section_nom", "section_end", "sector_length", "sector_name", "sectoringdom", "sector_number", "sectoridnum", "sectoringnum"], "buf": ["bc", "pb", "port", "uf", "limit", "lb", "prop", "uc", "end", "ref", "config", "text", "val", "cv", "fb", "queue", "bb", "bytes", "pad", "fp", "cas", "buffer", "gb", "path", "cmd", "data", "wb", "pool", "rc", "lim", "num", "byte", "b", "mem", "blocks", "seq", "ff", "src", "length", "fd", "len", "loc", "bd", "Buffer", "ab", "batch", "feed", "buff", "bf", "proc", "array", "bag", "vec", "rb", "block", "offset", "feat", "padding"], "nb_sectors": ["nb_segments", "nb_sections", "nb_teces", "nb_vegments", "nb_beivers", "nb_pegments", "nb_veivers", "nb_pections", "nb_vections", "nb_veces", "nb_gecs", "nb_beces", "nb_secctions", "nb_veapters", "nb_secctors", "nb_begments", "nb_teivers", "nb_gectors", "nb_tegments", "nb_serctions", "nb_tectors", "nb_vectors", "nb_sercs", "nb_seces", "nb_bectors", "nb_vecs", "nb_seivers", "nb_pectors", "nb_secs", "nb_secgments", "nb_serctors", "nb_seccs", "nb_seapters", "nb_serapters", "nb_geapters", "nb_pecs", "nb_gections"], "cb": ["lc", "bc", "pb", "sb", "cd", "lb", "config", "usb", "db", "cv", "unc", "fb", "func", "bb", "function", "fp", "buffer", "cmp", "rob", "eb", "cmd", "cp", "obb", "ob", "cf", "ctrl", "tc", "abc", "code", "wb", "c", "ctx", "CB", "cfg", "b", "cpp", "gc", "src", "callback", "buff", "conf", "rb", "fn", "cod", "cgi", "gb"], "opaque": ["OPaque", "opaques", "opec", "copc", "copaques", "ipace", "ipacity", "Opac", "ipaque", " opac", "copaque", "oppaque", "iopaques", "opc", "oppacity", "opace", "pque", "Opacity", "pacity", "iopace", "pace", " opc", "ipque", "opacity", "OPec", "OPacity", "OPac", "opac", " opacity", "Opaque", "OPc", "opque", "iopacity", "copque", "copacity", "iopaque", "paque", " opec", "oppaques", "copec", "iopque", "oppque"], "acb": ["accp", "awab", " acbs", " acv", "acv", " acbf", "ACb", "ACB", "ackfb", "acca", "akb", "ocb", "ecv", "ecb", "accbe", "ackbb", "ocbs", "accn", "ecf", "ainpl", "acB", " acp", "accab", "accv", "acab", "acfb", "ack", "ancp", "aca", "sacob", " acn", "accb", "ecbf", "ACp", " acob", "sacbs", "ecfb", " acsb", " acB", "accf", "ancob", "sacbb", "ecn", "acsb", "ecsb", "akpl", " acfb", "agk", "akbb", " acf", "acn", "acob", "anca", "accbb", "ackbf", "sacb", "ancv", "agbe", "ancpl", "ancbe", "acf", "ainb", " aca", "ancsb", "ainob", "ocbe", "akob", "accsb", "ocbb", "ancbb", "ackb", "awa", "acpl", "acbf", "ACsb", "acp", "agp", "agb", "anck", "ancb", "acbs", "awb", "ocp", "awv", "ecB", "ecp", "eca", "ainbb", "ecbe", "acbb", "ecbb", "ACbb", "ocob", "ecab", "ock", " acbb", "acbe"], "s": ["status", "e", "bis", "sl", "fs", "ses", "services", "sys", "state", "ssl", "os", "p", "cs", "ls", "is", "stats", "sa", "sg", "settings", "c", "js", "spec", "si", "b", "service", "session", "S", "ns", "iss", "ps", "rs", "gs", "http", "secondary", "su", "ss", "states"], "bh": ["ih", "hab", "pb", "sb", "hp", "hy", "hm", "lb", "ba", "bang", "acl", "ha", "db", "fb", "bb", "bp", "dh", "bl", "lr", "fp", "sth", "ah", "ht", "kh", "adh", "bg", "obb", "aph", "bt", "abi", "rh", "bi", "wb", "uh", "af", "amb", "kk", "sh", "b", "hub", "hl", "bm", "zh", "bd", "bel", "gh", "bf", "http", "h", "xb", "ph", "abb", "hh"]}}
{"project": "qemu", "commit_id": "ecf5e8eae8b0b5fa41f00b53d67747b42fd1b8b9", "target": 0, "func": "static inline bool regime_translation_disabled(CPUARMState *env,\n\n                                               ARMMMUIdx mmu_idx)\n\n{\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        switch (env->v7m.mpu_ctrl &\n\n                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK:\n\n            /* Enabled, but not for HardFault and NMI */\n\n            return mmu_idx == ARMMMUIdx_MNegPri ||\n\n                mmu_idx == ARMMMUIdx_MSNegPri;\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:\n\n            /* Enabled for all cases */\n\n            return false;\n\n        case 0:\n\n        default:\n\n            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but\n\n             * we warned about that in armv7m_nvic.c when the guest set it.\n\n             */\n\n            return true;\n\n        }\n\n    }\n\n\n\n    if (mmu_idx == ARMMMUIdx_S2NS) {\n\n        return (env->cp15.hcr_el2 & HCR_VM) == 0;\n\n    }\n\n    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;\n\n}\n", "idx": 15653, "substitutes": {"env": ["forge", "erv", "en", "context", "enh", "esp", "enc", "cv", "ench", "ea", "profile", "enter", "config", "core", "eve", "iv", "eu", "oa", "press", "ass", "er", "req", "txt", "skin", "conf", "np", "loader", "energy", "impl", "dict", "equ", "e", "viron", "engine", "exc", "eng", "ext", "Environment", "export", "eni", "shell", "dt", "ne", "ov", "que", "exec", "db", "ev", "vel", "ec", "emb", "environment", "fen", "el", "iss", "ef", "cur", "err"], "mmu_idx": ["mmu_idX", "mmu_idex", "mmu_idsX", "mmu_idsc", "mmu_idc", "mmu_sidx", "mmu_midx", "mmu_ridx", "mmu_ridb", "mmu_idev", "mmu_Idc", "mmu_sidxc", "mmu_idexe", "mmu_Idb", "mmu_idb", "mmu_sidc", "mmu_idsy", "mmu_midxc", "mmu_midy", "mmu_midxe", "mmu_idxc", "mmu_IdX", "mmu_sidxe", "mmu_ridxc", "mmu_sidX", "mmu_Idx", "mmu_idsx", "mmu_Idv", "mmu_idv", "mmu_Idxc", "mmu_idexc", "mmu_idy", "mmu_Idxe", "mmu_sidy", "mmu_ridX", "mmu_idxe"]}}
{"project": "qemu", "commit_id": "7ef8cf9a0861b6f67f5e57428478c31bfd811651", "target": 1, "func": "static int scsi_req_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    cmd->xfer = scsi_cdb_length(buf);\n\n    switch (buf[0]) {\n\n    case TEST_UNIT_READY:\n\n    case REWIND:\n\n    case START_STOP:\n\n    case SET_CAPACITY:\n\n    case WRITE_FILEMARKS:\n\n    case WRITE_FILEMARKS_16:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case SYNCHRONIZE_CACHE_16:\n\n    case LOCATE_16:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG_10:\n\n    case UPDATE_BLOCK:\n\n    case RESERVE_TRACK:\n\n    case SET_READ_AHEAD:\n\n    case PRE_FETCH:\n\n    case PRE_FETCH_16:\n\n    case ALLOW_OVERWRITE:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n        if ((buf[1] & 2) == 0) {\n\n            cmd->xfer = 0;\n\n        } else if ((buf[1] & 4) == 1) {\n\n            cmd->xfer = 1;\n\n        }\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        cmd->xfer = dev->blocksize;\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        cmd->xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        cmd->xfer = 6;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        /* GPCMD_SET_STREAMING from multimedia commands.  */\n\n        if (dev->type == TYPE_ROM) {\n\n            cmd->xfer = buf[10] | (buf[9] << 8);\n\n        } else {\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case WRITE_6:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case WRITE_10:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case READ_10:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case FORMAT_UNIT:\n\n        /* MMC mandates the parameter list to be 12-bytes long.  Parameters\n\n         * for block devices are restricted to the header right now.  */\n\n        if (dev->type == TYPE_ROM && (buf[1] & 16)) {\n\n            cmd->xfer = 12;\n\n        } else {\n\n            cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4);\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n    case RECEIVE_DIAGNOSTIC:\n\n    case SEND_DIAGNOSTIC:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    case READ_CD:\n\n    case READ_BUFFER:\n\n    case WRITE_BUFFER:\n\n    case SEND_CUE_SHEET:\n\n        cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16);\n\n        break;\n\n    case PERSISTENT_RESERVE_OUT:\n\n        cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL;\n\n        break;\n\n    case ERASE_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* MMC command GET PERFORMANCE.  */\n\n            cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8),\n\n                                                    buf[10], buf[1] & 0x1f);\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n    case READ_DVD_STRUCTURE:\n\n    case SEND_DVD_STRUCTURE:\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* BLANK command of MMC */\n\n            cmd->xfer = 0;\n\n        } else {\n\n            cmd->xfer = ata_passthrough_12_xfer_size(dev, buf);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_16:\n\n        cmd->xfer = ata_passthrough_16_xfer_size(dev, buf);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12409, "substitutes": {"cmd": ["device", "head", "call", "root", "pkg", "input", "config", "cc", "code", "child", "utils", "msg", "ht", "def", "ctrl", "req", "MD", "send", "std", "module", "cmp", "init", "nd", "ct", "force", "client", "conn", "help", "cd", "grad", "clean", "ind", "plugin", "cli", "ck", "acl", "parent", "cfg", "add", "c", "cat", "dc", "bind", "cb", "target", "md", "text", "gen", "Cmd", "cod", "cf", "nt", "command", "cookie", "cp", "mac", "comm", "host", "vc", "window", "cur", "wd", "dom", "hw", "ctx"], "dev": ["device", "proc", "ch", "cam", "d", "enc", "priv", "def", "serial", "ve", "user", "Dev", "mod", "comment", "server", "app", "valid", "conf", "unknown", "var", "der", "conn", "client", "de", "pub", "prof", "adv", "pad", "info", "ver", "engine", "temp", "desc", "data", "driver", "error", "des", "diff", "serv", "dem", "end", "dc", "DEV", "md", "dd", "ev", "off", "reg", "debug", "dom", "err"], "buf": ["func", "vec", "ff", "context", "uc", "bc", "queue", "fd", "array", "cv", "enc", "batch", "rc", "uint", "bb", "fb", "home", "bd", "msg", "uf", "conv", "bytes", "nb", "buffer", "bus", "bag", "v", "br", "buff", "band", "grab", "img", "rb", "exc", "data", "b", "fab", "Buffer", "box", "wb", "Buff", "bf", "result", "gb", "usb", "bh", "ab", "bu", "tab", "cb", "bo", "bg", "comb", "db", "src", "seq", "window", "cur", "pad", "ctx", "alloc"]}}
{"project": "qemu", "commit_id": "3eff1f46f08a360a4ae9f834ce9fef4c45bf6f0f", "target": 0, "func": "static void virtio_scsi_complete_req(VirtIOSCSIReq *req)\n\n{\n\n    VirtIOSCSI *s = req->dev;\n\n    VirtQueue *vq = req->vq;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);\n\n    if (req->sreq) {\n\n        req->sreq->hba_private = NULL;\n\n        scsi_req_unref(req->sreq);\n\n    }\n\n    virtio_scsi_free_req(req);\n\n    virtio_notify(vdev, vq);\n\n}\n", "idx": 12710, "substitutes": {"req": ["sem", "proc", "def", "low", "str", "cmp", "mr", "rec", "ver", "tar", "requ", "spec", "pro", "pri", "call", "ru", "dq", "ctr", "progress", "fr", "grad", "resource", "require", "data", "ext", "iq", "r", "exec", "ev", "res", "rf", "rr", "tr", "config", "wx", "ref", "init", "app", "rh", "conn", "war", "sec", "desc", "rx", "http", "qt", "f", "dep", "query", "wa", "load", "rt", "cur", "push", "ctx", "err", "pkg", "hr", "worker", "required", "row", "this", "user", "sq", "conf", "request", "p", "crit", "pull", "q", "cmd", "org", "resp", "qq", "seq"], "s": ["sys", "ses", "m", "service", "d", "t", "fs", "sym", "g", "S", "os", "sk", "js", "si", "es", "sq", "session", "server", "v", "ss", "client", "o", "w", "dev", "p", "e", "sb", "b", "sf", "n", "f", "gs", "spec", "c", "ns", "ssl", "r", "ds", "services", "su"], "vq": ["hq", " vque", "jque", "vrw", "vqt", "vp", "tvq", "vqu", "vqa", "fqu", "hg", "nqt", "vrdev", " vw", "fdev", "fqs", "fp", "hqt", "evqs", "tvp", "tvqs", "nw", " vg", "hque", " vqa", "fque", "nq", "vque", "evp", "vw", "fq", "fqa", "vrq", "vqs", "nqu", "nque", "vg", "vrqa", "ng", "jw", "jq", " vqt", "evq", "evque", "jqu", "tvque", "fw"], "vdev": [" vdiv", "Vdiv", "vconn", "wconn", "wdev", "Vdev", " vev", "vdiv", "Vrc", "wdevice", " vconn", "lconn", "Vev", "wdiv", "vrc", "ldev", "vmdiv", "vdevice", " vrc", "vmrc", " vdevice", "vmev", "vmdev", "ldevice", "vev"]}}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int segment_hls_window(AVFormatContext *s, int last)\n\n{\n\n    SegmentContext *seg = s->priv_data;\n\n    int i, ret = 0;\n\n    char buf[1024];\n\n\n\n    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,\n\n                              &s->interrupt_callback, NULL)) < 0)\n\n        goto fail;\n\n\n\n    avio_printf(seg->pb, \"#EXTM3U\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-VERSION:3\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-TARGETDURATION:%d\\n\", (int)seg->time);\n\n    avio_printf(seg->pb, \"#EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n                FFMAX(0, seg->number - seg->size));\n\n\n\n    av_log(s, AV_LOG_VERBOSE, \"EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n           FFMAX(0, seg->number - seg->size));\n\n\n\n    for (i = FFMAX(0, seg->number - seg->size);\n\n         i < seg->number; i++) {\n\n        avio_printf(seg->pb, \"#EXTINF:%d,\\n\", (int)seg->time);\n\n        if (seg->entry_prefix) {\n\n            avio_printf(seg->pb, \"%s\", seg->entry_prefix);\n\n        }\n\n        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);\n\n        if (ret < 0) {\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        avio_printf(seg->pb, \"%s\\n\", buf);\n\n    }\n\n\n\n    if (last)\n\n        avio_printf(seg->pb, \"#EXT-X-ENDLIST\\n\");\n\nfail:\n\n    avio_closep(&seg->pb);\n\n    return ret;\n\n}\n", "idx": 10620, "substitutes": {"s": ["conf", "session", "sg", "ts", "sv", "si", "g", "n", "sf", "stats", "m", "src", "b", "t", "gs", "sa", "c", "service", "serv", "p", "server", "ls", "e", "qs", "se", "xs", "js", "sq", "rs", "f", "args", "us", "o", "aws", "v", "es", "sync", "scope", "south", "sie", "sl", "services", "ns", "sb", "storage", "spec", "u", "self", "comm", "h", "sys", "client", "soc", "a", "su", "site", "ses", "ss", "sr", "core", "ssl", "sc"], "last": ["count", "later", "parent", "l", "timeout", "start", "show", "second", "Last", "info", "total", "latest", "reply", "max", "prev", "se", "cli", "final", "style", "loc", "lag", "sec", "next", "code", "size", "eval", "event", "state", "end", "old", "full", "first", "error", "after", "li", "length", "result", "use", "lo"], "seg": [" sek", "SEc", "kep", "eleig", "kel", "beg", "teig", "serge", "elega", "tegen", "sug", "ceg", "segm", "schega", "sege", "kege", "SEgo", "keG", "segs", "zego", "kegn", "neG", "gec", "negen", "zek", "serg", "SEp", "lec", "gee", "gego", "schege", "geg", "adeg", "kegg", "neig", "adeleg", "kec", "serig", "SEb", " segm", "sugment", "zega", "keg", "begg", "gega", "speb", "tege", "peg", "tega", " sega", "pseg", "bep", "schegn", "zeg", "selk", "persego", "schegg", "begm", "inego", "tegm", "segment", "sergen", "segn", "cege", "legen", "begs", "seig", " sego", "nego", "sep", "sega", " segen", "selgg", "pegen", "nep", "SEg", "SEge", "zep", "adegg", "tegn", "spegen", "pec", "speg", "scheg", "seleg", "persegen", "sel", "kego", "suga", "gep", "geig", "seeg", "pep", "schego", "parsegn", "tego", " see", "selge", "SEga", " segn", "seb", "keig", "selgn", "bega", "cega", "schegment", "kegen", "sek", "eleg", "neg", "parseg", "pega", "segen", "SEgen", "gege", "inega", "sego", "keleg", "ineg", "tee", "adep", "pege", "psegn", "psep", "spego", "segg", "nega", "seegs", "selga", "elege", "leg", " sege", "lel", "gegn", "perseg", "psegen", "gegm", "inege", "begen", "zege", "seep", "peig", "gegment", "selg", "sec", "sugn", "parsegen", "seegm", "beleg", "cegen", "gegen", " sep", " sec", "teg", "see", "SEig", "SEgn", "gegs", "perseb", "gel", "parsep", "psega", "kega", "seG", "geG"], "i": ["oi", "l", "ui", "di", "base", "it", "start", "n", "si", "in", "zi", "info", "xi", "id", "b", "ini", "z", "c", "line", "limit", "p", "ix", "uri", "e", "iter", "eni", "f", "ie", "j", "ai", "multi", "index", "slice", "ind", "mi", "ti", "gi", "phi", "name", "r", "abi", "qi", "bi", "pi", "ii", "type", "I", "li", "ip", "ci", "ni", "ski", "ri", "fi", "iu"], "buf": ["bag", "uf", " b", "seq", "Buffer", "img", "ff", "pad", "ba", "src", "fd", "b", "wb", " arr", "mem", " bu", "pool", "block", "data", "fb", "bd", "config", "fi", "pb", "cb", "fp", "queue", "rb", "loc", "tmp", "bc", "f", "alloc", "cv", "msg", "exc", "rc", "bh", "bed", "raw", "home", "ctx", "callback", "bytes", "h", "null", "ret", " buffer", "func", "buff", "br", "cmd", "result", "vec", "buffer", " buff", "text", "box", "uc"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_main_loop_start(void)\n\n{\n\n}\n", "idx": 19966, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "7104c23bd1a1dcb8a7d9e2c8838c7ce55c30a331", "target": 0, "func": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int A[2] = {0}, B[2], C[2];\n\n    int i, j;\n\n    int mx, my;\n\n    int avail_index = avail_indexes[subblock_no];\n\n    int c_off = part_sizes_w[block_type];\n\n\n\n    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*s->b8_stride;\n\n    if(subblock_no == 3)\n\n        c_off = -1;\n\n\n\n    if(r->avail_cache[avail_index - 1]){\n\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][0];\n\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][1];\n\n    }\n\n    if(r->avail_cache[avail_index - 4]){\n\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + c_off]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[dmv_no][0];\n\n    my += r->dmv[dmv_no][1];\n\n    for(j = 0; j < part_sizes_h[block_type]; j++){\n\n        for(i = 0; i < part_sizes_w[block_type]; i++){\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][0] = mx;\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][1] = my;\n\n        }\n\n    }\n\n}\n", "idx": 27317, "substitutes": {"r": ["ru", "rs", "k", "sr", "er", "w", "this", "b", "m", "p", "c", "d", "dr", "rf", "x", "rb", "br", "mr", "ra", "tr", "fr", "self", "rss", "nor", "e", "R", "rh", "err", "l", "re", "rc", "rg", "kr", "ar", "ur", "as", "h", "ir", "rt", "f", "pr", "n", "t", "v", "rr", "result", "hr", "g"], "block_type": [" block_pos", "blockworkkey", "block_name", "blockingtype", "block_pos", "blockworktype", "blockingname", "blockinglock", "blockingkey", " block_key", " block_name", " block_lock", "block_key", "blockworklock", " block_no", "block_no", "block_number", " block_number", "block_lock", "blockworkname"], "subblock_no": ["subblockIDno", "subblock2number", "subblock_po", "subBlock_nr", "subblock1pos", "subBlock_num", "subblock_No", "subblock1num", "subblock2po", "subblock2pos", "subblock2no", "subblock2No", "subblock_pos", "subBlock_number", "subblock_nu", "subblockIDpos", "subblock2num", "subblock_nos", "subblock_num", "subblock_code", "subBlock_code", "subBlock_No", "subblockIDbo", "subblock1nos", "subblock2nr", "subblock_bo", "subBlock_po", "subBlock_pos", "subblock1number", "subBlock_bo", "subBlock_nos", "subblock_nr", "subblockIDnu", "subblock1No", "subblock1nr", "subblock2nos", "subblock1no", "subBlock_no", "subblock_number", "subBlock_nu"], "dmv_no": ["dmf2from", "dmv2number", "dmvblockno", "dmf_nos", "dmvdno", "dmv_number", "dmvdfrom", "dmvdnos", "dmv2nos", "dmvblocknos", "dmv2from", "dmf2number", "dmv_from", "dmf_no", "dmf_from", "dmvblockfrom", "dmf2no", "dmvdnumber", "dmf_number", "dmv_nos", "dmf2nos", "dmv2no", "dmvblocknumber"], "s": ["sys", "w", "sy", "server", "ns", "ts", "sq", "sync", "self", "u", "es", "gs", "stats", "south", "share", "http", "lines", "sym", "current", "f", "service", "js", "n", "sim", "fs", "t", "native", "S", "er", "p", "m", "b", "c", "se", "x", "sports", "storage", "ds", "us", "su", "is", "spec", "one", "services", "h", "sl", "settings", "in", "g", "side", "rs", "ses", "ss", "d", "conf", "sg", "e", "session", "sb", "setup", "client", "sf", "ssl", "sc", "opt", "site", "o", "multi", "si", "os", "ls", "y", "a", "an", "v", "l"], "A": ["S", "None", "L", "An", "AF", "Va", "Ar", "AA", "Am", "P", "API", "T", "File", "H", "AT", "AW", "X", "AS", "AV", "U", "AC", "Alpha", "GA", "M", "LA", "D", "IA", "This", "AD", "Y", "SA", "Array", "G", "All", "mA", "AM", "NA", "N", "Ca", "I", "At", "CA", "W", "MA", "a", "V", "E", "AU", "And", "AB", "Ab", "AP", "AR", "As", "F"], "B": ["OB", "S", "L", "BA", "Q", "DB", "IB", "b", "K", "VB", "P", "T", "BR", "H", "Z", "BS", "SB", "X", "EB", "PB", "LB", "U", "TB", "R", "Block", "M", "Bs", "D", "BF", "Y", "WB", "NB", "Bar", "Base", "GB", "Both", "G", "N", "I", "BE", "AB", "W", "MB", "V", "QB", "E", "J", "AP", "BB", "O", "BG", "UB", "F"], "C": ["S", "L", "CE", "Q", "CL", "GC", "DC", "c", "Code", "CU", "CS", "P", "T", "KC", "Ch", "Cl", "X", "YC", "Cache", "U", "EC", "AC", "R", "M", "CC", "D", "Cu", "CW", "Y", "Config", "CNN", "CI", "CV", "G", "CT", "N", "CP", "CN", "MC", "CA", "W", "V", "E", "Cons", "VC", "Sc", "Con", "Ca", "O", "F"], "i": ["k", "z", "p", "m", "b", "c", "d", "x", "mi", "phi", "it", "e", "li", "ii", "si", "ai", "ci", "h", "I", "f", "y", "n", "ip", "index", "iu", "pi"], "j": ["k", "w", "z", "p", "b", "m", "kj", "x", "je", "jp", "aj", "em", "ji", "o", "l", "ii", "ij", "h", "y", "n", "mm", "q", "v", "J", "pos", "g"], "mx": ["cm", "nm", "ml", " mc", "m", "px", "me", "ms", "jp", "mi", "hh", "nz", "wx", "ma", "max", "cl", " m", "mn", "ij", " mm", "ga", "ng", "xp", "rx", "mm", "avier", "mu", "ap"], "my": ["md", "micro", "th", "nm", "My", "me", "Mi", "mmm", "ms", "am", "hh", "mid", "nz", "MY", "mos", "yo", "mic", "hz", "sym", "mis", "mn", "pm", "mo", "mon", "ng", "MM", "mm"]}}
{"project": "qemu", "commit_id": "6baebed7698a37a0ac5168faf26023426b0ac940", "target": 1, "func": "static int find_dirty_height(VncState *vs, int y, int last_x, int x)\n\n{\n\n    int h;\n\n\n\n    for (h = 1; h < (vs->serverds.height - y); h++) {\n\n        int tmp_x;\n\n        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))\n\n            break;\n\n        for (tmp_x = last_x; tmp_x < x; tmp_x++)\n\n            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);\n\n    }\n\n\n\n    return h;\n\n}\n", "idx": 18194, "substitutes": {"vs": ["ns", "ums", "vas", "ts", "s", "bs", "stats", "rs", "vr", "las", "sv", "vc", "services", "vp", "ils", "vals", "sb", "ys", "ss", "ls", "ops", "fs", "xs", "lines", "lv", "vers", "sk", "views", "cs", "css", "VS", "obs", "outs", "qs", "ov", "ses", "v", "verts", "js", "ps", "alls", "vt", "sts", "ks", "http", "gs", "va", "es", "env", "cv", "ds"], "y": ["j", "ch", "ky", "t", "sky", "iy", "hy", "ya", "i", "year", "ys", "type", "z", "ny", "ym", "zy", "ry", "cy", "Y", "l", "d", "ye", "yi", "dy", "ay", "w", "height", "yy", "ey", "e", "ish", "key", "yt", "v", "yr", "c", "yn", "p", "col", "oy", "vy", "yo", "gy", "a", "py", "sy", "u"], "last_x": ["last__w", " last_ex", "last_index", "last__xy", " last_xp", "prev_y", " last_z", " last_xy", "last__xp", "last__x", " last_w", "prev_x", "prev_w", "prev_index", "last__y", "last__z", "last_w", "last_z", "last_xy", "last_xp", "last__ex", "last_y", "last_ex", " last_y"], "x": ["rx", "m", "xf", "xx", "t", "f", "ix", "px", "n", "i", "z", "xy", "max", "index", "pos", "xs", "en", "l", "d", "ax", "ex", "w", "dx", "e", "X", "q", "_", "v", "c", "p", "xi", "wa", "u"], "h": ["m", "j", "ch", "code", "t", "eh", "f", "oh", "hr", "n", "hy", "dh", "g", "gh", "hi", "i", "hd", "z", "rh", "max", "ho", "uh", "o", "han", "his", "home", "hhh", "l", "d", "ht", "sh", "kh", "height", "w", "hl", "id", "k", "q", "e", "bh", "v", "ih", "c", "hp", "p", "hm", "b", "hh", "ph", "ha", "hs", "he", "ah", "H", "u"], "tmp_x": ["tmp__xi", "last_rx", " tmp_name", " tmp_xs", "tmp_ex", " tmp_ex", "tmp_ix", " tmp_X", "last_ix", "tmp__y", "tmp_name", " tmp_rex", "tmp_xs", "tmp_pe", "tmp__pe", "tmp_X", " tmp_xi", " tmp_pe", "tmp_rex", "tmp__x", "tmp_y", " tmp_y", "last_X", "tmp_rx", "tmp_xi"]}}
{"project": "qemu", "commit_id": "a9f8ad8f2acdb2398da5d32a5efc19cb0196d79f", "target": 1, "func": "static void register_core_rtas(void)\n\n{\n\n    spapr_rtas_register(\"display-character\", rtas_display_character);\n\n    spapr_rtas_register(\"get-time-of-day\", rtas_get_time_of_day);\n\n    spapr_rtas_register(\"power-off\", rtas_power_off);\n\n\n\n\n}", "idx": 924, "substitutes": {}}
{"project": "qemu", "commit_id": "bf298f83c35da854632c5be75733a4aa95a780bf", "target": 0, "func": "void tlb_set_page(CPUState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    PhysPageDesc *p;\n\n    unsigned long pd;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    unsigned long addend;\n\n    CPUTLBEntry *te;\n\n    CPUWatchpoint *wp;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    p = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        pd = IO_MEM_UNASSIGNED;\n\n    } else {\n\n        pd = p->phys_offset;\n\n    }\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\\n\",\n\n           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK);\n\n    if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {\n\n        /* Normal RAM.  */\n\n        iotlb = pd & TARGET_PAGE_MASK;\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)\n\n            iotlb |= IO_MEM_NOTDIRTY;\n\n        else\n\n            iotlb |= IO_MEM_ROM;\n\n    } else {\n\n        /* IO handlers are currently passed a physical address.\n\n           It would be nice to pass an offset from the base address\n\n           of that region.  This would avoid having to special case RAM,\n\n           and avoid full address decoding in every device.\n\n           We can't use the high bits of pd for this because\n\n           IO_MEM_ROMD uses these as a ram address.  */\n\n        iotlb = (pd & ~TARGET_PAGE_MASK);\n\n        if (p) {\n\n            iotlb += p->region_offset;\n\n        } else {\n\n            iotlb += paddr;\n\n        }\n\n    }\n\n\n\n    code_address = address;\n\n    /* Make accesses to pages with watchpoints go via the\n\n       watchpoint trap routines.  */\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {\n\n            iotlb = io_mem_watch + paddr;\n\n            /* TODO: The memory case can be optimized by not trapping\n\n               reads of pages with a write breakpoint.  */\n\n            address |= TLB_MMIO;\n\n        }\n\n    }\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||\n\n            (pd & IO_MEM_ROMD)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&\n\n                   !cpu_physical_memory_is_dirty(pd)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 5381, "substitutes": {"env": ["eng", "cfg", "ea", "ep", "kn", "v", "ef", "config", "qt", "environment", "nc", "rc", "exc", "et", "enc", "queue", "eu", "inet", "db", "ext", "gui", "server", "obj", "init", "net", "conf", "ev", "np", "e", "en", "dev", "dc", "ctx", "exec", "ini", "Environment", "context", "ec", "network", "eni", "viron", "console", "global", "proc", "txt", "engine", "loader", "manager", "conn"], "vaddr": ["zaddress", "vadd", "vserver", " vserver", "voffset", "Voffset", " voffset", "vconfig", " vhost", "Vaddr", "zhost", "phost", "wadd", "faddr", "zaddr", " vconfig", "waddr", " vadd", "paddress", "vptr", "foffset", "tvaddr", "pptr", "Vaddress", "pserver", "fdr", "tvconfig", "pconfig", " vdr", "pdr", "qaddress", "tvaddress", "vhost", "zptr", " vaddress", "faddress", "vdr", "qaddr", "Vdr", "padd", "qhost", "qptr", "whost", "tvserver", "vaddress", "fhost", "fptr", "waddress"], "paddr": [" pmode", " poffset", "padded", "pyaddress", "vadd", " palign", "voffset", "vpairs", " voffset", "npaddr", "fadd", " pptr", "pyadded", "fmode", "pmode", "vpoffset", "vpalign", "pyaddr", "vpaddr", "vadded", "pairs", "faddr", "vpaddress", "npoffset", "pyoffset", "vpptr", "paddress", "vptr", "npairs", "valign", "pptr", "npaddress", " vairs", "vmode", " vaddress", "faddress", "palign", "poffset", "padd", " padd", " paddress", "vaddress", " padded"], "prot": ["stat", "fen", "ocol", "reset", "ret", "inf", "phy", "platform", "pro", "eth", " proto", "config", "rot", "rf", "Prot", "typ", "inet", "lit", "conv", "ext", "sil", "thin", "fl", "pri", "cli", "period", "np", "lo", "uri", "bis", "nat", "lat", "rx", "fp", " protocol", "rin", "iol", "prop", "addr", "dim", "prefix"], "mmu_idx": ["mmu_indg", "mmu_indb", "mmu_idf", "mmu_idg", "mmu_indf", "mmu_ridy", "mmu_ridv", "mmu_idy", "mmu_sidy", "mmu_idsxc", "mmu_idv", "mmu_sidv", "mmu_idsx", "mmu_idsy", "mmu_indx", "mmu_sidb", "mmu_idsv", "mmu_sidx", "mmu_sidf", "mmu_sidxc", "mmu_sidg", "mmu_ridx", "mmu_idxc", "mmu_ridxc", "mmu_idb"], "size": ["name", "SIZE", "large", "sec", "count", "fee", "shape", "value", "security", "sum", "data", "password", "sn", "si", "unit", "loc", "capacity", "offset", "limit", "length", "small", "Size", "ffff", "number", "code", "len", "uri", "en", "storage", "sized", "bytes", "empty", "timeout", "scale", "z", "global", "memory", "cap", "c", "class", "page", "desc", "ize", "max"], "p": ["cp", "P", "o", "bp", "python", "v", "pr", "parent", "pa", "pre", "po", "b", "pp", "i", "sync", "pe", "lp", "ap", "l", "pm", "f", "pi", "pg", "d", "j", "pc", "np", "dp", "e", "point", "w", "pn", "t", "n", "fp", "jp", "h", "vp", "sp", "c", "page", "api", "tp", "pb", "r", "ps", "pkg"], "pd": ["pat", "dh", "pins", "pm", "pi", "d", "td", "adh", "sd", "ped", "sha", "ppa", "gd", "dt", "tp", "pb", "mode", "nd", "cd", "plugin", "pid", " dd", "pod", "slice", "pattern", "pe", " rc", "php", "wordpress", "sth", "da", "ds", "xd", "pad", "dra", "ld", "std", "python", "pard", "md", "bd", "vd", "dat", "pa", "po", "pp", " prod", "wa", "lp", "ad", " sd", "att", "pc", "py", "np", "wd", "dp", "lda", "priority", "pos", "dep", "fd", "api", "dl", "dim", " delta", " td", "od", "pr", "dd", "si", "edd", "pg", "delay", " da", "dc", "PD", "hd"], "index": ["base", "position", "bin", "count", "ci", "config", "val", "si", "slice", "pattern", "loc", " indexes", "ion", "length", "pc", "fe", "ffff", "byte", "part", "len", "dc", "pos", "pointer", "type", "Index"], "address": ["area", "position", "entry", "ress", "shape", "Address", "object", "password", "alias", "module", "adjust", "image", "ace", "route", "region", "enter", "resource", "capacity", "package", "offset", "event", "order", "state", "server", "number", "code", "point", "uri", "message", "port", "array", "output", "network", "pointer", "memory", "attribute", "ip", "node", "location", "adr", "pair", "element", "addr", "host", "reference", "prefix"], "code_address": ["cache_number", "cache_reference", "data_address", "code_reference", "codeouthost", "data_addr", "code2address", "code2reference", "codeoutnumber", "code2host", "code_addr", "cache_host", "code_location", "code_number", "code2number", "data_location", "codeoutaddress", "code_host", "cache_address", "codeoutreference"], "addend": ["loadstart", "addstart", "loadending", " addends", " addending", "readest", "readends", "addends", "pushstart", "readend", "addpath", "pushend", "loadend", "addending", "Addends", "Addest", " addstart", "pushending", "Addpath", " addest", "Addend", "pushends", "addest", " addpath", "readpath", "loadends"], "te": ["ep", "inf", "fee", "ite", "ffe", "eu", "de", "ext", "ue", "fe", "ss", "e", "oe", "se", "inst", "tw", "we", "port", "oss", "ee", "ne", "eni", "ta", "slave", "txt", "ette", "pl", "au"], "wp": ["cp", "hp", "plugin", "gp", "hw", "bp", "ep", "fw", "wx", "pp", "op", "pod", "wm", "widget", "wk", "lp", "xp", "wb", "pg", "mp", "php", "arp", "pc", "wordpress", "np", "WP", "dp", "w", "pn", "dc", "ctx", "fp", "jp", "hop", "kw", "iw", "vp", "wu", "ip", "wl", "api", "tp", "pb"], "iotlb": ["iottb", "iottlas", "iotll", "cotlb", "otlas", "youtlp", "ontlp", "iollas", "youtlb", "otlr", "ietlp", "nitrb", "iollab", "iotla", "otrb", "ietlb", "ietb", "ietrb", "iotrb", "iotlab", "bootlas", "iollb", "iotl", "cotl", "otl", "bootlb", "iotlr", "iottlr", "youtl", "otb", "ietlr", "ittlp", "iottlp", "iotlp", "iottlab", "ittl", "nitla", "ittlb", "ietlab", "iottl", "ioll", "otlp", "ietll", "ittll", "iottlb", "ontlb", "nitl", "nitlb", "otlb", "bootl", "ontl", "ontll", "cotlp", "ietla", "iotb", "nitlp", "bootlab", "ietlas", "iotlas", "youtla", "ietl", "cotlas", "otlab"]}}
{"project": "qemu", "commit_id": "d78c19b5cf4821d0c198f4132a085bdbf19dda4c", "target": 0, "func": "static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,\n\n                                target_ulong tce)\n\n{\n\n    IOMMUTLBEntry entry;\n\n    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);\n\n    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;\n\n\n\n    if (index >= tcet->nb_table) {\n\n        hcall_dprintf(\"spapr_vio_put_tce on out-of-bounds IOBA 0x\"\n\n                      TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    tcet->table[index] = tce;\n\n\n\n    entry.target_as = &address_space_memory,\n\n    entry.iova = ioba & page_mask;\n\n    entry.translated_addr = tce & page_mask;\n\n    entry.addr_mask = ~page_mask;\n\n    entry.perm = spapr_tce_iommu_access_flags(tce);\n\n    memory_region_notify_iommu(&tcet->iommu, entry);\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 1497, "substitutes": {"tcet": ["tomET", "dcent", "tcat", "TClet", "tcets", "TCrt", "kuet", "TCet", "scnt", "timset", "TCets", "bcet", "tmot", " tcote", "tocets", "tcent", "TCET", "tomet", "TCent", "tcpet", "tmet", "tmets", "tocant", "tmett", "rcet", "rcinet", "tcote", "dcant", "TCant", "tocnt", "cmnt", "cmat", "tomett", "tocrt", "hhen", "tocet", "tcen", "tcot", "rcET", "tclet", "timpet", "scent", " tcset", " tcpet", "dcets", "tcset", "tcinet", "tocET", "ncet", "bcant", "hhinet", "bclet", "bcent", "timote", "cment", "dcet", "timet", "kuote", "ncen", "tcett", "kuset", "tmET", "rcen", "tcrt", "kupet", "tcnt", "hhet", "TCot", "scat", "ncinet", "tment", "tcant", "cmet", "hhET", "tomot", "bcat", "TCnt", "toclet", "tmant", "scet", "TCett", "tmrt", "bcnt", "ncET", "tcET"], "ioba": [" ioga", "lioby", "lioha", "siogg", "sioca", "ioca", "ioco", "uobe", "tioby", "uoba", "iogg", "siobe", "pioba", "enioha", " ioca", "siobi", "liunta", "piunta", "sioga", "sioby", "tioca", "enioba", "ioma", " iogg", "uogg", "sioba", "iobi", " ioby", "ioby", "pioco", " iobe", "pioha", "tioga", "tioba", "sioma", "piobe", "lioba", "enioby", " ioma", " ioco", "pioby", "piobi", "ioha", "sioco", "iobe", "eniunta", "uoma", "iunta", " iobi", "ioga"], "tce": [" tct", "tCE", " tke", "lace", "pfe", " tace", "tcp", "ptco", " tcp", "Tfe", "ptfe", " tcf", "lfe", " tco", "tct", "fCE", "pce", "tcer", "ttcer", "ttCE", "fcer", "lce", " tche", " tfe", "lke", "ttce", "Tcp", "TCE", " tCE", "tke", "tace", "Tct", "lcp", "pcf", "tche", "fce", "lCE", "tcf", "pke", "ptce", "fche", "Tace", "Tce", " tcer", "Tco", "tfe", "ttche", "lcf", "tco", "ptct"], "entry": ["match", "route", "server", "se", "row", "service", "offset", "inter", "key", "extra", "array", "data", "image", "new", "send", "add", " Entry", "type", "cat", "ge", "ry", "cur", "it", "record", "end", "insert", "ent", "member", "seed", "component", "Entry", "inner", "info", "event", "write", "index", "parse", "feed", "address", "ie", "result", "step", "or", "reader", "e", "try", "join", "obj", "comment", "connection", "way", "cel", "cell", "error", "element", "link", "module", "line", "engine", "valid", "enter", "part", "inc", "import", "response", "export", "slave"]}}
{"project": "qemu", "commit_id": "ff9d38963e55598b40237735426225c35de6c7e5", "target": 0, "func": "static void qdict_crumple_test_recursive(void)\n\n{\n\n    QDict *src, *dst, *rule, *vnc, *acl, *listen;\n\n    QObject *child, *res;\n\n    QList *rules;\n\n\n\n    src = qdict_new();\n\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n\n\n\n    res = qdict_crumple(src, &error_abort);\n\n\n\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n\n\n\n    dst = qobject_to_qdict(res);\n\n\n\n    g_assert_cmpint(qdict_size(dst), ==, 1);\n\n\n\n    child = qdict_get(dst, \"vnc\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    vnc = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(vnc, \"listen\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    listen = qobject_to_qdict(child);\n\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n\n\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(acl, \"rules\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n\n    rules = qobject_to_qlist(child);\n\n    g_assert_cmpint(qlist_size(rules), ==, 2);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    /* With recursive crumpling, we should see all names unescaped */\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qdict_get_qdict(vnc, \"acl\");\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n\n\n\n    QDECREF(src);\n\n    QDECREF(dst);\n\n}\n", "idx": 5104, "substitutes": {"src": ["sub", "scene", "r", "sr", "sec", "http", "sit", "spec", "s", "gru", "rb", "config", "rc", "sync", "sn", "slice", "dest", "stream", "sys", "uc", "loc", "support", "resource", "https", "href", "url", "sl", "scripts", "gz", "dist", "grad", "sc", "rss", "sb", "uri", "inst", "rect", "lib", "ctx", "go", "cb", "ruby", "nil", "feat", "filename", "source", "rl", "req", "gl", "remote", "iv", "gb", "sup", "supp", "sel", "ssl", "sq", "secure", "desc", "ref", "rs", "rob", "img", "RC", "rec", "pkg"], "dst": ["Dst", "bsc", " dsl", "lst", "fsts", "pdstr", " ddr", "dsc", "Dsts", "lsc", "pdsts", "pdsc", "dsp", "datsts", "dsts", "Dsc", "pdst", "fsc", " dsts", " dsc", "dsl", "dstr", "bsp", " dsp", "bsts", "Dstr", "lstr", "ddr", "Dsl", "zst", "zsc", "zstr", "datst", "datsl", "ldr", "zdr", "bst", "datsc", " dstr", "fst", "fsp"], "rule": ["row", "block", "rr", "parent", "record", "route", "tag", "resource", "Rule", "attr", "url", "roll", "comment", "ule", "rx", "result", "root", "reader", "run", "re", "node", "class", "user", "rol", "r", "ride", "role"], "vnc": ["vNC", "vnt", "vpc", "pcn", " vcn", "vrn", "hnc", "hrn", "Vdc", "Vnt", "svcn", "lnc", "vcn", "vdc", "Vnd", "ldc", "lcn", "svnc", "hcn", "lne", " vdc", "pnc", " vNC", "ppc", "lpc", "lNC", " vnd", "lnd", "svnt", " vne", "prn", "Vcn", " vrn", "pnd", "hpc", "VNC", " vpc", "vne", "svnd", "Vnc", "pnt", "Vpc", "vnd", "Vne"], "acl": ["oc", "anc", "cr", "el", "acc", "ace", "cl", "attr", "ack", "sc", "ol", "arr", "fn", "lib", "ctx", "rx", "exec", "rl", "lr", "ic", "ul", "ssl", "wl", "scl", "il", "asc", "ac", "cache", "rol"], "listen": ["Listan", "listened", "nullen", "Listem", "warden", "cyclan", "Liste", "Listen", "listenum", "Listel", " lister", "listem", " listening", " listener", "warde", "Listening", "diffening", " listened", "cardem", "diffened", "warder", "wardel", "carder", "ler", "listening", "liste", "listan", "listel", "len", "lel", "diffen", "nullan", "lister", " listem", "Listened", "nullening", "listener", "cyclen", "carden", "nullenum", "cyclening", "cyclenum", "Listener", "cardener", "Lister", "Listenum", " listenum", "diffenum", "le"], "child": ["local", "entry", "anch", "ow", "children", "plus", "create", "boy", "code", "col", "kid", "Child", "brother", "sel", "current", "rec", "row", "build", "friend", "id", "cur", "count", "parent", "value", "xml", "content", "leaf", "server", "daughter", "comment", "path", "win", "work", "protected", "remote", "new", "cow", "end", "baby", "feed", "block", "rc", "key", "cl", "cell", "ck", "section", "oy", "global", "cache", "r", "seed", "cel", "sub", "ch", "pull", "session", "ell", "che", "ray", "resource", "rest", "client", "ack", "q", "result", "root", "this", "iv", "request", "gh", "slave", "ew", "inner"], "res": ["gr", "ris", "ret", "reg", "rr", "ress", "pre", "Res", "ros", "rel", "sys", "details", "repl", "resource", "results", "rh", "rest", "cs", "Rs", "ras", "ry", "resolution", "des", "rss", "rez", "error", "rus", "rx", "err", "response", "rev", "result", "pres", "root", "resh", "reader", "remote", "re", "RES", "R", "request", "os", "resources", "resp", "ps", "ref", "cache", "rs", "RS", "r", "rem", "rar", "js"], "rules": ["groups", "Rules", "files", "runs", "plugins", "comments", "rows", "names", "vals", "results", "rights", "args", "scripts", "stars", "ops", "tests", "rx", "lr", "settings", "blocks", "reader", "errors", "resources", "items", "params", "rs", "ras"]}}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static int dvbsub_decode(AVCodecContext *avctx,\n\n                         void *data, int *data_size,\n\n                         AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n    AVSubtitle *sub = data;\n\n    const uint8_t *p, *p_end;\n\n    int segment_type;\n\n    int page_id;\n\n    int segment_length;\n\n    int i;\n\n\n\n    av_dlog(avctx, \"DVB sub packet:\\n\");\n\n\n\n    for (i=0; i < buf_size; i++) {\n\n        av_dlog(avctx, \"%02x \", buf[i]);\n\n        if (i % 16 == 15)\n\n            av_dlog(avctx, \"\\n\");\n\n    }\n\n\n\n    if (i % 16)\n\n        av_dlog(avctx, \"\\n\");\n\n\n\n    if (buf_size <= 6 || *buf != 0x0f) {\n\n        av_dlog(avctx, \"incomplete or broken packet\");\n\n        return -1;\n\n    }\n\n\n\n    p = buf;\n\n    p_end = buf + buf_size;\n\n\n\n    while (p_end - p >= 6 && *p == 0x0f) {\n\n        p += 1;\n\n        segment_type = *p++;\n\n        page_id = AV_RB16(p);\n\n        p += 2;\n\n        segment_length = AV_RB16(p);\n\n        p += 2;\n\n\n\n        if (p_end - p < segment_length) {\n\n            av_dlog(avctx, \"incomplete or broken packet\");\n\n            return -1;\n\n        }\n\n\n\n        if (page_id == ctx->composition_id || page_id == ctx->ancillary_id ||\n\n            ctx->composition_id == -1 || ctx->ancillary_id == -1) {\n\n            switch (segment_type) {\n\n            case DVBSUB_PAGE_SEGMENT:\n\n                dvbsub_parse_page_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_REGION_SEGMENT:\n\n                dvbsub_parse_region_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_CLUT_SEGMENT:\n\n                dvbsub_parse_clut_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_OBJECT_SEGMENT:\n\n                dvbsub_parse_object_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAYDEFINITION_SEGMENT:\n\n                dvbsub_parse_display_definition_segment(avctx, p, segment_length);\n\n                break;\n\n            case DVBSUB_DISPLAY_SEGMENT:\n\n                *data_size = dvbsub_display_end_segment(avctx, p, segment_length, sub);\n\n                break;\n\n            default:\n\n                av_dlog(avctx, \"Subtitling segment type 0x%x, page id %d, length %d\\n\",\n\n                        segment_type, page_id, segment_length);\n\n                break;\n\n            }\n\n        }\n\n\n\n        p += segment_length;\n\n    }\n\n\n\n    return p - buf;\n\n}\n", "idx": 27261, "substitutes": {"avctx": ["navcontext", "avalconn", "avcontext", "avesync", "avalcn", "afcontext", "abcc", "avectx", "aviactx", "ajctx", "avekb", "avcn", "ajcot", "abcu", "airctx", "aviacas", "ajwcs", "aircontext", "navcca", "affw", "AVwcs", "AVcontext", "afcca", "avecc", " avci", "avcu", "abcf", "avepkg", "afsync", "avalfw", "avalloc", "aircot", "avcca", "abcontext", "AVconfig", "AVcn", "airpkg", "AVloc", "avalcontext", "AVvoc", "avalvoc", "afctx", "avconfig", "avpkg", "avalctx", "aviacontext", "avcot", "afci", "avfw", "avloc", "abctx", "aveloc", "AVcas", "Avci", "AVctx", "afvoc", "avci", "avcf", "avalwcs", "avalcf", "avevoc", "avcc", "avecontext", "avefw", "Avcu", "avsync", "avecu", "avvoc", "avalkb", "afcot", "avconn", "ajpkg", "afconn", "ajcontext", "navconn", "Avctx", "avalcca", "avecf", "afpkg", "abpkg", "aviaconfig", "ajcn", "avkb", "AVcf", "afcu", " avcu", "avalcas", "AVkb", "avalsync", "Avcontext", "avalcc", " avcontext", "avcas", "navctx", "avalconfig", "avwcs"], "data": ["load", "Data", "body", "package", "primary", "batch", "frame", "context", "image", "d", "cat", "buffer", "api", "base", "media", "text", "config", "next", "reader", "ra", "rec", "aux", "message", "padding", "input", "dat", "sample", "parent", "board", "client", "size", "rc", "cache", "response", "channel", "block", "length", "buff", "window", "au", "bytes", "umi", "value", "da", "DATA", "content", "results", "root", "meta", "map", "result", "val"], "data_size": ["data_start", "buffer_width", "datablocksize", "datablockwidth", "buffer_length", "data_width", "datablocklength", "buffer_start", "buffer_size", "datablockstart", "data_length"], "avpkt": ["AVPuto", "AVfct", "AVpacket", "avlpke", "avPkt", "avhkt", "avfkn", "avPacket", "avhacket", "AVcpacket", "avlpacket", "avlputo", "avfke", "avpbuto", "AVfacket", "avpke", "avPke", "AVPkt", "avlpkt", "AVputo", "avcpkn", "avfct", "AVfke", "AVpkn", "avhct", "avpkn", "avpbke", "avspkt", "avhke", "AVpke", "avcpacket", "avcpkt", "AVcpct", "AVPke", "avputo", "avspkn", "avspct", "avPct", "avpacket", "avPuto", "AVpct", "avpbacket", "avfkt", "avspacket", "avpbkt", "AVcpkt", "avpct", "AVcpkn", "avfacket", "avcpct", "AVPacket", "AVfkt", "AVpkt"], "buf": ["seq", "uf", "bag", "uc", "b", "batch", "wb", "c", "cv", "grab", "vec", "buffer", "queue", "img", "rb", "config", "br", "ab", "cur", "prop", "cb", "back", "bc", "port", "front", "num", "bp", "pad", "mem", "home", "ff", "cmd", "padding", "pb", "cap", "loc", "box", "pool", "cp", "fb", "cf", "rc", "alloc", "cache", "feat", "conv", "cas", "length", "buff", "array", "h", "f", "src", "fp", "v", "pack", "block", "large"], "ctx": ["exec", "txt", "remote", "pa", "cm", "np", "cca", "communication", "anc", "c", "pkg", "context", "cv", "qa", "xc", "media", "sq", "config", "component", "jp", "support", "cb", "aka", "bc", "concept", "sync", "cmp", "wx", "fc", "chan", "hw", "cmd", "vc", "loc", "lib", "fw", "cli", "parent", "cc", "cp", "ci", "cf", "cn", "client", "rc", "co", "cas", "git", "lc", "wp", "ctrl", "ca", "cu", "conn", "fp", "ha", "ck", "nc", "tx", "connection", "cam"], "sub": ["summary", "seq", "sc", "section", "uc", "app", "name", "sam", "job", "text", "config", "pub", "ch", "form", "rec", "sp", "path", "pl", "sec", "ub", "sup", "part", "child", "reg", "Sub", "meta", "desc"], "p": ["pp", "pa", "np", "page", "b", "pt", "c", "m", "parser", "d", "x", "api", "P", "py", "jp", "pe", "up", "ps", "dp", "bp", "port", "op", "proc", "u", "mp", "e", "point", "sp", "patch", "o", "pb", "s", "at", "per", "pl", "parent", "cp", "client", "wp", "h", "part", "lp", "f", "po", "y", "pr", "n", "tp", "j", "t", "a", "fp", "q", "ip", "v", "r", "pi", "pre", "pos", "vp", "l", "post", "pc", "ap", "g"], "p_end": ["p_get", "p___en", "p___end", "data_ident", "data_end", "p_post", "dataIPoffset", "P__ends", "dataIPend", "p_range", "lp___end", "P__start", "lp_range", "p___post", "p_ident", "p_offset", "lp___en", "lp_id", "lp___id", "p_center", "p_en", "ap_ending", "p___range", "pixcenter", "P__get", "p_ends", "p__end", "pixend", "p__ends", "P_ends", "dataIPpost", "P_get", "p___id", "p__get", "p_ending", "P_end", "pIPoffset", "P__end", "ap_begin", "pIPpost", "ap_end", "pIPend", "p_begin", "pIPident", "data_post", "lp_end", "p_start", "pixbegin", "data_offset", "P_start", "dataIPident", "lp_en", "p___ident", "ap_center", "p___offset", "p__start", "p_id", "lp___range", "pixending"], "segment_type": ["segment_name", "segment_id", "sement_style", "segment_style", "sement_id", "sement_name", "sement_type", "sement_length"], "page_id": ["page___type", "section_id", "page___id", " page_uri", " page_sid", "page_pad", "page_iden", " page_iden", "page___no", " page_no", " page_num", "page_uri", "section_iden", "page_case", "pageOiden", "page_num", "page_sid", "section_ids", "section_case", "pageOid", " page_type", "page___num", "page_ids", "page_type", " page_pad", "pageOpad", "page_no", "pageOtype"], "segment_length": ["asedata", "segments_end", "ase\n", "segmentityend", "pedata", "aseend", "segment_len", "segmentalltype", "segment_number", "segment_base", "peend", "sement_id", "segment_size", "pe\n", "segment_count", " sedata", "segmentalltext", "segmentlenlen", "sement_len", "sement_base", "sement_text", "segmentitynumber", "sement_end", "sement_length", "sedata", "segments_size", "segmentaltype", "segment_id", "segmentalend", "se\n", "segments_type", "segmentaltext", "segmentlenid", " se\n", "segments_number", "sement_type", " seend", "segmentlenlength", "segments_count", "segmentitytype", "segmentallength", "segmentitylength", "segmentalllength", "segments_length", "seend", "segment_end", "segment_text", "segmentlenbase", "segmentallend"], "i": ["yi", "b", "m", "c", "info", "d", "x", "api", "adi", "ti", "mi", "phi", "qi", "end", "ri", "id", "io", "ui", "u", "e", "li", "gi", "o", "zi", "multi", "s", "start", "xi", "uri", "ii", "bi", "si", "ai", "di", "ini", "ci", "fi", "eni", "vi", "lc", "f", "I", "mini", "oi", "n", "ip", "j", "t", "a", "index", "v", "iu", "r", "pi", "mu", "l", "hi"]}}
{"project": "qemu", "commit_id": "03e6e5017757645f00b2f3b4f3a257973985e455", "target": 0, "func": "void cpu_state_reset(CPUMIPSState *env)\n\n{\n\n    if (qemu_loglevel_mask(CPU_LOG_RESET)) {\n\n        qemu_log(\"CPU Reset (CPU %d)\\n\", env->cpu_index);\n\n        log_cpu_state(env, 0);\n\n    }\n\n\n\n    memset(env, 0, offsetof(CPUMIPSState, breakpoints));\n\n    tlb_flush(env, 1);\n\n\n\n    /* Reset registers to their default values */\n\n    env->CP0_PRid = env->cpu_model->CP0_PRid;\n\n    env->CP0_Config0 = env->cpu_model->CP0_Config0;\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    env->CP0_Config0 |= (1 << CP0C0_BE);\n\n#endif\n\n    env->CP0_Config1 = env->cpu_model->CP0_Config1;\n\n    env->CP0_Config2 = env->cpu_model->CP0_Config2;\n\n    env->CP0_Config3 = env->cpu_model->CP0_Config3;\n\n    env->CP0_Config6 = env->cpu_model->CP0_Config6;\n\n    env->CP0_Config7 = env->cpu_model->CP0_Config7;\n\n    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask\n\n                                 << env->cpu_model->CP0_LLAddr_shift;\n\n    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;\n\n    env->SYNCI_Step = env->cpu_model->SYNCI_Step;\n\n    env->CCRes = env->cpu_model->CCRes;\n\n    env->CP0_Status_rw_bitmask = env->cpu_model->CP0_Status_rw_bitmask;\n\n    env->CP0_TCStatus_rw_bitmask = env->cpu_model->CP0_TCStatus_rw_bitmask;\n\n    env->CP0_SRSCtl = env->cpu_model->CP0_SRSCtl;\n\n    env->current_tc = 0;\n\n    env->SEGBITS = env->cpu_model->SEGBITS;\n\n    env->SEGMask = (target_ulong)((1ULL << env->cpu_model->SEGBITS) - 1);\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->SEGMask |= 3ULL << 62;\n\n    }\n\n#endif\n\n    env->PABITS = env->cpu_model->PABITS;\n\n    env->PAMask = (target_ulong)((1ULL << env->cpu_model->PABITS) - 1);\n\n    env->CP0_SRSConf0_rw_bitmask = env->cpu_model->CP0_SRSConf0_rw_bitmask;\n\n    env->CP0_SRSConf0 = env->cpu_model->CP0_SRSConf0;\n\n    env->CP0_SRSConf1_rw_bitmask = env->cpu_model->CP0_SRSConf1_rw_bitmask;\n\n    env->CP0_SRSConf1 = env->cpu_model->CP0_SRSConf1;\n\n    env->CP0_SRSConf2_rw_bitmask = env->cpu_model->CP0_SRSConf2_rw_bitmask;\n\n    env->CP0_SRSConf2 = env->cpu_model->CP0_SRSConf2;\n\n    env->CP0_SRSConf3_rw_bitmask = env->cpu_model->CP0_SRSConf3_rw_bitmask;\n\n    env->CP0_SRSConf3 = env->cpu_model->CP0_SRSConf3;\n\n    env->CP0_SRSConf4_rw_bitmask = env->cpu_model->CP0_SRSConf4_rw_bitmask;\n\n    env->CP0_SRSConf4 = env->cpu_model->CP0_SRSConf4;\n\n    env->active_fpu.fcr0 = env->cpu_model->CP1_fcr0;\n\n    env->insn_flags = env->cpu_model->insn_flags;\n\n\n\n#if defined(CONFIG_USER_ONLY)\n\n    env->hflags = MIPS_HFLAG_UM;\n\n    /* Enable access to the CPUNum, SYNCI_Step, CC, and CCRes RDHWR\n\n       hardware registers.  */\n\n    env->CP0_HWREna |= 0x0000000F;\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        env->hflags |= MIPS_HFLAG_FPU;\n\n    }\n\n#ifdef TARGET_MIPS64\n\n    if (env->active_fpu.fcr0 & (1 << FCR0_F64)) {\n\n        env->hflags |= MIPS_HFLAG_F64;\n\n    }\n\n#endif\n\n#else\n\n    if (env->hflags & MIPS_HFLAG_BMASK) {\n\n        /* If the exception was raised from a delay slot,\n\n           come back to the jump.  */\n\n        env->CP0_ErrorEPC = env->active_tc.PC - 4;\n\n    } else {\n\n        env->CP0_ErrorEPC = env->active_tc.PC;\n\n    }\n\n    env->active_tc.PC = (int32_t)0xBFC00000;\n\n    env->CP0_Random = env->tlb->nb_tlb - 1;\n\n    env->tlb->tlb_in_use = env->tlb->nb_tlb;\n\n    env->CP0_Wired = 0;\n\n    env->CP0_EBase = 0x80000000 | (env->cpu_index & 0x3FF);\n\n    env->CP0_Status = (1 << CP0St_BEV) | (1 << CP0St_ERL);\n\n    /* vectored interrupts not implemented, timer on int 7,\n\n       no performance counters. */\n\n    env->CP0_IntCtl = 0xe0000000;\n\n    {\n\n        int i;\n\n\n\n        for (i = 0; i < 7; i++) {\n\n            env->CP0_WatchLo[i] = 0;\n\n            env->CP0_WatchHi[i] = 0x80000000;\n\n        }\n\n        env->CP0_WatchLo[7] = 0;\n\n        env->CP0_WatchHi[7] = 0;\n\n    }\n\n    /* Count register increments in debug mode, EJTAG version 1 */\n\n    env->CP0_Debug = (1 << CP0DB_CNT) | (0x1 << CP0DB_VER);\n\n    env->hflags = MIPS_HFLAG_CP0;\n\n\n\n    if (env->CP0_Config3 & (1 << CP0C3_MT)) {\n\n        int i;\n\n\n\n        /* Only TC0 on VPE 0 starts as active.  */\n\n        for (i = 0; i < ARRAY_SIZE(env->tcs); i++) {\n\n            env->tcs[i].CP0_TCBind = env->cpu_index << CP0TCBd_CurVPE;\n\n            env->tcs[i].CP0_TCHalt = 1;\n\n        }\n\n        env->active_tc.CP0_TCHalt = 1;\n\n        env->halted = 1;\n\n\n\n        if (!env->cpu_index) {\n\n            /* VPE0 starts up enabled.  */\n\n            env->mvp->CP0_MVPControl |= (1 << CP0MVPCo_EVP);\n\n            env->CP0_VPEConf0 |= (1 << CP0VPEC0_MVP) | (1 << CP0VPEC0_VPA);\n\n\n\n            /* TC0 starts up unhalted.  */\n\n            env->halted = 0;\n\n            env->active_tc.CP0_TCHalt = 0;\n\n            env->tcs[0].CP0_TCHalt = 0;\n\n            /* With thread 0 active.  */\n\n            env->active_tc.CP0_TCStatus = (1 << CP0TCSt_A);\n\n            env->tcs[0].CP0_TCStatus = (1 << CP0TCSt_A);\n\n        }\n\n    }\n\n#endif\n\n#if defined(TARGET_MIPS64)\n\n    if (env->cpu_model->insn_flags & ISA_MIPS3) {\n\n        env->hflags |= MIPS_HFLAG_64;\n\n    }\n\n#endif\n\n    env->exception_index = EXCP_NONE;\n\n}\n", "idx": 21427, "substitutes": {"env": ["inv", "gear", "app", "config", "event", "eni", "extra", "pos", "exc", "fg", "ini", "data", "que", "context", "header", " environments", "cdn", "iter", "global", "v", "conf", "ev", "inet", "output", "this", "emb", "org", "end", "conn", "db", "cv", "ench", "oa", "eng", "qv", "site", "ah", "dev", "vel", "enc", "assets", "code", "ext", "self", "et", "equ", " environment", "rev", "ass", " en", "NV", "fen", "qt", "erv", "net", "example", "e", "err", "eu", "token", "img", "ea", "exec", "init", "agen", "her", "Environment", "el", "module", "edge", "enable", "dt", "gui", "core", "er", "req", "stage", "dat", "manager", "h", "ec", "ne", "en", "obj", "inc", "engine", "export", "esi", "nc", "args", "cache", "vs", "dict", "np", "py", "client", "En", "het", "viron", "session", "console", " Environment", "vm", "server", "environment", "here"]}}
{"project": "FFmpeg", "commit_id": "50c466d609ec60a324a7a776dfdb57c8d38faa11", "target": 1, "func": "static av_cold int g726_encode_init(AVCodecContext *avctx)\n\n{\n\n    G726Context* c = avctx->priv_data;\n\n\n\n    if (avctx->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL &&\n\n        avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Sample rates other than 8kHz are not \"\n\n               \"allowed when the compliance level is higher than unofficial. \"\n\n               \"Resample or reduce the compliance level.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if (avctx->sample_rate <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Samplerate is invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono is supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (avctx->bit_rate % avctx->sample_rate) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitrate - Samplerate combination is invalid\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;\n\n    if (c->code_size < 2 || c->code_size > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of bits %d\\n\", c->code_size);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    avctx->bits_per_coded_sample = c->code_size;\n\n\n\n    g726_reset(c, c->code_size - 2);\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n    avctx->coded_frame->key_frame = 1;\n\n\n\n    /* select a frame size that will end on a byte boundary and have a size of\n\n       approximately 1024 bytes */\n\n    avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2];\n\n\n\n    return 0;\n\n}\n", "idx": 14141, "substitutes": {"avctx": ["ajloc", " avscope", "avctr", "avlc", "avsci", "aflc", "aklc", "afconfig", "vercf", "avcu", " avcontext", "avecmp", "avecoll", "avecli", "avecontext", "avconfig", "avcp", "afconn", "vercit", "aupkg", "aucontext", "ajcontext", "vercp", "afcf", "afcit", " avconfig", "AVcontext", "avectx", "afctr", "verloc", "avcli", "afcu", "AVcoll", "AVconn", "AVlc", "averctx", "afcontext", "avcoll", "ajcit", "akctx", "avconn", "avloc", "avectrl", "ajcmp", " avcu", "avctrl", "akcontext", "afsci", "avscope", "avecm", " avctr", "ajcli", "avcm", " avpkg", "avcf", "ajsci", "avecu", "vercontext", "auctr", " avcm", "averconn", "avecit", "akcf", "vercli", "ajctx", "aveconfig", "aveloc", " avcli", "afloc", "verctx", "avecf", "afctx", "ajcf", "afcoll", "afcli", "avcca", "afcca", "afpkg", "ajcp", " avsci", "AVcmp", "averctrl", "avcmp", "avescope", "avercca", "avcit", "avelc", "AVcu", "afcmp", "afcp", "verconn", "auctx", "afcm", "avcontext", "avercit", "aveconn", "afscope", " avconn", "AVctx", "avpkg", "afctrl", "verlc", "vercca", "avercontext"], "c": ["context", "ch", "mc", "cm", "m", "uc", "d", "ca", "enc", "t", "unc", "config", "cc", "l", "code", "i", "pc", "C", "a", "gc", "g", "cs", "ctrl", "lc", "ci", "h", "cy", "cmp", "con", "ct", "v", "conn", "cr", "w", "col", "u", "oc", "p", "e", "s", "sec", "nc", "k", "b", "co", "tc", "n", "f", "arc", "cu", "dc", "ac", "anc", "sc", "ce", "cf", "ic", "coll", "cp", "exec", "vc", "xc", "cache", "ec", "cur", "fc", "cl", "ctx"]}}
{"project": "FFmpeg", "commit_id": "934fe00680a1139cbc0950641655af5923dd7763", "target": 0, "func": "static int opt_input_file(OptionsContext *o, const char *opt, const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret;\n\n    int64_t timestamp;\n\n    uint8_t buf[128];\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n\n\n\n    if (o->format) {\n\n        if (!(file_iformat = av_find_input_format(o->format))) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Unknown input format: '%s'\\n\", o->format);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        exit_program(1);\n\n    }\n\n    if (o->nb_audio_sample_rate) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_sample_rate[o->nb_audio_sample_rate - 1].u.i);\n\n        av_dict_set(&format_opts, \"sample_rate\", buf, 0);\n\n    }\n\n    if (o->nb_audio_channels) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_channels[o->nb_audio_channels - 1].u.i);\n\n        av_dict_set(&format_opts, \"channels\", buf, 0);\n\n    }\n\n    if (o->nb_frame_rates) {\n\n        av_dict_set(&format_opts, \"framerate\", o->frame_rates[o->nb_frame_rates - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_sizes) {\n\n        av_dict_set(&format_opts, \"video_size\", o->frame_sizes[o->nb_frame_sizes - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_pix_fmts)\n\n        av_dict_set(&format_opts, \"pixel_format\", o->frame_pix_fmts[o->nb_frame_pix_fmts - 1].u.str, 0);\n\n\n\n    ic->video_codec_id   = video_codec_name ?\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0)->id : CODEC_ID_NONE;\n\n    ic->audio_codec_id   = audio_codec_name ?\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0)->id : CODEC_ID_NONE;\n\n    ic->subtitle_codec_id= subtitle_codec_name ?\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0)->id : CODEC_ID_NONE;\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n    ic->interrupt_callback = int_cb;\n\n\n\n    if (loop_input) {\n\n        av_log(NULL, AV_LOG_WARNING, \"-loop_input is deprecated, use -loop 1\\n\");\n\n        ic->loop_input = loop_input;\n\n    }\n\n\n\n    /* open the input file with generic avformat function */\n\n    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        exit_program(1);\n\n    }\n\n    assert_avoptions(format_opts);\n\n\n\n    /* apply forced codec ids */\n\n    for (i = 0; i < ic->nb_streams; i++)\n\n        choose_decoder(o, ic, ic->streams[i]);\n\n\n\n    /* Set AVCodecContext options for avformat_find_stream_info */\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = avformat_find_stream_info(ic, opts);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        exit_program(1);\n\n    }\n\n\n\n    timestamp = o->start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (o->start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_WARNING, \"%s: could not seek to position %0.3f\\n\",\n\n                   filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    add_input_streams(o, ic);\n\n\n\n    /* dump the file content */\n\n    av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = o->input_ts_offset - (copy_ts ? 0 : timestamp);\n\n    input_files[nb_input_files - 1].nb_streams = ic->nb_streams;\n\n    input_files[nb_input_files - 1].rate_emu   = o->rate_emu;\n\n\n\n    for (i = 0; i < o->nb_dump_attachment; i++) {\n\n        int j;\n\n\n\n        for (j = 0; j < ic->nb_streams; j++) {\n\n            AVStream *st = ic->streams[j];\n\n\n\n            if (check_stream_specifier(ic, st, o->dump_attachment[i].specifier) == 1)\n\n                dump_attachment(st, o->dump_attachment[i].u.str);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    reset_options(o, 1);\n\n    return 0;\n\n}\n", "idx": 22459, "substitutes": {"o": ["io", "e", "ow", "oo", "O", "object", "off", "oe", "obj", "ao", "oa", "ol", "ou", "so", "node", "no", "f", "ro", "po", "op", "t", "oi", "u", "m", "wo", "original", "mo", "custom", "one", "ob", "os", "oc", "p", "od", "ant", "c", "lo", "module", "oid", "ocr", "go", "fo", "bo", "ov", "online", "to", "n", "co", "iso", "ot", "ko", "http", "from", "image", "l", "k", "ilo", "vo"], "opt": ["io", "obj", "config", "option", "text", "Opt", "rec", "path", "op", "alloc", "cmd", "info", "cat", "enc", "open", "timeout", "ctx", "Option", "w", "loc", "options", "root", "proc", "fn", "oc", "attr", "url"], "filename": ["name", "txt", "binary", "download", "il", "utf", "file", "fb", "phrase", "microsoft", "fax", "json", "lua", "uri", "ln", "png", "fp", "f", "path", "login", "msg", "nil", "wl", "kl", "prefix", "directory", "subject", "which", "sheet", "timeout", "println", "kn", "nuclear", "title", "source", "document", "ename", "location", "src", "fd", "length", "wav", "dll", "jpg", "sf", "tty", "bf", "fil", "fn", "username", "files", "l", "Filename", "url"], "ic": ["lc", "bc", "fc", "ik", "ig", "fi", "ici", "ican", "ct", "nic", "IC", "aci", "aic", "pc", "mic", "anc", "ci", "isc", "ac", "ico", "mc", "xc", "pic", "tc", "ant", "au", "c", "ctx", "icc", "iac", "cy", "cci", "ics", "gc", "ai", "xi", "ec", "icer", "cit", "voc", "oc", "lic", "cu", "acs", "vc"], "file_iformat": ["file_iformart", "file_iolac", "file_iformant", "file_iolant", "file_iplac", "file_iformata", "file__iformat", "file_isolat", "file__iformac", "file_isolata", "file_iliart", "file_iplat", "file_iformt", "file__iolt", "file_iddant", "file_iddac", "file__iformt", "file_iolata", "file_iliat", "file_isolit", "file_iddt", "file_isolart", "file_iolart", "file_iformit", "file_iolit", "file_iplt", "file__iformant", "file__iolac", "file_iliata", "file_iddat", "file_iformac", "file__iolant", "file_iliit", "file_iplant", "file__iolat", "file_iolt", "file_iolat"], "err": ["status", " typ", " error", " aux", " pri", "result", "rr", " resp", " len", " fe", "res", "stat", "id", " seq", "var", "rc", "out", "cb", " rc", "seq", "error", "fd", "len", "req", "nt", "h", "resp", "fun"], "i": ["io", "ix", "e", "ind", "ui", "d", "ti", "I", "l", "f", "ci", "t", "info", "u", "ini", "m", "it", "r", "s", "ip", "p", "id", "is", "mi", "c", "index", "si", "ii", "b", "n", "iu", "ai", "v", "z", "li", "h", "pi", "x", "zi", "k", "ni", "count"], "ret": ["status", "bc", "en", "result", "val", "wa", "Ret", "no", "buffer", "res", "cat", "rc", "cb", "aux", "RET", "rt", "mem", "flag", "seq", "len", "back", "alt", "ry", "nt", "fi"], "timestamp": ["frametime", "microoffset", "framestamp", "framest", "microestamp", "framoffset", "timest", "imoffset", "imestamp", "timoffset", "microetime", "microest", "timetime", "imest", "imetime"], "buf": ["begin", "bc", "config", "buffer", "alloc", "msg", "bg", "data", "context", "wb", "pool", "header", "font", "la", "mem", "window", "bo", "ff", "src", "br", "bd", "batch", "wx", "doc", "proc", "rb", "fam", "feat", "output", "cap", "str", "uf", "text", "cv", "null", "fp", "ucc", "bed", "rc", "cb", "desc", "bh", "bag", "vec", "conv", "uc", "ref", "fb", "queue", "func", "bytes", "bin", "Buff", "img", "f", "box", "bn", "byte", "b", "tmp", "usr", "fd", "loc", "buff", "bf", "pb", "port", "cur", "ctx", "aux", "seq", "auc", "block", "url"], "opts": [" opttr", " opttes", "operts", "optes", "opertr", "opfs", " opfs", " optes", " optts", "opertes", " optfs", "optr", " optr", "operfs"], "orig_nb_streams": [" orig_nb_streamries", " orig_nb_roundd", " orig_nb_threadd", " orig_nb_inputries", " orig_nb_roundries", " orig_nb_threadries", " orig_nb_inputd", " orig_nb_rounding", " orig_nb_inputing", " orig_nb_inputs", " orig_nb_threading", " orig_nb_rounds", " orig_nb_streaming", " orig_nb_streamd", " orig_nb_threads"]}}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,\n\n                        void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);\n\n            if (se->compat) {\n\n                g_free(se->compat);\n\n            }\n\n            g_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 17267, "substitutes": {"dev": ["Dev", "dd", "mod", "ch", "tr", "gd", "conf", "pub", "reg", "debug", "de", "pack", "def", "der", "enc", "ev", "ad", "serv", "private", "device", "trans", "od", "proc", "pro", "gr", "ver"], "vmsd": ["vnsD", " vnsD", "vcsd", " vmsdt", " vmsdy", "lmsds", "vmesdt", "vmsds", "vMSdt", "vcsdn", "vMSdn", "vmesd", " vnsdt", "vMSdl", "vmesD", "vMSdy", "vmsdl", "vimsdl", " vnsd", "vmesdn", " vnsdd", "vmsD", "vmsdt", " vmsdl", "vMSdd", "vMSd", "vimsdy", "vmesdx", "vmesdd", "lmesd", "lmesdx", "vMSde", "vmsdy", "vmmde", "vnsdd", " vmsdd", "lmsdx", "vcsds", "vmsdx", " vimsde", "vmsdd", "vcsdx", "lmesds", "vnsd", " vimsdl", " vimsd", "vmmdl", "vMSdx", "lmsdn", "vmsde", "vMSD", "vMSds", " vimsdy", "vmmd", "vimsd", "vmsdn", "vmesds", " vmsde", "vnsdt", "lmesdn", " vmsD", "vmmdy", "vimsde", "lmsd"], "opaque": ["ompula", "copacity", "oppity", "operacity", "opity", "oppac", "copaque", " opacity", "compaque", "oppacity", "opac", "efficit", "opacity", "copula", " opac", "oppaque", "effaque", "operaque", "operity", "effaques", "operula", "effacity", "opula", " opity", "compaques", "compicit", "opicit", "operac", "opaques", "ompac", "operaques", "ompaque", "opericit", "copac", "ompacity", "compacity"], "se": ["entry", "per", "session", "s", "ede", "so", "sp", "ste", "ne", "pe", "de", "see", "sl", "SE", "ge", "isse", "as", "ie", "sel", "sem", "lex", "sea", "te", "sec", "sd", "ae", "ze", "sk", "su", "parse", "ce", "le", "seed", "sed", "use", "pse", "cel", "e", "ses", "Se", "sle", "be", "si", "ade", "cle", "sche", "ke", "ace", "es", "ser", "ase", "ve", "sa"], "new_se": ["new_parse", "new_entry", "newfparse", "new_sem", " new_sem", "newfentry", " new_parse", "newfSE", " new_entry", "newfse", "new_SE", " new_SE"]}}
{"project": "FFmpeg", "commit_id": "5d7e3d71673d64a16b58430a0027afadb6b3a54e", "target": 1, "func": "static int seqvideo_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    SeqVideoContext *seq = avctx->priv_data;\n\n\n\n    seq->frame.reference = 1;\n\n    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &seq->frame)) {\n\n        av_log(seq->avctx, AV_LOG_ERROR, \"tiertexseqvideo: reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    seqvideo_decode(seq, buf, buf_size);\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = seq->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 20422, "substitutes": {"avctx": ["abcmp", "aveca", "ajbc", "apcmp", "apctx", "AVcmp", "afca", "apcontext", "avcit", "ajcontext", "avsc", "afcmp", " avcit", "afclient", "aucontext", "afctx", "AVcontext", "avecmp", " avsc", "AVca", "avcas", " avbc", "avca", "afcas", "AVclient", "avecontext", "afcu", "avbc", "ajcas", "avcontext", "avcu", "abctx", "afbc", "afsc", "avclient", " avcas", "abcu", "avecit", "avectx", "afcit", "avcmp", "abcontext", "afcontext", "AVctx", "ajctx", "auctx", " avcontext", "apcu", "auclient", "aucmp", "avesc"], "data": ["uf", "start", "def", "response", "obj", "config", "result", "input", "val", "progress", "message", "Data", "meta", "queue", "func", "bytes", "f", "buffer", "ata", "info", "address", "size", "cache", "code", "body", "load", "record", "memory", "la", "frame", "source", "DATA", "read", "media", "reader", "slice", "flow", "len", "length", "feed", "batch", "buff", "parent", "dat", "vec", "li", "image", "block", "base", "video"], "data_size": ["data\u00b7scale", "data\u00b7size", "data_scale", "data_small", "data_fee", "batch_source", "batch_size", "batch_time", " data_scale", "data_source", "data\u00b7fee", "data_time", " data_fee", "batch_small"], "avpkt": ["avPct", "avlpkt", "avpeft", "abpconn", "abfacket", "abpkn", "avvpkn", "avppka", "afPacket", "avlpacket", "avfpft", "afpka", "avfpctx", "avppkt", " avpecht", "abfkn", " avpcht", "avfka", "avpka", "avpconn", "avlpconn", "abpacket", "avPacket", "avfkt", " avpectx", "afPct", "avlpcht", "avpcht", " avpeft", "avpecht", "abpkt", "avlpft", "abfkt", " avpft", "avpekt", "avfct", " avpekt", "avpft", "afPka", "avfacket", "avpct", "avlpctx", "avfconn", "avpectx", "afpct", "avppacket", "avfkn", "avvpkt", "avppct", "afpkt", "avlpkn", "afPkt", "avvpacket", "avfpcht", "avpkn", "avvpconn", "avpctx", " avpctx", "avPka", "avpacket", "avPkt", "avfpkt", "abfconn", "afpacket"], "buf": ["bc", "pb", "uf", "uc", "ref", "config", "val", "fb", "queue", "bb", "pad", "img", "cas", "f", "buffer", "alloc", "cache", "cf", "wb", "pool", "la", "cb", "rc", "b", "fd", "flow", "br", "batch", "buff", "proc", "array", "vec", "bag", "rb", "block", "base", "feat", "cap"], "seq": ["lc", "bc", "cc", "sel", "uc", "sci", "jp", "config", "ref", "coll", "val", "xxx", "pkg", "cv", "lex", "clus", "queue", "wave", "cl", "sequ", "cas", "cmp", "exec", "acc", "cmd", "sequence", "cache", "zip", "job", "ctrl", "que", "context", "q", "code", "cli", "la", "pse", "ctx", "frame", "aux", "comp", "sub", "rev", "qa", "slice", "iq", "req", "iter", "feed", "sem", "buff", "select", "ec", "sec", "vec", "fam", "fi", "feat", "sq"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)\n\n{\n\n    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);\n\n    s->freq = PXA25X_FREQ;\n\n    s->tm4 = NULL;\n\n}\n", "idx": 5646, "substitutes": {"base": ["bas", "address", "kit", "name", "area", "builder", "id", "scope", "b", "ada", "i", "home", "info", "ace", "f", "server", "py", "buffer", "e", "proxy", "target", "ase", "source", "p", "temp", "scale", "Base", "frame", "gb", "start", "c", "ip", "type", "site", "ases", "addr", "prefix"], "irqs": ["rinqs", "mirqs", "IRqs", "mirviews", "mirq", "mirfs", "irks", "irquest", "rinviews", "ireq", "irq", "irfs", "mirks", "ireqs", "IRquest", " irks", " irquest", "IRq", "IRks", "rinfs", "irviews", "irefs", "ireviews", "rinq", "mirquest", " irq"], "s": ["options", "r", "o", "sf", "v", "S", "spec", "session", "b", "si", "i", "sync", "m", "f", "ns", "d", "server", "service", "ss", "conf", "u", "e", "an", "sb", "w", "secondary", "ds", "t", "n", "ts", "p", "array", "span", "settings", "z", "fs", "c", "g", "ssl", "sym", "sq", "js"]}}
{"project": "FFmpeg", "commit_id": "b1306823d0b3ae998c8e10ad832004eb13bdd93e", "target": 0, "func": "static int write_option(void *optctx, const OptionDef *po, const char *opt,\n\n                        const char *arg)\n\n{\n\n    /* new-style options contain an offset into optctx, old-style address of\n\n     * a global var*/\n\n    void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ?\n\n                (uint8_t *)optctx + po->u.off : po->u.dst_ptr;\n\n    int *dstcount;\n\n\n\n    if (po->flags & OPT_SPEC) {\n\n        SpecifierOpt **so = dst;\n\n        char *p = strchr(opt, ':');\n\n\n\n        dstcount = (int *)(so + 1);\n\n        *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1);\n\n        (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : \"\");\n\n        dst = &(*so)[*dstcount - 1].u;\n\n    }\n\n\n\n    if (po->flags & OPT_STRING) {\n\n        char *str;\n\n        str = av_strdup(arg);\n\n        av_freep(dst);\n\n        *(char **)dst = str;\n\n    } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) {\n\n        *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);\n\n    } else if (po->flags & OPT_INT64) {\n\n        *(int64_t *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT64_MIN, INT64_MAX);\n\n    } else if (po->flags & OPT_TIME) {\n\n        *(int64_t *)dst = parse_time_or_die(opt, arg, 1);\n\n    } else if (po->flags & OPT_FLOAT) {\n\n        *(float *)dst = parse_number_or_die(opt, arg, OPT_FLOAT, -INFINITY, INFINITY);\n\n    } else if (po->flags & OPT_DOUBLE) {\n\n        *(double *)dst = parse_number_or_die(opt, arg, OPT_DOUBLE, -INFINITY, INFINITY);\n\n    } else if (po->u.func_arg) {\n\n        int ret = po->u.func_arg(optctx, opt, arg);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_ERROR,\n\n                   \"Failed to set value '%s' for option '%s'\\n\", arg, opt);\n\n            return ret;\n\n        }\n\n    }\n\n    if (po->flags & OPT_EXIT)\n\n        exit_program(0);\n\n\n\n    return 0;\n\n}\n", "idx": 8425, "substitutes": {"optctx": [" optcf", " optcfg", "opctx", "optlib", " optcontext", "optionctx", "oplib", "optionbuf", "usrcfg", "optcontext", "opbuf", "optionlib", "optbuf", "optcfg", " optbuf", "usrctx", "usrcf", " optlib", "optcf", "usrcontext", "optioncf", "opcontext", "optioncfg", "optioncontext"], "po": ["va", "co", "ppa", "ta", "fo", "da", "O", "no", "aco", "bp", "to", "go", "ono", "oo", "pa", "pp", "poke", "oe", "post", "elo", "obj", "ote", "pd", "pro", "oto", "pb", "pe", "np", "bo", "cro", "gro", "cho", "op", "o", "Po", "mp", "oa", "py", "oda", "ppo", "zone", "ako", "plate", "pr", "vo", "PO", "pre", "jp", "tp", "pi", "pc", "ao", "mo", "apo", "obo", "pos", "flo", "lo", "ko", "yo"], "opt": ["sp", "Opt", "timeout", "fo", "ext", "alt", "ord", "prefix", "info", "go", "prot", "open", "pl", "tag", "path", "iv", "stat", "feat", "config", "obj", "optim", "dest", "attr", "lit", "usr", "off", "loc", "prop", "cho", "op", "dr", "o", "oss", "name", "aut", "sl", "pr", "neg", "err", "option", "sn", "cl", "spec", "orig", "init", "fn", "cat", "pos", "options", "ret", "text", "inf", "pot", "proc", "expr", "crit", "ok", "lo"], "arg": ["mac", "arc", "gen", "arr", "param", "argument", "flag", "g", "val", "ax", "all", "go", "tag", "path", "ang", "num", "doc", "ad", "other", "var", "config", "util", "target", "reg", "star", "ag", "or", "args", "loc", "op", "ac", "dr", "next", "none", "call", "parse", "inc", "ig", "name", "ar", "r", "neg", "err", "option", "enc", "as", "cat", "ret", "use", "image", "Arg", "par", "help", "inter", "any"], "dst": ["Dstd", "dstal", "ldst", "sdsc", "dsp", "adste", " ddr", "ldST", "dest", "Dsts", "ddr", "sdest", "dedste", "idste", "dST", "eddest", "edsc", "rdST", "DST", "dost", "adest", "nsc", "Dste", "dste", "nST", "dstd", "ldsc", " dST", "idstd", "ddest", "iddest", "insts", " dost", "idsc", "dedst", " ddest", " dsc", "sdrest", "iddr", "drest", " dsp", "inste", "rdst", "nsp", " dstd", "dedsts", " dsts", " dest", "fst", " dstal", "idst", "dsts", " dste", "rdsc", "ldsp", "adst", "dedsc", " drest", "instal", "idsts", "sdsts", "adST", "Dsc", "sdst", "dsc", "edst", "fST", "rdsts", "sdST", "sdost", "inst", "nst", "eddr", "adrest", "Dst", "adsts", "adost", "sdste", "Dstal", "fste", "fsc"], "dstcount": [" dstlimit", "dSTc", "dostCount", "dputCount", "dostid", "dftCount", "dputlast", " dstc", "dputlength", "dstid", "ndstCount", "dSTlength", "ndputlength", "ndputcount", " destlength", " destlast", " dSTsize", "destid", "destlast", " destid", "drestlimit", "dstweight", "dSTweight", "dstlength", "dstlast", "dSTcount", " dputCount", " destCount", "dostc", "dftcount", "destlimit", " dputc", "dstc", "dSTsize", " dputcount", "destCount", "dstsweight", "destcount", " dSTlast", "ndstcount", "dstlimit", "dstscount", "dostlimit", " dSTCount", "destlength", "drestcount", " destlimit", "drestlength", " dstid", "ndputCount", "drestid", "ndstlength", " destcount", "dstslast", "dstCount", " dstweight", "dostcount", " dstCount", "dstsCount", " dSTweight", "dostlength", " dstsize", "dftweight", " dSTcount", "dSTlast", "dstsize", " dstlength", " dstlast", "dSTCount", "dstslength", "dputcount", "dftsize", "dstssize", "dputc"], "so": ["ld", "osa", "zip", "sp", "sh", "co", "le", "pg", "fo", "si", "sf", "go", "to", "osp", "sw", "ly", "ne", "sa", "lo", "s", "obj", "se", "cli", "cu", "bo", "pe", "sq", "st", "os", "sk", "la", "SO", "ie", "cs", "o", "py", "osi", "ce", "asi", "sync", "sl", "sn", "sth", "tp", "ste", "shi", "sm", "oh", "pc", "mo", "li", "px", "ci", "So", "su", "flo", "ski", "sc", "te"], "p": ["lp", "l", "sp", "wp", "pg", "n", "g", "php", "m", "bp", "b", "t", "pa", "d", "i", "pp", "c", "cp", "s", "pb", "e", "fp", "np", "pe", "q", "P", "f", "op", "j", "o", "py", "v", "r", "pr", "pre", "hp", "tp", "jp", "pi", "pc", "u", "h", "api", "vp"], "str": ["cr", "sp", "arr", "tr", "hr", "strings", "Str", "fr", "sw", "kr", "strike", "doc", "data", "s", "STR", "iter", "wr", "style", "stri", "rs", "f", "dr", "bl", "v", "sl", "pr", "r", "err", "spec", "enc", "u", "type", "text", "br", "sr", "sc"]}}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)\n\n{\n\n    VirtIOS390Bus *bus;\n\n    int dev_len;\n\n\n\n    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);\n\n    dev->vdev = vdev;\n\n    dev->dev_offs = bus->dev_offs;\n\n    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */\n\n\n\n    dev_len = VIRTIO_DEV_OFFS_CONFIG;\n\n    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;\n\n    dev_len += dev->feat_len * 2;\n\n    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);\n\n\n\n    bus->dev_offs += dev_len;\n\n\n\n    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,\n\n                                                      dev->host_features);\n\n    s390_virtio_device_sync(dev);\n\n    s390_virtio_reset_idx(dev);\n\n    if (dev->qdev.hotplugged) {\n\n        S390CPU *cpu = s390_cpu_addr2state(0);\n\n        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 21723, "substitutes": {"dev": ["cam", "def", "app", "device", "dist", "info", "nov", "data", "bug", "serial", "var", "dem", "dim", "raw", "gh", "test", "di", "v", "conf", "ev", "pub", "priv", "end", "conn", "valid", "driver", "non", "der", "de", "d", "ad", "mod", "self", "dom", "dc", "md", "err", "f", "model", "exec", "adv", "dd", "p", "comment", "module", "sd", "ver", "dt", "rad", "error", "req", "user", "Dev", "cd", "DEV", "gu", "wd", "cur", "engine", "gd", "diff", "id", "client", "pro", "die", "ch", "w", "debug", "block", "pack", "development", "server"], "vdev": ["qdd", "vdd", "qdevice", "frad", "nvdevice", "Vd", "lrad", "vdiv", "vvdiv", "qdev", "nvdev", "vd", "pdevice", " vd", "pd", "ldd", "nvdd", "fdiv", "vvdev", " vdevice", "pdev", "vdevice", "ddevice", "nvrad", "ddev", "ddiv", "vvrad", "drad", "ldevice", "qrad", "vvdevice", "ldev", "vrad", "fdev", "fdevice", "pdiv", "Vdev", "Vdiv", "Vdevice", " vdiv"], "bus": ["io", "lc", "bc", "class", "def", "obj", "usb", "config", "board", "loop", "mount", "val", "db", "Bus", "bridge", "host", "build", "home", "local", "path", "band", "device", "lab", "dir", "use", "cat", "cache", "bug", "cart", "lock", "os", "us", "sync", "comment", "buf", "plug", "disk", "pl", "pass", "ch", "pull", "b", "hub", "session", "show", "BUS", "feed", "back", "boot", "lib", "http", "conf", "proc", "bs", "user", "nt", "pack", "block", "base", "pub"], "dev_len": ["priv_lin", "ev_val", " dev_Len", "dev5lan", "priv_lon", "dev64len", "dev_base", "ev_la", "dev_lan", "ev_lon", "dev64lim", "dev64lon", "dev_la", "av_lon", "devenfin", "devenlin", "priv7len", "dev6lin", "dev6fin", "ev_base", "patch_label", "av_lit", "dev_lon", "ev_len", "patch_lin", "priv7lin", "patch_len", "patchenlabel", "dev_lin", "dev_lit", " dev_length", "av_len", "patchenlin", "devenlen", "dev5lon", "dev6label", "dev64lit", "ev_den", "patch_fin", "dev_fin", "patchenfin", "priv_lan", "dev7lin", "priv7lon", "dev_den", "dev7lan", "dev7lon", " dev_val", "dev_Len", "dev_label", "av_lim", "dev7len", "priv7lan", "priv_len", "dev_length", "devenlabel", "dev5len", "dev5lin", "dev_val", "dev6len", "patchenlen", "dev_lim"], "cpu": ["platform", "computer", "bench", "net", "gpu", "linux", "GPU", "performance", "pkg", "consumer", "rpm", "processor", "process", "pc", "CPU", "node", "device", "css", "cp", "fps", "cache", "component", "machine", "np", "disk", "pool", "px", "cn", "gp", "pid", "mem", "loader", "chip", "xi", "proc", "vm", " CPU", "clock", "sta", "pu", "ilo"]}}
{"project": "qemu", "commit_id": "2e061a7c86d77c599676d89c3461f8efe9c275b1", "target": 0, "func": "static void do_info_commands(Monitor *mon, QObject **ret_data)\n\n{\n\n    QList *cmd_list;\n\n    const mon_cmd_t *cmd;\n\n\n\n    cmd_list = qlist_new();\n\n\n\n    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&\n\n            !compare_cmd(cmd->name, \"info\")) {\n\n            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));\n\n        }\n\n    }\n\n\n\n    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {\n\n            char buf[128];\n\n            snprintf(buf, sizeof(buf), \"query-%s\", cmd->name);\n\n            qlist_append_obj(cmd_list, get_cmd_dict(buf));\n\n        }\n\n    }\n\n\n\n    *ret_data = QOBJECT(cmd_list);\n\n}\n", "idx": 12624, "substitutes": {"mon": ["bin", "mc", "meter", "Mon", "mid", "mat", "module", "met", "con", "mm", "mod", "mem", "mun", "sam", " monitor", "mi", "atom", "min", "monitor", "ann", "pm", "MON", "bo", "mag", "man", "om", "wat", "mu"], "ret_data": ["ret_result", "ret_obj", "retacresult", "ret_body", " ret_body", " ret_obj", " ret_di", "ret_list", "retacdata", " ret_result", "ret_di", " ret_list", "retacdi"], "cmd_list": ["cmdiptable", "cmdenval", "cfg_val", "cfgxdel", "cmdsstack", "cfgxlist", "cmdxval", "cmdendata", "command_stack", "cmdenlist", "cmdendel", "cmd_head", "msg_list", "cmd_set", "msg_record", "cfgxdata", "cookiellist", "cmdxback", "msg_table", "cookielhead", "msg_List", "cmdllist", "msg_main", "cmdenmain", "cmdldata", "cmdipset", "cmdlhead", "cmd_record", "cmd_data", "cfg_del", "cookie_back", "cmdlback", "cmdxdel", "cmd_main", "cmdxhead", "cmdiplist", "cmd_table", "cmdsset", "msg_set", "cmdenList", "cfg_data", "cookie_data", "command_set", "cookielback", "cmdxlist", "cmd_stack", "cmdiprecord", "cookie_head", "cfgxval", "cookieldata", "cookie_list", "cmd_del", "msg_pre", "cmd_pre", "cmdxdata", "cmd_val", "command_list", "cfg_list", "cmd_back", "cmdenpre", "cmdslist", "cmd_List"], "cmd": ["call", "domain", "pkg", "cm", "cook", "config", "cc", "code", "id", "pt", "child", "ctr", "msg", "name", "ctrl", "g", "req", "cn", "auth", "module", "method", "mod", "cmp", "ct", "opt", "conn", "client", "cd", "check", "clean", "obj", "grad", "plugin", "cli", "ck", "mode", "cfg", "custom", "c", "block", "crit", "cat", "dc", "cb", "gen", "md", "ht", "nick", "Cmd", "cf", "q", "kg", "command", "cp", "cookie", "vc", "comm", "cod", "content", "host", "prefix", "header", "dom", "cl", "ctx"], "buf": ["path", "map", "vec", "port", "bin", "ff", "uc", "bc", "queue", "rc", "batch", "code", "bn", "bd", "msg", "uf", "fun", "bytes", "pool", "str", "buffer", "raw", "lit", "bag", "loc", "br", "buff", "value", "la", " buffer", "doc", "brace", "rb", "data", "b", "byte", "box", "base", "Buffer", "wb", "block", "alloc", "bo", "cap", "text", "cb", "cas", "coll", "src", "seq", "num", "addr", "pad", "ctx", " buff"]}}
{"project": "FFmpeg", "commit_id": "3c5cf2a31b4b29a8e4282cbe6a3f0617c14698b8", "target": 0, "func": "static int screenpresso_decode_frame(AVCodecContext *avctx, void *data,\n\n                                     int *got_frame, AVPacket *avpkt)\n\n{\n\n    ScreenpressoContext *ctx = avctx->priv_data;\n\n    AVFrame *frame = data;\n\n    int keyframe;\n\n    int ret;\n\n\n\n    /* Size check */\n\n    if (avpkt->size < 3) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small (%d)\\n\", avpkt->size);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* Basic sanity check, but not really harmful */\n\n    if ((avpkt->data[0] != 0x73 && avpkt->data[0] != 0x72) ||\n\n        avpkt->data[1] != 8) { // bpp probably\n\n        av_log(avctx, AV_LOG_WARNING, \"Unknown header 0x%02X%02X\\n\",\n\n               avpkt->data[0], avpkt->data[1]);\n\n    }\n\n    keyframe = (avpkt->data[0] == 0x73);\n\n\n\n    /* Resize deflate buffer and frame on resolution change */\n\n    if (ctx->inflated_size != avctx->width * avctx->height * 3) {\n\n        av_frame_unref(ctx->current);\n\n        ret = ff_get_buffer(avctx, ctx->current, AV_GET_BUFFER_FLAG_REF);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        /* If malloc fails, reset len to avoid preserving an invalid value */\n\n        ctx->inflated_size = avctx->width * avctx->height * 3;\n\n        ret = av_reallocp(&ctx->inflated_buf, ctx->inflated_size);\n\n        if (ret < 0) {\n\n            ctx->inflated_size = 0;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* Inflate the frame after the 2 byte header */\n\n    ret = uncompress(ctx->inflated_buf, &ctx->inflated_size,\n\n                     avpkt->data + 2, avpkt->size - 2);\n\n    if (ret) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Deflate error %d.\\n\", ret);\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    /* When a keyframe is found, copy it (flipped) */\n\n    if (keyframe)\n\n        av_image_copy_plane(ctx->current->data[0] +\n\n                            ctx->current->linesize[0] * (avctx->height - 1),\n\n                            -1 * ctx->current->linesize[0],\n\n                            ctx->inflated_buf, avctx->width * 3,\n\n                            avctx->width * 3, avctx->height);\n\n    /* Otherwise sum the delta on top of the current frame */\n\n    else\n\n        sum_delta_flipped(ctx->current->data[0], ctx->current->linesize[0],\n\n                          ctx->inflated_buf, avctx->width * 3,\n\n                          avctx->width * 3, avctx->height);\n\n\n\n    /* Frame is ready to be output */\n\n    ret = av_frame_ref(frame, ctx->current);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Usual properties */\n\n    if (keyframe) {\n\n        frame->pict_type = AV_PICTURE_TYPE_I;\n\n        frame->key_frame = 1;\n\n    } else {\n\n        frame->pict_type = AV_PICTURE_TYPE_P;\n\n    }\n\n    *got_frame = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 14813, "substitutes": {"avctx": ["verkb", "abconn", "versci", "avlc", "avsci", "aflc", "versync", "akcmp", "afxc", "navctx", "apcmp", "AVcf", "afconfig", "vercf", "avesync", "avcu", " avcontext", "avecmp", "avxc", "navcontext", "avecontext", "avconfig", "avenp", "avctl", "avcp", "Avconfig", "afnp", "abctx", "navpkg", "AVconfig", "afconn", "abcontext", "avekb", "avecp", "abcmp", "apcontext", "afcf", " avconfig", "AVcontext", "avectx", "abxc", "abcu", "AVnp", "afcu", "afsync", "AVconn", "AVlc", "avnp", "afcontext", "avkb", "AVpkg", "akctx", "avconn", "avectrl", " avcu", "avctrl", "akcontext", "afsci", "AVsync", "avesci", "avepkg", "avcf", "vercontext", "navsync", "avsync", "aveconfig", "vercmp", "verctx", "avecf", "navcf", "afctx", "afctl", "Avcontext", "afpkg", "akctl", "afkb", "AVcmp", "Avctx", "avcmp", "apctl", "AVcp", "avelc", "verctrl", "AVcu", "afcmp", "Avcu", "apctx", "afcp", "AVctrl", "avcontext", "aveconn", "AVctx", "avexc", "avpkg", "afctrl"], "data": ["area", "device", "batch", "val", "i", "memory", "shape", "sample", "align", "image", "new", "bytes", "x", "raw", "ul", "media", "base", "reader", "count", "lines", "end", "offset", "fail", "get", "window", "in", "index", "message", "actions", "draw", "call", "head", "bin", "part", "slice", "d", "id", "api", "weight", "missing", "to", "script", "key", "client", "instance", "byte", "length", "result", "number", "feed", "body", "results", "ack", "cache", "empty", "addr", "header", "depth", "complete", "style", "connection", "buffer", "valid", "value", "alpha", "ad", "pipe", "block", "first", "DATA", "load", "video", "pos", "delay", "channel", "it", "record", "ui", "as", "input", "response", "shift", "code", "split", "a", "name", "gap", "capacity", "present", "size", "wave", "p", "buf", "read", "parent", "dat", "next", "Data", "file", "scale", "last", "content", "pad", "start"], "got_frame": ["get2frame", "gotoutbuffer", "got_buffer", "gotoutframe", "got_image", "get_frames", "got2frames", "get_buffer", "get2buffer", "got2frame", "get_image", "get2image", "got2buffer", "get2frames", "gotoutframes", "got_frames", "gotoutimage", "get_frame", "got2image"], "avpkt": ["avperet", "avfdr", "avPcht", "affnt", "affcht", "avpud", "avfelt", "AVPdr", "avcpdt", "avpoleter", "avpruth", " avdacket", " avfpcht", "avdkt", "avppkt", "avperkt", "AVpdr", "avPdr", "avprnt", "akpud", "avfpacket", "avfpsth", "akpck", "avPck", "avkkt", "avcpkt", "affft", "avmkt", "afffx", "avpaelt", "AVpacket", "avbpka", "avbpkt", "avpraga", "afpacker", "avwpdat", "avfcht", "avPacket", "avpwd", "avprwd", "avebwd", "avepeter", "avpolwd", " avpnt", "avcpdat", "avcpacket", "avpfx", "avdnt", "avspkt", "avpacker", " avbpka", "avdacket", "avnpkt", "avbpelt", "avkacket", "afpcht", "avdud", "avmfx", "avpsth", "avpaga", " avfpkt", "avbeter", "affuth", "afpdt", "avpeuth", "avpacket", "avppacker", "avpck", "avfdt", "avvpck", "avpekt", "avepkt", "affacket", "akpkt", "avcputh", "affdat", "akprud", "avpace", "affelt", "akpruth", "avvkt", "avperacket", "avpcht", "avspacket", "avfft", " avpcht", "avputh", "avnpce", "afpkt", " avpsth", "avpnt", "avpolaga", "avmet", "avpelt", " avpelt", "avfck", "akprck", "avnpelt", "avspsth", "avfkt", "afpelt", "avbacket", "avebaga", "avfpkt", "avbwd", "AVPacket", "avvpdr", "avpeelt", "afpdat", " avfpacket", "affet", "AVPkt", "avfacker", "avPkt", "avvcht", "akputh", "avpka", "avepwd", "afpacket", "avpakt", "avppacket", "avpdat", "avwpkt", " avdud", "avprkt", "avprud", " avfpsth", " avpka", "avpce", "AVpkt", "avfdat", "avPud", " avbpce", "avkuth", "avfud", "avpeter", "avebkt", "avppft", "avvnt", "avmacket", "avcpck", "avpracket", "avPuth", "avpdt", " avbpkt", "avffx", "akprkt", "afpfx", "avwpacket", "avfacket", "AVPck", "avbcht", "affacker", "avpaka", "avnpka", " avpud", " avbpelt", "avbkt", "affdt", " avpce", "avspcht", "AVpck", "avpreter", "afpft", "avcpacker", "avcpft", "affkt", "afpnt", "avvpacket", "afpet", "avbnt", " avpacket", "avwpdt", "avfnt", "avPsth", "avpeacket", "avbaga", "avvacket", "avpet", "avpolkt", "avprck", "avpft", "avkelt", "avvpkt", "avfuth", "avcpud", "avperfx", " avdkt", "avebeter", "avpdr", "avfpcht", "afputh", "avfet", " avdnt", "avepaga", "avbpce"], "ctx": [" context", "sys", "context", "tx", "cam", "cm", "pkg", "qa", "cv", "ca", "bc", "sync", "cc", "config", "pc", "cdn", "utils", "Context", "ctrl", "lc", "ci", "act", "cs", "conv", "wx", "cn", "cms", "wcs", "cmp", "sq", "loc", " cx", "conn", "client", "np", "kw", "uc", "comp", "ck", "tc", "co", "component", "nc", "cli", "cus", "acl", "cfg", "c", "cca", "crit", "cu", "anc", "cb", "cas", "sci", "cmd", "cf", "coll", "cp", "exec", "kb", "vc", "xc", "qq", "css", "support", "hw", "fw"], "frame": ["board", "context", "part", "Frame", "slice", "code", "iframe", "object", "shot", "row", "image", "event", "buffer", "session", "value", "element", "document", "view", "instance", "component", "result", "flow", "parent", "block", "seq", "window", "node"], "keyframe": ["KEYFrame", " keyfram", "KEYflow", "matchline", "keyblock", "switchhole", "keyfram", " keyword", "linkframe", "keyword", "KeyFrame", "linksequence", "linkfram", "matchhole", "switchline", "Keyframe", "switchFrame", "matchframe", "Keyword", "KEYsequence", "keyFrame", "KEYword", "keysequence", "KEYfram", " keyflow", "switchframe", "KEYframe", " keyblock", "linkblock", " keysequence", "keyline", "matchFrame", "KEYblock", "Keyflow", "keyflow", " keyhole", " keyline", " keyFrame", "keyhole"], "ret": ["en", "reply", "art", "val", "def", "gt", "status", "ct", "obj", "active", "rb", "bf", "att", "cat", "fail", "RET", "num", "debug", "ft", "rev", "done", "rc", "rets", "sr", "arg", "det", "error", "pass", "detail", "mt", "ext", "result", "url", "try", "al", "res", "reg", "rf", "flag", "run", "alt", "let", "format", "fun", "ref", "lit", "info", "Ret", "rl", "reset", "nt", "re", "rt", "rep", "no", "usr", "post", "bit", "replace", "err", "code", "back", "bad", "hash", "feat", "success", "match", "resp", "db", "len"]}}
{"project": "qemu", "commit_id": "f65ed4c1529f29a7d62d6733eaa50bed24a4b2ed", "target": 1, "func": "int kvm_init(int smp_cpus)\n{\n    KVMState *s;\n    int ret;\n    int i;\n    if (smp_cpus > 1)\n        return -EINVAL;\n    s = qemu_mallocz(sizeof(KVMState));\n    if (s == NULL)\n        return -ENOMEM;\n    for (i = 0; i < ARRAY_SIZE(s->slots); i++)\n        s->slots[i].slot = i;\n    s->vmfd = -1;\n    s->fd = open(\"/dev/kvm\", O_RDWR);\n    if (s->fd == -1) {\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n        ret = -errno;\n        goto err;\n    }\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n    if (ret < KVM_API_VERSION) {\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm version too old\\n\");\n        goto err;\n    }\n    if (ret > KVM_API_VERSION) {\n        ret = -EINVAL;\n        fprintf(stderr, \"kvm version not supported\\n\");\n        goto err;\n    }\n    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);\n    if (s->vmfd < 0)\n        goto err;\n    /* initially, KVM allocated its own memory and we had to jump through\n     * hooks to make phys_ram_base point to this.  Modern versions of KVM\n     * just use a user allocated buffer so we can use phys_ram_base\n     * unmodified.  Make sure we have a sufficiently modern version of KVM.\n     */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm does not support KVM_CAP_USER_MEMORY\\n\");\n        goto err;\n    }\n    /* There was a nasty bug in < kvm-80 that prevents memory slots from being\n     * destroyed properly.  Since we rely on this capability, refuse to work\n     * with any kernel without this capability. */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION,\n                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr,\n                \"KVM kernel module broken (DESTROY_MEMORY_REGION)\\n\"\n                \"Please upgrade to at least kvm-81.\\n\");\n        goto err;\n    }\n    ret = kvm_arch_init(s, smp_cpus);\n    if (ret < 0)\n        goto err;\n    kvm_state = s;\n    return 0;\nerr:\n    if (s) {\n        if (s->vmfd != -1)\n            close(s->vmfd);\n        if (s->fd != -1)\n            close(s->fd);\n    }\n    qemu_free(s);\n    return ret;\n}", "idx": 9418, "substitutes": {"smp_cpus": ["smp_gpus", "smp_puses", "smp_mpu", "smp_pul", "smp_cpu", "smp_gpis", "smp_mpis", "smp_gpul", "smp_gpuses", "smp_ipu", "smp_cpul", "smp_cpuses", "smp_ipis", "smp_mpul", "smp_cpis", "smp_mpuses", "smp_gpu", "smp_pus", "smp_ipus", "smp_mpus", "smp_pis", "smp_ipuses"], "s": ["l", "session", "is", "m", "http", "t", "x", "gs", "set", "sk", "v", "state", "bis", "groups", "ns", "spec", "self", "settings", "sg", "ds", "si", "n", "your", "sf", "w", "b", "k", "c", "se", "e", "args", "sq", "us", "f", "j", "sym", "sets", "scope", "es", "current", "sup", "r", "storage", "as", "ps", "su", "site", "fs", "ss", "secure", "g", "stat", "d", "sa", "ls", "status", "socket", "os", "cs", "o", "sync", "south", "sl", "native", "new", "sb", "sys", "secondary", "ssl", "conf", "ts", "in", "service", "p", "server", "qs", "tests", "xs", "js", "rs", "sec", "aws", "S", "states", "services", "h", "client", "ses", "y"], "ret": ["true", "af", "fail", "red", "ref", "arg", "cb", "reg", "gt", "code", "al", "opt", "end", "att", "err", "hash", "re", " RET", "let", "url", "resp", "arr", "flag", "val", "key", "id", "no", "Ret", "mem", "post", "fit", "ut", "j", "db", "res", "bf", "det", "lt", "art", "error", "back", "not", "sat", "mt", "rl", "bad", "str", "nb", "len", "alt", "def", "nt", "conn", "num", " Ret", "pat", "reply", "status", "rb", "rt", "rc", "fun", "req", "part", "cat", "result", "success", "pass", "valid", "info", "sur", "job", "lit", "pt", "rets", "bot", "bit", "RET", "ft", "rev", "match", "feat", "pet"], "i": ["oi", "l", "sp", "ui", "dim", "di", "base", "it", "si", "n", "zi", "key", "m", "xi", "id", "b", "x", "t", "ini", "k", "d", "uli", "c", "p", "ix", "uri", "e", "mu", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "gi", "mi", "ind", "ti", "phi", "abi", "qi", "err", "pi", "bi", "part", "ii", "init", "u", "uni", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu", "ki"]}}
{"project": "qemu", "commit_id": "3401c0d95ffb9a9a57093ee002d24d014ffed4f8", "target": 1, "func": "static void do_send_key(const char *string)\n\n{\n\n    char keybuf[16], *q;\n\n    uint8_t keycodes[16];\n\n    const char *p;\n\n    int nb_keycodes, keycode, i;\n\n\n\n    nb_keycodes = 0;\n\n    p = string;\n\n    while (*p != '\\0') {\n\n        q = keybuf;\n\n        while (*p != '\\0' && *p != '-') {\n\n            if ((q - keybuf) < sizeof(keybuf) - 1) {\n\n                *q++ = *p;\n\n            }\n\n            p++;\n\n        }\n\n        *q = '\\0';\n\n        keycode = get_keycode(keybuf);\n\n        if (keycode < 0) {\n\n            term_printf(\"unknown key: '%s'\\n\", keybuf);\n\n            return;\n\n        }\n\n        keycodes[nb_keycodes++] = keycode;\n\n        if (*p == '\\0')\n\n            break;\n\n        p++;\n\n    }\n\n    /* key down events */\n\n    for(i = 0; i < nb_keycodes; i++) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode & 0x7f);\n\n    }\n\n    /* key up events */\n\n    for(i = nb_keycodes - 1; i >= 0; i--) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode | 0x80);\n\n    }\n\n}\n", "idx": 5191, "substitutes": {"keybuf": ["valuebuf", "kbuff", "kuf", " keybuffer", "charbuff", "rowqueue", "keyblock", "kbase", "keyuf", "charbase", " keybase", "kbuffer", "parentbuff", "valueblock", "rowbuff", "charbuffer", "kblock", "charseq", "valuebuff", " keyuf", " keybuff", "bytebuffer", "rowbuffer", " keyqueue", "keybase", "keybuff", "kcb", "keyseq", "kqueue", "valueuf", "keyqueue", "charcb", "kbuf", " keycb", "bytebuf", "keycb", "bytecb", "charbuf", "charqueue", "rowseq", "valuequeue", "rowcb", "keybuffer", "parentuf", "parentbuffer", " keyblock", " keyseq", "valuebuffer", "rowuf", "rowbuf", "parentbuf", "bytebuff"], "q": ["patch", "P", "ch", "iq", "v", "cur", "id", "qq", "check", "qt", "x", "b", "force", "sync", "pe", "queue", "qi", "key", "l", "f", "dq", "d", "j", "u", "code", "e", "sh", "w", "que", "comment", "k", "Q", "qs", "t", "qu", "qa", "req", "h", "z", "c", "g", "sq", "y", "query", "text", "r"], "keycodes": ["Keylines", "changecode", "kcode", "keyodes", "Keybuf", "switchcodes", "lockcode", "switchcode", " keyodes", "Keycards", "keypath", "maccoded", "kmaps", "charcode", "lockcoded", "changecodes", " keycards", " keymaps", "switchbuf", "changeodes", "keycards", "charpath", " keycoded", "maccodes", "maccode", "charcodes", "Keycodes", "Keypath", "switchcards", "Keycode", "keycoded", "lockcodes", "lockmaps", " keypath", " keylines", "macodes", "keylines", "kcoded", "changecoded", "charlines", "keymaps", "kcodes"], "p": ["patch", "cp", "P", "pid", "o", "python", "v", "pr", "a", "s", "pa", "pat", "pre", "po", "b", "pp", "op", "x", "pe", "ap", "lp", "m", "l", "f", "pi", "at", "pg", "php", "j", "d", "pc", "py", "param", "np", "u", "code", "e", "point", "part", "t", "k", "n", "jp", "fp", "qa", "h", "sp", "pos", "pointer", "c", "ip", "g", "y", "type", "api", "tp", "pair", "pl", "cache", "r", "ps", "prefix"], "nb_keycodes": ["nb_linklines", "nb_datecodes", "nb_Keycodes", "nb_keyodes", "nb_datecards", "nb_switchcod", "nb_linkcards", "nb_keycats", "nb_linkcats", "nb_keycode", "nb_keycards", "nb_keylines", "nb_callmaps", "nb_Keylines", "nb_keychecks", "nb_mycodes", "nb_charcodes", "nb_calllines", "nb_callchecks", "nb_charxes", "nb_keyxes", "nb_macodes", "nb_switchcodes", "nb_callodes", "nb_myxes", "nb_charses", "nb_changecodes", "nb_Keychecks", "nb_callcards", "nb_linkcodes", "nb_keycod", "nb_myses", "nb_callcodes", "nb_Keyses", "nb_changelines", "nb_callcats", "nb_maccodes", "nb_keyses", "nb_callcod", "nb_datecats", "nb_Keymaps", "nb_callcode", "nb_changemaps", "nb_datelines", "nb_Keyxes", "nb_maccode", "nb_switchlines", "nb_keymaps", "nb_changechecks"], "keycode": ["pointcode", "xcoded", "skycode", "skypath", "lockcode", "rycod", "vercod", "keydesc", "rowcod", "opcod", "keypath", "keydef", "rowcoded", " keycod", "rowCode", "wordpath", "pointcod", " keyc", "keycycle", "typedesc", "checkmessage", "lockdef", " keyode", "keyCode", "checkode", "lockCode", "checkc", "levelcode", "rowcodes", "Keycycle", "transferfore", "keyfore", "vercode", "checkdef", "ryode", " keyCode", "keycoded", "pointode", "xcode", "levelfore", "pointmessage", "rycode", "Keycod", "typecodes", "ycod", "rowcode", " keydesc", "keycomment", "wordc", "lockc", "Keyfore", "rycoded", " keydef", "ycode", "typecode", "valuecode", "levelcod", " keycoded", "ycodes", "skycomment", "wordcode", "vercoded", "Keycode", "Keymessage", " keycomment", "keymessage", " keypath", "wordcomment", "ycoded", "callcod", "valueode", "callcodes", "keyode", "valuecoded", "opc", "transfercycle", "checkcode", "keycod", "opcode", "levelcycle", "opcodes", "calldesc", "callcode", "xcod", "lockcod", "typecod", "Keyode", "lockcoded", "skyc", "transfercod", "checkcod", "transfercode", "verc", "valuecod", "lockcodes", "keyc", "xc"], "i": ["gi", "o", "ti", "v", "id", "I", "chi", "a", "di", "s", "ci", "x", "ji", "ni", "b", "xi", "si", "ri", "io", "abi", "slice", "info", "bi", "m", "qi", "ix", "l", "f", "pi", "yi", "phi", "j", "ii", "iu", "ai", "cli", "init", "u", "e", "uri", "k", "n", "multi", "mi", "ini", "ie", "one", "eni", "start", "oi", "hi", "c", "ip", "g", "y", "api", "li", "inner", "fi", "index", "zi", "mu", "ui"]}}
{"project": "FFmpeg", "commit_id": "ff486c0f7f6b2ace3f0238660bc06cc35b389676", "target": 0, "func": "static int get_pcm(HEVCContext *s, int x, int y)\n\n{\n\n    int log2_min_pu_size = s->sps->log2_min_pu_size;\n\n    int x_pu             = x >> log2_min_pu_size;\n\n    int y_pu             = y >> log2_min_pu_size;\n\n\n\n    if (x < 0 || x_pu >= s->sps->min_pu_width ||\n\n        y < 0 || y_pu >= s->sps->min_pu_height)\n\n        return 2;\n\n    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];\n\n}\n", "idx": 10547, "substitutes": {"s": ["session", "sg", "ts", "sv", "context", "ds", "n", "si", "g", "is", "sf", "w", "m", "http", "t", "b", "i", "gs", "service", "c", "p", "ls", "e", "se", "qs", "xs", "sq", "js", "f", "cs", "sym", "o", "aws", "sets", "S", "es", "sky", "sync", "space", "services", "ns", "sb", "storage", "spec", "u", "self", "sys", "sim", "side", "ses", "ps", "su", "site", "ss", "fs", "settings", "ssl"], "x": ["l", "n", "ax", "xx", "w", "xi", "m", "id", "t", "b", "z", "d", "i", "c", "X", "p", "ix", "max", "e", "pe", "xs", "f", "height", "index", "size", "v", "fx", "tx", "u", "h", "xy", "rx", "px", "image", "dx", "ex"], "y": ["ym", "ady", "yt", "oy", "ry", "ny", "w", "b", "ey", "vy", "z", "t", "i", "ys", "p", "cy", "iy", "yi", "ay", "zy", "sy", "yy", "j", "height", "py", "sky", "ery", "Y", "ty", "ies", "yr", "u", "yn", "ya", "dy", "yo"]}}
{"project": "qemu", "commit_id": "b248ede2ef2792d364bd305e5e92e24921c924a8", "target": 1, "func": "if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_get_clock_ns(rt_clock);\n\n    int requeued = 0;\n\n\tstruct mbuf *ifm, *ifqt;\n\n\n\n\tDEBUG_CALL(\"if_start\");\n\n\n\n\tif (slirp->if_queued == 0)\n\n\t   return; /* Nothing to do */\n\n\n\n again:\n\n        /* check if we can really output */\n\n        if (!slirp_can_output(slirp->opaque))\n\n            return;\n\n\n\n\t/*\n\n\t * See which queue to get next packet from\n\n\t * If there's something in the fastq, select it immediately\n\n\t */\n\n\tif (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n\t\tifm = slirp->if_fastq.ifq_next;\n\n\t} else {\n\n\t\t/* Nothing on fastq, see if next_m is valid */\n\n\t\tif (slirp->next_m != &slirp->if_batchq)\n\n\t\t   ifm = slirp->next_m;\n\n\t\telse\n\n\t\t   ifm = slirp->if_batchq.ifq_next;\n\n\n\n\t\t/* Set which packet to send on next iteration */\n\n\t\tslirp->next_m = ifm->ifq_next;\n\n\t}\n\n\t/* Remove it from the queue */\n\n\tifqt = ifm->ifq_prev;\n\n\tremque(ifm);\n\n\tslirp->if_queued--;\n\n\n\n\t/* If there are more packets for this session, re-queue them */\n\n\tif (ifm->ifs_next != /* ifm->ifs_prev != */ ifm) {\n\n\t\tinsque(ifm->ifs_next, ifqt);\n\n\t\tifs_remque(ifm);\n\n\t}\n\n\n\n\t/* Update so_queued */\n\n\tif (ifm->ifq_so) {\n\n\t\tif (--ifm->ifq_so->so_queued == 0)\n\n\t\t   /* If there's no more queued, reset nqueued */\n\n\t\t   ifm->ifq_so->so_nqueued = 0;\n\n\t}\n\n\n\n        if (ifm->expiration_date < now) {\n\n            /* Expired */\n\n            m_free(ifm);\n\n        } else {\n\n            /* Encapsulate the packet for sending */\n\n            if (if_encap(slirp, ifm)) {\n\n                m_free(ifm);\n\n            } else {\n\n                /* re-queue */\n\n                insque(ifm, ifqt);\n\n                requeued++;\n\n            }\n\n        }\n\n\n\n\tif (slirp->if_queued)\n\n\t   goto again;\n\n\n\n        slirp->if_queued = requeued;\n\n}\n", "idx": 26587, "substitutes": {"ifm": ["ifmt", "IFp", " ifmc", "tifp", "afp", "actcm", "Ifcm", "ilm", "fnm", "itmc", "iffrm", "fm", "ifbm", " ifr", "actmt", "confm", "fcm", " iffm", "ifdm", "formc", "ilrm", "evmn", "incm", "afmt", "ifw", "actw", "iffnm", "tifmt", "iffd", "iffc", "ofy", "ifh", "notp", "elp", "evm", "actmm", "fp", "IfM", "itercm", "ittm", "notm", "ifmc", "iffcm", "itmi", "ifmn", "evp", "itn", " ifmt", "elrm", "confym", "itfm", "iterw", "itgm", " ifbm", "endifmt", "form", "ifM", "itrm", "incmt", "eldm", "endifn", " iftm", "ff", "IFm", "Ifmt", "afd", "iffn", "ifgm", "incmm", "tifm", "idc", "opmt", "evM", "ily", "itm", "Ifm", "ofcm", "iffm", "itp", " ifM", "ifym", "notmt", "oftm", "ifn", "elm", "iffmi", "afcm", "iftm", "Ifp", "itw", "iffbm", "incr", "iffdm", "iffp", "itcm", "frm", " ifcm", "ify", " ifmn", "iterl", "Ifmn", "ifc", "ifd", "fc", "itf", "actl", "fh", "ifrm", "afdm", "actm", "ifr", "eld", "defmn", "idf", "elcm", "tifcm", "forn", "fortm", "fgm", "defcm", "afm", "defym", "ifmi", "ifmm", "opcm", "ild", "Ifbm", "iterm", "iff", "ifcm", "ifnm", "confcm", "ilcm", "itc", "ifl", "idm", " ifp", "confmn", "fdm", " ifdm", "opp", " ifmm", "idgm", "actr", "iffh", " ifd", "IFmt", "ity", "endifcm", " ifnm", "ifp", "ifffm", " ifl", "endifm", " ifym", " ifh", "opm", "itl", "notcm", " ifmi", "Ifn", "iltm", "ofm", "IFl", " ifn", "defm", " ifrm", "IFcm", "iffl"], "ifqt": ["fqt", " iftk", "fikt", "afiq", "tifwx", "afiqq", "tifkt", "inkt", "fqq", "inq", "lifwx", " ifqq", " ifq", "afiqt", "aficit", "inqt", "lifkt", "fitk", "ifvt", " ifvt", "incqt", "inctk", "ifcit", "tifvt", "lifqt", "fivt", " ifcit", "Ifq", "ifwx", "Ifkt", "fq", "fcit", "lifvt", "fiwx", "ifqq", "incqq", "incvt", "fkt", "ifq", "fiqq", "fiqt", "Ifqq", "ifkt", "Ifqt", "iftk", "tifqt", "inqq"], "slirp": ["slripc", "slirl", "sloircp", "slirtpc", "slireP", "slyrpa", "slirtr", "slierl", "slwerp", "sliroP", "blirpc", "collirop", "spliropad", "slpirv", "quairr", "slirpad", "slirb", "spliarl", "slirep", "sliripc", "blirr", "slurpre", "sliarpe", "slrispi", "slirg", "skirpatch", "slirepa", "ellirtpc", " sliror", "elirp", "selirpc", "Sloirpe", "slripa", "sliarp", "skirib", "sliropad", "slirper", "Slirpe", "sliperp", "sladrp", " slirop", "lairlp", "slairr", "slrisp", "slirr", "collirp", "spliarpc", "slirP", "slirepc", "splirpe", "slyrpc", "blirpre", "slierping", "splirpc", "splirl", "selyrpc", "slirepe", "shierp", "spliarpa", "shierg", "slwerl", "slairp", "sliroper", "ellirtcp", "collirb", "slirv", "blierr", "slricp", "collirope", "shirr", "elierp", "sliarpc", "selyrpa", "slirib", "slaripi", "sliverpc", "ellircp", "slirlpatch", "slierpi", "skirp", "slirer", "sliripad", "slrispo", "selirpa", "quirpa", "blirp", "slirip", "colliroper", "slpirpc", "sliverpa", "spliarp", "slirop", "slrip", "slirtf", "splirp", "sladrcp", "sliropa", "sladrr", "sloirpe", "slirel", "slirlb", "selirpi", "slirpc", "slarig", "slierpc", "slrisr", "slirpi", "lairf", "elirping", "ellirp", "elierr", "slyrpe", "slierg", "ellirpc", "Slirr", "slierp", "slirpo", "shirpi", "sliarl", "lairp", "selirp", "elirpc", "slirlf", "slirecp", "slirope", " sliroP", "slirtl", "slircp", "slirpa", "lairlpc", "quairpc", "slpirp", "slurpc", "sliperpc", "slirf", " slircp", "slirocp", "slurr", "sloirr", "sliropi", "slriscp", "skirb", "slwerpc", "quirr", "elirr", "slrispad", "slyrper", "shierr", "splirpad", "ellirpa", "slurp", "Sloirr", "slyrb", "slyrp", "elierpc", "slyrpi", "skiripc", "selyrp", "slirtcp", "shierpc", "slirob", "collirob", "shirl", "slairpa", "Slircp", "spliarpad", "slirtpa", "slirpre", "slpirf", "sliperpad", "lairpc", "shierpi", "collirpe", "ellirtp", "quairpa", "slierb", "slirlpi", "slirpe", "sliropc", "Sloircp", "slrispc", "slyrpad", "slwerpa", "sloirp", "spliarpe", "slrispa", " slirr", "slirtP", "slirlg", "sliarpa", "slirtv", "slierr", "Slirp", "quirp", "spliropc", "slirpatch", "blierpre", "slierpatch", "slirlpc", "splirop", "slireg", "sliripatch", "slairpc", "quirpc", "slierpre", "lairlf", "Sloirp", "shirp", "slirtp", "skirpc", "elierping", "slirtg", "sliperpe", "sladrpe", "splirpa", "slirping", "sliarpad", "sliverr", "blierp", "sliripe", "shirpc", "slirepre", "quairp", "collirper", "slyrpo", " slirocp", "shierl", "sliropo", "splirpo", "slirlp", "slrisping", "ellirtpa", "skirip", "sliror", "skiripatch", "lairlv", "sloirper", " slirP", "shirg", "slarip", "lairv", "selyrpi", "slirlv", "slireping", "slaripc", "sloirb", "blierpc", "sliverp", "spliropo"], "if_queued": ["if_quesumed", "if_cluing", "ifallquemented", "if_continued", "if_queues", "if_queuing", "if_queue", "if_qauing", "if_Queuing", "if_continue", "if_quesuing", "if_queueless", "if_qaue", "ifallqueue", "if_quesue", "if_ques", "if_qued", "if_clueless", "if_queueueless", "ifallcontinued", "if_QueUE", "if_quemented", "if_quesued", "ifallqueued", "ifallcontinmented", "if_queumed", "if_queueued", "if_queueumed", "if_clued", "if_qaued", "if_queueues", "if_Queued", "ifallcontinue", "ifallqueUE", "if_continUE", "if_queUE", "if_continmented", "if_que", "if_Quemented", "ifallcontinUE", "if_qaueless", "if_Queue", "if_Queumed", "if_queueue", "if_clue", "if_queueUE", "if_queueuing", "if_queuemented", "if_quing"], "ifq_so": ["ifq_since", "ifp_while", "ifq_gone", "ifp_since", "ifp_next", "ifc_since", "ifq_while", "ifc_co", "ifq_lo", "ifp_gone", "ifq_next", "ifq__since", "ifp_so", "ifq_co", "ifp_lo", "ifp_co", "ifq__co", "ifq__so", "ifc_so"], "so_queued": ["so_queurized", "so_queueued", "so_quued", "so_queueues", "so_scheue", "so_queueue", "so_queues", "so_scheued", "so_scheues", "so_quue", "so_quurized", "so_scheurized", "so_queue", "so_quues", "so_queueurized"], "requeued": ["refqueumed", "refpeumed", "reequeused", "repeuated", "requeuing", "requured", "reQueuing", "requeumed", "reQueued", "repeured", "requeuated", "repemented", "reequeued", "repeused", "remqueuer", "reequed", "refpeued", "reequeuing", "repluated", "refquemented", "requeused", "requuing", "refqueuated", "requer", "reQueused", "reQueues", "reeqused", "requred", "replmented", "refpemented", "repeued", "remquured", "remqueued", "repeumed", "requated", "remquuer", "requeues", "refpeuated", "refqueued", "requed", "remqueured", "requuer", "requeuer", "replued", "remquuing", "reequing", "repeues", "reqused", "remquued", "replumed", "requemented", "requmed", "requing", "requeured", "reeques", "repeuing", "reques", "requued", "remqueuing", "repeuer", "reequeues", "reqmented"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)\n\n{\n\n    memory_region_init_io(mr, &isa_mmio_ops, NULL, \"isa-mmio\", size);\n\n}\n", "idx": 3766, "substitutes": {"mr": ["dr", "rg", "mn", "vm", "mt", "rs", "gr", "mc", "mx", "r", "rr", "MR", "mi", "mm", "lr", "kr", "adr", "rb", "m", "nr", "er", "ir", "fr", "RM", "usr", "pr", "br", "rm", "pm", "sr", "pc", "rx", "shr", "rt", "vr", "rh", "Mr"], "size": ["SIZE", "name", "capacity", "cs", "ize", "esc", "small", "loc", "empty", "g", "code", "args", "number", "storage", "address", "ptr", "len", "length", "Size", "sec", "sn", "scale", "fee", "iz", "six", "addr", "io", "shape", "timeout"]}}
{"project": "qemu", "commit_id": "a879125b47c3ae554c01824f996a64a45a86556e", "target": 1, "func": "static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    outw(0xcfc, value);\n\n}\n", "idx": 11980, "substitutes": {"bus": ["boot", "pass", "board", "http", "mount", "BBC", "bridge", "config", "ux", "plug", "bug", "bits", "serial", "us", "BUS", "os", "Bus", "sync", "USB", "port", "usb", "self", "cache", "proc"], "devfn": ["devicefile", "devFN", "DevFN", "tempfn", "Devfp", "Devfile", " devfd", "devicefp", " devfile", "Devfunction", "tempfd", "devicefn", "Devfn", "tempfp", "devicefunction", "devfp", " devfp", "tempFN", " devFN", "Devfd", " devfunction", "devfile", "devfunction", "devfd"], "offset": ["parent", "alias", "location", "reference", "timeout", "optional", "start", "prefix", "info", "pointer", "data", "slot", "limit", "set", "number", "style", "off", "padding", "o", "index", "size", "format", "align", "end", "address", "function", "position", "error", "pos", "attribute", "length", "Offset", "range", "reset"], "value": ["parent", "reference", "timeout", "Value", "start", "val", "key", "w", "data", "number", "array", "flow", "slave", "padding", "entry", "child", "values", "version", "index", "v", "format", "name", "current", "function", "address", "position", "property", "amount", "type", "message", "image", "buffer", "VALUE", "paid", "fee"]}}
{"project": "qemu", "commit_id": "50628d3479e4f9aa97e323506856e394fe7ad7a6", "target": 1, "func": "void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y,\n\n                  int dst_x, int dst_y, int w, int h)\n\n{\n\n    DisplayState *s = con->ds;\n\n    DisplayChangeListener *dcl;\n\n\n\n    if (!qemu_console_is_visible(con)) {\n\n        return;\n\n    }\n\n    QLIST_FOREACH(dcl, &s->listeners, next) {\n\n        if (con != (dcl->con ? dcl->con : active_console)) {\n\n            continue;\n\n        }\n\n        if (dcl->ops->dpy_gfx_copy) {\n\n            dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h);\n\n        } else { /* TODO */\n\n            dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h);\n\n        }\n\n    }\n\n}\n", "idx": 15373, "substitutes": {"con": ["channel", "en", "mc", "cm", "connect", "uc", "bc", "ca", "enc", "core", "rc", "config", "pc", "unc", "cc", "lic", "canon", "current", "connection", "ctrl", "syn", "public", "conv", "cn", "lang", "conf", "cr", "win", "conn", "client", "cons", "col", "an", "CON", "ocon", "nc", "co", "can", "dom", "parent", "control", "c", "Con", "inc", "close", "dc", "anc", "type", "common", "login", "coll", "cal", "exec", "com", "cache", "ec", "dn", "class", "fc", "ln", "cl", "ctx", "anon"], "src_x": ["src01my", " src_rx", "src00orig", "src_orig", "src00y", "src_my", " src_xi", "src01rx", "src00x", "src01x", "src_xi", " src_my", "src00xi", "src_rx", " src_orig", "src01y"], "src_y": ["src_Y", " src_ya", " src_oy", " src_Y", " src_ny", "src_oy", "src_ny", "src_ya"], "dst_x": ["dsta_x", "dsta_xs", "dsts_x", "dsta_X", "drc_xi", "dsts_ix", "dsts_X", "drc_index", "dst_ix", "dst_xs", "dst_X", "dsts_y", "dst_xi", "drc_w", "dst_index", "dst_w", "drc_x", "dsta_y"], "dst_y": ["dest_vy", "dest_dy", "dest_x", "dest_bar", "dst_Y", "dst_i", "dst_vy", "dest_y", "dbl_y", "dst_z", "dbl_x", "dst_dy", "dbl_Y", "dst_bar", "dbl_z", "dest_i"], "w": ["m", "en", "wh", "d", "t", "iw", "l", "ww", "ew", "a", "g", "weight", "wx", "new", "wt", "x", "sw", "v", " W", "win", "o", "z", "p", "e", "b", "wb", "n", "f", "c", "W", "wa", "q", "fw", "r", "we", "work", "y", "ow"], "h": ["hi", "m", "ch", "en", "ha", "ih", "t", "hr", "l", "i", "g", "hs", "x", "gh", "v", "rh", "o", "help", "uh", "hh", "z", "p", "e", "time", "k", "b", "n", "f", "hm", "c", "W", "end", "q", "r", "H", "sh", "hw", "work", "ph", "y", "height"], "s": ["sys", "ses", "self", "sync", "l", "rs", "g", "cs", "syn", "S", "os", "new", "si", "sq", "session", "ps", "ss", "conn", "o", "p", "se", "e", "sb", "b", "n", "f", "acl", "spec", "c", "ns", "is", "sn", "sc", "ssl", "sl", "ds", "sa", "ls"], "dcl": ["cdcel", "dwl", "fcl", "idcl", "ddcl", "ldscl", "tcl", "dCL", "idbc", "dlfl", "sdcel", "dbl", " dlf", "adcl", "ncl", "fpl", "thell", "npl", "Dbc", "adCL", "dacl", "dlcl", "ddfl", " dCL", "idfc", "ldcl", "tscl", "dpl", "dlf", "lcl", "Dcl", "sdfl", "ddcel", "dlc", "nscl", " dbc", "cdcl", "dcel", " dwl", "dlpl", " dacl", "nCL", " dfl", "dhell", "dsl", "dscl", "dfc", "cdCL", "dsCL", "dlwl", "tfc", "idlf", " dcel", "ldacl", "Dpl", "adcel", "idpl", " dpl", "tlc", " dhell", "tfl", "dbc", "dsbl", "fCL", "lpl", "adfl", " dbl", "tbl", " dfc", " dsl", "lacl", "ldCL", "dfl", "lfl", "ldwl", "ddCL", "ldpl", " dlc", "sdhell", "ldsl", "Dlf", "idfl", "fscl", "ldfl", " dscl", "dssl", "ldbl", "tcel", "idlc", "sdcl", "cdfl"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,\n\n                                        hwaddr size, unsigned client)\n\n{\n\n    assert(mr->terminates);\n\n    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,\n\n                                                    size, client);\n\n}\n", "idx": 21612, "substitutes": {"mr": ["ru", "err", "adr", "Mr", "rpm", "rr", "tr", "yr", "rf", "lr", "pc", "r", "m", "mc", "rh", "dr", "rc", "nr", "rm", "fr", "rar", "sr", "rl", "vr", "rt", "hr", "usr", "fm", "cr", "er", "bm", "reader", "br", "req", "rs", "manager", "vm", "kr", "rb", "tm", "ir", "MR", "mn", "rg"], "addr": ["conn", "ref", "adr", "hop", "amp", "part", "val", "kt", "mode", "oa", "ord", "wd", "align", "host", "node", "layer", "address", "ip", "enc", "id", "ace", "prefix", "mac", "ext", "dr", "index", "nr", "edge", "rt", "ptr", "src", "slice", "base", "offset", "x", "attr", "inter", "url"], "size": ["name", "security", "shape", "iz", "esc", "en", "scale", "eni", "sized", "Size", "style", "ize", "ish", "address", "use", "storage", "grow", "gz", "six", "small", "si", "len", "z", "sec", "from", "SIZE", "empty", "offset", "max", "count"], "client": ["remote", "sim", "public", "external", "conn", "wrapper", "gray", "config", "progress", "cm", "connection", "null", "pc", "local", "cell", "buffer", "ian", "standard", "box", "cache", "mac", "cli", "close", "ctx", "self", "window", "worker", "child", "ients", "clean", "global", "parent", "lib", "util", "ce", "resource", "server", "this", "Client"]}}
{"project": "qemu", "commit_id": "74b6ce43e3aacbb101018407196fc963e2c39fea", "target": 1, "func": "static void qio_channel_socket_finalize(Object *obj)\n{\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);\n    if (ioc->fd != -1) {\n#ifdef WIN32\n        WSAEventSelect(ioc->fd, NULL, 0);\n#endif\n        closesocket(ioc->fd);\n        ioc->fd = -1;", "idx": 24331, "substitutes": {"obj": ["node", "ock", "oc", "objects", "pt", "ob", "enc", "data", "Object", "orb", "pointer", "jp", "cb", "opt", "so", "io", "self", "bj", "buf", "o", "obb", "arr", "tmp", "object", "nt", "os", "ctx", "parent", "sb", "cn", "Obj", "po", "j", "src", "conn", "init", "ex", "org", "ops", "pos"], "ioc": ["ptoc", "giocl", "itocl", "riocl", "iooco", "itroc", " iirc", "iocl", "iOC", "xioc", "ioco", " iocl", "xiroc", "riirc", " iroc", "rioc", " iob", "ioca", "poc", "gioco", "proc", "iiroc", "iiOC", "ioocl", "iob", "dioca", "diroc", "piob", "xioco", "gioc", "itirc", "gioca", "iioc", "dioc", "pOC", "itoc", "iooc", "iirc", " iOC", "ioroc", "rioca", "xiob", "diocl", "riroc", "piocl", "pioc", "iitoc", "piroc", "xiocl", "giroc", "iroc", " itoc"]}}
{"project": "FFmpeg", "commit_id": "fc49f22c3b735db5aaac5f98e40b7124a2be13b8", "target": 1, "func": "static char *choose_pixel_fmts(OutputStream *ost)\n\n{\n\n    if (ost->keep_pix_fmt) {\n\n        if (ost->filter)\n\n            avfilter_graph_set_auto_convert(ost->filter->graph->graph,\n\n                                            AVFILTER_AUTO_CONVERT_NONE);\n\n        if (ost->st->codec->pix_fmt == PIX_FMT_NONE)\n\n            return NULL;\n\n        ost->pix_fmts[0] = ost->st->codec->pix_fmt;\n\n        return ost->pix_fmts;\n\n    }\n\n    if (ost->st->codec->pix_fmt != PIX_FMT_NONE) {\n\n        return av_strdup(av_get_pix_fmt_name(choose_pixel_fmt(ost->st, ost->enc, ost->st->codec->pix_fmt)));\n\n    } else if (ost->enc->pix_fmts) {\n\n        const enum PixelFormat *p;\n\n        AVIOContext *s = NULL;\n\n        uint8_t *ret;\n\n        int len;\n\n\n\n        if (avio_open_dyn_buf(&s) < 0)\n\n            exit_program(1);\n\n\n\n        p = ost->enc->pix_fmts;\n\n        if (ost->st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            if (ost->st->codec->codec_id == CODEC_ID_MJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUV420P, PIX_FMT_YUV422P, PIX_FMT_NONE };\n\n            } else if (ost->st->codec->codec_id == CODEC_ID_LJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ444P, PIX_FMT_YUV420P,\n\n                                                    PIX_FMT_YUV422P, PIX_FMT_YUV444P, PIX_FMT_BGRA, PIX_FMT_NONE };\n\n            }\n\n        }\n\n\n\n        for (; *p != PIX_FMT_NONE; p++)\n\n            avio_printf(s, \"%s:\", av_get_pix_fmt_name(*p));\n\n        len = avio_close_dyn_buf(s, &ret);\n\n        ret[len - 1] = 0;\n\n        return ret;\n\n    } else\n\n        return NULL;\n\n}\n", "idx": 16693, "substitutes": {"ost": ["oc", "ist", "dd", "rost", "ob", "op", "pod", "nt", "gg", "ut", "ST", "iol", "design", "ont", "irst", "osta", "od", "boot", "opt", "word", "est", "tt", "rest", "ot", "hop", "ocr", "ld", "object", "o", "art", "tto", "rob", "obs", "rot", "ober", "OST", "oy", "et", "ood", "ft", "org", "oh", "mot", "src", "oper", "node", "hyd", "sta", "oop", "host", "ott", "oid", "ad", "post", "rss", "ust", "ogg", "ud", "orb", "inst", "\u00f3", " nost", "boost", "oss", "rog", "ort", "ord", "feed", "ast", "ods", "rod", "otype", "roc", "old", "add", "st", "lov", "osc", "http", "os", "oster", "server", "sty"], "p": ["pc", "per", "wp", "m", "t", "fp", "x", "f", "jp", "sp", "pn", "vp", "r", "pe", "n", "i", "bp", "cp", "lp", "pb", "o", "l", "d", "pp", "pi", "q", "pa", "e", "v", "c", "ps", "mp", "b", "pr", "h", "tp", "py", "port", "np", "pt", "P", "u"], "s": ["ns", "spec", "m", "ts", "sg", "session", "f", "settings", "services", "r", "n", "g", "i", "sb", "ss", "ctx", "o", "cs", "socket", "w", "e", "ssl", "ses", "v", "c", "ps", "si", "S", "b", "gs", "sys", "sq", "ds", "u"], "ret": ["code", "rs", "data", "al", "sp", "buffer", "nt", "r", "result", "num", "mem", "resp", "out", "att", "val", "re", "Ret", "back", "q", "seq", "RET", "res", "proc", "opt", "Len"], "len": ["per", "bin", " n", "net", "lit", "nt", "fun", "fin", "pos", "mem", " l", "en", "count", "resp", " el", "L", "lf", "ln", "val", "size", "length", " length", "rev", "seq", " clen", "Len"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE int16 extractFloat64Exp( float64 a )\n\n{\n\n\n\n    return ( a>>52 ) & 0x7FF;\n\n\n\n}\n", "idx": 6844, "substitutes": {"a": ["abc", "as", "area", "ea", "na", "alpha", "la", "pa", "va", "value", "aa", "b", "x", "data", "i", "ae", "m", "ia", "l", "ma", "ga", "f", "u", "an", "e", "da", "A", "ab", "ba", "p", "input", "ca", "h", "sup", "sa", "c", "ac", "aux", "r"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void arm_mptimer_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = arm_mptimer_realize;\n\n    dc->vmsd = &vmstate_arm_mptimer;\n\n    dc->reset = arm_mptimer_reset;\n\n    dc->no_user = 1;\n\n    dc->props = arm_mptimer_properties;\n\n}\n", "idx": 23277, "substitutes": {"klass": [" kcl", "skclass", "kslass", "kcl", "ksclass", " klasses", "kscl", "Klass", "sklasses", " kclass", "Kcl", "kclass", "sklass", "klasses", " kass", "skass", "Klasses", "kslasses", "kass", "Kass", "Kclass"], "data": ["after", "i", "def", "config", "ui", "this", "input", "Data", "ata", "exec", "info", "da", "cache", "dd", "load", "rc", "DATA", "loader", "session", "di", "parent", "dat", "api"], "dc": ["md", "lc", "bc", "fc", "cd", "cc", "conn", "config", "controller", "db", "cm", "d", "DC", "pc", "ds", "css", "df", "nc", "ga", "ac", "da", "cat", "dd", "design", "mc", "cf", "ctrl", "tc", "dr", "c", "rc", "spec", "dt", "dk", "tk", "gc", "cr", "enter", "fd", "cdn", "loc", "cca", "jc", "di", "doc", "dat", "disc", "ec", " DC", "vc"]}}
{"project": "qemu", "commit_id": "45b339b18c660eb85af2ba25bfcaed5469660d77", "target": 0, "func": "static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *async, uint32_t *int_mask)\n\n{\n\n    int len = 0, max_len, err, ret;\n\n    uint8_t pid;\n\n\n\n    max_len = ((td->token >> 21) + 1) & 0x7ff;\n\n    pid = td->token & 0xff;\n\n\n\n    ret = async->packet.result;\n\n\n\n    if (td->ctrl & TD_CTRL_IOS)\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n\n\n    if (ret < 0)\n\n        goto out;\n\n\n\n    len = async->packet.result;\n\n    td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);\n\n\n\n    /* The NAK bit may have been set by a previous frame, so clear it\n\n       here.  The docs are somewhat unclear, but win2k relies on this\n\n       behavior.  */\n\n    td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);\n\n    if (td->ctrl & TD_CTRL_IOC)\n\n        *int_mask |= 0x01;\n\n\n\n    if (pid == USB_TOKEN_IN) {\n\n        if (len > max_len) {\n\n            ret = USB_RET_BABBLE;\n\n            goto out;\n\n        }\n\n\n\n        if ((td->ctrl & TD_CTRL_SPD) && len < max_len) {\n\n            *int_mask |= 0x02;\n\n            /* short packet: do not update QH */\n\n            trace_usb_uhci_packet_complete_shortxfer(async->queue->token,\n\n                                                    async->td);\n\n            return TD_RESULT_NEXT_QH;\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    trace_usb_uhci_packet_complete_success(async->queue->token, async->td);\n\n    return TD_RESULT_COMPLETE;\n\n\n\nout:\n\n    /*\n\n     * We should not do any further processing on a queue with errors!\n\n     * This is esp. important for bulk endpoints with pipelining enabled\n\n     * (redirection to a real USB device), where we must cancel all the\n\n     * transfers after this one so that:\n\n     * 1) If they've completed already, they are not processed further\n\n     *    causing more stalls, originating from the same failed transfer\n\n     * 2) If still in flight, they are cancelled before the guest does\n\n     *    a clear stall, otherwise the guest and device can loose sync!\n\n     */\n\n    while (!QTAILQ_EMPTY(&async->queue->asyncs)) {\n\n        UHCIAsync *as = QTAILQ_FIRST(&async->queue->asyncs);\n\n        uhci_async_unlink(as);\n\n        uhci_async_cancel(as);\n\n    }\n\n\n\n    switch(ret) {\n\n    case USB_RET_STALL:\n\n        td->ctrl |= TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        trace_usb_uhci_packet_complete_stall(async->queue->token, async->td);\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_BABBLE:\n\n        td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        /* frame interrupted */\n\n        trace_usb_uhci_packet_complete_babble(async->queue->token, async->td);\n\n        return TD_RESULT_STOP_FRAME;\n\n\n\n    case USB_RET_NAK:\n\n        td->ctrl |= TD_CTRL_NAK;\n\n        if (pid == USB_TOKEN_SETUP)\n\n            break;\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_IOERROR:\n\n    case USB_RET_NODEV:\n\n    default:\n\n\tbreak;\n\n    }\n\n\n\n    /* Retry the TD if error count is not zero */\n\n\n\n    td->ctrl |= TD_CTRL_TIMEOUT;\n\n    err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;\n\n    if (err != 0) {\n\n        err--;\n\n        if (err == 0) {\n\n            td->ctrl &= ~TD_CTRL_ACTIVE;\n\n            s->status |= UHCI_STS_USBERR;\n\n            if (td->ctrl & TD_CTRL_IOC)\n\n                *int_mask |= 0x01;\n\n            uhci_update_irq(s);\n\n            trace_usb_uhci_packet_complete_error(async->queue->token,\n\n                                                 async->td);\n\n        }\n\n    }\n\n    td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |\n\n        (err << TD_CTRL_ERROR_SHIFT);\n\n    return TD_RESULT_NEXT_QH;\n\n}\n", "idx": 4315, "substitutes": {"s": ["o", "is", "S", "spec", "sg", "session", "si", "sys", "ses", "m", "status", "f", "ns", "state", "sl", "ls", "service", "cs", "ss", "conf", "sis", "sie", "sb", "se", "secondary", "su", "p", "south", "sv", "fs", "sa", "os", "g", "ssl", "sq", "rs", "r"], "td": ["lang", "dh", "elt", "data", "token", "typ", "d", "det", "sd", "ht", "lc", "dt", "pb", "lf", "nd", "cd", "tf", "st", "dn", "nt", "wn", "ctl", " dd", "lt", "pt", "tif", "table", "sth", "tw", "butt", "ds", "zh", "ts", "ld", "txt", "cod", "pl", "ff", "std", "email", "md", "bd", "dat", "tmp", "dial", "ad", "BT", "th", "db", " sd", "tl", "att", "pc", "wd", "sb", "tn", "dev", "t", "tm", "cmd", "gb", "ind", "ssl", "fd", "dl", "TD", "od", "dd", "pd", "rd", "edd", "kt", "ln", "cz", "fc"], "async": ["ASync", "rassync", "asssync", "Assync", "asyn", "aynchron", "abscent", "ASynchron", "acynchronous", "rasynchronous", "assynchronous", "ASsync", "Asynchronous", "aync", "acyn", "ASyn", "ayn", "ASynchronous", "assynchron", " assync", "aynchronous", "abssync", "ascent", "rasync", "asynchronous", "acync", " asynchron", "acsync", "Async", "asynchron", "assync", "absynchronous", " ascent", "rasyn", "Ascent", "rasynchron", "Asyn", "Asynchron", " asynchronous", "absync", "assyn", " asyn"], "int_mask": ["int1ask", "const_mask", "const_ask", "const128limit", "int_sum", "int1map", "const_offset", "const_limit", "int_map", "int1mask", "int128ask", " int_ask", "const_map", "int128limit", "int64limit", "int128counter", "const128counter", " int_map", "int_limit", "int_ask", " int_sum", "const128mask", "const128ask", "const_counter", "int_counter", "int64mask", "const_hack", "int128mask", "int1sum", "int64ask", "int64counter", "int_hack", "int_offset"], "max_len": ["max33lif", "max33lang", "maxlogfail", "max64len", "min_lin", "max__fail", "max_el", " max_lif", "max33pos", "max_Len", "min_fail", "maxlogel", " max_lang", "maxlogpos", "max__len", "max_lif", "max64en", "max__lif", " max_en", " max_length", "max_pos", "max__el", "min_val", "max_lang", "maxloglen", "min_pos", " max_pos", "max__pos", "max_length", "min_len", " max_Len", "max33len", "min_length", "max64length", "max_fail", "max_lin", "min_el", "max64Len", "max_en", "max_val", "max__lang"], "err": ["cmp", "er", "cur", "rr", "spec", "progress", "mid", "exc", "sys", "attr", "res", "error", "arr", "dev", "rx", "cb", "str", "rev", "req", "mr", "ver", "proc", "fun", "ind", "resp", "cache", "conn", "msg"], "ret": ["flag", "reg", "rt", "el", "al", "alt", "mem", "cur", "nt", "pat", "pre", "rot", "lt", "val", "last", "bit", "cat", "format", "reply", "status", "db", "fin", "lit", "att", "pet", "obj", "arg", "res", "match", "def", "des", "len", "code", "det", "arr", "RET", "mi", "feat", "rl", "rev", "result", "seq", "Ret", "ft", "opt", "re", "fun", "back", "resp", "success", "ref", "fi", "rep", "group", "r", "rets", "msg"], "pid": ["plugin", "uid", "od", "bin", "id", "vid", "pin", "ci", "nt", "pa", "mid", " dd", "val", "pd", "si", "token", "sn", "perm", "pt", " proc", "ix", "db", "pi", "phi", "pri", "pet", "d", "pc", " p", " conn", "py", "sid", "len", " pin", "ds", "kid", "pad", "mi", "ticket", "p", "pty", " pos", " pc", "prop", "pos", "pointer", "proc", "ind", " id", "ip", "fd", "oid", "pron", "pb", "addr", "conn", " tid", "slot"], "as": ["ans", "act", "er", "ann", "are", "al", "is", "a", "nas", "aster", "asa", "pas", "alias", "or", "ap", "ad", "AS", "with", "was", "at", "las", "ai", "bs", "an", "ay", "ak", "ar", "asp", "action", "As", "ask", "task", "ais", "asha", "am", "acs", "sa", "os", "var", "ms", "asc", "ach", "ac", "app", "es", "ras", "ast", "ass", "aw"]}}
{"project": "qemu", "commit_id": "9d27abd94fe2c48281a77112d58422b392a80f7b", "target": 0, "func": "static void cpu_x86_dump_state(FILE *f)\n\n{\n\n    int eflags;\n\n    char cc_op_name[32];\n\n    eflags = cc_table[CC_OP].compute_all();\n\n    eflags |= (DF & DF_MASK);\n\n    if ((unsigned)env->cc_op < CC_OP_NB)\n\n        strcpy(cc_op_name, cc_op_str[env->cc_op]);\n\n    else\n\n        snprintf(cc_op_name, sizeof(cc_op_name), \"[%d]\", env->cc_op);\n\n    fprintf(f, \n\n            \"EAX=%08x EBX=%08X ECX=%08x EDX=%08x\\n\"\n\n            \"ESI=%08x EDI=%08X EBP=%08x ESP=%08x\\n\"\n\n            \"CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\\n\"\n\n            \"EIP=%08x\\n\",\n\n            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], \n\n            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], \n\n            env->cc_src, env->cc_dst, cc_op_name,\n\n            eflags & DF_MASK ? 'D' : '-',\n\n            eflags & CC_O ? 'O' : '-',\n\n            eflags & CC_S ? 'S' : '-',\n\n            eflags & CC_Z ? 'Z' : '-',\n\n            eflags & CC_A ? 'A' : '-',\n\n            eflags & CC_P ? 'P' : '-',\n\n            eflags & CC_C ? 'C' : '-',\n\n            env->eip);\n\n#if 1\n\n    fprintf(f, \"ST0=%f ST1=%f ST2=%f ST3=%f\\n\", \n\n            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));\n\n#endif\n\n}\n", "idx": 4337, "substitutes": {"f": ["fen", "fr", "tf", "feed", "sf", "v", "s", "b", "rf", "i", "m", "fx", "l", "d", "j", "fe", "buffer", "e", "w", "file", "fn", "t", "df", "xf", "n", "fp", "filename", "p", "h", "fs", "c", "g", "fd", "fc", "fi", "r", "F", "af"], "eflags": ["eflases", "efllages", "efdlag", "efdlagg", "efdlages", "eflatts", "eflcases", "eflbags", "eblars", "efrales", "alfdlagg", "efliugs", "evllugs", "ecdlag", "evrag", "eflaags", "efplags", "efliacks", "ecloages", "efplages", "ecdlags", "efliagn", "eflinks", "evlaches", "eflaugs", "efloars", "eflcagn", "eclagn", "alflats", "eflays", "alfflages", "efslags", "efliales", "efdlacks", "efsags", "efrag", "eflbases", "eflaages", "efgags", "ecloagn", "eflcag", "eflcars", "efslats", "efflugs", "eflaats", "ecloars", "efflcases", "efflcatts", "evllag", "eclays", "eclugs", "eflugs", "efllags", "alfdlags", "efgaches", "efllats", "ecdlales", "eblacks", "efslag", "efllinks", "evlags", "eblugs", "alflages", "eflaars", "alfflugs", "efflags", "efcag", "efliays", "efloagn", "efrags", "efflatts", "efflages", "efflases", "eclags", "efgag", "ecsales", "efflcags", "alflags", "evrats", "eblags", "eclars", "eclales", "efdlugs", "alflugs", "eflag", "eflagn", "efsag", "eflcatts", "ecloags", "efslinks", "ebliugs", "eflats", "ebliags", "eflcags", "eflagg", "alfdlages", "eflales", "efsays", "efliag", "eflbatts", "evrags", "eflyats", "efliages", "evlinks", "evrinks", "ecsays", "efrinks", "eflbats", "eflyases", "efllag", "eflcugs", "evrages", "eflars", "evllages", "efdlales", "efrages", "alfdlars", "ebliacks", "efplag", "eflyatts", "efliags", "eflcages", "alflars", "eflcats", "evraches", "efflcats", "eflcales", "efrats", "eflyags", "eflaagg", "efflats", "efdlars", "eclag", "eclages", "evlugs", "efloages", "evlats", "ebliars", "efllugs", "eflaches", "eflcagg", "evllags", "alfflags", "efdlags", "ecsag", "alfflats", "efliars", "efraches", "ecsags", "efllacks", "eflages", "efcags", "efcages", "efrays", "efgages", "alflagg", "efllars", "evlages", "efcaches", "efplugs", "efsales", "efloags", "eflacks", "evlag", "ecdlugs"], "cc_op_name": ["cc_oper_str", "cc_op_path", "cc_oper_id", "cc_oper_name", "cc_op_str", "cc_op_names", "cc_op_id", "cc_oper_path", "cc_op_size", "cc_oper_no", "cc_op_type", "cc_op_no", "cc_oper_names", "cc_oper_size", "cc_oper_type"]}}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "static void qemu_tcg_init_vcpu(CPUState *cpu)\n\n{\n\n    char thread_name[VCPU_THREAD_NAME_SIZE];\n\n    static QemuCond *tcg_halt_cond;\n\n    static QemuThread *tcg_cpu_thread;\n\n\n\n    /* share a single thread for all cpus with TCG */\n\n    if (!tcg_cpu_thread) {\n\n        cpu->thread = g_malloc0(sizeof(QemuThread));\n\n        cpu->halt_cond = g_malloc0(sizeof(QemuCond));\n\n        qemu_cond_init(cpu->halt_cond);\n\n        tcg_halt_cond = cpu->halt_cond;\n\n        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, \"CPU %d/TCG\",\n\n                 cpu->cpu_index);\n\n        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,\n\n                           cpu, QEMU_THREAD_JOINABLE);\n\n#ifdef _WIN32\n\n        cpu->hThread = qemu_thread_get_handle(cpu->thread);\n\n#endif\n\n        while (!cpu->created) {\n\n            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);\n\n        }\n\n        tcg_cpu_thread = cpu->thread;\n\n    } else {\n\n        cpu->thread = tcg_cpu_thread;\n\n        cpu->halt_cond = tcg_halt_cond;\n\n    }\n\n}\n", "idx": 8457, "substitutes": {"cpu": ["kernel", "cmp", "gpu", "bench", "net", "python", "config", "thread", "computer", "np", "cn", "gp", "frame", " CPU", "gnu", "process", "lb", "cpp", "nc", "gc", "fc", "mac", "chip", "que", "instance", "vm", "component", "uci", "hw", "performance", "pai", "colo", "clock", "fps", "winner", "loader", "CPU", "lc", "cus", "uca", "boot", "conn", "uno", "consumer", "GPU", "cp", "cu", "cli", "fp", "cube", "eni", "linux", "home", "intel", "custom", "node", "gru", "px", "cache", "core", "mc", "cdn", "processor", "phy", "auc", "userc", "qa", "queue", "console", "name", "ctx", "pu", "pc", "nic", "platform", "null", "css", "proc", "roc"], "thread_name": [" thread_names", "condalname", "thread2names", "condalindex", "cond_size", "threadalsize", "connection_name", " thread_NAME", "thread_size", "connection_type", "threadalindex", "threadsname", "cond_number", "thread_number", "thread_len", "cond_name", "thread_names", "condalnumber", "threadslen", "threadssize", "threadalnumber", "thread_type", "thread_index", "connection_size", "thread2name", "threadstype", "connection_len", "thread_NAME", "cond_index", "threadalname", "thread2NAME", "condalsize"], "tcg_halt_cond": ["tcg_halt_reason", "tcg_halturecondition", "tcg_halt__code", "tcg_halt2code", "tcg_hort2cond", "tcg_halt_condition", "tcg_halt2reason", "tcg_hort_cond", "tcg_hait_cond", "tcg_haltingconnection", "tcg_halt_connection", "tcg_hort2reason", "tcg_hal_cond", "tcg_halt_Cond", "tcg_haltureCond", "tcg_halt2cond", "tcg_halt__reason", "tcg_halturecond", "tcg_halt2condition", "tcg_hait_condition", "tcg_haltingcondition", "tcg_hal_Cond", "tcg_hort_code", "tcg_hait_Cond", "tcg_haltingcond", "tcg_halturecmd", "tcg_hort2code", "tcg_halt__cond", "tcg_hort_condition", "tcg_halt_code", "tcg_hal_connection", "tcg_hort_reason", "tcg_halt_cmd", "tcg_halt__condition", "tcg_hait_cmd", "tcg_hal_condition", "tcg_haltingCond", "tcg_hort2condition"], "tcg_cpu_thread": ["tcg_cpu__process", "tcg_cpu__method", "tcg_cpu2cond", "tcg_cpu_process", "tcg_gpu_loop", "tcg_gpu_method", "tcg_cpu_worker", "tcg_gpu_connection", "tcg_cpu2method", "tcg_cpu2loop", "tcg_gpu_cond", "tcg_cpu_connection", "tcg_cpu2process", "tcg_gpu_thread", "tcg_cpu_loop", "tcg_gpu_process", "tcg_gpu_worker", "tcg_cpu__thread", "tcg_cpu2thread", "tcg_cpu__loop", "tcg_cpu_cond", "tcg_cpu_method", "tcg_cpu2connection"]}}
{"project": "FFmpeg", "commit_id": "295b79b5d8c0cf0a9691f8d6b512aa1e289d528d", "target": 1, "func": "static av_cold int roq_encode_init(AVCodecContext *avctx)\n{\n    RoqContext *enc = avctx->priv_data;\n    av_lfg_init(&enc->randctx, 1);\n    enc->framesSinceKeyframe = 0;\n    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions must be divisible by 16\\n\");\n        return AVERROR(EINVAL);\n    if (avctx->width > 65535 || avctx->height > 65535) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions are max %d\\n\", enc->quake3_compat ? 32768 : 65535);\n        return AVERROR(EINVAL);\n    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))\n        av_log(avctx, AV_LOG_ERROR, \"Warning: dimensions not power of two, this is not supported by quake\\n\");\n    enc->width = avctx->width;\n    enc->height = avctx->height;\n    enc->framesSinceKeyframe = 0;\n    enc->first_frame = 1;\n    enc->last_frame    = av_frame_alloc();\n    enc->current_frame = av_frame_alloc();\n    if (!enc->last_frame || !enc->current_frame) {\n    enc->tmpData      = av_malloc(sizeof(RoqTempdata));\n    enc->this_motion4 =\n        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->last_motion4 =\n        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->this_motion8 =\n        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));\n    enc->last_motion8 =\n        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));\n    return 0;", "idx": 5754, "substitutes": {"avctx": ["akcontext", " avcf", "archconn", "archcontext", " avvoc", "avedc", "apscontext", "AVlc", "archctx", "vercu", "navcontext", "aveloc", "aveconfig", "afctx", "avalcu", "Avloc", "vertx", "ajctx", "navctx", "afdc", "avcli", " avcontext", "avcdn", "avalvoc", "avevoc", "Avconn", "afloc", "afcmp", "avcmp", "akctx", "avecli", "apsconn", "avectl", "avalctx", "aveconn", "Avctx", "avecontext", "akconn", "afcf", "avlc", "avalsci", "avecdn", "ajcmp", " avcu", "AVconn", "aksci", "avecu", "avelc", "avalcontext", "afcli", "navconfig", "aflc", "afctl", "vercontext", "avcu", "navcmp", "avconfig", "AVcontext", "afsci", "avcontext", "afcdn", "avvoc", "avsci", "verloc", "apscdn", "avesci", "avloc", "avconn", "avctl", "avdc", "verconn", "avectx", "avetx", "AVctx", "akloc", "avcf", "aftx", "avalconn", "avecf", "avtx", "archctl", "ajcli", "Avcontext", "verctx", "akcu", "afconn", "apsctx", "afcontext", "afvoc", "afconfig", "ajcontext", " avconn", "avaldc", "vercmp", "avecmp", "afcu"], "enc": ["lang", "anne", "el", "oa", "et", "auc", "nec", "uc", "ev", "code", "con", "acl", "bc", "exec", "equ", "ou", "ec", "ver", "ct", "lc", "ac", "conn", "rec", "oc", "pack", "ocr", "build", "unc", "cur", "acc", "nt", "config", "nc", "eu", "sl", "Enc", "lib", "ent", "ctx", "win", "ee", "node", "adr", "util", "env", "bn", "oder", "ENC", "eng", "act", "hw", "ann", "nw", "sec", "rc", "cat", "loc", "kg", "inc", "ext", "pc", "cc", "ce", "e", "en", "oy", "dev", "ant", "ic", "c", "ssl", "adj", "cache", "vc", "app", "cel", "ch", "anc", "emb", "od", "ell", "sys", "ae", "rh", "mac", "client", "dc", "load", "coll", "ang", "eni", "iv", "fc", "ew", "cdn"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int sig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct rt_sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t    \t   && current->exec_domain->signal_invmap\n\n\t\t    \t   && sig < 32\n\n\t\t    \t   ? current->exec_domain->signal_invmap[sig]\n\n\t\t\t   : */sig),\n\n\t\t\t  &frame->sig);\n\n\terr |= __put_user((target_ulong)&frame->info, &frame->pinfo);\n\n\terr |= __put_user((target_ulong)&frame->uc, &frame->puc);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Create the ucontext.  */\n\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\n\terr |= __put_user(0, &frame->uc.uc_link);\n\n\terr |= __put_user(/*current->sas_ss_sp*/ 0, &frame->uc.uc_stack.ss_sp);\n\n\terr |= __put_user(/* sas_ss_flags(regs->esp) */ 0,\n\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\n\terr |= __put_user(/* current->sas_ss_size */ 0, &frame->uc.uc_stack.ss_size);\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\n\t\t\t        env, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb8, (char *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_rt_sigreturn, (int *)(frame->retcode+1));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+5));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 12741, "substitutes": {"sig": ["psigs", " sigs", "nsIG", "pock", "ssigs", "psigma", "gsIG", "setsigh", "sesigma", "pigma", "SIG", "dsigma", "nsigma", "sesigs", "ssock", "sesig", "setsig", "sesigh", "gsigs", "sigma", "setsigma", "nsigs", "pig", "sIG", "pigs", "sigs", " sIG", "psock", "ssig", "nsig", "setsIG", "Sig", "gsigma", " sigma", "gsig", "sesIG", "dsigh", "sock", "Sigs", "ssigma", "sigh", "dsig", "Sigma", "psig", "dsIG"], "ka": ["aka", "ua", "area", "sta", "eka", "ha", "qa", "ca", "ea", "ai", "ja", "ia", "ker", "da", "oa", "LA", "ta", "ko", "ra", "za", "KA", "ki", "na", "ema", "ama", "qua", "cha", "la", "ba", "ku", "ket", "kt", "au", "ma", "cca", "sc", "wa", "va", "kb", "ga", "sa", "ya", "asa", "ae", "ctx"], "info": ["zip", "hi", "path", "isu", "ui", "context", " inf", "uc", "ai", "config", "id", "ini", "i", "inf", "code", "up", "home", "api", "name", "ci", "source", "image", "py", "fo", "about", "init", "si", "update", "ii", "loc", "hel", "job", "meta", "conf", "buff", "help", "summary", "fi", "mi", "abi", "f", "stat", "information", "inc", "diff", "setup", "INFO", "afi", "iso", "hand", "Info", "ami", "util", "in", "index"], "set": ["en", "context", "sche", "enc", "config", "pre", "SET", "msg", "ex", "send", "section", " en", "status", "ner", "sets", "init", "si", "update", "loc", "setting", "vert", "ut", "parse", "clear", "ind", "se", "e", "eq", "Set", "site", "base", "from", "stat", "store", "dat", "state", "export", "spec", "setup", "reset", "block", "end", "ne", "gen", "sc", "get", "cal", "que", "sh", "exec", "sel", "ise", "iss", "et", "kit", "net", "ze", "start"], "env": ["en", "context", "enc", "ea", "config", "ini", "eu", " en", "si", "init", "loc", "estate", "v", "conf", "np", "stage", "dev", "dict", "e", "ctx", "viron", "exc", "eq", "ind", "data", "eng", "ext", "qt", "dat", "ette", "eni", "ne", "ep", "db", "ev", "et", "ec", "environment", "el", "ise", "vs", "ef", "net"], "frame": ["build", "profile", "motion", "def", "za", "image", "event", "module", "ace", "model", "rame", "base", "raise", "flow", "line", "frames", "c", "class", "cycle", "dr", "lock", "window", "fc", "message", "draw", "call", "part", "slice", "sche", "flower", "session", "cha", "fr", "parse", "version", "fake", "fi", "data", "b", "result", "design", "pe", "function", "body", "layout", "el", "thread", "zip", "ch", "Frame", "fram", "config", "iframe", "fb", "framework", "style", "shot", "connection", "source", "plane", "cpu", "section", "game", "update", "scope", "step", "element", "role", "view", "layer", "processor", "stage", "e", "boot", "note", "f", "point", "none", "cfg", "feature", "state", "fe", "block", "ne", "cf", "load", "que", "hop", "scene", "plate", "ctx", "node", "tick", "ze", "jp", "code", "object", "range", "row", "user", "position", "feat", "component", "nil", "setup", "next", "file", "target", "figure", "seq"]}}
{"project": "FFmpeg", "commit_id": "8089b7fa8c5b5a48cc7101daa4be891d0ead5a5e", "target": 1, "func": "int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)\n\n{\n\n    int64_t intnum=1;\n\n    double num=1;\n\n    int den=1;\n\n\n\n    av_get_number(obj, name, o_out, &num, &den, &intnum);\n\n    return num*intnum/den;\n\n}\n", "idx": 11806, "substitutes": {"obj": ["arr", "img", "nb", "n", "val", "prefix", "nt", "src", "b", "ab", "iv", "buf", "ref", "Obj", "attr", "cb", "po", "act", "rb", "js", "os", "ut", "inst", "orb", "code", "j", "o", "oa", "opt", "ctx", "object", "oid", "emb", "pos", "ob", "io", "obb", "adj"], "name": ["parent", "alias", "NAME", "base", "n", "val", "comment", "prefix", "key", "word", "w", "id", "info", "path", "filename", "num", "nam", "data", "time", "names", "cn", "f", "o", "named", "size", "min", "object", "option", "new", "part", "ns", "type", "ame", "out", "ann", "Name"], "o_out": ["o_OUT", "o_outs", "o__in", "o__OUT", "o_in", " o_array", " o_in", "o__outs", " o_outs", " o_OUT", "o_array", "o__out"]}}
{"project": "qemu", "commit_id": "f94d18d6c6df388fde196d3ab252f57e33843a8b", "target": 0, "func": "static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n\n{\n\n    XHCIState *xhci = epctx->xhci;\n\n    XHCIStreamContext *stctx;\n\n    XHCITransfer *xfer;\n\n    XHCIRing *ring;\n\n    USBEndpoint *ep = NULL;\n\n    uint64_t mfindex;\n\n    int length;\n\n    int i;\n\n\n\n    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);\n\n\n\n    /* If the device has been detached, but the guest has not noticed this\n\n       yet the 2 above checks will succeed, but we must NOT continue */\n\n    if (!xhci->slots[epctx->slotid - 1].uport ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {\n\n        return;\n\n    }\n\n\n\n    if (epctx->retry) {\n\n        XHCITransfer *xfer = epctx->retry;\n\n\n\n        trace_usb_xhci_xfer_retry(xfer);\n\n        assert(xfer->running_retry);\n\n        if (xfer->timed_xfer) {\n\n            /* time to kick the transfer? */\n\n            mfindex = xhci_mfindex_get(xhci);\n\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n\n            if (xfer->running_retry) {\n\n                return;\n\n            }\n\n            xfer->timed_xfer = 0;\n\n            xfer->running_retry = 1;\n\n        }\n\n        if (xfer->iso_xfer) {\n\n            /* retry iso transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            assert(xfer->packet.status != USB_RET_NAK);\n\n            xhci_complete_packet(xfer);\n\n        } else {\n\n            /* retry nak'ed transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            if (xfer->packet.status == USB_RET_NAK) {\n\n                return;\n\n            }\n\n            xhci_complete_packet(xfer);\n\n        }\n\n        assert(!xfer->running_retry);\n\n        xhci_ep_free_xfer(epctx->retry);\n\n        epctx->retry = NULL;\n\n    }\n\n\n\n    if (epctx->state == EP_HALTED) {\n\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n\n        return;\n\n    }\n\n\n\n\n\n    if (epctx->nr_pstreams) {\n\n        uint32_t err;\n\n        stctx = xhci_find_stream(epctx, streamid, &err);\n\n        if (stctx == NULL) {\n\n            return;\n\n        }\n\n        ring = &stctx->ring;\n\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n\n    } else {\n\n        ring = &epctx->ring;\n\n        streamid = 0;\n\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n\n    }\n\n    assert(ring->dequeue != 0);\n\n\n\n    while (1) {\n\n        length = xhci_ring_chain_length(xhci, ring);\n\n        if (length <= 0) {\n\n            break;\n\n        }\n\n        xfer = xhci_ep_alloc_xfer(epctx, length);\n\n        if (xfer == NULL) {\n\n            break;\n\n        }\n\n\n\n        for (i = 0; i < length; i++) {\n\n            TRBType type;\n\n            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);\n\n            assert(type);\n\n        }\n\n        xfer->streamid = streamid;\n\n\n\n        if (epctx->epid == 1) {\n\n            xhci_fire_ctl_transfer(xhci, xfer);\n\n        } else {\n\n            xhci_fire_transfer(xhci, xfer, epctx);\n\n        }\n\n        if (xfer->complete) {\n\n            xhci_ep_free_xfer(xfer);\n\n            xfer = NULL;\n\n        }\n\n\n\n        if (epctx->state == EP_HALTED) {\n\n            break;\n\n        }\n\n        if (xfer != NULL && xfer->running_retry) {\n\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n\n            epctx->retry = xfer;\n\n            break;\n\n        }\n\n    }\n\n\n\n    ep = xhci_epid_to_usbep(epctx);\n\n    if (ep) {\n\n        usb_device_flush_ep_queue(ep->dev, ep);\n\n    }\n\n}\n", "idx": 6532, "substitutes": {"epctx": ["eptx", "epcoll", "pplc", "epslc", "mpchan", "Epctx", "ipctx", "ekcontext", "epsctx", "mpcf", "epscmp", " epctr", "ppctx", "ppcb", "mpconfig", " eprc", " epcmp", "epsconfig", "ekcoll", "epchan", "epcf", "ppcontext", "epscontext", "evcb", "evcontext", "epcache", "ypcmp", "mpcoll", "mpctr", "epcmp", "epscb", "epconfig", "ekctr", "ypctx", "mprc", "mpctx", "ekctx", "mplc", "eprc", "mpcb", "ppcache", "Epcontext", "mpcache", "ypconfig", "ipcontext", "ekchan", "epctr", "ypcontext", "epcontext", "mptx", "eplc", "epsrc", "eklc", "ekcache", "ypcb", "pptx", "epstx", "evtx", "ipcb", "epcb", "ekcf", " epcoll", "yptx", "mpcmp", "ipcmp", "Epcf", "ppcmp", "Epchan", "evctx", "mpcontext", " epcontext"], "streamid": [" streamtype", "reamname", "reamId", "pooltype", "streamtype", " streamID", "poolId", "poolname", " streamId", "streamID", "streamId", "poolid", " streamname", "reamID", "reamtype", "streamname", "reamid", "poolID"], "xhci": ["xehdi", "workhlc", "xhlc", "exhoci", "xhdci", "xhdcli", "xhsci", "xhoci", "xhldi", "workhscit", "exhsi", "xhdcin", "workhci", "xmcycle", "wxhco", "xhcci", "xxhsco", "xhdc", "xhcu", "xhscci", "workhni", "ixhcin", "xhai", "wxhsci", "wxhsni", "xahcit", "xrhci", "xehoci", "xhloci", "xhddi", "workhsai", "workhslc", "xhcm", "ixhcycle", "wxhsco", "ixhdcycle", "xehsi", "xbhcu", "xhmci", "xhcit", "xehcu", "xhni", "xvcm", "xxhsci", "wxhni", "xehci", "ixhci", "xhsdc", "yehcci", "xhcli", "xhmcli", "xvcci", "ixhdcin", "xhsi", "exehci", "xrhni", "workhsdi", "ixhcli", "ixhdci", "xbhcci", "yhcit", "workhdi", "xhdcycle", "xxhci", "xhllc", "xahco", "xhcycle", "xvcu", "workhai", "xvcit", "xmcin", "xmcli", "xvco", "yhcu", "xrhcit", "xhdsi", "xehni", "wxhscci", "xvlc", "xhdoci", "xehco", "xehcci", "xxhscm", "workhsci", "xhsdi", "yehcu", "xmci", "yehci", "xhmcin", "xvdi", "xhlsi", "xhldc", "xxhcm", "exehsi", "xehcm", "exehdi", "exhdi", "xhscit", "xrhai", "xhmcycle", "workhdc", "xhdi", "workhcit", "yhcci", "xbhci", "xhsni", "xhslc", "xbhcit", "xvci", "exehoci", "wxhcci", "xvdc", "xxhco", "xahcci", "workhsni", "xahai", "xhsco", "xhlci", "ixhdcli", "workhsdc", "xxhscci", "xahni", "yehcit", "exhci", "xhscm", "xhsai", "xxhcci", "xahci", "xhco", "wxhci", "yhci", "xehcit", "xhcin"], "stctx": ["artcontext", "epconf", "crcontext", "crconf", "crctx", "stconf", "artctx", "stcontext", "crconn", "artconn", "artconf", "epcontext", "stconn", "epconn"], "xfer": ["yter", "sexfr", "interper", "ytransfer", "yclude", "swfr", "fuelFER", " xper", "yher", " xcer", "crossper", "Xher", "axmer", "axFER", "fxporter", "axporter", "crossferred", "xper", "hardfort", "workger", "interpper", "xxFER", "Xfar", "wxpire", "yfort", "xxfar", "xxception", "crossmer", "sexporter", "axcer", "xpire", "lexf", " xception", "fxper", "crossger", "axher", " xmor", "axferred", "lexference", "helcer", "xyference", "xcer", "swper", "swger", "wxf", "yfr", "axpper", "Xporter", " xber", "xher", "crossFER", "workfr", " xclude", "xporter", "xxferred", "broadfer", "broadpper", "fxference", "xxpire", "xyfar", "xxter", "helference", "xfr", "sexfer", "crossporter", "fxferred", "xger", "lexporter", "swfer", "fuelfer", "crosspper", "Xter", " xter", "helfer", "fuelporter", " xf", "infer", "xxher", " xporter", "xpper", "Xcer", "Xfer", "Xfr", " xtransfer", "inference", "yper", "wxference", " xpper", "wxfr", "crosscer", "hardference", "Xference", "xtransfer", "axference", "broadferred", "lexher", "interfer", "fxfer", "xter", "yfer", "crossfer", "axfr", "XFER", "xyfer", "xfar", "xf", "crossference", "lexber", "wxfer", "lexmer", "xxper", " xpire", "yporter", "xclude", "fxFER", "lexfer", "lexfr", "xxporter", "workference", "workcer", "xxfer", "helpire", "xfort", "xception", " xher", " xfr", "ypire", "workf", "xxference", "workception", "sexfort", "xxmor", "interference", "workporter", "xber", "workfer", "hardfer", "Xpire", "xmor", "xference", "wxcer", "Xtransfer", "inFER", "sexference", "xferred", "axpire", "axclude", "crossfr", "fuelferred", "xFER", "broadcer", "ymor", "xmer", "xxger", "crosspire", "hardporter", "yference", "axber", "fxpper", "crossher", " xger", "axper", "inporter", "axfer", " xFER", "xxtransfer", "xyter", "yger", " xference"], "ring": ["rw", "ig", "reg", "rr", "Ring", "spec", "chain", "binding", "RW", "ING", "ng", "rss", "file", "path", "RP", "str", "amp", "root", "rings", "remote", "range", "orig", "RR", "link", "pair", "ref", "rs", "prefix"], "ep": ["cp", "yp", "gp", "eng", "imp", "elf", "ever", "ef", "channel", "plug", "gap", "pp", "wp", "pipe", "ap", "lp", "enc", "peer", "EP", "package", "mp", "ext", "eq", "ream", "Ep", "ev", "e", "dp", "eg", "dc", "exec", "fp", "eps", "p", "ee", "amp", "ec", "vp", "sp", "cap", "ip", "dep", "env", "pkg"], "mfindex": [" mfopen", "mfopen", "mfpIndex", "mdfindex", "umvindex", "mfwIndex", "MFname", "mFname", "mfwindex", " mrfopen", "mfnumber", "mfwname", "mfpid", "Mfname", "MfIndex", "mflevel", " mrfid", "mFIndex", "mfIndex", " mrfindex", "mvlevel", "Mfnumber", " mfid", "mrfopen", "mfpinc", "umfindex", "umvinc", "mdfinc", "mfpindex", "umfdate", "MFnumber", "mfid", "mvindex", "mvdate", "umvlevel", "mvinc", "mFopen", "MFIndex", "mfwnumber", "mfdate", "mrfid", "umfinc", "mfpopen", "mdfdate", "mFindex", "mfpdate", "MFindex", "umflevel", " mfIndex", "mFid", "mdflevel", "Mfindex", "mrfIndex", "umvdate", "mfname", "mfinc", " mrfIndex", "mrfindex", "mfplevel", "mFnumber"], "length": ["padding", "count", "total", "shape", " lengths", "style", "Length", "loc", "sequence", "weight", "match", "duration", "impl", "len", "path", "load", "ptr", "ength", "size"], "i": ["o", "id", "I", "is", "a", "s", "list", "b", "io", "or", "info", "l", "f", "pi", "d", "code", "e", "n", "p", "h", "z", "start", "c", "ip", "ed", "end"]}}
{"project": "FFmpeg", "commit_id": "560b10a6c3627cccf6735170d370cf9e3d38e805", "target": 1, "func": "static void init_gain_table(COOKContext *q) {\n\n    int i;\n\n    q->gain_size_factor = q->samples_per_channel/8;\n\n    for (i=0 ; i<23 ; i++) {\n\n        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,\n\n                               (1.0/(double)q->gain_size_factor));\n\n    }\n\n    memset(&q->gain_copy, 0, sizeof(COOKgain));\n\n    memset(&q->gain_current, 0, sizeof(COOKgain));\n\n    memset(&q->gain_now, 0, sizeof(COOKgain));\n\n    memset(&q->gain_previous, 0, sizeof(COOKgain));\n\n}\n", "idx": 6999, "substitutes": {"q": ["iq", "v", "cur", "qq", "quad", "config", "qt", "x", "sync", "co", "queue", "m", "quant", "qi", "l", "cal", "cl", "f", "event", "client", "ue", "call", "dq", "d", "ce", "conf", "u", "ck", "e", "que", "comment", "qs", "Q", "k", "t", "self", "work", "question", "qu", "p", "context", "input", "qa", "req", "this", "z", "request", "charge", "c", "g", "sq", "core", "cf", "query", "cache", "requ", "quest"], "i": ["gi", "o", "ti", "v", "id", "I", "count", "a", "chi", "di", "ci", "ni", "b", "x", "si", "xi", "io", "abi", "ri", "info", "bi", "in", "qi", "l", "f", "pi", "yi", "phi", "d", "ii", "j", "length", "iu", "ai", "uli", "it", "u", "e", "uri", "k", "n", "multi", "ini", "ie", "p", "z", "eni", "start", "oi", "hi", "c", "ip", "li", "fi", "index", "r", "zi", "mu", "ui"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        int b= src[i*3+0];\n\n        int g= src[i*3+1];\n\n        int r= src[i*3+2];\n\n\n\n        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);\n\n    }\n\n#endif /* COMPILE_TEMPLATE_MMX */\n\n}\n", "idx": 13205, "substitutes": {"dst": [" dsts", "cdsrc", "bsc", "cdsts", "Dst", "Dsts", "sconst", "bsrc", "dsts", " dsrc", "dconst", " dsc", " dconst", " drc", "lconst", "lsts", "ssts", "dsrc", "sst", "lst", "cdsc", "cdst", "dsc", "Dconst", "lrc", "drc", "bsts", "bst", "Dsrc"], "src": ["rib", "proc", "sync", "fl", "dist", "rc", "config", "cv", "enc", "tmp", "supp", "iv", "ctr", "sup", "source", "conv", "sth", "sr", "sq", "dest", "secure", "loc", "storage", "gl", "lib", "impl", "img", "rb", "pack", "buf", "http", "sb", "reflect", "flash", "inst", "scl", "gb", "url", "cb", "sn", "sc", "ssl", "rob", "cont", "transform", "sl", "text", "sur", "rect", "SOURCE", "rest", "sub", "seq", "sel", "stack", "cur", "st", "support", "ctx"], "unused": ["nonferred", "Unuse", "Unchecked", "unchecked", "nonchecked", " unferred", "unuse", "nonused", " unuse", "Unferred", "unferred", "Unused", " unchecked", "nonuse"], "i": ["hi", "qi", "it", "ui", "m", "adi", "I", "d", "t", "ai", "ni", "xi", "id", "ini", "l", "gi", "iu", "oi", "io", "api", "g", "ci", "mu", "di", "x", "si", "ie", "ii", "v", "uri", "o", "u", "z", "iii", "p", "e", "s", "fi", "info", "cli", "li", "k", "b", "ix", "multi", "j", "phi", "n", "f", "ti", "at", "ip", "c", "is", "anti", "hei", "pi", "r", "bi", "ri", "ami", "zi", "index", "start"]}}
{"project": "qemu", "commit_id": "0e22a2d18998fd183c8181663981eb681ca977e9", "target": 1, "func": "static void vhost_scsi_stop(VHostSCSI *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    int ret = 0;\n\n\n\n    if (!k->set_guest_notifiers) {\n\n        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);\n\n        if (ret < 0) {\n\n                error_report(\"vhost guest notifier cleanup failed: %d\\n\", ret);\n\n        }\n\n    }\n\n    assert(ret >= 0);\n\n\n\n    vhost_scsi_clear_endpoint(s);\n\n    vhost_dev_stop(&s->dev, vdev);\n\n    vhost_dev_disable_notifiers(&s->dev, vdev);\n\n}\n", "idx": 14822, "substitutes": {"s": ["args", "south", "sys", "ses", "m", "self", "service", "sync", "d", "sg", "t", "fs", "i", "rs", "sym", "a", "g", "cs", "S", "settings", "os", "new", "es", "js", "sq", "secure", "server", "v", "session", "storage", "ss", "ps", "conf", "o", "u", "params", "p", "e", "instance", "sf", "b", "sb", "f", "tests", "gs", "less", "spec", "ns", "serv", "c", "is", "ssl", "services", "r", "ds", "su", "ls", "ts", "us", "ks", "aws"], "vdev": ["qdev", " vserial", "fpub", "qdist", " vdiv", "qhost", "qserial", "qdi", "tvtech", "vrhost", "vserial", "ftech", "svdi", " vpub", " vde", "svserial", "vrdev", "fdev", " vdist", "vdiv", "qdevice", "vdi", "fde", "svbus", "vrdevice", "fdiv", "svdevice", "fdevice", "tvpub", "vhost", "vdevice", " vtech", "tvdevice", "svdiv", " vdevice", "vbus", "vdist", " vdi", "tvdev", "vrdist", " vbus", "vpub", " vhost", "vtech", "svde", "vde", "svdev"], "qbus": [" qb", "qubuild", "qhub", "Qb", "quhub", "qb", "qproc", "sqbuild", "Qbus", "qubus", "quickbus", "pproc", "quda", "Qcase", "qbs", "Qproc", "sqda", "pboot", "qucase", "Qbs", "qboot", "Qboot", "qcase", "quproc", "quickbuild", "sqbus", "qubs", "pbus", "quboot", "pbs", "qda", "qbuild", "quickhub", " qboot", "quickda", " qcase", "sqhub", "qub"], "k": ["ke", "dk", "kind", "wk", "ijk", "ak", "tk", "unk", "ko", "g", "kick", " K", "ki", "uk", "sk", "kernel", "key", "kw", "o", "p", "ku", "ok", "ck", "spec", "mk", "c", "K", "q", "kin", "ack", "get", "kb", "ik", "ky", "work", "kid", "ks"]}}
{"project": "FFmpeg", "commit_id": "ae3da0ae5550053583a6f281ea7fd940497ea0d1", "target": 1, "func": "static int decode_band(IVI45DecContext *ctx, int plane_num,\n\n                       IVIBandDesc *band, AVCodecContext *avctx)\n\n{\n\n    int         result, i, t, idx1, idx2, pos;\n\n    IVITile     *tile;\n\n\n\n    band->buf     = band->bufs[ctx->dst_buf];\n\n    if (!band->buf) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Band buffer points to no data!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    band->ref_buf = band->bufs[ctx->ref_buf];\n\n    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);\n\n\n\n    result = ctx->decode_band_hdr(ctx, band, avctx);\n\n    if (result) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error while decoding band header: %d\\n\",\n\n               result);\n\n        return result;\n\n    }\n\n\n\n    if (band->is_empty) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Empty band encountered!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];\n\n\n\n    /* apply corrections to the selected rvmap table if present */\n\n    for (i = 0; i < band->num_corr; i++) {\n\n        idx1 = band->corr[i * 2];\n\n        idx2 = band->corr[i * 2 + 1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n    pos = get_bits_count(&ctx->gb);\n\n\n\n    for (t = 0; t < band->num_tiles; t++) {\n\n        tile = &band->tiles[t];\n\n\n\n        if (tile->mb_size != band->mb_size) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MB sizes mismatch: %d vs. %d\\n\",\n\n                   band->mb_size, tile->mb_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        tile->is_empty = get_bits1(&ctx->gb);\n\n        if (tile->is_empty) {\n\n            ivi_process_empty_tile(avctx, band, tile,\n\n                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));\n\n            av_dlog(avctx, \"Empty tile encountered!\\n\");\n\n        } else {\n\n            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);\n\n            if (!tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Tile data size is zero!\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            result = ctx->decode_mb_info(ctx, band, tile, avctx);\n\n            if (result < 0)\n\n                break;\n\n\n\n            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);\n\n            if (result < 0 || ((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Corrupted tile data encountered!\\n\");\n\n                break;\n\n            }\n\n\n\n            pos += tile->data_size << 3; // skip to next tile\n\n        }\n\n    }\n\n\n\n    /* restore the selected rvmap table by applying its corrections in reverse order */\n\n    for (i = band->num_corr-1; i >= 0; i--) {\n\n        idx1 = band->corr[i*2];\n\n        idx2 = band->corr[i*2+1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n#ifdef DEBUG\n\n    if (band->checksum_present) {\n\n        uint16_t chksum = ivi_calc_band_checksum(band);\n\n        if (chksum != band->checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\\n\",\n\n                   band->plane, band->band_num, band->checksum, chksum);\n\n        }\n\n    }\n\n#endif\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return result;\n\n}\n", "idx": 21708, "substitutes": {"ctx": ["conv", "lc", "bc", "grad", "cam", "cc", "wcs", "support", "gpu", "conn", "sci", "ref", "config", "coll", "pkg", "cv", "kt", "cm", "connection", "crit", "tx", "ca", "anc", "cas", "scl", "cmp", "ci", "nc", "cmd", "cp", "component", "cf", "xc", "ctrl", "kb", "context", "sync", "np", "buf", "rc", "c", "cb", "cn", "bank", "client", "la", "sc", "ann", "cal", "cpp", "cci", "gc", "qa", "media", "fw", "loc", "bm", "cca", "utils", "buff", "cms", "conf", "hw", "ck", "kw", "voc", "concept", "cu", "gb", "vc"], "plane_num": [" sheet_num", " sheet_name", " frame_num", " sheet_no", " sheet_sum", " frame_sum", " frame_name", " frame_no"], "band": ["target", "app", "event", "amp", "config", "part", "map", "cm", "piece", "device", "cell", "front", "bit", "cat", "data", "leg", "list", "link", "work", "field", "bank", "bo", "line", "rule", "library", "station", "slice", "bd", "cast", "batch", "grid", "image", "output", "phase", "support", "object", "db", "d", "bb", "style", "bass", "component", "tool", "plug", "low", "ann", "brand", "hub", "channel", "Band", "feed", "dB", "boot", "back", "bus", "lc", "fb", "not", "ld", "function", "layer", "model", "cmd", "full", "nd", "act", "point", "gen", "day", "b", "service", "flow", "co", "stage", "group", "guide", "gb", "plane", "obj", "board", "project", "kt", "player", "card", "feature", "plugin", "bridge", "product", "grab", "pp", "word", "kk", "tag", "frame", "filter", "match", "ground", "range", "unk", "block", "broad"], "avctx": ["svcontext", "aveca", "avcci", "svcmp", "AVcmp", "AVctl", "ivcontext", "vercontext", "airctx", "verconn", "afcci", "afctl", "averctl", "afcmp", "avconn", "AVcli", "verctx", "airconn", "AVcontext", "afctx", "avercontext", "AVca", "avca", "ivctx", "averctx", "svcb", " avcli", "vercci", "svctx", "avecontext", "avercli", "avcontext", "verkb", "ivcci", "svconn", "avctl", "AVconn", "svctl", "avcb", " avctl", " avconn", "ivconn", "afcb", "vercb", "avectx", "avcmp", "afcontext", "AVctx", "aircontext", "afconn", " avca", "avcli", " avcontext", "airkb", "aveconn", "afkb", "avkb"], "result": ["status", "found", "response", "effect", "err", "event", "valid", "val", "mate", "inc", "message", "card", "feature", "duration", "type", "product", "results", "df", "done", "term", "order", "catch", "info", "acc", "rate", "entry", "res", "data", "final", "other", "ret", "score", "compl", "diff", "number", "arr", "work", "current", "record", "comment", "success", "rc", "mer", "answer", "match", "pass", "die", "ver", "future", "value", "Result", "date", "there", "error", "length", "total", "test", "page", "grade", "root", "dest", "ge", "su", "attr", "count"], "i": ["io", "name", "ix", "start", "e", "ie", "qi", "ind", "ui", "eni", "part", "pi", "key", "ki", "gi", "d", "uri", "my", "ti", "I", "f", "ci", "y", "u", "info", "m", "ini", "phi", "j", "size", "p", "ip", "id", "bi", "is", "mi", "c", "index", "si", "ii", "in", "x", "b", "n", "iu", "sup", "slice", "ai", "xi", "hi", "di", "multi", "v", "yi", "li", "l", "fi", "k", "ni", "type"], "t": ["port", "the", "target", "e", "g", "time", "d", "tt", "token", "tim", "ti", "l", "f", "y", "u", "m", "s", "j", "p", "ts", "at", "o", "c", "num", "tf", "dt", "a", "b", "ta", "w", "to", "T", "n", "te", "test", "task", "ot", "v", "z", "qt", "tz", "h", "pt", "offset", "x", "k", "type"], "idx1": ["idxf1", "idnt1", " idxOne", "idx4", "idy4", " idxc0", " idx0", "idx81", " idxc2", "idww81", "idxOne", "idxf2", "idxBack", "idww2", "idxc2", "idXOne", "idwwone", " idxone", "idxc0", " idxc81", "iddx2", "idxcJ", " idxcBack", "idxf81", "idxc4", "idy1", " idxcJ", "iddxBack", "idnOne", "idn0", "idX1", " idX0", "iddxJ", "idx0", "idy0", "idxfone", "idnt2", " idX1", " idxBack", "idX0", "idxone", "idn1", " idXOne", "idX4", " idxcone", "idntJ", "idww1", "idxc1", " idxc1", "idntBack", " idx4", "idy2", "idX2", " idxJ", " idxc4", "idxc81", "idyOne", "idxcone", " idx81", "iddx1", "idxcBack", "idxJ", " idX2", "idn2"], "idx2": ["idxf02", "indx2", "idxe1", "idXFL", "idxe2", "idx4", " idxc0", "idt02", "idxi1", " idx62", "sidt1", "indxFL", "idX0", "sidx1", "idxe22", "sidx02", "idxTwo", "idxFL", "idt1", "idX02", "idxi0", "idy02", "idt2", "idcyTwo", "idxc4", "idy1", "idxc62", "idx02", "idX1", "indcy02", "idxc1", " idx4", "idy2", "idX2", "idxi22", "idx62", "indx02", " idx0", "idXTwo", "idxc2", "idx22", "idxc0", " idx22", "indcy2", "idcy2", "indcyTwo", "idxfFL", "indcyFL", "idcyFL", "sidx2", "indxTwo", " idxc2", "idxe4", "idxi2", "idxf2", "idxfTwo", "idxi62", "idX62", "idx0", "idxc22", "idcy02", " idxc62", " idxc1", " idxc22", " idxc4", "sidt02", "idxi4", "sidt2"], "pos": ["col", "port", "def", "end", "obj", "ref", "val", "part", "pi", "post", "pc", "POS", "no", "po", "neg", "op", "j", "cache", "rel", "os", "p", "Pos", "slot", "trans", "o", "index", "pl", "pro", "spec", "pid", "pres", "min", "n", "len", "loc", "conf", "sp", "pt", "position", "offset", "prop", "type"], "tile": ["route", "pod", "col", "Tile", "plane", "port", "target", "table", "flat", "oe", "late", "scale", "hop", "item", "nn", "coll", "token", "kt", "so", "cube", "file", "feature", "plate", "style", "plugin", "bridge", "tle", "cand", "node", "layer", "pixel", "split", "cell", "transfer", "coord", "tab", "cat", "zip", "tif", "component", "unit", "zone", "sheet", "tool", "tag", "tf", "rule", "line", "service", "ele", "flo", "slice", "chip", "mask", "ole", "co", "stone", "task", "grid", "image", "ge", "texture", "fo", "entity"]}}
{"project": "qemu", "commit_id": "e8a095dadb70e2ea6d5169d261920db3747bfa45", "target": 1, "func": "void bdrv_remove_aio_context_notifier(BlockDriverState *bs,\n\n                                      void (*attached_aio_context)(AioContext *,\n\n                                                                   void *),\n\n                                      void (*detach_aio_context)(void *),\n\n                                      void *opaque)\n\n{\n\n    BdrvAioNotifier *ban, *ban_next;\n\n\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n\n        if (ban->attached_aio_context == attached_aio_context &&\n\n            ban->detach_aio_context   == detach_aio_context   &&\n\n            ban->opaque               == opaque)\n\n        {\n\n            QLIST_REMOVE(ban, list);\n\n            g_free(ban);\n\n\n\n            return;\n\n        }\n\n    }\n\n\n\n    abort();\n\n}\n", "idx": 5931, "substitutes": {"bs": ["bas", "base", "bp", "lb", "http", "bt", "bg", "b", "bm", "bi", "BS", "fb", "bes", "bus", "ns", "ls", "iss", "bb", "cs", "ss", "us", "vs", "sb", "ops", "banks", "bis", "ds", "bc", "ab", "ba", "blocks", "gb", "fs", "sa", "bos", "bid", "ps", "bay", "pb", "rs", "bn", "cas", "bh"], "attached_aio_context": ["attached_aios_context", "attached_aios_channel", "attached_aio2config", "attached_aios_ctx", "attached_aio2ctx", "attached_aios_config", "attached_aio_channel", "attached_aio2context", "attached_aio_connection", "attached_aio_address", "attached_aio_config", "attached_aios_connection", "attached_aio_ctx", "attached_aios_address", "attached_aio2channel"], "detach_aio_context": ["detach_aio2resource", "detach_aio_center", "detach_aio_resource", "detach_aios_resource", "detach_aios_config", "detach_aios_center", "detach_aio_config", "detach_aio2ctx", "detach_aio2context", "detach_aios_ctx", "detach_aio_ctx", "detach_aios_connection", "detach_aio_connection", "detach_aios_context", "detach_aio2config"], "opaque": ["opula", " opula", "ocaque", "oconymous", "copac", "oponymous", "ophole", "operaques", "Opaque", "operonymous", "Opacho", "cophole", "ocacity", "Opaques", "operac", "operaque", "opac", " ophole", "operhole", " oponymous", "Opacity", " opacity", " opac", "ocula", "opacho", "opaques", "operacity", "copaque", "opacity", "operacho", " opaques", " opacho", "operula", "copacity"], "ban": ["base", "stat", "fen", "gate", "anc", "kin", "ork", "pan", "ann", "bin", "block", "author", "anan", "pin", "pa", "wan", "anon", "lan", "bug", "cat", "card", "tag", "ga", "kan", "bat", "AN", "bon", "man", "han", "native", "an", "con", "auth", "comment", "Ban", "scan", "fn", "go", "ticket", "bridge", "fa", "ang", "span", "batch", "un", "ana", "don", "bank", "fan", "iban", "ver", "can", "rule", "bid", "plan", "bo", "bay", "bn", "cas", "gan", "feature"], "ban_next": ["ban_first", " ban2last", "ban2next", "ban_handle", "ban_last", " ban_last", "bn_next", "bn_prev", "bn_sec", "bn_handle", " ban_first", "ban2last", "ban_sec", "ban_prev", " ban2next", "ban2first", " ban2first"]}}
{"project": "qemu", "commit_id": "e5d9adbdab972a2172815c1174aed3fabcc448f1", "target": 1, "func": "int64_t qmp_guest_fsfreeze_freeze(Error **err)\n\n{\n\n    int ret = 0, i = 0;\n\n    FsMountList mounts;\n\n    struct FsMount *mount;\n\n    Error *local_err = NULL;\n\n    int fd;\n\n\n\n    slog(\"guest-fsfreeze called\");\n\n\n\n    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    QTAILQ_INIT(&mounts);\n\n    build_fs_mount_list(&mounts, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    /* cannot risk guest agent blocking itself on a write in this state */\n\n    ga_set_frozen(ga_state);\n\n\n\n    QTAILQ_FOREACH(mount, &mounts, next) {\n\n        fd = qemu_open(mount->dirname, O_RDONLY);\n\n        if (fd == -1) {\n\n            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);\n\n            goto error;\n\n        }\n\n\n\n        /* we try to cull filesytems we know won't work in advance, but other\n\n         * filesytems may not implement fsfreeze for less obvious reasons.\n\n         * these will report EOPNOTSUPP. we simply ignore these when tallying\n\n         * the number of frozen filesystems.\n\n         *\n\n         * any other error means a failure to freeze a filesystem we\n\n         * expect to be freezable, so return an error in those cases\n\n         * and return system to thawed state.\n\n         */\n\n        ret = ioctl(fd, FIFREEZE);\n\n        if (ret == -1) {\n\n            if (errno != EOPNOTSUPP) {\n\n                error_setg_errno(err, errno, \"failed to freeze %s\",\n\n                                 mount->dirname);\n\n                close(fd);\n\n                goto error;\n\n            }\n\n        } else {\n\n            i++;\n\n        }\n\n        close(fd);\n\n    }\n\n\n\n    free_fs_mount_list(&mounts);\n\n    return i;\n\n\n\nerror:\n\n    free_fs_mount_list(&mounts);\n\n    qmp_guest_fsfreeze_thaw(NULL);\n\n    return 0;\n\n}\n", "idx": 18409, "substitutes": {"err": ["ret", "rr", "ner", "br", "cfg", "fr", "conf", "call", "runner", "ctr", "eor", "reader", "eth", "rc", "r", "reg", "rt", "ar", "str", "or", "ast", "usr", "rh", "ie", "orig", "ind", "ry", "der", "resp", "arr", "orr", "nil", "gr", "aster", "mr", "rar", "ev", "rn", "ler", "dr", "e", "lr", "cr", "rev", "acer", "erg", "req", "rb", "dev", "ir", "doc", "gz", "error", "sys", "Er", "er", "iter", "server", "fi", "order", "attr", "conn", "bug"], "mounts": ["ountgs", "hostches", "ounts", "ntses", "mountes", "Mountgs", "threads", "lses", "configd", "mountedd", "hosts", "configp", "pathl", "Mounts", "uptes", "configes", "threadls", "mountongs", "Mountains", "configses", "emptains", "configls", "dirls", "dirs", "ntes", "threades", "nts", "mountl", "fundses", "configches", "dires", "emptgs", "paths", "dird", "les", "dirches", "mountsets", "mountedp", "Mountses", "mountses", "mountedl", "mounteds", "mountches", "Mountongs", "uptses", "hostses", "mountgs", "configs", "dirses", "hostes", "mountd", "mountains", "ntsets", "threadl", "uptsets", "mountp", "pathes", "emptongs", "upts", "mountls", "mountedls", "ls", "ountongs", "ountains", "mountedes", "lsets", "dirp", "empts", "pathls", "funds"], "mount": ["entry", "part", "m", "group", "child", "user", "f", "call", "track", "handle", "component", "md", "service", "option", "root", "block", "match", "source", "mem", "multi", "pg", "host", "link", "pair", "hw", "path", "pkg", "fail", "config", "Mount", "sync", "parent", "device", "mont", "c", "patch", "account", "p", "url", "dev", "follow", "cache", "mounted", "lock", "cmp", "od", "monitor", "field", "proc", "boot", "find", "connection", "project", "port", "mm", "valid", "own", "lc", "attr", "target"], "local_err": ["local_er", "locallytx", " local_state", "http_log", "local_log", "local__ir", " local_order", " local_er", "localxtx", "local__log", " local_error", "localapperr", "localxerror", "local7err", "local7error", " local_tx", "localapperror", "localappcor", "local__error", "local_ir", " local_magic", "shared_err", "shared_rr", "localxer", "localxerr", " local_cor", "local_error", "local_rr", " local_rr", "locallyerr", "shared_error", "shared_req", "local7er", "local_order", "locallyerror", "localxmagic", "http_error", "http_err", "localxorder", "local__err", "local_state", "locallyorder", "http_ir", "local_cor", "local7state", "local_req", "local_magic", "localapprr", "local_tx"], "fd": ["dc", "dn", "dd", "draft", "db", "pid", "nd", "fw", "ff", "fp", " FD", "f", "fat", "dir", "handle", "gd", "conn", "reader", "fe", "md", "io", "file", " fin", "fun", "feed", "fa", "cf", "cb", "hd", "vd", "wb", " f", " fid", "fc", "dl", "fs", "wd", "ld", "zip", "fen", "sd", "fed", "writer", "wind", "cond", "ln", "fx", "lf", "d", "fl", " d", "df", "bf", "FH", "socket", "bd", "pipe", "handler", "fb", "buf", "c", "fff", "fm", "fn", "cd", "len", "fi", "FD", "ds", "sf"], "i": ["ret", "init", "j", "t", "info", "x", "f", "ini", "qi", "r", "ai", "mi", "io", "phi", "n", "counter", "result", "nt", "num", "ii", "di", "index", "mini", "ind", "I", "count", "out", " ret", "l", "val", "pi", "ui", "ci", "abi", "id", "key", "limit", "e", "v", "c", "ni", "si", "p", "b", "len", "it", "fi", "li", "ib", "u"]}}
{"project": "qemu", "commit_id": "81174dae3f9189519cd60c7b79e91c291b021bbe", "target": 1, "func": "static void serial_tx_done(void *opaque)\n\n{\n\n    SerialState *s = opaque;\n\n\n\n    if (s->tx_burst < 0) {\n\n        uint16_t divider;\n\n\n\n        if (s->divider)\n\n          divider = s->divider;\n\n        else\n\n          divider = 1;\n\n\n\n        /* We assume 10 bits/char, OK for this purpose. */\n\n        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /\n\n            (1000000 * 10 / (s->baudbase / divider));\n\n    }\n\n    s->thr_ipending = 1;\n\n    s->lsr |= UART_LSR_THRE;\n\n    s->lsr |= UART_LSR_TEMT;\n\n    serial_update_irq(s);\n\n}\n", "idx": 3070, "substitutes": {"opaque": [" opque", "opaques", "pac", "OPc", " opac", "paques", "psa", "opac", "OPac", "OPaques", " opsa", "OPque", "OPaque", "openc", "OPsa", "openque", " opaques", "opsa", "openaques", "openaque", "opc", "paque", "opque", " opc"], "s": ["sg", "submit", "same", "server", "js", "service", "opens", "cs", "http", "ss", "ops", "spec", "ts", "a", "rs", "sb", "new", "d", "n", "is", "sl", "scope", "i", "g", "params", "m", "ses", "sf", "spot", "sync", "settings", "storage", "ds", "sets", "status", "ps", "gs", "ns", "c", "p", "rates", "services", "state", "e", "f", "es", "secondary", "sys", "sq", "conf", "south", "sec", "o", "stats", "b", "S", "t", "session", "os", "your", "hs", "states", "fs", "si", "sym", "parts", "ssl"], "divider": ["dividers", "DIVcer", "devide", "promide", "provinner", "devider", "Dividable", "Division", "promider", " divide", " divided", "incision", "decide", "Divided", "DIVision", "divisionoration", "divinner", "DIVider", "divisionision", "division", "providers", " division", "DivIDER", "divided", " divcer", "Divcer", "divoration", "deciders", "decides", "Divides", "divIDER", "divisionider", " divinner", "incider", "providable", "Divinner", " dividable", "decidable", "promice", "multiplider", "divcer", "provide", "provider", "divides", "incoration", "devidable", "divride", "multiplride", " divIDER", "multiplision", " divice", "DIVidable", "decIDER", "deviders", "divice", "decider", "Divide", "provided", "Divider", "provIDER", "incride", "dividable", "promision", "multiploration", "decision", "divide", " divides", "divisionride", "decice"]}}
{"project": "qemu", "commit_id": "09e68369a88d7de0f988972bf28eec1b80cc47f9", "target": 0, "func": "static QmpInputVisitor *to_qiv(Visitor *v)\n\n{\n\n    return container_of(v, QmpInputVisitor, visitor);\n\n}\n", "idx": 4849, "substitutes": {"v": ["vim", "o", "a", "s", "value", "V", "vt", "val", "x", "data", "i", "m", "uv", "l", "f", "conv", "version", "j", "q", "u", "vi", "vs", "e", "k", "t", "p", "virtual", "h", "vp", "sv", "iv", "var", "c", "g", "lv", "vv", "view"]}}
{"project": "FFmpeg", "commit_id": "7ed47e97297fd5ef473d0cc93f0455adbadaac83", "target": 1, "func": "static int smacker_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    SmackerContext *smk = s->priv_data;\n    AVStream *st, *ast[7];\n    int i, ret;\n    int tbase;\n    /* read and check header */\n    smk->magic = avio_rl32(pb);\n    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))\n    smk->width = avio_rl32(pb);\n    smk->height = avio_rl32(pb);\n    smk->frames = avio_rl32(pb);\n    smk->pts_inc = (int32_t)avio_rl32(pb);\n    smk->flags = avio_rl32(pb);\n    if(smk->flags & SMACKER_FLAG_RING_FRAME)\n        smk->frames++;\n    for(i = 0; i < 7; i++)\n        smk->audio[i] = avio_rl32(pb);\n    smk->treesize = avio_rl32(pb);\n    if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)\n        av_log(s, AV_LOG_ERROR, \"treesize too large\\n\");\n//FIXME remove extradata \"rebuilding\"\n    smk->mmap_size = avio_rl32(pb);\n    smk->mclr_size = avio_rl32(pb);\n    smk->full_size = avio_rl32(pb);\n    smk->type_size = avio_rl32(pb);\n    for(i = 0; i < 7; i++) {\n        smk->rates[i]  = avio_rl24(pb);\n        smk->aflags[i] = avio_r8(pb);\n    smk->pad = avio_rl32(pb);\n    /* setup data */\n    if(smk->frames > 0xFFFFFF) {\n        av_log(s, AV_LOG_ERROR, \"Too many frames: %\"PRIu32\"\\n\", smk->frames);\n    smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size));\n    smk->frm_flags = av_malloc(smk->frames);\n    if (!smk->frm_size || !smk->frm_flags) {\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));\n    /* read frame info */\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_size[i] = avio_rl32(pb);\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_flags[i] = avio_r8(pb);\n    /* init video codec */\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    smk->videoindex = st->index;\n    st->codec->width = smk->width;\n    st->codec->height = smk->height;\n    st->codec->pix_fmt = AV_PIX_FMT_PAL8;\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;\n    st->codec->codec_tag = smk->magic;\n    /* Smacker uses 100000 as internal timebase */\n    if(smk->pts_inc < 0)\n        smk->pts_inc = -smk->pts_inc;\n    else\n        smk->pts_inc *= 100;\n    tbase = 100000;\n    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);\n    avpriv_set_pts_info(st, 33, smk->pts_inc, tbase);\n    st->duration = smk->frames;\n    /* handle possible audio streams */\n    for(i = 0; i < 7; i++) {\n        smk->indexes[i] = -1;\n        if (smk->rates[i]) {\n            ast[i] = avformat_new_stream(s, NULL);\n            if (!ast[i])\n                return AVERROR(ENOMEM);\n            smk->indexes[i] = ast[i]->index;\n            ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n            if (smk->aflags[i] & SMK_AUD_BINKAUD) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;\n            } else if (smk->aflags[i] & SMK_AUD_USEDCT) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;\n            } else if (smk->aflags[i] & SMK_AUD_PACKED){\n                ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;\n                ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');\n            } else {\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8;\n            if (smk->aflags[i] & SMK_AUD_STEREO) {\n                ast[i]->codec->channels       = 2;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n            } else {\n                ast[i]->codec->channels       = 1;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO;\n            ast[i]->codec->sample_rate = smk->rates[i];\n            ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8;\n            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;\n            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate\n                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);\n    /* load trees to extradata, they will be unpacked by decoder */\n    if(ff_alloc_extradata(st->codec, smk->treesize + 16)){\n        av_log(s, AV_LOG_ERROR,\n               \"Cannot allocate %\"PRIu32\" bytes of extradata\\n\",\n               smk->treesize + 16);\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);\n    if(ret != st->codec->extradata_size - 16){\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(EIO);\n    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size);\n    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size);\n    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size);\n    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size);\n    smk->curstream = -1;\n    smk->nextpos = avio_tell(pb);\n    return 0;", "idx": 3913, "substitutes": {"s": ["sg", "parser", "js", "service", "cs", "ss", "spec", "ts", "qs", "sa", "sb", "r", "sam", "n", "sl", "sis", "g", "comments", "m", "ses", "ls", "sf", "plugins", "sync", "sv", "storage", "ds", "request", "gs", "ns", "c", "p", "services", "w", "e", "us", "f", "sys", "sq", "sc", "u", "conf", "summary", "south", "o", "v", "b", "su", "S", "t", "ks", "site", "session", "types", "support", "an", "si", "sym", "ssl"], "pb": ["pl", "fc", "parser", "vp", "ctx", "bh", "lp", "pd", "ppa", "esi", "sb", "bps", "lb", "ab", "cpp", "prot", "eb", "hub", "rob", "prop", "pg", "bc", "platform", "tc", "buf", "api", "PB", "tp", "rb", "proc", "fp", "sf", "cb", "bf", "abc", "phys", "pa", "pkg", "p", "apy", "lc", "rpm", "wb", "gb", "jp", "summary", "pm", "mp", "phrase", "pc", "bp", "asm", "fb", "b", "plugin", "cp", "uf", "wp", "lab", "dp", "typ", "db", "xb"], "smk": ["Smk", "tmok", "tmku", "mmck", " smdk", " smok", "syk", "simdk", "mbq", "svok", "svck", "symok", " smwork", "smK", "symku", "slc", "irmke", " smq", "omsk", "ymK", "mmk", "skkin", "svke", " smg", "slkit", "tmke", "svc", "Smck", "ymkt", "skk", " smkt", "slk", " smK", "symdk", "mmok", "mbkit", "Smok", "symke", "tmq", "irmk", " smsk", "spework", "symck", "spek", "slik", "ymck", "spekin", "tmc", "tmck", "smck", "irmK", "lammk", "bmck", "ymik", "mbke", "ymk", "mmik", "symsk", " smck", "SmK", "smwork", "tmsk", "symak", "smf", " smv", "emok", "lammd", "smku", "snke", "slok", "Smch", "snk", "symwork", "svsk", "emke", "mmke", "slq", "sksk", "mmdk", "spedk", "mmch", "tmg", "mmkt", " smf", "smv", "speg", "omk", "smc", " smc", "mmku", "svku", "smek", "speek", "slke", "spekg", "swke", "omwork", "snek", "symc", "emK", "smch", "lammek", "smak", " smak", "sykg", "smg", "mmkg", "smq", "bmg", "smik", " smd", "omkin", "symkit", "lammsk", "sld", "smkit", "sped", "bmsk", "swck", "mbk", "slck", " smek", "symg", "svdk", "symk", " smkg", "smkg", "mmc", "tmk", "svek", "simk", " smch", "smkin", "simck", "ymke", "swv", "syd", "smd", "mmg", " smik", "smke", "tmik", "speok", "swk", "smdk", "slkg", "ymok", "speak", "slv", "smok", "svk", " smke", "skwork", "mmK", "irmok", "simf", "tmdk", "smsk", "syc", "bmk", "symq", "speck", "slg", "mmek", "snck", "mmf", "emk", "ymsk", "mmsk", "spesk", "slsk", "smkt"], "st": ["ist", "ld", "src", "rest", "ss", "sa", "ts", "sb", "ct", "sp", "sl", "sh", "St", "bl", "ste", "cr", "str", "sw", "sc", "ST", "std", "sn", "sts", "rd", "sta", "inst", "ost", "sth"], "ast": ["rest", "ts", "sa", "ab", "ac", "ream", "au", "post", "ess", "AST", "sc", "std", "obj", "node", "amp", "asm", "at", "asts", "inst", "sta", "path", "port", "ost", "am", "emb", "pp", "sth", "est"], "i": ["my", "li", "gi", "abi", "key", "ni", "ii", "zi", "ji", "chi", "h", "ui", "pi", "image", "d", "I", "n", "di", "is", "udi", "id", "mi", "it", "iu", "uli", "j", "y", "eni", "inner", "ri", "m", "info", "ti", "slice", "ini", "index", "z", "multi", "ai", "ie", "ip", "x", "c", "p", "ind", "bi", "hi", "phi", "e", "f", "l", "adi", "u", "ori", "ki", "v", "o", "qi", "ix", "t", "b", "uri", "ci", "init", "fi", "start", "si", "in", "xi"], "ret": ["row", "buffer", "rs", "aux", "ru", "alt", "tmp", "nt", "rev", "back", "tr", "rc", "Ret", "result", "ref", "resp", "std", "obj", "en", "RET", "seq", "re", "val", "rt", "res"], "tbase": ["mbuffer", "dBase", "mbase", "tseq", "tbuffer", "dbuffer", "outbase", "dbase", "dseq", "outBase", "outbuffer", "tBase", "mseq", "mBase", "outseq"], "frames": ["files", "groups", "plays", "quarters", "fram", "rules", "views", "vals", "flags", "cells", "seconds", "tracks", "faces", "Frames", "games", "links", "frame", "hops", "fps", "runs", "bits", "flows", "ports", "shots", "scenes", "tones", "ones", "planes", "images", "lines", "values", "pages", "features", "steps", "rows", "videos", "weights", "bands", "cycles", "blocks", "events", "points", "codes", "headers", "bytes", "times", "versions", "caps", "parts"]}}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void gd_resize(DisplayChangeListener *dcl,\n\n                      DisplayState *ds)\n\n{\n\n    GtkDisplayState *s = ds->opaque;\n\n    cairo_format_t kind;\n\n    int stride;\n\n\n\n    DPRINTF(\"resize(width=%d, height=%d)\\n\",\n\n            ds_get_width(ds), ds_get_height(ds));\n\n\n\n    if (s->surface) {\n\n        cairo_surface_destroy(s->surface);\n\n    }\n\n\n\n    switch (ds->surface->pf.bits_per_pixel) {\n\n    case 8:\n\n        kind = CAIRO_FORMAT_A8;\n\n        break;\n\n    case 16:\n\n        kind = CAIRO_FORMAT_RGB16_565;\n\n        break;\n\n    case 32:\n\n        kind = CAIRO_FORMAT_RGB24;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n        break;\n\n    }\n\n\n\n    stride = cairo_format_stride_for_width(kind, ds_get_width(ds));\n\n    g_assert(ds_get_linesize(ds) == stride);\n\n\n\n    s->surface = cairo_image_surface_create_for_data(ds_get_data(ds),\n\n                                                     kind,\n\n                                                     ds_get_width(ds),\n\n                                                     ds_get_height(ds),\n\n                                                     ds_get_linesize(ds));\n\n\n\n    if (!s->full_screen) {\n\n        GtkRequisition req;\n\n        double sx, sy;\n\n\n\n        if (s->free_scale) {\n\n            sx = s->scale_x;\n\n            sy = s->scale_y;\n\n\n\n            s->scale_y = 1.0;\n\n            s->scale_x = 1.0;\n\n        } else {\n\n            sx = 1.0;\n\n            sy = 1.0;\n\n        }\n\n\n\n        gtk_widget_set_size_request(s->drawing_area,\n\n                                    ds_get_width(ds) * s->scale_x,\n\n                                    ds_get_height(ds) * s->scale_y);\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n        gtk_widget_get_preferred_size(s->vbox, NULL, &req);\n\n#else\n\n        gtk_widget_size_request(s->vbox, &req);\n\n#endif\n\n\n\n        gtk_window_resize(GTK_WINDOW(s->window),\n\n                          req.width * sx, req.height * sy);\n\n    }\n\n}\n", "idx": 11368, "substitutes": {"dcl": ["ddcl", "dsCL", "dCL", "ddCl", " dCl", " dfl", "dscl", "dsfl", "dsCl", "ddCL", "dfl", "ddfl", " dCL", "dCl"], "ds": ["vs", "ld", "sem", "cdn", "des", "session", "gd", "ts", "ks", "dh", "did", "uds", "dom", "dds", "da", "die", "dt", "dos", "dal", "ads", "d", "gs", "data", "ys", "ls", "pd", "parts", "dist", "du", "xs", "js", "rs", "df", "os", "ded", "dl", "dr", "db", "cs", "dat", "sync", "sts", "md", "dd", "DS", "vd", "ans", "ns", "dc", "nas", "sd", "ms", "Ds", "dm", "sys", "od", "der", "ses", "fs", "ps", "del", "ss", "bs", "settings", "dx"], "s": ["l", "session", "is", "its", "m", "t", "gs", "parts", "state", "ns", "hs", "spec", "self", "params", "sg", "si", "n", "your", "b", "i", "iss", "c", "e", "args", "sq", "us", "f", "sym", "sets", "es", "r", "sis", "as", "u", "fs", "ps", "site", "ss", "ks", "sv", "g", "stats", "ops", "d", "sa", "ls", "os", "cs", "o", "sync", "sl", "new", "sb", "sys", "secondary", "a", "ssl", "vs", "conf", "ts", "service", "p", "qs", "ins", "xs", "js", "rs", "aws", "S", "sts", "states", "services", "h", "ses", "y", "bs"], "kind": ["parent", "ld", "rank", "gen", " kinds", "good", "kg", "std", "context", "str", "start", "Kind", "class", "def", "vid", "id", "method", "key", "nt", "die", "path", "k", "instance", "data", "head", "info", "draw", "lit", "args", "style", "xxx", "brand", "mode", "ie", "code", "mid", "child", "stroke", "actory", "kid", "shape", "nd", "ck", "name", "ind", "inner", "kt", "desc", "part", "cost", "spec", "ke", "need", "init", "concept", "type", "lang", "mean", "dev", "impl", "sid", "engine", "text", "feat", "depth", "ko"], "stride": ["striider", "striide", "Stride", " strided", "brided", "Strided", " strider", "briding", "strider", "bride", "striding", "striiding", "drided", "Strider", "trider", " striding", "Striding", "drider", "strided", "tride", "trided", "brider", "driding", "triding", "dride", "striided"], "req": ["sp", "cmp", "war", "rw", "org", "require", "ver", "ra", "ref", "qq", "tar", "reg", "dist", " reg", "ctr", "cur", "err", "spec", "get", "grad", "rx", "resp", " requirements", "fr", "iw", "gr", "serv", "e", "app", "request", "sq", "f", "j", "res", "r", "wx", "ur", "compl", "exec", "rf", "dq", "sem", "ru", " requisite", "seq", "str", "g", "conn", "util", "progress", "query", "tx", "jp", "a", "ret", "cache", "crit", "conf", "urg", "qt", "ry", "wa", "rr", "rec", "p", "js", "q", "sec", "requ", "lib", "Requ", "ctx", "pr", "pull", "client", "proc", " requ"], "sx": ["ssph", "Sx", "sfx", " smy", "spxe", "ppx", "sw", "ssfx", "ssw", "spy", " sph", " sX", "ssxe", "dw", "ssx", "ssy", "sxe", "py", " sxe", "sph", "dfx", "sX", "pX", "sct", "smy", " spx", "ssmy", " sct", " sfx", "px", "Spx", "spph", "spx", "Sy", "SX", "dx", "dy", "ssct"], "sy": ["ady", "hi", "si", "ry", "len", "asy", "ny", "phy", "ey", "sa", "ys", "fy", "thin", "ay", "sq", "zy", "lat", "yy", "gy", "sym", "py", "size", "syn", "sky", "ky", "south", "fun", "hy", "ty", "SY", "dy", "idy", "sys", "rx", "lon", "sat", "yn", "y", "ch", "Sy", "wy", "ity", "cy", "Ty"]}}
{"project": "FFmpeg", "commit_id": "90c6963daea9210d7d2104e2ece94dd4e2fffc17", "target": 1, "func": "void avfilter_link_free(AVFilterLink **link)\n\n{\n\n    if (!*link)\n\n        return;\n\n\n\n    if ((*link)->pool) {\n\n        int i;\n\n        for (i = 0; i < POOL_SIZE; i++) {\n\n            if ((*link)->pool->pic[i]) {\n\n                AVFilterBufferRef *picref = (*link)->pool->pic[i];\n\n                /* free buffer: picrefs stored in the pool are not\n\n                 * supposed to contain a free callback */\n\n                av_freep(&picref->buf->data[0]);\n\n                av_freep(&picref->buf);\n\n\n\n                av_freep(&picref->audio);\n\n                av_freep(&picref->video);\n\n                av_freep(&picref);\n\n            }\n\n        }\n\n        av_freep(&(*link)->pool);\n\n    }\n\n    av_freep(link);\n\n}\n", "idx": 21302, "substitutes": {"link": ["lc", "like", "name", "cross", "e", "key", "connection", "message", "file", "style", "parse", "hip", "plugin", "local", "f", "model", "info", "dd", "bug", "lock", "play", "list", "id", "ace", "sync", "load", "comment", "ink", "hack", "plug", "Link", "friend", "tag", "filter", "mail", "module", "source", "check", "match", "pull", "linked", "a", "line", "service", "install", "call", "child", "loc", "feed", "di", "parent", "lib", "http", "user", "li", "group", "lang", "ck", "image", "block", "pack", "l", "base", "links", "action", "url", "type"], "i": ["io", "ami", "name", "e", "ix", "fi", "qi", "ri", "ui", "pi", "key", "gi", "d", "uri", "chi", "ti", "I", "f", "ci", "y", "info", "phi", "m", "ini", "oi", "j", "u", "ip", "p", "abi", "o", "bi", "wei", "mi", "mu", "index", "si", "ii", "b", "ji", "iu", "ai", "xi", "base", "hi", "di", "multi", "v", "yi", "li", "l", "x", "zi", "ni", "type"], "picref": ["picdef", "docref", " picdef", "docreference", "picRef", "Picdef", "picreference", "nicreference", "pcdef", "icrel", "pictrel", "nicRef", "pcreference", "pcrel", " picblock", "pinreference", "pinref", "icRef", "icreference", "pcref", "pictRef", "pinflow", "picrel", "pictref", "Picrel", "PicRef", "pcRef", "nicref", " picRef", "docrel", "nicrel", "pcflow", "docflow", "Picref", "pictreference", "Picblock", "pinblock", " picreference", "picblock", "picflow", "Picreference", "pinrel", "icref", "pinRef"]}}
{"project": "qemu", "commit_id": "53628efbc8aa7a7ab5354d24b971f4d69452151d", "target": 1, "func": "int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    int offset = 0, counter = 10;\n\n    int res;\n\n\n\n    if (!s->chr_sync_read) {\n\n        return 0;\n\n    }\n\n    \n\n    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {\n\n        return replay_char_read_all_load(buf);\n\n    }\n\n\n\n    while (offset < len) {\n\n        do {\n\n            res = s->chr_sync_read(s, buf + offset, len - offset);\n\n            if (res == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (res == -1 && errno == EAGAIN);\n\n\n\n        if (res == 0) {\n\n            break;\n\n        }\n\n\n\n        if (res < 0) {\n\n            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n                replay_char_read_all_save_error(res);\n\n            }\n\n            return res;\n\n        }\n\n\n\n        offset += res;\n\n\n\n        if (!counter--) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_char_read_all_save_buf(buf, offset);\n\n    }\n\n    return offset;\n\n}\n", "idx": 7125, "substitutes": {"s": ["o", "serv", "sf", "v", "S", "http", "spec", "session", "b", "socket", "si", "i", "sync", "sys", "ses", "services", "m", "l", "f", "side", "ns", "usb", "state", "d", "ls", "sl", "space", "service", "ss", "conf", "sports", "u", "sis", "e", "sie", "sb", "gs", "sim", "se", "secondary", "ds", "t", "n", "storage", "ts", "su", "self", "p", "south", "sv", "c", "os", "g", "ssl", "sq", "sym", "site", "src", "es", "r", "ps", "js"], "buf": ["cmp", "feed", "buff", "vec", "header", "bd", "rb", "config", "b", "data", "rc", "queue", "uc", "fb", "db", "uf", "wb", "f", "lim", "num", "bb", "img", "buffer", "que", "bag", "Buffer", "port", "cmd", "ctx", "path", "bc", "cb", "fp", "loader", "coord", "seq", "req", "batch", "msg", "prop", "alloc", "bf", "fd", "cf", "br", "pb", "src", "cas", "bh", "ff", "prefix"], "len": ["base", "block", "el", "count", "list", "val", "data", "lt", "lan", "ll", "in", "l", "num", "offset", "f", "fin", "limit", "length", "fl", "all", "en", "fn", "n", "lon", "seq", "pos", "line", "Len", "ln", "lc", "lin", "li", "cache", "lf", "lim", "end", "size"], "res": ["gr", "nos", "row", "ris", "reset", "reg", "red", "cr", "ret", "id", "rr", "sr", "block", "ress", "progress", "pre", "Res", "val", "x", "rc", "rec", "rel", "details", "rh", "results", "rest", "ries", "ras", "des", "resolution", "e", "rss", "rez", "error", "rus", "arr", "rx", "err", "response", "rev", "result", "pres", "seq", "resh", "req", "css", "re", "pos", "mr", "ver", "os", "RES", "resp", "ms", "ps", "hr", "rs", "no", "r", "rem", "max", "rar"], "counter": ["master", "cmp", "row", "fr", "Counter", "er", "iter", "count", "entry", "parent", "total", "prev", "race", "num", "order", "server", "length", "nr", "loop", "ctr", "outer", "number", "code", "per", "clock", "arr", "timer", "field", "loader", "result", "seq", "ounter", "ner", "sp", "pointer", "ver", "c", "page", "inner", "cache", "r", "trace"]}}
{"project": "FFmpeg", "commit_id": "9745f19ffc9031ce480e43d7cf1053b58100d70f", "target": 0, "func": "static av_cold int ass_decode_init(AVCodecContext *avctx)\n\n{\n\n    avctx->subtitle_header = av_malloc(avctx->extradata_size);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);\n\n    avctx->subtitle_header_size = avctx->extradata_size;\n\n    return 0;\n\n}\n", "idx": 24269, "substitutes": {"avctx": ["avcms", "varctx", "navcontext", "varcontext", "afconnection", "aycontext", "avcontext", "avesync", "afcontext", "avectx", "avcn", "varcn", "avecmp", "navcu", "avecor", "afcca", "avcu", "afsync", "avepkg", "avalloc", "aucmp", "avcca", "evcms", "avalcontext", " avloc", "afcn", "afctx", "avalctx", "avpkg", "afca", "varci", "afci", "avloc", "aveca", "verctx", "avci", "avcf", "avecontext", "evcontext", "avcmp", "aucontext", "avsync", "afcms", "avecu", "avca", "auctx", "afcf", "aupkg", "evctx", " avcf", "avcor", "vercn", "afcor", "avconn", "ayctx", "avalcor", "afconn", "verci", "navconn", "avalcca", "avecf", "aycmp", " avsync", "evcmp", "afpkg", "avecca", "avalconnection", "vercontext", " avca", "afcu", " avcu", "aycms", "avconnection", "aveconn", " avconn", " avcontext", " avconnection", "afloc", "navctx", "afcmp"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) &&\n\n                 float64_is_infinity(farg2.d))) {\n\n        /* Division of infinity by infinity */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);\n\n    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {\n\n        /* Division of zero by zero */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN division */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 2806, "substitutes": {"env": ["eu", "oa", "vm", "server", "ctx", "ext", "fen", "em", "conn", "context", "esi", "txt", "her", "equ", "environment", "shell", "priv", "ea", "eng", "enc", "gear", "ef", "eni", "proc", "erv", "enh", "ah", "style", "ep", "config", "kn", "ec", "exc", " environment", "ack", "Environment", "c", "et", "e", "loader", "conf", "cache", "viron", "chal", "obj", "en", " environments", "iss", "ev", "site", "manager", "session", "aer", "img", "engine", "qt", "que", "console", "energy", "db", "ench"], "arg1": ["ar2", "ar1", "argument3", "ax2", "argument2", "arkone", "ar01", "ark2", " arg3", " arg01", "arg01", "ark1", "ark01", "ax01", "ar3", "axone", "argument01", "argone", "argument1", "arg3", "ax1", " argone"], "arg2": ["param1", "paramTwo", "param2", "argsTwo", "argetb", " argTwo", "Arg82", " argb", "arg82", "Argb", "arget1", "arg0", "args2", "Arg1", "arget2", " arg82", "args0", "arget82", "argTwo", "param0", "Arg2", "args1", "argb", " arg0"], "farg1": ["frargumentinf", "ferg21", "farg41", "fari11", "fagn11", " fval01", "frarg1", "ferg1", "fconfig1", "ferg41", "fagn0", "frargument41", "fark4", "frargument61", "infagnpart", "fax1", "fackpart", "fargsb", "infagn41", "cvalone", "farginf", " fArg3", "fArg0", "fag21", " fArg11", "ferginf", "infargh", "fasc3", " fArg31", "fargumentinf", "sfark4", "fArgn", "fargone", "carg3", "fargs01", "fagn81", "frargument1", " fArg1", "fArg81", "Farg1", "fargback", "farg3", " fargonce", "fArg3", "fax4", "fArg31", "farg0", "carg1", "fasc41", "farg31", "farg11", "fasc01", "cargone", "sfark1", "fconfigpart", "fagnonce", "fargh", "sfarg0", "fack1", " farg5", "sfargn", "fArg01", "farg21", "fargs3", "farg01", " farg31", "fargs4", "fval3", "fcard5", "frarginf", "fax0", "fag1", " ferg1", "cval3", " fArgonce", " farg11", "fagnh", "ferg5", " ferg5", "fconfig41", " farg41", "infarg1", "fconfigh", "fArgone", "faginf", "infagnh", "infarg41", " fval3", "fargonce", "fag61", "fcardback", "fergback", " fArg0", "fval1", "fArgb", " farg01", "fari81", "fval41", "Farg3", "fArg11", "fari1", "Fargn", "fArg2", "farg5", "cval1", "frg31", "fark1", "fagn31", "ferg61", "fargument41", "frg3", "fArgonce", " fargb", "faxn", "fag5", "sfark0", " farg0", "fagnpart", "fargsn", "frarg41", " farg81", "fag41", "Fargs3", "fval01", " fval41", "fArg1", "fagn1", "fagn3", "infagn1", " farg3", "sfarg1", "fargs1", "fargs41", "farkn", "fvalone", "fargs0", "frg1", "Fargsone", "farg61", "fackh", "farg4", "cvaln", "fcard21", "fagn41", "Fargs1", "Fargsn", "Fargone", "fasc1", "fargument1", " fargback", " ferg21", "fari0", "fack41", "infargpart", "fvaln", " farg21", "fargsone", "fagback", "fargument61", "sfarg4", "sfarkn", "fark0", "fargs2", " fArg81", "fargpart", "fargn", "cargn", "fargb", "frarg61", " fergback", "farg81", "frgonce", " fval1", "fcard1"], "farg2": ["fparam2", "fargument2", " farg02", "cvaltwo", " fark1", "farg96", "cargtwo", "fargsb", "fvalidpage", "fArg0", " farg52", "freg2", "forig2", " fArgb", "fArgtwo", "infargpage", "fargpage", "fval52", "carg3", "farkB", "farc2", "fitemtwo", "cargb", "fpar52", " fArgtwo", "fval2", " fark2", "farg3", "fregb", "fig96", "fitempage", "farg0", "fparamb", "farg52", "fpar2", "fvalid2", "farmtwo", "fargB", "forig5", "infitem82", "cvalb", "fargs3", "fval3", "carg2", "infarg2", "freg5", "cval3", "fitem2", "forarg96", "fargument96", "forigtwo", "farm96", " fArg2", "farcpage", "fark02", "fvalid82", "fparam0", " fArg0", "fArgb", "forarg2", " fargB", " fargtwo", "fArg2", "farg5", "forargtwo", "fitem82", "fark1", "freg96", " fargb", "fpartwo", " fval96", "cval2", "fargsB", "farg02", " farg0", "fvaltwo", "fval96", " fval2", "fargs02", "fargstwo", "farc82", "fargument52", "infitemtwo", "fparamtwo", "farm2", "fvalidtwo", "fargtwo", "fpar96", "fig2", "infargtwo", "figtwo", "fargs1", " farkB", " fark02", "fargs0", " fval52", "freg3", "fvalb", " fvaltwo", "forig96", "infarg82", " farg96", "infitempage", "fregtwo", "infitem2", "fig5", "farctwo", "fargs2", "farm5", "fargumenttwo", "farg82", "fargb", "forarg5", "fark2"]}}
{"project": "FFmpeg", "commit_id": "e16e49ac90f6da9e019fdf23084cbb256d14bd9c", "target": 0, "func": "static void term_exit(void)\n\n{\n\n#ifndef __MINGW32__\n\n    tcsetattr (0, TCSANOW, &oldtty);\n\n#endif\n\n}\n", "idx": 22392, "substitutes": {}}
{"project": "qemu", "commit_id": "e69a17f65e9f12f33c48b04a789e49d40a8993f5", "target": 0, "func": "static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)\n\n{\n\n    unsigned int i;\n\n\n\n    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)\n\n        qemu_put_be32s(f, &q->queue[i]);\n\n\n\n    qemu_put_sbe32s(f, &q->next);\n\n    qemu_put_sbe32s(f, &q->priority);\n\n}\n", "idx": 11142, "substitutes": {"f": ["l", "rf", "lf", "fo", "fen", "g", "ff", "n", "af", "sf", "w", "m", "fr", "info", "fd", "b", "t", "k", "x", "fw", "d", "c", "fb", "p", "ref", "e", "fp", "cf", "feed", "df", "j", "bf", "tf", "o", "fx", "r", "elf", "u", "form", "self", "F", "file", "fs", "buff", "fe", "fc"], "q": ["l", "dq", "conf", "qt", "plus", "g", "view", "w", "info", "id", "k", "que", "x", "quick", "d", "iq", "c", "qu", "s", "work", "p", "qq", "qs", "qa", "e", "queue", "cf", "sq", "flow", "quest", "j", "v", "sync", "query", "r", "req", "check", "cl", "u", "Q", "question"], "i": ["l", "hi", "ui", "di", "start", "si", "n", "zi", "key", "info", "xi", "id", "t", "x", "b", "ini", "k", "d", "c", "ji", "p", "ix", "uri", "e", "yi", "mu", "mini", "ie", "j", "ai", "o", "multi", "index", "v", "gi", "ti", "phi", "qi", "pi", "bi", "ii", "u", "h", "I", "li", "ip", "ci", "io", "ni", "ri", "jj", "fi", "iu"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void raven_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = raven_init;\n\n    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;\n\n    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;\n\n    k->revision = 0x00;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"PReP Host Bridge - Motorola Raven\";\n\n    dc->vmsd = &vmstate_raven;\n\n    dc->no_user = 1;\n\n}\n", "idx": 3598, "substitutes": {"klass": ["Kcl", "oklass", "klasses", " kazz", "kickclass", "okull", "skazz", "Kull", "kickazz", "kull", "okclass", "Klf", "kicklass", "skull", "Kclass", "kicklf", " kcl", "sklasses", " klf", "skclass", "klf", "skcl", "kazz", "Klasses", "Klass", "sklass", "kclass", "okcl", "Kazz", " klasses", "kcl", " kclass"], "data": ["da", "dd", "def", "context", "device", "cc", "rec", "record", "parent", "i", "params", "m", "info", "create", "df", "config", "json", "raw", "result", "reader", "dev", "DATA", "dat", "Data", "input", "db"], "k": ["ek", "uk", "cs", "q", "kick", "key", "device", "ke", "d", "tk", "ck", "kind", "K", "sk", "ko", "kr", "g", "dk", "kin", "ka", "m", "ijk", "ok", "kt", "mk", "kw", "kn", "c", "kid", "p", "self", "f", "u", "ku", "kk", "ki", "o", "ik", "ks"], "dc": ["fc", "DC", "da", "cc", "mc", "device", "d", "di", "tk", "ck", "nc", "director", "bc", "tc", "de", "cdn", "dk", "ac", "df", "dt", "ds", "config", "ec", "c", "doc", "lc", "design", "sc", "cd", "cmd", "disc", "pc", "cf", "dat", "acc", "desc", "db", "rc"]}}
{"project": "FFmpeg", "commit_id": "2207ea44fb4fad4d47646a789bc244e3e84c1726", "target": 0, "func": "static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,\n\n                                              int linesize,\n\n                                              int block_w, int block_h,\n\n                                              int src_x, int src_y,\n\n                                              int w, int h,\n\n                                              emu_edge_core_func *core_fn)\n\n{\n\n    int start_y, start_x, end_y, end_x, src_y_add = 0;\n\n\n\n    if (src_y >= h) {\n\n        src_y_add = h - 1 - src_y;\n\n        src_y     = h - 1;\n\n    } else if (src_y <= -block_h) {\n\n        src_y_add = 1 - block_h - src_y;\n\n        src_y     = 1 - block_h;\n\n    }\n\n    if (src_x >= w) {\n\n        src   += w - 1 - src_x;\n\n        src_x  = w - 1;\n\n    } else if (src_x <= -block_w) {\n\n        src   += 1 - block_w - src_x;\n\n        src_x  = 1 - block_w;\n\n    }\n\n\n\n    start_y = FFMAX(0, -src_y);\n\n    start_x = FFMAX(0, -src_x);\n\n    end_y   = FFMIN(block_h, h-src_y);\n\n    end_x   = FFMIN(block_w, w-src_x);\n\n    av_assert2(start_x < end_x && block_w > 0);\n\n    av_assert2(start_y < end_y && block_h > 0);\n\n\n\n    // fill in the to-be-copied part plus all above/below\n\n    src += (src_y_add + start_y) * linesize + start_x;\n\n    buf += start_x;\n\n    core_fn(buf, src, linesize, start_y, end_y,\n\n            block_h, start_x, end_x, block_w);\n\n}\n", "idx": 2300, "substitutes": {"buf": ["fd", "buffer", "ctx", "offset", "bag", "array", "sb", "queue", "data", "loc", "bc", "buff", "pb", "tmp", "cas", "rb", "proc", "dest", "cb", "pool", "config", "bus", "block", "cv", "Buffer", "vec", "ptr", "stack", "ref", "br", "gb", "stream", "cmd", "alloc", "seq", "fb", "b", "cmp", "conv", "uf", "img", "count", "msg", "uc", "rc", "port"], "src": ["fc", "sub", "rib", "buffer", "ctx", "sup", "split", "stat", "rs", "spec", "sb", "image", "url", "loc", "rob", "send", "bc", "sl", "cur", "gz", "comp", "rb", "proc", "secure", "dest", "sync", "cb", "slice", "source", "feat", "config", "scenes", "st", "sel", "start", "attr", "sc", "sq", "gb", "stream", "sec", "bg", "sr", "seq", "rss", "gl", "inst", "sur", "b", "img", "support", "uc", "rect", "input", "dist", "rc", "ssl"], "linesize": ["lightssize", "lightsization", "pagesIZE", "linesization", "postsization", " linesization", "blockssize", " linesIZE", "linesized", "planesization", "pagesization", "paramsized", " linesized", "paramsization", "lightsized", "postsized", "lightsize", "paramsize", "planesize", "pagesize", "linessize", "planesized", "linesIZE", " linessize", "postsize", "blocksize", "blocksization", "postsIZE", "planessize", "paramsIZE", "pagessize", "blocksIZE"], "block_w": ["block_work", " block_work", "block64h", "blockingh", "block00wx", "block_fw", "blockings", "block67win", "blockacwt", "node_w", "block_x", "block_y", "lock_x", "nodeacwin", "blockacw", "block24w", "block25work", "block00rw", "block24wx", "node_x", "lock_h", "block_wx", "block_s", "blockIdh", "blockacwx", "blockingx", " block_wx", "lock_s", "node_sh", " block_x", "block67w", "block_sw", "nodeacx", "nodeacw", " block_rw", "block00h", "blockacws", "blockacsh", "block_sh", "blockIdw", "block24rw", "blockacwin", "blockach", "block00y", "lock_rw", "blockacsw", " block_sw", "blockIdwork", "block25h", " block_fw", "block_win", "block64wx", "lock_w", "blockacx", "blockingw", "block67x", "block00w", "lock_y", "block25w", "node_win", "block_wt", "block67sh", " block_wt", "block_ws", " block_ws", "block25fw", "block24h", "block64w", "block64sw", "block_rw", "blockIdfw", "nodeacsh"], "block_h": ["block_hw", "blocknw", "block_x", "block_y", "Block_hw", "block_hs", "block_bh", "block53hw", "block24w", "block55hs", "Block_bh", "lock_h", "Block_h", "block12gh", "block_oh", " block_oh", "block_loc", "lock_hw", " block_hs", "block67w", "block2h", "block_wa", "block53y", "block00h", "block00x", "block_gh", "block67h", "block55h", "block24hw", "block53w", " block_y", " block_loc", "block00y", "Block_ih", "block2x", "lock_w", "Block_w", "lock_y", "block_ih", "block55y", "block00ih", "block67loc", "block12w", "blocknhw", " block_wa", "block67gh", "blocknbh", "block55wa", "block12loc", "block24bh", "block2y", "Block_x", "block24h", "block2ih", "blocknh", " block_gh", "block53h", "Block_y", "block12h"], "src_x": ["src2y", "source_z", "block_x", "block_z", "block_y", "src_ady", "src2w", "srcqx", "src_n", "srcqz", "src___y", " src_h", "src2h", "source_ady", "source_X", " src_z", "sup_w", "srcqy", "sup_X", "source_xd", "block_n", "srcqady", "src_w", "sup_y", "src_X", "src2x", "source_x", "src___z", "source_y", "src_xd", "src_z", "src___n", "src_h", "src___x", "sup_x", " src_w"], "src_y": ["src2y", "src_yo", "block_x", "src_ny", "block_y", "srcureya", "src2w", "srcqx", "src_sky", " src_yo", "block_ya", "srcqyt", "srcamex", "src_yl", " src_ny", "block_yl", "srcuresky", " src_z", "srcqny", "srcacyo", "src_Y", "srcqy", "src00y", " src_yt", "src00x", "srcameyn", "src_vy", "source_Y", "srcacx", "block_sky", "src_w", "src_yn", "src_ya", "src_yt", "src2x", "source_x", "srcacy", "srcamey", "srcacyt", "source_y", "source_yo", "srcurex", "source_ya", "src_z", "src00z", " src_vy", "src00yo", "srcacya", "source_yn", "src2z", "srcacny", "srcurey", " src_w", "srcameY"], "w": ["ow", "q", "hw", "a", "cl", "fw", "r", "wt", "d", "n", "sh", "k", "W", "y", "g", "max", "aw", "wo", "m", "wh", "z", "kw", "x", "l", "p", "work", "sw", "c", "e", "f", "wb", "u", "win", "wd", "o", "v", "s", "b", "t", "wa", "ew", "iw", "wp", "rh", "wx"], "h": ["H", "q", "bh", "ih", "hw", "host", "ht", "high", "r", "d", "n", "sh", "head", "ph", "th", "k", "end", "uh", "ha", "y", "g", "m", "ah", "z", "ch", "home", "hm", "l", "hi", "c", "p", "x", "e", "hh", "f", "height", "hp", "u", "en", "o", "v", "s", "b", "t", "wa", "hs", "oh", "rh", "gh"], "core_fn": ["cr_format", "cr_function", "corePfn", "core_func", "corefuncfn", "corefuncfunction", "corePfunc", "cr_fn", "core_fs", "cr_func", "corePfunction", "corefuncfunc", "corefuncfs", "core_format", "corePformat", "core_function", "cr_fs"], "start_y": [" start_ry", "start05y", "start_ry", "start_cy", "start67yi", "start05year", " start_yi", "start_year", "end_year", "start00z", "start_yl", "startCx", "end_yn", "start67ry", "start00x", "start05yl", "startCyn", "startjry", "start67y", "startjx", "startJx", "start_ny", "end_z", "end_cy", "end_yl", "start_yn", "startJcy", "end_yi", "startjy", "startjyi", "start_yi", "start00y", "startJy", "start05x", "start67x", "startJz", "start_z", "startCy", "start00ny", "startJny", "startCyi", "end_ny"], "start_x": ["end_X", "startally", "end_width", "start_xy", "start_X", "startallx", "startallX", "start_asy", "start___xs", "end_xs", "start64y", "start00ey", "start64ey", "end_asy", "start___x", "startlx", "start00z", "end_xi", "end_ya", "start_xs", "startlwy", "start00x", "start64x", "startly", "startJx", "start___z", "start_ye", "end_z", "start_ey", "startJxi", "start___width", "end_ye", "start___asy", "start_width", "startallya", "end_xy", "start_xi", "start00y", "end_wy", "start_wy", "startJy", "start_z", "start64z", "startJxs", "startJxy", "end_ey", "startlye", "start_ya", "start___y", "startJwidth"], "end_y": ["endXx", "endLx", "end1i", " end_ny", "start_w", "end33ny", "start_yi", "endDy", "start_dy", "end2i", "endLdy", " end_ya", "end2y", "end33ya", "endXyn", "end_i", "endLy", "endLya", " endJy", "start_i", "end1w", "end33y", "endJy", "end_ya", "endXyi", "endJx", "endJya", "end_dy", "endDyi", "end33x", "end_yn", "start_yn", "endJdy", " endJx", " endJya", "end_ny", "endJny", "endDyn", "end1x", "end1y", "end_yi", "start_ya", "endDx", " endJny", "end2x", "end_w", "endXy", "end2w"], "end_x": ["endjx", "end_X", "start_ys", "end64ya", "endjyn", "end___ya", "end___ey", "start_X", "end_z", "endjy", "start_ey", "end_ys", "endJX", "end___y", "start_z", "end_ya", "endJy", "endJx", "end64y", "end_yn", "end___x", "start_yn", "end_ey", "end64yn", "start_xs", "end_xs", "start_ya", "endJz", "endjya", "end64x"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    unsigned int datalen;\n\n\n\n    if (offset < s->inode.vdi_size) {\n\n        error_report(\"shrinking is not supported\");\n\n        return -EINVAL;\n\n    } else if (offset > SD_MAX_VDI_SIZE) {\n\n        error_report(\"too big image size\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n    s->inode.vdi_size = offset;\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    close(fd);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to update an inode.\");\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14951, "substitutes": {"bs": ["bt", "ses", "blocks", "as", "bc", "BS", "fs", "ins", "iss", "bb", "rs", "fb", "cs", "os", "cms", "es", "js", "ss", "ms", "rb", "obs", "pb", "b", "sb", "gb", "gs", "bits", "bh", "ns", "outs", "ds", "bi", "sa", "ls", "lb", "bos", "ts", "vs"], "offset": ["port", "adjusted", "enabled", "location", "Offset", "part", "slot", "shift", "id", "seed", "oa", "range", "bytes", "position", "fp", "loc", "error", "limit", "o", "alpha", "size", "data", "pointer", "af", "base", "length", "padding", "address", "number", "timeout", "reset", "fee", "off", "pos", "prefix", "addr", "num", "delay", "len", "ptr", "alloc", "index", "start"], "s": ["sys", "ses", "service", "sync", "fs", "t", "l", "ins", "i", "rs", "sym", "g", "cs", "qs", "S", "settings", "os", "its", "sets", "js", "es", "si", "sq", "uns", "session", "v", "ps", "ss", "conf", "storage", "o", "ms", "p", "e", "d", "site", "sb", "b", "f", "gs", "spec", "c", "ns", "xs", "is", "stats", "ssl", "sl", "states", "services", "ds", "ops", "r", "sa", "su", "ls", "sis", "ts", "in", "ks", "aws"], "ret": ["alt", "ft", "en", "rc", "id", "val", "code", "back", "rets", "fun", "sr", "ref", "det", "hash", "lit", "conn", "pass", "obj", "mt", "fin", "success", "data", "af", "base", "Ret", "ext", "bf", "lf", "result", "att", "url", "red", "arr", "cb", " result", "nt", "re", "out", "rt", "resp", "r", "db", "et", "RET", "al", "res", "reg", "addr", "rf", "flag", "len", "bit"], "fd": ["ft", "ff", "d", "fl", "rd", "fs", "id", "fb", "bd", "fm", "cond", " fid", "fun", "dl", "fx", "nd", "fat", "fp", "fn", "ld", "dir", "fr", "pd", "dy", "cd", "handler", "fi", "fin", "fed", "buf", "sf", "wb", "nil", "bf", "f", "result", "lf", "draft", "fe", "df", "dt", "dc", "feed", "end", "cb", "md", "cf", "fail", "resp", "dd", "db", "fee", "hd", "wd", "fc", "fa", "wat", "FD"], "datalen": [" dalength", "davaln", " dalen", "Davalan", " datallen", "davalang", "dalanength", "dalang", "dalength", "datalan", "Datalens", "dataline", "dillen", "davalan", " datalun", " dataline", " datalenc", "daln", "Datalan", "davalun", "Dataln", "datalenc", "dmalens", "dilenc", "dalanen", "datalun", "datalength", "dataln", "dilen", "dacline", " datalength", " dalun", " dotaline", " dotalenc", " datalang", "davalength", " dotalen", "davalens", "Davaln", "datallen", "datalang", "Datalen", " dalang", "datalens", "dmalan", "dmaln", "dotalenc", "dalan", "dotalen", "dalen", "dalanun", "dotallen", " dotallen", "diline", "dacllen", "dmalen", "daclenc", "dotaline", "Davalen", "daclen", "dalens", "dalanang", "dalun", "davalen", "Davalens"]}}
{"project": "qemu", "commit_id": "6e99c631f116221d169ea53953d91b8aa74d297a", "target": 0, "func": "static int net_socket_can_send(void *opaque)\n\n{\n\n    NetSocketState *s = opaque;\n\n\n\n    return qemu_can_send_packet(&s->nc);\n\n}\n", "idx": 6594, "substitutes": {"opaque": ["opa", "opera", "copac", "copa", "iopacity", "pacity", "operac", "operaque", "opac", "space", "spaques", "iopa", "spaque", " opacity", " opace", "opaques", "paque", "pace", "operacity", "copaque", "iopac", "opace", "opacity", "spacity", " opaques", "iopaque", "copacity", "paques"], "s": ["o", "sf", "sec", "S", "a", "spec", "sg", "scope", "socket", "si", "sync", "sys", "ses", "services", "m", "states", "f", "ns", "server", "sl", "stats", "ss", "u", "e", "sie", "sb", "ops", "secondary", "ds", "n", "p", "fs", "sa", "c", "g", "ssl", "sq", "sym"]}}
{"project": "FFmpeg", "commit_id": "2005fddcbb4e18e8f7c34326e40609e4a2d83c31", "target": 0, "func": "int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)\n\n{\n\n    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };\n\n    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };\n\n\n\n    if (mode > 6U) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"out of range intra chroma pred mode at %d %d\\n\",\n\n               h->mb_x, h->mb_y);\n\n        return -1;\n\n    }\n\n\n\n    if (!(h->top_samples_available & 0x8000)) {\n\n        mode = top[mode];\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"top block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if ((h->left_samples_available & 0x8080) != 0x8080) {\n\n        mode = left[mode];\n\n        if (is_chroma && (h->left_samples_available & 0x8080)) {\n\n            // mad cow disease mode, aka MBAFF + constrained_intra_pred\n\n            mode = ALZHEIMER_DC_L0T_PRED8x8 +\n\n                   (!(h->left_samples_available & 0x8000)) +\n\n                   2 * (mode == DC_128_PRED8x8);\n\n        }\n\n        if (mode < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"left block unavailable for requested intra mode at %d %d\\n\",\n\n                   h->mb_x, h->mb_y);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    return mode;\n\n}\n", "idx": 3748, "substitutes": {"h": ["H", "ctx", "http", "bh", "q", "ih", "hw", "conn", "context", "dh", "hash", "host", "ht", "r", "header", "sh", "ph", "th", "hist", "k", "auth", "uh", "ha", "y", "g", "hu", "m", "hr", "ah", "ch", "home", "hm", "l", "c", "p", "hi", "him", "hh", "e", "f", "hd", "eh", "u", "hp", "history", "v", "hl", "adh", "um", "b", "t", "he", "hs", "kh", "oh", "rh", "gh"], "mode": ["route", "key", "device", "command", "dim", "success", "when", "go", "de", "move", "code", "mid", "direction", "home", "shift", "du", "theme", "message", "power", "option", "rage", "name", "time", "access", "ui", "type", "position", "id", "mi", "model", "max", "ode", "step", "gone", "state", "core", "maybe", "driver", "scale", "site", "Mode", "me", "MODE", "mate", "guide", "version", "mod", "mega", "ror", "ward", "use", "kind", "member", "language", "m", "project", "result", "role", "size", "date", "cmd", "phase", "error", "module", "rule", "slave", "ride", "stage", "cost", "match", "level", "delay", "no", "method", "grade", "purpose", "month", "ko", "side", "mage", "none", "mission", "style", "source", "md", "lane", "feature", "range", "depth", "ace", "rc"], "is_chroma": ["is_opera", "is_chromi", "is_chromA", "is_opero", "is_roman", "is_comas", "is_romb", "is_coma", "is_romas", "is_romo", "is_comA", "is_operb", "is_roma", "is_chromb", "is_operan", "is_operas", "is_romi", "is_romA", "is_operi", "is_chromas", "is_operA", "is_coman", "is_chromo", "is_chroman"], "top": ["call", "to", "primary", "above", "upper", "current", "high", "header", "ap", "head", "op", "first", "next", "max", "toc", "master", "config", "opt", "bot", "best", "pop", "hop", "prev", "front", "all", "up", "TOP", "dot", "full", "tops", "root", "Top", "bottom", "plus", "table"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void verdex_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t verdex_rom = 0x02000000;\n\n    uint32_t verdex_ram = 0x10000000;\n\n\n\n    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: \"pxa270-c0\");\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"verdex.rom\", verdex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, verdex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 99 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 99));\n\n}\n", "idx": 7334, "substitutes": {"machine": ["base", "mem", "vm", "device", "session", "config", "M", "gpu", "m", "image", "mac", "state", "linux", "service", "net", "connection", "instance", "Machine", "process", "computer", "boot", "node", "proc", "slave", "model", "cache", "loader", "manager", "mode"], "cpu_model": ["pixel_spec", "gpu_model", "pixel_model", "cpu_models", "cpu67location", "cpu__model", "cpu67spec", "cpuidmodel", "cpu_scale", "gpu_scale", "cpuworkmode", "cpu67model", "cpuablesize", "cpuablemodel", "pixel_size", "gpu_mode", "pixel__location", "pixel_location", "cpu_location", "cpuidmode", "gpu_space", "cpuworkspace", "cpu67size", "cpuworkmodel", "cpuidscale", "cpu__size", "cpu__location", "cpu_spec", "cpuablelocation", "cpuablespec", "cpu_mode", "cpu_space", " cpu_models", "pixel__spec", "cpuworkscale", "cpu__spec", "cpuidspace", "pixel__model", " cpu_mode", "pixel__size", "cpu_size"], "cpu": ["cp", "cmp", "bench", "gc", "hw", "chip", "mem", "platform", "pu", "vm", "io", " CPU", "gpu", "module", "uu", "unit", "ram", "pc", "linux", "net", "proxy", "clock", "instance", "kernel", "fps", "process", "result", "computer", "processor", "boot", "eni", "node", "memory", "proc", "GPU", "mx", "performance", "ilo", "lc", "core", "cache", "loader", "CPU", "conn", "copy"], "dinfo": ["pinfo", "dconfig", "finf", "pinf", "adinfo", "dbinfo", "dinf", "vdconf", "dfo", " dfi", "dbconfig", "dINFO", "ffo", "dInfo", "bfo", "ldinfo", "ldinf", "pfo", "pInfo", "dedinfo", "ldconf", "ffi", "fInfo", "vdfo", "dedconf", "dedInfo", " dconfig", "bconf", "dbINFO", "adINFO", "dbinf", "ldfi", " dinf", "dconf", " dfo", "finfo", " dInfo", "vdInfo", "binf", "ldfo", "adconfig", "vdinfo", "dedfo", "adinf", " dconf", " dINFO", "dfi", "binfo"], "be": ["replace", "enable", "nl", "BE", "bre", "ere", "le", "te", "are", "is", "Be", "b", "see", "use", "ignore", "ate", "bi", "ae", "ace", "ome", "ble", "bes", "de", "abe", "bee", "ve", "by", "fe", "ce", "byte", "eb", "ine", "e", " Be", "stop", "sb", "se", "we", "bis", "fore", "allow", "leave", "ape", " BE", "me", "ba", "ee", "ne", "scale", "ke", "range", "bf", "ro", "comb", "bl", "obe", "ze", "trace"], "address_space_mem": ["address_system_lim", "address_range_memory", "address_system_mem", "address_system_ram", "address_space_memory", "address_range_mem", "address_space_ram", "address_range_ram", "address_space_lim"]}}
{"project": "FFmpeg", "commit_id": "bc488ec28aec4bc91ba47283c49c9f7f25696eaa", "target": 1, "func": "av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c,\n\n                                     AVCodecContext *avctx,\n\n                                     unsigned high_bit_depth)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_mmx;\n\n\n        c->diff_pixels = ff_diff_pixels_mmx;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        if (!high_bit_depth)\n\n            c->get_pixels = ff_get_pixels_sse2;\n\n\n        c->diff_pixels = ff_diff_pixels_sse2;\n\n    }\n\n}", "idx": 4091, "substitutes": {"c": ["cm", "this", "acs", "cs", "ctx", "anc", "cc", "mc", "cl", "ct", "co", "bc", "cur", "con", "k", "tc", "enc", "i", "g", "ac", "m", "coll", "cr", "z", "ch", "config", "C", "ec", "dc", "ce", "cu", "p", "cv", "l", "w", "self", "lc", "f", "e", "cache", "ca", "sc", "cd", "u", "vc", "pc", "s", "v", "cp", "cmp", "t", "cf", "ci", "uc", "rc"], "avctx": [" avcmd", "AVctx", " avcontext", "afcmd", "avcmd", "avcb", "AVcmd", " avcb", "afctx", "afcontext", "AVcb", "AVcontext", "afcb", "avcontext"], "high_bit_depth": ["high_bitvaldetails", "high_bitbitrate", "high_check_depth", "high_pixelpcount", "high_bit_dim", "high_bitingsize", "high_bitvaldensity", "high_pixel_rate", "high_checkpredetails", "high_bitbitdim", "high_bitingrate", "high_pixel_count", "high_checkpredepth", "high_bitprate", "high_bitvaldepth", "high_checkpredensity", "high_bit_details", "high_bitingdepth", "high_bitpredepth", "high_pixel_depth", "high_bit_size", "high_bit_density", "high_pixelprate", "high_check_density", "high_bitingdim", "high_bitbitsize", "high_check_details", "high_bitbitdepth", "high_pixelpdepth", "high_bitpdepth", "high_bit_count", "high_bit_rate", "high_bitpredetails", "high_bitpredensity", "high_bitpcount"]}}
{"project": "FFmpeg", "commit_id": "bf87908cd8da31e8f8fe75c06577170928ea70a8", "target": 1, "func": "static int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb,\n\n                                     AVStream *st, RMStream *ast, int read_all)\n\n{\n\n    char buf[256];\n\n    uint32_t version;\n\n    int ret;\n\n\n\n    /* ra type header */\n\n    version = avio_rb16(pb); /* version */\n\n    if (version == 3) {\n\n        unsigned bytes_per_minute;\n\n        int header_size = avio_rb16(pb);\n\n        int64_t startpos = avio_tell(pb);\n\n        avio_skip(pb, 8);\n\n        bytes_per_minute = avio_rb16(pb);\n\n        avio_skip(pb, 4);\n\n        rm_read_metadata(s, 0);\n\n        if ((startpos + header_size) >= avio_tell(pb) + 2) {\n\n            // fourcc (should always be \"lpcJ\")\n\n            avio_r8(pb);\n\n            get_str8(pb, buf, sizeof(buf));\n\n        }\n\n        // Skip extra header crap (this should never happen)\n\n        if ((startpos + header_size) > avio_tell(pb))\n\n            avio_skip(pb, header_size + startpos - avio_tell(pb));\n\n        if (bytes_per_minute)\n\n            st->codec->bit_rate = 8LL * bytes_per_minute / 60;\n\n        st->codec->sample_rate = 8000;\n\n        st->codec->channels = 1;\n\n        st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = AV_CODEC_ID_RA_144;\n\n        ast->deint_id = DEINT_ID_INT0;\n\n    } else {\n\n        int flavor, sub_packet_h, coded_framesize, sub_packet_size;\n\n        int codecdata_length;\n\n        unsigned bytes_per_minute;\n\n        /* old version (4) */\n\n        avio_skip(pb, 2); /* unused */\n\n        avio_rb32(pb); /* .ra4 */\n\n        avio_rb32(pb); /* data size */\n\n        avio_rb16(pb); /* version2 */\n\n        avio_rb32(pb); /* header size */\n\n        flavor= avio_rb16(pb); /* add codec info / flavor */\n\n        ast->coded_framesize = coded_framesize = avio_rb32(pb); /* coded frame size */\n\n        avio_rb32(pb); /* ??? */\n\n        bytes_per_minute = avio_rb32(pb);\n\n        if (version == 4) {\n\n            if (bytes_per_minute)\n\n                st->codec->bit_rate = 8LL * bytes_per_minute / 60;\n\n        }\n\n        avio_rb32(pb); /* ??? */\n\n        ast->sub_packet_h = sub_packet_h = avio_rb16(pb); /* 1 */\n\n        st->codec->block_align= avio_rb16(pb); /* frame size */\n\n        ast->sub_packet_size = sub_packet_size = avio_rb16(pb); /* sub packet size */\n\n        avio_rb16(pb); /* ??? */\n\n        if (version == 5) {\n\n            avio_rb16(pb); avio_rb16(pb); avio_rb16(pb);\n\n        }\n\n        st->codec->sample_rate = avio_rb16(pb);\n\n        avio_rb32(pb);\n\n        st->codec->channels = avio_rb16(pb);\n\n        if (version == 5) {\n\n            ast->deint_id = avio_rl32(pb);\n\n            avio_read(pb, buf, 4);\n\n            buf[4] = 0;\n\n        } else {\n\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n\n            ast->deint_id = AV_RL32(buf);\n\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n\n        }\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(buf);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n\n\n        switch (st->codec->codec_id) {\n\n        case AV_CODEC_ID_AC3:\n\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n\n            break;\n\n        case AV_CODEC_ID_RA_288:\n\n            st->codec->extradata_size= 0;\n\n            ast->audio_framesize = st->codec->block_align;\n\n            st->codec->block_align = coded_framesize;\n\n            break;\n\n        case AV_CODEC_ID_COOK:\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n        case AV_CODEC_ID_ATRAC3:\n\n        case AV_CODEC_ID_SIPR:\n\n            if (read_all) {\n\n                codecdata_length = 0;\n\n            } else {\n\n                avio_rb16(pb); avio_r8(pb);\n\n                if (version == 5)\n\n                    avio_r8(pb);\n\n                codecdata_length = avio_rb32(pb);\n\n                if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n\n                    av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            ast->audio_framesize = st->codec->block_align;\n\n            if (st->codec->codec_id == AV_CODEC_ID_SIPR) {\n\n                if (flavor > 3) {\n\n                    av_log(s, AV_LOG_ERROR, \"bad SIPR file flavor %d\\n\",\n\n                           flavor);\n\n                    return -1;\n\n                }\n\n                st->codec->block_align = ff_sipr_subpk_size[flavor];\n\n            } else {\n\n                if(sub_packet_size <= 0){\n\n                    av_log(s, AV_LOG_ERROR, \"sub_packet_size is invalid\\n\");\n\n                    return -1;\n\n                }\n\n                st->codec->block_align = ast->sub_packet_size;\n\n            }\n\n            if ((ret = rm_read_extradata(pb, st->codec, codecdata_length)) < 0)\n\n                return ret;\n\n\n\n            break;\n\n        case AV_CODEC_ID_AAC:\n\n            avio_rb16(pb); avio_r8(pb);\n\n            if (version == 5)\n\n                avio_r8(pb);\n\n            codecdata_length = avio_rb32(pb);\n\n            if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n\n                av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n\n                return -1;\n\n            }\n\n            if (codecdata_length >= 1) {\n\n                avio_r8(pb);\n\n                if ((ret = rm_read_extradata(pb, st->codec, codecdata_length - 1)) < 0)\n\n                    return ret;\n\n            }\n\n            break;\n\n        default:\n\n            av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));\n\n        }\n\n        if (ast->deint_id == DEINT_ID_INT4 ||\n\n            ast->deint_id == DEINT_ID_GENR ||\n\n            ast->deint_id == DEINT_ID_SIPR) {\n\n            if (st->codec->block_align <= 0 ||\n\n                ast->audio_framesize * sub_packet_h > (unsigned)INT_MAX ||\n\n                ast->audio_framesize * sub_packet_h < st->codec->block_align)\n\n                return AVERROR_INVALIDDATA;\n\n            if (av_new_packet(&ast->pkt, ast->audio_framesize * sub_packet_h) < 0)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n        switch (ast->deint_id) {\n\n        case DEINT_ID_INT4:\n\n            if (ast->coded_framesize > ast->audio_framesize ||\n\n                sub_packet_h <= 1 ||\n\n                ast->coded_framesize * sub_packet_h > (2 + (sub_packet_h & 1)) * ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_GENR:\n\n            if (ast->sub_packet_size <= 0 ||\n\n                ast->sub_packet_size > ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_SIPR:\n\n        case DEINT_ID_INT0:\n\n        case DEINT_ID_VBRS:\n\n        case DEINT_ID_VBRF:\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"Unknown interleaver %X\\n\", ast->deint_id);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (read_all) {\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            rm_read_metadata(s, 0);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17752, "substitutes": {"s": ["ns", "types", "spec", "session", "bs", "t", "rs", "f", "sv", "settings", "sb", "sl", "ss", "ls", "ops", "fs", "parser", "cs", "bis", "sc", "ssl", "e", "ses", "cli", "scl", "c", "sync", "ps", "client", "p", "support", "b", "sys", "es", "os", "se", "sq", "sa", "ds", "sf"], "pb": ["pc", "wp", "plugin", "ab", "eb", "txt", "db", "phys", "fp", "jp", "platform", "vp", "usb", "pd", "pl", "bm", "sb", "pm", "bp", "cpp", "cb", "um", "bc", "src", "hub", "lp", "cp", "ctx", "fc", "xb", "lb", "wb", "nb", "fab", "posts", "PB", "parser", "dp", "pg", "prop", "gb", "rob", "summary", "pkg", "bps", "bf", "bot", "bh", "fb", "lc", "loc", "rb", "hp", "p", "plug", "mp", "b", "ppa", "SB", "proc", "api", "pro", "tp", "prot", "uf", "wikipedia", "pt", "lab", "typ"], "st": ["pt", "set", "ist", "est", "tt", "ts", "fr", "nd", "rest", "ct", "ess", "ste", "td", "str", "sb", "ost", "sl", "ss", "src", "ut", "th", "vd", "ld", "ST", "sd", "sta", "art", "l", "rd", "std", "sh", "stop", "sn", "sc", "bl", "sth", "cl", "kt", "sts", "St", "put", "inst", "et", "cast", "ft", "sa"], "ast": ["ans", "at", "ist", "est", "ab", "na", "ts", "nd", "af", "rest", "ref", "ct", "ess", "ar", "ost", "AST", "am", "master", "as", "node", "ST", "sta", "art", "att", "host", "ta", "aps", "aster", "Ast", "ac", "oid", "ad", "tta", "asm", "sam", "post", "rss", "test", "doc", "od", "dist", "asting", "ace", "a", "addr", "cast", "amd", "ma", "end", "asts", "an", "sa", "amp"], "read_all": ["read_data", "reader_all", "reader_total", "readbytotal", "reader_raw", "read_raw", "reader_data", "read_total", "readbydata", "readbyall", "readbyraw"], "buf": ["Buffer", "bin", "br", "db", "ff", "txt", "data", "fp", "text", "buffer", "rc", "feed", "block", "cb", "bc", "loc", "src", "cp", "wb", "ctx", "pos", "bb", "ba", "xff", "prop", "bo", "queue", "config", "bd", "fd", "buff", "fb", "v", "map", "batch", "rb", "seq", "tmp", "uc", "binary", "pad", "cmd", "b", "cap", " buffer", "bytes", "bag", "uf", "cv", " b"], "version": ["tun", "VERSION", "plugin", "brand", "vision", "shape", "code", "info", "mode", "name", "f", "platform", "option", "channel", "type", "available", "package", "python", "ception", "tag", "description", "release", "class", "format", "size", "Version", "length", "v", "position", "stage", "generation", "versions", "support", "driver", "feature", "depth", "beta", "number", "compatible", "message", "project", "connection", "server", "software", "section", "cv", "ver"], "ret": ["status", "info", "rc", "result", "quiet", "num", "max", "resp", "val", "final", "class", "Ret", "conv", "complete", "no", "con", "rev", "dev", "seq", "RET", "gen", "error", "res", " resp", " success", "lang", "success"], "bytes_per_minute": ["bytes_per_double", "bytes_PER_second", "bytes_Per_double", "bytes_PER_minute", "bytes_Per_min", "bytes_Per_minute", "bytes_per_month", "bytes_Per_month", "bytes_per_mand", "bytes_PER_day", "bytes_Per_second", "bytes_per_min", "bytes_per_second", "bytes_per_day"], "flavor": ["fluendor", "flavored", " flavored", "Flavored", "fluavorite", "fluavour", "FLavour", "Flavorite", "flavorite", " flendor", " flavour", "Flendor", "flavour", "FLavor", "FLavored", "Flavor", "Flavour", "FLendor", "fluavor", " flavorite", "flendor"], "sub_packet_h": ["sub_packacket_h", "sub_packet_length", "sub_packacket_size", "sub_packacket_length", "sub_packacket_count", "sub_packet_count"], "coded_framesize": ["coded_wordsize", "coded_filesizable", "coded_boardssize", "coded_timessize", "coded_framized", "coded_frameization", "coded_capsize", "coded_boardsized", "coded_boardsize", "coded_filesized", "coded_timesizable", "coded_capsized", "coded_frameize", "coded_framesizing", "coded_flowsize", "coded_flowssize", "coded_framessize", "coded_flowsization", "coded_filessize", "coded_wordsizing", "coded_filesize", "coded_framesization", "coded_capsizable", "coded_flowsizable", "coded_boardsizable", "coded_framize", "coded_timesize", "coded_framesizable", "coded_frameizable", "coded_framsize", "coded_wordssize", "coded_framizing", "coded_capssize", "coded_framesized", "coded_wordsized", "coded_timesization"], "sub_packet_size": ["sub_packetlistsized", "sub_packacket_sized", "sub_packetlistsize", "sub_packacket_size", "sub_packet_name", "sub_packacket_name", "sub_packet_sized", "sub_packetlistname"], "codecdata_length": ["codecdata_type", "codecdataqtype", "codecframe_type", "codecframeaclength", "codecdataaclength", "codecdata_capacity", "codecdataaccapacity", "codecdataactotal", "codecdata_total", "codecframe_total", "codecframeaccapacity", "codecdataqlength", "codecframe_capacity", "codecdataactype", "codecframe_length", "codecframeactype", "codecdataqtotal", "codecdataqcapacity", "codecframeactotal"]}}
{"project": "qemu", "commit_id": "91cda45b69e45a089f9989979a65db3f710c9925", "target": 0, "func": "static int get_segment64(CPUPPCState *env, struct mmu_ctx_hash64 *ctx,\n\n                         target_ulong eaddr, int rw, int type)\n\n{\n\n    hwaddr hash;\n\n    target_ulong vsid;\n\n    int pr, target_page_bits;\n\n    int ret, ret2;\n\n\n\n    pr = msr_pr;\n\n    ctx->eaddr = eaddr;\n\n    ppc_slb_t *slb;\n\n    target_ulong pageaddr;\n\n    int segment_bits;\n\n\n\n    LOG_MMU(\"Check SLBs\\n\");\n\n    slb = slb_lookup(env, eaddr);\n\n    if (!slb) {\n\n        return -5;\n\n    }\n\n\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;\n\n        segment_bits = 40;\n\n    } else {\n\n        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;\n\n        segment_bits = 28;\n\n    }\n\n\n\n    target_page_bits = (slb->vsid & SLB_VSID_L)\n\n        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\n\n    ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)\n\n                  : (slb->vsid & SLB_VSID_KS));\n\n    ctx->nx = !!(slb->vsid & SLB_VSID_N);\n\n\n\n    pageaddr = eaddr & ((1ULL << segment_bits)\n\n                            - (1ULL << target_page_bits));\n\n    if (slb->vsid & SLB_VSID_B) {\n\n        hash = vsid ^ (vsid << 25) ^ (pageaddr >> target_page_bits);\n\n    } else {\n\n        hash = vsid ^ (pageaddr >> target_page_bits);\n\n    }\n\n    /* Only 5 bits of the page index are used in the AVPN */\n\n    ctx->ptem = (slb->vsid & SLB_VSID_PTEM) |\n\n        ((pageaddr >> 16) & ((1ULL << segment_bits) - 0x80));\n\n\n\n    LOG_MMU(\"pte segment: key=%d nx %d vsid \" TARGET_FMT_lx \"\\n\",\n\n            ctx->key, ctx->nx, vsid);\n\n    ret = -1;\n\n\n\n    /* Check if instruction fetch is allowed, if needed */\n\n    if (type != ACCESS_CODE || ctx->nx == 0) {\n\n        /* Page address translation */\n\n        LOG_MMU(\"htab_base \" TARGET_FMT_plx \" htab_mask \" TARGET_FMT_plx\n\n                \" hash \" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, hash);\n\n        ctx->hash[0] = hash;\n\n        ctx->hash[1] = ~hash;\n\n\n\n        /* Initialize real address with an invalid value */\n\n        ctx->raddr = (hwaddr)-1ULL;\n\n        LOG_MMU(\"0 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                \" vsid=\" TARGET_FMT_lx \" ptem=\" TARGET_FMT_lx\n\n                \" hash=\" TARGET_FMT_plx \"\\n\",\n\n                env->htab_base, env->htab_mask, vsid, ctx->ptem,\n\n                ctx->hash[0]);\n\n        /* Primary table lookup */\n\n        ret = find_pte64(env, ctx, 0, rw, type, target_page_bits);\n\n        if (ret < 0) {\n\n            /* Secondary table lookup */\n\n            LOG_MMU(\"1 htab=\" TARGET_FMT_plx \"/\" TARGET_FMT_plx\n\n                    \" vsid=\" TARGET_FMT_lx \" api=\" TARGET_FMT_lx\n\n                    \" hash=\" TARGET_FMT_plx \"\\n\", env->htab_base,\n\n                    env->htab_mask, vsid, ctx->ptem, ctx->hash[1]);\n\n            ret2 = find_pte64(env, ctx, 1, rw, type, target_page_bits);\n\n            if (ret2 != -1) {\n\n                ret = ret2;\n\n            }\n\n        }\n\n    } else {\n\n        LOG_MMU(\"No access allowed\\n\");\n\n        ret = -3;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22399, "substitutes": {"env": ["bc", "priv", "enh", "txt", "en", "err", "eu", "config", "chal", "cv", "queue", "impl", "ea", "ef", "exc", "fg", "enc", "dict", "que", "np", "context", "Environment", "rc", "cb", "cfg", "loader", "viron", "fw", "req", "proc", "qt", "manager", "conf", "vm", "ev", "environment", "scope", "fi", "ec", "emb"], "ctx": ["conv", "lc", "git", "pb", "cc", "wcs", "gpu", "conn", "obj", "config", "hs", "event", "acl", "std", "pkg", "cv", "cm", "tx", "ca", "css", "cas", "fp", "cu", "ci", "cmp", "exec", "local", "exc", "cmd", "cp", "act", "cf", "xc", "ctrl", "kb", "context", "sync", "cli", "que", "comment", "rc", "c", "cb", "cn", "cfg", "sc", "gc", "qa", "general", "fw", "loc", "console", "zh", "utils", "util", "qt", "conf", "hw", "ck", "kw", "fn", "scope", "sq", "vc"], "eaddr": ["eadhr", "eddhr", "eddDR", "oadder", "eddbr", "ewder", "engrd", "engDR", "adr", "eebr", "ecdr", "oadhr", "awDR", "oaddr", "eadaddr", "ewDR", "awdr", "eedr", "execdr", "eehr", "eystr", "eadstr", "ewdr", "eadrd", "edddr", "hwrd", "addr", "acedr", "ecstr", "eeDR", "eadr", "awbr", "aedr", "adaddr", "eadbr", "acerr", "eadrr", "execstr", "eydr", "aeaddr", "eadder", "engder", "engdr", "execder", "oadDR", "awrd", "eadDR", "hwder", "aceder", "hwDR", "eyrr", "ecaddr", "aestr", "awder", "eyder", "adstr", "aer", "ewbr", "hwdr", "execrr", "oadbr", "ecr", "acestr"], "rw": ["reg", "class", "table", " pri", "ref", "rows", "eth", "mode", "tr", "rec", "wr", "rr", "rep", " flags", "weight", "buffer", " len", "res", "rc", "pool", "match", "xp", "w", "ptr", "src", "req", "dest"], "type": ["pb", "port", "Type", "name", "types", "shape", "class", "target", "ref", "ping", "val", "key", "TYPE", "style", "ty", "info", "version", "ip", "py", "ver", "ptr", "value", "ype", "len", "block", "lit", "pt", "format"], "hash": ["str", "hz", "ref", "ha", "val", "sha", "key", "height", "tr", "img", "kh", "msg", "cache", "version", "sum", "id", "number", "count", "depth", "mac", "auth", "rh", "pool", "header", "memory", "index", "ash", "num", "match", "search", "sh", "Hash", "value", "rev", "chip", " Hash", "html", "skip", "root", "v", "array", "h", "block", "image", "empty", "where", "ph"], "vsid": ["VSaid", "vside", "dsID", "hersID", "vesid", "VSparent", "veside", " vsID", " vsd", "pssid", "bsid", "versoid", "vs\n", "lside", "psid", "ss\n", "VS\n", "versids", "versuid", "ssbit", "cosd", "osids", "opensid", "vskey", " vsi", "vssid", "vsbit", "vassecret", "vasid", "dsids", "versi", "VSd", "csoid", "vsi", " vsaid", "VSname", "kinsparent", "cosid", "opensId", "dsid", "vsoid", "osID", "cside", " vskid", "ssaid", "umsid", "pside", "ssid", "vsip", " vside", "lsId", "obside", "vessecret", "vskid", "VSkid", "opsID", " vs0", "opensID", "VSsecret", "hersid", " vsname", "kinsid", " vsfile", "vsaid", "bsfile", "osid", "vsname", "psoid", "stsparent", "csid", "kinsID", "VSid", "VSID", "kinsId", "umsname", "obsid", "vasname", "vs0", "stsoid", "csname", "dskey", "vsids", "obsID", "stside", "Vsid", "Vsparent", "versname", "csID", "VSoid", "opsid", " vskey", "VSId", "cosId", "umsids", "vesId", "bsId", "VSsid", "versip", "lsID", "cosaid", "psuid", "obsId", "bsID", "vasId", "vessid", "vesID", "versite", "dside", "opsId", "VSip", " vsids", "versid", "vsd", "stsID", "stsid", " vsuid", "VS0", "umsID", "ss0", "lsid", "vsfile", "vsID", "vsuid", "stsId", "hersaid", "dsparent", "vssecret", "vsite", "opensfile", "versID", "psname", "Vside", " vsoid", "stskid", "stsite", "cskid", "VsID", " vsId", "psID", "vsId", " vsip", " vs\n", "oskey", "VSids", "VSbit", "vsparent", "psi", "ssID", "hersbit", "vesname", "VSide", "opsparent", "verskid", "csite"], "pr": ["PR", "ra", "Ra", "err", "val", "pe", "rx", "tr", "rr", "wr", "repl", "pc", "build", "lr", "pos", "po", "per", "pre", "r", "j", "rel", "arr", "p", "spr", "sa", "dr", "lo", "pl", "fr", "pin", "pro", "ver", "ch", "sr", "pull", "ptr", "seq", "cr", "fl", "gr", "br", "mr", "ps", "rs", "put", "up", "sp", "kr", "pt", "pa", "Pr"], "target_page_bits": ["target_page_bytes", "target_Page_pieces", "target_site_bytes", "target_page64pieces", "target_page_pieces", "target_site_pieces", "target_page64bit", "target_page_ints", "target_page2pieces", "target_page2bytes", "target_page_bit", "target_page32bits", "target_site_ints", "target_Page_bytes", "target_page32bytes", "target_pagepbytes", "target_page32bit", "target_page2bit", "target_pagepbits", "target_page64bytes", "target_page2bits", "target_page64bits", "target_pagepbit", "target_pagepints", "target_Page_bits", "target_site_bit", "target_site_bits", "target_page32pieces", "target_Page_bit"], "ret": ["reg", "def", "result", "val", "rep", "Ret", "res", "rel", "rets", "arr", "pin", "match", "RET", "mem", "seq", "rev", "re", "pat", "req", "proc", "alt", "sec", "nt", "lit", "resp", "fun", "pub"], "ret2": ["Ret1", "seq4", " ret4", " ret1", "ret1", "ret4", "seq2", "Ret2", "Ret4", "seq1"], "slb": ["sslbu", "llb", "slbs", " slB", "sslB", "Slbs", "mlr", " slr", "selob", "ellsb", "clb", "slob", " slab", "Slb", "blf", " slbb", "selab", "selb", "selp", "ellp", "Slf", "dlb", "dlbar", "slk", "islb", "ellab", "islB", "mlB", "Slbi", "dlB", "selbs", " slf", "sslib", "silb", "slf", "clB", "mlk", "mlb", "llbb", "slab", " slbs", "self", "slsb", "llf", "blb", "selr", "slbu", "slr", "SLb", " slib", "plbb", " slp", "clbi", "plb", "sslb", "slbar", " slbar", "llp", "mlib", "mlp", "slbi", "llB", "SLsb", "slB", "selB", "dlsb", "slib", "SLB", "islib", "silf", "blB", "SLbb", "islbu", "SlB", "dlob", "islsb", "SLf", "silB", "silab", "selib", "SLp", " slsb", "ellb", "slbb", " slbi", "SLbar", "plob", "SLab", "Slbb", "dlbb", "selbb", " slbu", "selk", "mlbb", "plB", "slp", " slk", "blab"], "pageaddr": ["pagebreak", "pagead", "screenatt", "screenaddr", " pagehop", "serverattr", " pageaddress", "screenaddress", "agead", " pageadd", "pageoffset", "recordattr", "pageattr", "gehop", " pageAddress", "pagehop", "ageflags", "pageatt", "serveraddr", "screenptr", "geaddress", " pageflags", "changeoffset", "ageaddress", "pageadd", "recordaddr", "changead", "diskatt", "pageAddress", "ageaddr", "recordaddress", "diskaddr", "changeaddress", "agebreak", "serveradd", "serveraddress", "_address", "recordadd", "imageaddr", "imageAddress", "changeaddr", "pageaddress", " pageattr", " pagebreak", " pageptr", " pagead", "imagehop", "_flags", "geAddress", "geaddr", "pageflags", " pageoffset", "_break", "pageptr", "imageaddress", "diskaddress", "_addr", "diskptr", " pageatt", "ageoffset"], "segment_bits": ["segmentnumabs", "segment_pieces", "sevisionationbits", "segment_abs", "segmentsbits", "sevision64files", "segmentnumcats", "segmentsbytes", "sevisionationabs", "segment64bits", "segment_flags", "sevision_pins", "segment54pins", "segment_cats", "segment36bits", "segmentationbits", "segmentnumbits", "segement_bytes", "segment64pins", "segment_files", "sevision_bits", "sevisionationpieces", "segment_locks", "sevision_pieces", "sevision64pins", "segmentnumpieces", "segment36cats", "sevision_files", "segment36abs", "segmentationcats", "segement_locks", "sevision_abs", "segmentsparts", "segmentationpieces", "segment64files", "sevision_cats", "segmentationabs", "segment54bits", "sevision64bits", "segment_pins", "segmentsflags", "segment_parts", "segment36pieces", "segment_bytes", "segement_bits", "segment54files", "segement_pieces", "sevisionationcats"]}}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "void bdrv_invalidate_cache_all(Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    Error *local_err = NULL;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n        bdrv_invalidate_cache(bs, &local_err);\n\n        aio_context_release(aio_context);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 4253, "substitutes": {"errp": ["raisepc", "erc", "erpc", "erP", "rarr", "rarc", "raiseP", "rarp", " errlp", "raisep", "errP", "errpc", "erpb", " errP", "raiselp", " errpc", " errc", "rarpb", "err", "errlp", " errpb", "erlp", "errc", "errr", "erp", "errpb", " errr"], "bs": ["bas", "base", "kit", "as", "bp", "lb", "ib", "ins", "is", "bits", "s", "bt", "bg", "b", "bps", "sync", "abi", "ses", "bi", "its", "BS", "fb", "bes", "ns", "state", "ls", "obj", "bb", "cs", "ss", "vs", "sb", "banks", "bis", "ds", "lib", "ctx", "bytes", "bc", "ba", "blocks", "boot", "css", "gb", "fs", "os", "bos", "bid", "ps", "bl", "pb", "rs", "src", "bh"], "local_err": ["localacerr", "global_msg", "local_bug", " local_state", "localserror", "localser", "localacver", "global_err", "localacrr", " local_rr", "localserr", " local_error", "localOer", "localacer", "localOerror", "local_msg", "global_error", "local_error", " local_er", "local_rr", "localsbug", "local_er", "localOerr", "local_ver", " local_bug", " local_ver", "global_er", "localOstate", "local_state"], "it": ["stat", "bas", "axis", "ib", "It", "iter", "bin", "ins", "id", "sit", "entry", "parent", "pit", "ite", "ci", "chain", "op", "i", "edit", "bit", "in", "its", "loc", "unit", "l", "lit", "j", "init", "which", "iti", "ibl", "iterator", "ait", "mit", "section", "ant", " It", "exec", "p", "jit", "and", "start", "IT", "ind", "ip", "ul", "c", "end"], "aio_context": ["aio__ctx", "aios_support", "aiojcontext", "aio_connection", "aio_ctx", "aiojproxy", "aiojctx", "aios_config", "aios_connection", "aioacctx", "aio__context", "aio__support", "aio_proxy", "aio_version", "aioaccontext", "aios_temp", "aiojconfig", "aios_version", "aios_ctx", "aios_context", "aios_proxy", "aio_support", "aio_config", "aioactemp", "aio__connection", "aioacversion", "aio_temp"]}}
{"project": "qemu", "commit_id": "42a6686b2f6199d086a58edd7731faeb2dbe7c14", "target": 0, "func": "void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)\n\n{\n\n    /* We're passed bits [11..0] of the instruction; extract\n\n     * SYSm and the mask bits.\n\n     * Invalid combinations of SYSm and mask are UNPREDICTABLE;\n\n     * we choose to treat them as if the mask bits were valid.\n\n     * NB that the pseudocode 'mask' variable is bits [11..10],\n\n     * whereas ours is [11..8].\n\n     */\n\n    uint32_t mask = extract32(maskreg, 8, 4);\n\n    uint32_t reg = extract32(maskreg, 0, 8);\n\n\n\n    if (arm_current_el(env) == 0 && reg > 7) {\n\n        /* only xPSR sub-fields may be written by unprivileged */\n\n        return;\n\n    }\n\n\n\n    switch (reg) {\n\n    case 0 ... 7: /* xPSR sub-fields */\n\n        /* only APSR is actually writable */\n\n        if (!(reg & 4)) {\n\n            uint32_t apsrmask = 0;\n\n\n\n            if (mask & 8) {\n\n                apsrmask |= XPSR_NZCV | XPSR_Q;\n\n            }\n\n            if ((mask & 4) && arm_feature(env, ARM_FEATURE_THUMB_DSP)) {\n\n                apsrmask |= XPSR_GE;\n\n            }\n\n            xpsr_write(env, val, apsrmask);\n\n        }\n\n        break;\n\n    case 8: /* MSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->v7m.other_sp = val;\n\n        } else {\n\n            env->regs[13] = val;\n\n        }\n\n        break;\n\n    case 9: /* PSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->regs[13] = val;\n\n        } else {\n\n            env->v7m.other_sp = val;\n\n        }\n\n        break;\n\n    case 16: /* PRIMASK */\n\n        env->v7m.primask[env->v7m.secure] = val & 1;\n\n        break;\n\n    case 17: /* BASEPRI */\n\n        env->v7m.basepri[env->v7m.secure] = val & 0xff;\n\n        break;\n\n    case 18: /* BASEPRI_MAX */\n\n        val &= 0xff;\n\n        if (val != 0 && (val < env->v7m.basepri[env->v7m.secure]\n\n                         || env->v7m.basepri[env->v7m.secure] == 0)) {\n\n            env->v7m.basepri[env->v7m.secure] = val;\n\n        }\n\n        break;\n\n    case 19: /* FAULTMASK */\n\n        env->v7m.faultmask = val & 1;\n\n        break;\n\n    case 20: /* CONTROL */\n\n        /* Writing to the SPSEL bit only has an effect if we are in\n\n         * thread mode; other bits can be updated by any privileged code.\n\n         * switch_v7m_sp() deals with updating the SPSEL bit in\n\n         * env->v7m.control, so we only need update the others.\n\n         */\n\n        if (!arm_v7m_is_handler_mode(env)) {\n\n            switch_v7m_sp(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0);\n\n        }\n\n        env->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK;\n\n        env->v7m.control |= val & R_V7M_CONTROL_NPRIV_MASK;\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"Attempt to write unknown special\"\n\n                                       \" register %d\\n\", reg);\n\n        return;\n\n    }\n\n}\n", "idx": 12452, "substitutes": {"env": ["en", "esp", "oa", "ah", "event", "gear", "server", "np", "obj", "dev", "export", "c", "end", "ep", "here", "ec", "lock", "ef", "args", "context", "rev", "iv", "eu", "vm", "txt", "skin", "console", "loader", "equ", "viron", "data", "ext", "entry", "eni", "qv", "uv", "cal", "exec", "gui", "cache", "ev", "ou", "el", "iss", "erv", "edge", "queue", "po", "ea", "cv", "config", "un", "style", "init", "scope", "app", "output", "conn", "stage", "e", "enable", "exc", "engine", "nc", "site", "eng", "qt", "Environment", "state", "global", "ne", "que", "inet", "net", "ctx", "err", "enc", "eye", "code", "er", "act", "v", "energy", "dat", "shell", "esc", "org", "db", "vel", "emb", "environment", "vs", "et", "esi", "esm"], "maskreg": ["filterbar", "filterregister", "maskrun", "switchReg", "switchrun", "filterrec", "askregister", "markREG", "askreg", "flagrec", "maskblock", " maskrec", "askbar", "markblock", "flagReg", "flagrun", "maskregister", "filterreg", " maskbar", "filterblock", "switchrec", "filterREG", "askrun", "maskREG", " maskREG", "flagreg", "maskReg", "markregister", "markreg", "switchreg", "maskrec", "askrec", "askReg", "askREG", "maskbar", "askblock"], "val": ["tx", "fl", "local", "def", "pre", "eval", "x", "vol", "loc", "pol", "ind", "mem", "dev", "Value", "sol", "pl", "base", "count", "play", "serv", "end", "text", "sl", "fail", "rot", "index", "bin", "arg", "key", "lib", "ut", "data", "b", "entry", "ann", "item", "arr", "cal", "pr", "al", "reg", "el", "vals", "alt", "slot", "config", "VAL", "test", "fx", "pret", "ref", "buffer", "unit", "update", "lit", "live", "pid", "valid", "value", "mask", "fe", "Val", "sel", "pos", "bl", "it", "ret", "enc", "pal", "pt", "cond", "v", "sil", "var", "col", "p", "ee", "buf", "ol", "rule", "all", "aval", "len"]}}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int check_physical (CPUState *env, mmu_ctx_t *ctx,\n\n                           target_ulong eaddr, int rw)\n\n{\n\n    int in_plb, ret;\n\n\n\n    ctx->raddr = eaddr;\n\n    ctx->prot = PAGE_READ;\n\n    ret = 0;\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n    case POWERPC_MMU_601:\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_REAL_4xx:\n\n    case POWERPC_MMU_BOOKE:\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_64BRIDGE:\n\n        /* Real address are 60 bits long */\n\n        ctx->raddr &= 0x0FFFFFFFFFFFFFFFULL;\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#endif\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        if (unlikely(msr_pe != 0)) {\n\n            /* 403 family add some particular protections,\n\n             * using PBL/PBU registers for accesses with no translation.\n\n             */\n\n            in_plb =\n\n                /* Check PLB validity */\n\n                (env->pb[0] < env->pb[1] &&\n\n                 /* and address in plb area */\n\n                 eaddr >= env->pb[0] && eaddr < env->pb[1]) ||\n\n                (env->pb[2] < env->pb[3] &&\n\n                 eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0;\n\n            if (in_plb ^ msr_px) {\n\n                /* Access in protected area */\n\n                if (rw == 1) {\n\n                    /* Access is not allowed */\n\n                    ret = -2;\n\n                }\n\n            } else {\n\n                /* Read-write access is allowed */\n\n                ctx->prot |= PAGE_WRITE;\n\n            }\n\n        }\n\n        break;\n\n    case POWERPC_MMU_BOOKE_FSL:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"BookE FSL MMU model not implemented\\n\");\n\n        break;\n\n    default:\n\n        cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 16431, "substitutes": {"env": ["viron", "ogen", "cf", "environment", "fen", "enc", "vm", "equ", "exec", "anne", "ev", "config", "ette", "qt", "cli", "ea", "vt", "dat", "end", "enh", "fi", "conn", "ion", "enable", "txt", "init", "cdn", "engine", "eu", "ne", "app", "erv", "dt", "self", "eng", "vert", "pect", "him", "het", "v", "dev", "ec", "et", "export", "org", "err", "net", "ou", "act", "inet", "network", "vs", "c", "pec", "edge", "eni", "np", "ah", "esi", "Environment", "db", "global", "info", "conf", "n", "exc", "loader", "oa", "en", "her", "context", "profile", "nc", "event", "site", "e", "cmd", "que", "cache", "proc", "server", "press"], "ctx": ["pc", "util", "na", "grad", "cc", "cfg", "btn", "wx", "obj", "cca", "vc", "rc", "exc", "cf", "cpp", "cb", "cp", "loc", "src", "bc", "wcs", "utils", "console", "git", "kw", "ctrl", "act", "cas", "ca", "exec", "css", "context", "cs", "hw", "acs", "std", "conv", "kb", "nc", "pkg", "tx", "ci", "config", "xc", "soc", "cu", "client", "cli", "lc", "c", "sync", "qa", "cmd", "ck", "sci", "cmp", "sys", "cn", "co", "sq", "cv", "conn"], "eaddr": ["EWfr", "eedbr", "eeder", "eadrr", "eebr", "evhr", "evder", "awdress", "eeDR", "ebDr", "eedDr", "awdr", "ebDR", "edrr", "elrr", "eedDR", "elder", "eddDR", "eerid", "eddbr", "eadDr", "eadbr", "eefr", "ealDR", "EWdr", "edder", "eaddress", "eldr", "eeddr", "ebdress", "eadder", "ebdr", "elhr", "aybr", "ayDR", "ealbr", "eedrr", "eadrid", "eddr", "awDr", "evdr", "EWDR", "aydr", "ayder", "eeddress", "edhr", "eedhr", "ealdr", "ealhr", "ealder", "edddr", "evrr", "eadDR", "eddder", "eadfr", "awDR", "eedr", "ealrr", "EWrid", "eedder", "eadhr"], "rw": ["rx", "wp", "rr", "fw", "wx", "RW", "r", "worker", "wl", "rack", "sw", "wb", "rg", "rew", "kw", "ew", "wk", "hw", "nr", "feat", "ww", "ffff", "w", "sr", "sth", "nw", "rb", "wer", "wr", "tw", "wu", "wh", "wn", "wa", "usr"], "in_plb": ["in_clbh", "in_plp", "in_plugbh", "in_PLa", "in_flB", "in_clB", "in_plc", "in_slb", "in_clb", "in_flab", "in_pelbh", "in_PLb", "in_plab", "in_plugb", "in_plugB", "in_cla", "in_pla", "in_plbh", "in_plugp", "in_clab", "in_plB", "in_fla", "in_flb", "in_slab", "in_clp", "in_pelp", "in_pelb", "in_clc", "in_slB", "in_pelB", "in_PLc", "in_sla", "in_PLp"], "ret": ["part", "code", "data", "al", "ref", "alt", "let", "lit", "r", "nt", "reg", "fun", "rt", "rc", "result", "try", "num", "sb", "match", "pass", "resp", "rets", "count", "def", "lt", "arg", "att", "art", "out", "val", "re", "Ret", "feat", "reset", "back", "last", "rot", "det", "fit", "id", "rev", "cur", "rl", "rb", "gt", "RET", "pet", "res", "mt", "ft", "valid", "addr", "reply", "success", "len"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int rv10_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    MpegEncContext *s = avctx->priv_data;\n\n    AVFrame *pict = data;\n\n    int i, ret;\n\n    int slice_count;\n\n    const uint8_t *slices_hdr = NULL;\n\n\n\n    av_dlog(avctx, \"*****frame %d size=%d\\n\", avctx->frame_number, buf_size);\n\n\n\n    /* no supplementary picture */\n\n    if (buf_size == 0) {\n\n        return 0;\n\n    }\n\n\n\n    if (!avctx->slice_count) {\n\n        slice_count = (*buf++) + 1;\n\n        buf_size--;\n\n\n\n        if (!slice_count || buf_size <= 8 * slice_count) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid slice count: %d.\\n\",\n\n                   slice_count);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        slices_hdr = buf + 4;\n\n        buf       += 8 * slice_count;\n\n        buf_size  -= 8 * slice_count;\n\n    } else\n\n        slice_count = avctx->slice_count;\n\n\n\n    for (i = 0; i < slice_count; i++) {\n\n        unsigned offset = get_slice_offset(avctx, slices_hdr, i);\n\n        int size, size2;\n\n\n\n        if (offset >= buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if (i + 1 == slice_count)\n\n            size = buf_size - offset;\n\n        else\n\n            size = get_slice_offset(avctx, slices_hdr, i + 1) - offset;\n\n\n\n        if (i + 2 >= slice_count)\n\n            size2 = buf_size - offset;\n\n        else\n\n            size2 = get_slice_offset(avctx, slices_hdr, i + 2) - offset;\n\n\n\n        if (size <= 0 || size2 <= 0 ||\n\n            offset + FFMAX(size, size2) > buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if ((ret = rv10_decode_packet(avctx, buf + offset, size, size2)) < 0)\n\n            return ret;\n\n\n\n        if (ret > 8 * size)\n\n            i++;\n\n    }\n\n\n\n    if (s->current_picture_ptr != NULL && s->mb_y >= s->mb_height) {\n\n        ff_er_frame_end(&s->er);\n\n        ff_MPV_frame_end(s);\n\n\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            if ((ret = av_frame_ref(pict, &s->current_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->current_picture_ptr);\n\n        } else if (s->last_picture_ptr != NULL) {\n\n            if ((ret = av_frame_ref(pict, &s->last_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->last_picture_ptr);\n\n        }\n\n\n\n        if (s->last_picture_ptr || s->low_delay) {\n\n            *got_frame = 1;\n\n        }\n\n\n\n        // so we can detect if frame_end was not called (find some nicer solution...)\n\n        s->current_picture_ptr = NULL;\n\n    }\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 18202, "substitutes": {"avctx": ["evcmp", "evctl", "afcmp", "auconn", "ajcontext", "avpkg", "averctx", "avctrl", "avhw", "airvoc", "abcontext", "avehw", "evcontext", "ajpkg", "afloc", "afcci", "avtx", "AVctx", "auctrl", " avcontext", "avalkw", "vertx", "ajhw", "avvoc", "Avctx", "airctx", "Avctl", "avctl", "aveconn", "afnp", "avercontext", "ajvoc", "akctrl", " avloc", "avalcli", "ajcci", "auctx", "abpkg", "ajctrl", "aucontext", "akcli", "aucf", "afctrl", " avcf", "AVloc", "afvoc", "avcci", "avcmp", "afcf", "aftx", "avcli", "vercontext", "avercli", "avalnp", "avalcci", "ajctx", "abcf", "avkw", " avpkg", "Avcontext", "avcf", "avloc", "avnp", "akctx", "AVcontext", "afkw", "avalctx", "avepkg", "afpkg", " avconn", "avalcontext", "avectx", "afctl", "verctx", "Avcmp", "averkw", "abctrl", "verpkg", "aircontext", "afhw", "afcontext", "akcontext", "ajnp", "avconn", "afctx", "abctx", "evctx", "avecontext", "AVcf", "aircci", "ajcli", "afconn", "abconn", "afcli", "autx", "avcontext", "aupkg"], "data": ["Data", "content", "au", "code", "reader", "sample", "base", "image", "f", "media", "buffer", "result", "window", "channel", "package", "padding", "slice", "o", "load", "d", "empty", "val", "array", "memory", "response", "start", "ad", "buff", "client", "parent", "tmp", "da", "p", "video", "address", "pad", "cache", "dat", "next", "body", "api", "DATA", "bytes", "message", "frame", "connection", "a", "value", "input"], "got_frame": ["buf_image", "buf_frames", "received_image", "buf_width", "bufvalframe", "bufvalwidth", "bufvalimage", "bufvalframes", "received_frames", "received_width", "received_frame", "buf_frame"], "avpkt": ["avppKT", "avcKT", "abcpfd", "avfkt", "avpKT", "evpacket", "avPkg", " avppk", "abcpkt", "avfct", "evpkg", "avcpkt", "avbpacket", "avvpk", "avbpkt", " avppkt", " avpKT", "avbpkg", "avpk", "avpkg", "abpfd", "evfkg", "avPsth", "avpfd", " avppKT", "abpkt", "avvpKT", " avppck", "avfsth", "abpct", "evpsth", "avppk", "avvpkt", "avpct", "avfkg", "avcpfd", " avpk", "evfsth", "avpck", " avpck", "avbpsth", "avpacket", "evpkt", "avffd", "avppkt", "avvpck", "evfkt", "abcpct", "avppck", "avvpacket", "avfacket", "avpsth", "abpacket", "abcpacket", "avvpfd", "avck", "avcck", "avvpct", "avPkt", "avcpct", "avcpacket", "evfacket", "avPacket", "avckt"], "buf": ["br", "func", "lim", "ctr", "true", "pool", "buffer", "rc", "vec", "result", "cf", "pack", "num", "window", "cb", "block", "cp", "bc", "loc", "src", "wb", "ctx", "pb", "pos", "cas", "xff", "home", "header", "array", "conv", "pkg", "feat", "av", "uu", "box", "aux", "img", "queue", "config", "front", "buff", "fb", "cur", "rb", "seq", "uc", "shift", "cmd", "off", "b", "cmp", "cap", "la", "alloc", "proc", "wa", "ha", "port", "bag", "uf", "cv", "len"], "s": ["ns", "spec", "m", "session", "j", "stats", "aws", "conf", "sv", "sp", "services", "service", "g", "sl", "ss", "utils", "self", "is", "cs", "d", "args", "sub", "sc", "ssl", "ses", "v", "sync", "c", "ps", "p", "S", "http", "gs", "sys", "storage", "a", "os", "se", "server", "sa"], "pict": ["fr", "arf", "fw", "ff", "af", " img", "image", "ref", "fa", " ff", "in", " f", "fs", "rf", "fo", "fl", "feat", "img", "rn", "w", "F", "fm", " fr", " fa", "aw", " r", "ft", " w", "cv", "wave"], "i": ["ti", "gi", "uri", "part", "bi", "init", "j", "ji", "code", "ami", "offset", "info", "x", "f", "name", "image", "ix", "ini", "qi", "r", "io", "mi", "ai", "phi", "g", "hi", "z", "ii", "ie", "in", "iu", "index", "di", "ind", "I", "slice", "multi", "zi", "mini", "is", "ip", "chi", "l", "oi", "pi", "uni", "ui", "ci", "id", "e", "ni", "c", "si", "p", "xi", "field", "h", "api", "it", "eni", "my", "fi", "esi", "inner", "y", "li", "u"], "ret": ["status", "info", "bit", "ref", "alt", "rc", "reg", "nt", "mi", "rt", "fun", "lit", "result", "r", "flag", "match", "ext", "fin", "mini", "mem", "def", "rets", "en", "arg", "bad", "val", "re", "Ret", "bf", "back", "value", "img", "xt", "det", "rb", " Ret", "RET", "error", "red", "res", "mt", "iter", "ft", "desc", "fi", "reply", "success", "len"], "slice_count": ["slice54size", " slice_loop", "slice_state", "slice_length", " slice_sum", "slice67div", "slice67count", " slice_label", "slice0count", "sliceNcount", "sliceablenumber", "slice54count", "slice0offset", "field_number", "byte67div", "byte_div", "field_offset", "field54number", "slice_limit", "slice67size", " slice_state", "slice54number", " slice_limit", "slicexgroup", "slice_div", "sliceOstate", "sliceNset", "sliceOlength", "field_count", "slice0number", "sliceablecount", " slice_length", " slice_size", "slice54offset", " slice_type", "slice67label", "field54size", " slice_start", "slice_number", " slice_queue", "sliceOstart", "slice4ref", " slice_group", "slice_group", "field54count", "slice_type", "byte67size", "sliceNsize", "slice4size", "slice_start", "slice_label", "sliceOcount", "slice_set", "slice_offset", "sliceablesize", "slice_ref", "byte_count", " slice_set", " slice_number", "field_size", " slice_ref", "byte_size", "slice_queue", "field54offset", "slice_loop", "byte67count", "sliceablelimit", "slice4count", "slice_size", "slice_sum", "slice0size", "slicexcount", "slicexloop"], "slices_hdr": ["slices_cdr", "slices_card", "slices_phdr", "slices_Hier", "slices_hr", "slices_shard", "slices_Hider", "slices_archdr", "slices_hstr", "slices_hier", "slices_Haddr", "slices_hhard", "slices_hhdr", "slices_hpider", "slices_shDR", "slices_hhtr", "slices_hDR", "slices_adhstr", "slices_adhict", "slices_phict", "slices_shdr", "slices_hard", "slices_hdier", "slices_hrt", "slices_hhDR", "slices_frt", "slices_shtr", "slices_archider", "slices_fhr", "slices_adhdr", "slices_hpdr", "slices_hddr", "slices_htr", "slices_hpaddr", "slices_cDR", "slices_Hr", "slices_hict", "slices_harrt", "slices_HDR", "slices_fdr", "slices_ctr", "slices_phstr", "slices_hpDR", "slices_harhr", "slices_haddr", "slices_hider", "slices_archaddr", "slices_archDR", "slices_hhr", "slices_hardr", "slices_Hdr"], "buf_size": ["buf00channel", "cap_len", "buflexuse", "bufcksize", "bufxize", "buf_sync", "uf_use", "buflexexternal", "bufsmax", "buff_external", "buf_set", "buflexcount", "buf_scale", "buf00small", "buff_use", "buf67sync", "uf_sec", "img67scale", "buff64count", "uf_scale", "queue_size", "queue_small", "buf64external", "cap67offset", "buf64size", "buf67size", "buf00size", "buff_max", "uf_capacity", "bufckcontent", "buf_channel", "cap_number", "img67size", "buff64size", "bufckcount", "uc_set", "buf_capacity", "buff_number", "uc_ize", "buf_external", "buf67send", "img_scale", "buf_content", "buf64ize", "uc_size", "bufckize", "buf_small", "bufcksmall", "buff64use", "uf_center", "queue_channel", "buf67len", "cap67len", "bufckscale", "buf00count", "uc_line", "buf_use", "buf16center", "cap_size", "buf64count", "bufxsize", "buf_send", "img_send", "buff_size", "img_size", "buf67number", "buf64line", "bufckchannel", "buf64set", "buff_count", "buf16size", "queue_count", "buf16use", "buf67offset", "buf_max", "buf_offset", "buf16scale", "buf64use", "img_sync", "img67send", "bufxline", "buf_ize", "cap67number", "uf_count", "uf_content", "buf_len", "bufxset", "uf_size", "buflexsize", "buf_sec", "bufsnumber", "buf_center", "buf_number", "img67sync", "cap_offset", "buf67scale", "cap67size", "buf_line", "buff64external", "uf_ize", "bufssize", "buf_count"], "size": ["set", "offset", "full", "pos", "empty", "new", "large", "length", "send", "age", "area", "Size", "len", "scale", "content", "name", "handle", "sort", "from", "timeout", "count", "last", "si", "iz", "shift", "gz", "weight", "code", "time", "core", "SIZE", "err", "image", "sized", "loc", "mini", "any", "speed", "ice", "page", "ize", "sync", "position", "address", "sum", "fee", "frame", "value", "izes", "capacity", "shape", "mode", "small", "esc", "slice", "en", "member", "ui", "use", "e", "unit", "video", "cap", "storage", "body", "second", "el"], "size2": ["speedTwo", "ize02", "size02", "speed1", "ize4", " size8", "size1", "name2", "scale1", "length5", " size4", "length2", "name8", "scaleTwo", "length82", " size5", "scale2", " size82", "size162", "ize3", "size5", "length02", "size3", "ize1", "speed62", "ize62", " size62", "size4", "size82", " size162", " size3", " sizeTwo", "ize2", "name1", "nameTwo", "scale3", "ize5", "ize8", " size1", "scale162", " size02", "speed2", "address2", "addressTwo", "lengthTwo", "size8", "ize162", "scale82", "length1", "size62", "address4", "izeTwo", "address1", "sizeTwo"]}}
{"project": "qemu", "commit_id": "4058fd98fd7e9c476774717adbd49698dd273166", "target": 0, "func": "cpu_x86_dump_seg_cache(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n                       const char *name, struct SegmentCache *sc)\n\n{\n\n#ifdef TARGET_X86_64\n\n    if (env->hflags & HF_CS64_MASK) {\n\n        cpu_fprintf(f, \"%-3s=%04x %016\" PRIx64 \" %08x %08x\", name,\n\n                    sc->selector, sc->base, sc->limit, sc->flags);\n\n    } else\n\n#endif\n\n    {\n\n        cpu_fprintf(f, \"%-3s=%04x %08x %08x %08x\", name, sc->selector,\n\n                    (uint32_t)sc->base, sc->limit, sc->flags);\n\n    }\n\n\n\n    if (!(env->hflags & HF_PE_MASK) || !(sc->flags & DESC_P_MASK))\n\n        goto done;\n\n\n\n    cpu_fprintf(f, \" DPL=%d \", (sc->flags & DESC_DPL_MASK) >> DESC_DPL_SHIFT);\n\n    if (sc->flags & DESC_S_MASK) {\n\n        if (sc->flags & DESC_CS_MASK) {\n\n            cpu_fprintf(f, (sc->flags & DESC_L_MASK) ? \"CS64\" :\n\n                           ((sc->flags & DESC_B_MASK) ? \"CS32\" : \"CS16\"));\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_C_MASK) ? 'C' : '-',\n\n                        (sc->flags & DESC_R_MASK) ? 'R' : '-');\n\n        } else {\n\n            cpu_fprintf(f, (sc->flags & DESC_B_MASK) ? \"DS  \" : \"DS16\");\n\n            cpu_fprintf(f, \" [%c%c\", (sc->flags & DESC_E_MASK) ? 'E' : '-',\n\n                        (sc->flags & DESC_W_MASK) ? 'W' : '-');\n\n        }\n\n        cpu_fprintf(f, \"%c]\", (sc->flags & DESC_A_MASK) ? 'A' : '-');\n\n    } else {\n\n        static const char *sys_type_name[2][16] = {\n\n            { /* 32 bit mode */\n\n                \"Reserved\", \"TSS16-avl\", \"LDT\", \"TSS16-busy\",\n\n                \"CallGate16\", \"TaskGate\", \"IntGate16\", \"TrapGate16\",\n\n                \"Reserved\", \"TSS32-avl\", \"Reserved\", \"TSS32-busy\",\n\n                \"CallGate32\", \"Reserved\", \"IntGate32\", \"TrapGate32\"\n\n            },\n\n            { /* 64 bit mode */\n\n                \"<hiword>\", \"Reserved\", \"LDT\", \"Reserved\", \"Reserved\",\n\n                \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\",\n\n                \"TSS64-avl\", \"Reserved\", \"TSS64-busy\", \"CallGate64\",\n\n                \"Reserved\", \"IntGate64\", \"TrapGate64\"\n\n            }\n\n        };\n\n        cpu_fprintf(f, \"%s\",\n\n                    sys_type_name[(env->hflags & HF_LMA_MASK) ? 1 : 0]\n\n                                 [(sc->flags & DESC_TYPE_MASK)\n\n                                  >> DESC_TYPE_SHIFT]);\n\n    }\n\ndone:\n\n    cpu_fprintf(f, \"\\n\");\n\n}\n", "idx": 27058, "substitutes": {"sys_type_name": ["sys_type2name", "sys_type_type", "sys_name2code", "sys_name2id", "sys_type_code", "sys_name2name", "sys_name_code", "sys_name_name", "sys_name_id", "sys_name_type", "sys_type_id", "sys_type2id", "sys_name2type", "sys_type2type", "sys_type2code"]}}
{"project": "FFmpeg", "commit_id": "fe448cd28d674c3eff3072552eae366d0b659ce9", "target": 0, "func": "static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n\n                                AVFrame *picture)\n\n{\n\n    int compno, reslevelno, bandno;\n\n    int x, y;\n\n\n\n    uint8_t *line;\n\n    Jpeg2000T1Context t1;\n\n\n\n    /* Loop on tile components */\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n\n        Jpeg2000Component *comp     = tile->comp + compno;\n\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n\n\n        /* Loop on resolution levels */\n\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n\n            /* Loop on bands */\n\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n                int nb_precincts, precno;\n\n                Jpeg2000Band *band = rlevel->band + bandno;\n\n                int cblkno = 0, bandpos;\n\n\n\n                bandpos = bandno + (reslevelno > 0);\n\n\n\n                if (band->coord[0][0] == band->coord[0][1] ||\n\n                    band->coord[1][0] == band->coord[1][1])\n\n                    continue;\n\n\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n\n                /* Loop on precincts */\n\n                for (precno = 0; precno < nb_precincts; precno++) {\n\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n                    /* Loop on codeblocks */\n\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n\n                        int x, y;\n\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n                        decode_cblk(s, codsty, &t1, cblk,\n\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n\n                                    bandpos);\n\n\n\n                        x = cblk->coord[0][0];\n\n                        y = cblk->coord[1][0];\n\n\n\n                        if (codsty->transform == FF_DWT97)\n\n                            dequantization_float(x, y, cblk, comp, &t1, band);\n\n                        else\n\n                            dequantization_int(x, y, cblk, comp, &t1, band);\n\n                   } /* end cblk */\n\n                } /*end prec */\n\n            } /* end band */\n\n        } /* end reslevel */\n\n\n\n        /* inverse DWT */\n\n        ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);\n\n    } /*end comp */\n\n\n\n    /* inverse MCT transformation */\n\n    if (tile->codsty[0].mct)\n\n        mct_decode(s, tile);\n\n\n\n    if (s->cdef[0] < 0) {\n\n        for (x = 0; x < s->ncomponents; x++)\n\n            s->cdef[x] = x + 1;\n\n        if ((s->ncomponents & 1) == 0)\n\n            s->cdef[s->ncomponents-1] = 0;\n\n    }\n\n\n\n    if (s->precision <= 8) {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            Jpeg2000Component *comp = tile->comp + compno;\n\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n            float *datap = comp->f_data;\n\n            int32_t *i_datap = comp->i_data;\n\n            int cbps = s->cbps[compno];\n\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n\n            int planar = !!picture->data[2];\n\n            int pixelsize = planar ? 1 : s->ncomponents;\n\n            int plane = 0;\n\n\n\n            if (planar)\n\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n\n\n\n            y    = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = picture->data[plane] + y * picture->linesize[plane];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint8_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = line + x * pixelsize + compno*!planar;\n\n\n\n                if (codsty->transform == FF_DWT97) {\n\n                    for (; x < w; x += s->cdx[compno]) {\n\n                        int val = lrintf(*datap) + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        *dst = val << (8 - cbps);\n\n                        datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                } else {\n\n                    for (; x < w; x += s->cdx[compno]) {\n\n                        int val = *i_datap + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        *dst = val << (8 - cbps);\n\n                        i_datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                }\n\n                line += picture->linesize[plane];\n\n            }\n\n        }\n\n    } else {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            Jpeg2000Component *comp = tile->comp + compno;\n\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n            float *datap = comp->f_data;\n\n            int32_t *i_datap = comp->i_data;\n\n            uint16_t *linel;\n\n            int cbps = s->cbps[compno];\n\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n\n            int planar = !!picture->data[2];\n\n            int pixelsize = planar ? 1 : s->ncomponents;\n\n            int plane = 0;\n\n\n\n            if (planar)\n\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n\n            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint16_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = linel + (x * pixelsize + compno*!planar);\n\n                if (codsty->transform == FF_DWT97) {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int  val = lrintf(*datap) + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                } else {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int val = *i_datap + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        i_datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                }\n\n                linel += picture->linesize[plane] >> 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 15420, "substitutes": {"s": ["sys", "m", "ses", "self", "bis", "d", "t", "sg", "service", "sky", "fs", "l", "i", "sync", "g", "cs", "sk", "os", "sets", "js", "si", "scope", "sq", "es", "session", "o", "u", "p", "e", "sec", "cli", "site", "sb", "sf", "n", "f", "gs", "spec", "c", "ns", "ssl", "sv", "sl", "ops", "services", "lex", "ds", "com", "ls", "ts", "space", "sports"], "tile": ["device", "ge", "port", "rice", "te", "slice", "t", "so", "style", "chip", "pixel", "sample", "audio", "image", "tg", "sk", "txt", "ie", "frame", "tri", "tto", "layer", "metadata", "e", "img", "cli", "kt", "site", "component", "ole", "ski", "tif", "setup", "dt", "phy", "tf", "file", "tle", "ele", "scale", "sl", "tu", "coll", "cell", "video", "Tile", "ile", "texture", "node"], "picture": [" f", " Frame", "cam", "fram", "iframe", "fb", "fm", " img", "fps", "audio", " pic", "image", "movie", "ref", "avi", "rame", "document", "media", "img", "fi", "play", "feature", " frame", " image", "mac", "video", "mpeg", "pic"], "compno": ["proplo", "componentno", "playnu", " compnu", "cmpno", "hostyes", "zipnon", "zipnu", "zipyes", "proppos", "hostnum", " compnum", "complo", "playna", "hostpos", "propno", "collpos", "cmporno", "componentlo", " comporno", "propna", "Compnum", " compyes", "hosteno", "compnon", "cmpyes", "comppos", "collnumber", "Compno", "collno", "Compeno", "compeno", "configyes", "domno", "confignon", "domnon", "collna", "hostnumber", "propnumber", "compyes", " compeno", "zipcho", "configno", "zipnumber", "componentpos", "compnum", "configcho", "Compyes", "compcho", "playno", "compnu", "zipna", "hostorno", " compna", "comporno", "componentnumber", "hostna", "playnumber", "compnumber", "cmpna", " complo", "domyes", "hostno", " compnumber", " comppos", "domcho", "compna", "zipno"], "reslevelno": ["resstagenos", "rescolnumber", "reslvlnos", "reslvlno", "reslayernos", "reslayerlo", " reslevelorno", "reslevelnon", "reslayer1", "resstagenumber", "reslevelsno", "reslayernumber", "resfullnos", "resstageno", "rescollno", "reslettern", "resslevelnt", "resalllo", "reslayerno", "reslayername", "resday1", " reslevelnum", "reslevelsnumber", "resslevelno", "resstagenum", "resallno", "resmodelno", "rusday1", "reslevelsorno", "rusdayname", "resletternum", "resdayname", "resmodelnum", "reslevelorno", "reslayernum", "preslayernum", "resfullnumber", "resallnum", "ressletterno", "resslevelnumber", "resscolnumber", " reslayerorno", "rezstageno", "reslvlnt", "resslevelnos", "reslevello", "resslettern", "rezlevelnumber", "reslevelnt", "rescolno", "rezlevelnon", "resfullno", "resletterno", "rezstagenumber", "resstagenon", "rescolnt", "resleveln", "reslevelnumber", " reslevelnumber", "resscolnt", "preslevelnum", "resletternumber", "ruslevelno", "rezstagenos", "reslayerorno", "resallname", "ruslevelname", "resallnos", "preslayernos", "rescolnos", "reslayernon", "preslayerno", "ressleveln", "ressletternum", "reslevelname", "rescollnum", " reslayernumber", "resstageorno", "reslayern", "ruslevel1", " reslayernum", "resmodeln", "reslevelnos", "resfullnon", "rezlevelno", "resscolnos", "ressletternumber", "rezstagenon", "reslayernt", "resslevelnum", " reslayerno", "rescollnos", "reslevelnum", "reslevel1", "preslayerlo", "reslvlnumber", "preslevello", "rescolllo", "resall1", "preslevelnos", "resscolno", "resdayno", "rusdayno", "rezlevelnos", "resmodelnumber", "preslevelno", "reslevelsnum"], "bandno": ["roadpo", "cellnum", "disklo", " bandNo", "tagyes", "bandnon", "roadlo", "blockno", "disksn", "patchno", "tagno", "cellNo", "fieldnumber", "roadno", "compnode", " bandnumber", "tagnu", "bootnum", "bandnos", "tagnos", "bootpo", "cellko", " bandnos", "patchna", " bandna", "bootpos", " bandnon", "blockyes", " bandko", "bootlo", " bandnu", "blockNo", "portNo", " bandeno", "diskno", "portnon", "bandsn", "patchnu", "bootno", " bandorno", "cellpos", "bandnumber", "bandnu", "celleno", "fieldno", "fieldko", "bandpo", "compnumber", "tagNo", "compko", "roadsn", "diskpo", "patchnos", "porteno", "cellno", "bandnode", " bandnum", "tagorno", "portno", " bandyes", "fieldnode", "bandlo", "blockorno", "cellnon", "bandyes", " bandnode", "bandna", "bootsn", "bandeno", "bootko", "tagna", "bandnum", "bandko", "bandNo", "bandorno"], "x": ["m", "d", "t", "on", "l", "i", "code", "val", "a", "name", "ex", "wx", "h", "image", "v", "o", "w", "yx", "dx", "z", "yl", "u", "p", "e", "rx", "b", "ix", "n", "f", "xx", "ax", "ip", "c", "X", "Y", "xy", "xxx", "pos", "height", "index"], "y": ["yt", "m", "d", "t", "_", "id", "lon", "i", "l", "ey", "g", "h", "this", "buffer", "ym", "o", "w", "yi", "dy", "col", "z", "yl", "obj", "p", "e", "b", "yo", "j", "n", "f", "oy", "ay", "vy", "ry", "type", "q", "year", "all", "r", "Y", "ya", "yy", "index", "sy"], "line": ["record", "lin", "code", "val", "l", "Line", "style", "source", "LINE", "cpu", "buffer", "unit", "frame", "output", "lay", "layer", "e", "time", "data", "lines", "mode", "block", "out", "link", "coll", "cell", "len"], "t1": ["t2", "c2", "m3", "c1", "T2", "f2", "t4", "T3", "m1", "tone", " t2", " t3", "T1", "t3", " tone", "f3", "T4", "fone", "c4", "m2", "c3", "m4", "f1", "Tone"], "comp": ["oper", "ch", "cop", "config", "cc", "Component", "Comp", "supp", "pixel", "def", "cond", "lc", "project", "ref", "unit", "cmp", "mod", "con", "loc", "app", "imp", "lib", "col", "prof", "clip", "p", "sec", "pack", "component", "b", "op", "omp", "cel", "dep", "spec", "c", "crit", "par", "pro", "common", "chrom", "coll", "com", "cell", "cp", "mac", "comm", "om", "seq", "prep", "hop", "prop", "company", "coord", "cl", "ctx", "comb"], "codsty": ["Codst", "codedsty", " codestyle", "chempoly", "compgy", "codpoly", "codesty", "compsys", "cmdty", "compsym", " codstyle", "cdety", "codst", "codty", "comppoly", "Codsty", "codedst", "cmdstyle", "cmdsty", " codty", "Codstal", " codsys", "codestyle", "codedety", "Codety", "cdsty", "codstyle", "codety", "codsys", "cbpoly", "cdst", " codsym", "codesys", "cmdsym", "cmdestyle", "codsym", "chemsty", "cmdsys", "codstal", "cbsty", "codedstal", "codeestyle", "cdstal", "compty", "chemgy", "cbgy", "chemty", "codgy", "cbty", "compsty"], "rlevel": ["prflow", "srinc", "arvel", " rpe", "brvel", "arlevel", "srlevel", "rlevels", "clevel", "bsync", "lcl", "arsync", "rinc", "linc", " rcomp", "Rpe", " rinc", "rflow", " rcl", "rpe", "brlevels", "rcl", "llevel", "rletter", " rlevels", "srcl", " rLevel", "clevels", "bvel", "ccoll", "rcomp", " rcoll", "lcomp", "bletter", "srlevels", "Rflow", "prlevels", " rletter", "ccomp", "lvel", "prpe", "lcoll", "Rlevels", "rvel", "rcoll", " rsync", "blevel", "rsync", "brLevel", " rflow", " rvel", "brlevel", "Rlevel", "prlevel", "lLevel", "arletter", "rLevel", "llevels"], "nb_precincts": ["nb_precincted", "nb_precruptes", "nb_precrits", "nb_precincting", "nb_precractes", "nb_preCritions", "nb_precributions", "nb_precresss", "nb_preCinctions", "nb_precruptions", "nb_precrited", "nb_preCrited", "nb_precrupte", "nb_precracts", "nb_precracted", "nb_precractions", "nb_prercruptors", "nb_preCinctes", "nb_preCincted", "nb_precrite", "nb_precinding", "nb_precrupts", "nb_precributs", "nb_preCrits", "nb_precrites", "nb_prercincte", "nb_preCunctes", "nb_precressions", "nb_precritions", "nb_prercincts", "nb_precinctions", "nb_prercinctions", "nb_prercrupts", "nb_precincte", "nb_precribute", "nb_precruptors", "nb_prercinctors", "nb_precrupted", "nb_precinctors", "nb_precunctions", "nb_precinds", "nb_prercruptions", "nb_precindions", "nb_precuncts", "nb_precindes", "nb_preCrites", "nb_precuncting", "nb_preCuncting", "nb_preCincts", "nb_precributors", "nb_precresses", "nb_precressing", "nb_precunctes", "nb_preCuncts", "nb_precinctes", "nb_precritors", "nb_prercrupte", "nb_preCincting", "nb_preCunctions"], "precno": ["prefmo", "prerecauto", "prekNo", "perfNo", "perfnone", "propnos", "prefNo", "prebyes", "procno", "percnone", "prefindex", "prechnone", " preceno", " precnone", "precindex", "prefauto", "perfno", "prebnos", "precnum", "prefeno", "prerecnone", "prepcindex", " prerecno", "precnone", " prerecNo", "precauto", "prerecnum", " precindex", "perfauto", "prechmo", " prepceno", "prercindex", " prepcindex", "prerecNo", "precatno", "prefyes", "prebpo", "precatyes", "prerecmo", "precnos", "percauto", " precmo", " prepcNo", "preknone", "precatnone", "prekyes", "precpo", "prercno", "procyes", "preceno", "prepyes", "perfyes", "preppo", "preacauto", "proppo", "percNo", "percnum", "perfnum", "precatnos", " prerecnone", "percno", "preacNo", " precNo", "percyes", "precmo", "prepnos", "prepno", "prechno", "prebno", "prepcno", "prepceno", "prefnum", "prekno", "propno", "prerceno", "procnos", "prechNo", "prepcNo", " prerecmo", "precyes", " prepcno", "precNo", "prerecno", "precatNo", "prercNo", "prefnone", "propyes", "procpo", "prefno", "preacnum", "preacno", "precatpo"], "band": ["word", "bridge", "device", "camp", "amp", "batch", "bound", "low", "audio", "event", "project", "dev", "play", "flow", "song", "bind", "broad", "book", "cell", "work", "tag", "bin", "part", "d", "ground", "bb", "product", "bus", "group", "Band", "version", "b", "length", "function", "host", "core", "brand", "bands", "service", "style", "bd", "connection", "plane", "guide", "app", "output", "layer", "stage", "boot", "co", "f", "gb", "loop", "ph", "bit", "channel", "board", "code", "back", "range", "bass", "gap", "contact", "pp", "position", "phase", "plugin", "ball", "direction", "component", "mode", "pair", "lab", "now", "cmd", "coll", "db", "coord"], "bandpos": ["groundpos", "bandloc", "bitposition", "Bandno", "bandPos", "cellno", "bitloc", "groundposition", "bootpo", "bandposition", "cellpos", "BandPos", "cellPos", "groundloc", "cellpo", "boardpo", "bitPos", "groundPos", "Bandpo", " bandposition", " bandPos", " bandpo", "bootpos", "bandpo", "bitpos", "boardposition", "Bandpos", "bootposition", " bandloc", "boardpos"], "prec": ["perb", "aref", " prek", "percs", "proc", "proci", "perv", "Preh", "pec", "precs", "arec", "pev", "prk", "calc", "pre", "prcu", "calf", "prc", "precu", "percu", "arecs", "preh", "pecs", "Prec", "perf", "arev", "prof", "Precu", "Preb", "prb", "perci", "prev", "pere", "pree", " pree", "calcu", "prf", "preb", "cale", " pref", "pref", "perh", "perc", "preci", "prh", "Preci", "procu", "pef", "Pref", "prek", "perk"], "cblkno": ["cblpyes", "cblkidyes", "cblcnum", "cblchnor", "cblkkno", "cblktno", "cplkyes", "cplkno", "cplkcho", "cblmknumber", "cbakNO", "cblkidnor", "cblcno", "cbakidno", "cblechno", "cblekpos", "cblktna", "cblkna", "cblqno", "cplqno", "cblknor", "cblkyes", "cblfeno", "cblfno", "cblikna", "cblkenor", "cblekorno", "cblcnumber", "cbleknor", "cmlkno", "cblekno", "cblikNO", "cblktpos", "cblnnum", "cplqcho", "cblechnor", "cblmknum", "cblqcho", "cblchpos", "cblpcho", "cblkNO", "cblmkno", "cplqNO", "cblikpos", "cblechorno", "cmlkeno", "cbakna", "cblfnum", "cblnno", "cblkcho", "cblqyes", "cblkpos", "cmlfno", "cmlfnum", "cblqNO", "cblkidcho", "cbakidna", "cblkeno", "cblechpos", "cblkidNO", "cblneno", "cblikno", "cbakidpos", "cblkidorno", "cblchno", "cbakno", "cblkepos", "cblksno", "cblknum", "cblcinfo", "cbakpos", "cbakidNO", "cblknumber", "cblpNO", "cblkknumber", "cblkidno", "cblkseno", "cmlknum", "cblpno", "cblkinfo", "cmlfeno", "cblksnum", "cblkkinfo", "cplqyes", "cblkidpos", "cplkNO", "cblkeorno", "cblmkinfo", "cblchorno", "cblktNO", "cblkorno", "cblkidna", "cblkknum"], "cblk": ["cblck", "cblke", " crelks", "cbrc", "cplk", "crenak", "cBlke", "cwnc", "cwnb", " cblkin", "ecglck", "cblak", "cablkk", "crelc", "crelks", "callkt", " cablsk", "cglkid", "cablsk", " crelk", "crelb", " crelok", "cBlsk", " crelb", " cablkk", " cblok", "crenk", "cblc", "cronsk", "cllkid", "dblkh", "Cblkin", " cblb", "cglk", " cablk", " cablkin", "crelsk", "cllk", "cBlkin", "cllok", "callsk", "cllc", "cBlc", " cblc", "cablkin", "dmlck", "ecblkin", "crelok", " cblke", "cblkin", "cblkt", "cllck", "ecglkin", "cwnok", "scblak", "cplsk", "crensk", "scablak", "dmlk", "cmlkin", "dmlke", "cbalkin", "callak", "dblck", "cblb", "cronk", "cbrks", "crelk", "cmlck", "cablak", "cbrk", "dblkin", "dmlkin", "cblkid", "dblke", " crelc", " crelsk", "csynk", " crelke", "cllkin", "cglck", "cbrkin", "CBlks", "cronkin", "Cblk", "cBlks", "scblsk", "cronkk", "Cblks", " cblsk", "callk", "scablsk", "ecglkid", "cmlk", "cllb", "cblks", "cblkk", "cplks", "cplke", "scblkt", "csynkk", "cbalck", "CBlk", "CBlc", "scablkt", "cmlke", "scablk", "dblk", "cablkt", "csynsk", "cbalk", "cglkin", " cblkk", "dmlkh", "scblk", "cblkh", "cablk", " cblks", "crelke", "ecblk", "ecblck", "cwnk", "cblok", "cmlkh", "cblsk", "CBlkin", "cllks", "csynkin", "ecblkid", "ecglk", "cBlk", "Cblc", "crenkt", "cbalke"]}}
{"project": "qemu", "commit_id": "5229f45bd98558af84d806a98032df3cb741c357", "target": 0, "func": "AUXReply aux_request(AUXBus *bus, AUXCommand cmd, uint32_t address,\n\n                      uint8_t len, uint8_t *data)\n\n{\n\n    AUXReply ret = AUX_NACK;\n\n    I2CBus *i2c_bus = aux_get_i2c_bus(bus);\n\n    size_t i;\n\n    bool is_write = false;\n\n\n\n    DPRINTF(\"request at address 0x%\" PRIX32 \", command %u, len %u\\n\", address,\n\n            cmd, len);\n\n\n\n    switch (cmd) {\n\n    /*\n\n     * Forward the request on the AUX bus..\n\n     */\n\n    case WRITE_AUX:\n\n    case READ_AUX:\n\n        is_write = cmd == READ_AUX ? false : true;\n\n        for (i = 0; i < len; i++) {\n\n            if (!address_space_rw(&bus->aux_addr_space, address++,\n\n                                  MEMTXATTRS_UNSPECIFIED, data++, 1,\n\n                                  is_write)) {\n\n                ret = AUX_I2C_ACK;\n\n            } else {\n\n                ret = AUX_NACK;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n    /*\n\n     * Classic I2C transactions..\n\n     */\n\n    case READ_I2C:\n\n    case WRITE_I2C:\n\n        is_write = cmd == READ_I2C ? false : true;\n\n        if (i2c_bus_busy(i2c_bus)) {\n\n            i2c_end_transfer(i2c_bus);\n\n        }\n\n\n\n        if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n            ret = AUX_I2C_NACK;\n\n            break;\n\n        }\n\n\n\n        ret = AUX_I2C_ACK;\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        i2c_end_transfer(i2c_bus);\n\n        break;\n\n    /*\n\n     * I2C MOT transactions.\n\n     *\n\n     * Here we send a start when:\n\n     *  - We didn't start transaction yet.\n\n     *  - We had a READ and we do a WRITE.\n\n     *  - We changed the address.\n\n     */\n\n    case WRITE_I2C_MOT:\n\n    case READ_I2C_MOT:\n\n        is_write = cmd == READ_I2C_MOT ? false : true;\n\n        if (!i2c_bus_busy(i2c_bus)) {\n\n            /*\n\n             * No transactions started..\n\n             */\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        } else if ((address != bus->last_i2c_address) ||\n\n                   (bus->last_transaction != cmd)) {\n\n            /*\n\n             * Transaction started but we need to restart..\n\n             */\n\n            i2c_end_transfer(i2c_bus);\n\n            if (i2c_start_transfer(i2c_bus, address, is_write)) {\n\n                ret = AUX_I2C_NACK;\n\n                break;\n\n            }\n\n        }\n\n\n\n        while (len > 0) {\n\n            if (i2c_send_recv(i2c_bus, data++, is_write) < 0) {\n\n                ret = AUX_I2C_NACK;\n\n                i2c_end_transfer(i2c_bus);\n\n                break;\n\n            }\n\n            len--;\n\n        }\n\n        bus->last_transaction = cmd;\n\n        bus->last_i2c_address = address;\n\n        ret = AUX_I2C_ACK;\n\n        break;\n\n    default:\n\n        DPRINTF(\"Not implemented!\\n\");\n\n        return AUX_NACK;\n\n    }\n\n\n\n    DPRINTF(\"reply: %u\\n\", ret);\n\n    return ret;\n\n}\n", "idx": 22330, "substitutes": {"bus": ["io", "bc", "port", "ux", "fi", "usb", "config", "drive", "driver", "board", "controller", "mount", "loop", "db", "connection", "plugin", "Bus", "bridge", "host", "product", "engine", "device", "proxy", "bug", "cache", "cat", "socket", "lock", "serial", "us", "sync", "plug", "service", "hub", "BUS", "feed", "boot", "lib", "http", "user", "base"], "cmd": ["md", "name", "grad", "class", "kind", "def", "cd", "cc", "conn", "bind", "send", "config", "pkg", "ctr", "cookie", "mode", "ack", "cm", "func", "handler", "plugin", "host", "cl", "device", "node", "cmp", "path", "ctrl", "Cmd", "msg", "head", "nd", "mid", "method", "id", "prefix", "code", "addr", "count", "mac", "fun", "buf", "content", "header", "ctx", "module", "cb", "client", "cfg", "c", "num", "dc", "seq", "magic", "comm", "call", "callback", "cli", "req", "domain", "MD", "proc", "cod", "command", "type"], "address": ["route", "package", "target", "attribute", "shape", "end", "object", "config", "event", "eni", "ress", "message", "connection", "uri", "handler", "host", "device", "path", "order", "slave", "size", "component", "ip", "ace", "number", "point", "addr", "attr", "content", "header", "network", "index", "source", "Address", "service", "location", "alias", "date", "channel", "enter", "error", "length", "email", "each", "grade", "array", "pointer", "resource", "image", "position", "server", "offset", "inet", "output", "command", "interface"], "len": ["lc", "delay", "limit", "un", "en", "end", "conn", "ind", "sl", "nn", "non", "val", "ln", "ld", "offset", "f", "pos", "lan", "split", "size", "fin", "lock", "list", "del", "lin", "fun", "addr", "body", "dy", "gen", "el", "lim", "num", "pl", "dim", "mem", "line", "seq", "lvl", "dl", "n", "length", "fl", "min", "loc", "ll", "partial", "lon", "alt", "nt", "li", "fn", "lf", "block", "all", "l", "base", "Len", "url", "count"], "data": ["delay", "after", "str", "name", "start", "def", "response", "config", "result", "input", "message", "Data", "connection", "queue", "d", "uri", "bytes", "pad", "buffer", "msg", "size", "ad", "cache", "new", "id", "addr", "body", "load", "buf", "content", "memory", "byte", "a", "DATA", "reply", "channel", "length", "reader", "di", "alpha", "dat", "block", "command", "format"], "i2c_bus": ["i2cu__usb", "i2c2bus", "i2c_plugin", "i2ct_proc", "i2ctADblock", "i2xc_fail", "i2cin_die", "i2c_Bus", "i2cADbus", "i2xc_serial", "i2cu__loop", "i2ce_bus", "i2cPubplugin", "i2vcAMspace", "i2f_usb", "i2cJbus", "i2ch_bit", "i2chJplugin", "i2f_bus", "i2xc_root", "i2c6boot", "i2cin_block", "i2chJboot", "i2c_die", "i2cADblock", "i2c_driver", "i2c__usb", "i2c_root", "i2cAMcontroller", "i2cPubbus", "i2vc_space", "i2c6space", "i2ctADbus", "i2vc_controller", "i2c_ux", "i2cin_bus", "i2cu__bus", "i2c_bis", "i2vc_boot", "i2c_usb", "i2c_serial", "i2c6controller", "i2cADux", "i2ch_plugin", "i2c_bit", "i2c_use", "i2c_proc", "i2c__loop", "i2cPubbit", "i2ch_boot", "i2c_space", "i2ct_ux", "i2cin_bis", "i2vcAMbus", "i2c_fail", "i2c_block", "i2c6bus", "i2vcAMcontroller", "i2f_bridge", "i2ce_controller", "i2cAMboot", "i2cJboot", "i2cJbit", "i2f_Bus", "i2cADproc", "i2cu__boot", "i2cJplugin", "i2ctADux", "i2ct_bus", "i2ct_block", "i2cPubboot", "i2cu_loop", "i2c_loop", "i2c__bridge", "i2chJbit", "i2cAMbus", "i2cu_bus", "i2c2bridge", "i2ce_use", "i2xc_bus", "i2c__bus", "i2vcAMboot", "i2c2usb", "i2cAMspace", "i2ch_bus", "i2c2Bus", "i2c__Bus", "i2c_boot", "i2cu_usb", "i2c_controller", "i2ctADproc", "i2chJbus", "i2cu_boot", "i2c__boot", "i2ce_driver", "i2vc_bus", "i2c_bridge"], "i": ["io", "udi", "ix", "e", "qi", "ri", "ind", "eni", "ui", "val", "pi", "gi", "d", "uri", "ti", "I", "f", "buffer", "ci", "info", "phi", "m", "s", "ini", "j", "oi", "ip", "p", "abi", "id", "addr", "is", "mi", "c", "index", "si", "a", "ii", "b", "n", "iu", "ai", "xi", "di", "v", "multi", "array", "li", "block", "l", "fi", "ni", "type"]}}
{"project": "FFmpeg", "commit_id": "d59bfcd11229300182c672ca734568919a85f773", "target": 1, "func": "static void mov_update_dts_shift(MOVStreamContext *sc, int duration)\n\n{\n\n    if (duration < 0) {\n\n\n\n\n\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n\n", "idx": 21385, "substitutes": {"sc": ["lc", "bc", "SC", "fc", "cc", "cam", "uc", "esc", "sk", "sci", "asc", "sche", "cv", "ca", "Sc", "cur", "pc", "cl", "cmp", "enc", "cs", "cer", "cf", "tc", "context", "rc", "c", "ctx", "spec", "dc", "soc", "cr", "desc", "src", "loc", "usc", "osc", "cms", "scope", "ec"], "duration": ["span", "delay", "port", "period", "attribute", "end", "event", "until", "time", "d", "uri", "pause", "feature", "pad", "device", "uration", "series", "sequence", "data", "lasting", "design", "Duration", "dimension", "component", "unit", "number", "depth", "context", "timeout", "tube", "audio", "document", "distance", "window", "direction", "date", "length", "database", "stage", "range", "doc", "frequency", "gap", "resource", "sleep", "repeat", "video"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,\n\n                                     TCGv cmp, int32_t disp)\n\n{\n\n    uint64_t dest = ctx->pc + (disp << 2);\n\n    int lab_true = gen_new_label();\n\n\n\n    if (use_goto_tb(ctx, dest)) {\n\n        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);\n\n\n\n        tcg_gen_goto_tb(0);\n\n        tcg_gen_movi_i64(cpu_pc, ctx->pc);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb);\n\n\n\n        gen_set_label(lab_true);\n\n        tcg_gen_goto_tb(1);\n\n        tcg_gen_movi_i64(cpu_pc, dest);\n\n        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);\n\n\n\n        return EXIT_GOTO_TB;\n\n    } else {\n\n        TCGv_i64 z = tcg_const_i64(0);\n\n        TCGv_i64 d = tcg_const_i64(dest);\n\n        TCGv_i64 p = tcg_const_i64(ctx->pc);\n\n\n\n        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);\n\n\n\n        tcg_temp_free_i64(z);\n\n        tcg_temp_free_i64(d);\n\n        tcg_temp_free_i64(p);\n\n        return EXIT_PC_UPDATED;\n\n    }\n\n}\n", "idx": 10064, "substitutes": {"ctx": ["cpu", "cdn", "cam", "wp", "context", "Context", "cca", "conn", "tc", "sci", "c", "cp", "config", "qq", "cu", "cli", "cb", "np", "txt", "cf", "cn", "wcs", "fp", "loc", "hw", "bc", "cc", "cs", "ctrl", "cus", "cv", "ck", "parse", "sync", "rc", "connection", "cas", "conv", "tx", "qa", "pc", "wx", "xc", "git", "cpp", "cms", "nc", "cfg", "cm", "ca", "client", "grad", "ci", "fc", "wordpress", "vc", "anc", "cmd", "lc", "pkg", "mc", "kb", "sc", "exec"], "cond": ["diff", "conf", "reason", "proc", "fail", "def", "temp", "Cond", "red", "c", "comb", "config", "cp", "obj", "cb", "reg", "cf", "condition", "loc", "cod", "prop", "sec", "df", "bc", "code", "unit", "pkg", " Cond", "cas", "conv", "pre", "desc", "cl", "xc", "com", "lock", "prep", "pos", "fc", "comp", "func", "lc", "cmd", "crit", "resp", "cell", "exec"], "cmp": ["cpu", "diff", "conf", "seq", "Compare", "gen", "co", "proc", "cp", "c", "config", "component", "cb", "upp", "fp", "cup", "np", "pro", "loc", "prop", "coll", "tmp", "op", "bc", "cho", "pkg", "omp", "ctrl", "mp", "cop", "agg", "cas", "conv", "jp", "desc", "rep", "cor", "com", "cpp", "Comp", "prep", "comm", "pos", "clip", "comp", "mom", "lc", "cmd", "crit", "resp", "imp"], "disp": ["demp", "discp", "DISp", "disps", " dispp", " Disps", "dislp", "DISP", "dempp", "despp", "dembp", "desp", "Disps", " disbp", "desbp", "DISps", "disP", "deslp", "dispp", "DisP", " Disp", "demlp", " dislp", " DisP", "Discp", " Discp", "DIScp", "disbp", "Disp"]}}
{"project": "qemu", "commit_id": "8991c460be5a0811194fd4d2b49ba7146a23526b", "target": 1, "func": "static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)\n\n{\n\n    return s->iq_tail == 0;\n\n}\n", "idx": 3394, "substitutes": {"s": ["js", "cs", "ss", "ops", "ts", "sb", "ips", "aws", "results", "ins", "ans", "ils", "ses", "ls", "settings", "sets", "als", "ds", "ps", "gs", "ns", "ares", "p", "rates", "services", "e", "es", "ches", "sys", "rows", "o", "b", "ves", "S", "ks", "states", "ures", "fs", "ows", "sym", "ssl"]}}
{"project": "FFmpeg", "commit_id": "e048a9cab10f1d41dca7b1ad9c8ecaceb3424d86", "target": 1, "func": "static int pcm_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    PCMDecode *s = avctx->priv_data;\n    int sample_size, c, n, i;\n    short *samples;\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n    uint8_t *dstu8;\n    int16_t *dst_int16_t;\n    int32_t *dst_int32_t;\n    int64_t *dst_int64_t;\n    uint16_t *dst_uint16_t;\n    uint32_t *dst_uint32_t;\n    samples = data;\n    src = buf;\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n        return -1;\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n        return -1;\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n        /* 2 samples are interleaved per block in PCM_DVD */\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n    else if (avctx->codec_id == CODEC_ID_PCM_LXF)\n        /* we process 40-bit blocks per channel for LXF */\n        sample_size = 5;\n    n = avctx->channels * sample_size;\n    if(n && buf_size % n){\n        if (buf_size < n) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n            return -1;\n        }else\n            buf_size -= buf_size % n;\n    buf_size= FFMIN(buf_size, *data_size/2);\n    *data_size=0;\n    n = buf_size/sample_size;\n    switch(avctx->codec->id) {\n    case CODEC_ID_PCM_U32LE:\n        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_U32BE:\n        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_S24LE:\n        DECODE(int32_t, le24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_S24BE:\n        DECODE(int32_t, be24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_U24LE:\n        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_U24BE:\n        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_S24DAUD:\n        for(;n>0;n--) {\n          uint32_t v = bytestream_get_be24(&src);\n          v >>= 4; // sync flags are here\n          *samples++ = av_reverse[(v >> 8) & 0xff] +\n                       (av_reverse[v & 0xff] << 8);\n        break;\n    case CODEC_ID_PCM_S16LE_PLANAR:\n        n /= avctx->channels;\n        for(c=0;c<avctx->channels;c++)\n            src2[c] = &src[c*n*2];\n        for(;n>0;n--)\n            for(c=0;c<avctx->channels;c++)\n                *samples++ = bytestream_get_le16(&src2[c]);\n        src = src2[avctx->channels-1];\n        break;\n    case CODEC_ID_PCM_U16LE:\n        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_U16BE:\n        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_S8:\n        dstu8= (uint8_t*)samples;\n        for(;n>0;n--) {\n            *dstu8++ = *src++ + 128;\n        samples= (short*)dstu8;\n        break;\n#if HAVE_BIGENDIAN\n    case CODEC_ID_PCM_F64LE:\n        DECODE(int64_t, le64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_F32LE:\n        DECODE(int32_t, le32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16LE:\n        DECODE(int16_t, le16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64BE:\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n    case CODEC_ID_PCM_S16BE:\n#else\n    case CODEC_ID_PCM_F64BE:\n        DECODE(int64_t, be64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n        DECODE(int32_t, be32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16BE:\n        DECODE(int16_t, be16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64LE:\n    case CODEC_ID_PCM_F32LE:\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_S16LE:\n#endif /* HAVE_BIGENDIAN */\n    case CODEC_ID_PCM_U8:\n        memcpy(samples, src, n*sample_size);\n        src += n*sample_size;\n        samples = (short*)((uint8_t*)data + n*sample_size);\n        break;\n    case CODEC_ID_PCM_ZORK:\n        for(;n>0;n--) {\n            int x= *src++;\n            if(x&128) x-= 128;\n            else      x = -x;\n            *samples++ = x << 8;\n        break;\n    case CODEC_ID_PCM_ALAW:\n    case CODEC_ID_PCM_MULAW:\n        for(;n>0;n--) {\n            *samples++ = s->table[*src++];\n        break;\n    case CODEC_ID_PCM_DVD:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        switch (avctx->bits_per_coded_sample) {\n        case 20:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n                src = src8;\n            break;\n        case 24:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                src = src8;\n            break;\n        default:\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n            return -1;\n            break;\n        samples = (short *) dst_int32_t;\n        break;\n    case CODEC_ID_PCM_LXF:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        //unpack and de-planerize\n        for (i = 0; i < n; i++) {\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract low 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract high 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n        src += n * avctx->channels * 5;\n        samples = (short *) dst_int32_t;\n        break;\n    default:\n        return -1;\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n    return src - buf;", "idx": 11712, "substitutes": {"avctx": ["afconn", "avcmp", "evcf", " avca", "devcontext", "abcontext", "verpkg", "AVcontext", "alctx", "aveconfig", "avconn", "avconv", "AVconn", " avcontext", "avcontext", " avconn", "avepkg", "abpkg", "navcmp", "afcontext", "akcontext", " avcu", "avcb", " avclient", "avecca", "avc", "attctx", "avbc", "afclient", "afpkg", "avectx", "alcontext", "aveclient", "afc", "vercmp", "navconn", "afcu", " avc", "attcontext", "avcmd", "devcf", "afbc", "verconn", "verconv", "afconv", " avcf", "afloc", "aveloc", "evbc", "evloc", " avbc", "avcca", "avca", "avloc", "navpkg", "vercf", "afctx", "abconn", "AVc", "navconv", "abcmp", "akctrl", " avcmd", "avcf", "avecb", "attcf", "vercontext", "avcu", "abctx", "verctx", "alcmd", "navctrl", "afconfig", "AVctx", "abctrl", "evconn", "evctx", "avctrl", "navcontext", "aveconn", "AVcu", "avecontext", "devctx", "akconn", "afctrl", "attloc", "afcca", "AVconfig", "navctx", "devcmp", "afcmp", "navcca", "afcmd", "avecu", "abcf", "evcontext", "afcf", "avconfig", "akctx", "navcf", "alca", "afcb", "avpkg", "afca", "avecf", "vercb", "navloc", "avclient"], "data": ["sample", "channel", "arr", "val", "source", "media", "window", "da", "b", "d", "block", "config", "p", "reader", "stream", "batch", "mu", "queue", "memory", "frame", "array", "empty", "tmp", "body", "DATA", "next", "f", "dat", "size", "slice", "input", "response", "content", "raw", "r", "results", "dd", "load", "Data", "blocks", "bytes", "message", "a", "video", "image", "result", "cache", "buff", "buffer"], "data_size": ["wave_scale", "data_scale", "channel_small", "data_range", "channel_offset", "data_shape", "data_small", "data_content", "cap_range", "wave_size", "channel_size", "data_sized", "data_number", "channel_sized", "cap_size", "cap_shape", "data_offset", "wave_shape", "cap_content", "wave_number"], "avpkt": ["avvpconn", "avpckt", "AVvpkt", "avnpkt", "navpeth", "avpacket", "avfacket", "avlpkg", "avckg", "ajpacket", "navlpeth", "AVpconn", "ajpmt", "ajpcmt", "avfkt", "navpkt", "avpcacket", "avnpconn", "avpcmt", "avcpkg", "ajpcnt", "avppmt", "avpconn", "avfpkt", "AVpk", "avvpct", "avppnt", "navlpkt", "ajpkt", "avvpkt", "avfpk", "avfnt", "avpnt", "avlpeth", "AVvpconn", "avcpkt", "avpct", "avpmt", "AVvpk", "ajpnt", "avfpconn", "avckt", "avlpkt", "avvpk", "avceth", "avppacket", "AVpct", "avpeth", "avpkg", "avcpct", "AVvpct", "AVpkt", "ajpcacket", "navlpkg", "avfmt", "navpct", "avlpct", "avnpk", "avnpct", "avcct", "navlpct", "avpcnt", "avcpeth", "ajpckt", "avfpct", "avpk", "navpkg", "avppkt"], "buf": ["bag", "uf", "map", "seq", "Buffer", "img", "ff", "pad", "b", "wb", "block", "fb", "config", "p", "bd", "pb", "cb", "fp", "queue", "cf", "rb", "array", "tmp", "bc", "f", "alloc", "cv", "v", "cap", "rc", "cas", "ctx", "port", "vec", "buff", "buffer", "box"], "s": ["session", "sg", "sv", "g", "stats", "m", "w", "b", "d", "gs", "sa", "p", "e", "f", "S", "v", "sync", "r", "ns", "sb", "spec", "sys", "a", "ses", "ss", "ssl", "sc"], "sample_size": ["sample67term", "sample2speed", "slice_size", "ample_shape", "mix_sized", "buf_size", "sample2scale", "samplelexterm", "ample_time", "buf_use", "samplelexsize", "sample67size", "slice_content", "samplelexuse", "mix_size", "sample_mode", "ample_size", "mix_mode", "sample2sized", "samplelexscale", "slice_page", "ample_fee", "ample_term", "samplelexsized", "sample_term", "sample2size", " sample_scale", "sample_shape", "buf_scale", "sample_scale", "slice_sized", " sample_speed", "buf_sized", "sample_speed", "mix_scale", "sample_use", "sample_page", "ample_speed", "sample67shape", "samplelexshape", "sample_time", " sample_sized", "sample_fee", "ample_body", "sample_content", "sample_sized", "sample_body", "samplelextime", "sample67time"], "c": ["count", "l", "C", "g", "w", "m", "k", "b", "x", "z", "d", "con", "p", "e", "cn", "cf", "f", "cc", "o", "v", "r", "dc", "u", "h", "nc", "cm", "ci"], "n": ["l", "un", "C", "nb", "g", "len", "all", "w", "m", "nt", "conn", "b", "x", "k", "num", "z", "t", "d", "ne", "net", "p", "e", "np", "cn", "number", "f", "pn", "network", "j", "o", "N", "size", "v", "r", "en", "sn", "ns", "nan", "u", "nc", "h", "ni", "y", "nn"], "i": ["l", "di", "si", "m", "b", "k", "ini", "x", "d", "p", "e", "f", "j", "o", "index", "v", "mi", "pi", "ii", "u", "I", "li", "ip", "ci", "ni", "y"], "samples": ["famps", "sample", "nources", "slamps", "famples", "fample", "suffample", "slources", "suffamps", "Sannels", "dannels", "damples", "sannels", "slample", "Samples", "slamples", "suffources", "dources", "sources", "Sources", "fources", "namples", "nannels", "suffamples", "samps"], "src": ["seq", "img", "source", "sel", "b", "RC", "sur", "rec", "config", "stream", "dest", "cb", "attr", "dist", "ptr", "loc", "rb", "tmp", "rs", "inst", "host", "sub", "slice", "lib", "cv", "sync", "rc", "input", "sl", "ctx", "sb", "url", "comp", "result", "func", "ssl", "sc"], "src8": ["dest16", "dest2", "rc2", "rc8", "dest8", " src16", "src16", "rc16"], "src2": ["src1", "src_", " src_", "rc1", "source_", "source1", "src0", " src0", "rc_", "rc2", "source0", "rc0", " src1", "source2"], "MAX_CHANNELS": ["MAX_CHANES", "MAX_ChANNELS", "MAX_CHANNEL", "MAX_CHANERS", "MAX_ChANNERS", "MAX_CHANCERS", "MAX_ChANNEL", "MAX_CHANGERS", "MAX_CHANETS", "MAX_CHANELS", "MAX_CHANNETS", "MAX_ChANCES", "MAX_CHANGELS", "MAX_ChANCELS", "MAX_CHANNES", "MAX_ChANCERS", "MAX_CHANCEL", "MAX_ChANCEL", "MAX_CHANCES", "MAX_CHANEL", "MAX_CHANGETS", "MAX_CHANCELS", "MAX_CHANNERS", "MAX_CHANGES", "MAX_ChANNES", "MAX_CHANGEL", "MAX_CHANCETS"], "dstu8": ["dstui8", "dstsu2", "dstuint6", "dstsui32", "dstsui8", "dstsui6", "dstsu6", "dstU32", "dstsui2", "dstui32", "dstu2", "dstuint32", "dstU2", "dstU6", "dstui6", "dstsu32", "dstuint2", "dstu32", "dstU8", "dstu6", "dstsu8", "dstuint8", "dstui2"], "dst_int16_t": ["dst_int16_s", "dst_int16_l", "dst_int16_T", "dst_int32_T", "dst_int32_l", "dst_int32_s"], "dst_int32_t": ["dst_int64_T", "dst_int32_f", "dst_int64_type", "dst_int64_f", "dst_int32_type", "dst_int32_T", "dst_int32JT", "dst_int32Jtype", "dst_int32Jf", "dst_int32Jt"], "dst_int64_t": ["dst_int64Jd", "dst_int16_s", "dst_int64_s", "dst_int64_T", "dst_int64_d", "dst_int16_T", "dst_int64Js", "dst_int64JT", "dst_int64Jt", "dst_int16_d"], "dst_uint16_t": ["dst_uint32_s", "dst_uint32_T", "dst_uint16_T", "dst_uint16_s", "dst_uint32_p", "dst_uint16_p"], "dst_uint32_t": ["dst_uint64_t", "dst_uint64_wt", "dst_uint32_s", "dst_uint32_T", "dst_uint64_s", "dst_uint64_T", "dst_uint32_wt"]}}
{"project": "qemu", "commit_id": "9646f4927faf68e8690588c2fd6dc9834c440b58", "target": 0, "func": "void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,\n\n                   uint32_t *eax, uint32_t *ebx,\n\n                   uint32_t *ecx, uint32_t *edx)\n\n{\n\n    X86CPU *cpu = x86_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t pkg_offset;\n\n\n\n    /* test if maximum index reached */\n\n    if (index & 0x80000000) {\n\n        if (index > env->cpuid_xlevel) {\n\n            if (env->cpuid_xlevel2 > 0) {\n\n                /* Handle the Centaur's CPUID instruction. */\n\n                if (index > env->cpuid_xlevel2) {\n\n                    index = env->cpuid_xlevel2;\n\n                } else if (index < 0xC0000000) {\n\n                    index = env->cpuid_xlevel;\n\n                }\n\n            } else {\n\n                /* Intel documentation states that invalid EAX input will\n\n                 * return the same information as EAX=cpuid_level\n\n                 * (Intel SDM Vol. 2A - Instruction Set Reference - CPUID)\n\n                 */\n\n                index =  env->cpuid_level;\n\n            }\n\n        }\n\n    } else {\n\n        if (index > env->cpuid_level)\n\n            index = env->cpuid_level;\n\n    }\n\n\n\n    switch(index) {\n\n    case 0:\n\n        *eax = env->cpuid_level;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 1:\n\n        *eax = env->cpuid_version;\n\n        *ebx = (cpu->apic_id << 24) |\n\n               8 << 8; /* CLFLUSH size in quad words, Linux wants it. */\n\n        *ecx = env->features[FEAT_1_ECX];\n\n        if ((*ecx & CPUID_EXT_XSAVE) && (env->cr[4] & CR4_OSXSAVE_MASK)) {\n\n            *ecx |= CPUID_EXT_OSXSAVE;\n\n        }\n\n        *edx = env->features[FEAT_1_EDX];\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ebx |= (cs->nr_cores * cs->nr_threads) << 16;\n\n            *edx |= CPUID_HT;\n\n        }\n\n        break;\n\n    case 2:\n\n        /* cache info: needed for Pentium Pro compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = 1; /* Number of CPUID[EAX=2] calls required */\n\n        *ebx = 0;\n\n        if (!cpu->enable_l3_cache) {\n\n            *ecx = 0;\n\n        } else {\n\n            *ecx = L3_N_DESCRIPTOR;\n\n        }\n\n        *edx = (L1D_DESCRIPTOR << 16) | \\\n\n               (L1I_DESCRIPTOR <<  8) | \\\n\n               (L2_DESCRIPTOR);\n\n        break;\n\n    case 4:\n\n        /* cache info: needed for Core compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, count, eax, ebx, ecx, edx);\n\n            *eax &= ~0xFC000000;\n\n        } else {\n\n            *eax = 0;\n\n            switch (count) {\n\n            case 0: /* L1 dcache info */\n\n                *eax |= CPUID_4_TYPE_DCACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1D_LINE_SIZE - 1) | \\\n\n                       ((L1D_PARTITIONS - 1) << 12) | \\\n\n                       ((L1D_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1D_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 1: /* L1 icache info */\n\n                *eax |= CPUID_4_TYPE_ICACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1I_LINE_SIZE - 1) | \\\n\n                       ((L1I_PARTITIONS - 1) << 12) | \\\n\n                       ((L1I_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1I_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 2: /* L2 cache info */\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(2) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                if (cs->nr_threads > 1) {\n\n                    *eax |= (cs->nr_threads - 1) << 14;\n\n                }\n\n                *ebx = (L2_LINE_SIZE - 1) | \\\n\n                       ((L2_PARTITIONS - 1) << 12) | \\\n\n                       ((L2_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L2_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 3: /* L3 cache info */\n\n                if (!cpu->enable_l3_cache) {\n\n                    *eax = 0;\n\n                    *ebx = 0;\n\n                    *ecx = 0;\n\n                    *edx = 0;\n\n                    break;\n\n                }\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(3) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n                *eax |= ((1 << pkg_offset) - 1) << 14;\n\n                *ebx = (L3_N_LINE_SIZE - 1) | \\\n\n                       ((L3_N_PARTITIONS - 1) << 12) | \\\n\n                       ((L3_N_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L3_N_SETS - 1;\n\n                *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX;\n\n                break;\n\n            default: /* end of info */\n\n                *eax = 0;\n\n                *ebx = 0;\n\n                *ecx = 0;\n\n                *edx = 0;\n\n                break;\n\n            }\n\n        }\n\n\n\n        /* QEMU gives out its own APIC IDs, never pass down bits 31..26.  */\n\n        if ((*eax & 31) && cs->nr_cores > 1) {\n\n            *eax |= (cs->nr_cores - 1) << 26;\n\n        }\n\n        break;\n\n    case 5:\n\n        /* mwait info: needed for Core compatibility */\n\n        *eax = 0; /* Smallest monitor-line size in bytes */\n\n        *ebx = 0; /* Largest monitor-line size in bytes */\n\n        *ecx = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE;\n\n        *edx = 0;\n\n        break;\n\n    case 6:\n\n        /* Thermal and Power Leaf */\n\n        *eax = env->features[FEAT_6_EAX];\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 7:\n\n        /* Structured Extended Feature Flags Enumeration Leaf */\n\n        if (count == 0) {\n\n            *eax = 0; /* Maximum ECX value for sub-leaves */\n\n            *ebx = env->features[FEAT_7_0_EBX]; /* Feature flags */\n\n            *ecx = env->features[FEAT_7_0_ECX]; /* Feature flags */\n\n            if ((*ecx & CPUID_7_0_ECX_PKU) && env->cr[4] & CR4_PKE_MASK) {\n\n                *ecx |= CPUID_7_0_ECX_OSPKE;\n\n            }\n\n            *edx = 0; /* Reserved */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 9:\n\n        /* Direct Cache Access Information Leaf */\n\n        *eax = 0; /* Bits 0-31 in DCA_CAP MSR */\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xA:\n\n        /* Architectural Performance Monitoring Leaf */\n\n        if (kvm_enabled() && cpu->enable_pmu) {\n\n            KVMState *s = cs->kvm_state;\n\n\n\n            *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX);\n\n            *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX);\n\n            *ecx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX);\n\n            *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX);\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xB:\n\n        /* Extended Topology Enumeration Leaf */\n\n        if (!cpu->enable_cpuid_0xb) {\n\n                *eax = *ebx = *ecx = *edx = 0;\n\n                break;\n\n        }\n\n\n\n        *ecx = count & 0xff;\n\n        *edx = cpu->apic_id;\n\n\n\n        switch (count) {\n\n        case 0:\n\n            *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_SMT;\n\n            break;\n\n        case 1:\n\n            *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_cores * cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_CORE;\n\n            break;\n\n        default:\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_INVALID;\n\n        }\n\n\n\n        assert(!(*eax & ~0x1f));\n\n        *ebx &= 0xffff; /* The count doesn't need to be reliable. */\n\n        break;\n\n    case 0xD: {\n\n        KVMState *s = cs->kvm_state;\n\n        uint64_t ena_mask;\n\n        int i;\n\n\n\n        /* Processor Extended State */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n            break;\n\n        }\n\n        if (kvm_enabled()) {\n\n            ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n            ena_mask <<= 32;\n\n            ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        } else {\n\n            ena_mask = -1;\n\n        }\n\n\n\n        if (count == 0) {\n\n            *ecx = 0x240;\n\n            for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n                const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n                if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                    && ((ena_mask >> i) & 1) != 0) {\n\n                    if (i < 32) {\n\n                        *eax |= 1u << i;\n\n                    } else {\n\n                        *edx |= 1u << (i - 32);\n\n                    }\n\n                    *ecx = MAX(*ecx, esa->offset + esa->size);\n\n                }\n\n            }\n\n            *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n            *ebx = *ecx;\n\n        } else if (count == 1) {\n\n            *eax = env->features[FEAT_XSAVE];\n\n        } else if (count < ARRAY_SIZE(x86_ext_save_areas)) {\n\n            const ExtSaveArea *esa = &x86_ext_save_areas[count];\n\n            if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                && ((ena_mask >> count) & 1) != 0) {\n\n                *eax = esa->size;\n\n                *ebx = esa->offset;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n    case 0x80000000:\n\n        *eax = env->cpuid_xlevel;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 0x80000001:\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = env->features[FEAT_8000_0001_ECX];\n\n        *edx = env->features[FEAT_8000_0001_EDX];\n\n\n\n        /* The Linux kernel checks for the CMPLegacy bit and\n\n         * discards multiple thread information if it is set.\n\n         * So don't set it here for Intel to make Linux guests happy.\n\n         */\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||\n\n                env->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 ||\n\n                env->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) {\n\n                *ecx |= 1 << 1;    /* CmpLegacy bit */\n\n            }\n\n        }\n\n        break;\n\n    case 0x80000002:\n\n    case 0x80000003:\n\n    case 0x80000004:\n\n        *eax = env->cpuid_model[(index - 0x80000002) * 4 + 0];\n\n        *ebx = env->cpuid_model[(index - 0x80000002) * 4 + 1];\n\n        *ecx = env->cpuid_model[(index - 0x80000002) * 4 + 2];\n\n        *edx = env->cpuid_model[(index - 0x80000002) * 4 + 3];\n\n        break;\n\n    case 0x80000005:\n\n        /* cache info (L1 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \\\n\n               (L1_ITLB_2M_ASSOC <<  8) | (L1_ITLB_2M_ENTRIES);\n\n        *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \\\n\n               (L1_ITLB_4K_ASSOC <<  8) | (L1_ITLB_4K_ENTRIES);\n\n        *ecx = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE);\n\n        *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE);\n\n        break;\n\n    case 0x80000006:\n\n        /* cache info (L2 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \\\n\n               (L2_DTLB_2M_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \\\n\n               (L2_ITLB_2M_ENTRIES);\n\n        *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \\\n\n               (L2_DTLB_4K_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \\\n\n               (L2_ITLB_4K_ENTRIES);\n\n        *ecx = (L2_SIZE_KB_AMD << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \\\n\n               (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE);\n\n        if (!cpu->enable_l3_cache) {\n\n            *edx = ((L3_SIZE_KB / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE);\n\n        } else {\n\n            *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE);\n\n        }\n\n        break;\n\n    case 0x80000007:\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_8000_0007_EDX];\n\n        break;\n\n    case 0x80000008:\n\n        /* virtual & phys address size in low 2 bytes. */\n\n        if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {\n\n            /* 64 bit processor, 48 bits virtual, configurable\n\n             * physical bits.\n\n             */\n\n            *eax = 0x00003000 + cpu->phys_bits;\n\n        } else {\n\n            *eax = cpu->phys_bits;\n\n        }\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ecx |= (cs->nr_cores * cs->nr_threads) - 1;\n\n        }\n\n        break;\n\n    case 0x8000000A:\n\n        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {\n\n            *eax = 0x00000001; /* SVM Revision */\n\n            *ebx = 0x00000010; /* nr of ASIDs */\n\n            *ecx = 0;\n\n            *edx = env->features[FEAT_SVM]; /* optional features */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xC0000000:\n\n        *eax = env->cpuid_xlevel2;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xC0000001:\n\n        /* Support for VIA CPU's CPUID instruction */\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_C000_0001_EDX];\n\n        break;\n\n    case 0xC0000002:\n\n    case 0xC0000003:\n\n    case 0xC0000004:\n\n        /* Reserved for the future, and now filled with zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    default:\n\n        /* reserved values: zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    }\n\n}\n", "idx": 7109, "substitutes": {"env": ["energy", "el", "environment", "oa", "et", "queue", "gui", "ench", "conf", "ev", "code", "zone", "her", "exec", "err", "equ", "Environment", "ec", "output", "stage", "vert", "dt", "engine", "conn", "vm", "config", "qt", "edge", "nc", "inet", "eu", "cal", "eye", "server", "assets", "ctx", "ini", "ne", "viron", "doc", "eve", "txt", "essential", "site", "end", "external", "eng", "exc", "db", "ext", "org", "obj", "net", "ce", "np", "vs", "e", "que", "en", "network", "global", "erv", "het", "eur", "cache", "app", "loader", "enable", "fen", "ea", "v", "scope", "enc", "uv", "event", "args", "init", "kernel", "context", "eni", "console", "cv", "host", "manager", "cdn"], "index": ["position", "x", "object", "localhost", "queue", "unit", "weight", "active", "match", "code", "len", "error", "depth", "connection", "output", "page", "engine", "current", "expression", "axis", "header", "id", "fee", "value", "list", "val", "update", "slice", "pattern", "info", "office", "url", "table", "number", "path", "ini", "ticket", "search", "node", "type", "element", "site", "tail", "end", "size", "condition", "address", "image", "loc", "inc", "key", "num", "version", "action", "instance", "timeout", "input", "pos", "level", "ind", "thread", "cache", "prefix", "find", "offset", "length", "example", "context", "pointer", "Index", "host", "date", "diff"], "count": ["cmp", "append", "last", "child", "call", "weight", "length", "cc", "code", "len", "col", "depth", "path", "empty", "Count", "seq", "batch", "start", "head", "core", "cache", "current", "max", "found", "counter"], "eax": ["ieac", " eAx", "ebase", "eix", "eag", "ebax", "oeax", "Eaj", "oexa", "oeas", "ebak", "iease", "ieaz", "eAx", "ceaped", " eass", "eeax", "eaped", " ease", "eeau", "ieau", "eaz", " eaj", "eas", " exa", " eac", " eAX", "eaag", "enass", "ieAx", "eeix", "enap", "oeaped", "eak", "ieAX", " eap", "eeaz", "exa", "ease", "EAX", "eaj", "Eac", "ieaj", "eass", "eac", "Eax", "eAX", "eap", " eak", " eag", "eaass", " eaz", " eas", "ieix", "ieax", "ceas", "ceax", " eix", "ebAx", "eaax", "cexa", "enax", "eau", " eau", " eaped", "ieak", "enag", "eaap"], "ebx": ["debux", "ecf", "ecg", " ebxx", "ebax", "egy", "ebux", "egx", " ebw", "ekw", "egz", "egX", "debX", "debg", "edX", "debx", "ekx", " ebis", "ebz", "ebw", "egb", " eby", "ebX", "edis", "ecb", "ecX", "edb", "ecax", "edex", "edax", "ebg", "ecy", "ecxx", "ebex", "egex", "ekux", "edz", "ecex", "ekX", "ecz", "ebxx", "egxx", "egf", "ebf", "ecux", "edf", "edy", "edw", "ebb", "ekz", "egax", "ebis", "ekg", "ekis", " ebz", "eby"], "ecx": ["ECx", "ecg", " ecid", "egv", "ECxi", "ect", "esclex", "egx", " ecz", "ebp", "eqex", "execz", " ecxx", "evg", "evp", "edX", "egg", "evx", "ebz", "execex", " ecv", "ebX", "eclex", "ECax", "ecX", "esct", "ecax", "edex", "eqx", "ecid", "efv", "edax", "edid", "eqt", "ebg", "escv", " ect", "edxi", "efz", "ecxx", "execX", "eqxi", "efx", "efxx", " ecX", "edz", "ecex", "ecxi", "ecz", "ebex", "ebxx", "eqlex", " eclex", "eqax", "execxx", "evv", "eqv", "ecv", "ecp", "execx", "escx", "ebv", "ECex", "egp", "execv", "edxx", "ebid"], "edx": ["EDex", "endedX", "ecn", "nedex", "nedX", "edix", "egx", "dedz", "egX", "aedz", "evex", " edex", "dedx", "edX", "endedx", "evx", "egix", "idX", "ebX", "aedx", "ecX", "EDX", "EDx", "nedany", "edex", "idax", "ecax", "edax", "idx", "idex", " edany", "endedax", "aedtx", "edtx", "dedex", "edn", "ebex", "evz", "edz", "ecex", "EDn", "egex", "nedx", " edix", " edX", "endedex", "ecix", "ebn", "edany", "ecany", "evtx", "dedtx", "aedex"], "cpu": ["cp", "cmp", "pid", "cfg", "hw", "python", "chip", "intel", "pu", "vm", "component", "config", "nc", "gpu", "module", "uu", "px", "cm", "unit", "obj", "pc", "linux", "net", "np", "nic", "proxy", "clock", "n", "ctx", "instance", "bc", "kernel", "loader", "process", "pool", "processor", "css", "boot", "eni", "console", "node", "c", "utils", "proc", "GPU", "cn", "core", "lc", "fc", "cache", "cpp", "CPU", "conn"], "cs": ["cp", "cmp", "Cs", "act", "cks", "spec", "ci", "nc", "rc", "cus", "cells", "sys", "co", "cross", "js", "sk", "ns", "stats", "ls", "pc", "args", "cc", "bs", "cons", "CS", "vs", "sc", "ics", "ops", "ks", "ds", "qs", "ctx", "wcs", "bc", "ts", "ces", "ils", "coll", "ec", "ca", "css", "acks", "fs", "acs", "utils", "c", "os", "ys", "cn", "lc", "cf", "core", "vc", "rs", "ras", "cas", "ps", "conn"], "pkg_offset": ["work2sort", "work_num", "pkg2num", "work2offset", "pkg__num", "work_sort", "pkg_length", "pkglnum", "work_offset", "pkgloffset", "pkg__offset", "pkg2length", "pkgllength", "pkg2sort", "pkg__length", "work2num", "pkg__sort", "work2length", "pkglsort", "work_length", "pkg2offset", "pkg_num", "pkg_sort"]}}
{"project": "qemu", "commit_id": "c7dfbf322595ded4e70b626bf83158a9f3807c6a", "target": 1, "func": "static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)\n\n{\n\n    uint32_t len;\n\n\n\n    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {\n\n        DPRINTF(s, 1,\n\n                \"usb-ccid: not sending apdu to client, no card connected\\n\");\n\n        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);\n\n        return;\n\n    }\n\n    len = le32_to_cpu(recv->hdr.dwLength);\n\n    DPRINTF(s, 1, \"%s: seq %d, len %d\\n\", __func__,\n\n                recv->hdr.bSeq, len);\n\n    ccid_add_pending_answer(s, (CCID_Header *)recv);\n\n    if (s->card) {\n\n        ccid_card_apdu_from_guest(s->card, recv->abData, len);\n\n    } else {\n\n        DPRINTF(s, D_WARN, \"warning: discarded apdu\\n\");\n\n    }\n\n}\n", "idx": 15664, "substitutes": {"s": ["secondary", "sys", "ses", "m", "self", "service", "t", "d", "sg", "sync", "fs", "your", "l", "private", "i", "sym", "rs", "sup", "g", "cs", "qs", "S", "submit", "new", "h", "os", "comments", "es", "js", "si", "sq", "session", "server", "v", "storage", "ss", "client", "o", "same", "w", "request", "u", "an", "sid", "p", "e", "se", "http", "site", "b", "sb", "n", "f", "tests", "gs", "spec", "c", "ns", "is", "stats", "ssl", "sv", "states", "services", "ds", "r", "ops", "su", "us", "support", "aws"], "recv": ["Recf", "conev", " recve", " recvd", "recq", "produvert", "produv", "recve", "recvar", " recsv", "recvm", "conv", "rcve", "produf", "rcvs", "rcV", "discV", "incf", "incvm", "incvert", "RecV", "conceive", "rcv", "ucv", "Recev", "conf", "convd", "Recvs", "Recov", " recvm", " recvert", "rcsv", " recV", "recf", " recf", "Recv", "recvd", "discq", "recov", "rcf", "rcq", "recvs", " recvar", " recq", "recceive", "rcceive", "recev", " recov", "recV", "recvert", "produvm", "discsv", "conve", "conov", "recsv", "conq", "ucf", "ucvar", "Recvar", "ucV", "incv", "discv", " recev", "rcov", "Recceive", "conV", " recvs", "Recvd"], "len": ["zen", "en", "lin", "d", "fl", "Len", "id", "l", "val", "lon", "lan", "lp", "dl", "str", "lang", "ie", "ld", "v", "lib", "dy", "z", "ll", "bl", "e", "fin", "li", "data", "base", "min", "length", "L", "ler", "f", "n", "lf", "line", "count", "il", "offset", "le", "sl", "all", "El", "seq", "pos", "num", "el", "span", "ln", "net", "err"]}}
{"project": "FFmpeg", "commit_id": "66f0c958bfd5475658b432d1af4d2e174b2dfcda", "target": 1, "func": "static int pxr24_uncompress(EXRContext *s, const uint8_t *src,\n\n                            int compressed_size, int uncompressed_size,\n\n                            EXRThreadData *td)\n\n{\n\n    unsigned long dest_len, expected_len = 0;\n\n    const uint8_t *in = td->tmp;\n\n    uint8_t *out;\n\n    int c, i, j;\n\n\n\n    for (i = 0; i < s->nb_channels; i++) {\n\n        if (s->channels[i].pixel_type == EXR_FLOAT) {\n\n            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */\n\n        } else if (s->channels[i].pixel_type == EXR_HALF) {\n\n            expected_len += (td->xsize * td->ysize * 2);\n\n        } else {//UINT 32\n\n            expected_len += (td->xsize * td->ysize * 4);\n\n        }\n\n    }\n\n\n\n    dest_len = expected_len;\n\n\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (dest_len != expected_len) {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    out = td->uncompressed_data;\n\n    for (i = 0; i < td->ysize; i++)\n\n        for (c = 0; c < s->nb_channels; c++) {\n\n            EXRChannel *channel = &s->channels[c];\n\n            const uint8_t *ptr[4];\n\n            uint32_t pixel = 0;\n\n\n\n            switch (channel->pixel_type) {\n\n            case EXR_FLOAT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                ptr[2] = ptr[1] + td->xsize;\n\n                in     = ptr[2] + td->xsize;\n\n\n\n                for (j = 0; j < td->xsize; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                                    (*(ptr[1]++) << 16) |\n\n                                    (*(ptr[2]++) << 8);\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_HALF:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                in     = ptr[1] + td->xsize;\n\n                for (j = 0; j < td->xsize; j++) {\n\n                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);\n\n\n\n                    pixel += diff;\n\n                    bytestream_put_le16(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_UINT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + s->xdelta;\n\n                ptr[2] = ptr[1] + s->xdelta;\n\n                ptr[3] = ptr[2] + s->xdelta;\n\n                in     = ptr[3] + s->xdelta;\n\n\n\n                for (j = 0; j < s->xdelta; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                    (*(ptr[1]++) << 16) |\n\n                    (*(ptr[2]++) << 8 ) |\n\n                    (*(ptr[3]++));\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            default:\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 22009, "substitutes": {"s": ["sv", "sb", "hm", "e", "sym", "space", "sk", "support", "sl", "fs", "g", "ses", "this", "su", "rates", "d", "ks", "ds", "services", "f", "sys", "t", "u", "m", "ssl", "ts", "p", "cs", "ls", "sync", "sa", "sg", "js", "self", "sd", "sm", "sq", "sh", "si", "sc", "spec", "sts", "b", "service", "parts", "session", "S", "ns", "sf", "side", "ps", "south", "gs", "bs", "l", "ss", "settings"], "src": ["sb", "fc", "sel", "config", "sl", "input", "rin", "img", "scl", "secure", "gb", "ssl", "setup", "rc", "filename", "ctx", "cb", "source", "ipl", "sc", "sr", "rl", "sub", "tmp", "inst", "slice", "loc", "rs", "proc", "st", "dest", "rb", "stream", "attr", "url"], "compressed_size": ["compressed67area", "comppped_size", "compressed64sum", "compressed_sum", "compressed2size", "compressed64scale", "compressed2len", "compached_sum", "comppped_offset", "comppped_data", "compressed_data", "compached_size", "compressed67data", "compressed_len", "compressed_area", "compressed_scale", "compressed64len", "compressed2sum", "compressed67offset", "compressed67size", "compressed_offset", "compressed2scale", "comppped_area", "compached_len", "compached_scale", "compressed64size"], "uncompressed_size": ["uncompressedrize", "uncompressed_width", "uncompressed64size", "uncompured64width", "uncompressedrwidth", "uncompressed64ize", "uncompured_source", "uncompressed_ize", "uncompured_ize", "uncompressedrsize", "uncompured64size", "uncompured64source", "uncompressedrsource", "uncompressed64source", "uncompured_size", "uncompressed_source", "uncompressed64width", "uncompured_width", "uncompured64ize"], "td": ["md", "pb", "sb", "txt", "cd", "table", "rd", "uc", "conn", "ind", "amp", "edd", "std", "prot", "lv", "butt", "input", "kt", "db", "det", "wd", "dal", "d", "xd", "vd", "pd", "ti", "dh", "ld", "ds", "pc", "layer", "dn", "ud", "t", "cmd", "standard", "dd", "nd", "tp", "hd", "tif", "data", "ts", "ssl", "tc", "elt", "od", "thin", "header", "sd", "tf", "dt", "ta", "dc", "tmp", "dl", "fd", "tn", "bd", "dll", "cz", "tm", "dat", "nt", "lf", "cod", "li", "pt", "att", "TD", "ht", "gb", "ctl"], "dest_len": ["dest_l", "dest9ler", "expected_l", "expected64Len", "expected64lon", "gest___ler", "dest64len", " dest_val", "dest2limit", "dest___len", "dest___lin", "rest_limit", "dest_size", "dest9val", "dest___ler", "expected_Len", "dest__count", "dest_lon", "gest_ler", "gest___len", " dest_count", "dest_length", "dest_lock", "dest2lock", "dest2length", "dest2len", "expected64l", "gest___lin", "rest_length", "dest_ler", " dest_size", "dest__len", "dest64l", "expected64len", "dest_limit", "dest64lon", "gest_val", "dest9lin", "gest___val", "rest_lock", "dest9len", "gest_lin", "expected_len", "dest64Len", "dest_val", "dest_count", "dest_lin", "expected_lon", "rest_len", "dest__size", "gest_len", "dest_Len", "dest__val", "dest___val"], "in": ["conn", "err", "config", "ind", "input", "inc", "val", "part", "connection", "impl", "rin", "d", "bin", "gin", "rec", "pc", "img", "din", "ci", "win", "again", "r", "address", "m", "socket", "data", "ssl", "p", "id", "inner", "rc", "index", "pin", "ctx", "source", "inn", "In", "ii", "dc", "pull", "into", "IN", "min", "inst", "ins", "proc", "inside", "resource", "image", "att", "inch", "isin"], "out": ["io", "name", "outs", "password", "conn", "err", "config", "result", "part", "copy", "bin", "gin", "token", "temp", "process", "img", "device", "buffer", "exec", "again", "other", "cmd", "bit", "m", "data", "opt", "new", "p", "at", "version", "sync", "ext", "client", "OUT", "source", "window", "error", "call", "Out", "parent", "proc", "v", "dest", "image", "att", "server", "output", "attr", "sum"], "c": ["lc", "col", "e", "uc", "g", "d", "con", "pc", "f", "ci", "y", "t", "nc", "r", "u", "ac", "cp", "cache", "m", "p", "cs", "enc", "rc", "cn", " rc", "sc", "ch", "b", "cy", "n", "vc", "call", "C", "co", "z", "v", "ce", "h", "l", "x", "cu", "k", "count"], "i": ["io", "lc", "ami", "e", "ix", "start", "ie", "fi", "qi", "ri", "iii", "ui", "eni", "mini", "pi", "ki", "gi", "d", "uri", "my", "chi", "ti", "I", "f", "ci", "y", "u", "oi", "ini", "m", "phi", "info", "it", "init", "p", "ip", "id", "o", "bi", "q", "is", "mi", "inner", "index", "si", "ii", "b", "n", "iu", "ai", "xi", "di", "v", "multi", "yi", "li", "h", "im", "l", "x", "k", "ni"], "j": ["je", "ja", "oj", "e", "jl", "obj", "jp", "ind", "g", "key", "d", "f", "pos", "y", "t", "u", "other", "m", "p", "o", "q", "js", "aj", "el", "num", "J", "ch", "b", "ii", "ji", "ij", "fl", "n", "jc", "v", "z", "li", "h", "jo", "l", "x", "ne", "k"], "channel": ["member", "camera", "row", "attribute", "conn", "config", "character", "container", "chan", "cv", "connection", "cm", "queue", "player", "handler", "plugin", "pc", "type", "layer", "pixel", "can", "socket", "Channel", "component", "slot", "cup", "client", "ch", "sc", "window", "service", "wan", "core", "call", "chron", "chip", "page", "parent", "group", "server", "course"], "ptr": ["str", "port", "grad", "start", "err", "ref", "prot", "pe", "ctr", "tr", "wr", "pad", "pc", "img", "rect", "fp", "buffer", "pos", "pointers", "address", "cp", "data", "tp", "pp", "patch", "p", "uv", "arr", "point", "code", "addr", "elt", "np", "ext", "dr", "ctx", "pr", "pl", "fr", "ch", "rt", "pull", "tmp", "desc", "inst", "fd", "loc", "slice", "iter", "Ptr", "stage", "st", "proc", "buff", "dat", "pointer", "nt", "pair", "dest", "pty", "pt", "att", "offset", "sp", "attr", "inter", "ft"]}}
{"project": "qemu", "commit_id": "4105de6732f771ea64113851a2ee7172c34d3a7a", "target": 1, "func": "e1000_can_receive(void *opaque)\n\n{\n\n    E1000State *s = opaque;\n\n\n\n    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||\n\n            s->mac_reg[RDH] != s->mac_reg[RDT]);\n\n}\n", "idx": 3130, "substitutes": {"s": ["submit", "this", "service", "opens", "ss", "ops", "spec", "sa", "a", "sb", "new", "ans", "is", "sl", "scope", "g", "space", "params", "m", "ses", "sf", "sync", "settings", "request", "ds", "ns", "c", "p", "services", "state", "self", "e", "secondary", "f", "conf", "sq", "sys", "south", "o", "su", "b", "S", "os", "session", "your", "an", "states", "si", "in", "sym", "ssl"]}}
{"project": "FFmpeg", "commit_id": "c81185a18333b28439476fdc00979225158c8755", "target": 1, "func": "void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height){\n\n    int w_align= 1;\n\n    int h_align= 1;\n\n\n\n    switch(s->pix_fmt){\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUYV422:\n\n    case PIX_FMT_UYVY422:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_GRAY8:\n\n    case PIX_FMT_GRAY16BE:\n\n    case PIX_FMT_GRAY16LE:\n\n    case PIX_FMT_YUVJ420P:\n\n    case PIX_FMT_YUVJ422P:\n\n    case PIX_FMT_YUVJ444P:\n\n    case PIX_FMT_YUVA420P:\n\n        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment\n\n        h_align= 16;\n\n\n\n        break;\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_UYYVYY411:\n\n        w_align=32;\n\n        h_align=8;\n\n        break;\n\n    case PIX_FMT_YUV410P:\n\n        if(s->codec_id == CODEC_ID_SVQ1){\n\n            w_align=64;\n\n            h_align=64;\n\n        }\n\n    case PIX_FMT_RGB555:\n\n        if(s->codec_id == CODEC_ID_RPZA){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n    case PIX_FMT_PAL8:\n\n    case PIX_FMT_BGR8:\n\n    case PIX_FMT_RGB8:\n\n        if(s->codec_id == CODEC_ID_SMC){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    case PIX_FMT_BGR24:\n\n        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    default:\n\n        w_align= 1;\n\n        h_align= 1;\n\n        break;\n\n    }\n\n\n\n    *width = ALIGN(*width , w_align);\n\n    *height= ALIGN(*height, h_align);\n\n    if(s->codec_id == CODEC_ID_H264)\n\n        *height+=2; // some of the optimized chroma MC reads one line too much\n\n}", "idx": 21899, "substitutes": {"s": ["sv", "sim", "sb", "i", "native", "e", "sym", "qs", "es", "space", "support", "sci", "sl", "fs", "g", "ses", "site", "ks", "l", "ds", "services", "f", "sys", "t", "j", "ssl", "os", "ts", "cs", "p", "us", "ls", "sync", "is", "ss", "sa", "sg", "c", "js", "settings", "spec", "si", "a", "service", "se", "n", "S", "ns", "sup", "session", "sf", "south", "rs", "gs", "ps", "conf", "su", "sq"], "height": ["view", "row", "shape", "end", "level", "layout", "style", "align", "build", "pad", "Height", "rank", "y", "size", "data", "hang", "depth", "crop", "index", "distance", "pull", "window", "w", "stroke", "top", "length", "angle", "alpha", "volume", "gap", "h", "image", "resolution", "bottom", "arrow", "x", "high", "max", "block", "padding"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)\n\n{\n\n    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));\n\n\n\n    entry->rect.x = x;\n\n    entry->rect.y = y;\n\n    entry->rect.w = w;\n\n    entry->rect.h = h;\n\n\n\n    vnc_lock_queue(queue);\n\n    QLIST_INSERT_HEAD(&job->rectangles, entry, next);\n\n    vnc_unlock_queue(queue);\n\n    return 1;\n\n}\n", "idx": 25872, "substitutes": {"job": ["node", "seq", "section", "page", "b", "server", "batch", "image", "manager", "ob", "module", "queue", "base", "cb", "plugin", "db", "line", "feed", "project", "work", "command", "session", "run", "group", "worker", "order", "item", "game", "child", "j", "row", "route", "event", "Job", "block", "connection", "lock", "layer"], "x": ["height", "code", "xx", "z", "i", "p", "b", "dy", "c", "name", "m", "d", "image", "px", "data", "address", "X", "id", "wx", "point", "xy", "work", "lat", "path", "xi", "dx", "loc", "ick", "shape", "win", "f", "rx", "n", "index", "t", "a", "v", "r", "pos", "ex", "l"], "y": ["z", "yi", "i", "p", "b", "sy", "oy", "dy", "ya", "ay", "d", "yt", "ies", "c", "wy", "py", "ye", "type", "cy", "ym", "vy", "yo", "ys", "ey", "xy", "Y", "zy", "ry", "ny", "j", "year", "t", "a", "ty", "yy"], "w": ["height", "ow", "k", "z", "i", "p", "b", "m", "c", "d", "sw", "weight", "wh", "rw", "u", "wx", "hw", "o", "work", "max", "fw", "wd", "ew", "length", "win", "wid", "f", "wt", "n", "W", "a", "wa", "t", "q", "v", "r", "ex", "l", "sh"], "h": ["height", "hm", "ht", "k", "z", "i", "p", "b", "m", "c", "d", "H", "u", "depth", "e", "home", "o", "hw", "dh", "rh", "hs", "size", "gh", "f", "n", "t", "host", "q", "v", "r", "l", "hi", "ph", "oh", "sh"], "entry": ["import", "element", " Entry", "ie", "section", "info", "server", "cat", "image", "module", "ge", "insert", "data", "queue", "connection", "or", "base", "pointer", "next", "add", "export", "member", "reader", "it", "end", "id", "line", "key", "link", "Entry", "e", "feed", "step", "path", "set", "start", "inner", "ent", "enter", "object", "offset", "si", "parent", "inc", "item", "rc", "ry", "update", "array", "lc", "service", "child", "index", "row", "inter", "event", "route", "post", "desc"]}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_quit(int argc, const char **argv)\n\n{\n\n    exit(0);\n\n}\n", "idx": 25580, "substitutes": {"argc": [" argf", "argsf", "Argf", "argsc", " argn", "Argn", "argf", "Argv", "argn", "argsn", "Argc", "argsv"], "argv": ["argsb", " argp", "argb", "argsc", "Argp", "Argv", "argp", "argsp", "Argc", "argsv", "Argb", " argb"]}}
{"project": "FFmpeg", "commit_id": "1dff9adcb934175fe1beb14ee139ad0636daa29d", "target": 0, "func": "static int recheck_discard_flags(AVFormatContext *s, int first)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    int i, changed = 0;\n\n\n\n    /* Check if any new streams are needed */\n\n    for (i = 0; i < c->n_playlists; i++)\n\n        c->playlists[i]->cur_needed = 0;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        struct playlist *pls = c->playlists[s->streams[i]->id];\n\n        if (st->discard < AVDISCARD_ALL)\n\n            pls->cur_needed = 1;\n\n    }\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->cur_needed && !pls->needed) {\n\n            pls->needed = 1;\n\n            changed = 1;\n\n            pls->cur_seq_no = select_cur_seq_no(c, pls);\n\n            pls->pb.eof_reached = 0;\n\n            if (c->cur_timestamp != AV_NOPTS_VALUE) {\n\n                /* catch up */\n\n                pls->seek_timestamp = c->cur_timestamp;\n\n                pls->seek_flags = AVSEEK_FLAG_ANY;\n\n                pls->seek_stream_index = -1;\n\n            }\n\n            av_log(s, AV_LOG_INFO, \"Now receiving playlist %d, segment %d\\n\", i, pls->cur_seq_no);\n\n        } else if (first && !pls->cur_needed && pls->needed) {\n\n            if (pls->input)\n\n                ff_format_io_close(pls->parent, &pls->input);\n\n            pls->needed = 0;\n\n            changed = 1;\n\n            av_log(s, AV_LOG_INFO, \"No longer receiving playlist %d\\n\", i);\n\n        }\n\n    }\n\n    return changed;\n\n}\n", "idx": 18649, "substitutes": {"s": ["ns", "ans", "spec", "m", "ts", "sg", "session", "t", "rs", "aws", "conf", "f", "stats", "sv", "settings", "services", "r", "service", "n", "sb", "g", "sl", "ss", "as", "fs", "is", "o", "cs", "l", "su", "ins", "args", "qs", "e", "ssl", "sc", "ses", "v", "sync", "js", "si", "ps", "p", "S", "sts", "b", "ks", "events", "gs", "http", "sys", "h", "its", "a", "es", "os", "us", "sets", "se", "sq", "server", "less", "sa", "ds", "u"], "first": ["required", "full", "f", "leaf", "current", "root", "based", "max", "top", "count", "always", "empty", "final", "change", "found", "First", "initial", "use", "correct", "last", "seen", "start", "prev", "only", "latest", "used", "p", "once", "missing", "next", "error", "split", "second", "repeat", "end", "before", "alpha", "one", "now"], "c": ["pc", "dc", "ic", "m", "ch", "t", "conf", "f", "cus", "vc", "ct", "conn", "r", "cm", "n", "cf", "g", "coll", "bc", "cp", "ctx", "mc", "ctrl", "o", "ca", "enc", "cs", "l", "d", "ce", "nc", "ac", "ci", "con", "tc", "config", "sc", "cu", "e", "k", "cr", "v", "lc", "cur", "p", "uc", "b", "ec", "cd", "h", "co", "C", "cc", "u"], "i": ["ti", "gi", "uri", "m", "bi", "init", "j", "ami", "info", "x", "f", "name", "ix", "ini", "qi", "ai", "mi", "n", "phi", "io", "g", "hi", "ii", "ie", "in", "di", "index", "ind", "iu", "I", "ori", "multi", "zi", "is", "o", "ip", "l", "d", "oi", "yi", "pi", "ui", "isin", "ci", "changed", "abi", "id", "start", "e", "k", "v", "cli", "ni", "si", "lc", "ri", "p", "xi", "b", "mu", "h", "a", "iv", "it", "eni", "my", "fi", "y", "li", "u"], "st": ["pt", "ist", "est", "fr", "rest", "ct", "sp", "ste", "pe", "str", "sb", "sw", "ast", "ss", "src", "ld", "sec", "ST", "sd", "stal", "sta", "su", "std", "sh", "stack", "stop", "sn", "sr", "sc", "start", "sth", "cr", "be", "si", "rss", "sts", "St", "inst", "ace", "ft", "se", "sa"], "pls": ["phs", "splws", "PLs", " plS", "plses", "ynws", "Plp", " Pld", " pli", "plops", "phses", "celp", "cli", "splss", "plds", "plS", "relp", "plg", "splg", "plis", "clp", "yni", " plsb", "plsb", "feeds", " Pls", "pgi", "pgp", "llp", "impls", "celsets", "plss", "splsets", "slp", "feedsets", " Pli", "sld", "cels", "implp", "PlS", "controlses", "splos", "pts", "clis", "splp", "ynp", " plws", " plsets", "clg", "cls", "phsets", "Pli", "splops", " plops", "logd", "logi", "plsets", "PLd", "pgis", "rels", "plos", "ptds", "plp", "splds", "pgses", "yng", "lls", "pps", " plis", "pgs", " plp", "Plsets", "celses", "controlsets", " plds", "pld", "spli", "splsb", " plss", "Pls", " pld", "yns", "logs", "PLi", "puti", "implops", " plses", "sls", "ppds", "plws", " plg", "spls", "logsb", "controls", "spld", "ppp", "relss", "lld", "putS", "slsets", "ynos", "php", "pli", " plos", "feedp", "ptp"]}}
{"project": "qemu", "commit_id": "1acae9f22380a03b468a29a3cc035b280610b5e4", "target": 0, "func": "_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,\n\n          const struct timespec *,tsp,int,flags)\n\n#endif\n\n#endif /* CONFIG_UTIMENSAT  */\n\n\n\n#ifdef CONFIG_INOTIFY\n\n#include <sys/inotify.h>\n\n\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\nstatic int sys_inotify_init(void)\n\n{\n\n  return (inotify_init());\n\n}\n", "idx": 13589, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "ac87c273a646eb8feba8e47f15da4934d119f650", "target": 1, "func": "int av_buffersrc_add_ref(AVFilterContext *buffer_filter,\n\n                         AVFilterBufferRef *picref, int flags)\n\n{\n\n    BufferSourceContext *c = buffer_filter->priv;\n\n    AVFilterBufferRef *buf;\n\n    int ret;\n\n\n\n    if (!picref) {\n\n        c->eof = 1;\n\n        return 0;\n\n    } else if (c->eof)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!av_fifo_space(c->fifo) &&\n\n        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +\n\n                                         sizeof(buf))) < 0)\n\n        return ret;\n\n\n\n    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {\n\n        ret = check_format_change(buffer_filter, picref);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    if (flags & AV_BUFFERSRC_FLAG_NO_COPY)\n\n        buf = picref;\n\n    else\n\n        buf = copy_buffer_ref(buffer_filter, picref);\n\n\n\n\n\n    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {\n\n        if (buf != picref)\n\n            avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n    c->nb_failed_requests = 0;\n\n\n\n    return 0;\n\n}", "idx": 25566, "substitutes": {"buffer_filter": ["bufferwfilter", "callbackvfinder", "bufferlexfilter", "thread_slice", "buffer_find", "callback_fil", "buffer_set", "buffer_context", "buffervfil", "bufferlexset", "callback_filter", "buffer_handler", "bufferwfil", "buffer_finder", "buffer_fil", "queue_proxy", "bufferwfinder", "bufferwcontrol", "queue_filter", "buffer0fil", "buffervfinder", "code_ref", "buffer_proxy", "buffer0control", "queue_set", "bufferlexcontext", "buffer_force", "buffer_control", "code_force", "bufferlexproxy", "buffer_slice", "buffer0filter", "queue_context", "callbackvfilter", "thread_filter", "buffervfilter", "callback_finder", "callback_control", "thread_fil", "code_filter", "callbackvfil", "buffer_ref", "buffer0finder", "buffervcontrol", "callbackvcontrol", "code_find", "thread_handler"], "picref": [" picdef", " picurl", " picalf", "pitcol", "pinconfig", "busdef", " picfilter", " piccol", "nicurl", "busref", "icdef", "macref", "picalt", "picurl", "busRef", "pinref", "icalf", "pcval", "bcRef", "Picconfig", "icreference", " picconfig", "pcref", "macfilter", "picval", "macurl", "picconfig", "picdef", "bcref", "macreference", "pitref", "nicfilter", "pinreference", "nicval", "pinurl", "nicREF", "pitalt", "nicdef", "picRef", "Picreference", "picalf", "pitreference", "pcdef", " picreference", "Picref", "pincol", "pinalt", "nicreference", "piccol", "icref", "picfilter", "picreference", "nicref", "bcreference", "icREF", " picREF", "busval", " picRef", "icRef", "bcalf", "nicRef", " picalt", "pcRef", "picREF", "Picurl"], "flags": ["mask", "ants", "args", "features", "flag", "ats", "ils", "Flags", "planes", "types", "rules", "books", " fs", "plugins", "locks", "vals", "lf", "stats", "rets", "options", "fields", "caps", "s", "lines", " bits", "fee", "fl", "lag", "utils", "fx", "files", "bugs", "ags", "fs", "bits", "styles", "alls", "status", "checks", "nl", "FLAG", "settings", "ops", "parts", "sf", "fd", "fun"], "c": ["exec", "sc", "call", "cm", "k", "w", "dc", "uc", "oc", "p", "b", "m", "cat", "C", "context", "d", "cv", "enc", "xc", "ec", "cur", "config", "cr", "conf", "ct", "bc", "cy", "ch", "self", "u", "e", "con", "o", "cl", "vc", "ac", "icc", "cc", "ctx", "ci", "cp", "cf", "mc", "rc", "cache", "co", "lc", "ctrl", "ca", "f", "tc", "cu", "conn", "t", "coll", "v", "g", "l", "cs", "ce", "pc"], "buf": ["ref", "bag", "wb", "pkg", "lb", "Buff", "buffer", "gb", "cb", "cmd", "pool", "cf", "buff", "f", "fp", "val", "obj", "b", "cv", "queue", "bd", "port", "proc", "feed", "ff", "pb", "cap", "cache", "feat", "cas", "raf", "src", "plug", "func", "len", "fd", "fun", "uf", "bin", "uc", "data", "rb", "ab", "brace", "str", "tmp", "la", "box", "cp", "fb", "fi", "alloc", "seq", "job", "vec", "img", "cur", "config", "bf", "br", "bh", "bc", "aux", "home", "loc", "ctx", "rc", "fat", "off", "bg", "runner", "result"], "ret": ["ref", "fin", "sr", "ft", "cat", "rf", "base", "att", "num", "mem", "det", "lit", "lib", "nt", "pet", "part", "match", "r", "val", "code", "obj", "af", "flag", "red", "en", "debug", "def", "bit", "repl", "RET", "result", "let", "bad", "pat", "Ret", "value", "len", "fun", "res", "over", "data", "back", "rb", "success", "no", "fail", "error", "al", "err", "re", "reply", "utf", "bot", "arg", "alt", "reg", " RET", "job", "cur", "bf", "pass", "id", "rets", "rev", "run", "art", "rc", "active", "rt", "ext", "out", "reset", "format"]}}
{"project": "qemu", "commit_id": "d5fee0bbe68d5e61e2d2beb5ff6de0b9c1cfd182", "target": 0, "func": "int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,\n\n                              int mmu_idx)\n\n{\n\n    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */\n\n        /* TODO - Unsupported */\n\n        error_report(\"Guest Radix Support Unimplemented\");\n\n        exit(1);\n\n    } else { /* Guest uses hash */\n\n        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);\n\n    }\n\n}\n", "idx": 6753, "substitutes": {"cpu": ["cp", "hp", "gp", "cmp", "ocr", "hw", "chip", "pai", "platform", "pu", "roc", "coe", "vm", "component", "colo", "plug", "rc", " CPU", "gpu", "px", "mac", "dylib", "pc", "linux", "cli", "np", "cpp", "clock", "kernel", "jp", "process", "processor", "computer", "pty", "boot", "css", "proc", "c", "GPU", "cn", "core", "lc", "cache", "loader", "CPU"], "eaddr": ["ewDR", "awDR", "ADdr", "ADder", "eadDR", "eadDr", "addDr", "abDr", "adddr", "awrd", "addrd", "eadrd", "abdr", "ewder", "eadder", "aceder", "ADDr", "ewdr", "abrd", "acedr", "awDr", "addDR", "aceDr", "ADDR", "aceDR", "ewDr", "awdr", "abDR"], "rwx": ["rawxs", "ewf", "ewxx", "rawxx", "rawf", "ewx", "RWx", "rwf", "RWex", "rwlex", "rrx", "rrxx", "rrlex", "wrx", "rrex", "rwex", "RWlex", "wrex", "rawx", "RWf", "rwxx", "RWxx", "RWxs", "wrlex", "wrxx", "ewxs", "rwxs"], "mmu_idx": ["mmu_itb", "mmu_idxs", "mmu_itv", "mmu_ridv", "mmu_idv", "mmu_ridX", "mmu_Idx", "mmu_IdX", "mmu_Idb", "mmu_Idxs", "mmu_itx", "mmu_itxs", "mmu_idX", "mmu_ridb", "mmu_ridx", "mmu_Idv", "mmu_idb"]}}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "long do_syscall(void *cpu_env, int num, long arg1, long arg2, long arg3, \n\n                long arg4, long arg5, long arg6)\n\n{\n\n    long ret;\n\n    struct stat st;\n\n    struct kernel_statfs *stfs;\n\n    \n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\\n\", num);\n\n#endif\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef HAVE_GPROF\n\n        _mcleanup();\n\n#endif\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        ret = get_errno(read(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_write:\n\n        ret = get_errno(write(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_open:\n\n        ret = get_errno(open((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk((char *)arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(fork());\n\n        break;\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int *status = (int *)arg2;\n\n            ret = get_errno(waitpid(arg1, status, arg3));\n\n            if (!is_error(ret) && status)\n\n                tswapls((long *)&status);\n\n        }\n\n        break;\n\n    case TARGET_NR_creat:\n\n        ret = get_errno(creat((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_link:\n\n        ret = get_errno(link((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_unlink:\n\n        ret = get_errno(unlink((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_execve:\n\n        ret = get_errno(execve((const char *)arg1, (void *)arg2, (void *)arg3));\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        ret = get_errno(chdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_time:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            ret = get_errno(time((time_t *)time_ptr));\n\n            if (!is_error(ret) && time_ptr)\n\n                tswap32s(time_ptr);\n\n        }\n\n        break;\n\n    case TARGET_NR_mknod:\n\n        ret = get_errno(mknod((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_chmod:\n\n        ret = get_errno(chmod((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lchown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpid:\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n        /* need to look at the data field */\n\n        goto unimplemented;\n\n    case TARGET_NR_umount:\n\n        ret = get_errno(umount((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(getuid());\n\n        break;\n\n    case TARGET_NR_stime:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            if (time_ptr)\n\n                tswap32s(time_ptr);\n\n            ret = get_errno(stime((time_t *)time_ptr));\n\n        }\n\n        break;\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n    case TARGET_NR_utime:\n\n        goto unimplemented;\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n    case TARGET_NR_access:\n\n        ret = get_errno(access((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n    case TARGET_NR_sync:\n\n        ret = get_errno(sync());\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        ret = get_errno(rename((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_mkdir:\n\n        ret = get_errno(mkdir((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rmdir:\n\n        ret = get_errno(rmdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        {\n\n            int *pipe_ptr = (int *)arg1;\n\n            ret = get_errno(pipe(pipe_ptr));\n\n            if (!is_error(ret)) {\n\n                tswap32s(&pipe_ptr[0]);\n\n                tswap32s(&pipe_ptr[1]);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_times:\n\n        goto unimplemented;\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(getgid());\n\n        break;\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(getegid());\n\n        break;\n\n    case TARGET_NR_acct:\n\n        goto unimplemented;\n\n    case TARGET_NR_umount2:\n\n        ret = get_errno(umount2((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        switch(arg2) {\n\n        case F_GETLK:\n\n        case F_SETLK:\n\n        case F_SETLKW:\n\n            goto unimplemented;\n\n        default:\n\n            ret = get_errno(fcntl(arg1, arg2, arg3));\n\n            break;\n\n        }\n\n        break;\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        ret = get_errno(chroot((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n    case TARGET_NR_sigaction:\n\n#if 0\n\n        {\n\n            int signum = arg1;\n\n            struct target_old_sigaction *tact = arg2, *toldact = arg3;\n\n            ret = get_errno(setsid());\n\n            \n\n\n\n        }\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sgetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_ssetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_sigsuspend:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigpending:\n\n        goto unimplemented;\n\n    case TARGET_NR_sethostname:\n\n        ret = get_errno(sethostname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrusage:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                target_tv->tv_sec = tswapl(tv.tv_sec);\n\n                target_tv->tv_usec = tswapl(tv.tv_usec);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            tv.tv_sec = tswapl(target_tv->tv_sec);\n\n            tv.tv_usec = tswapl(target_tv->tv_usec);\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_select:\n\n        goto unimplemented;\n\n    case TARGET_NR_symlink:\n\n        ret = get_errno(symlink((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_readlink:\n\n        ret = get_errno(readlink((const char *)arg1, (char *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n    case TARGET_NR_swapon:\n\n        ret = get_errno(swapon((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap:\n\n        {\n\n            uint32_t v1, v2, v3, v4, v5, v6, *vptr;\n\n            vptr = (uint32_t *)arg1;\n\n            v1 = tswap32(vptr[0]);\n\n            v2 = tswap32(vptr[1]);\n\n            v3 = tswap32(vptr[2]);\n\n            v4 = tswap32(vptr[3]);\n\n            v5 = tswap32(vptr[4]);\n\n            v6 = tswap32(vptr[5]);\n\n            ret = get_errno((long)mmap((void *)v1, v2, v3, v4, v5, v6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap2:\n\n#else\n\n    case TARGET_NR_mmap:\n\n#endif\n\n        ret = get_errno((long)mmap((void *)arg1, arg2, arg3, arg4, arg5, arg6));\n\n        break;\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(munmap((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_truncate:\n\n        ret = get_errno(truncate((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpriority:\n\n        ret = get_errno(getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n    case TARGET_NR_statfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_statfs((const char *)arg1, stfs));\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            tswap32s(&stfs->f_type);\n\n            tswap32s(&stfs->f_bsize);\n\n            tswap32s(&stfs->f_blocks);\n\n            tswap32s(&stfs->f_bfree);\n\n            tswap32s(&stfs->f_bavail);\n\n            tswap32s(&stfs->f_files);\n\n            tswap32s(&stfs->f_ffree);\n\n            tswap32s(&stfs->f_fsid.val[0]);\n\n            tswap32s(&stfs->f_fsid.val[1]);\n\n            tswap32s(&stfs->f_namelen);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_fstatfs(arg1, stfs));\n\n        goto convert_statfs;\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, (long *)arg2);\n\n        break;\n\n    case TARGET_NR_syslog:\n\n        goto unimplemented;\n\n    case TARGET_NR_setitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_getitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_stat:\n\n        ret = get_errno(stat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        ret = get_errno(lstat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st = (void *)arg2;\n\n                target_st->st_dev = tswap16(st.st_dev);\n\n                target_st->st_ino = tswapl(st.st_ino);\n\n                target_st->st_mode = tswap16(st.st_mode);\n\n                target_st->st_nlink = tswap16(st.st_nlink);\n\n                target_st->st_uid = tswap16(st.st_uid);\n\n                target_st->st_gid = tswap16(st.st_gid);\n\n                target_st->st_rdev = tswap16(st.st_rdev);\n\n                target_st->st_size = tswapl(st.st_size);\n\n                target_st->st_blksize = tswapl(st.st_blksize);\n\n                target_st->st_blocks = tswapl(st.st_blocks);\n\n                target_st->st_atime = tswapl(st.st_atime);\n\n                target_st->st_mtime = tswapl(st.st_mtime);\n\n                target_st->st_ctime = tswapl(st.st_ctime);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            target_long *status_ptr = (void *)arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            struct target_rusage *target_rusage = (void *)arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr)\n\n                    *status_ptr = tswap32(status);\n\n                if (target_rusage) {\n\n                    target_rusage->ru_utime.tv_sec = tswapl(rusage.ru_utime.tv_sec);\n\n                    target_rusage->ru_utime.tv_usec = tswapl(rusage.ru_utime.tv_usec);\n\n                    target_rusage->ru_stime.tv_sec = tswapl(rusage.ru_stime.tv_sec);\n\n                    target_rusage->ru_stime.tv_usec = tswapl(rusage.ru_stime.tv_usec);\n\n                    target_rusage->ru_maxrss = tswapl(rusage.ru_maxrss);\n\n                    target_rusage->ru_ixrss = tswapl(rusage.ru_ixrss);\n\n                    target_rusage->ru_idrss = tswapl(rusage.ru_idrss);\n\n                    target_rusage->ru_isrss = tswapl(rusage.ru_isrss);\n\n                    target_rusage->ru_minflt = tswapl(rusage.ru_minflt);\n\n                    target_rusage->ru_majflt = tswapl(rusage.ru_majflt);\n\n                    target_rusage->ru_nswap = tswapl(rusage.ru_nswap);\n\n                    target_rusage->ru_inblock = tswapl(rusage.ru_inblock);\n\n                    target_rusage->ru_oublock = tswapl(rusage.ru_oublock);\n\n                    target_rusage->ru_msgsnd = tswapl(rusage.ru_msgsnd);\n\n                    target_rusage->ru_msgrcv = tswapl(rusage.ru_msgrcv);\n\n                    target_rusage->ru_nsignals = tswapl(rusage.ru_nsignals);\n\n                    target_rusage->ru_nvcsw = tswapl(rusage.ru_nvcsw);\n\n                    target_rusage->ru_nivcsw = tswapl(rusage.ru_nivcsw);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_swapoff:\n\n        ret = get_errno(swapoff((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_sysinfo:\n\n        goto unimplemented;\n\n    case TARGET_NR_ipc:\n\n        goto unimplemented;\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_sigreturn:\n\n        goto unimplemented;\n\n    case TARGET_NR_clone:\n\n        goto unimplemented;\n\n    case TARGET_NR_setdomainname:\n\n        ret = get_errno(setdomainname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        ret = get_errno(sys_uname((struct new_utsname *)arg1));\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = get_errno(gemu_modify_ldt(cpu_env, arg1, (void *)arg2, arg3));\n\n        break;\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n            target_ulong *pset = (void *)arg2, *poldset = (void *)arg3;\n\n            \n\n            switch(how) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -EINVAL;\n\n                goto fail;\n\n            }\n\n            \n\n            if (pset) {\n\n                target_to_host_old_sigset(&set, pset);\n\n                set_ptr = &set;\n\n            } else {\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && poldset) {\n\n                host_to_target_old_sigset(poldset, &oldset);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_create_module:\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n    case TARGET_NR_get_kernel_syms:\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsuid:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsgid:\n\n        goto unimplemented;\n\n    case TARGET_NR__llseek:\n\n        {\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            *(int64_t *)arg4 = tswap64(res);\n\n        }\n\n        break;\n\n    case TARGET_NR_getdents:\n\n#if TARGET_LONG_SIZE != 4\n\n#error not supported\n\n#endif\n\n        {\n\n            struct dirent *dirp = (void *)arg2;\n\n            long count = arg3;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = tswap16(de->d_reclen);\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = reclen;\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, (void *)arg2, (void *)arg3, (void *)arg4, \n\n                        (void *)arg5);\n\n        break;\n\n    case TARGET_NR_flock:\n\n        goto unimplemented;\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(readv(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(writev(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n    case TARGET_NR_fdatasync:\n\n        goto unimplemented;\n\n    case TARGET_NR__sysctl:\n\n        goto unimplemented;\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_setscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n    case TARGET_NR_sched_get_priority_min:\n\n    case TARGET_NR_sched_rr_get_interval:\n\n    case TARGET_NR_nanosleep:\n\n    case TARGET_NR_mremap:\n\n    case TARGET_NR_setresuid:\n\n    case TARGET_NR_getresuid:\n\n    case TARGET_NR_vm86:\n\n    case TARGET_NR_query_module:\n\n    case TARGET_NR_poll:\n\n    case TARGET_NR_nfsservctl:\n\n    case TARGET_NR_setresgid:\n\n    case TARGET_NR_getresgid:\n\n    case TARGET_NR_prctl:\n\n    case TARGET_NR_rt_sigreturn:\n\n    case TARGET_NR_rt_sigaction:\n\n    case TARGET_NR_rt_sigprocmask:\n\n    case TARGET_NR_rt_sigpending:\n\n    case TARGET_NR_rt_sigtimedwait:\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n    case TARGET_NR_rt_sigsuspend:\n\n    case TARGET_NR_pread:\n\n    case TARGET_NR_pwrite:\n\n        goto unimplemented;\n\n    case TARGET_NR_chown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getcwd:\n\n        ret = get_errno(sys_getcwd1((char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_capget:\n\n    case TARGET_NR_capset:\n\n    case TARGET_NR_sigaltstack:\n\n    case TARGET_NR_sendfile:\n\n    case TARGET_NR_getpmsg:\n\n    case TARGET_NR_putpmsg:\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(vfork());\n\n        break;\n\n    case TARGET_NR_ugetrlimit:\n\n    case TARGET_NR_truncate64:\n\n    case TARGET_NR_ftruncate64:\n\n    case TARGET_NR_stat64:\n\n    case TARGET_NR_lstat64:\n\n    case TARGET_NR_fstat64:\n\n    case TARGET_NR_lchown32:\n\n    case TARGET_NR_getuid32:\n\n    case TARGET_NR_getgid32:\n\n    case TARGET_NR_geteuid32:\n\n    case TARGET_NR_getegid32:\n\n    case TARGET_NR_setreuid32:\n\n    case TARGET_NR_setregid32:\n\n    case TARGET_NR_getgroups32:\n\n    case TARGET_NR_setgroups32:\n\n    case TARGET_NR_fchown32:\n\n    case TARGET_NR_setresuid32:\n\n    case TARGET_NR_getresuid32:\n\n    case TARGET_NR_setresgid32:\n\n    case TARGET_NR_getresgid32:\n\n    case TARGET_NR_chown32:\n\n    case TARGET_NR_setuid32:\n\n    case TARGET_NR_setgid32:\n\n    case TARGET_NR_setfsuid32:\n\n    case TARGET_NR_setfsgid32:\n\n    case TARGET_NR_pivot_root:\n\n    case TARGET_NR_mincore:\n\n    case TARGET_NR_madvise:\n\n    case TARGET_NR_getdents64:\n\n    case TARGET_NR_fcntl64:\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n    case TARGET_NR_readahead:\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        goto unimplemented;\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"Unsupported syscall: %d\\n\", num);\n\n        ret = -ENOSYS;\n\n        break;\n\n    }\n\n fail:\n\n    return ret;\n\n}\n", "idx": 14289, "substitutes": {"cpu_env": ["cpu_ext", "cpu2info", "cpu_path", "cpu2path", "cpu2ext", "cpu_info", "pu_ext", "pu_info", "cpu2env", "pu_path", "pu_env"], "num": ["proc", "NUM", "sync", "nam", "integ", "code", "current", "name", "msg", "fun", "test", "nb", "unit", "method", "con", "init", "sum", "gnu", "loc", "valid", "fn", "begin", "np", "temp", "multi", "count", "n", "nu", "number", "timeout", "block", "nm", "counter", "Num", "type", "gen", "loop", "cmd", "out", "command", "um", "param", "off", "no", "reg", "dim", "len", "thread", "node"], "arg1": ["erg2", "arg10", "ig2", "ar2", "Arg91", "ax1", "args6", "argument1", "args2", "argumentone", "arg31", "argone", "arg91", "arg01", "ar1", "Argn", "Arg01", " arg0", "ag2", "ig1", "Arg4", "ag6", "mag2", " arg31", "args3", "argumentn", " arg01", "ax6", "ar4", " argone", "args1", " arg91", "erg31", "mag91", "inc2", "Arg5", "ag0", "ar3", "argument3", "Arg31", "mag1", "Arg0", "inc1", "ax2", "args0", "arg0", "Arg10", "Arg2", "argument01", "Arg3", " arg10", "Arg1", "ar0", "argument6", "erg1", "argn", "ig3", "inc3", "ax5", "axone", "ag1", "ig10", "args4", "inc4", "argument2", " argn"], "arg2": ["Arg5", "Arg6", "Arg52", " arg52", "ar3", "Arg4", "argument42", "ark4", "ar2", "arg02", "ax4", "ax1", "Arg42", "argument52", "item42", "argument4", "arg52", "ark1", "ax2", "item4", "ax6", "ar4", "item5", "argument1", "Arg2", "arg42", "Arg3", "Arg02", "Arg1", "ar1", " arg02", "ark2", "ark02", "argument2", "item2", "argument5"], "arg3": ["Arg5", "Arg6", "argument6", "ar3", "Arg4", "argument3", "ar2", "argument4", "ar4", "argument1", "Arg2", "Arg3", "Arg1", "ar1", "argument2", "argument5", "ar6"], "arg4": ["args4", "args3", "argument2", "args5", "args2", "argument3", "argument4", "argument5"], "arg5": ["args4", "ar4", "ar2", "args3", "ar3", "args5", "ar5", "args2"], "arg6": ["args6", "doc5", "ax7", "doc6", "doc7", "ax6", "args8", "arg7", "ax5", "arg8", "doc8", "args5", "args7", "ax8"], "ret": ["alt", "let", "en", "rev", "format", "ft", "reply", "sg", "rc", "id", "val", "back", "def", "rets", "gt", "fun", "rg", "std", "str", "ref", "det", "arg", "lit", "error", "value", "job", "conn", "obj", "pass", "ut", "mt", "ll", "mem", "success", "data", "match", "ext", "Ret", "result", "expr", "att", "rl", "url", "red", "cat", " result", "nt", "re", "rt", "get", "resp", "repl", "db", "r", "RET", "reg", "flag", "lv", "len", "bit", "err"], "st": ["t", "ust", "std", "x", "vm", "istic", "ss", "mt", "bl", "ST", "sf", "sb", "est", "inst", "St", "store", "sn", "nt", "sc", "sl", "ast", "stack", "ist", "rest", "sts", "ost"], "stfs": ["sthfs", "stfn", "snFS", "ostfd", "snfd", "snfs", "snfn", "stfd", "ostfs", "sthFS", "sthfn", "ostFS", "ostfn", "stFS", "sthfd"], "status": ["date", "warning", "STAT", "complete", "service", "d", "id", "code", "msg", "name", "ex", "fps", "sp", "source", "progress", "uses", "str", "si", "update", "comment", "error", "job", "step", "flags", "size", "stage", "version", "active", "s", "info", "sec", "temp", "wait", "success", "data", "stat", "result", "speed", "state", "spec", "serv", "type", "stats", "security", "class", "flag", "y", "Status", "index", "start"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static int vscsi_queue_cmd(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union srp_iu *srp = &req->iu.srp;\n\n    SCSIDevice *sdev;\n\n    int n, id, lun;\n\n\n\n    vscsi_decode_id_lun(be64_to_cpu(srp->cmd.lun), &id, &lun);\n\n\n\n    /* Qemu vs. linux issue with LUNs to be sorted out ... */\n\n    sdev = (id < 8 && lun < 16) ? s->bus.devs[id] : NULL;\n\n    if (!sdev) {\n\n        dprintf(\"VSCSI: Command for id %d with no drive\\n\", id);\n\n        if (srp->cmd.cdb[0] == INQUIRY) {\n\n            vscsi_inquiry_no_target(s, req);\n\n        } else {\n\n            vscsi_makeup_sense(s, req, ILLEGAL_REQUEST, 0x24, 0x00);\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        } return 1;\n\n    }\n\n\n\n    req->sdev = sdev;\n\n    req->lun = lun;\n\n    n = sdev->info->send_command(sdev, req->qtag, srp->cmd.cdb, lun);\n\n\n\n    dprintf(\"VSCSI: Queued command tag 0x%x CMD 0x%x ID %d LUN %d ret: %d\\n\",\n\n            req->qtag, srp->cmd.cdb[0], id, lun, n);\n\n\n\n    if (n) {\n\n        /* Transfer direction must be set before preprocessing the\n\n         * descriptors\n\n         */\n\n        req->writing = (n < 1);\n\n\n\n        /* Preprocess RDMA descriptors */\n\n        vscsi_preprocess_desc(req);\n\n    }\n\n\n\n    /* Get transfer direction and initiate transfer */\n\n    if (n > 0) {\n\n        req->data_len = n;\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    } else if (n < 0) {\n\n        req->data_len = -n;\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    }\n\n    /* Don't touch req here, it may have been recycled already */\n\n\n\n    return 0;\n\n}\n", "idx": 20026, "substitutes": {"s": ["ns", "spec", "m", "ts", "session", "sg", "t", "rs", "conf", "f", "services", "r", "service", "g", "sb", "i", "ops", "fs", "self", "is", "o", "cs", "d", "e", "ssl", "q", "ses", "v", "sync", "js", "c", "ps", "sym", "p", "secondary", "S", "b", "http", "ks", "gs", "sys", "u", "es", "os", "state", "server", "states", "sq", "ds", "sf"], "req": ["require", "spec", "grab", "user", "ref", "str", "cf", "sec", "release", "exec", "rec", "comp", "tar", "pri", "config", "qt", "qq", "xml", "resource", "next", "res", "gr", "input", "rx", "j", "ctr", "hr", "dq", "query", "app", "sem", "rf", "resp", "min", "arg", "load", "mr", "dev", "ir", "off", "ec", "ra", "desc", "ver", "org", "required", "fr", "war", "quest", "err", "call", "f", "jp", "r", "rt", "ro", "worker", "cb", "rh", "ry", "need", "crit", "iq", "w", "serv", "q", "c", "qa", "Request", " request", "er", "pro", "sq", "progress", "rr", "request", "tr", "conf", "reg", "ext", "ctx", "def", "get", "low", "dr", "e", "client", "cur", "seq", "cmd", "rw", "cache", "cmp", "http", "requ", "wa", "proc"], "srp": ["vrpe", "srf", "krP", "hrf", "lerf", "trp", "krpc", "irpt", "srP", "drpr", "yrpe", "crf", "rtpe", "rtpatch", "crps", "sprc", "yrp", "srper", "rrpatch", "src", "irpr", "trpt", "vrp", "hrp", "krpe", "rrpe", "trpe", "crc", "yrpt", "sprp", "drpe", "rrpt", "irp", "sprf", "lerp", "hrper", "drpt", "yrpatch", "srps", "vrc", "lerper", "srpr", "irpe", "drpc", "vrps", "vrpc", "srpe", "rtp", "yrpc", "rrpr", "rrp", "trpi", "srpt", "srpatch", "vrpi", "lerpc", "drP", "drp", "krp", "crp", "vrf", "vrpt", "sprps", "hrpe", "srpc", "hrP", "vrper", "yrpi", "srpi", "hrpc", "rtpc", "rrpc"], "sdev": ["fdev", "tsconn", "dsdiv", "dsvalid", "esdi", "pdev", " sgu", "dsdef", " sconn", "ssval", "tsdevice", " sdebug", "nsdi", " sdi", "sdebug", "ssdiv", "physdev", "esconn", "gsvalid", "sval", "sgu", "gsdiv", "southdiv", "Sdevice", " sev", "fdiv", "setsdem", "gsdev", "cdev", "sev", "sDev", "physdevice", "Sev", "cdebug", "dsdev", "Svalid", "sDEV", " sdevice", "svalid", " sdiv", "SDev", "physDEV", "gsval", "servicesdev", "servicescomp", "srad", "psdiv", "psdem", "esdevice", "servicesrad", "sconn", "setsval", "psDev", "esdev", "nsconn", " sDev", "dsev", " srad", "cdiv", "lsdev", "dsDev", "lsdevice", "lsconn", "lsdebug", " spub", "southprof", "esdebug", "cgu", "ssdev", "southdem", "sprof", "Sdev", "csdevice", "setsdev", "servicesev", "csdev", "csconn", " svalid", "setsprof", "nsdev", "setsvalid", "ppub", "fgu", "Sdebug", "scomp", "pdevice", "fdebug", "sdef", " scomp", "spub", "sdi", "psdef", " sdef", "SDEV", "tsdebug", "setsdiv", "sdem", " sDEV", "southdev", "physdebug", "nsdevice", "ssvalid", "psdev", "tsdev", "sdevice", "psprof", "csdebug", "sdiv"], "n": ["ns", " len", "na", "not", "m", "dn", "j", "t", "un", "x", "name", "f", "pn", "net", "ng", "nt", "ne", "r", "adj", "num", "on", "N", "g", "i", "nor", "z", "nl", "max", "in", "nb", "en", "count", "nat", "o", "ln", "l", "non", "d", "nc", "no", "sn", "w", "nu", "k", "e", "v", "ni", "c", "nw", "p", "none", "b", "fn", "anon", "cn", "number", "a", "nn", "an", "y", "len"], "id": ["uri", "Id", "vid", "pid", "code", "db", "data", "info", "x", "name", "f", "ID", "bit", "ref", "du", "md", "aid", "rid", "num", "i", "type", "max", "ide", "in", "kid", "active", "head", "ip", "bid", "d", "uid", "size", "did", "oid", "ident", "length", "start", "q", "ad", "mid", "key", "dev", "seq", "p", "url", "ids", "sid", "len", "end", "it", "bug"], "lun": [" lnum", "dlunt", "kluna", " lban", "lund", "llune", "Lunt", "slund", "luno", "rlun", "fluna", "lcun", "lbUN", "elban", "llUN", "Luc", "plunt", "klnum", "flune", "len", "lon", "klun", "flun", "lcune", "luna", "rlUN", "olun", " lul", "LUN", "pluna", " lune", "dlun", "lunt", "olund", " lunt", "slun", "dlen", "lune", "llun", "lban", "plUN", "lbunt", "clune", "Lul", " len", "Lun", "sluna", "clund", "elen", "klune", "clun", "dlban", "lbuna", "Lon", "lcUN", "elun", "lcunt", "lnum", "oluno", "rluc", "dluc", "elunt", "lluc", "slune", "flnum", "slon", "Luna", " luna", " lUN", "lUN", " luc", "dlUN", "rlune", "plun", "llul", "lbun", "llunt", "sluno", "Lune", "cluno", "olune", "dlune", "lul", "luc", " lon"]}}
{"project": "FFmpeg", "commit_id": "aac0eda40754c010ab5156dcd5d0d1554937e9a7", "target": 0, "func": "static int decode_ics(AACContext * ac, SingleChannelElement * sce, GetBitContext * gb, int common_window, int scale_flag) {\n\n    Pulse pulse;\n\n    TemporalNoiseShaping * tns = &sce->tns;\n\n    IndividualChannelStream * ics = &sce->ics;\n\n    float * out = sce->coeffs;\n\n    int global_gain, pulse_present = 0;\n\n\n\n    /* This assignment is to silence a GCC warning about the variable being used\n\n     * uninitialized when in fact it always is.\n\n     */\n\n    pulse.num_pulse = 0;\n\n\n\n    global_gain = get_bits(gb, 8);\n\n\n\n    if (!common_window && !scale_flag) {\n\n        if (decode_ics_info(ac, ics, gb, 0) < 0)\n\n            return -1;\n\n    }\n\n\n\n    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)\n\n        return -1;\n\n    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)\n\n        return -1;\n\n\n\n    pulse_present = 0;\n\n    if (!scale_flag) {\n\n        if ((pulse_present = get_bits1(gb))) {\n\n            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n                av_log(ac->avccontext, AV_LOG_ERROR, \"Pulse tool not allowed in eight short sequence.\\n\");\n\n                return -1;\n\n            }\n\n            decode_pulses(&pulse, gb, ics->swb_offset);\n\n        }\n\n        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))\n\n            return -1;\n\n        if (get_bits1(gb)) {\n\n            av_log_missing_feature(ac->avccontext, \"SSR\", 1);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)\n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 20199, "substitutes": {"ac": ["pc", "oc", "ic", "dc", "af", "vc", "ct", "gc", "inc", "acc", "aic", "iac", "anc", "app", "bc", "am", "jac", "fac", "as", "mic", "acl", "mc", "Ac", "abc", "act", "AC", "ae", "pac", "ca", "auc", "att", "ack", "cs", "acs", "ach", "kit", "ax", "tc", "config", "ad", "sac", "k", "cu", "ga", "com", "ag", "acer", "c", "cat", "uc", "ck", "aut", "cache", "ec", "ace", "a", "api", "mac", "an", "cc"], "sce": ["SCE", "gske", "iske", "gsced", "spose", "ske", "Scast", "vesce", "scca", " scent", "sste", "dscent", "oscel", " scca", "Sce", "gscel", "psce", "insse", "openske", "unske", "Ske", "scent", "insces", "yscer", "sced", "esce", "sescent", "dsCE", " scel", "vescel", " sste", "opensce", " ske", "sject", " scer", "scel", "gsste", "sCE", "pscel", "insce", " sces", "opensse", "ospose", "openscel", "esces", "pscast", "iscca", "inscent", " scast", "insCE", "sse", "osce", "dsce", "inscast", "seske", "unsce", "isject", "scast", " sject", "wske", "sesCE", "vesste", "escel", "wsce", " sse", "dske", "isce", "sesce", "wscel", "osced", " sCE", "scer", "inscel", "unsCE", "ysce", "sces", "wsces", "opensces", "yske", "unscent", "pske", "eske", "veske", "gspose", "gsce", "inske"], "gb": ["pc", "gi", "eb", "gram", "sg", "db", "cfg", "og", "gnu", "GB", "gd", "bin", "cca", "gal", "yg", "agg", "vc", "gio", "ged", "usb", "gc", "gg", "bm", "sb", "g", "gin", "gh", "cb", "hd", "bc", "hub", "ym", "ctx", "gam", "rg", "bb", "lb", "nb", "kw", "range", "cs", "generic", "gp", "gate", "kb", "bf", "ko", "go", "ci", "ig", "mb", "ga", "buff", "bits", "bg", "rb", "gt", "b", "gz", "gs", "boot", "gy", "gm", "cgi", "Gb", "ub"], "common_window": ["commoniangroup", " commonitycount", "commonitydepth", " common_mode", "commoniancount", "commonmwindow", "commoniandepth", " common_depth", "commonarygroup", "commonianwindow", "commonitymode", "commonityevent", "common_event", " common_event", "commonarydepth", " common_group", " commonitywindow", "commonmevent", "commonmmode", "commonitygroup", "common_mode", "commonarywindow", " commonitydepth", "common_count", "common_depth", "commonarycount", "commonitywindow", " common_count", "common_group", " commonitygroup", "commonitycount"], "scale_flag": ["scalevalwin", "scaleoinfo", "scaleallinfo", "cale_window", "cale_bit", "cale_flag", " scale_type", " scale_window", "scalevalwindow", "scale_win", " scale_file", "scalevalbit", "scaleoflag", " scale_info", "scale_file", "scale_bit", "cale_win", "scalealltype", "scalevalflag", "scaleotype", "scale_window", "scaleallflag", "scale_info", "scale_type"], "pulse": ["vpulse", "pixels", "pushitch", "epuls", "patilot", "compurchase", "lpulse", "epipe", "pitch", " puls", "purchase", "pixel", "lpuls", "compitch", "copitch", "pushulsion", "puls", "epulse", "pulsion", "copixel", "lpilot", "compulse", "pair", "vpulsion", "compulsion", "Pulsion", "Pilot", "pipe", " pilot", "ppixels", "patair", "patulse", "copulse", "patulsion", "epilot", "paramitch", "paramixel", "pushurchase", "pilot", "vpitch", "ppitch", " pair", " pulsion", "vpurchase", "pushulse", "lpipe", "paramixels", "ppixel", "ppulse", "Pair", " pipe", "paramulse", "Pulse", "copixels"], "tns": ["touts", "Tnas", "tbs", "dds", " tls", "fna", "atsn", "Tls", "atds", "tsbs", "tsns", "tscons", "fls", " ticks", "pns", "dsn", "atnc", "fcs", "atns", "tticks", "fns", "otds", "ttbs", "tnc", "dnc", "pls", "ttcons", "ticks", "Tna", " tcs", " tbs", "Tns", " touts", "pouts", " tcons", "Tcs", "otnc", "tsicks", "tnas", "dns", "ttns", "tls", "tds", "tsn", "tcons", " tnas", "tcs", "Touts", "pnas", " tna", "otns", "tna", "otsn"], "ics": ["ic", "ns", "spec", "cfg", "x", "xes", "gg", "details", "cf", "str", "aic", "igs", "cons", "cs", "icons", "aps", "acks", "qs", "codes", "cli", "xml", "ks", "gy", "icc", "isc", "fi", "icing", "ts", "fps", "cus", "ix", "omics", "osi", "times", "iac", "ips", "bc", "wcs", "mic", "magic", "acs", "inf", "rics", "outs", "ig", "xxx", "ick", "uses", "gz", "status", "nic", "ico", "IC", "fits", "nas", "items", "wic", "cells", "ins", "ci", "ga", "events", "sys", "cases", "rates", "stats", "amples", "gc", "io", "g", "ats", "ls", "ops", "fc", "fs", "abc", "icks", "xs", "is", "css", "args", "inas", "isi", "bits", "ICS", "gs", "its", "ipes"], "out": ["at", "bin", "cfg", "init", "extra", "obj", "err", "image", "full", "ix", "op", "bit", "gc", "io", "Out", "g", "i", "cb", "bc", "in", "wcs", "ext", "raw", "orig", "bb", "copy", "o", "again", "new", "go", "args", "outs", "ui", "img", "prefix", "sync", "temp", "c", "lib", "cache", "gen", "output", "co", "amp", "input"], "global_gain": ["global67gen", "Global_band", "global_generation", "global67gain", "global_wall", "global67wall", "global_band", " global_speed", "global67generation", "global67band", "Global_gen", "global5wall", "global_speed", "global5gain", " global_generation", "Global_growth", "global_gen", "global67growth", " global_wall", "global_growth", "global5generation", " global_gen", "Global_gain"]}}
{"project": "qemu", "commit_id": "4656e1f01289cc3aa20986deb6a407165826abe5", "target": 1, "func": "void ppc_tlb_invalidate_all(CPUPPCState *env)\n\n{\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n        ppc6xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        ppc4xx_tlb_invalidate_all(env);\n\n        break;\n\n    case POWERPC_MMU_REAL:\n\n        cpu_abort(env, \"No TLB for PowerPC 4xx in real mode\\n\");\n\n        break;\n\n    case POWERPC_MMU_MPC8xx:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n        break;\n\n    case POWERPC_MMU_BOOKE:\n\n        tlb_flush(env, 1);\n\n        break;\n\n    case POWERPC_MMU_BOOKE206:\n\n        booke206_flush_tlb(env, -1, 0);\n\n        break;\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_601:\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_620:\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_2_06:\n\n\n#endif /* defined(TARGET_PPC64) */\n\n        tlb_flush(env, 1);\n\n        break;\n\n    default:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"Unknown MMU model\\n\");\n\n        break;\n\n    }\n\n}", "idx": 26472, "substitutes": {"env": ["exec", "fen", "her", "code", "esm", "txt", "args", "console", "kn", "er", "exc", "engine", "server", "c", "context", "him", "manager", "enable", "enc", "vs", "queue", "ec", "en", "config", "Environment", "export", "gear", "priv", "state", "loader", "ev", "dict", "ea", "ah", "environment", "chn", "profile", "forest", "e", "password", "esi", "dat", "err", "viron", "dev", "model", "ctx", "energy", "eu", "skin", "eni", "cache", "erv", "ench", "vm", "req", "h", "icer", "forge", "ext", "stage", "prov", "status", "nw", "conn", "enh", "v", "init", " environment", "event", "settings", "que", "eng"]}}
{"project": "qemu", "commit_id": "3b00f702c236900cca403bdcbed48d59bfec0fba", "target": 0, "func": "static void s390_flic_common_realize(DeviceState *dev, Error **errp)\n\n{\n\n    S390FLICState *fs = S390_FLIC_COMMON(dev);\n\n    uint32_t max_batch = fs->adapter_routes_max_batch;\n\n\n\n    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {\n\n        error_setg(errp, \"flic property adapter_routes_max_batch too big\"\n\n                   \" (%d > %d)\", max_batch, ADAPTER_ROUTES_MAX_GSI);\n\n    }\n\n\n\n    fs->ais_supported = true;\n\n}\n", "idx": 23555, "substitutes": {"dev": ["md", "Dev", "str", "priv", "grad", "cam", "def", "conn", "eth", "de", "d", "tr", "ds", "device", "devices", "dist", "info", "data", "diff", "mod", "self", "pro", "ver", "rad", "dc", "dm", "test", "req", "tty", "di", "proc", "conf", "bus", "hw", "development", "ev", "pub"], "errp": [" errf", "rrP", "rrf", "rorp", "rorip", "errf", "erip", "errorpc", "rrp", " errfp", " errpc", "errpc", "rrpc", "errfp", "errP", " errip", "errorf", "rorpc", "erfp", "errorP", " errP", "errip", "erp", "rorfp", "erpc", "errorp"], "fs": ["fc", "outs", "qs", "fts", "linux", "fb", "ks", "ds", "fp", "f", "flags", "df", "flows", "sys", "fps", "os", "fx", "cf", "cs", "fits", "ls", "vs", "stats", "af", "js", "FS", "ows", "fr", "ms", "fd", "ns", "fw", "feed", "ps", "alls", "bf", "bs", "Fs", "ats", "files", "ips", "ss"]}}
{"project": "qemu", "commit_id": "240ce26a0533a6e5ee472789fbfbd9f7f939197e", "target": 1, "func": "static int decode_micromips_opc (CPUMIPSState *env, DisasContext *ctx, int *is_branch)\n\n{\n\n    uint32_t op;\n\n\n\n    /* make sure instructions are on a halfword boundary */\n\n    if (ctx->pc & 0x1) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        ctx->bstate = BS_STOP;\n\n        return 2;\n\n    }\n\n\n\n    op = (ctx->opcode >> 10) & 0x3f;\n\n    /* Enforce properly-sized instructions in a delay slot */\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT;\n\n\n\n        switch (op) {\n\n        case POOL32A:\n\n        case POOL32B:\n\n        case POOL32I:\n\n        case POOL32C:\n\n        case ADDI32:\n\n        case ADDIU32:\n\n        case ORI32:\n\n        case XORI32:\n\n        case SLTI32:\n\n        case SLTIU32:\n\n        case ANDI32:\n\n        case JALX32:\n\n        case LBU32:\n\n        case LHU32:\n\n        case POOL32F:\n\n        case JALS32:\n\n        case BEQ32:\n\n        case BNE32:\n\n        case J32:\n\n        case JAL32:\n\n        case SB32:\n\n        case SH32:\n\n        case POOL32S:\n\n        case ADDIUPC:\n\n        case SWC132:\n\n        case SDC132:\n\n        case SD32:\n\n        case SW32:\n\n        case LB32:\n\n        case LH32:\n\n        case DADDIU32:\n\n        case LWC132:\n\n        case LDC132:\n\n        case LD32:\n\n        case LW32:\n\n            if (bits & MIPS_HFLAG_BDS16) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        case POOL16A:\n\n        case POOL16B:\n\n        case POOL16C:\n\n        case LWGP16:\n\n        case POOL16F:\n\n        case LBU16:\n\n        case LHU16:\n\n        case LWSP16:\n\n        case LW16:\n\n        case SB16:\n\n        case SH16:\n\n        case SWSP16:\n\n        case SW16:\n\n        case MOVE16:\n\n        case ANDI16:\n\n        case POOL16D:\n\n        case POOL16E:\n\n        case BEQZ16:\n\n        case BNEZ16:\n\n        case B16:\n\n        case LI16:\n\n            if (bits & MIPS_HFLAG_BDS32) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                /* Just stop translation; the user is confused.  */\n\n                ctx->bstate = BS_STOP;\n\n                return 2;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    switch (op) {\n\n    case POOL16A:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs1 = mmreg(uMIPS_RS1(ctx->opcode));\n\n            int rs2 = mmreg(uMIPS_RS2(ctx->opcode));\n\n            uint32_t opc = 0;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case ADDU16:\n\n                opc = OPC_ADDU;\n\n                break;\n\n            case SUBU16:\n\n                opc = OPC_SUBU;\n\n                break;\n\n            }\n\n\n\n            gen_arith(ctx, opc, rd, rs1, rs2);\n\n        }\n\n        break;\n\n    case POOL16B:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rs = mmreg(uMIPS_RS(ctx->opcode));\n\n            int amount = (ctx->opcode >> 1) & 0x7;\n\n            uint32_t opc = 0;\n\n            amount = amount == 0 ? 8 : amount;\n\n\n\n            switch (ctx->opcode & 0x1) {\n\n            case SLL16:\n\n                opc = OPC_SLL;\n\n                break;\n\n            case SRL16:\n\n                opc = OPC_SRL;\n\n                break;\n\n            }\n\n\n\n            gen_shift_imm(ctx, opc, rd, rs, amount);\n\n        }\n\n        break;\n\n    case POOL16C:\n\n        gen_pool16c_insn(ctx, is_branch);\n\n        break;\n\n    case LWGP16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = 28;            /* GP */\n\n            int16_t offset = SIMM(ctx->opcode, 0, 7) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case POOL16F:\n\n        if (ctx->opcode & 1) {\n\n            generate_exception(ctx, EXCP_RI);\n\n        } else {\n\n            /* MOVEP */\n\n            int enc_dest = uMIPS_RD(ctx->opcode);\n\n            int enc_rt = uMIPS_RS2(ctx->opcode);\n\n            int enc_rs = uMIPS_RS1(ctx->opcode);\n\n            int rd, rs, re, rt;\n\n            static const int rd_enc[] = { 5, 5, 6, 4, 4, 4, 4, 4 };\n\n            static const int re_enc[] = { 6, 7, 7, 21, 22, 5, 6, 7 };\n\n            static const int rs_rt_enc[] = { 0, 17, 2, 3, 16, 18, 19, 20 };\n\n\n\n            rd = rd_enc[enc_dest];\n\n            re = re_enc[enc_dest];\n\n            rs = rs_rt_enc[enc_rs];\n\n            rt = rs_rt_enc[enc_rt];\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n            gen_arith_imm(ctx, OPC_ADDIU, re, rt, 0);\n\n        }\n\n        break;\n\n    case LBU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n            offset = (offset == 0xf ? -1 : offset);\n\n\n\n            gen_ld(ctx, OPC_LBU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LHU16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_ld(ctx, OPC_LHU, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case LW16:\n\n        {\n\n            int rd = mmreg(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_ld(ctx, OPC_LW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SB16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4);\n\n\n\n            gen_st(ctx, OPC_SB, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SH16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 1;\n\n\n\n            gen_st(ctx, OPC_SH, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SWSP16:\n\n        {\n\n            int rd = (ctx->opcode >> 5) & 0x1f;\n\n            int rb = 29;            /* SP */\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 5) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case SW16:\n\n        {\n\n            int rd = mmreg2(uMIPS_RD(ctx->opcode));\n\n            int rb = mmreg(uMIPS_RS(ctx->opcode));\n\n            int16_t offset = ZIMM(ctx->opcode, 0, 4) << 2;\n\n\n\n            gen_st(ctx, OPC_SW, rd, rb, offset);\n\n        }\n\n        break;\n\n    case MOVE16:\n\n        {\n\n            int rd = uMIPS_RD5(ctx->opcode);\n\n            int rs = uMIPS_RS5(ctx->opcode);\n\n\n\n            gen_arith_imm(ctx, OPC_ADDIU, rd, rs, 0);\n\n        }\n\n        break;\n\n    case ANDI16:\n\n        gen_andi16(ctx);\n\n        break;\n\n    case POOL16D:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUS5:\n\n            gen_addius5(ctx);\n\n            break;\n\n        case ADDIUSP:\n\n            gen_addiusp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case POOL16E:\n\n        switch (ctx->opcode & 0x1) {\n\n        case ADDIUR2:\n\n            gen_addiur2(ctx);\n\n            break;\n\n        case ADDIUR1SP:\n\n            gen_addiur1sp(ctx);\n\n            break;\n\n        }\n\n        break;\n\n    case B16:\n\n        gen_compute_branch(ctx, OPC_BEQ, 2, 0, 0,\n\n                           SIMM(ctx->opcode, 0, 10) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case BNEZ16:\n\n    case BEQZ16:\n\n        gen_compute_branch(ctx, op == BNEZ16 ? OPC_BNE : OPC_BEQ, 2,\n\n                           mmreg(uMIPS_RD(ctx->opcode)),\n\n                           0, SIMM(ctx->opcode, 0, 7) << 1);\n\n        *is_branch = 1;\n\n        break;\n\n    case LI16:\n\n        {\n\n            int reg = mmreg(uMIPS_RD(ctx->opcode));\n\n            int imm = ZIMM(ctx->opcode, 0, 7);\n\n\n\n            imm = (imm == 0x7f ? -1 : imm);\n\n            tcg_gen_movi_tl(cpu_gpr[reg], imm);\n\n        }\n\n        break;\n\n    case RES_20:\n\n    case RES_28:\n\n    case RES_29:\n\n    case RES_30:\n\n    case RES_31:\n\n    case RES_38:\n\n    case RES_39:\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    default:\n\n        decode_micromips32_opc (env, ctx, op, is_branch);\n\n        return 4;\n\n    }\n\n\n\n    return 2;\n\n}\n", "idx": 10504, "substitutes": {"env": ["cot", "fg", "chal", "cdn", "conf", "qt", "pec", "context", "equ", "conn", "org", "info", "que", "iv", "viron", "environment", "e", "cb", "qa", "erv", "txt", "np", "priv", "ec", "manager", "inst", "ev", "db", "cv", "ea", "oa", "scope", "exc", "cal", "en", "err", "Environment", "enc", "esp", "cfg", "dev", "her", "eu", "pkg", "fi"], "ctx": ["utils", "cmp", "Context", "na", "sci", "fw", "gs", "config", "qq", "cb", "np", "txt", "cn", "wcs", "loc", "cc", "cas", "kt", "cpp", "concept", "gc", "nc", "ca", "grad", "rx", "pkg", "settings", "fc", "ku", "prefix", "cca", "c", "ct", "cf", "sq", "hw", "bc", "conv", "wx", "anc", "lc", "sc", "exec", "std", "context", "conn", "src", "cp", "util", "cli", "cs", "ctrl", "progress", "linux", "ck", "sync", "rc", "ga", "tx", "jp", "xc", "kw", "fn", "comp", "vc", "cmd", "qa", "console", "lib", "cv", "support", "pc", "git", "cm", "client", "ci", "kb"], "is_branch": ["is_bracket", "is_braged", "is_backet", "is_baluster", "is_refanch", "is_balanch", "is_banch", "is_baged", "is_buster", "is_refaged", "is_bruster", "is_refacket", "is_balaged", "is_refuster", "is_balacket"], "op": ["tool", "pol", "sp", "vert", "oc", "it", "operator", "operation", "ext", " Op", "proc", "prefix", "opus", "ops", " ip", "top", "ver", "rop", "addr", "p", "prev", "OP", "oop", "ep", "off", "bug", "prop", "mode", "dr", "omp", "cop", "opt", "msg", "name", "opp", "Op", "mod", "option", "ipop", "hop", "oper", "bit", "type", "cat", "lock", "ip", "ant", "lic", "cmd", "ap", "expr", "pop"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_int(TestOutputVisitorData *data,\n\n                                 const void *unused)\n\n{\n\n    int64_t value = -42;\n\n    QObject *obj;\n\n\n\n    visit_type_int(data->ov, NULL, &value, &error_abort);\n\n\n\n    obj = visitor_get(data);\n\n    g_assert(qobject_type(obj) == QTYPE_QINT);\n\n    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);\n\n}\n", "idx": 24212, "substitutes": {"data": ["exec", "Data", "code", "call", "args", "this", "info", "p", "m", "parser", "d", "qa", "test", "buffer", "api", "style", "config", "ad", "ds", "type", "reader", "state", "id", "self", "ui", "o", "arr", "input", "dat", "object", "parent", "ctx", "client", "record", "cache", "window", "comment", "value", "da", "a", "DATA", "match", "database", "draw", "result", "writer"], "unused": ["unknownuse", " unchecked", "Unuse", "unknownchecked", "unchecked", "unusable", " unuse", "unuse", "unknownusable", "Unused", " unusable", "Unusable", "Unchecked", "unknownused"], "obj": ["ref", "node", "code", "args", "ie", "i", "p", "b", "pt", "bo", "adj", "ns", "ob", "x", "api", "Object", "img", "py", "jp", "cb", "act", "eff", "so", "inst", "instance", "op", "bj", "o", "tmp", "nb", "object", "art", "nt", "parent", "ctx", "os", "fi", "oa", "Obj", "elt", "po", "oi", "n", "j", "js", "alt", "value", "coll", "init", "ind", "ex", "attr", "pos", "val"]}}
{"project": "qemu", "commit_id": "21ce148c7ec71ee32834061355a5ecfd1a11f90f", "target": 1, "func": "static inline int cris_addc_pi_m(int a, int **b)\n\n{\n\n\tasm volatile (\"addc [%1+], %0\\n\" : \"+r\" (a), \"+b\" (*b));\n\n\treturn a;\n\n}\n", "idx": 10640, "substitutes": {"a": ["parent", "l", "va", "area", "ama", "na", "da", "ba", "x", "ab", "pa", "i", "sa", "c", "ad", "p", "e", "aaa", "ada", "au", "ia", "f", "ac", "an", "la", "fa", "alpha", "ae", "ha", "ea", "name", "am", "ga", "A", "as", "aa", "ca", "ma"], "b": ["l", "ib", "base", "bb", "nb", "abc", "abb", "ba", "m", "bar", "k", "ab", "x", "wb", "i", "c", "fb", "bd", "pb", "e", "cb", "B", "rb", "f", "be", "db", "bf", "v", "lb", "bis", "sb", "emb", "ob", "y", "xb", "bs", "zb"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int process_input_packet(InputStream *ist, const AVPacket *pkt)\n\n{\n\n    int i;\n\n    int got_output;\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int ret = 0;\n\n    handle_eof:\n\n\n\n        ist->last_dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size &&\n\n            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = decode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = decode_video    (ist, &avpkt, &got_output);\n\n            if (avpkt.duration)\n\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            else if (ist->st->avg_frame_rate.num)\n\n                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),\n\n                                              AV_TIME_BASE_Q);\n\n            else if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n\n                                                   ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        ist->last_dts = ist->next_dts;\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n\n                             ist->dec_ctx->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->dec_ctx->time_base.num * ticks) /\n\n                                  ist->dec_ctx->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 566, "substitutes": {"ist": ["dr", "ism", "ists", "act", "rest", "ct", "adder", "kt", "er", "ind", "pop", "set", "wp", "gest", "irst", "est", "ld", "ext", "alist", "ht", "sth", "erd", "pick", "edit", "ict", "asp", "adr", "post", "work", "esp", "isi", "wd", "uss", "ird", "iz", "nd", "ast", "pt", "artist", "ard", "IST", "osi", "xt", "ad", "add", "op", "ait", "str", "feat", "st", "oss", "et", "ide", "isu", "ista", "rss", "inst", "sim", "dit", "ust", "isc", "dd", "isd", "ant", "asi", "ord", "it", "iste", "pect", "nt", "ft", "mot", "ess", "ocr", "art", "std", "ilst", "sta", "dat", "part", "ace", "gd", "dist"], "pkt": ["pcht", " packet", " pct", "pnt", "poch", "tpacket", " poch", "jpkt", "pelt", "pkh", "tacket", "paelt", "ipkh", "Pft", "wpcht", "prekt", "paacket", "spkt", " pkg", "packet", "wpkh", "ipcht", " pqt", "preacket", "tpcht", "ipnt", "cpelt", "ipkt", " pcht", "wpnt", "pkg", "tpkt", "spkg", "Pkg", "ipacket", "cpoch", "jpacket", "pct", "pakt", "dunch", "Pkt", "ipelt", "spacket", "Pcht", "punch", "spcht", "pft", "prent", " pelt", " punch", "Pnt", "ipoch", "cpkt", "jpqt", "tkt", "spnt", "Punch", "telt", "tcht", "Pelt", "spelt", "Pct", " pft", "tpqt", "Pqt", "preelt", " pnt", "pacht", "spkh", "cpacket", "dacket", "pqt", "dkt", "wpkt", "dct", "jpft", "Packet"], "i": ["ret", "out", "I", "n", "id", "it", "num", "j", "g", "rep", "inner", "info", "nt", "multi", "h", "x", "p", "et", "fin", "f", "len", "set", "reset", "en", "debug", "start", "det", "res"], "got_output": ["gotestenabled", "genestgenerated", "given_input", " got_Output", "got_hidden", "got_control", "gotesttarget", "gotaccontrol", "got_target", "gotayenabled", "gotacoutput", "genestenabled", "gotachidden", "genestoutput", "got_Output", "given_output", " got_value", "gen_target", "got_value", "genesttarget", "gotayOutput", "got_reason", "got_progress", "got_input", "got_enabled", "got_generated", "gotestgenerated", "gotaygenerated", "gen_output", "gotayreason", " got_reason", "gotacinput", "given_control", "gotestoutput", "gotaytarget", "gen_enabled", " got_progress", "given_hidden", "gen_generated", "gotayoutput"], "avpkt": ["avnpka", "avnpkt", "ullpck", "avcurrentkt", "affkt", "affck", "avpreacket", "AVpqt", "attcpacket", "avopck", "avspacket", "avprekt", "ajpkt", "avpft", "avppsth", "avespacket", "avpakt", "avvacket", "avppka", "avbputh", "ajmft", "AVpauth", "attcpkt", "avcurrentacket", "airlelt", "avfcht", "avbcht", "avhelt", "avelacket", "avcpet", "avmcht", "navpkat", "airpKT", "avcacket", "avepka", "avgelt", "avpqt", "avbpcht", "avpett", "avpacht", "avpacket", "avppft", "avpekt", "avpaunch", "airlacket", "avpeconn", "avpkat", "avcnt", "avpaacket", "airbkt", "avcpacket", "avcpt", "avrcht", "avppkh", "avepunch", "avspeth", "avpka", "avbpqt", "avbpkt", "avpaft", "attpacket", "avgkt", "ajpcht", "ajmkt", "navdacket", "avdacket", "airpett", "avcpkt", "AVpaft", "avnpck", "avcpck", "affacket", "avspelt", "avlKT", "avppck", "avbacket", "avppkt", "avfck", "ajpft", "avbpsth", "airbett", "ampkt", "avespkt", "avspunch", "avfunch", "avfpka", "avenpkt", "ullppsth", "attcpet", "avfconn", "avelnt", "avheth", "avvkt", "avpunch", "avpet", "avbkt", "navdkat", "avfiece", "avfkt", "avmkt", "avprkat", "avepnt", "ajmelt", "avepkt", "avbpck", "navpkt", "airbft", "AVpaqt", "ampcht", "ullppck", "avfpft", "ullpkt", "avwett", "avbett", "avespunch", "avwcht", "attpck", "avbpft", "avpck", "avespcht", "avpreelt", "avbconn", "ampeth", "airlKT", "avapeth", "avepft", "avelpt", "avgft", "amspeth", "avppt", "attpkt", "avpKT", "avbuth", "avdkat", "avpeth", "avspcht", "avpreKT", "ullpkh", "ampelt", "avapelt", "avnpsth", "ajpelt", "ajmcht", "avspkt", "affconn", "attcpck", "avbck", "avvKT", "avvelt", "avenpck", "avbpkh", "airlkt", "amspkt", "avepcht", "amspelt", "airpcht", "airpft", "avdiece", "avopacket", "afpconn", "avhcht", "airpelt", "avpnt", "navpiece", "AVpkt", "avpsth", "afpkt", "avbqt", "avmft", "avputh", "avfpck", "avwft", "avfkat", "avrft", "avbft", "avelkt", "avmelt", "navdkt", "avpriece", "avgcht", "avopet", "avpconn", "avbpelt", "airbcht", "ullpsth", "avfpkt", "navdiece", "avpcht", "avpkh", "avlpt", "avdkt", "avapkt", "AVputh", "avepacket", "avprkt", "ullppkh", "avopkt", "avenpft", "avfacket", "avcurrentpt", "avnpft", "avpiece", "aveppt", "avpracket", "avpeacket", "avnpkh", "afpacket", "avepck", "AVpakt", "avfet", "avenpka", "avlnt", "airpacket", "avpaqt", "ullppkt", "navpacket", "afpck", "amspcht", "avrkt", "AVpft", "avhkt", "avpelt", "airpkt", "avlelt", "avapcht", "avwkt", "avpeck", "avlkt", "avckt", "avlacket", "avcurrentnt", "avpauth", "avrett", "attpet"]}}
{"project": "FFmpeg", "commit_id": "41abc9da50ba7a7b68bbbf6622475ce7a3c72e3f", "target": 1, "func": "static int decode_frame_ilbm(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    IffContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n\n    const uint8_t *buf_end = buf+buf_size;\n\n    int y, plane, res;\n\n\n\n    if ((res = extract_header(avctx, avpkt)) < 0)\n\n        return res;\n\n\n\n    if (s->init) {\n\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n            return res;\n\n        }\n\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return res;\n\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n\n            return res;\n\n    }\n\n    s->init = 1;\n\n\n\n    if (avctx->codec_tag == MKTAG('A','C','B','M')) {\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for (plane = 0; plane < s->bpp; plane++) {\n\n                for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n                    uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for(y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    const uint8_t * start = buf + (plane * avctx->height + y) * s->planesize;\n\n                    if (start >= buf_end)\n\n                        break;\n\n                    decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {\n\n        int raw_width = avctx->width * (av_get_bits_per_pixel(&av_pix_fmt_descriptors[avctx->pix_fmt]) >> 3);\n\n        int x;\n\n        for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n            memcpy(row, buf, FFMIN(raw_width, buf_end - buf));\n\n            buf += raw_width;\n\n            if (avctx->pix_fmt == PIX_FMT_BGR32) {\n\n                for(x = 0; x < avctx->width; x++)\n\n                    row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(row, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { // PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width % 2); // padding if odd\n\n            }\n\n        } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width & 1); // padding if odd\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else {\n\n            av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n", "idx": 24896, "substitutes": {"avctx": ["apcontext", "vercmp", "navcontext", "avalconn", "alconn", "aprt", "versci", "avehw", "avcontext", "avesync", "afcontext", "afrt", "ajcue", "avectx", "avctl", "ajctx", " avpkg", "ajcot", "avalcci", "afxc", " avcot", "abcmp", "avcci", "abcoll", "akctx", "akcontext", "AVcontext", "afcli", "avcu", "abcf", "afsync", "avepkg", "avcoll", "afctrl", "AVconfig", "abcontext", "afc", "avalcontext", "avalctrl", "avsci", " avctl", "afctx", "avconfig", "apcoll", "avalctx", "avpkg", "avcot", "afca", "avchan", "avectrl", "abctx", "avctrl", "avhw", "apcf", "navsync", "apconn", "AVctx", "ajc", "avrt", "avxc", "verctx", "aveca", "akcb", "avcb", "alctx", "avecb", "avcf", "ajhw", "ajcoll", "avecontext", "afchan", "avcmp", "afcmp", "verconn", "apctx", "abc", "ajctl", "avsync", "akca", "afcf", "avca", "navpkg", "avecu", "afhw", "afcci", "akchan", "ajrt", "afcue", "afcb", "avalpkg", "akcci", "avc", "AVpkg", "navconfig", " avxc", "afcot", "avconn", "alcontext", "afcoll", "ajcf", "afconn", "ajconfig", "ajcontext", "ajsync", "akconn", "afctl", "avalxc", "alpkg", "avalchan", "afpkg", "vercf", "avcue", "avalsci", "avecli", "aveconfig", "vercontext", "avcli", "afcu", " avcu", " avcoll", "aveconn", "avalsync", " avconn", "afsci", " avcontext", "avecue", "navctx", "akpkg", "navcli", "afconfig"], "data": ["head", "w", "batch", "frame", "name", "module", "buffer", "base", "next", "split", "input", "lines", "sequence", "buff", "window", "bytes", "da", "content", "memory", "draw", "body", "code", "slice", "p", "empty", "action", "actions", "media", "align", "ad", "address", "one", "cache", "first", "value", "DATA", "map", "block", "table", "Data", "done", "bin", "d", "delay", "open", "message", "offset", "output", "parent", "size", "length", "ata", "source", "header", "alpha", "shift", "i", "image", "read", "style", "end", "id", "pad", "padding", "dat", "zero", "layout", "ul", "sample", "last", "series", "index", "a", "results", "result", "format"], "data_size": ["image1len", "data1shape", "image_length", "data1size", "image_len", "data_shape", "image1shape", "image_size", "image_shape", "data_len", "data1length", "data_length", "image1length", "image1size", "data1len"], "avpkt": ["avperkt", "avperdt", "avPacket", "avppacket", "avpce", "avfke", " avpKT", "avlpett", "avpcka", "avvdt", "avspce", "avfpKT", "afpect", "afpce", "avvacket", "avpect", "afpkid", "avpeect", "avppkt", "avbpkid", "afpka", "avfkt", "avspacket", "afpcht", "affce", "avppce", "avfpqt", "avfect", "affect", "ajpacket", "avpckt", "afpki", "ajlpacket", "ajpkt", "affka", "avbpett", "avfett", "avpqt", "avpercht", "avlpacket", "ajlpkt", "afpacket", "avpett", " avPkt", "avect", "avfeth", "avspeth", "avpki", "avfpacket", "avpka", " avPacket", "avfdt", "avlpce", " avPqt", "avpccht", "avpcacket", "abfacket", "avppkid", "avfcht", "avpcht", "affcht", "affki", "avlpeth", "avfpkt", "avperacket", "avpct", "avecht", "avperki", "avPKT", "aphpke", "avvki", "avspke", "avlpke", "avfce", "avcct", "aphlpacket", "avPkt", " avPKT", "avPqt", "abfcht", " avpacket", "affacket", "abpkt", "avperka", "ajpett", "afpdt", " avpqt", "avspkt", "avekt", "avbpkt", "aphpkt", "avfki", "avbpacket", "aveacket", "avpece", "avpkid", "aphpeth", "avfka", "avcacket", "abfct", "avfacket", "afpkt", "avccht", "aphlpkt", "affdt", "abpcht", "avpeth", "ajlpett", "avspect", "avfqt", "ajlpkid", "aphlpeth", "avpeacket", "aphlpke", "avlpkid", "avpke", "avlpkt", "avfct", "affkt", "abfkt", "affkid", "avfKT", "avpekt", "abpacket", "avfkid", "ajpkid", "avpacket", "abpct", "avpKT", "avvkt", "avpdt", "aphpacket", "avckt"], "s": ["S", "sc", "ses", "rs", "sys", "args", "sk", "w", "i", "p", "m", "c", "ss", "ns", "d", "se", "ts", "sq", "ds", "conf", "us", "ps", "sg", "ins", "ks", "sync", "bs", "su", "is", "e", "es", "gs", "stats", "o", "sets", "http", "session", "spec", "l", "si", "sym", "hs", "aws", "os", "sb", "services", "sec", "xs", "sup", "as", "ls", "f", "service", "js", "n", "qs", "details", "a", "t", "fs", "v", "full", "r", "ops", "parts", "ssl", "cs", "its", "g"], "buf": ["seq", "uf", "fin", "gen", "w", "uc", "b", "batch", "wb", "empty", "cv", "bn", "wave", "queue", "buffer", "vec", "base", "cur", "rb", "ab", "cb", "bc", "flow", "num", "bus", "xy", "home", "cmd", "max", "zero", "cap", "loc", "fw", "offset", "box", "fl", "cp", "cf", "alloc", "cache", "bar", "length", "buff", "h", "f", "bytes", "limit", "bg", "header", "lim", "block", "len"], "buf_end": ["buf2End", "fileaclimit", "bufacEnd", "buf2start", "buf2size", "buf_size", "buf_max", "buf2limit", "buffer_end", "file_end", "buf_End", "buffer_start", "buffer_size", "fileacEnd", "bufacend", "file_start", "buf2max", "buffer_max", "fileacend", "fileacstart", "file_End", "file_limit", "bufacstart", "bufaclimit", "buf2end", "buf_limit", "buf_start"], "y": ["height", "yr", "w", "z", "i", "p", "m", "sy", "oy", "dy", "c", "b", "ay", "d", "base", "py", "col", "ye", "type", "gy", "cy", "iy", "ch", "port", "vy", "yo", "key", "ey", "ady", "o", "Y", "yy", "hop", "h", "f", "n", "ip", "j", "ny", "t", "a", "ind", "l", "ya", "area", "g"], "plane": ["zone", "orient", "slice", "w", "z", "page", "p", "nat", "i", "cat", "se", "ge", "weight", "sea", "pe", "planes", "col", "port", "flow", "num", "key", "line", "e", "xy", "span", "axis", "per", "fl", "lane", "rot", "jet", "cp", "mo", "plan", "scale", "period", "level", "direction", "den", "drop", "f", "flo", "n", "ane", "core", "fly", "age", "pos", "pen", "len", "priority", "pose"], "res": ["ber", "rs", "breaks", "gen", "obj", "args", "errors", "score", "nos", "resolution", "RES", "msg", "ms", "success", "cr", "conf", "rus", "gr", "ps", "error", "mr", "cons", "pass", "rec", "range", "press", "bs", "vals", "rss", "e", "css", "resh", "arr", "min", "rh", "err", "rev", "rap", "clean", "re", "ros", "ras", "result", "ret", "sol", "rate", "os", "response", "cache", "req", "ress", "Res", "rem", "des", "status", "rx", "details", "pres", "reg", "js", "resp", "results", "content", "ver", "r", "root", "ris", "reset", "cs", "val", "rates", "rex"], "row": ["sc", "slice", "byte", "w", "col", "rows", "port", "id", "num", "line", "key", "feed", "cell", "max", "month", "offset", "rc", "ry", "zip", "win", "entry", "value", "ip", "index", "q", "block", "pos", "val"]}}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "static void sd_response_r1_make(SDState *sd,\n\n                                uint8_t *response, uint32_t last_status)\n\n{\n\n    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;\n\n    uint32_t status;\n\n\n\n    status = (sd->card_status & ~mask) | (last_status & mask);\n\n    sd->card_status &= ~CARD_STATUS_C | APP_CMD;\n\n\n\n    response[0] = (status >> 24) & 0xff;\n\n    response[1] = (status >> 16) & 0xff;\n\n    response[2] = (status >> 8) & 0xff;\n\n    response[3] = (status >> 0) & 0xff;\n\n}\n", "idx": 7556, "substitutes": {"sd": ["std", "sf", "od", "sy", "md", "bd", "vd", "s", "sg", "dd", "pd", "si", "data", "sn", "ad", "so", "db", "sk", "sam", "state", "d", "sl", "sm", "ss", "td", "sie", "sb", "se", "ds", "settings", "sv", "sa", "ld", "ind", "gd", "dl", "SD", "cd"], "response": ["position", "header", "http", "parent", "wave", "value", "update", "object", "data", "sync", "Response", "reply", "body", "image", "route", "sequence", "content", "version", "server", "description", "document", "service", "answer", "match", "error", "connection", "respons", "message", "json", "received", "application", "result", "array", "output", "respond", "settings", "request", "tree", "write", "resp", "model", "page", "api", "success", "site", "next", "index"], "last_status": ["last_state", " last_date", " last_state", "last_stat", "last_date", "last__stat", " last_stat", "last__date", "last__status", "last__state"], "status": ["stat", "login", "flag", "id", "complete", "s", "progress", "security", "session", "update", "date", "data", "sync", "style", "xml", "sex", "speed", "content", "state", "server", "stats", "version", "description", "active", "modified", "service", "match", "reason", "code", "sc", "error", "comment", "message", "full", "json", "received", "str", "score", "su", "result", "seq", "prefix", "source", "output", "settings", "stage", "request", "model", "Status", "success", "site", "index", "command", "summary", "msg"]}}
{"project": "qemu", "commit_id": "665414ad06aa1bc92e615db9641e58fb13d07de1", "target": 1, "func": "static int ram_block_enable_notify(const char *block_name, void *host_addr,\n\n                                   ram_addr_t offset, ram_addr_t length,\n\n                                   void *opaque)\n\n{\n\n    MigrationIncomingState *mis = opaque;\n\n    struct uffdio_register reg_struct;\n\n\n\n    reg_struct.range.start = (uintptr_t)host_addr;\n\n    reg_struct.range.len = length;\n\n    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\n\n    /* Now tell our userfault_fd that it's responsible for this area */\n\n    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {\n\n        error_report(\"%s userfault register: %s\", __func__, strerror(errno));\n\n\n\n\n\n\n\n\n\n    return 0;\n", "idx": 24771, "substitutes": {"block_name": ["blockfprefix", " block_address", "block_prefix", "blockfaddress", " block_size", "blockfsize", " block_prefix", "blockfname", "block_address", "block_size"], "host_addr": ["hostacoffset", "block_addr", "hostacaddress", "hostacaddr", "block_id", "hostacsize", "block_offset", "host_size", "host_address", "host_name", "host_id", "block_address", "hostbname", "block_size", "hostbaddress", "hostbaddr", "hostbid", "host_offset"], "offset": ["ref", "slice", "position", "data", "base", "style", "align", "pointer", "address", "prefix", "Offset", "error", "end", "start", "set", "loc", "parent", "order", "off", "origin", "addr", "entry", "limit", "index", "range", "pos", "len"], "length": ["build", "seq", "ength", "slice", "family", "section", "info", "position", "mount", "base", "style", "read", "delay", "filename", "address", "type", "duration", "port", "pad", "url", "depth", "line", "padding", "angle", "library", "sequence", "view", "shape", "level", "block", "Length", "count", "limit", "pull", "index", "match", "range", "l", "len"], "opaque": [" oprobe", "opprobe", "ospatile", " opaques", "opaques", "opatile", "opcos", "ospaque", "opusatile", " opatile", "opusmac", "opusaque", "ospcos", " opmac", "Opaque", " opcos", "Opaques", "oppaques", "ospmac", "opuscos", "oppaque", "opmac", "Opatile", "Oprobe", "oprobe", "oppatile"], "mis": ["abi", "sys", "oci", "iss", "scope", "oc", "m", "tis", "isi", "cci", "ms", "vis", "mi", "Mis", "bos", "mac", "rec", "mos", "is", "mes", "proc", "mic", "miss", "session", "mn", "os", "fi", "mc", "mas", "cas", "fs", "pas", "osi", "acs", "voc", "pc", "params"], "reg_struct": ["reg2const", "regacint", "mod_return", "mod_feat", "Reg_feat", " reg_addr", "reg_addr", "regacnat", " reg_string", "Reg_int", "reg_int", "reg2struct", "rec_config", "rec_struct", "mod_struct", " reg_nat", "Reg_nat", "reg_feat", "rec_const", "reg_config", "reg_string", " reg_feat", "rec_construct", "reg_Struct", "reg2config", "regacstruct", "regacfeat", "reg_const", "Reg_struct", "reg_return", "reg_ptr", "reg_construct", " reg_ptr", "mod_config", "reg_nat", "reg2construct", " reg_Struct"]}}
{"project": "FFmpeg", "commit_id": "6f3d2fb18bb6225c27e22a95846c42f2093dc3b7", "target": 0, "func": "static void end_last_frame(AVFilterContext *ctx)\n\n{\n\n    TileContext *tile    = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef *out_buf = outlink->out_buf;\n\n\n\n    outlink->out_buf = NULL;\n\n    ff_start_frame(outlink, out_buf);\n\n    while (tile->current < tile->nb_frames)\n\n        draw_blank_frame(ctx, out_buf);\n\n    ff_draw_slice(outlink, 0, out_buf->video->h, 1);\n\n    ff_end_frame(outlink);\n\n    tile->current = 0;\n\n}\n", "idx": 7649, "substitutes": {"ctx": ["cp", "cmp", "anc", "fw", "ci", "component", "config", "cus", "rc", "cca", "concept", "loc", "px", "cm", "tx", "sk", "client", "conv", "obj", "cc", "ctr", "cs", "cli", "sci", "kt", "conf", "ck", "sc", "cam", "cmd", "wcs", "bc", "cb", "exec", "Context", "cu", "context", "ctrl", "ca", "kb", "c", "ct", "cn", "cf", "tk", "lc", "fc", "cv", "vc", "src", "cas", "conn", "pkg", "xc", "tc"], "tile": ["tool", "cp", "lane", "tf", "layer", "chip", "phy", "rt", "coe", "component", "ci", "qt", "kick", "update", "pixel", "crop", "tto", "race", "slice", "module", "texture", "tu", "grid", "plate", "ace", "px", "tif", "so", "image", "Tile", "sk", "late", "grade", "cli", "ctr", "kt", "uri", "target", "oe", "zip", "file", "plane", "fit", "tm", "cu", "ski", "task", "coll", "context", "ne", "ie", "scale", "ptr", "frame", "oi", "txt", "thread", "tk", "cf", "ilo", "dt", "tt", "cache", "conn", "feature", "tc"], "outlink": ["outstyle", "uplike", "apploop", "outhide", "inlink", "outlinked", "outLink", "outline", "againlink", "upline", "againstyle", "outputstyle", "pointlock", "inLink", "offloop", "libstyle", "outputlink", "outerhide", "instyle", "outerloop", "inlinked", "applink", "outlock", "offlink", "offlinked", "appload", "uppath", "inloop", "pointline", "liblink", "pointLink", " outline", "offload", "outputlike", "inload", "outlike", "againload", "inlock", " outlinked", "libline", "liblinked", "outerload", "outputpath", "applinked", "againloop", " outload", " outlock", "againhide", " outloop", "againpath", "pointlink", "uploop", " outstyle", "againlike", "outloop", "uplink", "upstyle", " outLink", " outhide", "upload", "outerlink", "outload", "outpath"], "out_buf": ["outdbuf", "in_buf", "outFbuf", "outPuf", "out_cache", "outingbuff", " out_bag", "outAcbuff", "out2buffer", "out_buff", "outdbuffer", " out_block", "out_uf", "outfbuf", "outdqueue", " outPbuffer", "out2cb", "outfref", "in_buffer", "outingbuf", "outIPblock", "outFbag", "outFuf", "out2block", "out_ref", "out_queue", "outfqueue", "outAcbuffer", "outPbag", "in_queue", "outingcache", " outPbag", "outIPbuf", "outPbuf", "outIPbuff", "outdbuff", "out_bag", " out_buffer", " out_buff", "outAcbuf", "out_cb", "out_buffer", "outfbuffer", "out2buf", " out_cache", "in_buff", " outPuf", " outPbuf", "outingbuffer", " out_uf", "outPbuffer", "outFbuffer", "out_block", "out2buff", "in_cb", "outfbuff", "outAccache", "in_ref"]}}
{"project": "qemu", "commit_id": "fc6c9257c6dd47316a1c55d356bcd89bdc5fd642", "target": 0, "func": "void ip6_input(struct mbuf *m)\n\n{\n\n    struct ip6 *ip6;\n\n\n\n    DEBUG_CALL(\"ip6_input\");\n\n    DEBUG_ARG(\"m = %lx\", (long)m);\n\n    DEBUG_ARG(\"m_len = %d\", m->m_len);\n\n\n\n    if (m->m_len < sizeof(struct ip6)) {\n\n        goto bad;\n\n    }\n\n\n\n    ip6 = mtod(m, struct ip6 *);\n\n\n\n    if (ip6->ip_v != IP6VERSION) {\n\n        goto bad;\n\n    }\n\n\n\n    /* check ip_ttl for a correct ICMP reply */\n\n    if (ip6->ip_hl == 0) {\n\n        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,\"ttl\");*/\n\n        goto bad;\n\n    }\n\n\n\n    /*\n\n     * Switch out to protocol's input routine.\n\n     */\n\n    switch (ip6->ip_nh) {\n\n    case IPPROTO_TCP:\n\n        /*tcp_input(m, hlen, (struct socket *)NULL);*/\n\n        break;\n\n    case IPPROTO_UDP:\n\n        /*udp_input(m, hlen);*/\n\n        break;\n\n    case IPPROTO_ICMPV6:\n\n        icmp6_input(m);\n\n        break;\n\n    default:\n\n        m_free(m);\n\n    }\n\n    return;\n\nbad:\n\n    m_free(m);\n\n}\n", "idx": 7324, "substitutes": {"m": ["machine", "o", "dm", "v", "gm", "md", "a", "M", "b", "x", "data", "i", "bm", "mo", "module", "l", "f", "mn", "nm", "d", "sm", "mod", "u", "man", "em", "e", "mc", "mt", "hm", "w", "en", "an", "message", "t", "n", "tm", "mut", "mi", "me", "source", "p", "fm", "this", "h", "mr", "am", "c", "mm", "g", "ms", "im", "y", "um", "r", "cm", "mu"], "ip6": ["ip06", "ip613", "p6", "p06", " ip8", "mp36", "cp16", "upsix", "ip16", " ip3", "up612", "op76", " ip4", "ip4", "ip8", "cp616", "ip3", "IPsix", "IP3", "clip16", " ip06", "up76", "ipsix", "mp613", "op4", "IP8", "mop16", "clip6", " ip36", "p8", " ipape", "IP6", "ipape", "mpape", " ipse", "p16", " ip16", "op612", "mp8", "mp3", "ip76", "up6", "IP76", "mp6", "op6", "IPape", "clipsix", " ip616", "mpsix", "IP613", "ip616", "mopse", "ip36", "cp36", "mopsix", "clip613", "mp06", "op8", "IP612", "IP16", "opsix", "IPse", "cp6", "mp16", "mp616", " ipsix", "ip612", "mop6", "mp4", "ipse"]}}
{"project": "qemu", "commit_id": "7e39d3a2dd34a84900e10b4ea1567f3b352659af", "target": 1, "func": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,\n\n                          Error **errp)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n\n\n\n    /* Open the raw file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    /* Open the test file */\n\n    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options,\n\n                                   \"test\", bs, &child_format, false,\n\n                                   &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    ret = 0;\n\nfail:\n\n\n\n\n    qemu_opts_del(opts);\n\n    return ret;\n", "idx": 3279, "substitutes": {"bs": ["ob", "base", "js", "cs", "ctx", "ss", "ops", "rs", "ts", "sa", "qs", "sb", "bps", "lb", "BS", "ib", "aws", "bc", "ins", "pb", "cas", "bl", "bis", "rb", "plugins", "ls", "ses", "bits", "cb", "ds", "als", "bas", "ps", "gs", "ns", "css", "vs", "bi", "us", "bos", "es", "gb", "as", "bu", "bb", "iss", "fb", "b", "blocks", "os", "ks", "fs", "db", "obs", "ssl"], "options": ["base", "files", "null", "opens", "ops", "ts", "data", "ips", "eps", "global", "ions", "scope", "includes", "false", "op", "params", "none", "ls", "args", "details", "info", "Options", "file", "settings", "outs", "style", "offs", "config", "ps", "errors", "opt", "x", "p", "values", "e", "bos", "lines", "es", "steps", "other", "object", "public", "obj", "o", "lib", "optional", "os", "times", "io", "fs", "option"], "flags": ["files", "offset", "Flags", "ops", "bit", "lag", "vals", "ips", " flag", "comments", "bits", " Flags", "args", "file", "settings", "config", "errors", "flag", "features", "ints", "mask", "stats", "bytes", "fs", " bits", "FLAG", "parts"], "errp": ["errorf", "errorpre", " errtp", " errpi", "rrf", "ierf", "errtp", "errorb", "errorpc", "rorr", "errpc", "rorp", "cerpa", "errn", " errr", "cerp", "cern", "errortp", "ierpi", "errb", " errn", "rorpi", "arrp", "cerpi", "arrn", "errr", " errpa", " errpc", "errorp", "errpi", " errb", "rrb", "arrpi", "rorpa", "arrpa", " errpre", "rortp", "ierpa", " errf", "errorr", "rorf", "rrpre", "errf", "errpa", "errpre", "rorpc", "ierp", "rrp"], "s": ["base", "js", "cs", "ss", "ops", "ts", "sa", "sb", "n", "is", "sl", "ses", "ls", "sv", "ds", "utils", "ps", "gs", "ns", "c", "p", "state", "vs", "self", "f", "sys", "v", "b", "su", "S", "os", "session", "t", "states", "si", "https", "ssl"], "opts": ["catters", "OPts", "obcs", "opouts", "alments", "opt", "copcs", "opcs", "olts", "operouts", " opcs", "optps", "opls", "opty", "copters", "opte", "experps", " opttes", "optters", "experouts", "alps", "OPty", "olty", "olt", "opta", " opns", "opments", "opps", "opert", "optes", "olpt", "otta", "catcs", " opt", "experta", "operta", "optcs", " optg", "optments", " opments", "opttes", " optes", "alts", "obts", "catps", " optts", " opps", "optns", "optg", "otts", "operty", "optt", "otouts", "oppt", " opte", "catts", "OPpt", "OPt", "otps", "copts", " opls", " opg", "operpt", " optns", "obls", "experts", "optls", "opg", "optts", "opns", "obt", "alte", "operts", "opters", "copps", "optte", "operps"], "local_err": [" local_spec", "local___nor", "local64orr", " local_nor", "localpyerror", "global_init", "localedbug", "localederror", "local8init", "local_worker", "localpynor", "local64error", "local__err", "local67er", "local67erer", "local___error", "local__cry", "local67cry", "localpybug", "remote_er", " local_orr", "local_orr", " local_war", "remote_err", "localpystatus", " local_bug", " local_cb", "local_status", "global_err", "custom_error", "local_error", "local_cry", "localedwar", "remote_worker", "local_cb", " local_erer", "local__erer", "custom_gr", "local_er", "remote_error", "local_bug", "custom_er", "local_init", "local_war", "local__error", "localpyer", "local_spec", " local_cry", "local8status", "global_status", "local_msg", "local67worker", "local64cb", "localpyerr", "local_erer", "local___err", "custom_err", "local___bug", "local64err", " local_error", "localpyinit", " local_er", " local_msg", "local_gr", "local_nor", "local8err", "local67err", "localederr", "local67error", "local8er", "global_er"], "ret": ["match", "rot", "base", "arg", "fun", "mt", "ext", "def", "bit", "flat", " Ret", "success", "data", "get", "alt", "cat", "id", "wait", "rets", "fit", "pet", "pass", " RET", "rep", "lt", "ft", "nt", "rev", "str", "back", "ber", "Ret", "feat", "bf", "pat", "sat", "opt", "result", "reply", "bot", "rc", "et", "ut", "len", "flag", "ref", "gt", "art", "RET", "final", "t", "req", "valid", "lit", "reg", "let", "val", "rt", "re", "part", "run", "det", "res", "bad"]}}
{"project": "qemu", "commit_id": "372579427a5040a26dfee78464b50e2bdf27ef26", "target": 1, "func": "int cpu_exec(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int ret;\n\n    SyncClocks sc;\n\n\n\n    /* replay_interrupt may need current_cpu */\n\n    current_cpu = cpu;\n\n\n\n    if (cpu_handle_halt(cpu)) {\n\n        return EXCP_HALTED;\n\n    }\n\n\n\n    rcu_read_lock();\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    if (sigsetjmp(cpu->jmp_env, 0) != 0) {\n\n#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)\n\n        /* Some compilers wrongly smash all local variables after\n\n         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.\n\n         * Reload essential local variables here for those compilers.\n\n         * Newer versions of gcc would complain about this code (-Wclobbered). */\n\n        cpu = current_cpu;\n\n        cc = CPU_GET_CLASS(cpu);\n\n#else /* buggy compiler */\n\n        /* Assert that the compiler does not smash local variables. */\n\n        g_assert(cpu == current_cpu);\n\n        g_assert(cc == CPU_GET_CLASS(cpu));\n\n#endif /* buggy compiler */\n\n        cpu->can_do_io = 1;\n\n        tb_lock_reset();\n\n        if (qemu_mutex_iothread_locked()) {\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n    }\n\n\n\n    /* if an exception is pending, we execute it here */\n\n    while (!cpu_handle_exception(cpu, &ret)) {\n\n        TranslationBlock *last_tb = NULL;\n\n        int tb_exit = 0;\n\n\n\n        while (!cpu_handle_interrupt(cpu, &last_tb)) {\n\n            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);\n\n            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);\n\n            /* Try to align the host and virtual clocks\n\n               if the guest is in advance */\n\n            align_clocks(&sc, cpu);\n\n        }\n\n    }\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n    rcu_read_unlock();\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n\n\n    return ret;\n\n}\n", "idx": 539, "substitutes": {"cpu": ["ilo", "cli", "roc", "gc", "process", "current", "lb", "clock", "nc", "px", "CPU", "cu", "css", "linux", "cp", "uu", " proc", "consumer", "gru", " cp", "bc", "cci", "nic", "frame", "mac", "fp", "pkg", "cow", "lc", "core", "fc", "cm", "ctx", "cpp", "computer", "ck", "prof", "boot", "proc", "cb", "pid", "c", "xc", "pu", "loader", "cache", " pc", "chip", "processor", "node", "cf", "uca", "net", "performance", "uc", "null", "vm", "server", "gpu", "intel", "hw", "conn", "uci", "tc", "platform", "fps", "comp", "auc", "none", "config", "bench", "dc", "cn", "ctrl", "pc", "cmp", " CPU", "sta", "ci", "console", "rc"], "cc": ["PC", "fc", "cm", " gcc", "cs", "ctx", "conn", "gc", "LC", "mc", "cl", "uc", "class", "ck", "co", "bc", "cci", "con", "tc", "client", "VC", "code", "cb", "cod", "ec", "dc", "ce", "cu", "c", "css", "xc", "cn", "cache", "ctrl", "core", "ca", "cca", "pc", "cp", "cmp", "ucc", "cf", "ci", "CC", "acc", "rc"], "ret": ["match", "nz", "test", "arg", "fun", "buffer", "rs", "gc", " Ret", "success", "data", "get", "alt", "job", "cur", "ry", "pet", "rets", "ben", "num", "rf", "pass", " RET", "rep", "scan", "nt", "back", "reply", "Ret", "result", "len", "reset", "ref", "sys", "ctr", "resp", "value", "sec", "en", "pc", "RET", "hard", "valid", "re", "reg", "val", "addr", "al", "fi", "det", "res", "mem"], "sc": ["fc", "sac", "src", "cs", "isc", "ss", "esc", "rs", "spec", "osc", "sb", "mc", "cl", "access", " SC", "ct", "RC", "bc", "sp", "sh", "scope", "tc", "sk", "loop", "comp", "ac", "cr", "SC", "config", "ec", "asc", "dc", "c", "sw", "cv", "lc", "soc", "sq", "ca", "core", "exec", "sys", "sr", "pc", " scr", "Sc", "si", "sci", "ctl", " Sc", "uc", "acc", " rc", "rc", " ss"], "last_tb": ["last_tyb", "last_nbl", "last_tabb", "last_Tbase", "last_interub", "last_ctabb", "last_tbs", "last_ctp", "last_torbase", "last_ptub", "last_torb", "last_Tb", "last_Tlb", "last_interf", "last_Tbl", "last_torbi", "last_nlb", "last_interk", "last_Tub", "last_pbs", "last_tbase", "last_ptk", "last_Tbi", "last_Tf", "last_pbi", "last_tyabb", "last_tp", "last_interb", "last_pbase", "last_Tbs", "last_nbs", "last_ptbs", "last_tybs", "last_tub", "last_tf", "last_torbs", "last_tbl", "last_ptlb", "last_typ", "last_ctb", "last_ctbs", "last_tbi", "last_pb", "last_Tp", "last_Tabb", "last_ptb", "last_ptf", "last_Tk", "last_nb", "last_tk", "last_tlb", "last_ptbl"], "tb": ["tbb", "rtbs", " tr", " tbb", "tsb", "ttb", "ttbs", "rtr", "tk", "ptb", "tbs", " tbi", "ttbb", "ptk", "tr", "tsr", "tsbi", "ptbs", "ptr", "ttr", "ttbi", "tsbb", "rtk", "rtb", "ttk", "tbi"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2,\n\n\t\t\tuint8_t *dst1, uint8_t *dst2,\n\n\t\t\tlong width, long height,\n\n\t\t\tlong srcStride1, long srcStride2,\n\n\t\t\tlong dstStride1, long dstStride2)\n\n{\n\n    long y,x,w,h;\n\n    w=width/2; h=height/2;\n\n#ifdef HAVE_MMX\n\n    asm volatile(\n\n\tPREFETCH\" %0\\n\\t\"\n\n\tPREFETCH\" %1\\n\\t\"\n\n\t::\"m\"(*(src1+srcStride1)),\"m\"(*(src2+srcStride2)):\"memory\");\n\n#endif\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s1=src1+srcStride1*(y>>1);\n\n\tuint8_t* d=dst1+dstStride1*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s1[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s1[x];\n\n    }\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s2=src2+srcStride2*(y>>1);\n\n\tuint8_t* d=dst2+dstStride2*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s2[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s2[x];\n\n    }\n\n#ifdef HAVE_MMX\n\n\tasm(\n\n\t\tEMMS\" \\n\\t\"\n\n\t\tSFENCE\" \\n\\t\"\n\n\t\t::: \"memory\"\n\n\t\t);\n\n#endif\n\n}\n", "idx": 13068, "substitutes": {"src1": [" src0", "supp2", "rc2", "source3", "rc0", "rcFirst", "source2", "sourceOne", "source1", " srcOne", "source0", "suppOne", "src3", "rcOne", "rc3", "suppFirst", "src0", " srcFirst", "rc1", " src3", "srcOne", "supp1", "srcFirst"], "src2": [" src0", "source8", "sur20", "rc2", "rc0", "source2", " src8", "source1", " src4", "source0", "src4", "sourceB", "sb1", "sur2", "sur0", "sb20", "rc4", "rc20", "sb2", "src0", "rc8", "source4", "sb0", "src20", "srcB", "sur1", "rc1", " srcB", "src8", "rcB"], "dst1": ["drest2", "dsc3", "Dst2", "adst3", "adsts2", "adstsOne", "dsp1", "Dst01", "dst3", "dsc2", "adst1", "dscOne", "Dsc1", "dst01", "dsp3", "drest001", "adst2", "dstsOne", "dsc1", "adsts3", "Dsc2", "drc01", "dsts2", "Dst1", "dstOne", "drest1", "dst001", "dsc01", "adsts1", "dsts3", "drc2", "dsp2", "drc1", "dsts1", "drest01", "adstOne", "dspOne", "Dsc01", "dsc001", "drc001", "Dst001", "Dsc001"], "dst2": [" dsp0", "dste1", "dspTwo", "ddest02", "dsc62", "dst02", " dsp2", "sst2", "dsp1", "drc0", "dste02", "dsc2", " dspTwo", "sdest62", "dsc02", "dscTwo", "dst62", "sdest02", "dste62", "sdest1", " dsp1", "dst0", "dstTwo", "dsc1", " dstTwo", "sdest2", "sst62", "drcTwo", "ddest62", "ddest1", "sst1", "dste2", "dsp0", "drc2", "drc1", "dsp2", "dsc0", "sst02", "ddest2", " dst0"], "height": ["head", "Height", "build", "thin", "density", "shape", "style", "image", "crop", "size", "pad", "img", "direction", "length", "th", "padding", "resolution", "gravity", "inches", "ph", "ht", "wa", "hold", "angle", "sh", "layout", "hd", "window", "ty", "dim", "depth"], "srcStride1": ["srcstride2", "srcstide1", "srcStride0", "srcStrite1", "srcScriteOne", "srcStri01", "srcScrite1", "srcStrideOne", "srcStrub2", "srcStrip2", "srcStride3", "srcStrub1", "srcStri2", "srcstideOne", "srcStide3", "srcScrideOne", "srcStrite11", "srcStrub11", "srcStrubOne", "srcstide0", "srcScrite11", "srcstide01", "srcStrite3", "srcstride3", "srcstide2", "srcstride01", "srcstride1", "srcStri0", "srcStide01", "srcStride11", "srcStrue3", "srcStrue2", "srcStrip1", "srcStrue1", "srcScride11", "srcScride2", "srcstide3", "srcStrite2", "srcStrueOne", "srcStri1", "srcStide1", "srcScrite2", "srcStide2", "srcStrip0", "srcStideOne", "srcStide0", "srcStriteOne", "srcScride1", "srcStrip01", "srcstrideOne", "srcStrue11", "srcStride01", "srcstride0"], "srcStride2": ["srcScride4", "srcShide3", "srcShide2", "srcStrb4", "srcStride0", "srcShride1", "srcStrite1", "srcScrite1", "srcScrite0", "srcStrue4", "srcStrite4", "srcStrip2", "srcStride3", "srcStrb1", "srcStide3", "srcScrite4", "srcShride3", "srcStide8", "srcStrip4", "srcScride0", "srcStrb0", "srcStrite8", "srcShride4", "srcStrite3", "srcShide1", "srcSterve2", "srcStrue3", "srcStride8", "srcStrue2", "srcStrue1", "srcStrip1", "srcStrite0", "srcScride2", "srcStrite2", "srcSterve4", "srcSterve8", "srcStrb2", "srcStide1", "srcScrite2", "srcStide4", "srcStide2", "srcStrip0", "srcStride4", "srcSterve1", "srcScride1", "srcShride2", "srcShide4"], "dstStride1": ["dstStride4", "dstStrite1", "dstScride1", "dstStro1", "dstStrip8", "dstStrip3", "dstStro01", "dstStro4", "dstStrideX", "dstStride8", "dstScrideX", "dstStrite01", "dstStro3", "dstStro8", "dstStride01", "dstScriteX", "dstScrite1", "dstStrip2", "dstStriteX", "dstStgrade1", "dstStgrade4", "dstStrite2", "dstScride4", "dstStrip1", "dstStro2", "dstScrite01", "dstStgrade01", "dstScride01", "dstStgradeX", "dstStrite4", "dstStroX", "dstStrite8", "dstScrite4", "dstStride3", "dstStrite3"], "dstStride2": ["dstStride4", "dstStrideTwo", "dstStrid4", "dstStriteTwo", "dststrTwo", "dstStgrade\n", "dststrideTwo", "dstStrTwo", "dststr52", "dstStridTwo", "dstStrite2", "dstStrip\n", "dstStr4", "dststride4", "dstStr52", "dstStride52", "dststr4", "dstStr2", "dststride2", "dstStrite4", "dstStride\n", "dstStrid52", "dstSterve\n", "dstStrid2", "dstResterve\n", "dstRestride\n", "dststr2", "dststride52", "dstStrite52"], "y": ["ny", "yt", "m", "hy", "ys", "t", "sky", "id", "l", "i", "lon", "iy", "a", "io", "name", "ey", "yd", "py", "gy", "cy", "by", "ym", "ye", "v", "key", "o", "dy", "yi", "z", "yl", "ady", "p", "e", "u", "yr", "uy", "b", "yo", "j", "n", "f", "yn", "oy", "c", "vy", "ay", "ry", "type", "year", "Y", "ya", "ky", "xy", "yy", "wy", "zy", "ty", "sy"], "x": ["m", "tx", "t", "on", "xi", "id", "l", "i", "code", "ww", "any", "my", "name", "ex", "g", "wx", "fx", "sw", "event", "image", "xt", "xp", "full", "px", "v", "key", "ct", "win", "yx", "dx", "view", "z", "u", "ady", "p", "e", "s", "time", "rx", "wait", "b", "ix", "j", "n", "f", "cross", "xx", "ax", "c", "xs", "pe", "xes", "X", "sex", "wa", "q", "r", "lex", "host", "xc", "xy", "work", "pos", "index", "php"], "w": ["m", "wh", "t", "iw", "l", "i", "ww", "ew", "g", "weight", "wx", "sw", "wt", "v", "wn", "win", "z", "p", "e", "s", "aw", "max", "b", "wb", "n", "wp", "c", "W", "tw", "ow", "wa", "r", "wall", "we", "hw", "wy", "window", "wd", "fw"], "h": ["hi", "m", "ch", "en", "t", "l", "i", "ww", "g", "hs", "gh", "v", "rh", "uh", "z", "p", "s", "k", "b", "j", "n", "f", "th", "hm", "c", "W", "ht", "wa", "q", "H", "sh", "high", "ph"], "s1": ["saOne", "ps8", "sa1", "ses5", "ns1", "s8", "ps2", "ps1", "dsOne", "cs2", " s5", "csX", "sesX", "sesone", "saone", "ses8", "s91", "ns91", "ses1", "s5", " s8", "dsone", "ds91", "nsOne", " sX", "sX", "cs1", "sone", "ds1", "sOne", "nsone", "psone", "sa91", "cs5", "ses2", " sone"], "d": ["D", "dh", "m", "done", "fd", "t", "l", "id", "i", "ded", "da", "bd", "g", "dl", "di", "ld", "ct", "v", "del", "o", "dy", "cd", "ad", "z", "p", "e", "s", "du", "data", "sd", "did", "b", "j", "n", "f", "dat", "c", "dt", "dc", "md", "q", "r", "ds", "dd", "db", "dr", "dim", "dos"], "s2": ["p2", " s92", "s8", " s8", "p8", "p92", "sync92", "p1", "sync8", "sync2", "sync1", "s92"]}}
{"project": "FFmpeg", "commit_id": "8f4020d8a4b2e6264f54accbcb881577316c3ca6", "target": 0, "func": "static int svq1_decode_frame_header(GetBitContext *bitbuf, MpegEncContext *s)\n\n{\n\n    int frame_size_code;\n\n\n\n    skip_bits(bitbuf, 8); /* temporal_reference */\n\n\n\n    /* frame type */\n\n    s->pict_type = get_bits(bitbuf, 2) + 1;\n\n    if (s->pict_type == 4)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        /* unknown fields */\n\n        if (s->f_code == 0x50 || s->f_code == 0x60) {\n\n            int csum = get_bits(bitbuf, 16);\n\n\n\n            csum = ff_svq1_packet_checksum(bitbuf->buffer,\n\n                                           bitbuf->size_in_bits >> 3,\n\n                                           csum);\n\n\n\n            av_dlog(s->avctx, \"%s checksum (%02x) for packet data\\n\",\n\n                    (csum == 0) ? \"correct\" : \"incorrect\", csum);\n\n        }\n\n\n\n        if ((s->f_code ^ 0x10) >= 0x50) {\n\n            uint8_t msg[256];\n\n\n\n            svq1_parse_string(bitbuf, msg);\n\n\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"embedded message: \\\"%s\\\"\\n\", (char *)msg);\n\n        }\n\n\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits1(bitbuf);\n\n\n\n        /* load frame size */\n\n        frame_size_code = get_bits(bitbuf, 3);\n\n\n\n        if (frame_size_code == 7) {\n\n            /* load width, height (12 bits each) */\n\n            s->width  = get_bits(bitbuf, 12);\n\n            s->height = get_bits(bitbuf, 12);\n\n\n\n            if (!s->width || !s->height)\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            /* get width, height from table */\n\n            s->width  = ff_svq1_frame_size_table[frame_size_code].width;\n\n            s->height = ff_svq1_frame_size_table[frame_size_code].height;\n\n        }\n\n    }\n\n\n\n    /* unknown fields */\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);    /* use packet checksum if (1) */\n\n        skip_bits1(bitbuf);    /* component checksums after image data if (1) */\n\n\n\n        if (get_bits(bitbuf, 2) != 0)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 4);\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 2);\n\n\n\n        while (get_bits1(bitbuf) == 1)\n\n            skip_bits(bitbuf, 8);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19654, "substitutes": {"bitbuf": ["bitvec", "bugctx", "loguf", "logbuf", "bonbox", "bugbuff", "bituf", "Bitbuffer", "bootvec", "lockbuff", "loaduf", "catcb", "Bitcb", "bugbuf", "bytebuff", "bonbag", "bonbuff", "bugbuffer", "bincb", "lockuf", "banduf", "bitsuf", "bitsbuf", "catbuff", "bitscb", "lockbuffer", "Bitbuf", "itbuffer", "bitsbag", "bonbuf", "logbuff", "bugcb", "bonbatch", "bytebuffer", "bitsbuff", "bitbox", "bootbuf", "bitbatch", " bitcb", " bitbuffer", "bootbatch", "loadbox", "itbuf", "bandbatch", "bandbuff", " bitbuff", "catbuf", "binbuffer", "bootcb", "bootuf", "bitctx", "bootbuffer", "logctx", "binbuff", "bitbuffer", "bitbag", "lockbuf", "bitbuff", "binbuf", "bonvec", "itbuff", "catuf", "bitsboard", "buguf", "bugboard", "binuf", "loadbuff", "bonuf", "loadbuf", "ituf", "bootbox", "Bitbuff", "loadcb", "bitboard", "bootctx", "bugbag", "bitcb", "bootbuff", "loadbuffer", "bitsbuffer", "bytebuf", "bytecb", "bytevec", " bituf", "bandbuf", "byteuf", "bonboard"], "s": ["ns", "spec", "words", "service", "details", "ss", "cons", "cs", "d", "new", "qs", "sym", "p", "ks", "h", "sets", "comments", "m", "ts", "sg", "rs", "aws", "sim", "manager", "self", "o", "su", "sc", "si", "S", "ds", "uns", "f", "r", "sb", "l", "ins", "w", "bis", "sync", "c", "ps", "b", "sys", "your", "es", "states", "sq", "sf", "session", "stats", "t", "conf", "services", "n", "g", "i", "sl", "ls", "fs", "xs", "is", "e", "ssl", "ses", "js", "http", "gs", "its", "os", "se", "y", "u"], "frame_size_code": ["frame_sizexcount", "frame_sizexcode", "frame_shape_code", "frame_sizevalcoded", "frame_genderfulllevel", "frame_scale_const", "frame_scale_code", "frame_shape_32", "frame_sizefullcoded", "frame_scale_str", "frame_sizeingcode", "frame_size_length", "frame_genderfullcoded", "frame_scale_count", "frame_size_coded", "frame_size_const", "frame_sizefullvalue", "frame_size_id", "frame_sizeingstr", "frame_shape_length", "frame_size_level", "frame_sizefulllevel", "frame_sizexnumber", "frame_size_str", "frame_size_cycle", "frame_gender_code", "frame_gender_coded", "frame_gender_value", "frame_sizeingcount", "frame_sizeingnumber", "frame_size_codes", "frame_sizevalcode", "frame_size_32", "frame_sizefullcode", "frame_size_number", "frame_sizexstr", "frame_gender_level", "frame_size_count", "frame_sizevalvalue", "frame_genderfullcode", "frame_shape_count", "frame_genderfullvalue", "frame_scale_codes", "frame_scale_cycle", "frame_sizevallevel", "frame_scale_id", "frame_scale_number", "frame_size_value"], "msg": ["ms", "html", "m", "gram", "sg", "og", "code", "data", "text", "err", "op", "md", "debug", "essage", "str", "g", "i", "comm", "type", "bc", "node", "mess", "orig", "raw", "loc", "byte", "arg", "enc", "nm", "empty", "header", "args", "asm", "ag", "req", "Msg", "seq", "cmd", "sym", "doc", "b", "gen", "gs", "error", "alloc", "bytes", "message", "mt", "frame", "desc"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static av_always_inline void rv40_strong_loop_filter(uint8_t *src,\n\n                                                     const int step,\n\n                                                     const int stride,\n\n                                                     const int alpha,\n\n                                                     const int lims,\n\n                                                     const int dmode,\n\n                                                     const int chroma)\n\n{\n\n    int i;\n\n\n\n    for(i = 0; i < 4; i++, src += stride){\n\n        int sflag, p0, q0, p1, q1;\n\n        int t = src[0*step] - src[-1*step];\n\n\n\n        if (!t)\n\n            continue;\n\n\n\n        sflag = (alpha * FFABS(t)) >> 7;\n\n        if (sflag > 1)\n\n            continue;\n\n\n\n        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +\n\n              26*src[ 0*step] + 25*src[ 1*step] +\n\n              rv40_dither_l[dmode + i]) >> 7;\n\n\n\n        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +\n\n              26*src[ 1*step] + 25*src[ 2*step] +\n\n              rv40_dither_r[dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p0 = av_clip(p0, src[-1*step] - lims, src[-1*step] + lims);\n\n            q0 = av_clip(q0, src[ 0*step] - lims, src[ 0*step] + lims);\n\n        }\n\n\n\n        p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 +\n\n              25*src[ 0*step] + rv40_dither_l[dmode + i]) >> 7;\n\n        q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] +\n\n              25*src[ 3*step] + rv40_dither_r[dmode + i]) >> 7;\n\n\n\n        if (sflag) {\n\n            p1 = av_clip(p1, src[-2*step] - lims, src[-2*step] + lims);\n\n            q1 = av_clip(q1, src[ 1*step] - lims, src[ 1*step] + lims);\n\n        }\n\n\n\n        src[-2*step] = p1;\n\n        src[-1*step] = p0;\n\n        src[ 0*step] = q0;\n\n        src[ 1*step] = q1;\n\n\n\n        if(!chroma){\n\n            src[-3*step] = (25*src[-1*step] + 26*src[-2*step] +\n\n                            51*src[-3*step] + 26*src[-4*step] + 64) >> 7;\n\n            src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] +\n\n                            51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7;\n\n        }\n\n    }\n\n}\n", "idx": 2115, "substitutes": {"src": ["reflect", "sub", "rest", "go", "upp", "url", "sites", "sl", "expl", "reach", "secure", "asc", "control", "ind", "shift", "cv", "connect", "btn", "scl", "sys", "sc", "u", "scripts", "upload", "aug", "hl", "obl", "start", "pack", "sup", "stat", "spec", "sb", "host", "filename", "ui", "bc", "iu", "gz", "gn", "sit", "length", "text", "integ", "agg", "sr", "lib", "iv", "transform", "sci", "rect", "input", "ssl", "build", "chrom", "loc", "use", "proc", "cb", "slice", "cont", "feat", "st", "sel", "usr", "c", "size", "attr", "stream", "sec", "rss", "gl", "inst", "sur", "supp", "conv", "req", "img", "low", "uc", "https", "stage", "http", "cur", "swing", "grad", "num", "seed", "comp", "rb", "dest", "sync", "source", "config", "scenes", "impl", "stack", "uv", "gb", "bg", "b", "cmp", "sort", "support", "view", "dist", "rc"], "step": ["route", "walk", "lock", "key", "dim", "ct", "weight", "trial", "stroke", "wait", "next", "move", "ste", "direction", "push", "index", "pointer", "progress", "x", "change", "shift", "set", "seq", "action", "sleep", "stop", "path", "start", "option", "flow", "group", "name", "split", "form", "type", "id", "frame", "gap", "pass", "batch", "dash", "length", "repeat", "patch", "amp", "scale", "session", "transform", "load", "input", "layer", "version", "trace", "offset", "mod", "drop", "page", "shock", "boot", "loop", "space", "slice", "back", "pad", "beta", "order", "steps", "sec", "phase", "mix", "Step", "run", "mode", "shape", "stage", "match", "test", "delay", "class", "d", "prop", "grad", "seed", "sync", "style", "config", "ip", "draw", "STEP", "depth", "part", "transfer"], "stride": ["collides", "strided", "stide", "ocriding", "strides", "ocrider", "erriding", "errider", "ocride", "Strided", "strider", "stides", "erride", "STRade", "collided", "stIDE", "StrIDE", "STRider", "STRiding", "Stride", "collide", "stided", "strade", "STRide", "ocrade", "errade", "collIDE", "strIDE", "striding", "Strides"], "alpha": ["rot", "xa", "linear", "A", "\u03b1", "lambda", "da", "offset", "pha", "sa", "a", "acl", "audio", "Alpha", "aa", "ma", "appa", "ta", "ac", "filter", "asc", "beta", "phi", "sc", "la", "amp", "sha", "phase", "scale", "igma", "af", "inc", "acc", "si", "rc"], "lims": ["limi", "limits", "lams", "imes", "milps", "Lims", "volgs", " Lims", " limes", "lamcs", "pls", "lamp", "Limits", "lifgs", "limp", "plps", "milp", " limits", "ligs", "limes", "ims", "imps", "lifits", "milcs", "limgs", " limi", "lifs", " Limits", " limgs", " limp", "Limgs", "Limports", "liggs", "limports", "ples", "volports", "dirports", " Limports", "dirits", "dirs", "lamps", "velgs", "mils", "ligports", " limports", "vols", "velits", " limps", "pli", "limps", "limcs", " limcs", "imi", "vels"], "dmode": ["dtool", "rdmode", "gmem", "pmodule", "madtone", "pmode", "dmem", "sdphase", "dmodule", " dmodule", "dapter", "sdlane", "pdtone", "dtone", "vdguide", "ldmode", "sdmodule", "rdmodule", "rdphase", "rmode", "pdmode", "madapter", "rdlane", "madmode", " dMode", "ldMode", "dguide", "rmodule", "dlane", "rtool", "sdtone", "rdmem", "vdmode", "dloop", "sdapter", "pdmodule", "pdMode", " dloop", "pdapter", "gmode", "madloop", "pguide", "gmodule", "dMode", "rguide", "ptool", "ldloop", "vdmodule", "sdmode", "pdloop", "sdloop", "glane", "rphase", "gphase", "dphase", "vdtool", "rmem", "ldmodule"], "chroma": ["chromac", "alphac", "normac", "alphama", "norma", "chrona", "chronac", "alphsa", "normsa", "chromama", "chronama", "chronsa", "chromsa", "normama"], "i": ["cli", "yi", "ami", "li", "gi", "ni", "ii", "zi", "chi", "ei", "ui", "pi", "r", "d", "I", "n", "di", "is", "id", "mi", "it", "iu", "k", "im", "j", "m", "eni", "info", "ti", "ini", "index", "multi", "ai", "ie", "x", "ip", "c", "p", "l", "bi", "phi", "e", "hi", "f", "u", "ori", "o", "v", "qi", "b", "t", "ix", "ik", "uri", "ci", "io", "si", "xi"], "sflag": ["osflag", "silag", " sfun", "psflag", "Scount", "cfun", "tret", "Sflag", "nflag", " sret", "siflags", "psstatus", "pquad", "scount", "plag", "siquad", "squad", " slag", "osret", "tsflag", "sforce", "secondarykill", "osforge", "secondaryflag", "cforce", "siflag", "nlag", "secondaryforge", " squad", "cflag", "slag", "sflags", "sforge", "tsstatus", "sfun", "cret", "tsfd", "pslen", " sflags", "pflags", " slen", "oskill", "skill", "tfun", " skill", "secondaryret", " sfd", "tforce", "ncount", "tslen", " sforge", "sfd", "sret", " sforce", "sstatus", "psfd", "slen", " sstatus", "pflag", "nflags", "tflag", "Slag", "Sflags"], "p0": ["q050", "P0", "p6", " p6", "pok", "p5", "f1", "ap0", "a0", "g93", "P1", "a00", "p050", "pt1", "g1", "pt050", "q00", " p00", "p00", "qfrom", "pr0", "g5", "pt0", "f2", "apfrom", "P2", "pnn", "prok", "ptfrom", "ap050", "q2", "p50", "ip0", "a2", "t0", "t50", "pfrom", "prnn", "ip1", "pr50", "f6", "ip5", " p2", "f0", "g0", "q93", "tok", " pnn", "a1", "p2", " pok", "ap1", "q5", " p50", "P6", "ip93", "tnn", "p93"], "q0": [" q00", "qt0", "qa180", "sq6", "p100", "dq00", "v80", "sqkn", " qkn", "p80", "dq8", "q00", "qa100", "y0", "qfrom", "p00", " qfrom", "sq0", "qtkn", "Q00", "y90", "dq90", "q6", "Q80", "sq3", " q3", "qu1", "q3", "sq90", "y00", "qkn", "y8", "q48", "sqfrom", "qu00", "q90", "Q1", "sq00", "q8", "qufrom", "qu0", "q100", "q80", "qa0", "q180", "p180", "qt3", "v1", "v00", "qu48", "v0", "dq0", "qt6", "sq48", "Q0", "qa1", "qu180", "qu100", " q48", " q6", "sq8"], "p1": ["qOne", "s0", "pone", "hinstance", "u0", "s1", "pgOne", "sp1", "qn", "pn", "pOne", "sone", "qone", "spOne", "spone", "pinstance", "uOne", "pg1", "pginstance", "cOne", " pOne", "ip0", "pg0", " pn", "sOne", "uone", "c1", "ipn", "ip1", "u1", "qa0", "hOne", "h1", "c0", "h0", "qainstance", "ipOne", "qa1", "qaOne", "sp0", "cone"], "q1": ["sqone", "k9", "pone", "dqone", "sq9", "sq1", "sq0", "qone", "p81", " qone", "kone", "p9", "q81", "dq1", " q81", "dq81", "dq0", "q9", "k0", "k1"]}}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "void qmp_transaction(TransactionActionList *dev_list, Error **errp)\n\n{\n\n    TransactionActionList *dev_entry = dev_list;\n\n    BlkTransactionState *state, *next;\n\n    Error *local_err = NULL;\n\n\n\n    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;\n\n    QSIMPLEQ_INIT(&snap_bdrv_states);\n\n\n\n    /* drain all i/o before any operations */\n\n    bdrv_drain_all();\n\n\n\n    /* We don't do anything in this loop that commits us to the operations */\n\n    while (NULL != dev_entry) {\n\n        TransactionAction *dev_info = NULL;\n\n        const BdrvActionOps *ops;\n\n\n\n        dev_info = dev_entry->value;\n\n        dev_entry = dev_entry->next;\n\n\n\n        assert(dev_info->kind < ARRAY_SIZE(actions));\n\n\n\n        ops = &actions[dev_info->kind];\n\n        assert(ops->instance_size > 0);\n\n\n\n        state = g_malloc0(ops->instance_size);\n\n        state->ops = ops;\n\n        state->action = dev_info;\n\n        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);\n\n\n\n        state->ops->prepare(state, &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto delete_and_fail;\n\n        }\n\n    }\n\n\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->commit) {\n\n            state->ops->commit(state);\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    goto exit;\n\n\n\ndelete_and_fail:\n\n    /* failure, and it is all-or-none; roll back all operations */\n\n    QSIMPLEQ_FOREACH(state, &snap_bdrv_states, entry) {\n\n        if (state->ops->abort) {\n\n            state->ops->abort(state);\n\n        }\n\n    }\n\nexit:\n\n    QSIMPLEQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {\n\n        if (state->ops->clean) {\n\n            state->ops->clean(state);\n\n        }\n\n        g_free(state);\n\n    }\n\n}\n", "idx": 9943, "substitutes": {"dev_list": ["ev_list", " dev_cont", "ev_entry", "dev__list", "dev__cont", "dev_code", "devayentry", "devaylist", "dev__entry", "devaycode", "dev_cont", "ev_code", "ev_cont", "dev__info", "devaycont"], "errp": ["erp", "rrpy", "errorlp", "rrlp", "errorpe", "errpe", "errpy", "errps", "errorpy", "errtp", "ierpe", "errorp", "rrp", " errtp", "ierpy", "ierp", "err", "errlp", "errortp", "erps", " errps", "ierlp", "rrpe", "errorps", " errr", "ertp", "errr", "errorr"], "dev_entry": ["demFentry", "demFalias", " dev_element", "demFevent", " dev_ry", "der_entry", "dev_ry", "dem_event", "dev_event", "dev5entry", "devamentry", "devFevent", "devamEntry", "dev_parse", " dev_enter", "dev_iterator", "dev_element", "dev5list", "demFlist", " dev_parse", "devFlist", "dev_alias", "der_element", "deramelement", "deramentry", "der_Entry", "devamelement", "dev_Entry", "dev5event", "dev5alias", "devFentry", "dev_enter", "deramEntry", "devFalias", "dem_entry", " dev_iterator", "dem_list", "dem_alias"], "state": ["parent", "session", "m", "point", "tag", "config", "set", "feed", "step", "er", "ie", "st", "code", "none", "call", "body", "al", "connection", "cur", "err", "port", "patch", "now", "grade", "form", "self", "type", "seed", "key", "view", "all", "id", "go", "k", "instance", "post", "rule", "s", "se", "e", "or", "op", "j", "slice", "scope", "module", "ner", "r", "load", "error", "root", "this", "back", "down", "State", "str", "g", "test", "class", "statement", "conn", "game", "public", "stat", "data", "head", "local", "action", "STATE", "style", "os", "entry", "resource", "o", "size", "sync", "order", "trans", "part", "oper", "node", "message", "use", "cache", "core", "start", "ry", "comment", "info", "update", "p", "run", "obj", "private", "manager", "child", "parse", "name", "event", "states", "inner", "user", "address", "out", "print"], "next": ["parent", "vious", "seq", "start", "owner", "again", "key", "second", "open", "path", "post", "last", "other", "data", "head", "prev", "iterator", "close", "set", "action", "off", "step", "sequence", "sec", "entry", "code", "child", "name", "response", "current", "ner", "future", "end", "done", "new", "first", "now", "after", "error", "front", "Next", "link", "self", "cycle", "loop", "back", "proc", "gen", "forward", "success", "chain"], "local_err": ["remote_error", "foreign___err", " local_req", "local_iter", "foreign_order", "remote_err", "local_cry", "foreign___notice", " local_cry", " local_error", "local_error", "local_req", "local___er", " local_iter", "foreign___order", "local_notice", "local___order", "local_order", "local___err", "foreign_err", "foreign_er", "local___notice", "foreign___er", "local_er", "remote_er", "foreign_notice"], "dev_info": ["ev_entry", "ev_Info", " dev_inf", "ev_family", "devjid", "devjinfo", " dev_next", "devlicinfo", "dev_id", "devenspec", "dev__id", "dev_inf", "devacinfo", "deveninfo", "devacinf", "devenid", "devlicentry", "devjnext", "ev_check", "devsinfo", "devacdata", "devliccheck", "dev_Info", "dev__entry", "devjentry", "dev__next", "dev_alias", "devacfamily", "dev_family", "devsalias", "dev_next", "dev__info", " dev_spec", "dev_data", " dev_alias", "dev_check", "devlicInfo", "devacalias", "dev_spec", " dev_id", "ev_data", "devsinf", "ev_info"], "ops": ["utils", "oc", "operator", "its", "opus", "steps", "afi", "outs", "uts", "step", "acs", "cop", "opt", "flags", "checks", "groups", "ns", "hop", "ips", "oops", "forces", "settings", "aps", "ils", "pps", "works", "opens", "app", "op", "opp", "eps", "locks", "acl", "lock", "ps", "times", "ss", " operations", "apps", "maps", "uses", "operation", "orders", "owner", "stats", "alls", "OPS", "arts", "effect", "posts", "ands", "OP", "pieces", "oop", "pins", "os", "cs", "o", "oa", "aux", "sync", "ups", "asts", "tx", "Ops", "als", "trans", "oper", "opers", "co", "ts", "active", "info", "actions", "changes", "ims", "oe", "obj", "ins", "xs", "rs", "obs", "states", "ms", "ip", "options", "loop", "io"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,\n\n                                 unsigned size)\n\n{\n\n    PICCommonState *s = opaque;\n\n    return s->elcr;\n\n}\n", "idx": 9067, "substitutes": {"opaque": ["opacity", "opac", "Opaque", "ipsa", " opops", " opsa", "operacity", " opac", "appacity", "ipcs", "ipops", "opcs", " opaques", " opacity", "ipaque", " opcs", "opops", "opsa", "Opops", "appac", "Opsa", "operaque", "opaques", "operaques", "operac", "appaques", "appaque", "Opcs"], "addr": ["Address", "arr", "byte", "base", "arm", "len", "ord", "pad", "src", "x", "pointer", "ad", "data", "ace", "ada", "ptr", "args", "arity", "oa", "cap", "address", "nr", "part", "asm", "type", "pos"], "size": ["timeout", "len", "capacity", "class", "small", "SIZE", "data", "from", "or", "args", "empty", "Size", "large", "unit", " length", "shape", "name", "address", "desc", "bytes", "type", "length", " sizes", "ize", " Size"], "s": ["session", "ts", "ks", "is", "si", "g", "rows", "in", "m", "instance", "ops", "i", "service", "c", "gs", "p", "ls", "e", "qs", "request", "args", "sq", "rs", "socket", "slave", "outs", "cs", "S", "es", "sync", "ubs", "states", "services", "r", "als", "ans", "ns", "hs", "rates", "ips", "params", "ses", "ps", "ss", "ows", "ssl"]}}
{"project": "FFmpeg", "commit_id": "08d2cee49c323715b66df0e4ff45ec0e07aaea7b", "target": 0, "func": "static int opt_input_file(const char *opt, const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret, rfps, rfps_base;\n\n    int64_t timestamp;\n\n    uint8_t buf[128];\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n\n\n\n    if (last_asked_format) {\n\n        if (!(file_iformat = av_find_input_format(last_asked_format))) {\n\n            fprintf(stderr, \"Unknown input format: '%s'\\n\", last_asked_format);\n\n            ffmpeg_exit(1);\n\n        }\n\n        last_asked_format = NULL;\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        ffmpeg_exit(1);\n\n    }\n\n    if (audio_sample_rate) {\n\n        snprintf(buf, sizeof(buf), \"%d\", audio_sample_rate);\n\n        av_dict_set(&format_opts, \"sample_rate\", buf, 0);\n\n    }\n\n    if (audio_channels) {\n\n        snprintf(buf, sizeof(buf), \"%d\", audio_channels);\n\n        av_dict_set(&format_opts, \"channels\", buf, 0);\n\n    }\n\n    if (frame_rate.num) {\n\n        snprintf(buf, sizeof(buf), \"%d/%d\", frame_rate.num, frame_rate.den);\n\n        av_dict_set(&format_opts, \"framerate\", buf, 0);\n\n    }\n\n    if (frame_width && frame_height) {\n\n        snprintf(buf, sizeof(buf), \"%dx%d\", frame_width, frame_height);\n\n        av_dict_set(&format_opts, \"video_size\", buf, 0);\n\n    }\n\n    if (frame_pix_fmt != PIX_FMT_NONE)\n\n        av_dict_set(&format_opts, \"pixel_format\", av_get_pix_fmt_name(frame_pix_fmt), 0);\n\n\n\n    ic->video_codec_id   =\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0);\n\n    ic->audio_codec_id   =\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0);\n\n    ic->subtitle_codec_id=\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0);\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n\n\n    /* open the input file with generic libav function */\n\n    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        ffmpeg_exit(1);\n\n    }\n\n    assert_avoptions(format_opts);\n\n\n\n    if(opt_programid) {\n\n        int i, j;\n\n        int found=0;\n\n        for(i=0; i<ic->nb_streams; i++){\n\n            ic->streams[i]->discard= AVDISCARD_ALL;\n\n        }\n\n        for(i=0; i<ic->nb_programs; i++){\n\n            AVProgram *p= ic->programs[i];\n\n            if(p->id != opt_programid){\n\n                p->discard = AVDISCARD_ALL;\n\n            }else{\n\n                found=1;\n\n                for(j=0; j<p->nb_stream_indexes; j++){\n\n                    ic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT;\n\n                }\n\n            }\n\n        }\n\n        if(!found){\n\n            fprintf(stderr, \"Specified program id not found\\n\");\n\n            ffmpeg_exit(1);\n\n        }\n\n        opt_programid=0;\n\n    }\n\n\n\n    if (loop_input) {\n\n        av_log(NULL, AV_LOG_WARNING, \"-loop_input is deprecated, use -loop 1\\n\");\n\n        ic->loop_input = loop_input;\n\n    }\n\n\n\n    /* Set AVCodecContext options for avformat_find_stream_info */\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = avformat_find_stream_info(ic, opts);\n\n    if (ret < 0 && verbose >= 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        ffmpeg_exit(1);\n\n    }\n\n\n\n    timestamp = start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n        /* reset seek info */\n\n        start_time = 0;\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st = ic->streams[i];\n\n        AVCodecContext *dec = st->codec;\n\n        InputStream *ist;\n\n\n\n        dec->thread_count = thread_count;\n\n\n\n        input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1);\n\n        ist = &input_streams[nb_input_streams - 1];\n\n        ist->st = st;\n\n        ist->file_index = nb_input_files;\n\n        ist->discard = 1;\n\n        ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0);\n\n\n\n        if (i < nb_ts_scale)\n\n            ist->ts_scale = ts_scale[i];\n\n\n\n        switch (dec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->dec = avcodec_find_decoder_by_name(audio_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            if(audio_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ist->dec= avcodec_find_decoder_by_name(video_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            rfps      = ic->streams[i]->r_frame_rate.num;\n\n            rfps_base = ic->streams[i]->r_frame_rate.den;\n\n            if (dec->lowres) {\n\n                dec->flags |= CODEC_FLAG_EMU_EDGE;\n\n            }\n\n            if(me_threshold)\n\n                dec->debug |= FF_DEBUG_MV;\n\n\n\n            if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {\n\n\n\n                if (verbose >= 0)\n\n                    fprintf(stderr,\"\\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\\n\",\n\n                            i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,\n\n\n\n                    (float)rfps / rfps_base, rfps, rfps_base);\n\n            }\n\n\n\n            if(video_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            else if(video_discard)\n\n                st->discard= video_discard;\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            if(subtitle_disable)\n\n                st->discard = AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_ATTACHMENT:\n\n        case AVMEDIA_TYPE_UNKNOWN:\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    /* dump the file content */\n\n    if (verbose >= 0)\n\n        av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = input_ts_offset - (copy_ts ? 0 : timestamp);\n\n\n\n    top_field_first = -1;\n\n    frame_rate    = (AVRational){0, 0};\n\n    frame_pix_fmt = PIX_FMT_NONE;\n\n    frame_height = 0;\n\n    frame_width  = 0;\n\n    audio_sample_rate = 0;\n\n    audio_channels    = 0;\n\n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n\n    av_freep(&ts_scale);\n\n    nb_ts_scale = 0;\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n    av_freep(&video_codec_name);\n\n    av_freep(&audio_codec_name);\n\n    av_freep(&subtitle_codec_name);\n\n    uninit_opts();\n\n    init_opts();\n\n    return 0;\n\n}\n", "idx": 7925, "substitutes": {"opt": ["option", "options", "oc", "open", "config", "op", "expr", "cat", "loc", "attr", "ext", "url", "obj", "Opt", "fn", "cmd", "path", "timeout", "feat", "temp", "wav", "prop", "alloc", "term", "text", "command", "prefix"], "filename": ["abl", "login", "name", "files", "python", "sf", "mpeg", "kn", "method", "provided", "config", "username", "tmp", "Filename", "println", "password", "format", "nuclear", "fax", "title", "f", "href", "url", "lua", "phrase", "subject", "description", "length", "document", "sheet", "ename", "fil", "download", "uri", "addin", "file", "binary", "fn", "json", "whatever", "path", "jpg", "fp", "nil", "dll", "source", "output", "msg", "wav", "microsoft", "kl", "txt", "location", "fd", "utf", "il", "blast", "png", "src", "directory", "prefix"], "ic": ["abc", "icc", "oc", "ig", "mic", "ik", "CI", "ci", "icer", "inc", "ican", "aci", "icing", "pc", "ai", "cc", "ics", "aic", "IC", "mc", "nic", "lic", "iac", "ici", "bc", "cu", "voc", "ec", "pic", "c", "cit", "ct", "lc", "fc", "ac", "vc", "fi", "au", "cm", "isc", "xc"], "file_iformat": ["file_ionicac", "file_icolat", "file_ilart", "file_iformac", "file_ionicar", "file_iolar", "file_iplt", "file_ilt", "file_ionict", "file_iplart", "file_ionicat", "file_iformar", "file_icolar", "file_iolart", "file_iolat", "file_ilat", "file_iplat", "file_ilac", "file_iolt", "file_icolac", "file_iformt", "file_icolt", "file_iplac", "file_iolac", "file_iformart"], "err": ["stat", "er", "header", "iter", "rr", "progress", "info", "loc", "attr", "all", "e", "error", "out", " error", "str", "seq", "output", "req", "reader", "ptr", "ver", "proc", "var", "ln", "resp", "r"], "i": ["id", "I", "ni", "b", "io", "abi", "info", "ir", "f", "pi", "attr", "ii", "iu", "it", "cli", "ai", "init", "t", "n", "ini", "h", "c", "ip", "ind", "ati", "ui"], "ret": ["gc", "ib", "mem", "rt", "I", "alt", "progress", "nt", "val", "rc", "info", "status", "q", "res", "buffer", "len", "out", "timeout", "exec", "cb", "result", "temp", "back", "aux", "rs", "fi"], "rfps": ["Rfps", "Rframes", "Rbps", "rdframes", "rbits", "rdbps", "rbps", "rdbits", "nfps", "Rbits", "rdfps", "nframes", "nbps", "rframes", "nbits"], "rfps_base": ["rfps_buffer", "rfps_bit", "rips_base", "rfps6length", "rfps_length", "rfps6bit", "rfps6base", "rips_bit", "rips_length", "rips_buffer", "rfps6buffer"], "timestamp": ["stimeline", "imestamp", "imend", "timeest", "timeeline", "stimend", "imeline", "timest", "timeend", "timeestamp", "timend", "stimestamp", "stimest", "imest", "timeline"], "buf": ["rb", "bg", "b", "raf", "auc", "queue", "uc", "buffer", "bag", "file", "func", "bc", "fp", "ab", "pool", "output", "proc", "pb", "img", "bh", "bed", "fam", "header", "extra", "lb", "prof", "config", "fb", "uf", "raw", "port", "ctx", "pad", "font", "batch", "usr", "wav", "doc", "cap", "text", "bn", "ff", "vec", "block", "box", "bd", "tmp", "rc", "cat", "loc", "grab", "wb", "db", "conv", "Buffer", "cmd", "feat", "fab", "prop", "fd", "bo", "desc", "aux", "src", "buff", "mem", "la", "Buff", "bt", "window", "bus", "bb", "ux", "cb", "result", "context", "seq", "alloc", "bf", "comb", "br", "cv", "pkg"], "opts": ["optionts", " opttes", "opertes", "operters", "optionns", "opns", " optts", "optionters", " optns", "optes", "optiontes", "operns", "operts", "opters", " optters"], "orig_nb_streams": [" orig_nb_threaded", " orig_nb_inputd", " orig_nb_threadd", " orig_nb_inputed", " orig_nb_streamd", " orig_nb_rawed", " orig_nb_rawpoints", " orig_nb_inputs", " orig_nb_threads", " orig_nb_raws", " orig_nb_threadpoints", " orig_nb_streamed", " orig_nb_inputpoints", " orig_nb_rawd", " orig_nb_streampoints"]}}
