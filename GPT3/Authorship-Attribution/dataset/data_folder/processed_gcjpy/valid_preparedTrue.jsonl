{"prompt":" \n  def is_sym( number ):\n  \tnum_str = str( number )\n  \tnum_len = len( num_str )\n  \thalf_len = int( num_len \/ 2 )\n  \tend = num_str[-half_len:]\n  \trev_end = end[::-1]\n  \tstart = num_str[:half_len]\n  \tequal = rev_end == start \n  \treturn equal\n  \n  f = open( 'palindromes.out' )\n  \n  numbers = [ int(x) for x in f.read().split() ]\n  \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n  \tmin, max = [ int(x) for x in raw_input().split() ]\n  \tcount = 0\n  \tfor number in numbers:\n  \t\tif min <= number and max >= number:\n  \t\t\tcount += 1\n  \n  \tprint 'Case #' + str( case ) + ': ' + str( count )\n <CODESPLIT> ","completion":" 0"}
{"prompt":"def build_table():\n  \ttable = []\n  \tfor i in range( 0, 31 ):\n  \t\ttable.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )\n  \n  \treturn table\n  \n  \n  def get_max_score( i ):\n  \treturn max( 0, min( 10, ( i + 2 ) \/ 3 ) )\n  \n  def get_max_surprise_score( i ):\n  \treturn min( i, max( 0, min( 10, ( i + 4 ) \/ 3 ) ) )\n  \n  def get_max( x, scores, score_needed, num_surprises ):\n  \tscores = sorted( scores, reverse=True )\n  \tnumPass = 0\n  \ti = 0;\n  \twhile ( i < len(scores) ):\n  \t\tif ( x[scores[i]][0] >= score_needed ):\n  \t\t\tnumPass += 1\n  \t\telse:\n  \t\t\tbreak\n  \t\ti += 1\n  \n  \twhile ( i < len(scores) and num_surprises > 0 ):\n  \t\tif ( x[scores[i]][1] >= score_needed ):\n  \t\t\tnumPass += 1\n  \t\t\tnum_surprises -= 1\n  \t\t\t\n  \t\ti += 1\n  \n  \treturn numPass\n  \n  x = build_table()\n  \n  num_cases = input()\n  \n  for i in range( 1, num_cases + 1 ):\n  \tline = raw_input().split()\n  \tnum_surprises = int(line[1])\n  \tscore_needed = int(line[2])\n  \tscores_raw = line[3:]\n  \n  \tscores = [ int(y) for y in scores_raw ]\n  \n  \tprint 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )\n <CODESPLIT> ","completion":" 0"}
{"prompt":" \n  \n  def is_palindrome(num):\n      s = str(num)\n      end_idx = len(s)-1\n      for i in range(len(s)\/\/2):\n          if s[i] != s[end_idx-i]:\n              return False\n      return True\n  \n  def is_valid_base(base):\n      return is_palindrome(base) and is_palindrome(base*base)\n  \n  def process_case(lo, hi):\n      cnt = 0\n      base_lo = math.ceil(math.sqrt(lo))\n      base_hi = math.floor(math.sqrt(hi))\n      for base in range(base_lo, base_hi+1):\n          if is_valid_base(base):\n              cnt += 1\n      return cnt\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          lo,hi = line_of_numbers(next(lines))\n          result = process_case(lo, hi)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('C-small-attempt0')\n <CODESPLIT> ","completion":" 1"}
{"prompt":" \n  def threshold(p, maxdiff):\n      minval = max(p - maxdiff, 0)\n      return p + minval + minval\n  \n  def process_case(numdata):\n      N,S,p = numdata[0:3]\n      scores = numdata[3:]\n      thre_normal = threshold(p, 1)\n      thre_surprise = threshold(p, 2)\n      result = 0\n      for tot in scores:\n          if tot >= thre_normal:\n              result += 1\n          elif S > 0 and tot >= thre_surprise:\n              result += 1\n              S -= 1\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          result = process_case(line_of_numbers(next(lines)))\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('B-small-attempt0')\n <CODESPLIT> ","completion":" 1"}
{"prompt":" \n  '''\n  Limits\n  \n  Small dataset       1 <= T <= 100, 1 <= A <= B <= 1000.\n  First large dataset 1 <= T <= 10000. 1 <= A <= B <= 1014.\n  Second large dataset    1 <= T <= 1000. 1 <= A <= B <= 10100.\n  \n  Sample\n  *** Input \n  3\n  1 4\n  10 120\n  100 1000\n   \t\n  *** Output \n  Case #1: 2\n  Case #2: 0\n  Case #3: 2\n  \n  \n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  pal_sqr_roots = '''1 \n  2 \n  3 \n  11 \n  22 \n  26 \n  101 \n  111 \n  121 \n  202 \n  212 \n  264 \n  307 \n  836 \n  1001 \n  1111 \n  2002 \n  2285 \n  2636 \n  10001 \n  10101 \n  10201 \n  11011 \n  11111 \n  11211 \n  20002 \n  20102 \n  22865 \n  24846 \n  30693 \n  100001 \n  101101 \n  110011 \n  111111 \n  200002 \n  798644 \n  1000001 \n  1001001 \n  1002001 \n  1010101 \n  1011101 \n  1012101 \n  1042151 \n  1100011 \n  1101011 \n  1102011 \n  1109111 \n  1110111 \n  1111111 \n  1270869 \n  2000002 \n  2001002 \n  2012748 \n  2294675 \n  3069307 \n  10000001 \n  10011001 \n  10100101 \n  10111101 \n  11000011 \n  11011011 \n  11100111 \n  11111111 \n  11129361 \n  12028229 \n  12866669 \n  20000002 \n  30001253 \n  64030648 \n  100000001 \n  100010001 \n  100020001 \n  100101001 \n  100111001 \n  100121001 \n  101000101 \n  101010101 \n  101020101 \n  101101101 \n  101111101 \n  110000011 \n  110010011 \n  110020011 \n  110091011 \n  110101011 \n  110111011 \n  111000111 \n  111010111 \n  111091111 \n  111101111 \n  111111111 \n  200000002 \n  200010002 \n  306930693 \n  1000000001 \n  1000110001 \n  1001001001 \n  1001111001 \n  1010000101 \n  1010110101 \n  1011001101 \n  1011111101 \n  1100000011 \n  1100110011 \n  1101001011 \n  1101111011 \n  1110000111 \n  1110110111 \n  1111001111 \n  2000000002 \n  2062386218 \n  2481623254 \n  10000000001 \n  10000100001 \n  10000200001 \n  10001010001 \n  10001110001 \n  10001210001 \n  10010001001 \n  10010101001 \n  10010201001 \n  10011011001 \n  10011111001 \n  10100000101 \n  10100100101 \n  10100200101 \n  10101010101 \n  10101110101 \n  10106064399 \n  10109901101 \n  10110001101 \n  10110101101 \n  10110911101 \n  10111011101 \n  10111111101 \n  10207355549 \n  11000000011 \n  11000100011 \n  11000200011 \n  11000910011 \n  11001010011 \n  11001110011 \n  11010001011 \n  11010101011 \n  11010911011 \n  11011011011 \n  11011111011 \n  11100000111 \n  11100100111 \n  11100910111 \n  11101010111 \n  11101110111 \n  11110001111 \n  11110101111 \n  13579355059 \n  20000000002 \n  20000100002 \n  22865150135 \n  30101273647 \n  30693069307 \n  83163115486 \n  100000000001 \n  100001100001 \n  100010010001 \n  100011110001 \n  100100001001 \n  100101101001 \n  100110011001 \n  100111111001 \n  101000000101 \n  101001100101 \n  101010010101 \n  101011110101 \n  101100001101 \n  101101101101 \n  101110011101 \n  101116809851 \n  110000000011 \n  110001100011 \n  110010010011 \n  110011110011 \n  110100001011 \n  110101101011 \n  110110011011 \n  111000000111 \n  111001100111 \n  111010010111 \n  111100001111 \n  111283619361 \n  112247658961 \n  128817084669 \n  200000000002 \n  1000000000001 \n  1000001000001 \n  1000002000001 \n  1000010100001 \n  1000011100001 \n  1000012100001 \n  1000100010001 \n  1000101010001 \n  1000102010001 \n  1000110110001 \n  1000111110001 \n  1001000001001 \n  1001001001001 \n  1001002001001 \n  1001010101001 \n  1001011101001 \n  1001100011001 \n  1001101011001 \n  1001110111001 \n  1001111111001 \n  1010000000101 \n  1010001000101 \n  1010002000101 \n  1010010100101 \n  1010011100101 \n  1010099010101 \n  1010100010101 \n  1010101010101 \n  1010109110101 \n  1010110110101 \n  1010111110101 \n  1011000001101 \n  1011001001101 \n  1011010101101 \n  1011011101101 \n  1011099011101 \n  1011100011101 \n  1011101011101 \n  1100000000011 \n  1100001000011 \n  1100002000011 \n  1100009100011 \n  1100010100011 \n  1100011100011 \n  1100100010011 \n  1100101010011 \n  1100110110011 \n  1100111110011 \n  1101000001011 \n  1101001001011 \n  1101009101011 \n  1101010101011 \n  1101011101011 \n  1101100011011 \n  1101101011011 \n  1110000000111 \n  1110001000111 \n  1110009100111 \n  1110010100111 \n  1110011100111 \n  1110100010111 \n  1110101010111 \n  1111000001111 \n  1111001001111 \n  1349465117841 \n  2000000000002 \n  2000001000002 \n  2149099165358 \n  2634812417864 \n  3069306930693 \n  6360832925898 \n  10000000000001 \n  10000011000001 \n  10000100100001 \n  10000111100001 \n  10001000010001 \n  10001011010001 \n  10001100110001 \n  10001111110001 \n  10010000001001 \n  10010011001001 \n  10010100101001 \n  10010111101001 \n  10011000011001 \n  10011011011001 \n  10011100111001 \n  10100000000101 \n  10100011000101 \n  10100100100101 \n  10100111100101 \n  10101000010101 \n  10101011010101 \n  10101100110101 \n  10110000001101 \n  10110011001101 \n  10110100101101 \n  10111000011101 \n  11000000000011 \n  11000011000011 \n  11000100100011 \n  11000111100011 \n  11001000010011 \n  11001011010011 \n  11001100110011 \n  11010000001011 \n  11010011001011 \n  11010100101011 \n  11011000011011 \n  11100000000111 \n  11100011000111 \n  11100100100111 \n  11101000010111 \n  11110000001111 \n  20000000000002 \n  30395080190573 \n  69800670077028 \n  98275825201587 \n  100000000000001 \n  100000010000001 \n  100000020000001 \n  100000101000001 \n  100000111000001 \n  100000121000001 \n  100001000100001 \n  100001010100001 \n  100001020100001 \n  100001101100001 \n  100001111100001 \n  100010000010001 \n  100010010010001 \n  100010020010001 \n  100010101010001 \n  100010111010001 \n  100011000110001 \n  100011010110001 \n  100011101110001 \n  100011111110001 \n  100100000001001 \n  100100010001001 \n  100100020001001 \n  100100101001001 \n  100100111001001 \n  100101000101001 \n  100101010101001 \n  100101101101001 \n  100101111101001 \n  100109990011001 \n  100110000011001 \n  100110010011001 \n  100110091011001 \n  100110101011001 \n  100110111011001 \n  100110990111001 \n  100111000111001 \n  100111010111001 \n  101000000000101 \n  101000010000101 \n  101000020000101 \n  101000101000101 \n  101000111000101 \n  101000990100101 \n  101001000100101 \n  101001010100101 \n  101001091100101 \n  101001101100101 \n  101001111100101 \n  101010000010101 \n  101010010010101 \n  101010101010101 \n  101010111010101 \n  101010990110101 \n  101011000110101 \n  101011010110101 \n  101100000001101 \n  101100010001101 \n  101100101001101 \n  101100111001101 \n  101101000101101 \n  101101010101101 \n  101110000011101 \n  101110010011101 \n  110000000000011 \n  110000010000011 \n  110000020000011 \n  110000091000011 \n  110000101000011 \n  110000111000011 \n  110001000100011 \n  110001010100011 \n  110001101100011 \n  110001111100011 \n  110010000010011 \n  110010010010011 \n  110010091010011 \n  110010101010011 \n  110010111010011 \n  110011000110011 \n  110011010110011 \n  110100000001011 \n  110100010001011 \n  110100101001011 \n  110100111001011 \n  110101000101011 \n  110101010101011 \n  110110000011011 \n  110110010011011 \n  111000000000111 \n  111000010000111 \n  111000091000111 \n  111000101000111 \n  111000111000111 \n  111001000100111 \n  111001010100111 \n  111010000010111 \n  111010010010111 \n  111100000001111 \n  111100010001111 \n  129610990752569 \n  200000000000002 \n  200000010000002 \n  210786628549538 \n  314155324482867 \n  1000000000000000 \n  1000000110000000 \n  1000001001000000 \n  1000001111000000 \n  1000010000100000 \n  1000010110100000 \n  1000011001100000 \n  1000011111100000 \n  1000100000010000 \n  1000100110010000 \n  1000101001010000 \n  1000101111010000 \n  1000110000110000 \n  1000110110110000 \n  1000111001110000 \n  1001000000001000 \n  1001000110001000 \n  1001001001001000 \n  1001001111001000 \n  1001010000101000 \n  1001010110101000 \n  1001011001101000 \n  1001100000011000 \n  1001100110011000 \n  1001101001011000 \n  1001110000111000 \n  1010000000000100 \n  1010000110000100 \n  1010001001000100 \n  1010001111000100 \n  1010010000100100 \n  1010010110100100 \n  1010011001100100 \n  1010100000010100 \n  1010100110010100 \n  1010101001010100 \n  1010110000110100 \n  1011000000001100 \n  1011000110001100 \n  1011001001001100 \n  1011010000101100 \n  1011100000011100 \n  1100000000000010 \n  1100000110000010 \n  1100001001000010 \n  1100001111000010 \n  1100010000100010 \n  1100010110100010 \n  1100011001100010 \n  1100100000010010 \n  1100100110010010 \n  1100101001010010 \n  1100110000110010 \n  1101000000001010 \n  1101000110001010 \n  1101001001001010 \n  1101010000101010 \n  1101100000011010 \n  1110000000000110 \n  1110000110000110 \n  1110001001000110 \n  1110010000100110 \n  1110100000010110 \n  1111000000001110 \n  2000000000000000 \n  2201019508986470 \n  2564053868197730 \n  3066446727654240 \n  3107974295870660 \n  3138199296186060'''\n  pal_sqr_roots = map(int, pal_sqr_roots.split())\n  \n  \n  \n  def is_palindrome(n):\n      return str(n)[::-1] == str(n)\n  \n  palindromic_roots = [x for x in pal_sqr_roots if is_palindrome(x)]\n  \n  fair_and_square = [x*x for x in palindromic_roots]\n  \n  \n  def get_num_fair_and_square(a, b):\n      return len([x for x in fair_and_square if a <= x <= b])\n  \n  for caseNo in range(1, int(input())+1):\n      a,b = map(int, input().split())\n      print 'Case #%d:' % caseNo, get_num_fair_and_square(a, b)\n  \n <CODESPLIT> ","completion":" 2"}
{"prompt":" \n  '''\n  Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]\n  At least S of the ti values will be between 2 and 28, inclusive.\n  \n  Small dataset 1 = N = 3.\n  Large dataset 1 = N = 100.\n  \n  Sample Input \n  4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \n  Output \n  Case #1: 3\n  Case #2: 2\n  Case #3: 1\n  Case #4: 3\n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  def maxBestDancers(N, S, p, *Ti):\n      cnt = 0\n      for score in Ti:\n          mx = (score + 2) \/\/ 3\n          if mx >= p:\n              cnt += 1\n          elif mx >= p-1 > 0 and S>0:\n              S -= 1\n              cnt += 1\n      return cnt\n  \n  for caseNo in range(1, int(input())+1):\n      print 'Case #%d:' % caseNo,\n      lst = map(int, input().split())\n      print maxBestDancers(*lst)\n  \n <CODESPLIT> ","completion":" 2"}
{"prompt":" \n  def generateTable(N):\n      msq = range(1, 4) + [11, 22] + [101, 111, 121, 202, 212]\n      nums = revnums = [1, 2]\n  \n      digsums = [1, 4]\n  \n      for i in xrange(2, N+1):\n          a, b, d = [], [], []\n          p = 10**(i-1)\n          for j in xrange(len(nums)):\n              for k in xrange(3):\n                  n, rn, ds = 10*nums[j] + k, revnums[j] + k*p, digsums[j] + k*k\n                  if ds < 5:\n                      a.append(n)\n                      b.append(rn)\n                      d.append(ds)\n                      msq.append(10*p*n + rn) # even length\n                      if i == N:\n                          continue\n                      for l in xrange(3): # odd length\n                          if 2*ds + l*l < 10:\n                              msq.append(100*p*n + 10*p*l + rn)\n          nums, revnums, digsums = a, b, d\n  \n      msq.sort()\n      return msq\n  \n  def getNum(A, B):\n      return bisect_right(tab2, B) - bisect_right(tab2, A-1)\n  \n  N = 10\n  tab = generateTable(N)\n  tab2 = map(lambda n: n**2, tab)\n  \n  T = int(raw_input())\n  for z in xrange(T):\n      A, B = map(int, raw_input().split())\n      print \"Case #%d: %d\" % (z+1, getNum(A, B))\n <CODESPLIT> ","completion":" 3"}
{"prompt":"T = int(raw_input())\n  \n  for z in xrange(1, T+1):\n      a = map(int, raw_input().split())\n      s, p = a[1:3]\n      a = a[3:]\n      A = 0 if p == 0 else 3*p - 2\n      B = 0 if p == 0 else 1 if p == 1 else 3*p-4\n      x = len(filter(lambda x: x >= A, a))\n      y = len(filter(lambda x: x >= B, a)) - x\n      res = x + min(s, y)\n      print \"Case #%d:\" % z, res\n <CODESPLIT> ","completion":" 3"}
{"prompt":" \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def pal(x):\n      l = list(str(x))\n      l2 = copy.copy(l)\n      l2.reverse()\n      return l == l2\n  \n  for i in range(num):\n      count = 0\n      line = f.readline()\n      a,b = line.split()\n      a = int(a)\n      b = int(b)\n      ma = int(math.sqrt(a))\n      mb = int(math.sqrt(b))+1\n      for j in range(ma,mb+1):\n          q = j*j\n          if q < a or q > b:\n              continue\n          if pal(j) and pal(q):\n              count += 1\n      print 'Case #{}:'.format(i+1), count\n <CODESPLIT> ","completion":" 4"}
{"prompt":" \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      res = [int(x) for x in f.readline().split()]\n      nrg, nrsup, score = res[0:3]\n      del res[0:3]\n      nrpass = 0\n      nrsuppass = 0\n      for x in res:\n          if score > 1:\n              if x >= 3*score-2:\n                  nrpass += 1\n              elif x >= 3*score-4:\n                  nrsuppass += 1\n          elif score == 1:\n              if x > 0:\n                  nrpass += 1\n          else:\n              nrpass +=1\n      print 'Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass)\n <CODESPLIT> ","completion":" 4"}
{"prompt":" \n  def ss(t, amap, bmap):\n      s = 0\n      for m in amap:\n          if len(m) == 1 and t == m.keys()[0]:\n              s += m[t]\n              for b in bmap:\n                  if t in b:\n                      b[t] -= 1\n                      if b[t] == 0:\n                          b.pop(t)\n              m.clear()\n      return s           \n  \n  \n  def solve(case, in_lines):\n      out = 'Case #%d: '%case\n   \n      rn, cn = [int(x) for x in in_lines[0].split()]\n      mtx = []\n      for i in xrange(rn):\n          mtx.append([int(x) for x in in_lines[i+1].split()])\n      rmap = [{} for x in xrange(rn)]\n      cmap = [{} for x in xrange(cn)]\n      td = {}\n      \n      for i in xrange(rn):\n          for j in range(cn):\n              k = mtx[i][j]\n              if k in rmap[i]:\n                  rmap[i][k] += 1\n              else:\n                  rmap[i][k] = 1\n              if k in cmap[j]:\n                  cmap[j][k] += 1\n              else:\n                  cmap[j][k] = 1\n              if k in td:\n                  td[k] += 1\n              else:\n                  td[k] = 1\n                  \n      while len(td):\n          k = min(td.keys())\n          sb = ss(k, rmap, cmap)\n          sb += ss(k, cmap, rmap)\n          if sb == 0:\n              break;\n          td[k] -= sb\n          if td[k] == 0:\n              td.pop(k)\n  \n      return out + ('YES' if sb else 'NO')\n  \n  \n  def main(raw):\n      lines = raw.split('\n')\n      n = int(lines[0])\n      ln = 1\n      outs = []\n      for case in xrange(1, n+1):\n          buff = []\n          cl = int(lines[ln].split()[0]) + ln + 1\n          while ln < cl and lines[ln]:\n              buff.append(lines[ln])\n              ln += 1\n          s = solve(case, buff)\n          print s\n          outs.append(s)\n      return '\n'.join(outs)\n      pass\n  \n  if __name__ == '__main__':\n      test_input = \"\"\"4\n  4 3\n  2 5 2\n  1 1 1\n  2 4 2\n  2 3 2\n  3 3\n  2 1 2\n  1 1 1\n  2 1 2\n  5 5\n  2 2 2 2 2\n  2 1 1 1 2\n  2 1 2 1 2\n  2 1 1 1 2\n  2 2 2 2 2\n  1 3\n  1 2 1\"\"\"\n      force_no_file = False\n      in_file_name = '' if force_no_file else 'B-large.in'\n      base_path = 'G:\/workspace\/py\/codejam2013\/RQ\/'\n      if in_file_name:\n          with open(base_path + in_file_name) as f:\n              raw = f.read()\n      else:\n          raw = test_input\n      out = main(raw)\n      if in_file_name:\n          with open(base_path + in_file_name + '.out', 'w') as f:\n              f.write(out)\n      pass\n <CODESPLIT> ","completion":" 5"}
{"prompt":" \n  def solve(icase, case_input):\n      case_output = 'Case #%i: '%icase\n      \n      result = 0\n      raw = [int(x) for x in case_input[0].split()]\n      ts = raw[3:]\n      ct = raw[1]\n      n = raw[2]\n      cc = 0\n      for i in ts:\n          if i > 3*n-3:\n              result += 1\n          elif i > max(3*n-5, 0):\n              cc += 1\n      result += min(cc, ct)\n  \n      case_output += '%d'%result\n      \n      return case_output\n  \n  \n  def main():\n      global use_test_data\n      global test_data\n      global input_file\n      global output_file\n      \n      if use_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for icase in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(icase, input)\n          print rslt\n          if not use_test_data:\n              print >> output_file, rslt\n      \n      if not use_test_data:\n          input_file.close()\n          output_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = \"\"\"4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \"\"\"\n      use_test_data = False\n      \n      test_file = 'B-small-attempt0.in'\n      if not use_test_data and '' != test_file:\n          input_file = open(test_file)\n          output_file = open(test_file + '.out', 'w')\n      \n      main()\n <CODESPLIT> ","completion":" 5"}
{"prompt":" \n  T = input()\n  \n  for n in range(1, T+1):\n  \n      A, B = raw_input().split()\n      A, B = int(A), int(B)\n  \n      j = 0\n      for i in range(A, B+1):\n          s = str(i)\n          m = int(i**.5)\n          if s[-1] in [\"1\", \"4\", \"5\", \"6\", \"9\"] and \\\n                  (s == \"\".join(reversed(s))) and \\\n                  m**2 == i:\n              s = str(m)\n              if s == \"\".join(reversed(s)):\n                  j += 1\n  \n  \n      print \"Case #%d: %d\" % (n, j)\n <CODESPLIT> ","completion":" 6"}
{"prompt":" \n  T=0 #no. of Test cases\n  for line in fileinput.input():\n      if fileinput.isfirstline():\n          T=int(line)\n          print \"no. of test cases:\", T\n          continue\n      \n      nums=[int(x) for x in line.split()]\n      N=nums[0] #no. of googlers\n      S=nums[1] #no. of surprising triplets\n      p=nums[2] #max value\n      \n      del nums[:3]\n      count=0\n      for num in nums:\n          quo=num\/\/3\n          rem=num%3\n          if quo >= p:\n              count += 1\n              continue\n          elif quo+1 == p and rem > 0:\n              count += 1\n              continue\n          elif quo+1 ==p and rem == 0 and quo > 0 and S > 0:\n              count += 1\n              S -= 1\n              continue\n          elif quo+2 >= p and rem == 2 and S > 0:\n              count += 1\n              S -= 1\n      \n      print \"Case #%(k)i: %(count)i\" % {\"k\":fileinput.lineno()-1,\"count\":count}\n <CODESPLIT> ","completion":" 6"}
{"prompt":" \n  fin = open('C-small-attempt0.in', 'r')\n  fout = open('ass3.out', 'w')\n  \n  T = int(fin.readline())\n  \n  def perfsq(n):\n      sq = int(math.sqrt(n))\n      if n == sq * sq:\n          return sq\n      return 0\n  \n  def palindrome(n):\n      s = str(n)\n      return (s == s[::-1])\n  \n  def getpal(n):\n      if n == 1:\n          for i in range(10):\n              yield i\n      else:\n          n2 = n \/ 2\n          for x in xrange(10 ** (n2 - 1), 10 ** n2):\n              s = str(x)\n              if n % 2:\n                  for i in range(10):\n                      ns = s + str(i) + s[::-1]\n                      yield int(ns)\n              else:\n                  ns = s + s[::-1]\n                  yield int(ns)\n  \n  for i in range(T):\n      A, B = map(int, fin.readline().split())\n  \n      ret = 0\n      for j in range(len(str(A)), len(str(B)) + 1):\n          for x in getpal(j):\n              if x < A:\n                  continue\n              if x > B:\n                  break\n              sq = perfsq(x)\n              if sq and palindrome(sq):\n                  ret += 1\n      fout.write('Case #%i: %i\n' % (i + 1, ret))\n <CODESPLIT> ","completion":" 7"}
{"prompt":"input_file = 'B-small-attempt1.in'\n  output_file = 'b.out'\n  \n  \n  def solvecase(inp):\n  \tdata = [int(n) for n in inp.split()]\n  \tN, S, p = data[0:3]\n  \tif p == 0:\n  \t\treturn N\n  \tt = data[3:]\n  \tret = 0\n  \tfor br in t:\n  \t\td, r = br \/ 3, br % 3\n  \t\tif br == 0 or p - d > 2:\n  \t\t\tcontinue\n  \t\tif (d >= p) or (r and (d + 1) >= p):\n  \t\t\tret += 1\n  \t\telif S and (d + max(r, 1)) >= p:\n  \t\t\tret += 1\n  \t\t\tS -= 1\n  \treturn ret\n  \n  lines = open(input_file, 'r').readlines()\n  out = open(output_file, 'w')\n  \n  for i, l in enumerate(lines[1:]):\n  \tsout = 'Case #%i: %i' % (i + 1, solvecase(l))\n  \tprint sout\n  \tout.write(sout + '\n')\n  \n  out.close()\n <CODESPLIT> ","completion":" 7"}
{"prompt":" a = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]\n  A = a[:10]\n  def subdfs(pre, mid, d, t, n):\n      if d == t:\n          k = long(''.join([pre, mid, pre[::-1]]))\n          k = k * k\n          if k > n:\n              return [1, 0]\n          sqk = str(k)\n          if sqk == sqk[::-1]:\n              A.append(k)\n              return [0, 1]\n          else:\n              return [0, 0]\n      res = subdfs(pre + '0', mid, d + 1, t, n)\n      if res[0]: return res\n      if not res[1]: return res\n      res2 = subdfs(pre + '1', mid, d + 1, t, n)\n      if res2[0]: return [1, res[1] + res2[1]]\n      return [0, res[1] + res2[1]]\n  \n  def dfs(d, n):\n      subdfs('1', '', 0, d, n)\n      subdfs('2' + '0' * d, '', d, d, n)\n      subdfs('1', '0', 0, d, n)\n      subdfs('1', '1', 0, d, n)\n      subdfs('1', '2', 0, d, n)\n      subdfs('2' + '0' * d, '0', d, d, n)\n      subdfs('2' + '0' * d, '1', d, d, n)\n  \n  def solve(pre):\n      read_ints = lambda: map(int, raw_input().split())\n      l, r = read_ints()\n      cl = bisect_left(A, l)\n      cr = bisect_right(A, r)\n      cl_ = cr_ = 0\n      for i in xrange(40):\n          if a[i] < l: cl_ += 1\n      for i in xrange(40):\n          if a[i] <= r: cr_ += 1\n      print pre, cr - cl\n  \n  for k in xrange(1, 48):\n      dfs(k, 10 ** 100 + 1)\n  A.sort()\n  N = int(raw_input())\n  for i in xrange(1, N + 1):\n      solve(\"Case #%d:\" % i)\n <CODESPLIT> ","completion":" 8"}
{"prompt":"T = int(raw_input())\n  for t in xrange(T):\n      line = map(int, raw_input().split())\n      N, S, p = line[0:3]\n      a = line[3:]\n      cnt = 0\n      a.sort(reverse=True)\n      for x in a:\n          if (x + 2) \/ 3 >= p:\n              cnt += 1\n          elif S > 0 and 2 <= x <= 28 and (x + 4) \/ 3 >= p:\n              cnt += 1\n              S -= 1\n          else:\n              break\n      print \"Case #%d: %d\" % (t + 1, cnt)\n <CODESPLIT> ","completion":" 8"}
{"prompt":"def isPalindrome(number):\n      strNum = str(number)\n      for i in range(len(strNum)\/2 + 1):\n          if strNum[i] != strNum[-1*(i+1)]:\n              return False\n      return True\n  \n  '''for i in range(40):\n      if isPalindrome(i) and isPalindrome(i*i):\n          print i*i\n  '''\n  \n  \n  filename = \"C-small-attempt0.in\"\n  outputname = filename + \"out.txt\"\n  \n  inFile = open(filename, 'r')\n  outFile = open(outputname, 'w')\n  \n  \n  fairAndSquareNums = [1,4,9,121,484]\n  \n  numTests = int(inFile.readline())\n  \n  for i in range(numTests):\n      line = inFile.readline().split()\n      count = 0\n      for j in range(int(line[0]), int(line[1])+1):\n          if j in fairAndSquareNums:\n              count += 1\n      outFile.write(\"Case #\" + str(i+1) + \": \" + str(count) + '\n')\n      print \"Case #\" + str(i+1) + \": \" + str(count)\n  \n  inFile.close()\n  outFile.close()\n <CODESPLIT> ","completion":" 9"}
{"prompt":"inputFile = open(\"B-small-attempt0 (3).in\", 'r')\n  outputFile = open(\"dancingOutSmall.txt\", 'w')\n  numTests = int(inputFile.readline())\n  \n  def countDancers(n,s,p,totals):\n      guaranteed = 0\n      needSurprise = 0\n      if p == 1:\n          for total in totals:\n              if total != 0:\n                  guaranteed += 1\n          return guaranteed\n      for total in totals:\n          if total >= p*3 - 2:\n              guaranteed += 1\n          elif total >= p*3 - 4:\n              needSurprise += 1\n      if needSurprise > s:\n          return guaranteed + s\n      else:\n          return guaranteed + needSurprise\n  \n  for i in range(numTests):\n      line = inputFile.readline().split()\n      n = int(line[0])\n      s = int(line[1])\n      p = int(line[2])\n      totals = []\n      for j in range(n):\n          totals += [int(line[3+j])]\n      outputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '\n')\n  \n  outputFile.close()\n <CODESPLIT> ","completion":" 9"}
{"prompt":" \n  n_cases = input()\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def is_palindrome(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  for case in xrange(1, n_cases + 1):\n      a, b = to_ints(raw_input())\n  \n      nums = range(int(b ** .5) + 2)\n      palins = filter(is_palindrome, nums)\n      squares = [x**2 for x in palins]\n      palin_squares = filter(is_palindrome, squares)\n      range_squares = [x for x in palin_squares if a <= x <= b]\n  \n      print \"Case #%d: %s\" % (case, len(range_squares))\n <CODESPLIT> ","completion":" 10"}
{"prompt":"n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      ins = map(int, raw_input().strip().split())\n      n = ins[0]\n      s = ins[1]\n      p = ins[2]\n      t = ins[3:]\n  \n      out = 0\n      for x in t:\n          if (x + 2) \/ 3 >= p:\n              out += 1\n          elif s and x > p and p - ((x - p) \/ 2) <= 2:\n              out += 1\n              s -= 1\n              \n      print \"Case #%d: %s\" % (case, out)\n <CODESPLIT> ","completion":" 10"}
{"prompt":"'''\n  Created on 13 Apr 2013\n  \n  @author: mengda\n  '''\n  \n  ls = []\n  \n  def isP(num):\n      num = str(int(num))\n      for i in range(len(num) \/ 2):\n          if num[i] <> num[-1 - i]:\n              return False\n      return True\n  \n  def createP(root, half_digits):\n      root = str(root)\n      for i in range(half_digits):\n          ls[i] = root[i]\n          ls[-1 - i] = root[i]\n      return int(''.join(ls))\n  \n  def process(A, B):\n      rlt = 0\n      a = int(math.ceil(math.sqrt(A)))\n      b = int(math.floor(math.sqrt(B)))\n      str_a = str(a)\n      half_digits = int(math.ceil(len(str_a) \/ 2.0))\n      root = int(str_a[:half_digits])\n      next_root = 10 ** half_digits\n      digits = len(str_a)\n      for _ in range(digits - len(ls)):\n          ls.append('')\n      while True:\n          if root == next_root:\n              if digits % 2 == 0:\n                  next_root *= 10\n                  half_digits += 1\n              else:\n                  root \/= 10\n              digits += 1\n              ls.append('')\n          p = createP(root, half_digits)\n          print p,\n          if p > b:\n              print 'too large'\n              break\n          if isP(math.pow(p, 2)):\n              print 'right one!'\n              rlt += 1\n          else:\n              print \n          root += 1\n      return rlt\n  \n  def process1(A, B):\n      rlt = 0\n      a = int(math.ceil(math.sqrt(A)))\n      b = int(math.floor(math.sqrt(B)))\n      for i in range(a, b + 1):\n          if not isP(i):\n              continue\n          power = math.pow(i, 2)\n          if isP(power):\n              rlt += 1\n      return rlt\n  \n  f = open('C-small-attempt1.in', 'r')\n  T = int(f.readline())\n  outLine = []\n  \n  for i in range(1, T + 1):\n      (A, B) = map(int, f.readline().split())\n      outLine.append('Case #%d: %s\n' % (i, process1(A, B)))\n      print outLine[-1],\n  \n  f.close()\n  outFile = open('C-S.out', 'w')\n  outFile.writelines(outLine)\n  outFile.close()\n <CODESPLIT> ","completion":" 11"}
{"prompt":"'''\n  Created on 2012-4-14\n  \n  @author: hemnd\n  '''\n  def cal(args):\n      rslt = 0\n      N = int(args[0])\n      S = int(args[1])\n      p = int(args[2])\n      for i in range(N):\n          s = int(args[i + 3])\n          e = s \/ 3\n          r = s % 3\n          if e >= p:\n              rslt += 1\n          elif r == 1:\n              if e + 1 >= p:\n                  rslt += 1\n          elif r == 0:\n              if e == 0:\n                  continue\n              if S > 0 and e + 1 >= p:\n                  rslt += 1\n                  S -= 1\n          elif r == 2:\n              if e + 1 >= p:\n                  rslt += 1\n              elif S > 0 and e + 2 >= p:\n                  rslt += 1\n                  S -= 1\n      return rslt\n  \n  inputFile = open('B-small-attempt0.in', 'r')\n  inputLines = inputFile.readlines()\n  inputFile.close()\n  \n  T = int(inputLines[0])\n  outputLines = []\n  \n  for i in range(1, T + 1):\n      args = inputLines[i].strip().split(' ')\n      outputLines.append('Case #%d: %d\n' % (i, cal(args)))\n      print outputLines[i - 1],\n  \n  outputFile = open('B-small.out', 'w')\n  outputFile.writelines(outputLines)\n  outputFile.close()\n <CODESPLIT> ","completion":" 11"}
{"prompt":" \n  \n  \n  def next_range(stream):\n      line = stream.readline()\n      if not line:\n          return None\n      return [int(x) for x in line.split()]\n  \n  \n  def is_palindrome(n):\n      n = str(n)\n      return all(n[i] == n[len(n)-1-i] for i in range(len(n) \/\/ 2))\n  \n  def mysqrt(n):\n      \"\"\"Return -1 if not an integer\"\"\"\n      rt = int(sqrt(n))\n      return rt if rt * rt == n else -1\n  \n  \n  def is_fas(n):\n      rt = mysqrt(n)\n      return rt != -1 and is_palindrome(n) and is_palindrome(rt)\n  \n  \n  def main():\n      with open('C-small-attempt0.in', encoding='utf-8') as f:\n          f.readline()\n  \n          for case in count(1):\n              r = next_range(f)\n              if r is None:\n                  break\n  \n              cnt = 0\n              for n in range(r[0], r[1] + 1):\n                  if is_fas(n):\n                      cnt += 1\n  \n              print('Case #{}: {}'.format(case, cnt))\n  \n  \n  main()\n <CODESPLIT> ","completion":" 12"}
{"prompt":" \n  \n  def best(total):\n      \"\"\"Return the best possible score for the given `total`.  Assume\n      the total is computed by summing exactly three scores (each in the\n      interval of 0 to 10 inclusive) and no score can be 2 points apart\n      \n      Arguments:\n      - `total`:\n      \"\"\"\n      m = total % 3\n      if m == 2:\n          b = total \/\/ 3 + 2\n      else:\n          b = total \/\/ 3 + 1\n      if b > 10:\n          b = 10\n      return b\n  \n  def best_non_surprising(total):\n      \"\"\"Return the best possible score for the given `total`, but\n      assume that there should be no more than 1 point difference\n      between the scores.\n  \n      Arguments:\n      - `total`:\n      \"\"\"\n      if total % 3 == 0:\n          return total \/\/ 3\n      else:\n          return total \/\/ 3 + 1\n  \n  def max_num_gte_p(totals, S, p):\n      \"\"\"Return the maximum number of Googlers that could have had a\n      best result of at least p.\n      \n      Arguments:\n      - `totals`:\n      - `S`: number of surprising triplets of scores\n      - `p`:\n      \"\"\"\n      res = 0\n      for total in totals:\n          if total == 0:\n              if p == 0:\n                  res += 1\n              continue\n  \n          if best_non_surprising(total) >= p:\n              res += 1\n          elif S > 0 and best(total) >= p:\n              res += 1\n              S -= 1\n  \n      return res\n  \n  def main():\n      with open(sys.argv[1], 'r') as f:\n          f.readline()            # skip T\n  \n          n = 0\n          for line in f:\n              n += 1\n  \n              line = [int(s) for s in line.split()]\n              N = line[0]\n              S = line[1]\n              p = line[2]\n              totals = line[3:]\n  \n              print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> ","completion":" 12"}
{"prompt":" \n  def read(f):\n      return list( int(v) for v in f.readline().split() )\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def testcases(f):\n      T = int(f.readline())\n      for X in range(1, T + 1):\n          A, B = read(f)\n          yield X, A, B\n  \n  def ispalindrome(v):\n      s = str(v)\n      for i in range(len(s) \/\/ 2):\n          if s[i] != s[-i-1]:\n              return False\n      return True\n  \n  def main(inf, outf):\n      MAX = 1000\n      fslst = []\n      for i in itertools.count():\n          if ispalindrome(i):\n              squere = i * i\n              print(MAX, squere, ispalindrome(squere))\n              if squere > MAX:\n                  break\n              if ispalindrome(squere):\n                  fslst.append(squere)\n      for X, A, B in testcases(inf):\n          cnt = 0\n          for fs in fslst:\n              if A <= fs <= B:\n                  cnt += 1\n          answer(outf, X, cnt)\n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n <CODESPLIT> ","completion":" 13"}
{"prompt":" \n  def testcases():\n      with open(sys.argv[1], \"r\") as f:\n          f.readline()  # skip number of testcases\n          for X, T in enumerate(f, 1):\n              yield X, [int(t) for t in T.split()]\n  \n  def main():\n      for X, T in testcases():\n          N = T[0]   # the number of Googlers\n          S = T[1]   # the number of surprising triplets of scores\n          p = T[2]   # best result of at least\n  \n          y = 0\n  \n          for t in T[3:]:\n              d, m = divmod(t, 3)\n              if m == 0:\n                  if p <= d:\n                      y += 1\n                  elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:\n                      y += 1\n                      S -= 1\n              elif m == 1:\n                  if p <= d + 1:\n                      y += 1\n              else:\n                  if p <= d + 1:\n                      y += 1\n                  elif p <= d + 2 and S:\n                      y += 1\n                      S -= 1\n  \n          print(\"Case #{:d}: {:d}\".format(X, y))\n  \n  if __name__==\"__main__\":\n      main()\n <CODESPLIT> ","completion":" 13"}
{"prompt":" \n  def pal(s):\n      for i in xrange(len(s)\/2):\n          if s[i] != s[-i-1]:\n              return False\n      return True\n  \n  def pal2(x, s):\n      return pal(s) and pal(str(x*x))\n  \n  def E(k):\n      return 10**k\n  \n  \n  def CREATE_DATABASE(MAX):\n      def init():\n          yield 1\n          yield 2\n          yield 3\n          yield 11\n          yield 22\n          for i in xrange(1, MAX):\n              yield 1*E(2*i) + 1\n              yield 1*E(2*i+1) + 1\n              yield 2*E(2*i) + 2\n              yield 2*E(2*i) + 2 + 1*E(i)\n              yield 2*E(2*i+1) + 2\n              \n              \n      heap = list(sorted(set(init())))\n      for i in heap:\n          print i\n      heapq.heapify(heap)\n      RES = []\n      try:\n          MAX_X = E(MAX)\n          print \"MAX_X\", MAX_X\n          while True:\n              x = heapq.heappop(heap)\n              RES.append(x)\n              if x == 3:\n                  continue\n              if x > MAX_X:\n                  break\n              s = str(x)\n              j = len(s) \/ 2\n              shift = 1 if len(s) == 2*j else 0\n              for i in xrange(j+1, MAX):\n                  n = E(2*i-shift) + 1 + E(i-j) * x\n                  if pal2(n,str(n)):\n                      heapq.heappush(heap, n)\n                  \n      except KeyboardInterrupt:\n          print \"stopped while x is\", x\n      with open(\"c.database\", 'w') as f:\n          for i in sorted(RES + heap):\n              f.write(\"%i\n\"%i)\n  \n  def READ_DATABASE():\n      with open(\"c.database\", 'r') as f:\n          return sorted(map(lambda x: int(x.strip())**2, f))\n  DB = READ_DATABASE()\n  \n  def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def nrints(N): return [rints() for i in xrange(N)]\n      A, B = rints()\n      i = bisect_left(DB, A) \n      j = bisect_right(DB, B)\n      return j-i\n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write(\"Case #%i: %s\n\" % (i, CASE(IN)))\n  \n  if __name__ == \"__main__\":\n      RUN(sys.stdin, sys.stdout)\n <CODESPLIT> ","completion":" 14"}
{"prompt":" \n  \n  \n  D1 = {} # no suprize\n  D2 = {} # surprize\n  for i in xrange(0, 31):\n      D1[i] = D2[i] = -1\n  \n  def precompute():\n      for a in xrange(0, 11):\n          for b in xrange(a, min(a+3,11)):\n              for c in xrange(b, min(a+3,11)):\n                  t = a+b+c\n                  assert a <= b <= c <= a+2 and c <= 11\n                  if c < a+2:\n                      D1[t] = max(D1[t], c)\n                  else: # that is, c == a+2, we have a suprize\n                      D2[t] = max(D2[t], c)\n  \n  \n  precompute()\n  \n  def case(S, P, ts):\n      res_n = 0\n      res_s = 0\n      for t in ts:\n          if D1[t] >= P:\n              res_n+=1\n          elif D2[t]>=P:\n              res_s+=1\n      return (res_n + min(res_s, S))\n  \n  \n  def solve(fin, fout):\n      T = int(fin.readline())\n      for t in xrange(T):\n          nums = map(int, fin.readline().strip().split(\" \"))\n          N, S, P = nums[:3]\n          ts = nums[3:]\n          assert len(ts) == N    \n          fout.write(\"Case #%i: %i\n\" % (t+1, case(S,P,ts)) )\n      return True\n  \n  if __name__ == \"__main__\":\n      with open(sys.argv[1],'r') as fin:\n          with open(sys.argv[2], 'w') as fout:\n              solve(fin, fout)\n <CODESPLIT> ","completion":" 14"}
{"prompt":" f   = file(sys.argv[1])\n  out = file(sys.argv[2], 'w')\n  \n  caseCnt = int(f.readline())\n  \n  Num = [\n  \t0,\n  \t1,\n  \t4,\n  \t9,\n  \t121,\n  \t484,\n  \t10201,\n  \t12321,\n  \t14641,\n  \t40804,\n  \t44944,\n  \t1002001,\n  \t1234321,\n  \t4008004,\n  \t100020001,\n  \t102030201,\n  \t104060401,\n  \t121242121,\n  \t123454321,\n  \t125686521,\n  \t400080004,\n  \t404090404,\n  \t10000200001,\n  \t10221412201,\n  \t12102420121,\n  \t12345654321,\n  \t40000800004,\n  \t1000002000001,\n  \t1002003002001,\n  \t1004006004001,\n  \t1020304030201,\n  \t1022325232201,\n  \t1024348434201,\n  \t1210024200121,\n  \t1212225222121,\n  \t1214428244121,\n  \t1232346432321,\n  \t1234567654321,\n  \t4000008000004,\n  \t4004009004004,\n  ]\n  \n  for case in range(1, caseCnt+1):\n  \tL, H = f.readline().split()\n  \tL = int(L); H = int(H)\n  \tassert L <= H\n  \t\n  \tfor i in range(len(Num)):\n  \t\tif L <= Num[i]:\n  \t\t\tbreak\n  \telse:\n  \t\tprint>>out, 'Case #%d:'%case, 0\n  \t\tcontinue\n  \n  \tlb = i - 1\n  \n  \tfor i in range(1, len(Num)+1):\n  \t\tif H >= Num[len(Num)-i]:\n  \t\t\tbreak\n  \telse:\n  \t\tprint>>out, 'Case #%d:'%case, 0\n  \t\tcontinue\n  \tub = len(Num)-i\n  \t\t\n  \tprint>>out, 'Case #%d:'%case, ub - lb\n  \n  out.close()\n <CODESPLIT> ","completion":" 15"}
{"prompt":" \n  f = file(\"B-small-attempt0.in\")\n  w = file(\"answer.txt\", \"w\")\n  cnt = int(f.readline()[:-1])\n  for no in range(cnt):\n  \tl = f.readline()[:-1].split()\n  \tT, s, p = map(int, l[:3])\n  \tts = map(int, l[3:])\n  \tns = p*3-2 if p*3-2 > 0 else 0\n  \tss = p*3-4 if p*3-4 > 0 else 31\n  \tl = filter(lambda x: x<ns, ts)\n  \tc = min([len(filter(lambda x: x>=ss, l)), s])\n  \t\n  \tprint>>w, \"Case #%d:\"%(no+1), T-len(l)+c\n  \n  \n <CODESPLIT> ","completion":" 15"}
{"prompt":"def check(a,b):\n      c = 0\n      n = 1\n      for i in range(1,4):\n          if i**2 >= a and i**2 <=b:\n              c += 1\n      if 44944 >= a and 44944 <= b:\n          c += 1\n      while n < 10:\n          p1 = int('1'+'1'*n)**2\n          if p1 >= a and p1 <=b:\n              c += 1\n          n += 1\n  \n  \n      if 484 >= a and 484 <= b:\n          c += 1\n  \n      n = 1\n      while True:\n          p2 = int('1'+'0'*n+'1')**2\n          p3 = int('2'+'0'*n+'2')**2\n          if p2 >= a and p2 <= b:\n              c += 1\n          else:\n              break\n          if p3 >= a and p3 <= b:\n              c += 1\n          else:\n              continue\n          n += 1\n  \n      n = 1\n      while True:\n          t = False\n          for m in range(2,5):\n              p4 = int('1'*m+'0'*n+'1'*m)**2\n              if p4 >= a and p4 <= b:\n                  c += 1\n              else:\n                  t = True\n                  break\n          if t:\n              break\n              \n          n += 1\n      return c\n                  \n  dat = raw_input().split()\n  n = int(dat.pop(0))\n  data = [int(e) for e in dat]\n  \n  for i in range(0, n*2, 2):\n      a, b = data[i], data[i+1]\n      print 'Case #%i: '%(i\/2+1) + str(check(a,b)) \n  \n      \n <CODESPLIT> ","completion":" 16"}
{"prompt":"f = open('cj2.in','r')\n  out = open('out1.txt','w')\n  inp = [[int(n) for n in s.split()] for s in f.readlines()]\n  \n  def score_partition(score):\n      poss = []\n      if score == 0:\n          return [[0,0,0]]\n      if score == 1:\n          return [[0,0,1]]\n      if score % 3 == 0:\n          poss.append([score\/3,score\/3,score\/3])\n          poss.append([score\/3-1,score\/3,score\/3+1])\n      if score % 3 == 1:\n          poss.append([score\/3, score\/3,score\/3+1])\n          poss.append([score\/3-1,score\/3+1,score\/3+1])\n      if score % 3 == 2:\n          poss.append([score\/3,score\/3+1,score\/3+1])\n          poss.append([score\/3,score\/3,score\/3+2])\n  \n      return poss\n  \n  \n  s = 0\n  c = 1\n  for e in inp[1:len(inp)]:\n      count = 0\n      surprises = e[1]\n      s = 0\n      p = e[2]\n      for i in e[3:len(e)]:\n          scores = score_partition(i)\n          for j in scores: \n              if max(j) >= p:\n                  if max(j)-min(j) == 2:\n                      if s < surprises:\n                          s +=1\n                          count +=1\n                          break\n                  else:\n                      count += 1\n                      break\n                  \n      out.write('Case #'+str(c)+': '+str(count)+'\n')\n      c += 1\n  \n  out.close()\n  f.close()\n                  \n          \n      \n      \n  \n      \n <CODESPLIT> ","completion":" 16"}
{"prompt":" def ispal(num):\n      num = str(num)\n      if num == num[::-1]:\n          return True\n      else:\n          return False\n  \n  def test(bot, top):\n      count = []\n      for i in range(bot,top+1):\n          if not ((int(i**0.5)**2) == i):\n              continue\n          if ispal(i) and ispal(int(i**0.5)):\n              count.append(i)\n      return len(count)\n  \n  case = 1\n  for line in open('C-small-attempt2.in', 'Ur'):\n      if ' ' in line:\n          a,b = line.split()\n          res = test(int(a),int(b))\n          print(\"Case #{0}: {1}\".format(case, res))\n          case += 1\n  \n  \n <CODESPLIT> ","completion":" 17"}
{"prompt":" data = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]\n  count = 0\n  for line in data[1:]:\n  \tcount += 1\n  \tsupps = line[1]\n  \tscore = line[2]\n  \tmaxes = 0\n  \tnonsuptot = (score*3)-2\n  \tsuptot = (score*3)-4\n  \tif suptot < 0:\n  \t\tsuptot = 1\n  \tfor i in range(3,(len(line))):\n  \t\tif line[i] >= nonsuptot:\n  \t\t\tmaxes += 1\n  \t\t\tcontinue\n  \t\tif (line[i] >= suptot) and (supps > 0):\n  \t\t\tmaxes += 1\n  \t\t\tsupps -= 1\n  \tif score == 0:\n  \t\tmaxes = line[0]\n  \tprint (\"Case #\"+str(count)+\":\", maxes)\n  \t\t\n  \t\t\t\n  \n  \n  \n  \n <CODESPLIT> ","completion":" 17"}
{"prompt":" \n  \n  def is_palindrome(a):\n      return str(a) == ''.join(reversed(str(a)))\n  \n  \n  def solve_problem(min_num, max_num):\n      count = 0\n      for i in xrange(min_num, max_num + 1):\n          if is_palindrome(i):\n              sqrt = math.sqrt(i)\n              if int(sqrt) == sqrt and is_palindrome(int(sqrt)):\n                  count += 1\n      return count\n  \n  \n  if __name__ == '__main__':\n      num_of_cases = int(sys.stdin.readline())\n      for i in xrange(1, num_of_cases + 1):\n          min_num, max_num = map(int, sys.stdin.readline().strip().split(' '))\n          print 'Case #{0}: {1}'.format(i, solve_problem(min_num, max_num))\n <CODESPLIT> ","completion":" 18"}
{"prompt":"\"\"\"\n  Google Code Jam 2012 Problem B\n  Usage:\n      python problem_b.py < input.txt > output.txt\n  \"\"\"\n  \n  \n  def calc_possible(n):\n      combinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores\n      return itertools.ifilter(lambda (x, y, z): x + y + z == n, combinations)\n  \n  \n  def calc_surprising(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def calc_normal(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def solve_problem():\n      number_of_cases = int(sys.stdin.readline())\n  \n      for i in xrange(1, number_of_cases + 1):\n  \n          case = sys.stdin.readline().strip()\n          result = 0\n          num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)\n          num_of_googlers = int(num_of_googlers)\n          num_of_surprising = int(num_of_surprising)\n          desired_score = int(desired_score)\n          scores = map(int, scores.split())\n  \n          possible_scores = []\n  \n          for k in xrange(num_of_googlers):\n  \n              normal = calc_normal(scores[k])\n              surprising = calc_surprising(scores[k])\n  \n              possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))\n  \n          possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))\n          result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))\n  \n          sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n  \n  \n  if __name__ == '__main__':\n      solve_problem()\n <CODESPLIT> ","completion":" 18"}
{"prompt":" \n  \n  \n  def ispalindrome(n):\n      return str(n) == str(n)[::-1]\n  \n  \n  def solve(A, B):\n      solution = []\n      for n in range(int(math.sqrt(A)), int(math.sqrt(B))+1):\n          if ispalindrome(n):\n              m = n ** 2\n              if ispalindrome(m) and A <= m <= B:\n                  solution.append(n)\n      return len(solution)\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          A, B = map(int, IN.readline().split())\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(A, B)))\n  \n  \n  def makesample(T=100, ABmax=1000):\n      print T\n      for index in range(T):\n          A = random.randint(1, ABmax)\n          B = random.randint(A, ABmax)\n          print A, B\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n <CODESPLIT> ","completion":" 19"}
{"prompt":" \n  \n  \n  \n  \n  def solve(S, p, tlist):\n  \tabove = 0\n  \tconsider = 0\n  \n  \tfor t in tlist:\n  \t\tavg = t \/ 3\n  \t\tmod = t % 3\n  \n  \t\tif mod == 0:\n  \t\t\tif avg >= p:\n  \t\t\t\tabove += 1\n  \t\t\telif avg + 1 >= p and t > 0:\n  \t\t\t\tconsider += 1\n  \n  \t\telif mod == 1:\n  \t\t\tif avg + 1 >= p:\n  \t\t\t\tabove += 1\n  \n  \t\telif mod == 2:\n  \t\t\tif avg + 1 >= p:\n  \t\t\t\tabove += 1\n  \t\t\telif avg + 2 >= p:\n  \t\t\t\tconsider += 1\n  \n  \treturn above + min(S, consider)\n  \n  \n  def main(IN, OUT):\n  \tN = int(IN.readline())\n  \tfor index in range(N):\n  \t\tdata = map(int, IN.readline().strip().split())\n  \t\t(N, S, p), tlist = data[:3], data[3:]\n  \t\tOUT.write('Case #%d: %d\n' % (index + 1, solve(S, p, tlist)))\n  \n  \n  if __name__ == '__main__':\n  \tmain(sys.stdin, sys.stdout)\n  \n <CODESPLIT> ","completion":" 19"}
{"prompt":" \n  N_MAX = 10 ** 7  # for First large dataset\n  \n  \n  def is_palindrome(n):\n      s = str(n)\n      for i in xrange(len(s) \/ 2):\n          if s[i] != s[-1 - i]:\n              return False\n      return True\n  \n  palindromes = [x for x in xrange(N_MAX) if is_palindrome(x)]\n  palindrome_squares = [x ** 2 for x in palindromes]\n  fair_and_square_palindromes = filter(is_palindrome, palindrome_squares)\n  \n  \n  T = int(raw_input())\n  for test_case_id in xrange(1, T + 1):\n      A, B = map(int, raw_input().split())\n      answer = len([x for x in fair_and_square_palindromes if A <= x <= B])\n      print 'Case #{}: {}'.format(test_case_id, answer)\n <CODESPLIT> ","completion":" 20"}
{"prompt":" \n  \n  poss = dict([(i, {}) for i in xrange(0, 30 + 1)])\n  for a, b, c in itertools.product(range(10 + 1), repeat=3):\n      if a <= b <= c and c - a <= 2:\n          n = a + b + c\n          if c - a == 2:\n              poss[n]['s'] = tuple(sorted((a, b, c)))\n          else:\n              poss[n]['n'] = tuple(sorted((a, b, c)))\n  \n  \n  T = int(raw_input())\n  for case in xrange(1, T + 1):\n      div = map(int, raw_input().split())\n      N, S, p = div[:3]\n      t = div[3:]\n  \n      ans = 0\n      t.sort(reverse=True)\n      for i in xrange(len(t)):\n          na, nb, nc = poss[t[i]]['n']\n          sa, sb, sc = poss[t[i]].get('s', (-1, -1, -1))\n          if p <= nc:\n              ans += 1\n          elif 0 < S and p <= sc:\n              ans += 1\n              S -= 1\n  \n      print 'Case #%d: %d' % (case, ans)\n  \n <CODESPLIT> ","completion":" 20"}
{"prompt":" \n  \n  \n  INPUT = \"tiny\"\n  if 1:\n      INPUT = \"C-small-attempt0.in\"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args\n  \n  def is_palindrome(N):\n      s = str(N)\n      return s == ''.join(reversed(s))\n  \n  def fair_and_square_set(max_N):\n      p = \"squareset_%d\" % max_N\n      try:\n          s = pickle.load(file(p))\n          return s\n      except:\n          pass\n      s = set()\n      for i in range(1,max_N+1):\n          if is_palindrome(i) and is_palindrome(i*i):\n              s.add(i*i)\n      pickle.dump(s, file(p, \"wb\"))\n      return s\n  \n  MAX_N = int(1e7)\n  SQUARE_SET = fair_and_square_set(MAX_N)\n  \n  def do_trial(A, B):\n      count = 0\n      for ss in SQUARE_SET:\n          if A <= ss <= B:\n              count += 1\n      return count\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      A, B = [int(x) for x in f.readline().split()]\n      v = do_trial(A, B)\n      print \"Case #%d: %s\" % (i+1, v)\n <CODESPLIT> ","completion":" 21"}
{"prompt":" \n  \n  INPUT = \"tiny\"\n  \n  INPUT = \"B-small-attempt0.in.txt\"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  def zdebug(*args):\n      print ''.join(str(s) for s in args)\n  \n  def can_score_p(N, p):\n      low_p = max(p-1, 0)\n      if low_p + low_p + p <= N:\n          return \"Y\"\n      low_p = max(p-2, 0)\n      if low_p + low_p + p <= N:\n          return \"S\"\n      return \"N\"\n  \n  def do_trial(N, S, p, *scores):\n      d = { \"Y\" : 0, \"N\" : 0, \"S\" : 0 }\n      for s in scores:\n          v = can_score_p(s, p)\n          debug(\"score %s p=%s : %s\" % (s, p, v))\n          d[v] = d[v] + 1\n      return d[\"Y\"] + min(d[\"S\"], S)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      l = [int(x) for x in f.readline()[:-1].split()]\n      v = do_trial(*l)\n      print \"Case #%d: %s\" % (i+1, v)\n <CODESPLIT> ","completion":" 21"}
{"prompt":" \n  \n  def is_palindromic(i):\n      n = i\n      rev = 0\n      while i > 0:\n          dig = i % 10\n          rev = rev * 10 + dig\n          i = i \/\/ 10\n      return n == rev\n  \n  def is_square(i):\n      if i == 1:\n          return True\n      x = i \/\/ 2\n      seen = set([x])\n      while x * x != i:\n          x = (x + (i \/\/ x)) \/\/ 2\n          if x in seen:\n              return False\n          seen.add(x)\n      return True\n  \n  def f(a, b):\n      tot = 0\n  \n      sra = a\n      while not is_square(sra):\n          sra += 1\n      srb = b\n      while not is_square(srb):\n          srb -= 1\n  \n      sra = int(sqrt(sra))\n      srb = int(sqrt(srb))\n  \n      for i in range(sra, srb+1):\n          if is_palindromic(i) and is_palindromic(i ** 2):\n              tot += 1\n  \n      return tot\n  \n  if __name__ == '__main__':\n      T = int(input())\n      for i in range(T):\n          a, b = map(int, input().split())\n          r = f(a, b)\n          print('Case #{}: {}'.format(i+1, r))\n <CODESPLIT> ","completion":" 22"}
{"prompt":" \n  T = int(raw_input())\n  for i in xrange(T):\n      values = map(int, raw_input().split())\n      [N,s,p] = values[0:3]\n      t = values[3:]\n      answer = 0\n      for note in t:\n          if note < 2:\n              if note >= p:\n                  answer += 1\n          elif note % 3 == 1 and (note-1) \/ 3 + 1 >= p:\n              answer += 1\n          elif note % 3 == 0:\n              n = note \/ 3\n              if n >= p:\n                  answer += 1\n              elif s > 0 and n + 1 >= p:\n                  answer += 1\n                  s -= 1\n          elif note % 3 == 2:\n              n = (note - 2) \/ 3\n              if n + 1 >= p:\n                  answer += 1\n              elif s > 0 and n + 2 >= p:\n                  answer += 1\n                  s -= 1\n      print 'Case #{0}: {1}'.format(i+1, answer)\n <CODESPLIT> ","completion":" 22"}
{"prompt":" \n  \n  FILE_NAME_BASE = 'C-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  \ta, b = (int(x) for x in inp.readline().split())\n  \treturn a, b\n  \n  def isFair(x):\n  \tl1 = list(str(x))\n  \tl2 = list(l1)\n  \tl2.reverse()\n  \treturn l1 == l2\n  \n  def solve(a, b):\n  \tc = 0\n  \tfor i in xrange(a, b + 1):\n  \t\tr = int(sqrt(i))\n  \t\tif r * r == i and isFair(i) and isFair(r):\n  \t\t\tc += 1\n  \n  \treturn str(c)\n  \n  def main():\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\n  \n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\n  \tnumCases = int(inp.readline())\n  \tif NUM_PROCESSES == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(NUM_PROCESSES)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n  \n  if __name__ == '__main__':\n  \tmain()\n <CODESPLIT> ","completion":" 23"}
{"prompt":" \n  FILE_NAME_BASE = 'B-small-attempt0'\n  NUM_PROCESSES = 0\n  \n  def parse(inp):\n  \tdata = tuple(int(x) for x in inp.readline().split())\n  \tdancers, surprises, points = data[ : 3]\n  \ttotals = data[3 : ]\n  \tassert len(totals) == dancers\n  \treturn totals, surprises, points\n  \n  def totalAtDist():\n  \t'''\n  \tIf a dancer's best result is b, the total can be:\n  \t  distance 0: 3b\n  \t  distance 1: [3b-2..3b-1]\n  \t  distance 2: [3b-4..3b-2]\n  \tNote: distance d is only possible if d <= b.\n  \n  \ttotal 15:\n  \tb = 0..4:  impossible\n  \tb = 5:     dist = 0\n  \tb = 6:     dist = 2\n  \tb = 7..10: impossible\n  \n  \tFor every total we have a number of explanations, which are\n  \t(b, d) pairs where b is the best result and d is the distance.\n  \n  \tThe output of this function shows:\n  \n  \tExcept for 0, 1, 29 and 30, every total t has exactly 2 explanations:\n  \t  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)\n  \tIn other words, always one surprise option and one normal option.\n  \tThe surprise option can have a result one higher than the normal one or\n  \tequal to it.\n  \t'''\n  \n  \tprint '  ',\n  \tfor b in xrange(0, 11):\n  \t\tprint 'b=%d' % b,\n  \tprint\n  \tfor total in xrange(0, 31):\n  \t\tprint '%2d' % total,\n  \t\tfor b in xrange(0, 11):\n  \t\t\ts = '0' if total == b * 3 else '.'\n  \t\t\ts += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'\n  \t\t\ts += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'\n  \t\t\tprint s,\n  \t\tprint\n  \n  \n  def solve(totals, surprises, points):\n  \tcountCertain = 0\n  \tcountSurprise = 0\n  \tfor total in totals:\n  \t\tif (total + 2) \/ 3 >= points:\n  \t\t\tcountCertain += 1\n  \t\telif 2 <= total <= 28 and (total + 4) \/ 3 >= points:\n  \t\t\tcountSurprise += 1\n  \t\telse:\n  \t\t\tpass\n  \n  \n  \treturn countCertain + min(countSurprise, surprises)\n  \n  if __name__ == '__main__':\n  \tinp = open(FILE_NAME_BASE + '.in.txt', 'r')\n  \tnumCases = int(inp.readline())\n  \tif NUM_PROCESSES == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(NUM_PROCESSES)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(FILE_NAME_BASE + '.out.txt', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n <CODESPLIT> ","completion":" 23"}
{"prompt":" \n  def isPalindrome(n):\n      cn=str(n)\n      return (cn==cn[::-1])\n  \n  palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]\n  \n  \n  \n              \n          \n          \n  \n  \n  \n  def Solve(a,b):\n      num=0\n      for p in palinSqrt:\n          if a<= p**2 <=b: num+=1\n      return num\n  \n  \n  \n  def parse(infile):\n      a,b=map(int, infile.readline().split() )\n      return a,b\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  class Categorizer(dict):\n      def __init__(self,thelist,transform,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.AddList(thelist)\n          self.trunc=trunc\n      def AddList(self,thelist):\n          for item in thelist: self.Add( item )\n      def Add(self,object):\n          cat=self.transform( object )\n          if type(cat) is float:\n              cat=round(cat,trunc)\n          if self.has_key(cat):\n              self[cat].append( object )\n          else:\n              self[cat]=[object]\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-len(x[1]))\n          total=0\n          for i in items: total+=len(i[1])\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(len(val))) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,len(count),\n                                     (\"%.2f\"%(len(count)*100.0\/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=[]\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=len(self[key])\n              avg+=len(self[key])*key\n          return avg\/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=len(self[key])\n              stddev += len(self[key]) * ( (key-avg)**2)\n          return stddev\/(1.0*ntot)\n      def Median(self):\n          tot=0\n          for value in self.itervalues(): tot+=len(value)\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += len(self[key])\n             if nCount>tot\/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n  \n  \n  \n  \n  class Counter(dict):\n      def __init__(self,thelist,transform=None,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.trunc=trunc\n          self.AddList(thelist)\n      def AddList(self,thelist):\n          if self.transform is not None:\n              for item in thelist: self.Add( self.transform(item) )\n          else:\n              for item in thelist: self.Add( item )            \n      def Add(self,object):\n          if type(object) is float:\n              object=round(object,self.trunc)\n          if self.has_key(object):\n              self[object]+=1\n          else:\n              self[object]=1\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-x[1])\n          total=0\n          for i in items: total+=i[1]\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(val)) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,count, (\"%.2f\"%(count*100.0\/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=0\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=self[key]\n              avg+=self[key]*key\n          return avg\/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=self[key]\n              stddev += self[key] * ( (key-avg)**2)\n          return stddev\/(1.0*ntot)\n      def Median(self):\n   \ttotal=sum(self.values())\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += self[key]\n             if nCount>total\/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: x[1])[0]\n  \n  \n  def gen_primes():\n      \"\"\" Generate an infinite sequence of prime numbers.\n      \"\"\"\n      D = {}  \n      q = 2  \n  \n      while True:\n          if q not in D:\n              yield q        \n              D[q * q] = [q]\n          else:\n              for p in D[q]:\n                  D.setdefault(p + q, []).append(p)\n              del D[q]\n  \n          q += 1\n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n <CODESPLIT> ","completion":" 24"}
{"prompt":" \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  for iCase in xrange(NumCases):\n      line=[ int(i) for i in infile.readline().split() ]\n  \n      n=line.pop(0)\n      s=line.pop(0)\n      p=line.pop(0)\n  \n      scores=line\n      assert(len(scores))==n\n  \n      imax=0\n      isurprise=0\n  \n      for score in scores:\n          if score<p: continue\n          if score<3*p-4:\n              pass\n          elif 3*p-2>score>=3*p-4:\n              isurprise+=1\n          else:\n              imax+=1\n  \n      print 'Case #'+str(iCase+1)+':',imax+min(isurprise,s)\n  \n <CODESPLIT> ","completion":" 24"}
{"prompt":" \n  lines = sys.stdin.readlines()\n  def parseCase(lines):\n      dims = map(int,lines[0].split(\" \"))\n      return 1, dims\n  \n  def getCases(lines):\n      i =0\n      while i < len(lines):\n          lines_used, case = parseCase(lines[i:])\n          i += lines_used\n          yield case\n  \n  \n  fands = []\n  phash = {1:True}\n  def isPalindrome(p):\n      return p in phash\n  \n  def test(p):\n      square = p**.5\n      return square == int(square) and isPalindrome(int(square))\n  \n  for i in range(1,10**5):\n      if i > 9:\n          small_p = int(i * 10 ** int(math.log(i,10)) + int(\"\".join(reversed(str(i)[:-1]))))\n      else: small_p = i\n      phash[small_p]= test(small_p)\n      if phash[small_p]: fands.append(small_p)\n      big_p = int(i * 10 ** int(math.log(i,10)+1) + int(\"\".join(reversed(str(i)))))\n      phash[big_p] = test(big_p)\n      if phash[big_p]: fands.append(big_p)\n  cNum =0\n  \n  for c in getCases(lines[1:]):\n      cNum += 1\n      answer = []\n      for i in fands:\n          if i < c[0]: continue\n          if i > c[1]: break\n          if phash[i]: answer.append(i)\n      answer = str(len(answer))\n      print \"Case #%d: %s\" % ( cNum, answer)\n  \n  \n      \n  \n  \n <CODESPLIT> ","completion":" 25"}
{"prompt":" \"\"\"\n  GCJ framework (gcj.fw.framework)\n   - Command Line and Package interface\n   - output redirection\n   - parsing case input\n   - executing problem code against cases\n   - testing framework\n  \"\"\"\n  \n  class Framework(object):\n      class Case(object):\n          def __init__(self, caseNumber, caseData=None):\n              self.number = caseNumber\n              self.data = caseData\n              self.result = None\n      \n          @classmethod\n          def parser(cls, f_in):\n              pass\n      \n          def run(self):\n              pass\n      \n          def execute(self, f_in=None):\n              if self.data is None:\n                  self.data = self.parser(f_in)\n              self.result = self.run(**self.data)\n      \n          def __str__(self):\n              return \"Case #%d: %s\" % (self.number, self.result)\n      \n      \n      class Result(object):\n          def __init__(self, resultData):\n              self.data = resultData\n      \n          def __str__(self):\n              return str(self.ata)\n  \n      def __init__(self, f_in, f_out):\n          sys.stdout = f_out\n          self.f_in = f_in if f_in is not None else sys.stdin\n  \n      def run(self):\n          nCases = int(self.f_in.readline().strip())\n          for num in xrange(nCases):\n              case = type(self).Case(num+1)\n              case.execute( f_in=self.f_in)\n              print case\n  \n  \n      @classmethod\n      def __main__(cls):\n          f_in = sys.stdin\n          if len(sys.argv) > 1:\n              if sys.argv[1] == \"-t\":\n                  unittest.main()\n                  sys.exit()\n              f_in = open(sys.argv[1])\n          framework = cls(f_in, sys.stdout)\n          framework.run()\n      \n  class Test(unittest.TestCase):\n      cases = []\n      case = None\n      c=[]\n      \n      def setUp(self):\n          self.c = []\n          self.defineCases()\n          counter = 1\n          self.cases = []\n          for c in self.c:\n              case = self.case(counter)\n              case.data = case.parser(StringIO.StringIO(c[0]))\n              self.cases.append( [case, c[1]])\n      \n      def defineCases(self):\n          pass\n      \n      def tearDown(self):\n          pass \n  \n      def test_Name(self):\n          self.setUp()\n          for case in self.cases:\n              print case[0].data, case[1]\n              case[0].execute()\n              self.assertEqual(case[0].result, case[1])\n  '''\n  Created on Apr 8, 2012\n  \n  @author: Joe\n  '''\n  \n  \n  class B(Framework):\n      class Case(Framework.Case):\n          def parser(self, fh):\n              args = map(int, fh.readline().strip().split(\" \"))\n              N,S,p = args[:3]\n              scores = args[3:] \n              return {\"N\":N,\"S\":S,\"p\":p,\"scores\":scores}\n          \n          def run(self, N=None,S=None,p=None,scores=None):\n              ret = 0\n              surps = 0\n              for score in scores:\n                  if p > 0 and score == 0: continue\n                  if 3*p-2 <= score:\n                      ret += 1\n                  else:\n                      if 3*p - 4 <= score:\n                          surps += 1\n              return str(ret + min(surps,S))\n              \n  class Test(Test):\n      def defineCases(self):\n          self.case = B.Case\n          self.c = [\n                    [\"3 1 5 15 13 11\",\"3\"],\n                    [\"3 0 8 23 22 21\",\"2\"],\n                    [\"2 1 1 8 0\",\"1\"],\n                    [\"6 2 8 29 20 8 18 18 21\",\"3\"],\n                    [\"1 1 1 1\", \"1\"]\n                    ]\n  \n  if __name__ == \"__main__\":\n      B.__main__()\n      \n <CODESPLIT> ","completion":" 25"}
{"prompt":"def is_palindrome(s):\n  \tif s == '':\n  \t\treturn True\n  \telse:\n  \t\tif (ord(s[0]) - ord(s[len(s)-1])) == 0:\n  \t\t\treturn is_palindrome(s[1 : len(s) - 1])\n  \t\telse:\n  \t\t\treturn False\n  \n  all_fair_and_square = set()\n  for i in range(10000):\n  \torig = str(i)\n  \trev = orig[::-1]\n  \n  \tpalin = orig + rev\n  \tintpalin = int(palin)\n  \tif is_palindrome(str(intpalin * intpalin)):\n  \t\tall_fair_and_square.add(intpalin * intpalin)\n  \n  \tpalin = orig[:-1] + rev\n  \tintpalin = int(palin)\n  \tif is_palindrome(str(intpalin * intpalin)):\n  \t\tall_fair_and_square.add(intpalin * intpalin)\n  \t\n  \n  \n  t = int(sys.stdin.readline().strip())\n  for ii in range(t):\n  \tline = sys.stdin.readline().strip().split()\n  \ta = int(line[0])\n  \tb = int(line[1])\n  \tcount = 0\n  \tfor num in all_fair_and_square:\n  \t\tif (num >= a) and (num <= b):\n  \t\t\tcount += 1\n  \tprint \"Case #\" + str(ii + 1) + \": \" + str(count)\n  \n <CODESPLIT> ","completion":" 26"}
{"prompt":" \n  t = int(sys.stdin.readline())\n  for i in range(t):\n  \tinputline = sys.stdin.readline().strip()\n  \tinputparams = inputline.split()\n  \n  \tn = int(inputparams[0])\n  \ts = int(inputparams[1])\n  \tp = int(inputparams[2])\n  \tvalidcount = 0\n  \tsurprisingcount = 0\n  \tfor j in range(n):\n  \t\tscore = int(inputparams[3 + j])\n  \t\tif (p + (p - 1) * 2) <= score:\n  \t\t\tvalidcount += 1\n  \t\telif ((p + (p - 2) * 2) <= score) and (p <= score):\n  \t\t\tsurprisingcount += 1\n  \n  \tprint \"Case #%d: %d\" % (i + 1, validcount + min(surprisingcount, s))\n <CODESPLIT> ","completion":" 26"}
{"prompt":" \n  \n  fairsquares = []\n  \n  \n  def read_fairsquares():\n      global fairsquares\n      f = open('fairsquares.txt')\n      for x in f:\n          fairsquares.append(int(x.strip()))\n  \n  \n  def count_less_than(A):\n      left = 0\n      right = len(fairsquares)\n      while left < right:\n          middle = (left + right) \/\/ 2\n          if fairsquares[middle] < A:\n              left = middle + 1\n          else:\n              right = middle\n      return left\n  \n  \n  def compute(A, B):\n      count_b = count_less_than(B + 1)\n      count_a = count_less_than(A)\n      return count_b - count_a\n  \n  \n  def parse():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  \n  if __name__ == \"__main__\":\n      read_fairsquares()\n      T = int(sys.stdin.readline().strip())\n      count = 1\n      part = 0\n      if len(sys.argv) == 3:\n          part = int(sys.argv[1])\n          count = int(sys.argv[2])\n      for i in xrange(T):\n          data = parse()\n          if i * count >= part * T and i * count < (part + 1) * T:\n              result = compute(*data)\n              print \"Case #%d: %s\" % (i + 1, result)\n <CODESPLIT> ","completion":" 27"}
{"prompt":" \n  \n  if __name__ == \"__main__\":\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          values = map(int, sys.stdin.readline().strip().split(' '))\n          _N, S, p = values[0:3]\n          t = values[3:]\n          min_normal = p + 2 * max(0, p - 1)\n          min_surprising = p + 2 * max(0, p - 2)\n          cnt_normal = len(filter(lambda x : x >= min_normal, t))\n          cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal\n          print \"Case #%d: %s\" % (i + 1, cnt_normal + min(cnt_surprising, S))\n <CODESPLIT> ","completion":" 27"}
{"prompt":" \n  def get_generators_up_to_length_n(n):\n      generators = []\n      for ii in range(1, n + 1):\n          generators += get_generators_length_n(ii)\n      return generators        \n  \n  def get_generators_length_n(length):\n      if length % 2 == 0: return get_even_generators_length_n(length)\n      else: return get_odd_generators_length_n(length)\n  \n  def get_odd_generators_length_n(length):\n      if length == 1: return [1, 2, 3]\n      else: \n          n = length \/ 2\n          generators = []\n          for ii in range(min(n, 4)):\n              for comb in itertools.combinations(range(1, n), ii):\n                  first_half = [\"1\"] + [\"0\"] * (n-1)\n                  for jj in comb:\n                      first_half[jj] = \"1\"\n                  second_half = list(first_half)\n                  second_half.reverse()\n                  palin = first_half + [\"0\"] + second_half\n                  generators.append(int(\"\".join([elem for elem in palin])))\n                  palin[n] = \"1\"\n                  generators.append(int(\"\".join([elem for elem in palin])))\n                  if ii <= 1:\n                      palin[n] = \"2\"\n                      generators.append(int(\"\".join([elem for elem in palin])))\n          generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (n - 1) + [\"0\"] + [\"0\"] * (n - 1) + [\"2\"])])))\n          generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (n - 1) + [\"1\"] + [\"0\"] * (n - 1) + [\"2\"])])))\n          generators.sort()\n          return generators\n  \n  def get_even_generators_length_n(length):\n      if length == 2: return [11, 22]\n      n = length \/ 2\n      generators = []\n      for ii in range(min(n, 4)):\n          for comb in itertools.combinations(range(1, n), ii):\n              first_half = [\"1\"] + [\"0\"] * (n-1)\n              for jj in comb:\n                  first_half[jj] = \"1\"\n              second_half = list(first_half)\n              second_half.reverse()\n              palin = first_half + second_half\n              generators.append(int(\"\".join([elem for elem in palin])))\n      generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (length - 2) + [\"2\"])])))\n      generators.sort()\n      return generators\n  \n  def is_palin(num):\n      string = str(num)\n      length = len(string)\n      ii = 0\n      while ii < length\/2:\n          if string[ii] != string[-(1+ii)]:\n              return False\n          ii += 1\n      return True\n  \n  def gen_fair_and_squares(upper_limit):\n      fair_and_squares = []\n      for ii in range(1, upper_limit + 1):\n          if (is_palin(ii) and is_palin(ii*ii)):\n              fair_and_squares.append(ii)\n      return fair_and_squares\n  \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  gens = get_generators_up_to_length_n(60)\n  squares = map(lambda x: x*x, gens)\n  \n  for t in range(T):\n      A, B = map(int, f.readline().strip().split())\n      total = 0\n      for elem in squares:\n          assert(is_palin(elem))\n          if elem >= A and elem <= B: total += 1\n          if elem > B:\n              break\n  \n      print \"Case #%d:\" % (t + 1), total\n <CODESPLIT> ","completion":" 28"}
{"prompt":" \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      temp = map(int, f.readline().split())\n      N = temp[0]\n      S = temp[1]\n      p = temp[2]\n      scores = temp[3:]\n      non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))\n      if (p<=1):\n          surprising_scores = 0\n      else:\n          surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))\n      num_scores = non_surprising_scores + min(surprising_scores, S)   \n      print \"Case #%d:\" % (t + 1), num_scores\n <CODESPLIT> ","completion":" 28"}
{"prompt":" \n  \n  \t\t\n  \t\n  def isPalindrome(S):\n  \ts = str(S) #so I dont need to make sure its a string\n  \tfor i in range(len(s)\/\/2):\n  \t\tif not s[i] == s[-1 - i]:\n  \t\t\treturn False\n  \treturn True\n  \n  def FairAndSquare(infile=\"C-small-attempt0.in\", outfile=\"C-small-attempt0.out\"):\n  \tinF = open(infile, 'r')\n  \toutF = open(outfile, 'w')\n  \t\n  \tfor t in range(1, int(inF.readline().strip()) + 1):\n  \t\ttemp = inF.readline().strip().split()\n  \t\tA = long(temp[0])\n  \t\tB = long(temp[1])\n  \t\tcount = long(0)\n  \t\t\n  \t\ti = long(math.ceil(math.sqrt(A)))\n  \t\tm = long(math.floor(math.sqrt(B)))\n  \t\twhile i <= m:\n  \t\t\tif isPalindrome(i):\n  \t\t\t\tif isPalindrome(i**2):\n  \t\t\t\t\tcount += 1\n  \t\t\ti += 1\n  \t\t\t\t\t\n  \t\toutF.write(\"Case #\" + str(t) + \": \" + str(count) + \"\n\")\n  \t\n  \tinF.close()\n  \toutF.close()\n  \t\n  \tf = open(outfile, 'r')\n  \tprint f.read()\n  \tf.close()\n  \t\n  \t\n  if __name__ == \"__main__\":\n      FairAndSquare()\n <CODESPLIT> ","completion":" 29"}
{"prompt":"data_dict = {}\n  init = False\n  \n  \n  def partB(infile=\"C:\/Users\/Jeffrey\/Dropbox\/Google Code Jam\/2011\/Qualifiers\/B\/input3.txt\",\\\n                outfile=\"C:\/Users\/Jeffrey\/Dropbox\/Google Code Jam\/2011\/Qualifiers\/B\/output.txt\"):\n      \n      linesA = []\n      for line in open(infile, 'r'):\n          linesA.append(line.strip())\n  \n      outA = []\n          \n      T = int(linesA[0])\n      for i in range(1, 1 + T):\n          caseA = linesA[i].split()\n          N = int(caseA[0])\n          S = int(caseA[1])\n          P = int(caseA[2])\n          \n          over_norm = 0\n          over_supr = 0\n          \n          for t in [int(conv) for conv in caseA[3:3+N]]:\n              if data_dict[t][0] >= P:\n                  over_norm += 1\n              elif data_dict[t][1] >= P:\n                  over_supr += 1\n          \n          outA.append(over_norm + min(over_supr, S))\n              \n              \n          \n      \n      out = open(outfile, 'w')\n      print \"\nOUTPUT\"\n      for i in range(1, 1 + T):\n          if i != 1:\n              out.write(\"\n\")\n          print \"Case #\" + str(i) + \": \" +str(outA[i-1])\n          out.write(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n      out.close()\n  \n  def dict_helper(total, depth=0, lowest=10):\n      pass\n  \n  def build_dict():\n      for i in range(31):\n          fullA = []\n          maxN = 0\n          maxS = 0\n          print str(i) + \": \"\n          for a1 in range(0,11):\n              for a2 in range(0,11):\n                  for a3 in range(0,11):\n                      if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):\n                          fullA.append((a1,a2,a3))\n                          \n                          print \"\\t\", fullA[-1],\n                          if max(a1,a2,a3)-min(a1,a2,a3) == 2:\n                              print \"*\"\n                              maxS = max(maxN, max(a1,a2,a3))\n                          else:\n                              print\n                              maxN = max(maxN, max(a1,a2,a3))\n          data_dict[i]=[maxN, maxS]\n      init = True\n      \n  if __name__ == \"__main__\":\n      build_dict()\n      partB()\n <CODESPLIT> ","completion":" 29"}
{"prompt":"\"\"\"Usage:\n      X.py < X.in > X.out\n  \"\"\"\n  \n  def isqrt(x):\n      \"returns int(floor(sqrt(x))) using only integer math\"\n      assert x >= 0, 'Undefined %r' % locals()\n      n = int(x)\n      if n == 0:\n          return 0\n      a, b = divmod(n.bit_length(), 2)\n      x = 2**(a+b)\n      while True:\n          y = (x + n\/\/x)\/\/2\n          if y >= x:\n              return x\n          x = y\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, **ignore):\n      P = map(int, infile.next().split())\n      return locals()\n  \n  def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      low = isqrt(P[0])\n      high = isqrt(P[1])+1\n  \n      def is_pal(n):\n          n = str(n)\n          for i in range(len(n)\/2+1):\n              if n[i]!=n[len(n)-1-i]:\n                  return False\n          return True\n  \n      res = 0\n      for i in range(low, high+1):\n          if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):\n              res += 1\n  \n      return 'Case #%s: %s\n' % (testcase, res)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n <CODESPLIT> ","completion":" 30"}
{"prompt":"\"\"\"Usage:\n      X.py < X.in > X.out\n  \"\"\"\n  \n  \n  \n  class Solver(object):\n      cache = {}\n  \n      def __init__(self, infile, testcase):\n          self.testcase = testcase\n          self.P = P = map(int, infile.next().split())\n  \n      def init_cache(self):\n          if 'main' in self.cache:\n              return\n  \n      def solve(self):\n  \n          N, S, p = self.P[:3]\n          G = sorted(self.P[3:], reverse=True)\n  \n          r = 0\n          s = 0\n          for g in G:\n              if g >= 3 * p - 2 and g >= p:\n                  r += 1\n              elif g >= 3 * p - 4 and g >= p:\n                  if s == S:\n                      break\n                  r += 1\n                  s += 1\n  \n          return r\n  \n  \n  def main():\n      T = int(sys.stdin.next())\n      for t in xrange(T):\n          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> ","completion":" 30"}
{"prompt":" \n  def is_fair(n):\n      n = str(n)\n      for i in range(long(len(n) \/ 2)):\n          if n[i] != n[len(n) - i - 1]:\n              return False\n      return True\n  \n  def is_square_and_fair(n):\n      if not is_fair(n): return False\n      root = math.sqrt(n)\n      if root != math.floor(root): return False\n      if not is_fair(long(root)): return False\n      return True\n  \n  def process():\n      a, b = sys.stdin.readline().split()\n      a = long(a)\n      b = long(b)\n      \n      count = 0\n      for i in range(a, b + 1):\n          if is_square_and_fair(i): count = count + 1\n  \n      return count\n  \n  def main():\n  \n      count = int(sys.stdin.readline())\n      for index in range(count):\n          result = process()\n          print \"Case #%d: %s\" % (index + 1, result)\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> ","completion":" 31"}
{"prompt":" \n  \n  def calculate_max_score(scores_sum):\n      if scores_sum % 3 == 1:\n          max_score = (scores_sum + 2) \/ 3\n          return (max_score, max_score)\n      if scores_sum % 3 == 2:\n          max_score = (scores_sum + 1) \/ 3\n          return (max_score, max_score + 1)\n      max_score = scores_sum \/ 3\n      if max_score == 0:\n          return (0, 0)\n      return (max_score, max_score + 1)\n  \n  def find_max_dancers(s, p, *scores_sums):\n      dancers_count = 0\n      for scores_sum in scores_sums:\n          (normal_max, surprise_max) = calculate_max_score(scores_sum)\n          if normal_max >= p:\n              dancers_count = dancers_count + 1\n              continue\n          if surprise_max >= p and s > 0:\n              s = s - 1\n              dancers_count = dancers_count + 1\n              continue\n      return dancers_count\n  \n  def main():\n  \n      case_count = int(sys.stdin.readline())\n  \n      for case_index in range(1, case_count + 1):\n          line = sys.stdin.readline().strip().split(' ')\n          s = int(line[1])\n          p = int(line[2])\n          scores_sums = [int(scores_sum) for scores_sum in line[3:]]\n          print 'Case #%i: %s' % (case_index, find_max_dancers(s, p, *scores_sums))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> ","completion":" 31"}
{"prompt":"'''\n  Created on Apr 12, 2013\n  \n  @author: Moatasem\n  '''\n  \n  \n  \n  def isPalindrome(word):\n      isPalin=False\n      if(len(word)%2==0):\n          f_half=word[0:len(word)\/2];\n          s_half=word[len(word)\/2:len(word)][::-1]\n          if( f_half==s_half):\n              isPalin= True\n      else:\n          f_half=word[0:len(word)\/2]\n          s_half=word[(len(word)\/2)+1:len(word)][::-1]\n          if( f_half==s_half):\n              isPalin= True\n      return isPalin\n      \n  def getNumberOfFairAndSquare(range_):\n      start=range_[0]\n      end=range_[1]\n      count_=0\n      for i in range(start,end+1):\n          root=math.sqrt(i);\n          if(root.is_integer() and isPalindrome(str(int(root))) and isPalindrome(str(i))):\n              count_+=1\n      return count_\n          \n          \n      \n  \n  f_r = open('C.in',\"r\")\n  n_test=int(f_r.readline().strip()) \n  f_w = open(\"C.out\", \"w\")\n  for i in range(n_test):\n      range_ =map(int,f_r.readline().split())\n      result=getNumberOfFairAndSquare(range_)\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n  f_r.close()\n  f_w.close()\n <CODESPLIT> ","completion":" 32"}
{"prompt":"'''\n  Created on Apr 14, 2012\n  \n  @author: moatasem\n  '''\n  \n  \n  def isSurprising(t):\n      if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):\n          return True\n      else:\n          return False\n  \n  \n  def getAllTriplets(n):\n      h=[]\n      for i in xrange(11):\n          for j in xrange(i,11):\n              for  k in xrange(j,11):\n                  if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):\n                      h.append((i,j,k))\n              \n      return  h\n  \n  def getInfo(p,total,S):\n      g= getAllTriplets(total)\n      if(S):\n          s_=len(g)\n          indcies=[]\n          for i in xrange (s_):\n              if(isSurprising(g[i])):\n                  indcies.append(i)\n          for i in xrange (len(indcies)):  \n              g.remove(g[indcies[i]])\n      equ=False\n      sur=False\n      sur_equ=False\n      for i in xrange(len(g)):\n          if(max(g[i])>=p):\n              if(isSurprising(g[i])):\n                  sur_equ=True\n              else:\n                  equ=True\n          elif(isSurprising(g[i])):\n                  sur=True\n      return sur_equ,equ,sur\n             \n  f = open(\"b_.in\", \"r\")\n  n=int(f.readline().strip())\n  for k  in xrange(n):\n      d=f.readline().strip()\n      googlers=[]\n      g=[int(i) for i in d.split(\" \")]\n      N=g[0]\n      S=g[1]\n      noSu=False\n      if(S==0):\n          noSu=True\n      p=g[2]\n      count=0\n      equ_count=0;\n      both_count=0;\n      sur_count=0;\n      first_count=0;\n      googlers=g[3:len(g)]\n      for o in xrange(N):\n          info=getInfo(p,googlers[o],noSu)\n          if(info[0]==True and info[1]==False and S<>0): #101 \/100\n              count+=1\n              S-=1\n          elif(info[0]==True and info[1]==True):#110 \/ 111\n              first_count+=1\n          elif(info[1]==True and info[2]==True):#011\n              both_count+=1\n          elif(info[1]==True):#010\n              count+=1\n          elif(info[2]==True):#001\n              sur_count+=1\n      count+=first_count\n      if(S>0):\n          if(first_count>S):\n              S=0\n          elif(first_count <=S) :\n              S-=first_count\n              if(S>0):\n                   if(both_count>S):\n                      both_count-=S\n                      S=0\n                   else:\n                      both_count=0\n      count+=both_count\n      \n      print 'Case #'+str((k+1))+\": \"+str(count)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n      \n  \n <CODESPLIT> ","completion":" 32"}
{"prompt":" \n  def isqrt(num):\n      return int(sqrt(num))\n  \n  def is_square(num):\n      return isqrt(num)**2 == num\n  \n  def is_palindrome(num):\n      return str(num) == \"\".join(reversed(str(num)))\n  \n  def is_fair_and_square(num):\n      return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))\n  \n  def solve(A,B):\n      count = 0\n      for i in range(A,B+1):\n          if is_fair_and_square(i):\n              count += 1\n      return count\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          A,B = [int(x) for x in raw_input().split()]\n          print \"Case #%d: %d\" % (i, solve(A,B))\n          \n <CODESPLIT> ","completion":" 33"}
{"prompt":"def max_of_triplets(n):\n      a = n\/\/3\n      if (n % 3) == 0:\n          if a == 0 : return (0,0)\n          return (a, a+1)\n      if (n % 3) == 1:\n          return (a+1, a+1)\n      if a == 9: return (10, 10)\n      return (a+1, a+2)\n  \n  def solve(scores, S, p):\n      t = 0\n      for s in scores:\n          a,b = max_of_triplets(s)\n          if a >= p:\n              t += 1\n          elif b >= p and S > 0:\n              t += 1\n              S -= 1\n      return t\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          nums = map(int, raw_input().strip().split())\n          N = nums[0]\n          S = nums[1]\n          p = nums[2]\n          scores = nums[3:]\n          if len(scores) != N:\n              print \"WTF\", i\n          print \"Case #%d: %d\" % (i, solve(scores, S, p))\n      \n <CODESPLIT> ","completion":" 33"}
{"prompt":" \n  def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      A, B = read_integers()\n      A_root = int( ceil( sqrt( A ) ) )\n      B_root = int( floor( sqrt( B ) ) )\n      count = 0\n      for root in range( A_root, B_root + 1 ):\n          word = str( root )\n          if word == word[ : : -1 ]:\n              word = str( root*root )\n              if word == word[ : : -1 ]:\n                  count += 1\n      print 'Case #%i:' % ( t + 1 ), count\n <CODESPLIT> ","completion":" 34"}
{"prompt":"def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 ),\n      line = iter( read_integers() )\n      N = line.next()\n      S = line.next()\n      p = line.next()\n      t = sorted( line )\n      count = 0\n      while t and ( t[ -1 ] + 2 )\/3 >= p:\n          t.pop()\n          count += 1\n      if p > 1:\n          while S and t and ( t[ -1 ] + 4 )\/3 >= p:\n              t.pop()\n              S -= 1\n              count += 1\n      print count\n <CODESPLIT> ","completion":" 34"}
{"prompt":" \n  def isPalindrome(x):\n      x = str(x)\n      if x[0] != x[-1]:\n          return 0\n      y = x[::-1]\n      if x == y:\n          return 1\n      return 0\n  \n  def generate():\n      digits = [str(x) for x in range(0,10)]\n      dplus = digits + [\"\"]\n  \n      for x in range(1,10):\n          y = x**2\n          if isPalindrome(y):\n              print y\n  \n      for x in range(1,10**4):\n          x = str(x)\n          y = x[::-1]\n          pals = [ int(x+z+y)**2 for z in dplus ]\n          for p in pals:\n              if isPalindrome(p):\n                  print p\n  \n  if __name__ == \"__main__\":\n      f = open( sys.argv[1] )\n      sqpals = np.array([int(l) for l in f])\n      sqpals.sort()\n      f.close()\n  \n      f = open( sys.argv[2] )\n      t = int(f.readline())\n      t = 1\n      for l in f:\n          a,b = [int(x) for x in l.split()]\n          mt = sqpals >= a\n          lt = sqpals <= b\n          output = sum( mt&lt )\n          print \"Case #%s: %s\"%(t,output)\n          t += 1\n      \n <CODESPLIT> ","completion":" 35"}
{"prompt":" \n  \n  if __name__ == \"__main__\":\n  \n      f = open( \"B-small-attempt1.in.txt\" )\n      g = open( \"output_small.txt\", \"w\" )\n  \n      f.readline()\n      line = f.readline()\n      caseI = 1\n      while line != \"\":\n          line = [ int(x) for x in line.split() ]\n          N = line[0]\n          surprise = line[1]\n          p = line[2]\n          points = line[3:]\n          points.sort()\n          points.reverse()\n  \n          maxp = 0\n          either = 0\n          make_surprise = 0\n          for x in points:\n              this_p = (x+2)\/3\n              if x in [0,1,29,30]:\n                  if this_p >= p:\n                      maxp += 1\n              elif this_p >= p:\n                  either += 1\n                  maxp += 1\n              elif this_p == p-1 and (x+2)%3 > 0:\n                  make_surprise += 1\n              else:\n                  either += 1\n  \n          if make_surprise >= surprise:\n              make_surprise -= surprise\n              maxp += surprise\n              make_surprise = 0\n          else:\n              maxp += make_surprise\n  \n          g.write( \"Case #%s: %s\n\"%(caseI,maxp) )\n  \n          line = f.readline()\n          caseI += 1\n  \n      f.close()\n      g.close()\n      \n <CODESPLIT> ","completion":" 35"}
{"prompt":" \n  possibles = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]\n  \n  for case in xrange(codejam.readint()):\n      A, B = map(int, codejam.readstring().split())\n      count = 0\n      for possible in possibles:\n          if A > possible:\n              continue\n  \n          if B < possible:\n              break\n  \n          count += 1\n  \n      print \"Case #%d: %d\" % (case + 1, count)\n <CODESPLIT> ","completion":" 36"}
{"prompt":" \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n <CODESPLIT> ","completion":" 36"}
{"prompt":" \n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tyield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 1\n  \t\tcase = []\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not line_index % n:\n  \t\t\t\tyield case_counter, case\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 0\n  \t\tnew_case = True\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tif new_case:\n  \t\t\t\tnew_case = False\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\n  \t\t\t\tlines_left = int(line.strip())\n  \t\t\t\tif not lines_left:\n  \t\t\t\t\tnew_case = True\n  \t\t\t\t\tyield case_counter, case\n  \t\t\t\tcontinue\n  \t\t\tif lines_left:\n  \t\t\t\tlines_left -= 1\n  \t\t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not lines_left:\n  \t\t\t\tnew_case = True\n  \t\t\t\tyield case_counter, case\n  \t\t\t\n  def part_of_list_to_int(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(int(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_int(array):\n  \treturn part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(float(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_float(array):\n  \treturn part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  \telem_len = len(array[0])\n  \tassert index < elem_len\n  \tfor elem in array:\n  \t\tassert elem_len == len(elem)\n  \tmax_sub = array[0][index]\n  \tmax_elem = array[0]\n  \tfor elem in array:\n  \t\tif elem[index] > max_sub:\n  \t\t\tmax_sub = elem[index]\n  \t\t\tmax_elem = elem\n  \treturn max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  \tlist_len = len(a_list)\n  \tif list_len == 1:\n  \t\tif a_list[0] == value:\n  \t\t\treturn pos\n  \t\treturn -1\n  \tif a_list[list_len\/2] > value:\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len\/2)], value, pos)\n  \telse:\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len\/2):], value, pos + (list_len\/2))\n  \t\n  def list_index_in_sorted_list(a_list, value):\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\n  \t\n  def check_palindrome(value):\n  \tval_str = str(value)\n  \tlength = len(val_str)\n  \tfor i in xrange(length):\n  \t\tif val_str[i] != val_str[length - 1 - i]:\n  \t\t\treturn False\n  \treturn True\n  \n  def calc_result(case):\n  \tA = int(case[0])\n  \tB = int(case[1])\n  \t\n  \tA_sqrt = int(math.ceil(math.sqrt(A)))\n  \tB_sqrt = int(math.floor(math.sqrt(B)))\n  \t\n  \tprint \"\\tinterval: %s\" % [A, B]\n  \tprint \"\\tsqrt_int: %s\" % [A_sqrt, B_sqrt]\n  \t\n  \tcount = 0\n  \tfor i in xrange(A_sqrt, B_sqrt + 1):\n  \t\tif check_palindrome(i):\n  \t\t\tif check_palindrome(i * i):\n  \t\t\t\tcount += 1\n  \t\t\t\tprint \"\\tfound: %d, %d\" % (i, i * i)\n  \t\n  \tprint \"\\ttot: %d\" % count\n  \tprint \n  \tresult = \"%s\" % count\n  \treturn result\n  \n  def main(filepath):\n  \tstart_time = time.time()\n  \twith file('output.txt', 'wb') as f_out:\n  \t\t\n  \t\tfor case_index, case in iterate_cases_1lpc(filepath):\n  \t\t\t\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\n  \t\t\tresult = calc_result(case)\n  \t\t\t\n  \t\t\tf_out.write(\"Case #%d: %s\n\" % (case_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n <CODESPLIT> ","completion":" 37"}
{"prompt":" \n  class Triplet(object):\n  \tdef __init__(self, i, j, k):\n  \t\tself.i = i\n  \t\tself.j = j\n  \t\tself.k = k\n  \t\tself.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))\n  \t\tself.valid = self.max_diff <= 2\n  \t\tself.surprise = self.max_diff == 2\n  \t\n  \tdef get_tuple(self):\n  \t\treturn (self.i, self.j, self.k)\n  \t\n  \tdef get_redundancies(self):\n  \t\treturn [(self.i, self.j, self.k),\n  \t\t\t\t(self.i, self.k, self.j),\n  \t\t\t\t(self.j, self.i, self.k),\n  \t\t\t\t(self.j, self.k, self.i),\n  \t\t\t\t(self.k, self.i, self.j),\n  \t\t\t\t(self.k, self.j, self.i)]\n  \n  class Googler(object):\n  \tdef __init__(self, total_points):\n  \t\tself.total_points = total_points\n  \t\tself.regular_triplets = []\n  \t\tself.surprise_triplets = []\n  \t\t\n  \t\tfor i in xrange(0, 11):\n  \t\t\tif i > total_points:\n  \t\t\t\tbreak\n  \t\t\tfor j in xrange(i, 11):\n  \t\t\t\tif i + j > total_points:\n  \t\t\t\t\tbreak\n  \t\t\t\tk = total_points - i - j\n  \t\t\t\tif k > 10:\n  \t\t\t\t\tbreak\n  \t\t\t\ttriplet = Triplet(i, j, k)\n  \t\t\t\tself.add(triplet)\n  \t\t\n  \t\tself.can_surprise = len(self.surprise_triplets) > 0\n  \t\tself.actual_triplet = None\n  \t\tself.best_result = -1\n  \t\t\n  \tdef add(self, triplet):\n  \t\tif not triplet.valid:\n  \t\t\treturn\n  \t\tif triplet.surprise:\n  \t\t\tself.add_uniquely(triplet, is_surprise=True)\n  \t\telse:\n  \t\t\tself.add_uniquely(triplet, is_surprise=False)\n  \t\t\t\n  \tdef add_uniquely(self, triplet, is_surprise):\n  \t\tif is_surprise:\n  \t\t\tinput_list = self.surprise_triplets\n  \t\telse:\n  \t\t\tinput_list = self.regular_triplets\n  \t\tfor triplet_redundancy in triplet.get_redundancies():\n  \t\t\tif triplet_redundancy in input_list:\n  \t\t\t\treturn\n  \t\tinput_list.append(triplet.get_tuple())\n  \t\n  \tdef __str__(self):\n  \t\treturn \"regular: %s\nsurprise: %s\" % (self.regular_triplets,\n  \t\t\t\t\t\t\t\t\t\t\t  self.surprise_triplets)\n  \t\n  \tdef set_googler(self, is_surprise=False):\n  \t\tif not is_surprise:\n  \t\t\tself.actual_triplet = self.regular_triplets[0]\n  \t\telse:\n  \t\t\tself.actual_triplet = self.surprise_triplets[0]\n  \t\tself.calc_best_result()\n  \t\n  \tdef calc_best_result(self):\n  \t\tself.best_result = max(self.actual_triplet)\n  \n  \t\t\n  class Contest(object):\n  \tdef __init__(self, num_of_googlers, results):\n  \t\tself.num = num_of_googlers\n  \t\tself.googlers = []\n  \t\tfor i in xrange(self.num):\n  \t\t\tself.googlers.append(Googler(results[i]))\n  \t\n  \tdef calc(self, num_of_surprises, p):\n  \t\tmax_googlers_over_p = 0\n  \t\tfor surprise_perm in self.get_permutations(num_of_surprises):\n  \t\t\tif not self.validate_permutation(surprise_perm):\n  \t\t\t\tcontinue\n  \t\t\tcount = 0\n  \t\t\tfor index, googler in enumerate(self.googlers):\n  \t\t\t\tgoogler.set_googler(index in surprise_perm)\n  \t\t\t\tif googler.best_result >= p:\n  \t\t\t\t\tcount += 1\n  \t\t\tif count >= max_googlers_over_p:\n  \t\t\t\tmax_googlers_over_p = count\n  \t\treturn max_googlers_over_p\n  \t\n  \tdef get_permutations(self, num_of_surprises):\n  \t\tresults = get_perms(0, self.num, num_of_surprises)\n  \t\tif not results:\n  \t\t\treturn [[]]\n  \t\treturn results\n  \t\n  \tdef validate_permutation(self, perm):\n  \t\tfor googler_index in perm:\n  \t\t\tif not self.googlers[googler_index].can_surprise:\n  \t\t\t\treturn False\n  \t\treturn True\n  \n  def get_perms(start_index, finish_index, amount):\n  \tif amount == 0:\n  \t\treturn []\n  \tresult_list = []\n  \tfor i in xrange(start_index, finish_index):\n  \t\tif amount == 1:\n  \t\t\tresult_list.append([i])\n  \t\t\tcontinue\n  \t\tfor result in get_perms(i + 1, finish_index, amount - 1):\n  \t\t\tnew_result = [i]\n  \t\t\tnew_result.extend(result)\n  \t\t\tresult_list.append(new_result)\n  \treturn result_list\n  \t\t\n  def main(filepath):\n  \twith file('dancing_output.txt', 'wb') as f_out:\n  \t\twith file(filepath, 'rb') as f_in:\n  \t\t\tfor line_index, line in enumerate(f_in):\n  \t\t\t\tif line_index == 0: #T\n  \t\t\t\t\tcontinue\n  \t\t\t\tinput_list = line.strip().split(' ')\n  \t\t\t\tnum_of_googlers = int(input_list[0])\n  \t\t\t\tnum_of_surprises = int(input_list[1])\n  \t\t\t\tp = int(input_list[2])\n  \t\t\t\tresults = []\n  \t\t\t\tfor res in input_list[3:]:\n  \t\t\t\t\tresults.append(int(res))\n  \t\t\t\tcontest = Contest(num_of_googlers, results)\n  \t\t\t\tresult = contest.calc(num_of_surprises, p)\n  \t\t\t\t\n  \t\t\t\tprint\n  \t\t\t\tprint line.strip()\n  \t\t\t\tprint result\n  \t\t\t\t\n  \t\t\t\tf_out.write(\"Case #%d: %d\n\" % (line_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n <CODESPLIT> ","completion":" 37"}
{"prompt":"def IsPal(n):\n      S = str(n);\n      return S == S[::-1];\n  \n  \n  def Gen():\n      LIM = 10**14;\n      N = 10**7;\n      LIST = [];\n      for i in range(1, N):\n          if IsPal(i):\n              if IsPal(i*i):\n                  LIST.append(i);\n      return LIST\n  \n  PP = Gen();\n  \n  T = int(raw_input());\n  for q in range(1,T+1):\n      [A,B] = map(int, raw_input().split());    \n      ANS = 0;\n      for i in range(len(PP)):\n          if B >= PP[i]**2 >= A:\n              ANS += 1;\n      \n      print \"Case #%d: %d\" %(q, ANS);\n <CODESPLIT> ","completion":" 38"}
{"prompt":"T = int(raw_input());\n  for i in range(T):\n     Data = map(int, raw_input().split());\n     N = Data.pop(0);\n     S = Data.pop(0);\n     p = Data.pop(0);\n     \n     Good = 0;\n     for score in Data:\n        if score >= 3*p-2:\n           Good += 1;\n        else:\n           if (S > 0) and (score >= 3*p-4) and (score >= p):\n              S -= 1;\n              Good += 1;\n  \n     print \"Case #%d:\" % (i+1),;\n     print Good;\n     \n  \n <CODESPLIT> ","completion":" 38"}
{"prompt":" \n  def isPalindrome(s):\n    length = len(s)\n    for i in xrange(length \/ 2):\n      if s[i] != s[length - 1 - i]: \n        return False\n    return True\n  \n  n = int(raw_input())\n  for i in range(n):\n    a, b = map(int, raw_input().strip().split(' '))\n    count = 0\n    for j in range(a, b+1):\n      if isPalindrome(str(j)):\n        s = math.sqrt(j)\n        if s == int(s) and isPalindrome(str(int(s))):\n          count += 1\n    print 'Case #%i: %i' % (i+1, count)\n <CODESPLIT> ","completion":" 39"}
{"prompt":" \n  T = int(sys.stdin.readline())\n  for i in range(T):\n      line = sys.stdin.readline().strip()\n      values = map(int, line.split(' '))\n      N = values[0]\n      S = values[1]\n      p = values[2]\n      totals = values[3:]\n      ans = 0\n      for total in totals:\n          base = total \/ 3\n          remainder = total - (base * 3)\n          scores = [base, base, base]\n          j = 0\n          while remainder > 0:\n              scores[j] += 1\n              remainder -= 1\n              j = (j + 1) % 3\n          if max(scores) >= p:\n              ans += 1\n          else:\n              if S > 0:\n                  remainder = total - (base * 3)\n                  if remainder == 0 and base > 0:\n                      if base + 2 >= p:\n                          ans += 1\n                          S -= 1\n                  elif base + min(remainder, 2) >= p:\n                      ans += 1\n                      S -= 1\n      print 'Case #%s: %s' % (i+1, ans)\n <CODESPLIT> ","completion":" 39"}
{"prompt":" \n  \n  LIMIT = 10\n  \n  def check_palindrome(number):\n      rev = 0\n      runner = number\n      while runner > 0:\n          rev = rev * 10 + (runner % 10)\n          runner \/= 10\n      if rev == number:\n          return True\n      else:\n          return False\n  \n  def list_to_number(number_list):\n      l = len(number_list)\n      res = 0; rres = 0\n      multi = 1\n      for i in xrange(1, l + 1):\n          res += number_list[l - i] * multi\n          rres += number_list[i - 1] * multi\n          multi *= 10\n      return (res, rres)\n  \n  def gen_one_side(side_length):\n      state = [0 for _ in xrange(side_length)]\n      done = False\n  \n      while not done:\n          if state[-1] != 0:\n              yield state\n          state[-1] += 1\n          curr = side_length - 1\n          while state[curr] == LIMIT:\n              if curr == 0:\n                  done = True\n                  break\n              state[curr] = 0\n              curr -= 1\n              state[curr] += 1\n  \n  def gen_odd_palindrome(side_length):\n      if side_length == 0:\n          for i in xrange(1, 10):\n              yield i\n      else:\n          multi = 10**side_length\n          for one_side in gen_one_side(side_length):\n              number, rnumber = list_to_number(one_side)\n              for i in xrange(LIMIT):\n                  yield number + i * multi + rnumber * multi * 10\n  \n  def gen_even_palindrome(side_length):\n      multi = 10**side_length\n      for one_side in gen_one_side(side_length):\n          number, rnumber = list_to_number(one_side)\n          yield number + rnumber * multi\n  \n  \n  def gen_palindrome():\n      l = 1\n  \n      while True:\n          if l % 2 == 1:\n              for odd_pal in gen_odd_palindrome((l - 1) \/ 2):\n                  yield odd_pal\n          else:\n              for even_pal in gen_even_palindrome(l \/ 2):\n                  yield even_pal\n          l += 1\n  \n  \n  cache = []\n  upper = 10**14\n  for pal in gen_palindrome():\n      pal2 = pal**2\n      if pal2 > upper:\n          break\n      if check_palindrome(pal2):\n          cache.append(pal2)\n  \n  cl = len(cache)\n  T = int(raw_input().strip())\n  for i in xrange(T):\n      low_ind = 0\n      high_ind = cl - 1\n      A, B = map(int, raw_input().strip().split(' '))\n  \n      while cache[low_ind] < A:\n          low_ind += 1\n      while cache[high_ind] > B:\n          high_ind -= 1\n  \n  \n      if low_ind <= high_ind:\n          print \"Case #%s: %s\" % (i + 1, high_ind - low_ind + 1)\n      else:\n          print \"Case #%s: 0\" % (i + 1)\n <CODESPLIT> ","completion":" 40"}
{"prompt":" \n  surprising = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]\n  regular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]\n  \n  f = open(argv[1], 'r')\n  T = int(f.readline().strip('\n'))\n  for i in range(T):\n  \tboth = 0\n  \tsurp_only = 0\n  \tline = f.readline().strip('\n').split(' ')\n  \tN = int(line[0]) # What for?\n  \tS = int(line[1])\n  \tp = int(line[2])\n  \tts = map(int, line[3:])\n  \tfor t in ts:\n  \t\tif reduce(max, map(max, regular[t])) >= p:\n  \t\t\tboth += 1\n  \t\telif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:\n  \t\t\tsurp_only += 1\n  \n  \tprint \"Case #%s: %s\" % (i + 1, both + min(surp_only, S))\n <CODESPLIT> ","completion":" 40"}
{"prompt":" \n  main = do\n      interact (unlines . map showCase . zip [1..] . map (solve . interval) . tail . lines)\n  \n    where\n      interval :: String -> (Int64, Int64)\n      interval l =\n          let [a, b] = map read $ splitOn \" \" l\n          in (a, b)\n  \n      showCase :: (Int64, Int) -> String\n      showCase (i, r) = printf \"Case #%d: %d\" i r\n  \n  solve :: (Int64, Int64) -> Int\n  solve (a, b) =\n      length $ takeWhile (<= b) $ dropWhile (< a) [ sq\n          | x <- [0..], palindrome x, let sq = x * x, palindrome sq\n          ]\n    where\n      square x = x * x\n      start = truncate $ sqrt $ double a\n  \n  -- | Returns True if s is a palindrome.\n  palindrome s =\n      let s' = show s\n      in s' == reverse s'\n  \n  double :: Int64 -> Double\n  double = fromIntegral\n <CODESPLIT> ","completion":" 41"}
{"prompt":" \n  main = interact (unlines . map showCase . zip [1..] . tail . lines)\n    where\n      showCase (i, t) = \"Case #\" ++ show i ++ \": \" ++ solve t\n  \n  solve = show . solve' . map read . words\n    where\n      solve' (n:s:p:ts) = \n          let pts = map maxPoints ts\n              directs = filter ((>= p) . fst) pts\n              surps = filter (\\(pd, ps) -> pd < p && ps >= p) pts\n          in length directs + min (length surps) s\n          \n  maxPoints :: Int -> (Int, Int)\n  maxPoints tot = \n      (maxScore $ scores normal, maxScore $ scores surprising)\n    where\n      scores cond = [ (x, y, z) |\n          x <- [0..10], y <- [0..10], z <- [0..10]\n          , x + y + z == tot, cond (x, y, z)\n          ]\n      normal t = bestScore t - badScore t <= 1\n      surprising t = bestScore t - badScore t <= 2\n      maxScore = maximum . map bestScore \n  \n  bestScore (x, y, z) = maximum [x, y, z]\n  badScore (x, y, z) = minimum [x, y, z]\n <CODESPLIT> ","completion":" 41"}
{"prompt":"def checkpalin(s):\n      k = len(s)\/\/2\n      for i in range(k):\n          if s[i]!= s[-1-i]:\n              return False\n      return True\n  \n  goods = [1,2,3]\n  \n  for i in range(1000):\n      for j in ['']+list(range(10)):\n          test = str(i)+str(j)+(str(i)[::-1])\n          if checkpalin(str(int(test)**2)):\n              goods.append(int(test))\n  goods = list(set(goods))\n  goods.sort()\n  \n  T = int(input())\n  \n  for case in range(1,T+1):\n      A,B = [int(x) for x in input().split()]\n      ans = 0\n      for n in goods:\n          if A <= n*n <= B:\n              ans += 1\n      print(\"Case #\",case,\": \",ans,sep='')\n <CODESPLIT> ","completion":" 42"}
{"prompt":"T=int(input())\n  for t in range(T):\n    l = [int(x) for x in input().split()]\n    n,huh,p = l[:3]\n    ss = l[3:]\n    nice, maybe = 0,0\n    for s in ss:\n      if s>= p+2*max(p-1,0):\n        nice += 1\n      elif s>= p+2*max(p-2,0):\n        maybe += 1\n    y = nice + min(maybe,huh)\n    print('Case #',t+1,': ',y,sep = '')\n  \n  \n <CODESPLIT> ","completion":" 42"}
{"prompt":" \n  \n  case = 1\n  problem = \"B\"\n  practice = False\n  \n  if practice:\n      practice = \"-practice\"\n  else:\n      practice = \"-attempt0\"\n  if case == 0:\n      infile = open(\"%s-%s%s.in\" % (problem, \"sample\", practice), 'r')\n      outfile = open(\"%s-%s%s.out\" % (problem, \"sample\", practice), 'w')        \n  elif case == 1:\n      infile = open(\"%s-%s%s.in\" % (problem, \"small\", practice), 'r')\n      outfile = open(\"%s-%s%s.out\" % (problem, \"small\", practice), 'w')    \n  elif case == 2:\n      infile = open(\"%s-%s%s.in\" % (problem, \"large\", practice), 'r')\n      outfile = open(\"%s-%s%s.out\" % (problem, \"large\", practice), 'w')   \n  else:\n      raise ValueError, 'Invalid case'\n      \n  lookup = {}\n  \n  def check_total(total, p):\n      assert type(total) == int\n      resid = total % 3\n  \n      min_nosurprise = (total \/ 3)    \n      max_nosurprise = (total \/ 3) + min(1, resid)\n      \n      \n      if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):\n          if max_nosurprise >= p:\n              return 1\n          else:\n              return -1\n  \n      if max_nosurprise >= p:\n          return 1\n      elif max_nosurprise == p-1:\n          return 0\n      else:\n          return -1\n      \n  cases = int(infile.readline().strip('\n'))\n  for i in range(cases):\n      print 'case %i of %i' % (i+1, cases)\n      line = infile.readline().split()\n      N = int(line[0])\n      S = int(line[1])\n      p = int(line[2])\n      points = []\n      for item in line[3:]:\n          points.append(int(item))\n      assert N == len(points)\n      assert p <= 10\n      assert p >= 0\n      assert S >= 0\n      assert S <= N\n      \n      always = 0\n      possible = 0\n      \n      for total in points:\n          if (total, p) in lookup:\n              depends = lookup[total, p]\n          else:\n              depends = check_total(total, p)\n          \n          if depends == 1:\n              always += 1\n          elif depends == 0:\n              possible += 1\n      \n      output = '%i' % (always + min(possible, S))\n      \n      outfile.write('Case #%i: %s\n' % (i+1, output))\n      \n  infile.close()\n  outfile.close()\n <CODESPLIT> ","completion":" 43"}
{"prompt":" \n  \n  def is_palindrome(num):\n      s1 = str(num)\n      s2 = s1[::-1]\n      return s1 == s2\n  \n  fair_numbers = []\n  for i in range(pow(10, 7)+1):\n      if is_palindrome(i):\n          num = i*i\n          if is_palindrome(num):\n              fair_numbers.append(num)\n  \n  N = int(sys.stdin.readline())\n  for T in range(1, N+1):\n      min_val, max_val = map(int, sys.stdin.readline().strip().split())\n  \n      ans = 0\n      for num in fair_numbers:\n          if num < min_val:\n              continue\n          if num > max_val:\n              break\n          ans += 1\n      print 'Case #%(T)s: %(ans)s' % locals()\n <CODESPLIT> ","completion":" 44"}
{"prompt":" \n  \n  for i, line in enumerate(sys.stdin):\n      if i == 0:\n          continue\n  \n      params = [int(n) for n in line.split(' ')]\n      (N, S, p) = params[:3]\n      scores = params[3:]\n  \n      (clear, possible) = (0, 0)\n      normal_min = max(p * 3 - 2, 0)\n      suprising_min = max(p * 3 - 4, 0)\n      for score in scores:\n          if p > score:\n              continue\n          elif score >= normal_min:\n              clear += 1\n          elif score >= suprising_min:\n              possible += 1\n  \n      ans = clear + min(possible, S)\n      print 'Case #%(i)s: %(ans)s' % locals()\n <CODESPLIT> ","completion":" 44"}
{"prompt":" \n  \n  \n  def calculatepalindromes(ndigits):\n      if ndigits == 1:\n          return 3\n  \n      result = 0\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)\/2)\n  \n      if isEven:\n          result += 1\n      else:\n          result += 3\n  \n      for numones in range(0, min(6, fillingdigits) + 1):\n          combinations = int(math.factorial(fillingdigits) \/ (math.factorial(fillingdigits-numones) * math.factorial(numones)))\n          result += combinations\n          if not isEven:\n              result += combinations\n  \n      return result\n  \n  \n  def findpalindromes(ndigits):\n      if ndigits == 1:\n          return [1, 2, 3]\n  \n      result = []\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)\/2)\n  \n      if isEven:\n          result.append(int(\"2\" + \"0\"*(fillingdigits*2) + \"2\"))\n      else:\n          result.append(int(\"2\" + \"0\"*fillingdigits + \"0\" + \"0\"*fillingdigits + \"2\"))\n          result.append(int(\"2\" + \"0\"*fillingdigits + \"1\" + \"0\"*fillingdigits + \"2\"))\n          result.append(int(\"1\" + \"0\"*fillingdigits + \"2\" + \"0\"*fillingdigits + \"1\"))\n  \n      for numones in range(0, min(6, fillingdigits)+1):\n          ones = fillOnes([], fillingdigits, numones)\n          for o in ones:\n              if isEven:\n                  result.append(int(\"1\" + \"\".join(o) + \"\".join(list(reversed(o))) + \"1\"))\n              else:\n                  result.append(int(\"1\" + \"\".join(o) + \"0\" + \"\".join(list(reversed(o))) + \"1\"))\n                  result.append(int(\"1\" + \"\".join(o) + \"1\" + \"\".join(list(reversed(o))) + \"1\"))\n  \n      return result\n  \n  def fillOnes(combination, size, remainingOnes):\n      if len(combination) == size:\n          return [combination]\n      result = []\n      if remainingOnes > 0:\n          c = combination + [\"1\"]\n          result += fillOnes(c, size, remainingOnes - 1)\n      if remainingOnes < size - len(combination):\n          c = combination + [\"0\"]\n          result += fillOnes(c, size, remainingOnes)\n      return result\n  \n  \n  \n  ncases = int(sys.stdin.readline())\n  \n  for t in range(1, ncases+1):\n      fairsquare = 0\n      (a, b) = sys.stdin.readline().strip().split(\" \")\n      intA = int(a)\n      intB = int(b)\n      ndigitsA = len(a)\n      ndigitsB = len(b)\n      ndigitsARooted = math.ceil(ndigitsA\/2)\n      ndigitsBRooted = math.ceil(ndigitsB\/2)\n  \n      if ndigitsBRooted == ndigitsARooted:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA and p ** 2 <= intB:\n                  fairsquare +=1\n      else:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA:\n                  fairsquare +=1\n  \n          for i in range(ndigitsARooted + 1, ndigitsBRooted):\n              fairsquare += calculatepalindromes(i)\n  \n          palindromes = findpalindromes(ndigitsBRooted)\n          for p in palindromes:\n              if p ** 2 <= intB:\n                  fairsquare +=1\n  \n      print(\"Case #%d: %d\" % (t, fairsquare))\n <CODESPLIT> ","completion":" 45"}
{"prompt":" \n  \n  def findbest(score):\n  \tif score == 0: return (0, 0)\n  \n  \tbest = math.ceil(score \/ 3)\n  \tbestsurp = round(score \/ 3) + 1\n  \n  \treturn (best, bestsurp)\n  \t\n  sys.stdin.readline()\n  \n  casenum = 0\n  for line in sys.stdin:\n  \tcasenum += 1\n  \n  \tdata = line.strip().split(' ')\n  \tmaxsurprising = int(data[1])\n  \tp = int(data[2])\n  \tscores = data[3:]\n  \tmaxgooglers = 0\n  \n  \tfor s in scores:\n  \t\t(best, bestsurp) = findbest(int(s))\n  \t\tif best >= p:\n  \t\t\tmaxgooglers += 1\n  \t\telse:\n  \t\t\tif bestsurp >= p and maxsurprising > 0:\n  \t\t\t\tmaxgooglers += 1\n  \t\t\t\tmaxsurprising -= 1\n  \n  \tprint(\"Case #%d: %d\" % (casenum, maxgooglers))\n <CODESPLIT> ","completion":" 45"}
{"prompt":" \n  def is_square(n):\n      if n in square:\n          return True\n      if is_fair(n):\n          root = int(math.sqrt(n))\n          if root**2 != n:\n              return False\n          ss = is_fair(root)\n          if ss: square.add(n)\n          return ss\n      return False\n  \n  def is_fair(n):\n      if n in fair:\n          return True\n      if n in unfair:\n          return False\n      sn = str(n)\n      l = len(sn)\n      mid = math.ceil(n\/2)\n      if sn[0:mid] == sn[mid::-1]:\n          fair.add(n)\n          return True\n      else:\n          unfair.add(n)\n          return False\n  \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n              \n      fair = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11])\n      unfair = set([12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n      square = set([1, 4])\n  \n      t = int(f.readline())\n      for _t in range(t):\n          s = f.readline()\n          if s:\n              x, y = s.split()\n              Total = sum([is_square(n) for n in range(int(x), int(y)+1)])             \n              print (\"Case #\" + str(_t+1) + \": \" + str(Total))\n      \n  \n <CODESPLIT> ","completion":" 46"}
{"prompt":" \n  def decode_data(input):\n      output = \"\"\n      for letter in input:\n          if letter in library:\n              output += library[letter]\n      return output\n  \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())    \n      for _t in range(t):\n          s = f.readline()\n          s = s.split()\n          N = int(s[0])\n          S = int(s[1])\n          p = int(s[2])\n          low_scores = (p - 1) * 2\n          ti = s[3:]\n          ti.sort()\n          r = 0\n          ti = [int(x) for x in ti]\n          for i in ti:\n              score = i - low_scores\n              if p <= i:\n                  if score >= p:\n                      r += 1\n                  elif score >= p - 2 and S > 0:\n                      S -= 1\n                      r +=1\n          print (\"Case #\" + str(_t+1) + \": \" + str(r))\n      \n  \n <CODESPLIT> ","completion":" 46"}
{"prompt":" \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      \"\"\" Returns True iff y is within relative or absolute 'epsilon' of x.\n          By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) \/ x <= epsilon\n          or -epsilon <= (x - y) \/ y <= epsilon)\n    \n  def read_syms(fd):\n      return [c for c in fd.readline().strip()]\n  \n  def read_ints(fd):\n      return [int(p) for p in fd.readline().strip().split()]\n  \n  def read_floats(fd):\n      return [float(p) for p in fd.readline().strip().split()]\n  \n  class Mtrx(object):\n      \n      def __init__(self, readfunc):\n          self.readfunc = readfunc\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in range(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in range(self.rows)]\n      \n      def readfromfile(self, fd):\n          self.data = []\n          self.rows, self.cols = read_ints(fd)\n          for _ in range(self.rows):\n              line = self.readfunc(fd)\n              assert len(line) == self.cols\n              self.data.extend(line)\n              \n      def __str__(self):\n          res = \"\"\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + \"\n\"\n          return res\n               \n  class IntMatrix(Mtrx):\n      def __init__(self):\n          super(IntMatrix, self).__init__(read_ints)\n  \n  class SymMatrix(Mtrx):\n      def __init__(self):\n          super(IntMatrix, self).__init__(read_syms)\n  \n  class memoizeit(object):\n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          try:\n              return self.cache[args]\n          except KeyError:\n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  class timeit(object):\n      def __init__(self, func):\n          self.func = func\n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          print self.func.__name__, \"{:7.3f}s, (res: {})\".format(delta, value)\n          return value\n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n <CODESPLIT> ","completion":" 47"}
{"prompt":" \n  OEXT = \".out\"\n  IN_S = \"small.in\"\n  IN_L = \"large.in\"\n  CASE_PRFX = \"Case #%s: \"\n  \n  \n  def avg(L):\n      return 1.0*sum(L)\/len(L)\n  \n  triplets = [[0,0,0], [0,0,1], [0,1,1], \n              [0,0,2], [0,2,2], [0,1,2],\n              [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],\n              ]\n  \n  def analyze_sum(sm, tgt):\n      av = 1.0 * sm \/ 3\n      av_cls = av % 1\n  \n      if av_cls > 0.1:\n          ns_max_val = math.ceil(av)\n      else:\n          ns_max_val = av \n      \n      s_max_val = 0 \n      if sm >= 2 and sm <= 28:\n          if av_cls > 0.5:\n              s_max_val = math.ceil(av) + 1\n          elif av_cls > 0.1:\n              s_max_val = math.ceil(av) \n          else:\n              s_max_val = av + 1\n      \n      if ns_max_val >= tgt:\n          res = [ns_max_val, None]\n          kind = 1\n      elif s_max_val < tgt:\n          res = [None, None]\n          kind = 0\n      else:\n          res = [None, s_max_val]\n          kind = 2\n          \n      print sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind\n      return res, kind\n  \n  def analyze_triplet(trip, tgt):\n      sm = sum(trip)\n      analyze_triplet(sm, tgt)\n      \n  \n  def read_input(filename):\n      data = []\n      with open(filename, \"r\") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              case = f.readline().strip().split()\n              case = [int(c) for c in case]\n              data.append({\"ngoog\": case[0], \"ssurp\": case[1], \"ptgt\": case[2],\n                           \"trips\": case[3:]})\n      return data\n  \n  def make_output(fname, output):\n      fname = fname + OEXT\n      with open(fname, \"w\") as f:\n          restext = []\n          for i, v in enumerate(output):\n              restext.append(CASE_PRFX % (i+1,) + str(v) + \"\n\")\n          f.writelines(restext)\n      \n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          ansys = [analyze_sum(c, case[\"ptgt\"]) for c in case[\"trips\"]]\n          non_surp_is_enough = len([k for _, k in ansys if k == 1])\n          surp_needed = len([k for _, k in ansys if k == 2])\n          if surp_needed >= case[\"ssurp\"]:\n              res = non_surp_is_enough + case[\"ssurp\"]\n          else:\n              res = non_surp_is_enough + surp_needed\n          output.append(res)\n      print \"output:\", output\n      make_output(fname, output)\n       \n  \n  main(\"examples.in\")\n  main(\"small.in\")\n <CODESPLIT> ","completion":" 47"}
{"prompt":"directory = 'C:\/users\/hai\/my projects\/google code jam\/2013\/qualification\/C\/'\n  \n  \n  def is_palindrome (n):\n      l = list(str(n))\n      return list(reversed(l)) == l\n  \n  def prepare ():\n      global fair_and_squares\n      fair_and_squares = []\n      \n      for i in range(1,10**7):\n          if is_palindrome(i):\n              sqr = i**2\n              if is_palindrome(sqr):\n                  fair_and_squares.append(sqr)\n      return\n  \n          \n  def solve (f_in, f_out):\n      prepare()\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          A,B = [int(x) for x in f_in.readline().split()]\n          count = len([x for x in fair_and_squares if (x>=A and x<=B)])\n          f_out.write('Case #' + str(testcase) + ': ' + str(count) + '\n')\n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n <CODESPLIT> ","completion":" 48"}
{"prompt":"directory = 'C:\/users\/hai\/my projects\/google code jam\/2012\/qualification\/B\/'\n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      print ('Test cases : ',T)\n      for i in range(1,T+1):\n          line = f_in.readline()\n          nnn = [int(x) for x in line.split()]\n          S = nnn[1]\n          p = nnn[2]\n          t = nnn[3:]\n          if p > 1:\n              A = 0\n              B = 0\n              for t_i in t:\n                  if t_i >=3*p-2:\n                      A += 1\n                  elif t_i >= 3*p-4:\n                      B += 1\n              result = A + min(B,S)\n          if p == 1:\n              result = len([x for x in t if x>=1])\n          if p == 0:\n              result=  len(t)\n          f_out.write('Case #' + str(i) + ': ' + str(result) + '\n')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n  \n  \n  \n  main_run()\n <CODESPLIT> ","completion":" 48"}
{"prompt":" \n  def isPalindrome(n) :\n      return str(n) == str(n)[::-1]\n  \n  def findPalindrome(n) :\n      if n % 2 == 0 : return [start*(10**(n\/2)) + int(str(start)[::-1]) for start in range(10**(n\/2-1),10**(n\/2))]\n      if n == 1 : return range(1,10)\n      return [start*(10**(n\/2)) + int(str(start)[:-1][::-1]) for start in range(10**(n\/2),10**((n+1)\/2))]\n  \n  def findPalindromeInRange(a, b) :\n      num = range(len(str(a)), len(str(b)) + 1)\n      allPalindrome = []\n      for n in num : allPalindrome += findPalindrome(n)\n      return filter(lambda x : a <= x <= b, allPalindrome)\n  \n  f = open('C-small-attempt0.in', 'r')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in range(T) :\n      A, B = map(int, f.readline()[:-1].split())\n      a = int(math.ceil(A**0.5))\n      b = int(B**0.5)\n      res = len(filter(lambda x : isPalindrome(x**2), findPalindromeInRange(a, b)))\n      outString = 'Case #' + str(case+1) + ': ' + str(res) + '\n'\n      print outString[:-1]\n      g.write(outString)\n  \n  f.close()\n  g.close()\n <CODESPLIT> ","completion":" 49"}
{"prompt":"fin = open('B-small-attempt0.in', 'r')\n  fout = open('B-output.txt', 'w')\n  \n  cases = int(fin.readline()[:-1])\n  \n  for case in range(cases) :\n      line = map(int, fin.readline()[:-1].split(' '))\n      N, S, p = line[:3]\n      T = line[3:]\n      okLimit = p + 2*max(p-1,0)\n      okIfSLimit = p + 2*max(p-2,0)\n      ok = len(filter(lambda x : x >= okLimit, T))\n      okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))\n      res = ok + min(okIfS, S)\n      fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')\n      \n  fin.close()\n  fout.close()\n <CODESPLIT> ","completion":" 49"}
{"prompt":" \n  \n  def palindromes():\n      for digits in count(1):\n          for n in xrange(10**(digits-1), 10**digits):\n              n = str(n)\n              yield int(n + n[-2::-1])\n          for n in xrange(10**(digits-1), 10**digits):\n              n = str(n)\n              yield int(n + n[::-1])\n  \n  def is_palindrome(n):\n      n = str(n)\n      return n == n[::-1]\n  \n  def solve(A, B):\n      count = 0\n      for n in palindromes():\n          square = n**2\n          if square > B:\n              break\n          if square >= A and is_palindrome(square):\n              count += 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n  \n              A, B = map(int,fin.readline().split())\n              soln = solve(A, B)\n  \n              print >> fout, \"Case #{0}: {1}\".format(case, soln)\n <CODESPLIT> ","completion":" 50"}
{"prompt":" \n  def solve(n, s, p, scores):\n      count = 0\n      for t in scores:\n          if ceil(t\/3) >= p:\n              count += 1\n          elif 2 <= t <= 28 and ceil((t+2)\/3) >= p and s > 0:\n              count += 1\n              s -= 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in range(1, T+1):\n              line = map(int, fin.readline().split())\n              n, s, p, *scores = line\n              result = solve(n, s, p, scores)\n              print(\"Case #{0}: {1}\".format(case, result), file=fout)\n <CODESPLIT> ","completion":" 50"}
{"prompt":" \n  def solve(lower, upper, cache):\n      counter = 0\n      for item in cache:\n          if item > upper:\n              break\n          if item < lower:\n              continue\n          counter += 1\n      return counter\n  \n  def is_palindrome(test_int):\n      str_arg = str(test_int)\n      return str_arg == str_arg[::-1]\n  \n  def generate_cache():\n      \"\"\" Generates a list of 'fair and square' numbers between 1 and 10^100\n  \n      By observation of generating the first few of these numbers it became\n      obvious that the 'roots' fitted a very specific pattern, they are either\n      single digits and 1,2 or 3; multiple digits consisting of only 1s and 0s;\n      multiple digits with a 2 at the beginning and end and 1s and 0s in the\n      middle or an odd number of digits with a single 2 in the centre and 1s and\n      0s elsewhere.\n  \n      This function therefore only looks at these numbers to build a list of all\n      valid results. \"\"\"\n      cache = [9,]\n      counter = 1\n      if upper_bound is None:\n          upper_bound = pow(2,25)\n      while counter < upper_bound:\n          binary_part = \"{0:b}\".format(counter)\n          half_int = binary_part\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = \"%s%s\" % (binary_part, 2)\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = \"2%s\" % binary_part[1:]\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          counter += 1\n      return sorted(cache)\n  \n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                        help=\"read input from FILE\", metavar=\"FILE\")\n      parser.add_option(\"-c\", \"--cache\", dest=\"cache_filename\",\n                        help=\"read\/write cache from\/to CACHE_FILE\", metavar=\"CACHE_FILE\")\n      parser.add_option(\"-g\", \"--generate-cache\", dest=\"generate_cache\",\n                        help=\"generate the cache file\", action=\"store_true\")\n      cache = None\n      (options, args) = parser.parse_args()\n      if options.generate_cache:\n          cache = generate_cache()\n          if not options.cache_filename:\n              output_file = open(options.cache_filename, \"w\")\n              pickle.dump(cache, output_file)\n              output_file.close()\n      else:\n          cache_file = open(options.cache_filename, \"r\")\n          cache = pickle.load(cache_file)\n          cache_file.close()\n      if not options.filename:\n          parser.error(\"Must provide a filename.\")\n      input_file = open(options.filename, \"r\")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n          case_number += 1\n          lower,upper = input_file.readline().split()\n          lower = int(lower)\n          upper = int(upper)\n          data_args = (lower, upper, cache)\n          print \"Case #%d: %s\" % (case_number, solve(*data_args))\n  \n  if __name__ == \"__main__\":\n      main()\n <CODESPLIT> ","completion":" 51"}
{"prompt":" \n  def solve(N,S,p,t):\n      if p == 0:\n          return N\n      outright_wins = 0\n      potential_surprises = 0\n      win_cutoff = (p * 3) - 3\n      surprise_cutoff = win_cutoff - 2\n      for score in t:\n          if score == 0:\n              continue\n          elif score > win_cutoff:\n              outright_wins += 1\n          elif score > surprise_cutoff:\n              potential_surprises += 1\n      if potential_surprises < S:\n          return outright_wins + potential_surprises\n      else:\n          return outright_wins + S\n  \n  def parse_case(data_line):\n      bits = data_line.split()\n      N = int(bits[0])\n      S = int(bits[1])\n      p = int(bits[2])\n      t = [int(x) for x in bits[3:]]\n      return N,S,p,t\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                        help=\"read input from FILE\", metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error(\"Must provide a filename.\")\n      input_file = open(options.filename, \"r\")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n      \tcase_number += 1\n      \tdata_args = parse_case(input_file.readline())\n      \tprint \"Case #%d: %d\" % (case_number, solve(*data_args))\n  \n  if __name__ == \"__main__\":\n  \tmain()\n <CODESPLIT> ","completion":" 51"}
{"prompt":" \n  \n  def is_palindrome(x):\n      candidate = list(str(x))\n      while len(candidate) > 1:\n          if candidate.pop(0) != candidate.pop():\n              return False\n      return True\n  \n  \n  def square(x):\n      return x * x\n  \n  \n  def solve_case(ab, case_number):\n      fs = 0\n      root = int(math.sqrt(ab[0]))\n      sq = square(root)\n      if sq < ab[0]:\n          root += 1\n          sq = square(root)\n  \n      while sq <= ab[1]:\n          if is_palindrome(root) and is_palindrome(sq):\n              fs += 1\n  \n          root += 1\n          sq = square(root)\n  \n      print \"Case #%d: %d\" % (case_number, fs)\n  \n  \n  def main():\n      r = sys.stdin\n      if len(sys.argv) > 1:\n          r = open(sys.argv[1], 'r')\n  \n      total_cases = r.readline()\n      for case_number in range(1, int(total_cases) + 1):\n          ab = map(int, r.readline().strip().split(' '))\n          solve_case(ab, case_number)\n  \n  if __name__ == \"__main__\":\n      main()\n <CODESPLIT> ","completion":" 52"}
{"prompt":" \n  mod_plus_conv_with_s = {0:1, 1:1, 2:2}\n  mod_plus_conv_without_s = {0:0, 1:1, 2:1}\n  \n  def solve_case(s, p, scores,case_number):\n  \tans = 0\n  \tfor score in scores:\n  \t\tif p <= (score \/ 3) + mod_plus_conv_without_s[score % 3]:\n  \t\t\tans = ans + 1\n  \t\telif s > 0 and (score \/ 3) > 0: \n  \t\t\tif p <= (score \/ 3) + mod_plus_conv_with_s[score % 3]:\n  \t\t\t\tans = ans + 1\n  \t\t\t\ts = s - 1\n  \tprint \"Case #%d: %d\" % (case_number, ans)\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n  \tr = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n  \tcase_line = map(int, r.readline().rstrip().split(' '))\n  \tsolve_case(case_line[1], case_line[2], case_line[3:], case_number)\n  \n <CODESPLIT> ","completion":" 52"}
{"prompt":" \n  def isPalindrome(n):\n  \tn = str(n)\t\n  \tfor i in xrange(len(n)\/2):\n  \t\tif n[i] != n[(-i-1)]:\n  \t\t\treturn False\n  \treturn True\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file(\"output.txt\", \"w\")\n  \n  T = eval(f.readline())\n  \n  for case in xrange(T):\n  \tdata = f.readline().split()\n  \tA = eval(data[0])\n  \tB = eval(data[1])\n  \n  \ti = A\n  \tfound = []\n  \twhile i <= B:\n  \t\tif isPalindrome(i):\n  \t\t\tsqrtI = math.sqrt(i)\n  \t\t\tif sqrtI == int(sqrtI):\n  \t\t\t\tif isPalindrome(int(sqrtI)):\n  \t\t\t\t\tfound.append(i)\n  \t\ti += 1\n  \n  \tfout.write(\"Case #%d: %d\n\" %(case + 1, len(found)))\n <CODESPLIT> ","completion":" 53"}
{"prompt":"arq = file(\"input.in\")\n  n_cases = eval(arq.readline())\n  out = file(\"output.txt\", \"w\")\n  \n  for case in xrange(n_cases):\n  \n  \tdata = arq.readline()\n  \tdata = data.strip()\n  \tdata = data.split(\" \")\n  \n  \tn = eval(data[0])\n  \ts = eval(data[1])\n  \tp = eval(data[2])\n  \n  \tscores = []\n  \tn_googlers_with_best_result = 0\n  \tcandidates = 0\n  \n  \tfor j in data[3:]:\n  \t\ti = eval(j)\n  \t\tif i%3 == 0:\n  \t\t\tscore = i\/3\n  \t\t\tscores.append([score, score, score])\n  \t\telif (i+1)%3 == 0:\n  \t\t\tscore = (i+1)\/3\n  \t\t\tscores.append([score-1, score, score])\n  \t\telse: #(i+2)%3 == 0\n  \t\t\tscore = (i+2)\/3\n  \t\t\tscores.append([score-1, score-1, score])\n  \n  \tfor score in scores:\n  \t\tif score[2] >= p:\n  \t\t\tn_googlers_with_best_result +=1\n  \t\telif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:\n  \t\t\tcandidates += 1\n  \n  \tn_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)\n  \n  \tout.write(\"Case #%d: %d\n\" % (case+1, n_googlers_with_best_result))\n <CODESPLIT> ","completion":" 53"}
{"prompt":" \n  \n  def isPal(n):\n      l = str(n)\n      return l == l[::-1]\n  \n  def solve(a, b):\n      l = int(math.ceil(math.sqrt(a)))\n      u = int(math.floor(math.sqrt(b)))\n  \n      count = 0\n      for x in range(l, u + 1):\n          if isPal(x):\n              if isPal(x*x):\n                  count += 1\n      return str(count)\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n          result = solve(a, b)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> ","completion":" 54"}
{"prompt":" \n  \n  \n  def solve(num_surprises, p, ts):\n      s = 0\n      u = 0\n      for t in ts:\n          a = int(t\/3)\n          r = t % 3\n          if a+1 >= p and not r == 0:\n              u += 1\n          elif a >= p and r == 0:\n              u += 1\n          elif a > 0 and a+1 >= p and r == 0:\n              s += 1\n          elif a+2 >= p and r == 2:\n              s += 1\n  \n      return min(num_surprises, s) + u\n          \n          \n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          line = [int(x) for x in sys.stdin.readline().split()]\n          num_surprises = line[1]\n          p = line[2]\n          ts = line[3:]\n          result = solve(num_surprises, p, ts)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> ","completion":" 54"}
{"prompt":" \n  def ispal(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  def ispalsq(n):\n      sqrt = int(math.sqrt(n) + .01)\n      if sqrt ** 2 != n:\n          return False\n      return ispal(n) and ispal(sqrt)\n  \n  def search(s, l, idx):\n      if l % 2 == 0:\n          m = s + s[::-1]\n      else:\n          m = s[:-1] + s[::-1]\n      assert ispal(m)\n      n = int(m) ** 2\n      if not ispal(n):\n          return 0\n  \n      r = 1 if (a <= n <= b) else 0\n      for i in xrange(idx, len(s)):\n          s2 = list(s)\n          s2[i] = str(int(s2[i])+1)\n          s2 = ''.join(s2)\n          r += search(s2, l, i)\n      return r\n  \n  \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          a, b = map(int, f.readline().split())\n  \n          total = 0\n          for l in xrange(1, 150):\n              if 10 ** (l-1) > b:\n                  break\n              total += search(\"1\" + \"0\" * ((l-1)\/2), l, 0)\n          print \"Case #%d: %d\" % (_t+1, total)\n  \n <CODESPLIT> ","completion":" 55"}
{"prompt":" \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          ns = map(int, f.readline().split())\n          n = ns[0]\n          s = ns[1]\n          p = ns[2]\n          assert len(ns) == n + 3\n          scores = ns[3:3+n]\n  \n          sure = 0\n          if_surprising = 0\n          for x in scores:\n              not_surprising = (x + 2) \/ 3\n              is_surprising = (x + 4) \/ 3\n              if not_surprising >= p:\n                  sure += 1\n              elif (2 <= x <= 28) and is_surprising >= p:\n                  if_surprising += 1\n          print \"Case #%d: %d\" % (_t+1, sure + min(if_surprising, s))\n <CODESPLIT> ","completion":" 55"}
{"prompt":" \n  \n  def readfile(file):\n    \"\"\"\n      input:\n  \n  \t\tT (number of test cases)\n  \n  \t\tA B\n  \n    \"\"\"\n  \n    tests = []\n  \n    T = int(file.readline().strip())\n  \n    for i in xrange(T):\n  \t\ttest = {}\n  \n  \t\tline = file.readline().strip()\n  \t\tparts = line.split(\" \")\n  \n  \t\tif len(parts) != 2:\n  \t\t\tprint \"HORRIBLE ERROR IN TEST CASE %d\" % (i+1,)\n  \t\t\treturn None\n  \n  \t\ttest['A'] = int(parts[0])\n  \t\ttest['B'] = int(parts[1])\n      \n  \t\ttests.append(test)\n  \n    return tests\n  \n  def isPalindrome(s):\n  \t\"\"\"\n  \t\tIs s a palindrome.\n  \n  \t\tS must be a string.\n  \t\"\"\"\n  \n  \tl = len(s)\n  \n  \tif (l % 2) == 0:\n  \t\tfrontHalf = s[0:l\/2]\n  \t\tbackHalf = s[l\/2:]\n  \telse:\n  \t\tfrontHalf = s[0:(l-1)\/2]\n  \t\tbackHalf = s[(l+1)\/2:]\n  \n  \tbackHalf = backHalf[::-1]\n  \n  \tif frontHalf == backHalf:\n  \t\treturn True\n  \telse:\n  \t\treturn False\n  \n  def isFairAndSquare(n):\n  \n  \tsqrtN = int(math.sqrt(n))\n  \n  \tif (sqrtN * sqrtN) != n:\n  \t\treturn False\n  \n  \tif not isPalindrome(str(n)):\n  \t\treturn False\n  \n  \tif not isPalindrome(str(sqrtN)):\n  \t\treturn False\n  \n  \treturn True\n  \n  def run(test):\n  \t\"\"\"\n  \t\tRun a test and return output.\n  \t\"\"\"\n  \n  \tcount = 0\n  \n  \tfor i in xrange(test['A'], test['B'] + 1):\n  \t\tif isFairAndSquare(i):\n  \t\t\tcount = count + 1\n  \n  \treturn count\n  \n  \ti = int(math.sqrt(test['A']))\n  \n  \tif (i * i) < test['A']:\n  \t\ti = i + 1\n  \n  \twhile i < test['B']:\n  \t\tif not isPalindrome(str(i)):\n  \t\t\ti = i + 1\n  \t\t\tcontinue\n  \n  \t\ts = i * i\n  \n  \t\tif s <= test['B']:\n  \t\t\tif isPalindrome(str(s)):\n  \t\t\t\tcount = count + 1\n  \t\telse:\n  \t\t\tbreak\n  \n  \t\ti = i + 1\n  \n  \treturn \"%s\" % (count, )\n  \n  file = open(sys.argv[1], \"rt\")\n  \n  tests = readfile(file)\n  \n  file.close()\n  \n  case = 1\n  \n  for test in tests:\n    result = run(test)\n    print \"Case #%d: %s\" % (case, result)\n    case = case + 1\n <CODESPLIT> ","completion":" 56"}
{"prompt":" \n  def readfile(filename):\n  \t\"\"\"\n  \t\tThe first line of the input gives the number of test\n  \t\tcases, T. T test cases follow. Each test case consists of\n  \t\ta single line containing integers separated by single\n  \t\tspaces. The first integer will be N, the number of\n  \t\tGooglers, and the second integer will be S, the number\n  \t\tof surprising triplets of scores. The third integer will\n  \t\tbe p, as described above. Next will be N integers ti:\n  \t\tthe total points of the Googlers.\n  \t\"\"\"\n  \n  \tfile = open(filename, \"rt\")\n  \n  \tretval = {}\n  \n  \tT = int(file.readline().strip())\n  \tretval['T'] = T\n  \n  \ttests = []\n  \n  \tfor i in xrange(T):\n  \t\tline = file.readline().strip()\n  \n  \t\tparts = line.split(\" \")\n  \n  \t\tN = int(parts[0])\n  \t\tS = int(parts[1])\n  \t\tp = int(parts[2])\n  \t\tt = []\n  \n  \t\tfor j in xrange(N):\n  \t\t\tt = t + [int(parts[3 + j]), ]\n  \n  \t\ttest = { 'N' : N, 'S': S, 'p' : p, 't' : t }\n  \t\ttests = tests + [test, ]\n  \n  \tretval['tests'] = tests\n  \treturn retval\n  \n  def spread(triplet):\n  \treturn max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))\n  \n  def bestresult(triplet):\n  \tif triplet:\n  \t\treturn max(triplet)\n  \treturn 0\n  \n  def getcombos(points):\n  \t\"\"\"\n  \t\tReturns ([unsurprising possibilities, ], [surprising possibilities])\n  \t\"\"\"\n  \n  \tunsurps = []\n  \tsurps = []\n  \n  \tavg = points \/ 3.0\n  \n  \tavg = int(avg)\n  \n  \ttested = []\n  \n  \tfor i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\tfor j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\t\tfor k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\t\t\tif (i + j + k) != points:\n  \t\t\t\t\tcontinue\n  \n  \t\t\t\tscores = (i,j,k)\n  \t\t\t\tscores = sorted(scores)\n  \n  \t\t\t\tif scores in tested:\n  \t\t\t\t\tcontinue\n  \t\t\t\ttested.append(scores)\n  \n  \t\t\t\ts = spread((i,j,k))\n  \n  \t\t\t\tif (s < 2):\n  \t\t\t\t\tunsurps.append(scores)\n  \t\t\t\telif (s == 2):\n  \t\t\t\t\tsurps.append(scores)\n  \t\t\t\telse:\n  \t\t\t\t\tcontinue\n  \n  \treturn (unsurps, surps)\n  \n  def getbesttriplet(triplets):\n  \tbest = None\n  \n  \tfor i in triplets:\n  \t\tif best:\n  \t\t\tif (bestresult(i) > bestresult(best)):\n  \t\t\t\tbest = i\n  \t\telse:\n  \t\t\tbest = i\n  \n  \treturn best\n  \t\n  \n  def getmulticombos(peeps):\n  \t\"\"\"\n  \t\tReturn the best surprising and non-surprising possibility for\n  \t\teach person.\n  \t\"\"\"\n  \n  \tret = []\n  \n  \tfor p in peeps:\n  \t\tu,s = getcombos(p)\n  \n  \t\tbestu = getbesttriplet(u)\n  \t\tbests = getbesttriplet(s)\n  \n  \t\tret.append((bestu, bests))\n  \n  \treturn ret\n  \n  def getbestresults(scores, best, numsur):\n  \t\"\"\"\n  \t\tFigure out the maximum number of people that could have gotten\n  \t\ta single score >= best.  Limited to choosing only numsur surprising\n  \t\ttriplets.\n  \t\"\"\"\n  \n  \tpeeps = getmulticombos(scores)\n  \n  \tcount = 0\n  \tsurcount = 0\n  \n  \tfor p in peeps:\n  \t\tif (bestresult(p[0]) >= best):\n  \t\t\tcount = count + 1\n  \t\telif ((bestresult(p[1]) >= best) and (surcount < numsur)):\n  \t\t\tcount = count + 1\n  \t\t\tsurcount = surcount + 1\n  \n  \treturn count\n  \n  def process(test):\n  \tN = test['N']\n  \tS = test['S']\n  \tp = test['p']\n  \tt = test['t']\n  \n  \treturn getbestresults(t, p, S)\n  \n  data = readfile(\"B-small-attempt0.in\")\n  \n  for i in xrange(data['T']):\n  \ttest = data['tests'][i]\n  \n  \tresult = process(test)\n  \n  \tprint \"Case #%d: %d\" % (i+1, result)\n <CODESPLIT> ","completion":" 56"}
{"prompt":" \n  class Test(unittest.TestCase):\n  \tdef test_1(self):\n  \t\tself.assertEqual(main(1, 4), 2)\n  \tdef test_2(self):\n  \t\tself.assertEqual(main(10, 120), 0)\n  \tdef test_3(self):\n  \t\tself.assertEqual(main(100, 100000000000000), 2)\n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def main(M, N):\n  \tfns = 0\n  \tnum = M\n  \tmaior = math.sqrt(N)\n  \tint_maior = 0\n  \t\n  \tif maior.is_integer():\n  \t\tint_maior = int(maior) - 1\n  \t\tif fair(N):\n  \t\t\tif fair(int(maior)):\n  \t\t\t\tfns += 1\n  \telse:\n  \t\tint_maior = int(maior)\n  \t\t\n  \twhile int_maior >= 1:\n  \t\tif fair(int_maior):\n  \t\t\tquadrado = int_maior * int_maior\n  \t\t\tif quadrado >= M:\n  \t\t\t\tif fair(quadrado):\n  \t\t\t\t\tfns += 1\n  \t\tint_maior -= 1\n  \treturn fns\n  \n  def main2(M, N):\n  \tfns = 0\n  \tnum = M\n  \twhile num <= N:\n  \t\tresult = raiz(num)\n  \t\tif result:\n  \t\t\tif fair(num):\n  \t\t\t\n  \t\t\t\tif fair(result):\n  \t\t\t\t\tfns += 1\n  \t\tnum += 1\n  \treturn fns\n  \t\n  def fair(num):\n  \treturn str(num) == str(num)[::-1]\n  \t\n  def raiz(num):\n  \tresult = math.sqrt(num)\n  \tif result.is_integer():\n  \t\treturn int(result)\n  \telse:\n  \t\treturn False\n  \t\n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tN,M = [int(x) for x in sys.stdin.readline().split(' ')]\t\n  \t\tprint \"Case #%d: %d\" % (i + 1, main(N,M))\n <CODESPLIT> ","completion":" 57"}
{"prompt":" \n  tCase = int(sys.stdin.readline())\n  \n  def alien(frases,case):\n  \t\n  \tcase = case.replace('(','[')\n  \tcase = case.replace(')',']')\n  \t\n  \tER1 = re.compile(case, re.I)\n  \tcount = 0\n  \tfor frase in frases:\n  \t\tif ER1.search(frase):\n  \t\t\tcount += 1\n  \treturn count\n  \n  \n  for i in xrange(tCase):\t\n  \tlinha = sys.stdin.readline().split()\n  \tP = int(linha[1])\n  \tT = int(linha[2])\n  \tlist = []\n  \tfor j in range (3,len(linha)):\n  \t\tlist.append(int(linha[j]))\n  \tlist.sort(reverse=True)\n  \trealT = T*3 - 2\n  \tsupT = realT - 2\n  \t\n  \tcount = 0\n  \tfor item in list:\n  \t\tif item >= realT:\n  \t\t\tcount += 1\n  \t\telif P > 0 and item >= supT and T >= 2:\n  \t\t\tcount += 1\n  \t\t\tP -= 1\n  \t\telif P > 0 and item >= realT and T == 1:\n  \t\t\tcount += 1\n  \t\t\tP -= 1\n  \t\telif T == 0:\n  \t\t\tcount += 1\n  \t\telse:\n  \t\t\tbreak\n  \t\t\n  \tprint \"Case #%d: %d\" % (i+1, count)\n  \t\n  \t\n  \n <CODESPLIT> ","completion":" 57"}
{"prompt":"def sqrt(x, ge):\n      if x == 1:\n          return 1\n      sx = x >> 1\n      step = sx >> 1\n  \n      while step:\n          if sx ** 2 >= x:\n              sx = sx - step\n          else:\n              sx = sx + step\n          step = step >> 1\n  \n      if ge:\n          while not sx ** 2 < x:\n              sx = sx - 1\n          while not sx ** 2 >= x:\n              sx = sx + 1\n      else:\n          while not sx ** 2 > x:\n              sx = sx + 1\n          while not sx ** 2 <= x:\n              sx = sx - 1\n  \n      return sx\n  \n  \n  def get_start_pali(a):\n      s = str(a)\n      ls = len(s)\n      if ls == 1:\n          return s, True\n      elif ls & 1:\n          return s[:ls >> 1 + 1], True\n      else:\n          return s[:ls >> 1], False\n  \n  \n  def get_next_pali(p, m):\n      if len(p) == p.count(\"9\"):\n          if m:\n              return \"1\" + \"0\" * (len(p) - 1), False\n          else:\n              return \"1\" + \"0\" * len(p), True\n      else:\n          return str(int(p) + 1), m\n  \n  \n  def pali_to_num(p, m):\n      if m:\n          return int(p + p[-2::-1])\n      else:\n          return int(p + p[::-1])\n  \n  \n  def is_pali(a):\n      s = str(a)\n      hls = len(s) >> 1\n      return s[:hls] == s[:-hls - 1:-1]\n  \n  for i in range(int(input())):\n      a, b = tuple(map(int, input().split()))\n      sqa, sqb = sqrt(a, True), sqrt(b, False)\n  \n      p, m = get_start_pali(sqa)\n      while pali_to_num(p, m) < sqa:\n          p, m = get_next_pali(p, m)\n  \n      count = 0\n  \n      while True:\n          curr = pali_to_num(p, m)\n          if curr > sqb:\n              break\n          if is_pali(curr ** 2):\n              count = count + 1\n          p, m = get_next_pali(p, m)\n  \n      print(\"Case #{}: {}\".format(i + 1, count))\n <CODESPLIT> ","completion":" 58"}
{"prompt":"def passes(p, t): #normal, surprising\n      q, r = divmod(t, 3)\n      if r == 0:\n          return q >= p, q + 1 >= p and q\n      elif r == 1:\n          return q + 1 >= p, q + 1 >= p and q\n      elif r == 2:\n          return q + 1 >= p, q + 2 >= p\n  \n  for case in range(int(input())):\n      st = input().strip().split()\n      n, s, p, t = int(st[0]), int(st[1]), int(st[2]), list(map(int, st[3:]))\n      result = 0\n      for i in t:\n          normal, surprising = passes(p, i)\n          if normal:\n              result += 1\n          elif surprising and s != 0:\n              result += 1\n              s -= 1\n      print(\"Case #{}: {}\".format(case + 1, result))\n <CODESPLIT> ","completion":" 58"}
{"prompt":"lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,\n      100020001,102030201,104060401,121242121,123454321,125686521,400080004,\n      404090404,10000200001,10221412201,12102420121,12345654321,40000800004,\n      1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,\n      1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,\n      1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,\n      102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,\n      123456787654321,400000080000004]\n  \n  \n  def solve(lo,hi):\n      global lst\n      count = 0\n      for i in range(len(lst)):\n          if (lst[i] >= lo and lst[i] <= hi ):\n              count += 1\n      return count\n  \n  fname = raw_input(\"name of file: \")\n  oname = raw_input(\"output file name:\")\n  f = open(fname,\"r\")\n  out = open(oname,\"w\")\n  n = int(f.readline()[:-1])\n  case_num = 1\n  for line in f:\n      args = line[:-1].split()\n      lo = int(args[0])\n      hi = int(args[1])\n      out.write(\"Case #%d: %d\n\" %(case_num,solve(lo,hi)))\n      case_num += 1\n      \n  out.close()\n  f.close()\n      \n <CODESPLIT> ","completion":" 59"}
{"prompt":"fileName = raw_input(\"File name: \")\n  \n  f = open(fileName,\"r\")\n  \n  t = int(f.readline()[:-1])\n  \n  tests = []\n  \n  for i in range (t):\n      tests += [f.readline()[:-1]]\n  \n  f.close()\n  \n  \n  def compute(raw):\n      dataN = [] # keeps the max mark for not surprising\n      dataS = [] # keeps the max marks for surprisings\n      \n      items = raw.split() \n      \n      for i in range (int(items[0])):\n          ti = int(items[3+i])\n          if ti < 1:\n              dataS += [0]\n              dataN += [0]\n          elif ti > 28:\n              dataS += [10]\n              dataN += [10]\n          else:\n              dataN += [int((ti+2)\/3)] # put the values for all participants\n              dataS += [int((ti+4)\/3)]\n          \n          \n  \n      \n      p = int(items[2])\n      s = int(items[1])\n      \n      n_vals = dataN\n      n_vals.sort()\n      \n  \n      i=0\n      minimum = 0 # how many numbers greater than p are there in \"not surprising\"\n      if n_vals[0] < p:\n          while n_vals[-1-i] >= p:\n              minimum += 1\n              i += 1\n      else:\n          minimum = len(n_vals)\n          \n  \n      s_vals = dataS\n      s_vals.sort()\n      i=0\n      maximum = 0 # how many numbers greater than p are there in \"surprising\"\n      if s_vals[0] < p:\n          while s_vals[-1-i] >= p:\n              maximum += 1\n              i += 1\n      else:\n          maximum = len(n_vals)\n      \n      return min(maximum, minimum+s) \n      \n  \n  for i in range (t):\n      print \"Case #%d: %d\" %(i+1,compute(tests[i]))\n  \n  \n      \n <CODESPLIT> ","completion":" 59"}
{"prompt":" \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(reader(f, *args, **kwargs))\n      return res\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      return read_ints(f)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%d'%res)\n      f.write('\n')\n  \n  \n  def aux(A, B, x, s):\n      res = 0\n      n = int(''.join(x[::-1]+x))\n      nn = n*n\n      if nn > B:\n          return res\n      if nn >= A:\n          res += 1\n      for c in [0, 1, 2]:\n          if s + c*c < 10:\n              n = int(''.join(x[::-1]+[str(c)]+x))\n              nn = n*n\n              if nn >= A and nn <= B:\n                  res += 1\n          if s + 2*c*c < 10:\n              res += aux(A, B, [str(c)]+x, s + 2*c*c)\n      return res\n  \n  def solve_small(case):\n      [A, B] = case\n      res = 0\n      for n in [1, 4, 9]:\n          if n >= A and n <= B:\n              res += 1\n      for c in [1, 2]:\n          res += aux(A, B, [str(c)], 2*c*c)\n      return res\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n <CODESPLIT> ","completion":" 60"}
{"prompt":" \n  __file__ = sys.argv[0]\n  __path__ = os.path.dirname(__file__)\n  __prob__ = os.path.basename(__path__)\n  \n  def pout(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n  \n  def perr(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n  \n  def argmin(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best > y:\n              best = y\n              res = x\n      return res\n  \n  def argmax(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best < y:\n              best = y\n              res = x\n      return res\n  \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_word_arr(f, R):\n      res = []\n      for i in range(R):\n          res.append(read_word(f))\n      return res\n  \n  def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(read_ints(f, *args, **kwargs))\n      return numpy.array(res, dtype)\n  \n  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n      global ERR_FILE\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      err_fn = fn + '.err'\n      if start_case == 0:\n          append = True\n          if os.path.exists(out_fn):\n              with open(out_fn, 'r') as f:\n                  for l in f:\n                      if l[:6] == 'Case #':\n                          start_case = int(l[6:l.index(':')])+1\n      else:\n          append = False\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'a' if append else 'w') as fo:\n              with open(err_fn, 'w') as ERR_FILE:\n                  T = read_int(fi)\n                  for i in range(T):\n                      case = read_case(fi)\n                      if i+1 < start_case:\n                          continue\n                      print('Case #%d of %d'%(i+1, T))\n                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                      perr('case')\n                      res = solver(case)\n                      perr('res')\n                      write_case(fo, i, res)\n                      fo.flush()\n                      if end_case is not None and i+1 == end_case:\n                          break\n  \n  def test(start_case=1, end_case=None):\n      fn = os.path.join(__path__, 'test')\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small2(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case, fn + '2.out')\n  \n  def large(start_case=0, end_case=None):\n      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case)\n  \n  \n  def read_case(f):\n      Z = read_ints(f)\n      (N, S, p) = Z[:3]\n      t = Z[3:]\n      return (N, S, p, t)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%(i+1))\n      f.write('%s'%res)\n      f.write('\n')\n  \n  FAIL = 'NO SOLUTION'\n  \n  def solve_small(case):\n      (N, S, p, t) = case\n      res = 0\n      for i in range(N):\n          if p >= 2:\n              if t[i] >= 3*p-2:\n                  res += 1\n              elif S > 0 and t[i] >= 3*p-4:\n                  res += 1\n                  S -= 1\n          elif p == 1:\n              if t[i] >= 3*p-2:\n                  res += 1\n          elif p == 0:\n              res += 1\n      return res\n  \n  solve_large = solve_small\n  \n  pout = perr\n <CODESPLIT> ","completion":" 60"}
{"prompt":"def esPal(x):\n  \treturn str(x) == str(x)[::-1]\n  \n  t = int(raw_input())\n  \n  for case in range(t):\n  \tline = raw_input().split(' ')\n  \ta = int(line[0])\n  \tb = int(line[1])\n  \n  \ti = int(a**.5)\n  \tif i*i != a:\n  \t\ti += 1\n  \tmax = int(b**.5)\n  \tcantidad = 0\n  \twhile i <= max:\n  \t\tif esPal(i) and esPal(i*i):\n  \t\t\tcantidad += 1\n  \t\ti += 1\n  \n  \tprint 'Case #'+str(case+1)+':', cantidad\n <CODESPLIT> ","completion":" 61"}
{"prompt":"t = int(raw_input())\n  \n  max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]\n  \n  for i in range(t):\n  \tline = raw_input().split(' ')\n  \tn = int(line[0])\n  \ts = int(line[1])\n  \tp = int(line[2])\n  \n  \ttotal = 0\n  \n  \tfor j in range(3, len(line)):\n  \t\tt = int(line[j])\n  \t\tif t == 0:\n  \t\t\tif p == 0:\n  \t\t\t\ttotal += 1\n  \t\telif t%3 == 0:\n  \t\t\tif t\/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\t\telif t\/3 + 1 >= p and s>0:\n  \t\t\t\ttotal +=1\n  \t\t\t\ts -=1\n  \t\telif t%3 == 1:\n  \t\t\tif (t+2)\/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\telse:\n  \t\t\tif (t+1)\/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\t\telif (t+1)\/3 + 1 >= p and s>0:\n  \t\t\t\ttotal +=1\n  \t\t\t\ts -=1\n  \n  \n  \n  \tprint 'Case #'+str(i+1)+':', total\n  \n  \n <CODESPLIT> ","completion":" 61"}
{"prompt":" \n  def is_palindrome(n):\n      s = str(n)\n      return s == s[::-1] \n  \n  palindromes = [[], [1,2,3,4,5,6,7,8,9], [11,22,33,44,55,66,77,88,99]]\n  all_palindromes = palindromes[1] + palindromes[2]\n  limit = [100]\n  \n  palindromic_squares = []\n  psqtop = 0\n  psqix = 0\n  \n  stdin = sys.stdin\n  for c in xrange(int(stdin.readline())):\n      a,b = map(int, stdin.readline().split())\n  \n      while psqtop < b:\n          while psqix >= len(all_palindromes):\n              ps = []\n              pp = 10 ** (len(palindromes)-1) + 1\n              for i in range(1,10):\n                  for p in palindromes[-2]:\n                      ps.append(i * pp + 10 * p) \n              palindromes.append(ps)\n              all_palindromes.extend(ps)\n  \n          sq = all_palindromes[psqix] * all_palindromes[psqix]\n          if is_palindrome(sq):\n              palindromic_squares.append(sq)\n          psqix  += 1\n          psqtop = sq\n  \n      aix = bisect.bisect_left(palindromic_squares, a)\n      bix = bisect.bisect_right(palindromic_squares, b)\n  \n      print \"Case #%i: %i\" % (c+1, bix-aix) \n <CODESPLIT> ","completion":" 62"}
{"prompt":" \n  T = int(stdin.readline())\n  for i in xrange(1,T+1):\n  \tns = map(int, stdin.readline().split())\n  \tN,S,p = ns[0:3]\n  \t\n  \th = 0\n  \tz = 0\n  \n  \tfor n in ns[3:]:\n  \t\tif n <= 1:\n  \t\t\tif n >= p: h += 1\t\n  \t\telif (n+2) \/\/ 3 >= p:\n  \t\t\th += 1\n  \t\telif (n+4) \/\/ 3 >= p:\n  \t\t\tz += 1\n  \n  \tprint \"Case #%d: %d\" % (i, h + min(S,z))\n  \n  \n <CODESPLIT> ","completion":" 62"}
{"prompt":" \n  N = 10**4\n  \n  def isp(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  fs = []\n  for i in range(N):\n      s = str(i)\n      n1 = int(s + s[::-1])**2\n      n2 = int(s[:-1] + s[::-1])**2\n  \n      if isp(n1):\n          fs.append(n1)\n      if isp(n2):\n          fs.append(n2)\n  \n  fs.sort()\n  \n  print(fs, file=sys.stderr)\n  \n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      board = []\n      A, B = map(int, fin.readline().split())\n  \n      i = bisect.bisect_left(fs, A)\n      j = bisect.bisect_right(fs, B)\n  \n      print(\"Case #%d: %s\" % (case, j-i))\n  \n  \n <CODESPLIT> ","completion":" 63"}
{"prompt":" fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      numbers = map(int, fin.readline().split())\n      N, S, p = numbers[:3]\n      T = numbers[3:]\n      normal_limit = p + 2*max(0, (p-1))\n      surpising_limit = p + 2*max(0, (p-2))\n  \n      normal_count = 0\n      surprising_count = 0\n  \n      for t in T:\n          if t >= normal_limit:\n              normal_count += 1\n          elif t >= surpising_limit:\n              surprising_count += 1\n  \n      result = normal_count + min(surprising_count, S)\n  \n      print \"Case #%d: %s\" % (case, result)\n  \n <CODESPLIT> ","completion":" 63"}
{"prompt":" \n  def read_ints():\n      return map(int, stdin.readline().rstrip().split(' '))\n  \n  def is_palin(n):\n      s = str(n)\n      return s == s[::-1]\n      \n  def find(n, fas):\n      for i in xrange(len(fas)):\n          if fas[i] >= n:\n              return i\n      return len(fas)\n      \n  def gen_fas(max):\n      fas = []\n      fasappend = fas.append\n      square, base, d = 1, 1, 3\n      while square < max:\n          if is_palin(square) and is_palin(base):\n              fasappend(square)\n          square += d\n          d += 2\n          base += 1\n      return fas\n      \n  def main():\n      MAX = 1000\n      fas = gen_fas(MAX)\n      \n      T = int(stdin.readline())\n      for Ti in xrange(T):\n          A, B = read_ints()\n          answer = find(B + 1, fas) - find(A, fas)\n          print 'Case #{}: {}'.format(Ti + 1, answer)\n          \n  main()\n <CODESPLIT> ","completion":" 64"}
{"prompt":" \n  def program():\n  \tT = int(stdin.readline())\n  \tfor Ti in xrange(T):\n  \t\tnumbers = a = map(int, stdin.readline().rstrip().split(' '))\n  \t\tN, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]\n  \t\t\n  \t\tm = 0\n  \t\tcurr_S = S\n  \t\tfor i in xrange(N):\n  \t\t\tt = totals[i]\n  \t\t\t\n  \t\t\tif t \/ 3 >= p or (t \/ 3 == p - 1 and t % 3 > 0):\n  \t\t\t\tm += 1\n  \t\t\telif curr_S > 0 and t > 0:\n  \t\t\t\tif (t \/ 3 == p - 1 and t % 3 == 0) or (t \/ 3 == p - 2 and t % 3 == 2):\n  \t\t\t\t\tm += 1\n  \t\t\t\t\tcurr_S -= 1\n  \t\t\n  \t\tprint 'Case #%d: %d' % (Ti + 1, m)\t\n  \t\n  if __name__ == '__main__':\n  \tprogram()\n <CODESPLIT> ","completion":" 64"}
{"prompt":" \n  def get_number_of_test_case():\n      return int(raw_input().strip())\n  \n  def solve_case(t):\n      A, B = [int(x) for x in raw_input().strip().split()]\n  \n      print 'Case #%d: %d' % (t, get_number_of_palindrome(B) - get_number_of_palindrome(A - 1),)\n  \n  def get_number_of_palindrome(n):\n      ret = 0\n  \n      nt = int(math.floor(math.sqrt(n)))\n      total_column = int(math.ceil(math.ceil(math.log10(nt + 1)) \/ 2.0))\n      upper_limit = 10 ** total_column\n  \n      counter = 0\n      while counter < upper_limit:\n          c_str = [c for c in str(counter)]\n          c_str.reverse()\n  \n          number = str(counter)\n          for c in c_str:\n              number += c\n          number = int(number)\n          number = number ** 2\n          if number <= n and is_palindrome(number):\n              ret += 1\n  \n          number = str(counter)\n          for c in c_str[1:]:\n              number += c\n          number = int(number)\n          number = number ** 2\n          if number <= n and is_palindrome(number):\n              ret += 1\n          \n          counter += 1\n  \n      return ret\n  \n  def is_palindrome(n):\n      if n == 0:\n          return False\n      num = str(n)\n      check_len = len(num) \/ 2\n      ret = True\n      for i in range(check_len):\n          ret &= num[i] == num[-i - 1]\n      return ret\n  \n  T = get_number_of_test_case()\n  t = 1\n  while t <= T:\n      solve_case(t)\n      t += 1\n  \n <CODESPLIT> ","completion":" 65"}
{"prompt":"t = int(raw_input().strip())\n  t_count = 1\n  while t_count <= t:\n  \tline = raw_input().strip().split()\n  \tn = int(line[0])\n  \ts = int(line[1])\n  \tp = int(line[2])\n  \tti_list = line[3:]\n  \tp_min = max(p * 3 - 2, p)\n  \tp_min_surprise = max(p * 3 - 4, p)\n  \tresult = 0\n  \tfor ti in ti_list:\n  \t\tti = int(ti)\n  \t\tif ti >= p_min:\n  \t\t\tresult += 1\n  \t\telif p_min > p_min_surprise and ti >= p_min_surprise and s > 0:\n  \t\t\tresult += 1\n  \t\t\ts -= 1\n  \tprint 'Case #%d: %d' % (t_count, result,)\n  \tt_count += 1\n <CODESPLIT> ","completion":" 65"}
