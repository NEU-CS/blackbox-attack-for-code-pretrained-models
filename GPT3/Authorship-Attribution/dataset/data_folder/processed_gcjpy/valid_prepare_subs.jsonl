{"code": " \n  def isqrt(num):\n      return int(sqrt(num))\n  \n  def is_square(num):\n      return isqrt(num)**2 == num\n  \n  def is_palindrome(num):\n      return str(num) == \"\".join(reversed(str(num)))\n  \n  def is_fair_and_square(num):\n      return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))\n  \n  def solve(A,B):\n      count = 0\n      for i in range(A,B+1):\n          if is_fair_and_square(i):\n              count += 1\n      return count\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          A,B = [int(x) for x in raw_input().split()]\n          print \"Case #%d: %d\" % (i, solve(A,B))\n          \n", "substitutes": {"num": ["abc", "input", "b", "inf", "all", "uri", "int", "init", "name", "multi", "nom", "mu", "o", "dom", "nam"], "A": ["API", "alpha", "D", "Ma", "Data", "SA", "TA", "One", "BA", "Pi", "Input", "Y", "Num", "Fa", "Na"], "B": ["Q", " b", "D", "UB", "Other", "b", "RB", "LB", "VB", "Bs", "BER", "BB", "EB", "BA", "Bal"], "count": ["cond", "add", "size", "case", "t", "key", "col", "seq", "n", "b", "loop", "found", "call", "array", "order"], "i": ["ai", "l", "ip", "j", "chi", "cli", "ib", "u", "ti", "t", "I", "n", "b", "ih", "v"], "T": ["P", "Q", "TS", "Z", "D", "TH", "t", "H", "I", "n", "TR", "M", "NT", "total", "TC"], "x": ["rex", "xb", "ex", "exp", "z", "u", " X", "xe", "dx", "xxx", "xd", "n", "r", "xx", "v"]}}
{"code": " \n  def isPalindrome(n):\n  \tn = str(n)\t\n  \tfor i in xrange(len(n)/2):\n  \t\tif n[i] != n[(-i-1)]:\n  \t\t\treturn False\n  \treturn True\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file(\"output.txt\", \"w\")\n  \n  T = eval(f.readline())\n  \n  for case in xrange(T):\n  \tdata = f.readline().split()\n  \tA = eval(data[0])\n  \tB = eval(data[1])\n  \n  \ti = A\n  \tfound = []\n  \twhile i <= B:\n  \t\tif isPalindrome(i):\n  \t\t\tsqrtI = math.sqrt(i)\n  \t\t\tif sqrtI == int(sqrtI):\n  \t\t\t\tif isPalindrome(int(sqrtI)):\n  \t\t\t\t\tfound.append(i)\n  \t\ti += 1\n  \n  \tfout.write(\"Case #%d: %d\n\" %(case + 1, len(found)))\n", "substitutes": {"n": ["l", "j", "z", "t", "u", "out", "pn", "r", "b", "s", "v", "node", "np", "net", "ne"], "i": ["l", "ti", "t", "fi", "b", "inf", "qi", "shift", "phi", "uri", "int", "iri", "multi", "ei", "id"], "inputFileName": ["inputfileName", "inputFilenameName", "outputFilePath", "inputTablePath", "inputFileCopy", "outputFileSize", "inputFilenamePath", "inputFilesName", "inputTableSize", "inputFileSize", "inputFilesPath", "inputFilesCopy", "outputDirHandle", "outputDirName", "inputDirSize"], "f": ["l", "z", "obj", "t", "u", "df", "feed", "iter", "fit", "input", "b", "s", "v", "fd", "r"], "fout": ["FOut", "fouts", "feouts", "FOUT", " foutput", "fOUT", "fein", "woutput", "fOut", "dout", "din", "Foutput", "wout", " fin", "win"], "T": ["P", "Q", "TS", "z", "Z", "D", "TH", "t", "H", "I", "Data", "M", "NT", "total", "p"], "case": ["section", "Case", "ite", "size", "ise", "rice", "key", "ce", "loc", "ue", "core", "me", "count", "pe", "su"], "data": ["config", "aa", "text", "j", "lines", "z", "missing", "database", "alpha", "t", "u", "valid", "feed", "complete", "loc"], "A": ["P", "ai", "API", "Na", "As", "Z", "D", "alpha", "AA", "LA", "am", "H", "I", "b", "Data"], "B": ["P", "Q", "J", "WB", "ab", "Z", "D", " b", "GB", "AB", "I", "H", "b", "BF", "BW"], "found": ["created", "fixed", "l", "missing", "new", "z", "where", "error", "valid", "identified", "iter", "old", "count", "shown", "inf"], "sqrtI": ["supprtI", "sqrtB", " sqrti", "sqratE", " sqntB", "sqntL", "squarertB", "sqrtE", "sqrtU", "sqRTI", "sqrcB", "sqntI", "squarercI", "suppRTL", " sqrati"]}}
{"code": " \n  def solve(lower, upper, cache):\n      counter = 0\n      for item in cache:\n          if item > upper:\n              break\n          if item < lower:\n              continue\n          counter += 1\n      return counter\n  \n  def is_palindrome(test_int):\n      str_arg = str(test_int)\n      return str_arg == str_arg[::-1]\n  \n  def generate_cache():\n      \"\"\" Generates a list of 'fair and square' numbers between 1 and 10^100\n  \n      By observation of generating the first few of these numbers it became\n      obvious that the 'roots' fitted a very specific pattern, they are either\n      single digits and 1,2 or 3; multiple digits consisting of only 1s and 0s;\n      multiple digits with a 2 at the beginning and end and 1s and 0s in the\n      middle or an odd number of digits with a single 2 in the centre and 1s and\n      0s elsewhere.\n  \n      This function therefore only looks at these numbers to build a list of all\n      valid results. \"\"\"\n      cache = [9,]\n      counter = 1\n      if upper_bound is None:\n          upper_bound = pow(2,25)\n      while counter < upper_bound:\n          binary_part = \"{0:b}\".format(counter)\n          half_int = binary_part\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = \"%s%s\" % (binary_part, 2)\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = \"2%s\" % binary_part[1:]\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          counter += 1\n      return sorted(cache)\n  \n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                        help=\"read input from FILE\", metavar=\"FILE\")\n      parser.add_option(\"-c\", \"--cache\", dest=\"cache_filename\",\n                        help=\"read/write cache from/to CACHE_FILE\", metavar=\"CACHE_FILE\")\n      parser.add_option(\"-g\", \"--generate-cache\", dest=\"generate_cache\",\n                        help=\"generate the cache file\", action=\"store_true\")\n      cache = None\n      (options, args) = parser.parse_args()\n      if options.generate_cache:\n          cache = generate_cache()\n          if not options.cache_filename:\n              output_file = open(options.cache_filename, \"w\")\n              pickle.dump(cache, output_file)\n              output_file.close()\n      else:\n          cache_file = open(options.cache_filename, \"r\")\n          cache = pickle.load(cache_file)\n          cache_file.close()\n      if not options.filename:\n          parser.error(\"Must provide a filename.\")\n      input_file = open(options.filename, \"r\")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n          case_number += 1\n          lower,upper = input_file.readline().split()\n          lower = int(lower)\n          upper = int(upper)\n          data_args = (lower, upper, cache)\n          print \"Case #%d: %s\" % (case_number, solve(*data_args))\n  \n  if __name__ == \"__main__\":\n      main()\n", "substitutes": {"lower": ["small", "l", "middle", "min", "new", "old", "range", "zero", "little", "equal", "future", "less", "source", "front", "left"], "upper": ["inter", "middle", "older", "alpha", "final", "iter", "old", "range", "actual", "header", "future", "master", "inner", "prev", "er"], "cache": ["co", "css", "clear", "menu", "chain", "function", "buffer", "file", "mc", "list", "table", "conf", "tree", "c", "ci"], "counter": ["clear", "progress", "key", "all", "ception", "master", "name", "function", "buffer", "gc", "seed", "handler", "ctr", "list", "cher"], "item": ["step", "section", "anything", "page", "amp", "case", "unit", "iter", "example", "obj", "key", "atom", "menu", "url", "rate"], "test_int": ["testing_integer", "testing_ind", "Test_arg", "testing_int", "test_integer", "testing_inter", "test_arg", "Test_id", "test_inter", "Test_inter", "test_id", "test_ind", "Test_int"], "str_arg": ["str2args", " str1min", "str_slice", " str_args", "str2Arg", " str_slice", " str6val", " str1mag", "str_Arg", "str1arg", "str2argument", "str_min", "str5Arg", "str1mag", " str_argument"], "upper_bound": ["upper_Bound", "upper67bottom", "upperboundlimit", "upper_limit", "outer_Bound", "lower_max", "lower_domain", "upperboundbound", "upperFrange", "lower_limit", "lower_range", "lower_bottom", "upperboundBound", "upperFbottom", "upperFdomain"], "binary_part": ["binary00party", "binary2Part", " binary_int", "binary67int", "padding00patch", "binary00part", "binary_word", "padding00field", "bin_string", "padding_part", " binary_format", "bin_part", "binary67Part", "binary00field", "binary67part"], "half_int": ["halfWexp", "half_next", "half_hard", "half67ani", "half67inc", "halfOint", "halfNINT", "halfedint", " half_inc", "half2INT", "halfedINT", "half___string", "halfhuint", "halffINT", "halfhintel"], "pal_int": ["apple_uint", "pallint", "bel2int", "half_net", "palhints", "palJslice", "cell_inter", "style_int", "palldesc", "palgind", "panellint", "pal48uint", "pal67alt", "palPelement", "palFformat"], "pal_square": ["al_close", "pal24steel", "palMsingle", "isal_inter", "cellkint", "pal_steel", "global_circle", "palpysquare", "palJout", "fill_circle", "palPvoid", "pal_radius", "palhquarter", "palxhole", "isal_private"], "parser": ["section", "config", "reader", "upload", "per", "loader", "py", "api", "server", "menu", "lp", "pm", "s", "au", "node"]}}
{"code": " \n  def solve(icase, case_input):\n      case_output = 'Case #%i: '%icase\n      \n      result = 0\n      raw = [int(x) for x in case_input[0].split()]\n      ts = raw[3:]\n      ct = raw[1]\n      n = raw[2]\n      cc = 0\n      for i in ts:\n          if i > 3*n-3:\n              result += 1\n          elif i > max(3*n-5, 0):\n              cc += 1\n      result += min(cc, ct)\n  \n      case_output += '%d'%result\n      \n      return case_output\n  \n  \n  def main():\n      global use_test_data\n      global test_data\n      global input_file\n      global output_file\n      \n      if use_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for icase in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(icase, input)\n          print rslt\n          if not use_test_data:\n              print >> output_file, rslt\n      \n      if not use_test_data:\n          input_file.close()\n          output_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = \"\"\"4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \"\"\"\n      use_test_data = False\n      \n      test_file = 'B-small-attempt0.in'\n      if not use_test_data and '' != test_file:\n          input_file = open(test_file)\n          output_file = open(test_file + '.out', 'w')\n      \n      main()\n", "substitutes": {"icase": ["iccace", "ikases", "ikape", "iacace", "ticased", "ICasing", "ticase", "icace", "iacasing", "wicase", "ICast", "unicases", "iccase", "unicase", "aicase"], "case_input": ["case_data", "Case_output", " case_file", "Case_source", "case_source", " case_data", "Case_data", "Case_input", "case_file"], "case_output": [" case_Output", " case_write", "case2output", " case_file", "case2Output", "case2write", "case_Output", "case_file", "case_final", " case_final", "case_unit", " case_unit", "case_write"], "result": ["character", "function", "runner", "cont", "grade", "inc", "conf", "coll", "counter", "instance", "feature", "case", "out", "df", " r"], "raw": ["RAW", "exp", "shape", "new", "null", "feed", "complete", "rew", "right", "now", "xml", "uc", "node", "flat", "full"], "x": ["ex", "l", "t", "xx", "int", "sex", "name", "id", "file", "rx", "cl", "line", "tx", "xs", "h"], "ts": ["ths", "tc", "TS", "features", "lines", "t", "states", "ms", "s", "tt", "cs", "tests", "stats", "ats", "acc"], "ct": ["config", "tc", "dc", "case", "t", "ce", "ss", "col", "count", "cd", "uc", "ic", "conn", "cs", "fc"], "n": ["l", "adj", "j", "min", "z", "t", "u", "pn", "max", "r", "b", "count", "v", "s", "nu"], "cc": ["co", "tc", "dc", "kk", "case", "ce", "cca", "cas", "cu", "count", "cd", "uc", " CC", "cs", "conn"], "i": ["ai", "l", "ip", "j", "iac", "z", "chi", "t", "ti", "u", "I", "b", "s", "v", "inf"], "data": ["step", "config", "image", "reader", "text", "lines", "zip", "database", "case", "api", "feed", "complete", "value", "xml", "Data"], "T": ["P", "Q", "J", "DT", "TS", "Z", "D", "TH", "t", "H", "I", "TR", "M", "A", "NT"], "iLine": ["siBlock", "iiDay", "iiCo", "siCo", "siLine", "liL", "siDay", " iPage", "iL", "IL", "uBlock", "iRange", "uPage", "IBlock", " iL"], "caseLineNum": ["caseLineLen", "caseEntryNum", "caseRowLen", "choiceLineLen", "caseLineNo", " caselineSum", "caseEntrySum", "choiceNameNo", "caselineNumber", " caselineNumber", "caseNameLen", "caseBlockSum", "caseRowNum", "caseLineNumber", " caselineNUM"], "input": ["step", "config", "image", "shape", "text", "view", "reader", "new", "submit", "ip", "null", "unit", "feed", "pull", "xml"], "rslt": ["Rsl", "rslet", "rotslett", "rslett", "Rslett", "srgt", "rotslt", "RSlt", "RSlet", "rstail", " rslet", " rstail", "Rslt", "srtail", "RSelt"], "test_data": ["test2data", "outputingfile", "case_data", " test_string", "testacdata", "testingwindow", "test_body", "testcasewindow", "output_database", "test2template", "outputingdatabase", "testingdata", "output_window", "outputingwindow", "test_filename"], "use_test_data": ["use_case_Data", "use_case_function", "use_testerData", "use_test2dat", "use_testing_Data", "use_testingData", "use_testing_break", "use_testing_dat", "use_testingresults", "use_test_function", "use_test_Data", "use_testing_class", "use_testing_data", "use_test2file", "use_Test_dat"], "test_file": ["testingline", " testingfile", " testingdata", "test_type", " testpfolder", "testmemfiles", " test_folder", "testpdir", " test_FILE", "testablefolder", "test_download", "testing_line", "test_files", "test_line", "testingfolder"], "input_file": ["output_source", "input_table", "input2buffer", "inputPoolfile", "output_data", "input_files", "input2line", " input_data", "input2file", "output_files", " input_log", "input_data", "input_source", "output_table", "inputPoolfiles"], "output_file": ["case_files", "outputingfile", "outputinglog", "case_data", " output_log", " output_channel", "output_line", "output_channel", "output_directory", "output_log", "output_data", "input_directory", "outputJfil", "outputJlog", "output_fil"]}}
{"code": "T = int(raw_input())\n  for t in xrange(T):\n      line = map(int, raw_input().split())\n      N, S, p = line[0:3]\n      a = line[3:]\n      cnt = 0\n      a.sort(reverse=True)\n      for x in a:\n          if (x + 2) / 3 >= p:\n              cnt += 1\n          elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:\n              cnt += 1\n              S -= 1\n          else:\n              break\n      print \"Case #%d: %d\" % (t + 1, cnt)\n", "substitutes": {"T": ["P", "Q", "TS", "z", "Z", "D", "H", "I", "n", "M", "A", "NT", "TC", "TW", "Time"], "t": ["l", "section", "text", "j", "z", "u", "i", "ti", "col", "n", "b", "s", "v", "tt", "total"], "line": ["LINE", "log", "l", "section", "strip", "text", "cell", "le", "lines", "page", "link", "inline", "case", "out", "comment"], "N": ["Q", "P", "Z", "D", "H", "n", "I", "M", "NA", "A", "NT", "SN", "na", "ns", "G"], "S": ["P", "Q", "State", "J", "Na", "size", "Z", "D", "Size", "ss", "POS", "H", "n", "I", "s"], "p": ["P", "l", "j", "z", "pp", "per", "i", "u", "n", "r", "b", "s", "lp", "pe", "cp"], "a": ["aa", "ai", "l", "wa", "section", "sta", "ab", "z", "alpha", "i", "va", "am", "ada", "oa", "n"], "cnt": ["ncnt", "lcnc", "pnd", "pct", "cgt", "lcrt", "count", " count", " crt", "ppt", "fcrt", "incnt", " cct", "incgt", "lcct"], "x": ["step", "xb", "ex", "l", "P", "j", "z", "size", "page", "case", "u", "i", " X", "dx", "insert"]}}
{"code": "def IsPal(n):\n      S = str(n);\n      return S == S[::-1];\n  \n  \n  def Gen():\n      LIM = 10**14;\n      N = 10**7;\n      LIST = [];\n      for i in range(1, N):\n          if IsPal(i):\n              if IsPal(i*i):\n                  LIST.append(i);\n      return LIST\n  \n  PP = Gen();\n  \n  T = int(raw_input());\n  for q in range(1,T+1):\n      [A,B] = map(int, raw_input().split());    \n      ANS = 0;\n      for i in range(len(PP)):\n          if B >= PP[i]**2 >= A:\n              ANS += 1;\n      \n      print \"Case #%d: %d\" %(q, ANS);\n", "substitutes": {"n": ["l", "j", "z", "t", "pn", "u", "r", "b", "s", "v", "nw", "net", "ne", "name", "k"], "S": ["P", "Q", "TS", "D", "ASS", "H", "I", "Su", "s", "M", "SO", "SU", "Sing", "String", "SB"], "LIM": ["LINK", "LAMP", " LINK", " LOM", "NLOM", "LROM", "NLINK", "NLAMP", "LRIM", "NLIM", "LRAMP", "LOM", " LAMP", "LRINK"], "N": ["Q", "P", "J", "Z", "D", "Size", "NI", "H", "I", "SIZE", "M", "NT", "Len", "NN", "NB"], "LIST": ["IST", "Q", "l", "IN", "API", "ALL", "Data", "all", "FACE", "list", "VERSION", "SE", "NAME", "PN", "SL"], "i": ["l", "t", "ti", "input", "b", "inf", "qi", "phi", "uri", "int", "id", "list", "o", "io", "h"], "PP": ["P", "Q", "WP", "pp", "TP", " LP", "DC", "Ps", "AB", "MP", "IP", "PO", "TX", "LB", "PD"], "T": ["Q", "P", "TS", "size", "Z", "D", "TH", "t", "TP", "H", "SIZE", "OT", "PO", "TX", "M"], "q": ["Q", "P", "l", "qu", "j", "sq", "count", "u", "t", "MQ", "I", "b", "r", "v", "qt"], "A": ["AR", "P", "Q", "ai", "API", "As", "D", "alpha", "AA", "LA", "AB", "I", "M", "AN", "AM"], "B": ["AR", "P", "Q", "J", "WB", "II", " b", "D", "AA", "LA", "AB", "I", "b", "BF", "M"], "ANS": ["\u03b1", "P", "Q", "AR", "ANN", "ANGE", "QB", "OPA", "ANT", "ANI", "AU", "ENA", "LA", "URN", "POS"]}}
{"code": "t = int(raw_input())\n  \n  max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]\n  \n  for i in range(t):\n  \tline = raw_input().split(' ')\n  \tn = int(line[0])\n  \ts = int(line[1])\n  \tp = int(line[2])\n  \n  \ttotal = 0\n  \n  \tfor j in range(3, len(line)):\n  \t\tt = int(line[j])\n  \t\tif t == 0:\n  \t\t\tif p == 0:\n  \t\t\t\ttotal += 1\n  \t\telif t%3 == 0:\n  \t\t\tif t/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\t\telif t/3 + 1 >= p and s>0:\n  \t\t\t\ttotal +=1\n  \t\t\t\ts -=1\n  \t\telif t%3 == 1:\n  \t\t\tif (t+2)/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\telse:\n  \t\t\tif (t+1)/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\t\telif (t+1)/3 + 1 >= p and s>0:\n  \t\t\t\ttotal +=1\n  \t\t\t\ts -=1\n  \n  \n  \n  \tprint 'Case #'+str(i+1)+':', total\n  \n  \n", "substitutes": {"t": ["l", "art", "ti", "lt", "b", "ot", "int", "rt", "table", "ta", "tp", "o", "ct", "h", "y"], "max": ["step", "maximum", "min", "size", "out", "iter", "count", "trial", "it", "all", "type", "default", "Max", "k", "current"], "i": ["l", "ai", "ip", "ij", "z", "iw", "ib", "u", "ti", "col", "I", "im", "r", "v", "b"], "line": ["co", "l", "inline", "key", "input", "b", "shell", "chain", "ne", "frame", "name", "id", "file", "list", "cl"], "n": ["l", "z", "size", "pn", "count", "b", "v", "ot", "span", "np", "net", "ne", "k", "nr", "d"], "s": ["l", "b", "tests", "stats", "downs", "tp", "steps", "comments", "posts", "xs", "ments", "y", "c", "g", "resses"], "p": ["l", "pp", "b", "pr", "ot", "op", "prev", "tp", "point", "o", "proc", "ap", "h", "y", "pt"], "total": ["otal", "alpha", "key", "right", "volume", "scale", "all", "stats", "multi", "active", "gross", "ta", "tp", "json", "start"], "j": ["bj", "note", "J", "uj", "l", "ip", "ji", "z", "obj", "ij", "jl", "u", "r", "b", "v"]}}
{"code": " \n  \n  \n  def calculatepalindromes(ndigits):\n      if ndigits == 1:\n          return 3\n  \n      result = 0\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)/2)\n  \n      if isEven:\n          result += 1\n      else:\n          result += 3\n  \n      for numones in range(0, min(6, fillingdigits) + 1):\n          combinations = int(math.factorial(fillingdigits) / (math.factorial(fillingdigits-numones) * math.factorial(numones)))\n          result += combinations\n          if not isEven:\n              result += combinations\n  \n      return result\n  \n  \n  def findpalindromes(ndigits):\n      if ndigits == 1:\n          return [1, 2, 3]\n  \n      result = []\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)/2)\n  \n      if isEven:\n          result.append(int(\"2\" + \"0\"*(fillingdigits*2) + \"2\"))\n      else:\n          result.append(int(\"2\" + \"0\"*fillingdigits + \"0\" + \"0\"*fillingdigits + \"2\"))\n          result.append(int(\"2\" + \"0\"*fillingdigits + \"1\" + \"0\"*fillingdigits + \"2\"))\n          result.append(int(\"1\" + \"0\"*fillingdigits + \"2\" + \"0\"*fillingdigits + \"1\"))\n  \n      for numones in range(0, min(6, fillingdigits)+1):\n          ones = fillOnes([], fillingdigits, numones)\n          for o in ones:\n              if isEven:\n                  result.append(int(\"1\" + \"\".join(o) + \"\".join(list(reversed(o))) + \"1\"))\n              else:\n                  result.append(int(\"1\" + \"\".join(o) + \"0\" + \"\".join(list(reversed(o))) + \"1\"))\n                  result.append(int(\"1\" + \"\".join(o) + \"1\" + \"\".join(list(reversed(o))) + \"1\"))\n  \n      return result\n  \n  def fillOnes(combination, size, remainingOnes):\n      if len(combination) == size:\n          return [combination]\n      result = []\n      if remainingOnes > 0:\n          c = combination + [\"1\"]\n          result += fillOnes(c, size, remainingOnes - 1)\n      if remainingOnes < size - len(combination):\n          c = combination + [\"0\"]\n          result += fillOnes(c, size, remainingOnes)\n      return result\n  \n  \n  \n  ncases = int(sys.stdin.readline())\n  \n  for t in range(1, ncases+1):\n      fairsquare = 0\n      (a, b) = sys.stdin.readline().strip().split(\" \")\n      intA = int(a)\n      intB = int(b)\n      ndigitsA = len(a)\n      ndigitsB = len(b)\n      ndigitsARooted = math.ceil(ndigitsA/2)\n      ndigitsBRooted = math.ceil(ndigitsB/2)\n  \n      if ndigitsBRooted == ndigitsARooted:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA and p ** 2 <= intB:\n                  fairsquare +=1\n      else:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA:\n                  fairsquare +=1\n  \n          for i in range(ndigitsARooted + 1, ndigitsBRooted):\n              fairsquare += calculatepalindromes(i)\n  \n          palindromes = findpalindromes(ndigitsBRooted)\n          for p in palindromes:\n              if p ** 2 <= intB:\n                  fairsquare +=1\n  \n      print(\"Case #%d: %d\" % (t, fairsquare))\n", "substitutes": {"ndigits": ["ngigions", "ndiggits", "ngigenits", "mdigets", "ndigbits", "ddigsals", "ndigges", "unddigets", "ndighins", "ndligites", "ntigets", "ndignit", "ldigenits", "ndligets", "ldigits"], "result": ["progress", "desc", "rest", "all", "function", "master", "buffer", "also", "fr", "runner", "list", "table", "other", "json", "grade"], "isEven": ["isDown", "isiElectric", "lisDeep", "isoExactly", "sDown", "phisElectric", "phisOpen", "phisExactly", " iseven", "isAll", "phisEqu", "lisOpen", "isySingle", " isElectric", "lisEven"], "fillingdigits": ["falingdigit", "fillingDigbits", "filingmultiplites", "fillingdigites", "fillingdimITS", "fillingmultiplists", "fillingdigets", "fillingbigins", "fillinglogITS", "fillingsignitives", "filledsignITS", "fillingDigensions", "falingdigites", "fillingdecins", "filledDigits"], "numones": ["ncells", "numtones", "mutcycles", "numbertimes", "numoes", " nummany", "nomONES", "numless", "nomones", "numubes", "Numcycles", "nummany", "numletters", "mutones", "nommany"], "combinations": ["Combinates", " combins", "cominations", "combinators", "clination", "comination", "clinations", "Combinations", "clinates", " combinates", "clines", "combins", "combinates", "clinators", "comines"], "ones": ["ox", "lo", "ubes", "videos", "lines", "z", "oes", "onents", "these", "aves", " phones", "nos", " zones", "oning", "one"], "o": ["co", "l", "ot", "bo", "op", "oo", "objects", "other", "od", "io", "\u00f3", "oice", "ou", "ol", "y"]}}
{"code": " \n  \n  def best(total):\n      \"\"\"Return the best possible score for the given `total`.  Assume\n      the total is computed by summing exactly three scores (each in the\n      interval of 0 to 10 inclusive) and no score can be 2 points apart\n      \n      Arguments:\n      - `total`:\n      \"\"\"\n      m = total % 3\n      if m == 2:\n          b = total // 3 + 2\n      else:\n          b = total // 3 + 1\n      if b > 10:\n          b = 10\n      return b\n  \n  def best_non_surprising(total):\n      \"\"\"Return the best possible score for the given `total`, but\n      assume that there should be no more than 1 point difference\n      between the scores.\n  \n      Arguments:\n      - `total`:\n      \"\"\"\n      if total % 3 == 0:\n          return total // 3\n      else:\n          return total // 3 + 1\n  \n  def max_num_gte_p(totals, S, p):\n      \"\"\"Return the maximum number of Googlers that could have had a\n      best result of at least p.\n      \n      Arguments:\n      - `totals`:\n      - `S`: number of surprising triplets of scores\n      - `p`:\n      \"\"\"\n      res = 0\n      for total in totals:\n          if total == 0:\n              if p == 0:\n                  res += 1\n              continue\n  \n          if best_non_surprising(total) >= p:\n              res += 1\n          elif S > 0 and best(total) >= p:\n              res += 1\n              S -= 1\n  \n      return res\n  \n  def main():\n      with open(sys.argv[1], 'r') as f:\n          f.readline()            # skip T\n  \n          n = 0\n          for line in f:\n              n += 1\n  \n              line = [int(s) for s in line.split()]\n              N = line[0]\n              S = line[1]\n              p = line[2]\n              totals = line[3:]\n  \n              print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"total": ["otal", "t", "i", "largest", "scale", "all", "stats", "master", "multi", "good", "mass", "gross", "table", "ta", "mu"], "m": ["l", "mm", "j", "mt", "mas", "t", "i", "mean", "u", "mad", "mr", "am", "ms", "r", "md"], "b": ["l", "j", "ab", "z", "bl", "ib", "t", "i", "rb", "u", "bb", "null", "r", "v", "wb"], "totals": ["totsials", "pottales", "tfatials", "totall", "toballs", "tOTalls", "pottalities", "pottalls", "potales", "tottalities", "totsals", "ntotall", "ntotials", "tfatales", "pottals"], "S": ["Q", "J", "State", "D", "Sign", "Ps", "o", "GS", "SE", "Ns", "Results", "SL", "Sn", "L", "Y"], "p": ["l", "pp", "t", "i", "pr", "op", "press", "all", "tp", "o", "proc", "ap", "h", "y", "start"], "res": ["exp", "es", "j", "z", "sys", "obj", "sol", "final", "out", "max", "nos", "ms", "pres", "r", "req"], "n": ["l", "j", "z", "size", "t", "i", "u", "max", "r", "v", "nu", "count", "net", "ne", "ln"], "line": ["co", "l", "inline", "key", "i", "int", "ne", "frame", "ln", "name", "file", "cl", "point", "o", "rule"], "s": ["opt", "l", "sq", "sec", "size", "sys", "lines", "sol", "unit", "t", "u", "i", "ss", "r", "ses"], "N": ["P", "Q", "Z", "D", " Ne", "I", "M", "ne", "SN", "NR", "ns", "NL", "G", "ni", "num"]}}
{"code": " \n  def readfile(filename):\n  \t\"\"\"\n  \t\tThe first line of the input gives the number of test\n  \t\tcases, T. T test cases follow. Each test case consists of\n  \t\ta single line containing integers separated by single\n  \t\tspaces. The first integer will be N, the number of\n  \t\tGooglers, and the second integer will be S, the number\n  \t\tof surprising triplets of scores. The third integer will\n  \t\tbe p, as described above. Next will be N integers ti:\n  \t\tthe total points of the Googlers.\n  \t\"\"\"\n  \n  \tfile = open(filename, \"rt\")\n  \n  \tretval = {}\n  \n  \tT = int(file.readline().strip())\n  \tretval['T'] = T\n  \n  \ttests = []\n  \n  \tfor i in xrange(T):\n  \t\tline = file.readline().strip()\n  \n  \t\tparts = line.split(\" \")\n  \n  \t\tN = int(parts[0])\n  \t\tS = int(parts[1])\n  \t\tp = int(parts[2])\n  \t\tt = []\n  \n  \t\tfor j in xrange(N):\n  \t\t\tt = t + [int(parts[3 + j]), ]\n  \n  \t\ttest = { 'N' : N, 'S': S, 'p' : p, 't' : t }\n  \t\ttests = tests + [test, ]\n  \n  \tretval['tests'] = tests\n  \treturn retval\n  \n  def spread(triplet):\n  \treturn max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))\n  \n  def bestresult(triplet):\n  \tif triplet:\n  \t\treturn max(triplet)\n  \treturn 0\n  \n  def getcombos(points):\n  \t\"\"\"\n  \t\tReturns ([unsurprising possibilities, ], [surprising possibilities])\n  \t\"\"\"\n  \n  \tunsurps = []\n  \tsurps = []\n  \n  \tavg = points / 3.0\n  \n  \tavg = int(avg)\n  \n  \ttested = []\n  \n  \tfor i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\tfor j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\t\tfor k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\t\t\tif (i + j + k) != points:\n  \t\t\t\t\tcontinue\n  \n  \t\t\t\tscores = (i,j,k)\n  \t\t\t\tscores = sorted(scores)\n  \n  \t\t\t\tif scores in tested:\n  \t\t\t\t\tcontinue\n  \t\t\t\ttested.append(scores)\n  \n  \t\t\t\ts = spread((i,j,k))\n  \n  \t\t\t\tif (s < 2):\n  \t\t\t\t\tunsurps.append(scores)\n  \t\t\t\telif (s == 2):\n  \t\t\t\t\tsurps.append(scores)\n  \t\t\t\telse:\n  \t\t\t\t\tcontinue\n  \n  \treturn (unsurps, surps)\n  \n  def getbesttriplet(triplets):\n  \tbest = None\n  \n  \tfor i in triplets:\n  \t\tif best:\n  \t\t\tif (bestresult(i) > bestresult(best)):\n  \t\t\t\tbest = i\n  \t\telse:\n  \t\t\tbest = i\n  \n  \treturn best\n  \t\n  \n  def getmulticombos(peeps):\n  \t\"\"\"\n  \t\tReturn the best surprising and non-surprising possibility for\n  \t\teach person.\n  \t\"\"\"\n  \n  \tret = []\n  \n  \tfor p in peeps:\n  \t\tu,s = getcombos(p)\n  \n  \t\tbestu = getbesttriplet(u)\n  \t\tbests = getbesttriplet(s)\n  \n  \t\tret.append((bestu, bests))\n  \n  \treturn ret\n  \n  def getbestresults(scores, best, numsur):\n  \t\"\"\"\n  \t\tFigure out the maximum number of people that could have gotten\n  \t\ta single score >= best.  Limited to choosing only numsur surprising\n  \t\ttriplets.\n  \t\"\"\"\n  \n  \tpeeps = getmulticombos(scores)\n  \n  \tcount = 0\n  \tsurcount = 0\n  \n  \tfor p in peeps:\n  \t\tif (bestresult(p[0]) >= best):\n  \t\t\tcount = count + 1\n  \t\telif ((bestresult(p[1]) >= best) and (surcount < numsur)):\n  \t\t\tcount = count + 1\n  \t\t\tsurcount = surcount + 1\n  \n  \treturn count\n  \n  def process(test):\n  \tN = test['N']\n  \tS = test['S']\n  \tp = test['p']\n  \tt = test['t']\n  \n  \treturn getbestresults(t, p, S)\n  \n  data = readfile(\"B-small-attempt0.in\")\n  \n  for i in xrange(data['T']):\n  \ttest = data['tests'][i]\n  \n  \tresult = process(test)\n  \n  \tprint \"Case #%d: %d\" % (i+1, result)\n", "substitutes": {"filename": ["rl", "section", "ppa", "knife", "folder", "size", "database", "journal", "figure", "description", "url", "path", "sf", "connection", "fd"], "file": ["le", "l", "log", "view", "reader", "wave", "page", "folder", "per", "feed", "iter", "pool", "server", "url", "File"], "retval": ["reteval", "Retvals", "retvalue", "Retval", "rtvals", " retvalue", "rtvalue", " retVal", "retvals", "Reteval", "returnret", "retret", "experval", " reteval", "attVal"], "T": ["P", "J", "Q", "DT", "TS", "Z", "D", "Size", "TH", "GT", "H", "I", "TX", "TR", "M"], "tests": ["docs", "features", "values", "lines", "TS", "example", "sections", "forms", "path", "seq", "reports", "tags", "txt", "stats", "fts"], "i": ["l", "iw", "ti", "b", "qi", "phi", "int", "ei", "id", "o", "io", "jit", "iq", "h", "y"], "line": ["strip", "log", "l", "le", "section", "cell", "text", "LINE", "lines", "page", "inline", "unit", "out", "comment", "server"], "parts": ["section", "format", "features", "lines", "piece", "bits", "args", "sections", "py", "ins", "forms", "cats", "letters", "data", "partial"], "N": ["P", "J", "Q", "Na", "Out", "Size", "D", "Z", "NI", "H", "n", "NC", "RN", "M", "NA"], "S": ["P", "J", "Q", "Size", "D", "Sign", "Sc", "n", "I", "M", "SU", "A", "se", "SN", "SA"], "p": ["P", "J", "l", "ip", "z", "pp", "per", "py", "eps", "n", "r", "b", "v", "pressure", "pr"], "t": ["P", "l", "tc", "z", "target", "n", "b", "v", "ot", "tt", "tu", "port", "trial", "it", "total"], "j": ["J", "uj", "l", "b", "pr", "qi", "int", "ne", "sh", "o", "io", "h", "y", "pt", "c"], "test": ["step", "trip", "ester", "section", "tri", "target", "py", "case", "valid", "unit", "example", "server", "value", "v", "flat"], "triplet": ["triple", "dipper", "prompper", "traple", "complet", "diple", "roupped", "Tript", "trips", "rouple", "Triplet", "tripper", "comple", "promps", "rouplets"], "points": ["windows", "grades", "breaks", "objects", "point", "steps", "cells", "reset", "posts", "offs", "pins", "dates", "planes", "start", "Point"], "unsurps": ["untype", "Unsurpe", "untypped", "unwrape", "unserpe", "untrippings", "Unwrap", "unsurplet", "UnSurppings", "unserplet", "UnSurp", "unsurppings", "Unsurps", "UnSurpps", "Unwrape"], "surps": ["surples", "trip", "strips", "trips", "surplets", "stripps", "urples", "sup", "urplets", "urppers", "supps", "Surplets", "urps", "supoints", "urp"], "avg": ["afge", "afga", "abc", "ravgar", " avgn", "abp", "svge", "AVG", "AVc", "ajgm", "avc", "apga", "avgo", "ravgz", "svga"], "tested": ["handled", "videos", "closed", "rounded", "raped", "Testing", "aligned", "checked", "selected", "trained", "connected", "valid", "rolled", "opened", " Tests"], "k": ["ak", "ip", "kk", "z", "key", "iv", "ki", "dk", "max", "ke", "n", "ks", "b", "r", "v"], "scores": ["scriptorer", "cores", " scorer", "SCores", "Scores", " Scorer", "sporer", "spopes", "missore", "locopes", "escenses", "scriptores", "scopes", "Scors", " scors"], "s": ["l", "es", "sq", "lines", "services", "sports", "ins", "sets", "ss", "states", "sup", "n", "sf", "ses", "v"], "triplets": ["dipps", "dropps", " triples", "trips", "Triplet", "polyps", "diplets", "tripps", "polyples", "traplets", " trips", "tript", "traps", "drops", "trapt"], "best": [" closest", "hess", "new", "suggest", "null", "final", "masters", "valid", "right", "value", "largest", " winner", "pop", "stable", "live"]}}
