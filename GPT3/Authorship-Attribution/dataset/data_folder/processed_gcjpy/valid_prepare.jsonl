{"prompt": " \n  def isqrt(num):\n      return int(sqrt(num))\n  \n  def is_square(num):\n      return isqrt(num)**2 == num\n  \n  def is_palindrome(num):\n      return str(num) == \"\".join(reversed(str(num)))\n  \n  def is_fair_and_square(num):\n      return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))\n  \n  def solve(A,B):\n      count = 0\n      for i in range(A,B+1):\n          if is_fair_and_square(i):\n              count += 1\n      return count\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          A,B = [int(x) for x in raw_input().split()]\n          print \"Case #%d: %d\" % (i, solve(A,B))\n          \n <CODESPLIT> ", "completion": " 33"}
{"prompt": "arq = file(\"input.in\")\n  n_cases = eval(arq.readline())\n  out = file(\"output.txt\", \"w\")\n  \n  for case in xrange(n_cases):\n  \n  \tdata = arq.readline()\n  \tdata = data.strip()\n  \tdata = data.split(\" \")\n  \n  \tn = eval(data[0])\n  \ts = eval(data[1])\n  \tp = eval(data[2])\n  \n  \tscores = []\n  \tn_googlers_with_best_result = 0\n  \tcandidates = 0\n  \n  \tfor j in data[3:]:\n  \t\ti = eval(j)\n  \t\tif i%3 == 0:\n  \t\t\tscore = i/3\n  \t\t\tscores.append([score, score, score])\n  \t\telif (i+1)%3 == 0:\n  \t\t\tscore = (i+1)/3\n  \t\t\tscores.append([score-1, score, score])\n  \t\telse: #(i+2)%3 == 0\n  \t\t\tscore = (i+2)/3\n  \t\t\tscores.append([score-1, score-1, score])\n  \n  \tfor score in scores:\n  \t\tif score[2] >= p:\n  \t\t\tn_googlers_with_best_result +=1\n  \t\telif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:\n  \t\t\tcandidates += 1\n  \n  \tn_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)\n  \n  \tout.write(\"Case #%d: %d\n\" % (case+1, n_googlers_with_best_result))\n <CODESPLIT> ", "completion": " 53"}
{"prompt": " \n  def solve(N,S,p,t):\n      if p == 0:\n          return N\n      outright_wins = 0\n      potential_surprises = 0\n      win_cutoff = (p * 3) - 3\n      surprise_cutoff = win_cutoff - 2\n      for score in t:\n          if score == 0:\n              continue\n          elif score > win_cutoff:\n              outright_wins += 1\n          elif score > surprise_cutoff:\n              potential_surprises += 1\n      if potential_surprises < S:\n          return outright_wins + potential_surprises\n      else:\n          return outright_wins + S\n  \n  def parse_case(data_line):\n      bits = data_line.split()\n      N = int(bits[0])\n      S = int(bits[1])\n      p = int(bits[2])\n      t = [int(x) for x in bits[3:]]\n      return N,S,p,t\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                        help=\"read input from FILE\", metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error(\"Must provide a filename.\")\n      input_file = open(options.filename, \"r\")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n      \tcase_number += 1\n      \tdata_args = parse_case(input_file.readline())\n      \tprint \"Case #%d: %d\" % (case_number, solve(*data_args))\n  \n  if __name__ == \"__main__\":\n  \tmain()\n <CODESPLIT> ", "completion": " 51"}
{"prompt": " \n  def solve(icase, case_input):\n      case_output = 'Case #%i: '%icase\n      \n      result = 0\n      raw = [int(x) for x in case_input[0].split()]\n      ts = raw[3:]\n      ct = raw[1]\n      n = raw[2]\n      cc = 0\n      for i in ts:\n          if i > 3*n-3:\n              result += 1\n          elif i > max(3*n-5, 0):\n              cc += 1\n      result += min(cc, ct)\n  \n      case_output += '%d'%result\n      \n      return case_output\n  \n  \n  def main():\n      global use_test_data\n      global test_data\n      global input_file\n      global output_file\n      \n      if use_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for icase in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(icase, input)\n          print rslt\n          if not use_test_data:\n              print >> output_file, rslt\n      \n      if not use_test_data:\n          input_file.close()\n          output_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = \"\"\"4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \"\"\"\n      use_test_data = False\n      \n      test_file = 'B-small-attempt0.in'\n      if not use_test_data and '' != test_file:\n          input_file = open(test_file)\n          output_file = open(test_file + '.out', 'w')\n      \n      main()\n <CODESPLIT> ", "completion": " 5"}
{"prompt": "T = int(raw_input())\n  for t in xrange(T):\n      line = map(int, raw_input().split())\n      N, S, p = line[0:3]\n      a = line[3:]\n      cnt = 0\n      a.sort(reverse=True)\n      for x in a:\n          if (x + 2) / 3 >= p:\n              cnt += 1\n          elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:\n              cnt += 1\n              S -= 1\n          else:\n              break\n      print \"Case #%d: %d\" % (t + 1, cnt)\n <CODESPLIT> ", "completion": " 8"}
{"prompt": "def IsPal(n):\n      S = str(n);\n      return S == S[::-1];\n  \n  \n  def Gen():\n      LIM = 10**14;\n      N = 10**7;\n      LIST = [];\n      for i in range(1, N):\n          if IsPal(i):\n              if IsPal(i*i):\n                  LIST.append(i);\n      return LIST\n  \n  PP = Gen();\n  \n  T = int(raw_input());\n  for q in range(1,T+1):\n      [A,B] = map(int, raw_input().split());    \n      ANS = 0;\n      for i in range(len(PP)):\n          if B >= PP[i]**2 >= A:\n              ANS += 1;\n      \n      print \"Case #%d: %d\" %(q, ANS);\n <CODESPLIT> ", "completion": " 38"}
{"prompt": " \n  def is_palindrome(n):\n      s = str(n)\n      return s == s[::-1] \n  \n  palindromes = [[], [1,2,3,4,5,6,7,8,9], [11,22,33,44,55,66,77,88,99]]\n  all_palindromes = palindromes[1] + palindromes[2]\n  limit = [100]\n  \n  palindromic_squares = []\n  psqtop = 0\n  psqix = 0\n  \n  stdin = sys.stdin\n  for c in xrange(int(stdin.readline())):\n      a,b = map(int, stdin.readline().split())\n  \n      while psqtop < b:\n          while psqix >= len(all_palindromes):\n              ps = []\n              pp = 10 ** (len(palindromes)-1) + 1\n              for i in range(1,10):\n                  for p in palindromes[-2]:\n                      ps.append(i * pp + 10 * p) \n              palindromes.append(ps)\n              all_palindromes.extend(ps)\n  \n          sq = all_palindromes[psqix] * all_palindromes[psqix]\n          if is_palindrome(sq):\n              palindromic_squares.append(sq)\n          psqix  += 1\n          psqtop = sq\n  \n      aix = bisect.bisect_left(palindromic_squares, a)\n      bix = bisect.bisect_right(palindromic_squares, b)\n  \n      print \"Case #%i: %i\" % (c+1, bix-aix) \n <CODESPLIT> ", "completion": " 62"}
{"prompt": " \n  \n  def findbest(score):\n  \tif score == 0: return (0, 0)\n  \n  \tbest = math.ceil(score / 3)\n  \tbestsurp = round(score / 3) + 1\n  \n  \treturn (best, bestsurp)\n  \t\n  sys.stdin.readline()\n  \n  casenum = 0\n  for line in sys.stdin:\n  \tcasenum += 1\n  \n  \tdata = line.strip().split(' ')\n  \tmaxsurprising = int(data[1])\n  \tp = int(data[2])\n  \tscores = data[3:]\n  \tmaxgooglers = 0\n  \n  \tfor s in scores:\n  \t\t(best, bestsurp) = findbest(int(s))\n  \t\tif best >= p:\n  \t\t\tmaxgooglers += 1\n  \t\telse:\n  \t\t\tif bestsurp >= p and maxsurprising > 0:\n  \t\t\t\tmaxgooglers += 1\n  \t\t\t\tmaxsurprising -= 1\n  \n  \tprint(\"Case #%d: %d\" % (casenum, maxgooglers))\n <CODESPLIT> ", "completion": " 45"}
{"prompt": " \n  \n  def best(total):\n      \"\"\"Return the best possible score for the given `total`.  Assume\n      the total is computed by summing exactly three scores (each in the\n      interval of 0 to 10 inclusive) and no score can be 2 points apart\n      \n      Arguments:\n      - `total`:\n      \"\"\"\n      m = total % 3\n      if m == 2:\n          b = total // 3 + 2\n      else:\n          b = total // 3 + 1\n      if b > 10:\n          b = 10\n      return b\n  \n  def best_non_surprising(total):\n      \"\"\"Return the best possible score for the given `total`, but\n      assume that there should be no more than 1 point difference\n      between the scores.\n  \n      Arguments:\n      - `total`:\n      \"\"\"\n      if total % 3 == 0:\n          return total // 3\n      else:\n          return total // 3 + 1\n  \n  def max_num_gte_p(totals, S, p):\n      \"\"\"Return the maximum number of Googlers that could have had a\n      best result of at least p.\n      \n      Arguments:\n      - `totals`:\n      - `S`: number of surprising triplets of scores\n      - `p`:\n      \"\"\"\n      res = 0\n      for total in totals:\n          if total == 0:\n              if p == 0:\n                  res += 1\n              continue\n  \n          if best_non_surprising(total) >= p:\n              res += 1\n          elif S > 0 and best(total) >= p:\n              res += 1\n              S -= 1\n  \n      return res\n  \n  def main():\n      with open(sys.argv[1], 'r') as f:\n          f.readline()            # skip T\n  \n          n = 0\n          for line in f:\n              n += 1\n  \n              line = [int(s) for s in line.split()]\n              N = line[0]\n              S = line[1]\n              p = line[2]\n              totals = line[3:]\n  \n              print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))\n  \n  if __name__ == '__main__':\n      main()\n <CODESPLIT> ", "completion": " 12"}
{"prompt": " \n  class Test(unittest.TestCase):\n  \tdef test_1(self):\n  \t\tself.assertEqual(main(1, 4), 2)\n  \tdef test_2(self):\n  \t\tself.assertEqual(main(10, 120), 0)\n  \tdef test_3(self):\n  \t\tself.assertEqual(main(100, 100000000000000), 2)\n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def main(M, N):\n  \tfns = 0\n  \tnum = M\n  \tmaior = math.sqrt(N)\n  \tint_maior = 0\n  \t\n  \tif maior.is_integer():\n  \t\tint_maior = int(maior) - 1\n  \t\tif fair(N):\n  \t\t\tif fair(int(maior)):\n  \t\t\t\tfns += 1\n  \telse:\n  \t\tint_maior = int(maior)\n  \t\t\n  \twhile int_maior >= 1:\n  \t\tif fair(int_maior):\n  \t\t\tquadrado = int_maior * int_maior\n  \t\t\tif quadrado >= M:\n  \t\t\t\tif fair(quadrado):\n  \t\t\t\t\tfns += 1\n  \t\tint_maior -= 1\n  \treturn fns\n  \n  def main2(M, N):\n  \tfns = 0\n  \tnum = M\n  \twhile num <= N:\n  \t\tresult = raiz(num)\n  \t\tif result:\n  \t\t\tif fair(num):\n  \t\t\t\n  \t\t\t\tif fair(result):\n  \t\t\t\t\tfns += 1\n  \t\tnum += 1\n  \treturn fns\n  \t\n  def fair(num):\n  \treturn str(num) == str(num)[::-1]\n  \t\n  def raiz(num):\n  \tresult = math.sqrt(num)\n  \tif result.is_integer():\n  \t\treturn int(result)\n  \telse:\n  \t\treturn False\n  \t\n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tN,M = [int(x) for x in sys.stdin.readline().split(' ')]\t\n  \t\tprint \"Case #%d: %d\" % (i + 1, main(N,M))\n <CODESPLIT> ", "completion": " 57"}
